URL: http://www.cs.brown.edu/people/vr/thesis.ps
Refering-URL: http://www.cs.brown.edu/people/vr/
Root-URL: http://www.cs.brown.edu
Title: An Optimizing Compiler for CLP(&lt;  
Author: Lin Viswanath Ramachandran B. Sc. M., Brown 
Degree: Indian Institute of Technology, Bombay, 1991  1993 Thesis Submitted in partial fulfillment of the requirements for the Degree of Doctor of Philosophy in the  
Date: May 1998  
Affiliation: Tech.,  University,  Department of Computer Science at Brown University.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi and J.D. Ullman. </author> <booktitle> Compilers Principles Techniques and Tools, </booktitle> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The only difference is that signs are replaced by intervals in the abstract constraints. We limit ourselves to some examples to explain these concepts in the domain LInt. Example 32 The abstract constraint (1; +1) = <ref> [1; 1] </ref>P + [1; 1]R represents both the constraint 3 = P + R and 3 = P + R but not the constraint 3 = 2P + 3R. Example 33 The abstract constraint with multiplicity h (1; +1) = [1; 1]P+[1; 1]R; One i represents only multisets of size 1, <p> The only difference is that signs are replaced by intervals in the abstract constraints. We limit ourselves to some examples to explain these concepts in the domain LInt. Example 32 The abstract constraint (1; +1) = <ref> [1; 1] </ref>P + [1; 1]R represents both the constraint 3 = P + R and 3 = P + R but not the constraint 3 = 2P + 3R. Example 33 The abstract constraint with multiplicity h (1; +1) = [1; 1]P+[1; 1]R; One i represents only multisets of size 1, e.g., f3 = <p> Example 32 The abstract constraint (1; +1) = <ref> [1; 1] </ref>P + [1; 1]R represents both the constraint 3 = P + R and 3 = P + R but not the constraint 3 = 2P + 3R. Example 33 The abstract constraint with multiplicity h (1; +1) = [1; 1]P+[1; 1]R; One i represents only multisets of size 1, e.g., f3 = P+Rg. h 0 [1:01; +1)P+(1; 1]R; Any i represents multisets of any size, e.g., ;, f0 3P Rg and f0 3P R; 0 2P 3Rg. <p> Example 33 The abstract constraint with multiplicity h (1; +1) = [1; 1]P+[1; 1]R; One i represents only multisets of size 1, e.g., f3 = P+Rg. h 0 <ref> [1:01; +1)P+(1; 1] </ref>R; Any i represents multisets of any size, e.g., ;, f0 3P Rg and f0 3P R; 0 2P 3Rg. Example 34 The abstract store fi = fh (1; +1) = [1; 1]P + [1; 1]R; One i ; h 0 [1:01; +1)P+(1; 1]R; Any ig represents constraint stores <p> <ref> [1; 1] </ref>P+[1; 1]R; One i represents only multisets of size 1, e.g., f3 = P+Rg. h 0 [1:01; +1)P+(1; 1]R; Any i represents multisets of any size, e.g., ;, f0 3P Rg and f0 3P R; 0 2P 3Rg. Example 34 The abstract store fi = fh (1; +1) = [1; 1]P + [1; 1]R; One i ; h 0 [1:01; +1)P+(1; 1]R; Any ig represents constraint stores with at least one constraint, and their equivalence classes. <p> Example 34 The abstract store fi = fh (1; +1) = <ref> [1; 1] </ref>P + [1; 1]R; One i ; h 0 [1:01; +1)P+(1; 1]R; Any ig represents constraint stores with at least one constraint, and their equivalence classes. For example f3 = P + Rg 2 Cc i (fi) and f3 = P + R ; 0 2P 3Rg 2 Cc i (fi). <p> 1, e.g., f3 = P+Rg. h 0 <ref> [1:01; +1)P+(1; 1] </ref>R; Any i represents multisets of any size, e.g., ;, f0 3P Rg and f0 3P R; 0 2P 3Rg. Example 34 The abstract store fi = fh (1; +1) = [1; 1]P + [1; 1]R; One i ; h 0 [1:01; +1)P+(1; 1]R; Any ig represents constraint stores with at least one constraint, and their equivalence classes. For example f3 = P + Rg 2 Cc i (fi) and f3 = P + R ; 0 2P 3Rg 2 Cc i (fi). <p> Consider the mortgage example mg/4. After six iterations, the fixpoint algorithm to compute the output of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; <p> Consider the mortgage example mg/4. After six iterations, the fixpoint algorithm to compute the output of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h <p> Consider the mortgage example mg/4. After six iterations, the fixpoint algorithm to compute the output of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; <p> fixpoint algorithm to compute the output of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + <ref> [10000; 1] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output <p> of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; <p> produced the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; <p> a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; <p> of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] <p> h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + <ref> [201; 1] </ref>R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; <p> = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + <ref> [201; 1] </ref>R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; <p> 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P <p> [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; <p> Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig <p> Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig We observe that there is a very close correspondence between the abstract constraints of the two stores. <p> iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig We observe that there is a very close correspondence between the abstract constraints of the two stores. <p> as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig We observe that there is a very close correspondence between the abstract constraints of the two stores. <p> output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig We observe that there is a very close correspondence between the abstract constraints of the two stores. <p> Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + <ref> [30301; 1] </ref>R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig We observe that there is a very close correspondence between the abstract constraints of the two stores. In particular, if the intervals in the constraints are replaced by their corresponding signs, then the two stores are identical. <p> 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + <ref> [30301; 1] </ref>R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig We observe that there is a very close correspondence between the abstract constraints of the two stores. In particular, if the intervals in the constraints are replaced by their corresponding signs, then the two stores are identical. <p> The basic idea of the widening is to take a pair of similar constraints from the two stores, see in what manner an interval coefficient in that constraint is changing, and accelerate that change. We illustrate this by considering the pair of similar constraints h [3; 5] = <ref> [1; 1] </ref>T; Onei and h [3; 6] = [1; 1]T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. <p> We illustrate this by considering the pair of similar constraints h [3; 5] = <ref> [1; 1] </ref>T; Onei and h [3; 6] = [1; 1]T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. A constraint that approximates both these constraints and accelerates the direction in which the constraint is growing can be given by h [3; +1) = [1; 1]T; Onei. <p> The change in the constraint is that the right endpoint of the constant term is increasing. A constraint that approximates both these constraints and accelerates the direction in which the constraint is growing can be given by h <ref> [3; +1) = [1; 1] </ref>T; Onei. This is the result of widening the pair of similar constraints. <p> Onei and h [3; 6] = <ref> [1; 1] </ref>T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. A constraint that approximates both these constraints and accelerates the direction in which the constraint is growing can be given by h [3; +1) = [1; 1]T; Onei. This is the result of widening the pair of similar constraints. This widening can be performed on other pairs of similar constraints as well, giving the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; <p> h [3; +1) = <ref> [1; 1] </ref>T; Onei. This is the result of widening the pair of similar constraints. This widening can be performed on other pairs of similar constraints as well, giving the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; <p> This is the result of widening the pair of similar constraints. This widening can be performed on other pairs of similar constraints as well, giving the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h <p> This widening can be performed on other pairs of similar constraints as well, giving the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; +1) = [1; 1] </ref>T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P <p> This widening can be performed on other pairs of similar constraints as well, giving the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; <p> the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig The widening for constraint stores is therefore applied only on stores that are the same (modulo replacement of <p> abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig The widening for constraint stores is therefore applied only on stores that are the same (modulo replacement of intervals by signs) <p> of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig The widening for constraint stores is therefore applied only on stores that are the same (modulo replacement of intervals by signs) and it consists of widening the <p> fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig The widening for constraint stores is therefore applied only on stores that are the same (modulo replacement of intervals by signs) and it consists of widening the intervals of similar <p> [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] <ref> [1:01; +1)P + (1; 1] </ref>R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig The widening for constraint stores is therefore applied only on stores that are the same (modulo replacement of intervals by signs) and it consists of widening the intervals of similar constraints in those stores. 4.3.2 Formal <p> h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] <ref> [1:01; +1)P + (1; 1] </ref>R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig The widening for constraint stores is therefore applied only on stores that are the same (modulo replacement of intervals by signs) and it consists of widening the intervals of similar constraints in those stores. 4.3.2 Formal Presentation We now formally present the widening operator for <p> First we show the computation of the goal independent (or online) output. Example 35 [Computation of LInt Output Description for mg/4] The abstract substi tution describing the output of the first clause is ffh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; <p> First we show the computation of the goal independent (or online) output. Example 35 [Computation of LInt Output Description for mg/4] The abstract substi tution describing the output of the first clause is ffh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; <p> First we show the computation of the goal independent (or online) output. Example 35 [Computation of LInt Output Description for mg/4] The abstract substi tution describing the output of the first clause is ffh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; <p> The abstract substi tution describing the output of the first clause is ffh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) <p> output of the first clause is ffh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; <p> <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; <p> h [0; 0] = <ref> [1; 1] </ref>P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; <p> <ref> [1; 1] </ref>P + [1; 1]B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P <p> <ref> [1; 1] </ref>B; Oneigg The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R <p> The abstract substitution describing the constraint store just before the recursive call in the second clause is ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; <p> h [0; 0] = [1:01; 1:01]P + <ref> [1; 1] </ref>R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this <p> + <ref> [1; 1] </ref>R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the <p> = <ref> [1; 1] </ref>T + [1; 1]T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause <p> + <ref> [1; 1] </ref>T1; Oneigg 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] <p> 106 Extending this with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; <p> with the denormalized output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] <p> output of the recursive call (when the recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; <p> recursive call returns the previous output) gives the abstract substitution ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; <p> the abstract substitution ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + <p> ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + <p> Onei; h <ref> [1; 1] </ref> = [1; 1]T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output <p> = <ref> [1; 1] </ref>T + [1; 1]T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. <p> + <ref> [1; 1] </ref>T1; Onei; h [0; 0] = [1; 1]T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; <p> 0] = <ref> [1; 1] </ref>T1; Onei; h [0; 0] = [1; 1]P1 + [1; 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = [1; 1]T; Onei; h <p> 1]P1 + <ref> [1; 1] </ref>B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh <p> 1]B; Oneigg Restricting this to the head variables gives the following abstract substitution as the output of the second clause ffh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; <p> h [0; 0] <ref> [1; 1] </ref>P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the <p> [0; 0] = [1:01; 1:01]P + <ref> [1; 1] </ref>R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores <p> [1:01; 1:01]P + <ref> [1; 1] </ref>R + [1; 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are <p> 1]B; Oneigg The widening of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are no stores in the old output that <p> of this with the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are no stores in the old output that have the same shape <p> the previously computed output of the first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are no stores in the old output that have the same shape as a store <p> first clause gives the following abstract substitution as the updated output of the predicate mg. f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are no stores in the old output that have the same shape as a store in the new output. <p> output of the predicate mg. f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are no stores in the old output that have the same shape as a store in the new output. The process can be iterated with the updated output of mg. <p> predicate mg. f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig g In this case, the widening is just the union of multistores because there are no stores in the old output that have the same shape as a store in the new output. The process can be iterated with the updated output of mg. <p> The process can be iterated with the updated output of mg. After a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; <p> The process can be iterated with the updated output of mg. After a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; <p> The process can be iterated with the updated output of mg. After a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; <p> The process can be iterated with the updated output of mg. After a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; <p> After a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P <p> After a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R <p> a few steps, the following multistore emerges as the output for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; <p> for mg (ff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] <p> old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + <p> <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; <p> = <ref> [1; 1] </ref>P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] <p> fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = <p> Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + <ref> [100; 1] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + <p> Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] <p> 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + <p> 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] <p> 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + <p> 1]T; Onei; h [0; 0] <ref> [1; 1] </ref>P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; <p> 1]P; Onei; h [2; 3] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h <p> 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; <p> 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + <ref> [10000; 1] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as <p> 201]R + [1; 100]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff <p> 100]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh <p> 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = [1; 1]T; Onei; <p> 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = [1; 1]T; Onei; h [0; 0] <p> h [0; 0] [1; 1]P; Onei; h [3; 5] = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + <ref> [201; 1] </ref>R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; <p> = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + <ref> [201; 1] </ref>R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = <p> [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; <p> Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; <p> 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; <p> h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; <p> 102:01]P + [201; 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P <p> 1]R; Anyig g Using this in the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R <p> the second clause produces the following multistore as a new output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; <p> output for mg (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] <p> (ff new ): fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + <p> <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; <p> = <ref> [1; 1] </ref>P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] <p> fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = <p> Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + <ref> [100; 1] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; <p> Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; <p> 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; <p> 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; <p> 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; <p> 1]T; Onei; h [0; 0] <ref> [1; 1] </ref>P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P <p> 1]P; Onei; h [2; 3] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; <p> 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig <p> <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated <p> <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg <p> <ref> [1; 201] </ref>R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f <p> <ref> [1; 100] </ref>B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] <p> Onei; h [0; 0] [1; 1]P; Onei; h [3; 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + <ref> [30301; 1] </ref>R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; <p> 6] = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + <ref> [30301; 1] </ref>R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = [1; 1]T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; <p> Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; <p> [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; <p> h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; <p> 1]R; Anyig g At this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; <p> this point the widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P <p> widening needs to be applied and produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R <p> produces the following multistore as the updated output of mg (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; <p> (ff new rff old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] <p> old ): f fh [0; 0] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + <p> <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1; 1]P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; <p> = <ref> [1; 1] </ref>P + [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] <p> fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = <p> Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + <ref> [100; 1] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + <p> Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] <p> 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + <p> 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] <p> 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + <p> 1]T; Onei; h [0; 0] <ref> [1; 1] </ref>P; Onei; h [2; 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; <p> 1]P; Onei; h [2; 3] = <ref> [1; 1] </ref>T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h <p> 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; +1) = [1; 1] </ref>T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P <p> 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; <p> 201]R + [1; 100]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig g Iterating the output computation once more produces the same abstract substitution indicating that this abstract multistore is <p> 100]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig g Iterating the output computation once more produces the same abstract substitution indicating that this abstract multistore is the fixpoint of <p> 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] <ref> [1; 201] </ref>R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig g Iterating the output computation once more produces the same abstract substitution indicating that this abstract multistore is the fixpoint of the computation and represents the output <p> 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + <ref> [1; 100] </ref>B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig g Iterating the output computation once more produces the same abstract substitution indicating that this abstract multistore is the fixpoint of the computation and represents the output of the predicate <p> [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] <ref> [1:01; +1)P + (1; 1] </ref>R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig g Iterating the output computation once more produces the same abstract substitution indicating that this abstract multistore is the fixpoint of the computation and represents the output of the predicate mg. 108 We now illustrate the <p> h [3; +1) = [1; 1]T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] <ref> [1:01; +1)P + (1; 1] </ref>R; Onei; h [0; 0] [1:01; +1)P + (1; 1]R; Anyig g Iterating the output computation once more produces the same abstract substitution indicating that this abstract multistore is the fixpoint of the computation and represents the output of the predicate mg. 108 We now illustrate the computation of the input description, when the top level <p> Example 36 [Computation of LInt Input Description for mg/4] The abstract substitution describing a top level query such that P and R are fixed, is given as ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneigg When the second clause is executed with this input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] <p> Example 36 [Computation of LInt Input Description for mg/4] The abstract substitution describing a top level query such that P and R are fixed, is given as ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneigg When the second clause is executed with this input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] <p> P and R are fixed, is given as ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneigg When the second clause is executed with this input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables <p> as ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneigg When the second clause is executed with this input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives <p> Onei; h (1; +1) = <ref> [1; 1] </ref>R; Oneigg When the second clause is executed with this input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; <p> 1]R; Oneigg When the second clause is executed with this input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) <p> input, the abstract substitution for the program point just before the recursive call to mg is ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 <p> substitution for the program point just before the recursive call to mg is ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; <p> point just before the recursive call to mg is ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on <p> the recursive call to mg is ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the <p> to mg is ffh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Onei; h [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution <p> 0] &lt; <ref> [1; 1] </ref>T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; <p> 1]T; Onei; h [0; 0] <ref> [1; 1] </ref>P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; <p> Onei; h [0; 0] = [1:01; 1:01]P + <ref> [1; 1] </ref>R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; <p> + <ref> [1; 1] </ref>R + [1; 1]P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the <p> + <ref> [1; 1] </ref>P1; Onei; h [1; 1] = [1; 1]T + [1; 1]T1; Oneigg When restricted to the variables of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh [1; 1] &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives <p> of the literal mg (P1,T1,R,B), this gives the abstract substitution ffh <ref> [1; 1] </ref> &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h <p> mg (P1,T1,R,B), this gives the abstract substitution ffh <ref> [1; 1] </ref> &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = <p> ffh <ref> [1; 1] </ref> &lt; [1; 1]T1; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; <p> h (1; +1) = <ref> [1; 1] </ref>R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = <p> = <ref> [1; 1] </ref>R; Onei; h (1; +1) = [1; 1]P1 + [1; 1]R; Oneigg l which on normalization gives the following input substitution for the recursive call to mg ffh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; <p> to mg ffh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of <p> 1]T; Onei; h (1; +1) = <ref> [1; 1] </ref>R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of the stores have the same shape. <p> +1) = <ref> [1; 1] </ref>R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of the stores have the same shape. <p> 1]R; Onei; h (1; +1) = <ref> [1; 1] </ref>P + [1; 1]R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of the stores have the same shape. <p> 1]P + <ref> [1; 1] </ref>R; Oneigg The widening of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of the stores have the same shape. <p> of this with the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of the stores have the same shape. The second clause can now be reexecuted with the updated input to continue the process of computing the input description. <p> the previous input gives the following abstract substitution as the updated input to mg f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig g In this case, the widening of the multistores just corresponds to their union because none of the stores have the same shape. The second clause can now be reexecuted with the updated input to continue the process of computing the input description. <p> The second clause can now be reexecuted with the updated input to continue the process of computing the input description. After some 109 stages of the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) <p> After some 109 stages of the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) <p> After some 109 stages of the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h <p> After some 109 stages of the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; <p> After some 109 stages of the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; <p> 109 stages of the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; <p> the computation, the following emerges as the input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; <p> emerges as the input description to mg (ff old ): f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; <p> input description to mg (ff old ): f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; <p> (ff old ): f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; <p> f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; <p> Onei; h (1; +1) = <ref> [1; 1] </ref>R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; <p> 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; <p> [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P <p> [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = <ref> [1; 100] </ref>P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] <p> [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh <ref> [5; 1] </ref> &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h <p> <ref> [1; 1] </ref>R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = <p> [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh <ref> [5; 1] </ref> &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; <p> <ref> [1; 1] </ref>T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g <p> <ref> [1; 1] </ref>T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the <p> = [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input <p> +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the <p> +1) [201; 1]R; Anyi; h (1; +1) = <ref> [1; 100] </ref>P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): <p> Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + <ref> [1; 201] </ref>R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; <p> 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] <ref> [1; 100] </ref>P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h <p> 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + <ref> [1; 201] </ref>R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = <p> 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = <ref> [1; 10000] </ref>P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = <p> [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h <p> h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; <p> 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; <p> 10000]P + [3:0301; 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; <p> 51010:048]R; Oneig g Using this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; <p> this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [2; 1] </ref> &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; <p> input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; <p> clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [2; 1] </ref> &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; <p> the input for the recursive clause gives the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; <p> the following new input (ff new ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; <p> ): f fh <ref> [1; 1] </ref> &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; <p> [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P <p> <ref> [1; 1] </ref>R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] <p> [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh <ref> [6; 1] </ref> &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h <p> <ref> [1; 1] </ref>R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = <p> [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh <ref> [6; 1] </ref> &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; <p> <ref> [1; 1] </ref>T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g <p> <ref> [1; 1] </ref>T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old <p> = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) <p> +1) [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; <p> +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] <ref> [1; 10000] </ref>P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh <p> Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + <ref> [1; 30301] </ref>R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; <p> 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] <ref> [1; 10000] </ref>P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) <p> 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + <ref> [1; 30301] </ref>R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; <p> 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = <ref> [1; 999999:995904] </ref>P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P <p> Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) <p> h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) <p> 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h <p> 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; <p> + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; <p> = [1; 999999:995904]P + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; <p> + [3:0301; 6152014:790656]R; Oneig g The updated input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; <p> g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; <p> input (ff new rff old ) becomes f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; <p> old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; <p> f fh (1; +1) = <ref> [1; 1] </ref>P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; <p> Onei; h (1; +1) = <ref> [1; 1] </ref>R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; <p> 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; <p> [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P <p> [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = <ref> [1; 100] </ref>P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + [1; +1)R; Onei; h [0; 0] <p> <ref> [1; 1] </ref>R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + [1; +1)R; Onei; h [0; 0] [1; +1)P + [1; +1)R; Anyi; h (1; +1) = <p> <ref> [1; 1] </ref>T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + [1; +1)R; Onei; h [0; 0] [1; +1)P + [1; +1)R; Anyi; h (1; +1) = [1; +1)P + [3:0301; +1)R; Oneig g <p> <ref> [1; 1] </ref>T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + [1; +1)R; Onei; h [0; 0] [1; +1)P + [1; +1)R; Anyi; h (1; +1) = [1; +1)P + [3:0301; +1)R; Oneig g This is the fixpoint of the computation <p> = [1; 1]R; Onei; h (1; +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + [1; +1)R; Onei; h [0; 0] [1; +1)P + [1; +1)R; Anyi; h (1; +1) = [1; +1)P + [3:0301; +1)R; Oneig g This is the fixpoint of the computation and represents all the possible inputs <p> +1) <ref> [201; 1] </ref>R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + [1; +1)R; Onei; h [0; 0] [1; +1)P + [1; +1)R; Anyi; h (1; +1) = [1; +1)P + [3:0301; +1)R; Oneig g This is the fixpoint of the computation and represents all the possible inputs to mg when the top level <p> +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] <ref> [1; +1)P + [1; +1)R; Onei; h [0; 0] </ref> [1; +1)P + [1; +1)R; Anyi; h (1; +1) = [1; +1)P + [3:0301; +1)R; Oneig g This is the fixpoint of the computation and represents all the possible inputs to mg when the top level query is such that P and <p> Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; +1)P + <ref> [1; +1)R; Onei; h [0; 0] </ref> [1; +1)P + [1; +1)R; Anyi; h (1; +1) = [1; +1)P + [3:0301; +1)R; Oneig g This is the fixpoint of the computation and represents all the possible inputs to mg when the top level query is such that P and R are fixed. <p> While is satisfiable, Ais sat (fi) is false because the abstract store obtained by projecting all the variables is fh&gt; &lt; 0; Oneig. Moving to the domain LInt, the abstraction of is fi 0 = fh [3; 3] = <ref> [1; 1] </ref>x; Onei; h [2; 2] &lt; [1; 1]x; Oneig. Projecting all the variables gives the abstract store fh [1; 1] &lt; 0; Oneig and so Ais sat (fi 0 ) is true, which represents the concrete operation more accurately. <p> While is satisfiable, Ais sat (fi) is false because the abstract store obtained by projecting all the variables is fh&gt; &lt; 0; Oneig. Moving to the domain LInt, the abstraction of is fi 0 = fh [3; 3] = <ref> [1; 1] </ref>x; Onei; h [2; 2] &lt; [1; 1]x; Oneig. Projecting all the variables gives the abstract store fh [1; 1] &lt; 0; Oneig and so Ais sat (fi 0 ) is true, which represents the concrete operation more accurately. <p> Moving to the domain LInt, the abstraction of is fi 0 = fh [3; 3] = <ref> [1; 1] </ref>x; Onei; h [2; 2] &lt; [1; 1]x; Oneig. Projecting all the variables gives the abstract store fh [1; 1] &lt; 0; Oneig and so Ais sat (fi 0 ) is true, which represents the concrete operation more accurately. <p> All the traditional Prolog optimizations may then be applied to this program. 8.4 Optimization of Imperative Languages Finally, we would like to add some comments about the relation of our work with the traditional compiler optimizations for imperative languages <ref> [1] </ref>. Dead code elimination in imperative languages is the counterpart to constraint removal in CLP languages.
Reference: [2] <author> R. Barbuti, R. Giacobazzi and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [2; 3] </ref> = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <p> [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [2; 3] </ref> = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <p> [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [2; 3] </ref> = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <p> this as the input to the second clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [2; 1] </ref> &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; <p> clause and recomputing the input for the recursive clause gives the following new input (ff new ): f fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [2; 1] </ref> &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh [6; 1] &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; <p> While is satisfiable, Ais sat (fi) is false because the abstract store obtained by projecting all the variables is fh&gt; &lt; 0; Oneig. Moving to the domain LInt, the abstraction of is fi 0 = fh [3; 3] = [1; 1]x; Onei; h <ref> [2; 2] </ref> &lt; [1; 1]x; Oneig. Projecting all the variables gives the abstract store fh [1; 1] &lt; 0; Oneig and so Ais sat (fi 0 ) is true, which represents the concrete operation more accurately. <p> Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks <ref> [2, 5, 4, 32, 33, 38] </ref> and algorithms [5, 7, 29, 25, 41]. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [3] <author> C. Braem, B. Le Charlier, S. Modart, and P. Van Hentenryck. </author> <title> Cardinality Analysis of Prolog. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 457-471, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: ! 2 &lt; is defined as Cc (0) = f0g; Cc () = f c j c 2 &lt; ^ c &gt; 0g; 1 Using multisets instead of sets simplifies a number of technical details in the proofs of our results. 2 This was motivated by previous work on sequences <ref> [28, 3] </ref> which separates properties of the elements of the sequences from properties of the sequence. 52 From the definition, it is easy to see that the concretization function is monotone, i.e. s 1 v s 2 ) Cc (s 1 ) Cc (s 2 ): Definition 3 [Operators] An operator <p> Consider the mortgage example mg/4. After six iterations, the fixpoint algorithm to compute the output of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 5] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P <p> + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 6] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + <p> The basic idea of the widening is to take a pair of similar constraints from the two stores, see in what manner an interval coefficient in that constraint is changing, and accelerate that change. We illustrate this by considering the pair of similar constraints h <ref> [3; 5] </ref> = [1; 1]T; Onei and h [3; 6] = [1; 1]T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. <p> We illustrate this by considering the pair of similar constraints h [3; 5] = [1; 1]T; Onei and h <ref> [3; 6] </ref> = [1; 1]T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. A constraint that approximates both these constraints and accelerates the direction in which the constraint is growing can be given by h [3; +1) = [1; 1]T; Onei. <p> The change in the constraint is that the right endpoint of the constant term is increasing. A constraint that approximates both these constraints and accelerates the direction in which the constraint is growing can be given by h <ref> [3; +1) = [1; 1] </ref>T; Onei. This is the result of widening the pair of similar constraints. <p> This widening can be performed on other pairs of similar constraints as well, giving the following widened abstract store after the seventh iteration of the 101 fixpoint algorithm. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; +1) = [1; 1] </ref>T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P <p> [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [2; 3] </ref> = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <p> 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 5] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P <p> [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [2; 3] </ref> = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <p> 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 6] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + <p> [1; 1]B; Oneig; fh [0; 0] &lt; [1; 1]T; Onei; h [1; 1] = [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h [0; 0] = [1:01; 1:01]P + [1; 1]R + [1; 1]B; Oneig fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [2; 3] </ref> = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <p> 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; +1) = [1; 1] </ref>T; Onei; h [0; 0] = [1:030301; +1)P + (1; 3:0301]R + (1; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; +1)P + (1; 1]R; Onei; h [0; 0] [1:01; +1)P <p> emerges as the input description to mg (ff old ): f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; <p> (ff old ): f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh [5; 1] &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; <p> g The updated input (ff new rff old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; <p> old ) becomes f fh (1; +1) = [1; 1]P; Onei; h (1; +1) = [1; 1]R; Oneig; fh [1; 1] &lt; [1; 1]T; Onei; h (1; +1) = [1; 1]R; Onei; h (1; +1) = [1; 1]P + [1; 1]R; Oneig fh <ref> [3; 1] </ref> &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh (1; 1] &lt; [1; 1]T; Onei; h (1; 1] &lt; [1; 1]T; Anyi; h (1; <p> While is satisfiable, Ais sat (fi) is false because the abstract store obtained by projecting all the variables is fh&gt; &lt; 0; Oneig. Moving to the domain LInt, the abstraction of is fi 0 = fh <ref> [3; 3] </ref> = [1; 1]x; Onei; h [2; 2] &lt; [1; 1]x; Oneig. Projecting all the variables gives the abstract store fh [1; 1] &lt; 0; Oneig and so Ais sat (fi 0 ) is true, which represents the concrete operation more accurately.
Reference: [4] <author> M. Bruynooghe, G. Janssens, A. Callebaut and B. Demoen. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proc. 1987 Symp. on Logic Programming, </booktitle> <pages> 192-204, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: It is not a difficult matter to transform any given CLP (&lt; Lin ) program into an equivalent normalized program by simple rewriting rules. The use of normalized programs, first proposed for logic programs in <ref> [4] </ref>, simplifies the semantics. 2.2.2 Concrete Objects The concrete objects manipulated by our concrete semantics are linear constraints and multisets of linear constraints. Consider a set of variables D = fx 1 ; : : : ; x n g. <p> Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks <ref> [2, 5, 4, 32, 33, 38] </ref> and algorithms [5, 7, 29, 25, 41]. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [5] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(2) </volume> <pages> 91-124, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Consider the mortgage example mg/4. After six iterations, the fixpoint algorithm to compute the output of mg has produced the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 5] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P <p> The basic idea of the widening is to take a pair of similar constraints from the two stores, see in what manner an interval coefficient in that constraint is changing, and accelerate that change. We illustrate this by considering the pair of similar constraints h <ref> [3; 5] </ref> = [1; 1]T; Onei and h [3; 6] = [1; 1]T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. <p> 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 5] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 10510:100480]P + [51010:048; 3:0301]R + [10000; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P <p> [1; 1]P + [1; 1]R; Oneig fh [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh <ref> [5; 1] </ref> &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h <p> [3; 1] &lt; [1; 1]T; Onei; h [3; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 100]P + [2:01; 303:01]R; Oneig fh <ref> [5; 1] </ref> &lt; [1; 1]T; Onei; h [5; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 100]P + [1; 201]R; Onei; h [0; 0] [1; 100]P + [1; 201]R; Anyi; h (1; +1) = [1; 10000]P + [3:0301; <p> Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks <ref> [2, 5, 4, 32, 33, 38] </ref> and algorithms [5, 7, 29, 25, 41]. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37]. <p> Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks [2, 5, 4, 32, 33, 38] and algorithms <ref> [5, 7, 29, 25, 41] </ref>. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [6] <author> W. Buttner and H. Simonis. </author> <title> Embedding Boolean Expressions into Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [22, 47, 8]), integers (e.g., [46]), Booleans (e.g., <ref> [6, 8] </ref>), and nonlinear real constraints (e.g., [42]). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain. These features make CLP languages especially suitable for expressing combinatorial search problems. <p> + [1; 100]B; Anyi; h [0; 0] [1:01; 102:01]P + [201; 1]R; Onei; h [0; 0] [1:01; 102:01]P + [201; 1]R; Anyig The seventh iteration produces the following abstract store as a possible output of mg. fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 6] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + <p> We illustrate this by considering the pair of similar constraints h [3; 5] = [1; 1]T; Onei and h <ref> [3; 6] </ref> = [1; 1]T; Onei. The change in the constraint is that the right endpoint of the constant term is increasing. A constraint that approximates both these constraints and accelerates the direction in which the constraint is growing can be given by h [3; +1) = [1; 1]T; Onei. <p> 3] = [1; 1]T; Onei; h [0; 0] = [1:0201; 103:0301]P + [303:01; 2:01]R + [100; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyig; fh [0; 0] &lt; [1; 1]T; Onei; h [0; 0] [1; 1]P; Onei; h <ref> [3; 6] </ref> = [1; 1]T; Onei; h [0; 0] = [1:030301; 1061520:146432]P + [6152015:314944; 3:0301]R +[999999:995904; 1]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Onei; h [0; 0] [1; 201]R + [1; 100]B; Anyi; h [0; 0] [1:01; 10303:01]P + [30301; 1]R; Onei; h [0; 0] [1:01; 10303:01]P + <p> [1; 1]P + [1; 1]R; Oneig fh [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh <ref> [6; 1] </ref> &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h <p> [2; 1] &lt; [1; 1]T; Onei; h [2; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [1; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h (1; +1) = [1; 1]P + [2:01; 2:01]R; Oneig fh <ref> [6; 1] </ref> &lt; [1; 1]T; Onei; h [6; 1] &lt; [1; 1]T; Anyi; h (1; +1) = [1; 1]R; Onei; h (1; +1) [201; 1]R; Onei; h (1; +1) [201; 1]R; Anyi; h [0; 0] [1; 10000]P + [1; 30301]R; Onei; h [0; 0] [1; 10000]P + [1; 30301]R; Anyi; h (1; +1) = [1; 999999:995904]P + [3:0301;
Reference: [7] <author> C. Codognet, P. Codognet and J.M. Corsini. </author> <title> Abstract Interpretation of Concurrent Logic Languages. </title> <booktitle> in Proc. North American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks [2, 5, 4, 32, 33, 38] and algorithms <ref> [5, 7, 29, 25, 41] </ref>. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [8] <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> Commun. ACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1990. </year>
Reference-contexts: Introduction Constraint logic programming (CLP) [21] is a generalization of logic programming where unification is replaced by constraint solving over a suitable domain, as the basic operation of the language. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., <ref> [22, 47, 8] </ref>), integers (e.g., [46]), Booleans (e.g., [6, 8]), and nonlinear real constraints (e.g., [42]). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain. <p> Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [22, 47, 8]), integers (e.g., [46]), Booleans (e.g., <ref> [6, 8] </ref>), and nonlinear real constraints (e.g., [42]). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain. These features make CLP languages especially suitable for expressing combinatorial search problems. <p> A constraint is a relation t 1 ffi t 2 with ffi 2 f&gt;; ; =; 6=; ; &lt;g: CLP (&lt; Lin ) is similar to the numerical part of Prolog III <ref> [8] </ref> and is closely related to CLP (&lt;) [22]. <p> Periodic Sequence The second program <ref> [8] </ref> is a mathematical problem which highlights many of the functionalities of CLP (&lt; Lin ).
Reference: [9] <author> A. Cortesi, B. Le Charlier, and P. Van Hentenryck. </author> <title> Combinations of Abstract Domains for Logic Programming. </title> <booktitle> In 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year> <month> 183 </month>
Reference-contexts: However, the current LSign analysis is unable to handle structures (or lists), and therefore is unable to perform the above reordering. Unfortunately, it is not obvious or trivial to instantiate the generic pattern pattern domain Pat (&lt;) <ref> [9] </ref> with the domains handling linear constraints. This is because Pat (&lt;) may lose information about functors.
Reference: [10] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <publisher> In New York ACM Press, </publisher> <editor> editor, </editor> <booktitle> Conf. Record of Fourth ACM Symposium on Programming Languages (POPL'77), </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: The optimizations are global in nature, and require information about the macro properties of the program in order to be automated successfully. The compiler (40,000 lines of C, including about 10,000 lines only for the optimizations), uses abstract interpretation <ref> [10] </ref> to collect the information necessary to perform the optimizations safely. <p> It uses abstract interpretation <ref> [10] </ref>, a systematic method to develop static analyses. In particular, the compiler uses algorithms based on the generic abstract interpretation system GAIA [29], instantiated to the following domains: Prop to determine fixed variables and LSign (or LInt) to determine unconstrained variables, redundant constraints and satisfiable constraint stores. <p> This section contains an informal review of these components. 1.6.1 The Abstract Interpretation Framework The abstract interpretation framework used by the compiler is a natural extension to CLP of the logic programming framework in [29]. It follows the traditional approach to abstract interpretation <ref> [10] </ref>. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. The concrete semantics is a collecting fixpoint semantics which captures the top-down execution of constraint logic programs using a left-to-right computation rule and which ignores the clause selection rule. <p> The chapter is organized in the following way. Section 2.1 introduces the basic ideas of abstract interpretation by means of an example. Section 2.2 presents the concrete semantics of CLP, while section 2.3 presents the abstract semantics of CLP. 2.1 Introduction Abstract interpretation <ref> [10] </ref> is a general methodology to design static analyses of programs in a systematic way. The basic intuition behind abstract interpretation is to infer some properties of a program, not by executing it on its traditional computation domain (say integers), but rather on an abstract domain (say signs of integers). <p> However, as 2 LInt is an infinite domain, it becomes necessary to introduce a widening operator 1 . The use of widening operators was proposed in <ref> [10] </ref> and has been previously used in domains such as type graphs for Prolog [50, 51]. The design of a widening operator is both experimental and theoretical in nature.
Reference: [11] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Conf. Record of Fifth ACM Symposium on Principles of Programming Languages (POPL'78), </booktitle> <year> 1978. </year>
Reference-contexts: This because the redundancy algorithms for the domains merely use the equations of the store to simplify the constraint and then check for trivial satisfiability. The domains cannot deduce redundancy caused by complex interactions of constraints. Utilizing a more sophisticated domain such as the domain Hull of <ref> [11] </ref> would improve the accuracy of redundancy removal. The addition of structures and improved redundancy removal would enable the analysis of more real-life examples, including larger programs. While the present examples are not trivial, they are all short programs.
Reference: [12] <author> S. Debray. </author> <title> Unfold/Fold Transformations and Loop Optimizations of Logic Programs. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI-88), </booktitle> <pages> pages 297-307, </pages> <address> Atlanta, </address> <year> 1988. </year>
Reference-contexts: It is essentially a Prolog program enhanced with a rational arithmetic component. As a consequence, traditional Prolog transformations and optimizations can now be applied. For instance, in our running example, the techniques of <ref> [12] </ref> can be used to transform our final program into a tail-recursive program. Similarly, efficient instructions can be generated for the tests and assignments [23]. <p> Papers by Van Roy [53] and Taylor [45] give a good idea of the speedups that can be obtained for Prolog programs through sophisticated global analyses. Debray <ref> [12] </ref> proposes a number of loop optimizations for Prolog that are the equivalent of classic loop optimizations in imperative languages. The paper uses "fold/unfold" transformations to remove recursion, fuse loops and move code out of loops.
Reference: [13] <author> V. Dumortier, G. Janssens, M. Bruynooghe and M. Codish. </author> <title> Freeness Analysis in the Presence of Numerical Constraints. </title> <booktitle> In Tenth International Conference on Logic Programming (ICLP-93), </booktitle> <pages> 100-115, </pages> <publisher> MIT Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains <ref> [13, 14, 37] </ref>. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of [26, 27]).
Reference: [14] <author> V. Dumortier and G. Janssens. </author> <title> Towards a Practical Full Mode Inference System for CLP(H,N). </title> <booktitle> In Eleventh International Conference on Logic Programming (ICLP-94), </booktitle> <address> Santa Marguerita Ligure, Italy, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains <ref> [13, 14, 37] </ref>. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of [26, 27]).
Reference: [15] <author> G. File and F. Ranzato. </author> <title> Improving abstract interpretations by systematic lifting to the powerset. </title> <booktitle> In Eleventh International Conference on Logic Programming (ICLP-94), </booktitle> <address> Santa Margherita Ligure, Italy, June 1994. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: In particular, the upper bound operation may lose too much information to be of practical use. It may therefore be necessary to move to the power domain 2 LSign in order to get the required accuracy. This is a fairly standard construction in abstract interpretation <ref> [15] </ref>. We briefly introduce the domain 2 LSign and its abstract operations. Definition 19 [Abstract Multistores] An abstract multistore over D is a set ff of abstract stores.
Reference: [16] <author> M.L. Fredman and R.E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> JACM, </journal> <volume> 34 </volume> <pages> 596-615, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Theorem 4 Let fi 1 and fi 2 be two abstract stores. The complexity of checking if fi 1 v fi 2 is not more than O (jfi 1 j 2 2 log jfi 1 jjfi 2 j). Proof: This follows from <ref> [16] </ref> which proved that the weighted bipartite matching prob lem can be solved in time O (jV j 2 log jV j + jV jjEj) i.e O (jfi 1 j 2 2 log jfi 1 jjfi 2 j) and the definition of the matching graph. 2 61 3.3.2 Addition We now
Reference: [17] <author> M. Garcia de la Banda and M. Hermenegildo. </author> <title> A Practical Approach to the Global Analysis of CLP Programs. </title> <booktitle> In Proc. of the International Symposium on Logic Programming (ILPS'93), </booktitle> <address> Vancouver, Canada, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: In general, we continue the presentation only with the domain LSign, for simplicity. 1.6.3 The Domain Prop The domain Prop [35, 52] is an effective domain to compute groundness information for Prolog. It can be extended easily to infer fixed variables in CLP (e.g. <ref> [17] </ref>). Its key idea is to represent the information through a Boolean formula. Informally speaking, a formula x $ y means that, whenever x is fixed, y is fixed and vice-versa. <p> It can also be extended easily to infer fixed variables in CLP (eg. <ref> [17] </ref>). The presentation is basically a review of material already presented in [52], along with the extension of Prop to handle the constraints of CLP (&lt; Lin ). Section 5.1 defines the abstract objects and their concretization. The abstract operations of the domain are presented in Section 5.2. <p> Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects <ref> [17, 35] </ref> and defining various abstract domains [13, 14, 37]. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of [26, 27]).
Reference: [18] <author> N. Heintze and J. Jaffar. </author> <title> An Engine for Logic Program Analysis. </title> <booktitle> In IEEE 7th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year>
Reference: [19] <author> M. Hermenegildo, K. Marriott, G. Puebla, and P. </author> <title> Stuckey Incremental Analysis of Logic Programs. </title> <booktitle> In 1995 International Conference on Logic Programming, </booktitle> <address> Japan, </address> <month> June, </month> <year> 1995. </year> <month> 184 </month>
Reference-contexts: The table indicates that the optimization times are reasonable for our benchmark programs, but that avenues of making the optimizer fast is an open area of research. For example the techniques of <ref> [19] </ref> should be useful here to obtain a faster, incremental implementation. In order to experimentally quantify the penalty paid for using intervals instead of signs, it is also useful to compare the optimization times when LInt is used in the analyzer instead of LSign. <p> Basically the input and intermediate description of every predicate that can be affected by a reordering is recomputed from scratch. Incremental techniques to only recompute relevant abstract stores of an abstract description need to be devised and the techniques of <ref> [19] </ref> should be helpful here to obtain a fast implementation. Also the present compiler performs multiple passes over the input program looking for more opportunities for reordering, as long as the previous pass was able to reorder something.
Reference: [20] <author> J.-L. Imbert, J. Cohen, and M.-D. Weeger. </author> <title> An Algorithm for Linear Constraint Solving: Its Incorporation in a Prolog Meta-Interpreter for CLP. </title> <journal> Journal of Logic Programming 16, </journal> <month> 3/4 (July </month> <year> 1993), </year> <pages> 235-254. </pages>
Reference: [21] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In POPL-87, </booktitle> <address> (Munich, Germany), </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Introduction Constraint logic programming (CLP) <ref> [21] </ref> is a generalization of logic programming where unification is replaced by constraint solving over a suitable domain, as the basic operation of the language. <p> The presentation is kept as informal as possible. Greater details can be found in <ref> [21, 22] </ref>. Syntax CLP (&lt; Lin ) programs have essentially the same syntax as Prolog, the main difference being that CLP (&lt; Lin ) programs also allow linear constraints over real numbers to appear in the bodies of clauses.
Reference: [22] <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R. Yap. </author> <title> The CLP(&lt;) language and system. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: Introduction Constraint logic programming (CLP) [21] is a generalization of logic programming where unification is replaced by constraint solving over a suitable domain, as the basic operation of the language. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., <ref> [22, 47, 8] </ref>), integers (e.g., [46]), Booleans (e.g., [6, 8]), and nonlinear real constraints (e.g., [42]). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain. <p> The presentation is kept as informal as possible. Greater details can be found in <ref> [21, 22] </ref>. Syntax CLP (&lt; Lin ) programs have essentially the same syntax as Prolog, the main difference being that CLP (&lt; Lin ) programs also allow linear constraints over real numbers to appear in the bodies of clauses. <p> A constraint is a relation t 1 ffi t 2 with ffi 2 f&gt;; ; =; 6=; ; &lt;g: CLP (&lt; Lin ) is similar to the numerical part of Prolog III [8] and is closely related to CLP (&lt;) <ref> [22] </ref>. To illustrate the semantics of CLP (&lt; Lin ), we use the simple program depicted in Figure 1.2. 3 p (X,Y) :- Y Z, q (X,Y,Z) :- q (X,Y,Z) :- r (X,Y) :- Declarative Semantics CLP programs can be read both declaratively and operationally. <p> Mortgage The first program is the mortgage example <ref> [22] </ref>, which relates various parameters in a mortgage computation. Figure 1.4 presents a CLP program for the mortgage example. The predicate mg relates the principal (P), number of monthly installments (T), monthly repayment (R) and final balance (B) of a mortgage that has a monthly interest rate of 1%. <p> Design decisions similar in spirit were adopted in CLP (&lt;) <ref> [22] </ref>. More details about the CLP (&lt; Lin ) runtime system are available in [49].
Reference: [23] <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R. Yap. </author> <title> An Abstract Machine for CLP(&lt;). </title> <booktitle> In Proc. ACM-SIGPLAN Conf. on Programming Language Design and Implementation (PLDI-92), </booktitle> <pages> 128-139, </pages> <address> 1992, </address> <publisher> ACM Press. </publisher>
Reference-contexts: As a consequence, traditional Prolog transformations and optimizations can now be applied. For instance, in our running example, the techniques of [12] can be used to transform our final program into a tail-recursive program. Similarly, efficient instructions can be generated for the tests and assignments <ref> [23] </ref>. <p> The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler.
Reference: [24] <author> N. Jorgensen, K. Marriott, and S. Michaylov. </author> <title> Some Global Compile Time Optimizations for CLP(&lt;). </title> <booktitle> In Logic Programming: Proc. 1991 Intl. Symp., </booktitle> <pages> 420-434, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler. <p> The redundancy elimination proposed in that paper is much more general, and is related to the future redundancy optimization of <ref> [24] </ref>. It consists of adding explicit constraint removal instructions to the program, which means that constraints can be added and then removed at a future program point when they have become redundant. <p> Optimizations such as "mutual exclusion" (converting multiple clauses for a predicate into "if then else" statements) and "code motion" (moving recursion invariant expressions out of recursive clauses, similar to loop invariant optimization in imperative languages) are proposed in <ref> [24] </ref>. More specialized optimizations such as linear threading, linear gather and mixed nonlinear gather, that work only on some classes of CLP (&lt;) programs are presented in [39]. 145 8.2 Abstract Interpretation of CLP As mentioned previously, the optimization of CLP programs is achieved by the method of abstract interpretation.
Reference: [25] <author> T. Kanamori and T. Kawamura. </author> <title> Analysing Success Patterns of Logic Programs bu Abstract Hybrid Interpretation. </title> <type> Technical Report, </type> <institution> ICOT, </institution> <year> 1987. </year>
Reference-contexts: Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks [2, 5, 4, 32, 33, 38] and algorithms <ref> [5, 7, 29, 25, 41] </ref>. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [26] <author> A.D. Kelly, A. MacDonald, K. Marriott, H. Sondergaard, P. Stuckey, and R. Yap. </author> <title> An Optimizing Compiler for CLP(&lt;). </title> <booktitle> In First International Conference on Principles and Practice of Constraint Programming (CP'95), </booktitle> <address> Cassis, France, September 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler. <p> However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler. The only exceptions that we are aware of is the system described in <ref> [26] </ref> which performs three optimizations on CLP (&lt;) programs viz. "solver bypass", "dead variable elimination" and "no fail constraint detection" and the system described in [27] which performs the above optimizations, as well as reordering and an optimization called "future redundancy". <p> Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37]. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of <ref> [26, 27] </ref>).
Reference: [27] <author> A.D. Kelly, A.D. Macdonald, K. Marriott, P.J. Stuckey, and R.H C. Yap. </author> <title> Effectiveness of Optimizing Compilation for CLP(R) In Michael J. </title> <editor> Maher (Ed.) </editor> <booktitle> Proc. Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> 37-51, </pages> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The only exceptions that we are aware of is the system described in [26] which performs three optimizations on CLP (&lt;) programs viz. "solver bypass", "dead variable elimination" and "no fail constraint detection" and the system described in <ref> [27] </ref> which performs the above optimizations, as well as reordering and an optimization called "future redundancy". However little information is available as to how the reordering is automated or how the correctness of the reordering optimization is guaranteed in the system of [27]. <p> fail constraint detection" and the system described in <ref> [27] </ref> which performs the above optimizations, as well as reordering and an optimization called "future redundancy". However little information is available as to how the reordering is automated or how the correctness of the reordering optimization is guaranteed in the system of [27]. It is just mentioned that a constraint that contains a "new" variable can be reordered across any number of intervening goals that do not contain that variable. <p> Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37]. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of <ref> [26, 27] </ref>).
Reference: [28] <author> B. Le Charlier, S. Rossi, and P. Van Hentenryck. </author> <title> An Abstract Interpretation Framework Which Accurately Handles Prolog Search Rule and the Cut. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 157-171, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: ! 2 &lt; is defined as Cc (0) = f0g; Cc () = f c j c 2 &lt; ^ c &gt; 0g; 1 Using multisets instead of sets simplifies a number of technical details in the proofs of our results. 2 This was motivated by previous work on sequences <ref> [28, 3] </ref> which separates properties of the elements of the sequences from properties of the sequence. 52 From the definition, it is easy to see that the concretization function is monotone, i.e. s 1 v s 2 ) Cc (s 1 ) Cc (s 2 ): Definition 3 [Operators] An operator
Reference: [29] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 35-101, </pages> <month> January 94. </month>
Reference-contexts: The compiler (40,000 lines of C, including about 10,000 lines only for the optimizations), uses abstract interpretation [10] to collect the information necessary to perform the optimizations safely. In particular, it uses abstract interpretation algorithms derived from the generic abstract interpretation system GAIA, <ref> [29] </ref> instantiated to the following abstract domains: Prop [34, 52] to deduce information on fixed variables, and LSign [37, 43] (or LInt) to deduce unconstrained variables, redundant constraints, and satisfiable constraint stores. 1.5 Overview of the Compiler Optimizations The high-level optimizations performed by our compiler may be viewed as source to <p> It uses abstract interpretation [10], a systematic method to develop static analyses. In particular, the compiler uses algorithms based on the generic abstract interpretation system GAIA <ref> [29] </ref>, instantiated to the following domains: Prop to determine fixed variables and LSign (or LInt) to determine unconstrained variables, redundant constraints and satisfiable constraint stores. <p> This section contains an informal review of these components. 1.6.1 The Abstract Interpretation Framework The abstract interpretation framework used by the compiler is a natural extension to CLP of the logic programming framework in <ref> [29] </ref>. It follows the traditional approach to abstract interpretation [10]. As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. <p> The concrete semantics is similar to that for logic programs in <ref> [29] </ref>, except that it has a component for the intermediate descriptions in addition to the output descriptions. The second step of the methodology is the abstraction of the concrete semantics. <p> The upper bound operation is a consistent abstraction of union of sets of constraint stores. The last step of the methodology consists of computing the least fixpoint or a post-fixpoint of the abstract semantics using an algorithm such as GAIA <ref> [29] </ref> or PLAI [40]. Both of these are top-down algorithms computing a small, but sufficient, subset of least fixpoint (or of a postfixpoint) necessary to answer a user query. From the abstract interpretation results, our optimizing compiler uses basically three pieces of information for each predicate p in the program. <p> Appendix A contains the details of various proofs in the thesis. 32 Chapter 2 Abstract Interpretation In this chapter, we give an introduction to abstract interpretation and review the abstract interpretation framework used in the thesis. The presentation closely follows that of <ref> [29] </ref>. The chapter is organized in the following way. Section 2.1 introduces the basic ideas of abstract interpretation by means of an example. <p> The concrete semantics is a natural extension to CLP of the logic programming semantics presented in <ref> [29] </ref>. It captures the top-down execution of CLP programs using a left-to-right computation rule, and ignores the clause selection rule. The concrete semantics is defined for normalized CLP programs and it manipulates sets of constraint stores, where constraint stores are multisets of linear constraints. <p> The concrete semantics is similar to that for logic programs in <ref> [29] </ref>, except that it has a component for the intermediate descriptions in addition to the output descriptions. We now present the transformation that gives us the concrete semantics. To simplify the presentation, the transformation is presented in two stages. <p> predicate calls in the body, the intermediate substitutions that can occur inside the predicate call (represented by fi 0 3 ) also need to be added to the accumulated intermediate substitution. 2.3 Abstract Semantics The abstract semantics is a natural extension to CLP of the logic programming abstract semantics in <ref> [29] </ref>, and is close to the works of [54] and [33]. The abstract semantics consists of approximating the concrete semantics by replacing a set of constraint stores by a single abstract substitution, i.e. an abstract substitution represents a set of constraint stores. <p> This can be computed in a top-down or a bottom-up fashion. Generic abstract interpretation algorithms from logic programming, such as GAIA <ref> [29] </ref> or PLAI [40] can be adapted for the purpose. From the abstract interpretation results, our optimizing compiler uses basically three abstract substitutions for each predicate p in the program. <p> Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks [2, 5, 4, 32, 33, 38] and algorithms <ref> [5, 7, 29, 25, 41] </ref>. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [30] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year> <month> 185 </month>
Reference-contexts: Section 6.1.1 gives a modified syntax for CLP (&lt; Lin ) programs that we shall use in this chapter to simplify the proofs. Section 6.1.2 presents an operational semantics of the language which is similar to the standard semantics based on SLD-Resolution with a left-to-right selection rule <ref> [30] </ref> but adapted to simplify our proofs. Section 6.1.3 formulates the reordering problem and defines formally which reorderings are admissible, i.e., which reorderings preserve the search space.
Reference: [31] <author> A. MacDonald, P. Stuckey, and R. Yap. </author> <title> Redundancy of Variables in CLP(&lt;). </title> <booktitle> In Logic Programming: Proc. 1993 Intl. Symp., </booktitle> <pages> 75-93, </pages> <address> 1993, </address> <publisher> MIT Press. </publisher>
Reference-contexts: The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler.
Reference: [32] <author> K. Marriott and H. Sondergaard. </author> <title> Notes for a Tutorial on Abstract Interpretation of Logic Programs. </title> <booktitle> In North American Conference on Logic Programming, </booktitle> <address> Cleveland, OH, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks <ref> [2, 5, 4, 32, 33, 38] </ref> and algorithms [5, 7, 29, 25, 41]. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [33] <author> K. Marriott, H. Sondergaard and N. D. Jones. </author> <title> Semantics-based Dataflow Analysis of Logic Programs. </title> <booktitle> In Information Processing-89, </booktitle> <pages> 601-606, </pages> <address> San Francisco, CA, </address> <year> 1989. </year>
Reference-contexts: occur inside the predicate call (represented by fi 0 3 ) also need to be added to the accumulated intermediate substitution. 2.3 Abstract Semantics The abstract semantics is a natural extension to CLP of the logic programming abstract semantics in [29], and is close to the works of [54] and <ref> [33] </ref>. The abstract semantics consists of approximating the concrete semantics by replacing a set of constraint stores by a single abstract substitution, i.e. an abstract substitution represents a set of constraint stores. <p> Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks <ref> [2, 5, 4, 32, 33, 38] </ref> and algorithms [5, 7, 29, 25, 41]. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [34] <author> K. Marriott and H. Sondergaard. </author> <title> Denotational Abstract Interpretation of Logic Programs, </title> <month> June </month> <year> 1990. </year> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 16(3): </volume> <pages> 607-648, </pages> <year> 1994. </year>
Reference-contexts: In particular, it uses abstract interpretation algorithms derived from the generic abstract interpretation system GAIA, [29] instantiated to the following abstract domains: Prop <ref> [34, 52] </ref> to deduce information on fixed variables, and LSign [37, 43] (or LInt) to deduce unconstrained variables, redundant constraints, and satisfiable constraint stores. 1.5 Overview of the Compiler Optimizations The high-level optimizations performed by our compiler may be viewed as source to source transformations, transforming the source program into another
Reference: [35] <author> K. Marriott and H. Sondergaard. </author> <title> Analysis of Constraint Logic Programs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: This enables a more precise analysis of programs in many cases. This will be discussed in greater detail later in the thesis. In general, we continue the presentation only with the domain LSign, for simplicity. 1.6.3 The Domain Prop The domain Prop <ref> [35, 52] </ref> is an effective domain to compute groundness information for Prolog. It can be extended easily to infer fixed variables in CLP (e.g. [17]). Its key idea is to represent the information through a Boolean formula. <p> Similar examples can be constructed for the other abstract applications such as redundancy and conditional satisfiability. 111 Chapter 5 Abstract Domain Prop In this chapter, we present the abstract domain Prop <ref> [35, 52] </ref> which is useful to deduce groundness information in Prolog programs. It can also be extended easily to infer fixed variables in CLP (eg. [17]). <p> Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects <ref> [17, 35] </ref> and defining various abstract domains [13, 14, 37]. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of [26, 27]).
Reference: [36] <author> K. Marriott and P. Stuckey. </author> <title> The 3 R's of optimizing Constraint Logic Programs: Refinement, Removal, and Reordering. </title> <booktitle> In Proc. of the 20th ACM Symposium on Principles of Programming Languages (POPL'93), </booktitle> <address> Charleston, South Carolina, </address> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: Improving the efficiency of CLP programs should encourage more widespread use of CLP in the real world. Our approach to CLP optimization is similar to the 3R's methodology proposed by Marriott and Stuckey <ref> [36] </ref> for CLP (&lt;). The approach which generalizes similar methodologies for logic programming, consists of refining constraints into tests and assignments, removing redundant constraints (i.e., constraints which are implied by the constraint store), and reordering constraints to maximize refinements and removals. <p> The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler. <p> Moreover, there are several subtle issues in guaranteeing that the reordered program has the same search space as the original program, and these deserve to be addressed in rigorous detail. While reordering constraints was first proposed by Marriott and Stuckey <ref> [36, 37] </ref>, this thesis is the first to formalize the notion of admissible reorderings and give an abstract test for the same. Our optimizations are most closely related to the refinement, removal and reordering (3R's) proposed in [36]. <p> While reordering constraints was first proposed by Marriott and Stuckey [36, 37], this thesis is the first to formalize the notion of admissible reorderings and give an abstract test for the same. Our optimizations are most closely related to the refinement, removal and reordering (3R's) proposed in <ref> [36] </ref>. Unlike our approach, the 3R's methodology transforms the original monotonic program (constraint addition only) into a non-monotonic program (constraint addition and removal).
Reference: [37] <author> K. Marriott and P. Stuckey. </author> <title> Approximating Interaction Between Linear Arithmetic Constraints. </title> <booktitle> In Proc. of the International Symposium on Logic Programming (ILPS'94), </booktitle> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In particular, it uses abstract interpretation algorithms derived from the generic abstract interpretation system GAIA, [29] instantiated to the following abstract domains: Prop [34, 52] to deduce information on fixed variables, and LSign <ref> [37, 43] </ref> (or LInt) to deduce unconstrained variables, redundant constraints, and satisfiable constraint stores. 1.5 Overview of the Compiler Optimizations The high-level optimizations performed by our compiler may be viewed as source to source transformations, transforming the source program into another (richer) source program which may contain, not only constraints, but <p> This store is called the intermediate description of p. The fact that these three descriptions suffice to produce good results comes from the nature of the abstract domains. 1.6.2 The Domains LSign and LInt The domain LSign <ref> [37, 43] </ref> is fundamental for the reordering and redundancy phases and for detecting unconstrained variables in the refinement phase. Its two critical ideas are the replacement of coefficients by their signs and the association of multiplicity information with constraints. <p> Note that abstract operations on this domain are non-trivial and use abstract versions of Fourier and Gaussian elimination. The details are presented later in this thesis and also in <ref> [37, 43] </ref>. We now illustrate the domain LSign on our running example. The top-level query, where P and R are fixed, is associated with the abstract store fh&gt; = P; Onei; h&gt; = R; Oneig stating that P and R are fixed to a real number. <p> The final set of results is experimental, indicating that our approach to CLP optimization is promising and can yield substantial speedups in program execution. The Domain LSign The thesis contributes to the theory underlying the abstract domain LSign <ref> [37, 43] </ref>. LSign is an elegant domain for analyzing CLP languages over linear real constraints. Its key conceptual ideas are the abstraction of linear constraints by replacing coefficients by signs and the use of annotations for preserving multiplicity information on the constraints. <p> Its key conceptual ideas are the abstraction of linear constraints by replacing coefficients by signs and the use of annotations for preserving multiplicity information on the constraints. Unfortunately, the original paper on LSign by Marriott and Stuckey <ref> [37] </ref> has a number of theoretical drawbacks. In particular, the ordering of abstract constraint stores given in [37] does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. <p> Unfortunately, the original paper on LSign by Marriott and Stuckey <ref> [37] </ref> has a number of theoretical drawbacks. In particular, the ordering of abstract constraint stores given in [37] does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. This thesis reconsiders the domain LSign, and corrects and completes the results of [37]. Our main contributions in this respect are summarized here. <p> In particular, the ordering of abstract constraint stores given in <ref> [37] </ref> does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. This thesis reconsiders the domain LSign, and corrects and completes the results of [37]. Our main contributions in this respect are summarized here. The thesis gives the definition of ordering and a polynomial time algorithm for its implementation. <p> Section 3.7 presents a complete worked example of the information collected during program analysis with the domain LSign. The chapter concludes with a discussion of the differences between the domain presented here with the original domain LSign as presented by Marriott and Stuckey <ref> [37] </ref>. The proofs of most of the results in this chapter can be found in Appendix A, although we sometimes include a sketch of the proof for the main results in the text. 3.1 Concrete Ob jects We review some of the concepts from the concrete semantics here. <p> We use Var () to denote the set of variables with non-zero coefficients in . We also denote by @ the set fi j x i 2 Dg. 3.2 Abstract Ob jects and Concretization In this section, we introduce the domain LSign. Although the presentation differs considerably from <ref> [37] </ref>, the domain is in fact a slight generalization of the original domain, which clearly separates multiplicity information from the abstract constraints. 2 The presentation is motivated by the fact that it makes it easy to define the concretization function compositionally by identifying the semantic objects clearly. In contrast, [37] uses <p> from <ref> [37] </ref>, the domain is in fact a slight generalization of the original domain, which clearly separates multiplicity information from the abstract constraints. 2 The presentation is motivated by the fact that it makes it easy to define the concretization function compositionally by identifying the semantic objects clearly. In contrast, [37] uses an approach based on an abstraction function and approximation relations. The first key idea is the notion of an abstract constraint which abstracts a concrete constraint by replacing each coefficient by its sign. Our definitions assume D = fx 1 ; : : : ; x n g. <p> Mult is ordered by One v ZeroOrOne v Any: Multiplicities are denoted by the letter , possibly subscripted. 3 <ref> [37] </ref> contains one other multiplicity OneOrMore which is obtained easily in our domain by includ ing one constraint with multiplicity One and one constraint with multiplicity Any. Note also that all inequalities are defined with a multiplicity Any in [37]. 53 We now turn to abstract constraint with multiplicities. <p> Any: Multiplicities are denoted by the letter , possibly subscripted. 3 <ref> [37] </ref> contains one other multiplicity OneOrMore which is obtained easily in our domain by includ ing one constraint with multiplicity One and one constraint with multiplicity Any. Note also that all inequalities are defined with a multiplicity Any in [37]. 53 We now turn to abstract constraint with multiplicities. Recall that elements of CS D are multisets of linear constraints. <p> Figure 3.2 presents the abstract algorithm. The algorithms are close to those in <ref> [37] </ref> but they are simplified thanks to the introduction of operations Csplit and Asplit which avoids much of the tedious case analysis. The algorithms are also more precise. The intuition behind the concrete version is as follows. Cproject nondeterministi-cally chooses a constraint in the store. <p> Contrary to the algorithm in <ref> [37] </ref>, the abstract Gaussian elimination algorithm does not split the &gt; coefficients of the variable being eliminated into 0, and . As shown in Section 3.8, this enables it to be more precise in some cases. Its consistency condition is as follows. <p> The main difference comes from the fact that we avoid combining a constraint with multiplicity One or ZeroOrOne with itself, contrary to the algorithm in <ref> [37] </ref>. This is achieved by testing the multiplicity of the constraint. Lemma 14 [Fourier] Let v 2 @, be a store, and fi be an abstract store. <p> R; Oneig fh &lt; T; Onei; h &lt; T; Anyi; h&gt; = R; Onei; h&gt; R; Onei; h&gt; R; Anyi; h&gt; = P + R; Oneig g by removing the third store which is subsumed by the fourth store. 3.8 Discussion The LSign domain was introduced by Marriott and Stuckey <ref> [37] </ref> as an elegant domain for analyzing constraint logic programming languages over linear real constraints. Its key conceptual idea is the abstraction of linear constraints by replacing coefficients by their signs. Unfortunately, the ordering given in [37], i.e., fi 1 v fi 2 , 8fl 1 2 fi 1 9fl 2 <p> the fourth store. 3.8 Discussion The LSign domain was introduced by Marriott and Stuckey <ref> [37] </ref> as an elegant domain for analyzing constraint logic programming languages over linear real constraints. Its key conceptual idea is the abstraction of linear constraints by replacing coefficients by their signs. Unfortunately, the ordering given in [37], i.e., fi 1 v fi 2 , 8fl 1 2 fi 1 9fl 2 2 fi 2 : fl 1 v fl 2 does not capture the intended meaning, since it would conclude that the set fi 1 = f = x 1 + x 2 ; = x 1 <p> The intended meaning of <ref> [37] </ref> is that fi 1 represents exactly two constraints while fi 2 represents exactly one constraint. We observed this problem when trying to define an upper bound operation for LSign which was not given in [37]. <p> The intended meaning of <ref> [37] </ref> is that fi 1 represents exactly two constraints while fi 2 represents exactly one constraint. We observed this problem when trying to define an upper bound operation for LSign which was not given in [37]. <p> This ordering problem obviously made it impossible to prove the correctness of the abstract operations of LSign. The first purpose of this chapter 6 is to reconsider the domain LSign and to correct and complete the results of <ref> [37] </ref>. <p> The second purpose of this chapter is to present improvements to the projection algorithm. Improving the accuracy of the projection algorithm can be very important in practice. The first improvement is to make abstract Fourier elimination much more precise. In <ref> [37] </ref>, when Fourier eliminating x from a constraint that contains x with coefficient &gt;, that constraint is always combined with itself (as it may represent two concrete constraints with opposite coefficients for x). <p> For example, projecting x from fh&gt; = &gt;x + y; ZeroOrOneig leads to the store fh&gt; = y; ZeroOrOnei; h&gt; = y; Anyig using the algorithm of <ref> [37] </ref>. The first abstract constraint in this store comes from taking the &gt; coefficient of x to be 0, while the second constraint comes from taking the &gt; coefficient of x to be and and combining the two. <p> Our improved algorithm would lead to the store fh&gt; = y; ZeroOrOneig, which can be easily seen to be definitely satisfiable. The second improvement is to make abstract Gauss elimination much more precise. Consider the following example. Using the algorithms of <ref> [37] </ref>, projecting x from fh = x; Onei; h&gt; = &gt;x + y; Oneig involves considering the cases 0, and for the &gt; coefficient of x in the second constraint, leading to fh&gt; = y; ZeroOrOnei; h&gt; = y; Anyig which may or may not be satisfiable. <p> We give abstract algorithms that answer a variety of interesting questions about satisfiability of constraint stores, redundancy of constraints and freeness of variables. While the utilization of LSign for satisfiability analysis had been mentioned earlier <ref> [37] </ref>, there was no detailed presentation of conditional satisfiability. Also, redundancy and freeness analysis are novel applications of the domain, presented for the first time in this chapter. To conclude the chapter, it is instructive to point out a limitation of the domain LSign. <p> However, reordering can take place only if it preserves the same search space which provides guarantees that the reordered program will be at least as efficient (asymptotically) as the original program. In general in the literature (see for example <ref> [37] </ref>), this issue is only discussed informally. <p> The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler. <p> Moreover, there are several subtle issues in guaranteeing that the reordered program has the same search space as the original program, and these deserve to be addressed in rigorous detail. While reordering constraints was first proposed by Marriott and Stuckey <ref> [36, 37] </ref>, this thesis is the first to formalize the notion of admissible reorderings and give an abstract test for the same. Our optimizations are most closely related to the refinement, removal and reordering (3R's) proposed in [36]. <p> Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains <ref> [13, 14, 37] </ref>. Little work has been done on actually integrating domains into optimizing compilers and evaluating the benefits (except for the systems of [26, 27]). <p> The thesis contributes to the theory underlying the abstract domain LSign <ref> [37, 43] </ref>. Unfortunately, the original paper on LSign by Marriott and Stuckey [37] has a number of theoretical drawbacks. In particular, the ordering of abstract constraint stores given in [37] does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. <p> The thesis contributes to the theory underlying the abstract domain LSign [37, 43]. Unfortunately, the original paper on LSign by Marriott and Stuckey <ref> [37] </ref> has a number of theoretical drawbacks. In particular, the ordering of abstract constraint stores given in [37] does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. <p> The thesis contributes to the theory underlying the abstract domain LSign [37, 43]. Unfortunately, the original paper on LSign by Marriott and Stuckey <ref> [37] </ref> has a number of theoretical drawbacks. In particular, the ordering of abstract constraint stores given in [37] does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. This thesis reconsiders the domain LSign, and corrects and completes the results of [37]. The thesis reports the first implementation of the domain LSign. <p> In particular, the ordering of abstract constraint stores given in <ref> [37] </ref> does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign. This thesis reconsiders the domain LSign, and corrects and completes the results of [37]. The thesis reports the first implementation of the domain LSign. The thesis also proposes the domain LInt which is a generalization of LSign, abstracting coefficients by intervals instead of signs. This enables a more accurate analysis of programs in many cases.
Reference: [38] <author> C. Mellish. </author> <title> Abstract Interpretation of Prolog Programs, </title> <address> 181-198, </address> <publisher> Ellis Horwood, </publisher> <address> Chicester, </address> <year> 1987. </year>
Reference-contexts: Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks <ref> [2, 5, 4, 32, 33, 38] </ref> and algorithms [5, 7, 29, 25, 41]. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [39] <author> S. Michaylov and B. Pippin. </author> <title> Optimizing Compilation of Linear Arithmetic in a Class of Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 586-600, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In our benchmarks, we have used an interest rate of 1% per month and a monthly repayment of 2 units; the final balance is unconstrained. The value of the principal and time period vary to illustrate various tradeoffs in the optimizations. Ode-Euler <ref> [39] </ref> is a program solving the ordinary differential equation y 0 = t numerically using Euler method. Triangular is a benchmark that involves simultaneously solving a sparse system of N equations, subsystems of which are in upper triangular form. <p> The chapter concludes by examining the relation of the CLP (&lt; Lin ) optimizations with imperative language optimizations in Section 8.4. 8.1 Optimization of CLP (&lt;) Our research is closely related to a number of papers published on the optimization of CLP (&lt;) (eg. <ref> [36, 26, 37, 24, 39, 31, 23] </ref>. However, few experimental results have appeared to quantify the possible benefits in a practical optimizing compiler. <p> More specialized optimizations such as linear threading, linear gather and mixed nonlinear gather, that work only on some classes of CLP (&lt;) programs are presented in <ref> [39] </ref>. 145 8.2 Abstract Interpretation of CLP As mentioned previously, the optimization of CLP programs is achieved by the method of abstract interpretation.
Reference: [40] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):315-347, </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: The upper bound operation is a consistent abstraction of union of sets of constraint stores. The last step of the methodology consists of computing the least fixpoint or a post-fixpoint of the abstract semantics using an algorithm such as GAIA [29] or PLAI <ref> [40] </ref>. Both of these are top-down algorithms computing a small, but sufficient, subset of least fixpoint (or of a postfixpoint) necessary to answer a user query. From the abstract interpretation results, our optimizing compiler uses basically three pieces of information for each predicate p in the program. <p> This can be computed in a top-down or a bottom-up fashion. Generic abstract interpretation algorithms from logic programming, such as GAIA [29] or PLAI <ref> [40] </ref> can be adapted for the purpose. From the abstract interpretation results, our optimizing compiler uses basically three abstract substitutions for each predicate p in the program.
Reference: [41] <author> R.A. O`Keefe. </author> <title> Finite Fixed-Point Problems. </title> <booktitle> in Fourth Intl. Conf. on Logic Programming, </booktitle> <pages> 729-743, </pages> <address> Melbourne, Australia, </address> <year> 1987. </year> <month> 186 </month>
Reference-contexts: Abstract interpretation of CLP is closely related to the abstract interpretation of logic programs and borrows many of the theoretical aspects such as work on frameworks [2, 5, 4, 32, 33, 38] and algorithms <ref> [5, 7, 29, 25, 41] </ref>. Much of the previous work on abstract interpretation of CLP has focused on theoretical aspects [17, 35] and defining various abstract domains [13, 14, 37].
Reference: [42] <author> W. Older and A. Vellino. </author> <title> Extending Prolog with Constraint Arithmetics on Real Intervals. </title> <booktitle> In Canadian Conference on Computer & Electrical Engineering, </booktitle> <address> Ottawa, </address> <year> 1990. </year>
Reference-contexts: Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [22, 47, 8]), integers (e.g., [46]), Booleans (e.g., [6, 8]), and nonlinear real constraints (e.g., <ref> [42] </ref>). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain. These features make CLP languages especially suitable for expressing combinatorial search problems.
Reference: [43] <author> V. Ramachandran and P. Van Hentenryck. LSign Reordered. </author> <title> In Static Analysis Symposium (SAS-95), </title> <address> Glasgow, UK, </address> <month> September </month> <year> 1995. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 983, </volume> <pages> 330-347, </pages> <publisher> Springer Verlag. </publisher>
Reference-contexts: In particular, it uses abstract interpretation algorithms derived from the generic abstract interpretation system GAIA, [29] instantiated to the following abstract domains: Prop [34, 52] to deduce information on fixed variables, and LSign <ref> [37, 43] </ref> (or LInt) to deduce unconstrained variables, redundant constraints, and satisfiable constraint stores. 1.5 Overview of the Compiler Optimizations The high-level optimizations performed by our compiler may be viewed as source to source transformations, transforming the source program into another (richer) source program which may contain, not only constraints, but <p> This store is called the intermediate description of p. The fact that these three descriptions suffice to produce good results comes from the nature of the abstract domains. 1.6.2 The Domains LSign and LInt The domain LSign <ref> [37, 43] </ref> is fundamental for the reordering and redundancy phases and for detecting unconstrained variables in the refinement phase. Its two critical ideas are the replacement of coefficients by their signs and the association of multiplicity information with constraints. <p> Note that abstract operations on this domain are non-trivial and use abstract versions of Fourier and Gaussian elimination. The details are presented later in this thesis and also in <ref> [37, 43] </ref>. We now illustrate the domain LSign on our running example. The top-level query, where P and R are fixed, is associated with the abstract store fh&gt; = P; Onei; h&gt; = R; Oneig stating that P and R are fixed to a real number. <p> The final set of results is experimental, indicating that our approach to CLP optimization is promising and can yield substantial speedups in program execution. The Domain LSign The thesis contributes to the theory underlying the abstract domain LSign <ref> [37, 43] </ref>. LSign is an elegant domain for analyzing CLP languages over linear real constraints. Its key conceptual ideas are the abstraction of linear constraints by replacing coefficients by signs and the use of annotations for preserving multiplicity information on the constraints. <p> The thesis contributes to the theory underlying the abstract domain LSign <ref> [37, 43] </ref>. Unfortunately, the original paper on LSign by Marriott and Stuckey [37] has a number of theoretical drawbacks. In particular, the ordering of abstract constraint stores given in [37] does not capture the intended meaning and makes it imposssible to prove the consistency of the abstract operations of LSign.
Reference: [44] <author> V. Ramachandran, P. Van Hentenryck, and A. Cortesi. </author> <title> Abstract Domains for Reordering of CLP(&lt; Lin ). Technical Report, </title> <institution> CS-97-07, Brown University, </institution> <month> June </month> <year> 1997. </year>
Reference: [45] <author> A. Taylor. </author> <title> LIPS on a MIPS:Results from a Prolog Compiler for a RISC. </title> <booktitle> In Logic Programming: Proc. Seventh Intl. Conf., </booktitle> <pages> 174-185, </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In particular, the attempt to reduce the constraint solving time through refinement and removal can be compared with the attempt to reduce the time spent in unification. Papers by Van Roy [53] and Taylor <ref> [45] </ref> give a good idea of the speedups that can be obtained for Prolog programs through sophisticated global analyses. Debray [12] proposes a number of loop optimizations for Prolog that are the equivalent of classic loop optimizations in imperative languages.
Reference: [46] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., [22, 47, 8]), integers (e.g., <ref> [46] </ref>), Booleans (e.g., [6, 8]), and nonlinear real constraints (e.g., [42]). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain.
Reference: [47] <author> P. Van Hentenryck and T. Graf. </author> <title> Standard Forms for Rational Linear Arithmetics in Constraint Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 5(2-4):303-320, </volume> <year> 1992. </year>
Reference-contexts: Introduction Constraint logic programming (CLP) [21] is a generalization of logic programming where unification is replaced by constraint solving over a suitable domain, as the basic operation of the language. Many CLP languages have been defined in the last decade on computation domains such linear real constraints (e.g., <ref> [22, 47, 8] </ref>), integers (e.g., [46]), Booleans (e.g., [6, 8]), and nonlinear real constraints (e.g., [42]). CLP languages preserve some of the traditional advantages of logic programming such as declarative semantics, nondeterminism and multi-directionality, while adding the expressive power of constraint solving over a suitable domain. <p> The solved form in the Gauss subsystem consists of isolating one variable per equation (called the basic variable) and eliminating it from the rest of the store. The solved form in the Simplex subsystem is similar, but it also imposes a lexicographic requirement <ref> [47] </ref> on the equations. In both subsystems disequations are fully dereferenced (i.e the basic variables are eliminated from them) and required to be different from 0 6= 0.
Reference: [48] <author> P. Van Hentenryck and V. Ramachandran. </author> <title> Backtracking without Trailing in CLP(&lt; Lin ). In Proc. </title> <booktitle> ACM-SIGPLAN Conf. on Programming Language Design and Implementation (PLDI-94), </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference: [49] <author> P. Van Hentenryck and V. Ramachandran. </author> <title> Backtracking without Trailing in CLP(&lt; Lin ). ACM Transactions on Programming Languages and Systems, </title> <month> July </month> <year> 1995. </year>
Reference-contexts: Design decisions similar in spirit were adopted in CLP (&lt;) [22]. More details about the CLP (&lt; Lin ) runtime system are available in <ref> [49] </ref>. <p> not constrained), then the equation above becomes an assignment X 1 := 5X 2 + 2X 3 + 4. i.e. the linear expression on the R.H.S. can be evaluated and assigned to X 1 . 1.3.3 The Constraint Solver The constraint solver and solved form are described in detail in <ref> [49] </ref>. The constraint solver receives constraints from the interface and updates its accumulated constraint store. Each time a constraint is added to the solver, it returns a Boolean value indicating whether the constraint was satisfiable in conjunction with the accumulated store. <p> Therefore, the constraint solving algorithms for CLP (&lt; Lin ) consist of maintaining the accumulated store in a solved form incrementally. The organization of the constraint solver into two modules is illustrated in Figure 1.7. More details about the constraint solver are available in <ref> [49] </ref>. 1.4 The Challenge of CLP Optimization While CLP languages greatly reduce the development time of several classes of programs (especially programs for combinatorial search problems), this reduction in development time may come at the expense of some run-time efficiency.
Reference: [50] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Type Analysis of Prolog Using Type Graphs. </title> <booktitle> In Proc. ACM-SIGPLAN Conf. on Programming Language Design and Implementation (PLDI-94), </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: However, as 2 LInt is an infinite domain, it becomes necessary to introduce a widening operator 1 . The use of widening operators was proposed in [10] and has been previously used in domains such as type graphs for Prolog <ref> [50, 51] </ref>. The design of a widening operator is both experimental and theoretical in nature. One the one hand, a widening operator should lead to efficient and accurate analyses; on the other hand, it should be possible to prove the termination and correctness of analyses using a widening operator.
Reference: [51] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Type Analysis of Prolog Using Type Graphs. </title> <journal> Journal of Logic Programming, </journal> <year> 1994. </year>
Reference-contexts: However, as 2 LInt is an infinite domain, it becomes necessary to introduce a widening operator 1 . The use of widening operators was proposed in [10] and has been previously used in domains such as type graphs for Prolog <ref> [50, 51] </ref>. The design of a widening operator is both experimental and theoretical in nature. One the one hand, a widening operator should lead to efficient and accurate analyses; on the other hand, it should be possible to prove the termination and correctness of analyses using a widening operator.
Reference: [52] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Evaluation of Prop. </title> <journal> Journal of Logic Programming, </journal> <volume> 23(3), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: In particular, it uses abstract interpretation algorithms derived from the generic abstract interpretation system GAIA, [29] instantiated to the following abstract domains: Prop <ref> [34, 52] </ref> to deduce information on fixed variables, and LSign [37, 43] (or LInt) to deduce unconstrained variables, redundant constraints, and satisfiable constraint stores. 1.5 Overview of the Compiler Optimizations The high-level optimizations performed by our compiler may be viewed as source to source transformations, transforming the source program into another <p> This enables a more precise analysis of programs in many cases. This will be discussed in greater detail later in the thesis. In general, we continue the presentation only with the domain LSign, for simplicity. 1.6.3 The Domain Prop The domain Prop <ref> [35, 52] </ref> is an effective domain to compute groundness information for Prolog. It can be extended easily to infer fixed variables in CLP (e.g. [17]). Its key idea is to represent the information through a Boolean formula. <p> Similar examples can be constructed for the other abstract applications such as redundancy and conditional satisfiability. 111 Chapter 5 Abstract Domain Prop In this chapter, we present the abstract domain Prop <ref> [35, 52] </ref> which is useful to deduce groundness information in Prolog programs. It can also be extended easily to infer fixed variables in CLP (eg. [17]). <p> It can also be extended easily to infer fixed variables in CLP (eg. [17]). The presentation is basically a review of material already presented in <ref> [52] </ref>, along with the extension of Prop to handle the constraints of CLP (&lt; Lin ). Section 5.1 defines the abstract objects and their concretization. The abstract operations of the domain are presented in Section 5.2. The application of the domain to deduce fixed variables is discussed in Section 5.3.
Reference: [53] <author> P. Van Roy and A. Despain. </author> <title> The Benefits of Global Dataflow Analysis for an Optimizing Prolog Compiler. </title> <booktitle> In Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> 501-515, </pages> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 187 </month>
Reference-contexts: In particular, the attempt to reduce the constraint solving time through refinement and removal can be compared with the attempt to reduce the time spent in unification. Papers by Van Roy <ref> [53] </ref> and Taylor [45] give a good idea of the speedups that can be obtained for Prolog programs through sophisticated global analyses. Debray [12] proposes a number of loop optimizations for Prolog that are the equivalent of classic loop optimizations in imperative languages.
Reference: [54] <author> W. Winsborough. </author> <title> Multiple Specialization using Minimal Function Graph Semantics. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4), </volume> <year> 1992. </year> <month> 188 </month>
Reference-contexts: that can occur inside the predicate call (represented by fi 0 3 ) also need to be added to the accumulated intermediate substitution. 2.3 Abstract Semantics The abstract semantics is a natural extension to CLP of the logic programming abstract semantics in [29], and is close to the works of <ref> [54] </ref> and [33]. The abstract semantics consists of approximating the concrete semantics by replacing a set of constraint stores by a single abstract substitution, i.e. an abstract substitution represents a set of constraint stores.
References-found: 54

