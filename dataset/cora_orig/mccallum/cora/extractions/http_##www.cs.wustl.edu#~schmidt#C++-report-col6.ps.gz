URL: http://www.cs.wustl.edu/~schmidt/C++-report-col6.ps.gz
Refering-URL: http://www.acl.lanl.gov/CORBA/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: schmidt@cs.wustl.edu vinoski@ch.hp.com  
Title: Object Interconnections Comparing Alternative Programming Techniques for Multi-threaded CORBA Servers: Thread Pool (Column 6)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column will appear in the April 1996 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 Chelmsford, MA 01824  
Affiliation: Department of Computer Science Hewlett-Packard Company Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: In particular, developers must address sources of accidental and inherent complexity: * Accidental complexity of multi-threaded programming arises from limitations with programming tools and design techniques. For example, many debuggers can't handle threaded programs and can't step across host boundaries. Likewise, algorithmic design <ref> [1] </ref> makes it hard to reuse application components because it tightly couples the structure of a threaded application to the functions it performs. * Inherent complexity of multi-threaded programming arises from challenges such as avoiding deadlock and live-lock, eliminating race conditions for shared objects, and minimizing the overhead of context switch, <p> a pool of threads, and start an event loop in the main thread, as shown below: const int DEFAULT_PORT = 12345; const int DEFAULT_POOL_SIZE = 4; int main (int argc, char *argv []) - u_short port = /* Port to listen for connections. */ argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : DEFAULT_PORT; int pool_size = /* Size of the thread pool. */ argc &gt; 2 ? atoi (argv [2]) : DEFAULT_POOL_SIZE; /* Create a passive-mode listener endpoint. */ 1 Porting our implementation to POSIX pthreads or Win32 threads is straightforward. <p> () Server Function The server main is responsible for creating a thread pool and the Quote Acceptor, as follows: // !!! Default constants. const int DEFAULT_PORT = 12345; const int DEFAULT_POOL_SIZE = 4; int main (int argc, char *argv []) - u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : DEFAULT_PORT; int pool_size = // !!! Size of the thread pool. argc &gt; 2 ? atoi (argv [2]) : DEFAULT_POOL_SIZE; // !!! Create a pool of threads to // handle quote requests from clients. <p> My_Quoter_var my_quoter = new TIE_My_Quoter (My_Quoter) (new My_Quoter); int pool_size = argc == 1 ? DEFAULT_POOL_SIZE : atoi (argv <ref> [1] </ref>); // Create a pool of threads to handle // quote requests from clients. 10 Thread::spawn_n (pool_size, Thread_Filter::pool_thread, (void *) 0, THR_DETACHED | THR_NEW_LWP); // Wait for work to do in the main thread // (which is also the thread that shepherds // CORBA requests through TP_Thread_Filter).
Reference: [2] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> 11 Beyond Multiprocessing... Multithreading the SunOS Ker--nel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: We'll explore the implementation and use of these components in this column using C, C++ wrappers, and CORBA, respectively. 3 The Multi-threaded C Thread Pool Solution 3.1 C Code The following example shows a solution written using C, sockets, and Solaris threads <ref> [2] </ref> 1 As in previous columns, we use a set of C utility functions to receive stock quote requests from clients (recv request), look up quote information (lookup stock price), and return the quote to the client (send response). /* WIN32 already defines this. */ #if defined (unix) typedef int HANDLE; <p> = 12345; const int DEFAULT_POOL_SIZE = 4; int main (int argc, char *argv []) - u_short port = /* Port to listen for connections. */ argc &gt; 1 ? atoi (argv [1]) : DEFAULT_PORT; int pool_size = /* Size of the thread pool. */ argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : DEFAULT_POOL_SIZE; /* Create a passive-mode listener endpoint. */ 1 Porting our implementation to POSIX pthreads or Win32 threads is straightforward. <p> These techniques are beyond the scope of this column and are discussed in <ref> [2, 3] </ref>. /* Close handle to prevent leaks. */ close (h); - /* NOTREACHED */ - The main program is similar to the one shown in Section 3.1.1, as shown below: int main (int argc, char *argv []) - /* Create a passive-mode listener endpoint. */ listener = create_server_endpoint (port); /* <p> // !!! Default constants. const int DEFAULT_PORT = 12345; const int DEFAULT_POOL_SIZE = 4; int main (int argc, char *argv []) - u_short port = argc &gt; 1 ? atoi (argv [1]) : DEFAULT_PORT; int pool_size = // !!! Size of the thread pool. argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : DEFAULT_POOL_SIZE; // !!! Create a pool of threads to // handle quote requests from clients. Thread::spawn_n (pool_size, Quote_Handler&lt;SOCK_Stream&gt;::pool_thread, (void *) 0, THR_DETACHED | THR_NEW_LWP); // !!! Factory that produces Quote_Handlers.
Reference: [3] <author> D. C. Schmidt, </author> <title> An OO Encapsulation of Lightweight OS Concurrency Mechanisms in the ACE Toolkit, </title> <type> Tech. Rep. </type> <institution> WUCS-95-31, Washington University, St. Louis, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: These techniques are beyond the scope of this column and are discussed in <ref> [2, 3] </ref>. /* Close handle to prevent leaks. */ close (h); - /* NOTREACHED */ - The main program is similar to the one shown in Section 3.1.1, as shown below: int main (int argc, char *argv []) - /* Create a passive-mode listener endpoint. */ listener = create_server_endpoint (port); /* <p> Thread::spawn_n (pool_size, Quote_Handler&lt;SOCK_Stream&gt;::pool_thread, (void *) 0, THR_DETACHED | THR_NEW_LWP); // !!! Factory that produces Quote_Handlers. Quote_Acceptor acceptor (port); svc_run (acceptor); /* NOTREACHED */ return 0; - First, the ACE method spawn n <ref> [3] </ref> is called to create a pool of n threads. Each thread executes the Quote Handler::pool thread function. Next, a Quote Acceptor object is created. This object is used to accept connections from clients and create Quote Handler objects to service them.
Reference: [4] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: Other operarting systems (e.g., many kernels based on System V UNIX) implement it as a library 4 call, so that calls to accept are not atomic. If accept is not atomic then it's possible for threads to receive EPROTO errors from accept, which means protocol error <ref> [4] </ref>. One solution to this problem is to explicitly add mutexes around the accept call, but this locking can itself become a bottleneck. * Caching open connections Our alternative thread pool solution forces each thread to allocate a new connection since threads are always blocked in accept.
Reference: [5] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: Rather than spending any more effort revising the C version, we'll incorporate these changes into the C++ solution in the next section. 4 The Multi-threaded C++ Wrappers Thread Pool Solution 4.1 C++ Wrapper Code This section illustrates a C++ thread pool implementation based on ACE <ref> [5] </ref>.
Reference: [6] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Tech. Rep. </type> <institution> HPL-94-34, Hewlett-Packard Laboratories, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: For instance, variations of the Quote Handler, Quote Acceptor, and Reactor have been used in previous implementations of the quote server in the Octo-ber 1995 and February 1996 C++ Report. Likewise, the Request Queue can be implemented by using components available with C++ libraries like ACE and STL <ref> [6] </ref>.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Since there is only one of these, we'll define it using the Singleton pattern <ref> [7] </ref>. <p> TYPE queue_ [MAX_SIZE]; // ... The ACE Singleton class is an adapter that turns ordinary classes into Singletons <ref> [7] </ref>, as follows: template &lt;class TYPE, class LOCK = Mutex&gt; class Singleton - public: static TYPE *instance (void) - // Perform the Double-Checked Locking // pattern to ensure proper initialization. if (instance_ == 0) - Guard&lt;LOCK&gt; lock (lock_); if (instance_ == 0) instance_ = new TYPE; - return instance_; - protected: <p> which is based on object composition rather than inheritance: class My_Quoter // Note lack of inheritance! - -; We use the Orbix TIE approach to associate the CORBA interfaces with our implementation as follows: DEF_TIE_Quoter (My_Quoter) The TIE approach is an example of an object form of the Adapter pattern <ref> [7] </ref>, whereas the inheritance approach we used last column uses the class form of the pattern. The object form of the Adapter uses delegation to tie the interface of the My Quoter object implementation class to the interface expected by the Quoter skeleton generated by MT-Orbix.
Reference: [8] <author> D. C. Schmidt and T. Harrison, </author> <title> Double-Checked Locking An Object Behavioral Pattern for Initializing and Accessing Thread-safe Objects Efficiently, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: == 0) - Guard&lt;LOCK&gt; lock (lock_); if (instance_ == 0) instance_ = new TYPE; - return instance_; - protected: // Singleton instance of TYPE. static TYPE *instance_; // Lock to ensure serialization. static LOCK lock_; -; The ACE Singleton adapter avoids subtle race conditions by using the Double-Checked Locking pattern <ref> [8] </ref>.
Reference: [9] <author> D. C. Schmidt, </author> <title> Design Patterns for Initializing Network Services: Introducing the Acceptor and Connector Patterns, </title> <journal> C++ Report, </journal> <volume> vol. 7, </volume> <month> November/December </month> <year> 1995. </year>
Reference-contexts: The handle input method will block if the queue is full, whereas the pool thread function will block if the queue is empty. 4.1.3 The Quote Acceptor Class The Quote Acceptor class is an implementation of the Acceptor pattern <ref> [9] </ref> that creates Quote Handlers to pro 7 cess quote requests from clients. Its implementation is simi- lar to the one shown in our previous column: typedef Acceptor &lt;Quote_Handler &lt;SOCK_Stream&gt;, // Quote service. SOCK_Acceptor&gt; // Passive conn. mech.
Reference: [10] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year> <month> 12 </month>
Reference-contexts: When a request is received, the Orbix Object Adapter upcalls the TIE object. In turn, this object dispatches the call to the My Quoter object that is associated with the TIE object. The TIE approach is mentioned in the C++ Language Mapping chapters of the CORBA 2.0 specification <ref> [10] </ref>. Not surprisingly, the idea for putting it there originally came from IONA Technologies, the makers of Orbix.
References-found: 10

