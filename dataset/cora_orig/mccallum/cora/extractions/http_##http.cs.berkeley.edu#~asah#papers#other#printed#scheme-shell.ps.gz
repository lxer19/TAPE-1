URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/scheme-shell.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Email: shivers@lcs.mit.edu  
Title: Personal Information Architecture Note 3 4/94 A Scheme Shell Although robust enough for general use,
Author: Olin Shivers Prologue 
Note: Whatever it is, it's an object lesson in angst. Furthermore, during late-night conversations with office mates and graduate students, I have formed the impression that I am not alone. In late February 1 I got embroiled in a  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY Laboratory for Computer Science  
Abstract: Shell programming terrifies me. There is something about writing a simple shell script that is just much, much more unpleasant than writing a simple C program, or a simple COMMON LISP program, or a simple Mips assembler program. Is it trying to remember what the rules are for all the different quotes? Is it having to look up the multi-phased interaction between filename expansion, shell variables, quotation, backslashes and alias expansion? Maybe it's having to subsequently look up which of the twenty or thirty flags I need for my grep, sed, and awk invocations. Maybe it just gets on my nerves that I have to run two complete programs simply to count the number of files in a directory (ls | wc -l), which seems like several orders of magnitude more cycles than was really needed. 
Abstract-found: 1
Intro-found: 1
Reference: [CLtL2] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Maynard, Mass., </address> <note> second edition 1990. </note>
Reference-contexts: Some of the design for the system calls was modeled after Richard Stallman's emacs [emacs], Project MAC's MIT Scheme [MIT Scheme], and COMMON LISP <ref> [CLtL2] </ref>. Tom Duff's Unix shell, rc, was also inspirational; 31 his is the only elegant Unix shell I've seen [rc]. Flames with Bennet Yee and Scott Draves drove me to design scsh in the first place; polite discussions with John Ellis and Scott Nettles subsequently improved it.
Reference: [Ellis] <editor> John R. </editor> <publisher> Ellis. </publisher>
Reference-contexts: Although some of the procedures have been described in passing, a detailed description of the system-call library is beyond the scope of this note. The reference manual [refman] contains the full details. 5 The Tao of Scheme and Unix Most attempts at embedding shells in functional programming languages <ref> [fsh, Ellis] </ref> try to hide the difference between running a program and calling a procedure. That is, if the user tries (lpr "notes.txt") the shell will first treat lpr as a procedure to be called. <p> subject of scsh and systems programming in Unix: * A Scheme shell wins because it is broad-spectrum. * A functional language is an excellent tool for systems programming. * Hacking Unix isn't so bad, actually, if you don't have to use C. 14 Acknowledgements John Ellis' 1980 SIGPLAN Notices paper <ref> [Ellis] </ref> got me thinking about this entire area. Some of the design for the system calls was modeled after Richard Stallman's emacs [emacs], Project MAC's MIT Scheme [MIT Scheme], and COMMON LISP [CLtL2].
References-found: 2

