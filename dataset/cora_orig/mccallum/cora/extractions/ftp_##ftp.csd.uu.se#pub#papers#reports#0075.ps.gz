URL: ftp://ftp.csd.uu.se/pub/papers/reports/0075.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: Email: fbevemyr,thomasl,hakanmg@csd.uu.se  
Title: Exploiting Recursion-Parallelism in Prolog  
Author: Johan Bevemyr Thomas Lindgren H-akan Millroth 
Address: Box 311, S-75105 Uppsala, Sweden  
Affiliation: Computing Science Dept., Uppsala University  
Abstract: We exploit parallelism across recursion levels in a deterministic subset of Prolog. The implementation extends a convential Prolog machine with support for data sharing and process managment. Extensive global dataflow analysis is employed to facilitate parallelization. Promising performance figures, showing high parallel efficiency and low overhead for parallelization, have been obtained on a 24 processor shared-memory multiprocessor.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Bell, </author> <title> Ultracomputers: a Teraflop before its time, </title> <journal> Comm. ACM, </journal> <volume> Vol. 35, No. 8, </volume> <year> 1992. </year>
Reference-contexts: 1 INTRODUCTION The Single Program Multiple Data (SPMD) model of parallel computation has recently received a lot of attention (see e.g. the article by Bell <ref> [1] </ref>). The model is characterized by each parallel process running the same program but with different data. 1 The attraction of this model is that it does not require a dynamic network of parallel processes: this facilitates efficient implementation and makes the parallel control-flow comprehensible for the programmer.
Reference: [2] <author> J. Bevemyr, </author> <title> A Recursion-Parallel Prolog Engine, </title> <type> PhL Thesis, </type> <institution> Computing Science Department, Uppsala University, </institution> <year> 1993. </year>
Reference-contexts: Due to space limitations, we can only describe these by means of a simple example and refer to other sources for a full discussion <ref> [3, 2, 4] </ref>. Consider the program: map ([],[]).
Reference: [3] <author> J. Bevemyr, T. Lindgren & H. Millroth, </author> <title> Reform Prolog: The Language and its Implementation, to appear in: </title> <booktitle> Proc. 10th Int. Conf. Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Due to space limitations, we can only describe these by means of a simple example and refer to other sources for a full discussion <ref> [3, 2, 4] </ref>. Consider the program: map ([],[]).
Reference: [4] <author> T. Lindgren, </author> <title> The Compilation and Execution of Recursion-Parallel Pro log on Shared Memory Multiprocessors, </title> <type> PhL Thesis, </type> <institution> Computing Science Department, Uppsala University, </institution> <month> May, </month> <note> 1993 (expected). </note>
Reference-contexts: Due to space limitations, we can only describe these by means of a simple example and refer to other sources for a full discussion <ref> [3, 2, 4] </ref>. Consider the program: map ([],[]).
Reference: [5] <author> S.K. Debray & D.S. Warren, </author> <title> Automatic Mode Inference for Logic pro grams, </title> <journal> J. Logic Programming, </journal> <volume> Vol. 5, No. 3, </volume> <year> 1988. </year>
Reference-contexts: The compiler then emits instructions based on this information, possibly falling back to more conservative code generation schemes when high-precision analysis results cannot be obtained. 5.1 Type analysis The type inference phase employs an abstract domain based on the standard mode-analysis domain <ref> [5] </ref>, augmented with support for lists and difference lists as well as handling of certain aliases. The compiler distinguishes the parallel and sequential types of a predicate.
Reference: [6] <author> H. Millroth, </author> <title> Reforming Compilation of Logic Programs, </title> <booktitle> Proc. Int. Symp. Logic Programming, </booktitle> <address> San Diego, Calif., </address> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A recursive invocation minus the head unification and the (next) recursive call is referred to as a recursion level. Each recursion level constitutes a process, which gives the programmer an easy way of estimating the process granularity of a given program or call. We implement recursion-parallelism by Reform compilation <ref> [6] </ref> (this can be viewed as an implementation technique for the Reform inference system [11]). fl To appear in: Proc. PARLE'93, Springer LNCS, 1993. 1 This should not be confused with the Single Instruction Multiple Data or SIMD model, where processes are synchronized instruction by instruction. 1 recursion-parallelism.
Reference: [7] <author> L. Naish, </author> <title> Parallelizing NU-Prolog, </title> <booktitle> Proc. 5th Int. Conf. Symp. Logic Pro gramming, </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Experimental results obtained when running benchmark programs on a parallel machine are presented and discussed in Section 7. 2 2 REFORM PROLOG Reform Prolog parallelizes a deterministic subset of Prolog. This is similar to the approach taken in Parallel NU-Prolog <ref> [7] </ref>. However, Reform Prolog exploits recursion-parallelism when parallelizing this subset, whereas Parallel NU-Prolog exploits AND-parallelism. With Reform Prolog, as with Parallel NU-Prolog, it is straight-forward to call parallel subprograms from a nondeterministic program. Thus, there is a natural embedding of parallel code in ordinary sequential Prolog programs.
Reference: [8] <author> D. Palmer and L. Naish, NUA-Prolog: </author> <title> An Extension to the WAM for Parallel Andorra, </title> <booktitle> Proc. 8th Int. Conf. Logic Programming, </booktitle> <address> Paris, </address> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We compare Reform Prolog with the only other Prolog systems, which supports deterministic dependent AND-parallelism, that we are aware of, Andorra-I [9] and NUA-Prolog <ref> [8] </ref>. The Andorra-I system is an interpreter written in C. NUA-Prolog is a compiled system using a WAM-based abstract machine. 10 It should be noted that these systems to some extent exploit different forms of parallelism.
Reference: [9] <author> V. Santos Costa, D.H.D. Warren and R. Yang, </author> <title> The Andorra-I Engine: A Parallel Implementation of the Basic Andorra Model, </title> <booktitle> Proc. 8th Int. Conf. Logic Programming, </booktitle> <address> Paris, </address> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We compare Reform Prolog with the only other Prolog systems, which supports deterministic dependent AND-parallelism, that we are aware of, Andorra-I <ref> [9] </ref> and NUA-Prolog [8]. The Andorra-I system is an interpreter written in C. NUA-Prolog is a compiled system using a WAM-based abstract machine. 10 It should be noted that these systems to some extent exploit different forms of parallelism. <p> nrev benchmark on an 11 processor Sequent Symmetry. (Note that the Reform Prolog figures were obtained using more than twice the number of processors the other systems used|using less processors improves the result.) The Andorra-I system shows parallelization overheads in the range of 35-40 % on a set of benchmarks <ref> [9] </ref>. NUA-Prolog shows a parallelization overhead of 50 % on the nrev benchmark. 8 CONCLUSIONS The developments and results discussed in this paper suggests that recursion-parallelism is an efficient method for executing Prolog programs on shared-memory multiprocessors.
Reference: [10] <author> P. Tang and P.-C. Yew, </author> <title> Processor Self-Scheduling for Multiple Nested Parallel Loops, </title> <booktitle> Proc. 1986 Int. Conf. Parallel Processing , 1986. </booktitle>
Reference-contexts: The drawback of this method is that a suspended process tie up a processor. The advantage is that non-suspended processes are not slowed down. In particular, very simplisitic and efficient approaches to process scheduling are possible. The Reform Prolog implementation currently supports static scheduling and dynamic self-scheduling <ref> [10] </ref>. With both approaches, the actual task switching amounts to a simple jump operation. 5 COMPILING RECURSION PARALLEL PROGRAMS The compiler ensures the safeness of the computation, guarantees that time-dependent operations are performed correctly and employs suspending and locking unification when necessary.
Reference: [11] <author> S. A. </author> <title> Tarnlund, Reform, </title> <type> report, </type> <institution> Computing Science Dept., Uppsala Uni versity, </institution> <year> 1991. </year>
Reference-contexts: Each recursion level constitutes a process, which gives the programmer an easy way of estimating the process granularity of a given program or call. We implement recursion-parallelism by Reform compilation [6] (this can be viewed as an implementation technique for the Reform inference system <ref> [11] </ref>). fl To appear in: Proc. PARLE'93, Springer LNCS, 1993. 1 This should not be confused with the Single Instruction Multiple Data or SIMD model, where processes are synchronized instruction by instruction. 1 recursion-parallelism. This is a control-structure transformation that changes the control-flow of a recursive program quite dramatically.
Reference: [12] <author> D.H.D. Warren, </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI International, Menlo Park, Calif., </institution> <year> 1983. </year> <month> 12 </month>
Reference-contexts: Each worker is a separate process running a WAM-based <ref> [12] </ref> Prolog engine with extensions to support parallel execution. The Prolog engine is comparable in speed with SICStus Prolog (slightly faster on some programs, slightly slower on others). The Reform engine alternates between two modes: sequential execution and parallel execution.
References-found: 12

