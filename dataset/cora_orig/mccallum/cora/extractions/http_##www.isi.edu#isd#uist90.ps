URL: http://www.isi.edu/isd/uist90.ps
Refering-URL: http://www.isi.edu/isd/
Root-URL: http://www.isi.edu
Title: Template-Based Mapping of Application Data to Interactive Displays [14] provide interactive what-you-see-is-what-you-get interfaces to assemble
Author: Pedro Szekely 
Keyword: Interactive user interface builder systems  
Note: 1.0 Introduction  such as Prototyper  2.0 Overview of Humanoid  
Address: 4676 Admiralty Way, Marina del Rey, CA 90292  
Affiliation: USC/Information Sciences Institute  
Email: szekely@isi.edu  
Phone: (213) 822-1511  
Abstract: This paper describes a template-based method for constructing interactive displays with the building-blocks (widgets) provided in a user interface toolkit. Templates specify how to break down complex application objects into smaller pieces, specify the graphical components (widgets) to be used for displaying each piece, and specify their layout. Complex interfaces are constructed by recursively applying templates, thus constructing a tree of widgets to display a complex application object. The template-based method is more general than the interactive, WYSIWYG interface builders in that it can specify dynamic displays for application data that changes at run time. The template-based method also leads to more consistent, extendable and modifiable interfaces. User interface toolkits such as the X Toolkit [10] and the Macintosh Tool-Box [5] provide abstractions that make the construction of user interfaces significantly easier than programming using graphics primitives. Unfortunately the toolkits do not make the construction of user interfaces easy enough. The tasks of assembling the widgets to construct complex displays, and of tying the widgets to application data structures remains difficult and time consuming. This paper describes a template-based method for assembling widgets into complex interfaces and tying them to application objects. Templates specify how to break down complex application objects into smaller pieces, specify the widgets to be used for displaying each piece, and specify their layout. Complex interfaces are constructed by recursively applying templates, thus constructing a tree of widgets to display a composite application object. The template-based method supports the construction of dynamic displays, and also encourages the design of consistent, extendable and modifiable interfaces. The paper is organized as follows. Section 2.0 presents an overview of a template-based UIMS named Humanoid, the High-level UIMS for Manufacturing Applications Needing Organized Iterative Development. Section 3.0 compares the template-based method with other methods, sections 4.0 and 5.0 describe the template-based method in detail, and finally section 6.0 discusses our experience with Humanoid. At a high level, Humanoid can be viewed as a layer of software on top of traditional user interface toolkits. Humanoid provides abstractions to facilitate the specification of the connections between application data structures and widgets provided by toolkits. Humanoid can also be viewed as a user interface design environment where interface designers can construct interfaces by establishing a mapping between the data structures of an application and the widgets of a user interface toolkit. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Action. ExperTelligence, </editor> <address> 5638 Hollister Avenue, #302, Goleta, CA 93117. </address>
Reference-contexts: The main advantage of the programming approach is its great exibility in constructing any interface feature desired. Interactive interface builder systems such as Prototyper [14], Cardellis interface builder [4] and Action <ref> [1] </ref> are tools whose goal is to eliminate programming from the interface construction process. Interface designers draw the widgets on the screen, interactively specifying their layout and other display properties such as fonts, line styles and labels.
Reference: [2] <author> Y. Arens, L. Miller, S. Shapiro and N. Sondheimer. </author> <title> Automatic Construction of User Interface Displays. </title> <booktitle> In AAA1 88, </booktitle> <pages> pages 808-813, </pages> <year> 1988. </year>
Reference-contexts: The inability of interface builders to specify methods of presentation rather than the presentation itself makes interface builders of little use for building the main windows of an application, which typically display objects that change at run time. Systems like APT [9] and II <ref> [2] </ref> are representative of systems that automatically generate displays. APT produces displays of quantitative data, and can produce results of quality comparable or better that the results produced by humans. However, few automatic systems have been built to construct fully interactive displays of data that can change at run time.
Reference: [3] <author> W. Bennett, S. Boies, J. Gould, S. Greene and C. Wiecha. </author> <title> Transformations on a Dialog Tree: Rule-Based Mapping of Content to Style. </title> <booktitle> In Proceedings of the ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 67-75, </pages> <month> Novem-ber </month> <year> 1989. </year>
Reference-contexts: The shortcoming of II is that it only addresses the output part of interface generation, its rule language is complicated and hard to use, and the displays produced are not updated when the presented data changes. The ITS system <ref> [3] </ref> is another system that uses rules. In ITS, interactive programs are defined using three kinds of abstractions: data definitions, to define the data manipulated by the program, content trees, to define the dialogues in an abstract way, and style rules, to map the content trees to graphical objects.
Reference: [4] <author> L Cardelli. </author> <title> Building User Interfaces by Direct Manipulation. </title> <booktitle> In Proceedings of the ACM SIGGRAPH Symposium on User Interface Software, Banff, Al-berta, </booktitle> <pages> pages 152-166, </pages> <month> October </month> <year> 1988 </year>
Reference-contexts: Since programming is involved, human factors experts are isolated from the iterative development cycle needed to construct good interfaces. The main advantage of the programming approach is its great exibility in constructing any interface feature desired. Interactive interface builder systems such as Prototyper [14], Cardellis interface builder <ref> [4] </ref> and Action [1] are tools whose goal is to eliminate programming from the interface construction process. Interface designers draw the widgets on the screen, interactively specifying their layout and other display properties such as fonts, line styles and labels.
Reference: [5] <editor> Inside Macintosh. </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachussetts, </address> <year> 1985. </year>
Reference-contexts: 1.0 Introduction User interface toolkits such as the X Toolkit [10] and the Macintosh Tool-Box <ref> [5] </ref> provide abstractions that make the construction of user interfaces significantly easier than programming using graphics primitives. Unfortunately the toolkits do not make the construction of user interfaces easy enough. <p> The program calls toolkit procedures to create the appropriate widget instances and passes in as parameters the values to fill in the widget slots. This is the method that many applications of the X toolkit [10] and the Macintosh toolbox <ref> [5] </ref> use. Even though the use of the toolkit saves a tremendous amount of effort, the job is sufficiently complex that the remaining tasks are still time-consuming and cumbersome. Since programming is involved, human factors experts are isolated from the iterative development cycle needed to construct good interfaces.
Reference: [6] <institution> KEE Software Development System Users Manual. KEE 3.0. </institution> <year> 1986. </year>
Reference-contexts: Ease of use can be increased by providing a development environment that borrows features from interactive interface builders, and knowledge-base development environments <ref> [6] </ref>. For example, template definition can be done interactively [7], examples of displays can be shown after each modification to a template, an interactive constraint editor such as Lapidary [12] can be used to define layout constraints.
Reference: [7] <author> K. Lai and T. Malone. </author> <title> Object Lens: A Spreadsheet for Cooperative Work. </title> <booktitle> In Proceedings of the Conference on Computer-Supported Cooperative Work, </booktitle> <pages> pages 115-124, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Ease of use can be increased by providing a development environment that borrows features from interactive interface builders, and knowledge-base development environments [6]. For example, template definition can be done interactively <ref> [7] </ref>, examples of displays can be shown after each modification to a template, an interactive constraint editor such as Lapidary [12] can be used to define layout constraints.
Reference: [8] <author> R. MacGregor. </author> <title> A Deductive Pattern Matcher. </title> <booktitle> In Proceedings of AAAI88, The National Conference on Artificial Intelligence, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: Humanoid assumes that applications are written using a frame-based knowledge representation system <ref> [8] </ref>. The application objects are represented as data structures with slots whose values can be either other objects, or primitive values such as numbers and strings. Hence, the run time state of an application is represented as a network of objects. <p> The selection algorithm makes use of predicate subsump-tion, a feature of the Loom knowledge representation language <ref> [8] </ref>. The basic idea is that for a restricted set of predicates, Loom can automatically determine whether one predicate subsumes another. Predicate subsumption is similar to the sub-type relation in the type hierarchies of object-oriented programming languages, except that the types can be fairly general predicates. <p> This feature of Loom, in conjunction with Humanoids selection algorithm makes the template library easier to maintain. 6.0 Implementation and Experience with Humanoid Humanoid is implemented in CommonLisp using the Loom knowledge representation language <ref> [8] </ref>, and the Garnet user interface toolkit [12]. Humanoid has been used to implement the interface for three applications: an inventory control system, an agenda management tool, and a knowledge base browser. An interface to Humanoid itself is under development.
Reference: [9] <author> J. Mackinlay. </author> <title> Automating the Design of Graphical Presentations of Relational Information. </title> <journal> ACM Transactions on Graphics, </journal> <pages> pages 110-141, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The inability of interface builders to specify methods of presentation rather than the presentation itself makes interface builders of little use for building the main windows of an application, which typically display objects that change at run time. Systems like APT <ref> [9] </ref> and II [2] are representative of systems that automatically generate displays. APT produces displays of quantitative data, and can produce results of quality comparable or better that the results produced by humans.
Reference: [10] <author> J. McCormack and P. Asente. </author> <title> An overview of the X toolkit. </title> <booktitle> In Proceedings of the ACM SIGGRAPH Symposium on User Interface Software, Banff, Al-berta, </booktitle> <pages> pages 46-55, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: 1.0 Introduction User interface toolkits such as the X Toolkit <ref> [10] </ref> and the Macintosh Tool-Box [5] provide abstractions that make the construction of user interfaces significantly easier than programming using graphics primitives. Unfortunately the toolkits do not make the construction of user interfaces easy enough. <p> The program calls toolkit procedures to create the appropriate widget instances and passes in as parameters the values to fill in the widget slots. This is the method that many applications of the X toolkit <ref> [10] </ref> and the Macintosh toolbox [5] use. Even though the use of the toolkit saves a tremendous amount of effort, the job is sufficiently complex that the remaining tasks are still time-consuming and cumbersome.
Reference: [11] <author> B. Myers et. al. </author> <title> The Garnet Toolkit Reference Manuals: Support for Highly-Interactive, Graphical User Interfaces in Lisp. </title> <type> Technical Report CMU-CS-89-196, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> November </month> <year> 1989. </year>
Reference: [12] <author> B. Myers, B. Vander Zanden and R. Dannenberg. </author> <title> Creating Graphical Interactive Application Objects by Demonstration. </title> <booktitle> In Proceedings of the ACM SIG-GRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 95-104, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: This feature of Loom, in conjunction with Humanoids selection algorithm makes the template library easier to maintain. 6.0 Implementation and Experience with Humanoid Humanoid is implemented in CommonLisp using the Loom knowledge representation language [8], and the Garnet user interface toolkit <ref> [12] </ref>. Humanoid has been used to implement the interface for three applications: an inventory control system, an agenda management tool, and a knowledge base browser. An interface to Humanoid itself is under development. <p> For example, template definition can be done interactively [7], examples of displays can be shown after each modification to a template, an interactive constraint editor such as Lapidary <ref> [12] </ref> can be used to define layout constraints.
Reference: [13] <author> D. Olsen. MIKE: </author> <title> The Menu Interaction Kontrol Environment. </title> <journal> ACM Transactions on Graphics, </journal> <volume> vol 17, no 3, </volume> <pages> pages 43-50, </pages> <year> 1986. </year>
Reference-contexts: APT produces displays of quantitative data, and can produce results of quality comparable or better that the results produced by humans. However, few automatic systems have been built to construct fully interactive displays of data that can change at run time. Systems like MIKE <ref> [13] </ref> and Chisel [15] are representative of systems that generate interactive interfaces automatically from a description of an applications objects and commands. The main shortcoming of these systems is that the interfaces generated are not of high enough quality.
Reference: [14] <institution> Prototyper Interface builder for the Macintosh. </institution> <note> Users Manual, </note> <year> 1989. </year>
Reference-contexts: Unfortunately the toolkits do not make the construction of user interfaces easy enough. The tasks of assembling the widgets to construct complex displays, and of tying the widgets to application data structures remains difficult and time consuming. Interactive user interface builder systems such as Prototyper <ref> [14] </ref> provide interactive what-you-see-is-what-you-get interfaces to assemble tool-box widgets into more complex interfaces. These tools are excellent for a restricted class of interfaces, which typically includes only menus and dialogue boxes. <p> Since programming is involved, human factors experts are isolated from the iterative development cycle needed to construct good interfaces. The main advantage of the programming approach is its great exibility in constructing any interface feature desired. Interactive interface builder systems such as Prototyper <ref> [14] </ref>, Cardellis interface builder [4] and Action [1] are tools whose goal is to eliminate programming from the interface construction process. Interface designers draw the widgets on the screen, interactively specifying their layout and other display properties such as fonts, line styles and labels.
Reference: [15] <author> G. Singh and M. Green. Chisel: </author> <title> A System for Creating Highly Interactive Screen Layouts. </title> <booktitle> In Proceedings of the ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 86-94, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: APT produces displays of quantitative data, and can produce results of quality comparable or better that the results produced by humans. However, few automatic systems have been built to construct fully interactive displays of data that can change at run time. Systems like MIKE [13] and Chisel <ref> [15] </ref> are representative of systems that generate interactive interfaces automatically from a description of an applications objects and commands. The main shortcoming of these systems is that the interfaces generated are not of high enough quality.
References-found: 15

