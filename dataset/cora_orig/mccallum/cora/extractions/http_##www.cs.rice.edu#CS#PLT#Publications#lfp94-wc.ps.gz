URL: http://www.cs.rice.edu/CS/PLT/Publications/lfp94-wc.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Email: fwright,cartwrightg@cs.rice.edu  
Title: A Practical Soft Type System for Scheme  
Author: Andrew K. Wright Robert Cartwright 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Soft typing is a generalization of static type checking that accommodates both dynamic typing and static typing in one framework. A soft type checker infers types for identifiers and inserts explicit run-time checks to transform untypable programs to typable form. Soft Scheme is a practical soft type system for R4RS Scheme. The type checker uses a representation for types that is expressive, easy to interpret, and supports efficient type inference. Soft Scheme supports all of R4RS Scheme, including uncurried procedures of fixed and variable arity, assignment, and continuations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiken, A., and Wimmers, E. L. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> Proceedings of the International Conference on Functional Programming Languages and Computer Architecture (1993), </booktitle> <pages> 31-41. </pages>
Reference-contexts: Furthermore, their representation does not support incremental definition of new type constructors, and type inference is not particularly efficient because simple types can have large representations. Aiken and Wimmers have recently developed a sophisticated soft type system for the functional language FL <ref> [1, 2] </ref>. Their system supports a rich type language including union types, recursive types, intersection types, conditional types, and subtype constraints. While it seems clear that their formal system assigns more precise types to some programs than our system does, their implementation discards some solutions for the sake of efficiency.
Reference: [2] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> Proceedings of the 21st Annual Symposium on Principles of Programming Languages (January 1994), </booktitle> <pages> 163-173. </pages>
Reference-contexts: Hence the standard algorithm cannot directly accommodate union types. We could base a polymorphic union type system on our presentation types and attempt to find an alternative method of inferring types. Aiken et al. <ref> [2] </ref> have pursued this approach, but its computational complexity is worse than Hindley-Milner typing. We elected instead to modify Hindley-Milner typing to accommodate union types and subtyping without compromising its computational complexity. <p> This type includes num, hence a run-time check is inserted. In contrast, the equivalent code: 8 (let ([x (if P 0 (cons 1 '()))]) (match x [(a . ) a] <ref> [ 2] </ref>)) couples the type test to the decomposition of x. By extending the type system to directly type pattern matching expressions, we avoid the unnecessary run-time check. <p> Furthermore, their representation does not support incremental definition of new type constructors, and type inference is not particularly efficient because simple types can have large representations. Aiken and Wimmers have recently developed a sophisticated soft type system for the functional language FL <ref> [1, 2] </ref>. Their system supports a rich type language including union types, recursive types, intersection types, conditional types, and subtype constraints. While it seems clear that their formal system assigns more precise types to some programs than our system does, their implementation discards some solutions for the sake of efficiency. <p> ;; ((arglist (list X1)) &gt;fl (list X1)) (define taut? ; test for a tautology (lambda (x) (match x [#t #t] [ (and (taut? (x #t)) (taut? (x #f)))]))) ;; (rec ([Y1 (+ false true ((+ false true) &gt; Y1))]) ;; (Y1 &gt; (+ false true))) ;; from Aiken and Wimmers <ref> [2] </ref> (define Y ; least fixed point combinator (lambda (f) (lambda (y) (((lambda (x) (f (lambda (z) ((x x) z)))) (lambda (x) (f (lambda (z) ((x x) z))))) y)))) (define last ; find last element of a list (Y (lambda (f) (lambda (x) (if (null? (cdr x)) (car x) ;; ((cons
Reference: [3] <author> Amadio, R. M., and Cardelli, L. </author> <title> Subtyping recursive types. </title> <booktitle> Proceedings of the 17th Annual Symposium on Principles of Programming Languages (Jan-uary 1990), </booktitle> <pages> 104-118. </pages>
Reference-contexts: The types assigned to program identifiers and expressions have label ;. We usually omit labels when writing types. Similarly, an implementation of type inference need not manipulate labels. Recursive types ff: t (which must have label ;) represent infinite regular trees <ref> [3] </ref>. The type ff: t binds ff in t ; the usual renaming rules apply to the bound variable ff, and we have ff: t = t [ff 7! ff: t ]. Recursive types must be formally contractive, i.e., phrases like ff: ff are not types.
Reference: [4] <author> Beer, R. D. </author> <title> Preliminary report on a practical type inference system for Common Lisp. Lisp Pointers 1, </title> <booktitle> 2 (1987), </booktitle> <pages> 5-11. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [4, 9, 13, 14, 15, 21] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [5] <author> Cartwright, R., and Fagan, M. </author> <title> Soft typing. </title> <booktitle> Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <pages> 278-292. </pages>
Reference-contexts: To ensure safety, programs that do not meet the stringent requirements of the type checker are ineligible for execution. In rejecting untypable programs, the type checker also rejects meaningful programs that it cannot prove are safe. Equivalent ty-pable programs are often longer and more complicated. Soft typing <ref> [5, 7] </ref> is a generalization of static type checking that accommodates both dynamic typing and static typing in one framework. <p> We have observed soft typed programs to run up to 3.3 times faster than ordinary dynamically typed programs. The type system underlying Soft Scheme is a refinement and extension of a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [5, 7] </ref>. Their system extends Hindley-Milner typing with limited union types, recursive types, and a modicum of subtyping as subset on union types. Soft Scheme includes several major extensions to their technical results. <p> Using immutable pairs when possible adequately addresses the problem for set-car! and set-cdr!. At present, we have no satisfactory solutions for global identifier assignments. 5 Related Work Our practical soft type system is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [5, 7] </ref>. Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an encoding technique Remy developed to reduce record subtyping to polymorphism [19].
Reference: [6] <editor> Clinger, W., Rees, J., et al. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <booktitle> ACM Lisp Pointers IV (July-September 1991). </booktitle>
Reference-contexts: 1 Introduction Dynamically typed languages like Scheme <ref> [6] </ref> permit program operations to be defined over any computable subset of the data domain. To ensure safe execution, 1 primitive operations confirm that their arguments belong to appropriate subsets called types. The types enforced by primitive operations induce types for defined operations. <p> Prototypes can then be transformed to more robust, maintainable, and efficient programs by rewriting them to accommodate better syntactic type assignment. We have developed a practical soft type system for R4RS Scheme <ref> [6] </ref>, a modern dialect of Lisp. Soft Scheme is based on an extension of the Hindley-Milner polymorphic type discipline that incorporates recursive types and a limited form of union type.
Reference: [7] <author> Fagan, M. </author> <title> Soft Typing: An Approach to Type Checking for Dynamically Typed Languages. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: To ensure safety, programs that do not meet the stringent requirements of the type checker are ineligible for execution. In rejecting untypable programs, the type checker also rejects meaningful programs that it cannot prove are safe. Equivalent ty-pable programs are often longer and more complicated. Soft typing <ref> [5, 7] </ref> is a generalization of static type checking that accommodates both dynamic typing and static typing in one framework. <p> We have observed soft typed programs to run up to 3.3 times faster than ordinary dynamically typed programs. The type system underlying Soft Scheme is a refinement and extension of a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [5, 7] </ref>. Their system extends Hindley-Milner typing with limited union types, recursive types, and a modicum of subtyping as subset on union types. Soft Scheme includes several major extensions to their technical results. <p> Using immutable pairs when possible adequately addresses the problem for set-car! and set-cdr!. At present, we have no satisfactory solutions for global identifier assignments. 5 Related Work Our practical soft type system is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [5, 7] </ref>. Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an encoding technique Remy developed to reduce record subtyping to polymorphism [19].
Reference: [8] <author> Gomard, C. K. </author> <title> Partial type inference for un-typed functional programs. </title> <booktitle> Proceedings of the 1990 ACM Conference on LISP and Functional Programming (June 1990), </booktitle> <pages> 282-287. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [8, 10, 18, 22, 23] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [9] <author> Heintze, N. </author> <title> Set based analysis of ML programs. </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-193, Carnegie Mellon University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [4, 9, 13, 14, 15, 21] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [10] <author> Henglein, F. </author> <title> Global tagging optimization by type inference. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> 205-215. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [8, 10, 18, 22, 23] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [11] <author> Hindley, R. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society 146 (December 1969), </journal> <pages> 29-60. </pages>
Reference-contexts: The types enforced by primitive operations induce types for defined operations. Scheme programmers typically have strong intuitive ideas about the types of program operations, but dynamically typed languages offer no tools to discover, verify, or express such types. Static type systems like the Hindley-Milner type discipline <ref> [11, 16] </ref> provide a framework to discover and express types. Static type checking detects certain errors prior to execution and enables compilers to omit many run-time type checks. Unfortunately, static type systems inhibit the freedom of expression enjoyed with dynamic typing.
Reference: [12] <author> Kaes, S. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> 193-204. </pages>
Reference-contexts: The extra bookkeeping required for this technique is minimal. The improvement in typing precision and the attendant reduction in run-time checking can be significant. We have also investigated several adaptations of structural subtyping <ref> [12, 17] </ref> to address the reverse flow problem. Structural subtyping is more powerful than encoding sub-typing with polymorphism as it permits subtyping at all function applications. By permitting more subtyping, soft type systems based on structural subtyping can infer more precise types.
Reference: [13] <author> Kaplan, M. A., and Ullman, J. D. </author> <title> A scheme for the automatic inference of variable types. </title> <journal> Journal of the Association for Computing Machinery 27, </journal> <month> 1 (January </month> <year> 1980), </year> <pages> 128-145. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [4, 9, 13, 14, 15, 21] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [14] <author> Kind, A., and Friedrich, H. </author> <title> A practical approach to type inference in EuLisp. </title> <booktitle> Lisp and Symbolic Computation 6, </booktitle> <month> 1/2 (August </month> <year> 1993), </year> <pages> 159-175. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [4, 9, 13, 14, 15, 21] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [15] <author> Ma, K. L., and Kessler, R. R. </author> <title> TICL|a type inference system for Common Lisp. </title> <journal> Software Practice and Experience 20, </journal> <month> 6 (June </month> <year> 1990), </year> <pages> 593-623. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [4, 9, 13, 14, 15, 21] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [16] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978), </journal> <pages> 348-375. </pages>
Reference-contexts: The types enforced by primitive operations induce types for defined operations. Scheme programmers typically have strong intuitive ideas about the types of program operations, but dynamically typed languages offer no tools to discover, verify, or express such types. Static type systems like the Hindley-Milner type discipline <ref> [11, 16] </ref> provide a framework to discover and express types. Static type checking detects certain errors prior to execution and enables compilers to omit many run-time type checks. Unfortunately, static type systems inhibit the freedom of expression enjoyed with dynamic typing.
Reference: [17] <author> Mitchell, J. C. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming 1, </journal> <month> 3 (July </month> <year> 1991), </year> <month> 245-286. </month> <title> Preliminary version in: Coercion and Type Inference, </title> <booktitle> Proc. 11th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> pp. 175-185. </pages>
Reference-contexts: The extra bookkeeping required for this technique is minimal. The improvement in typing precision and the attendant reduction in run-time checking can be significant. We have also investigated several adaptations of structural subtyping <ref> [12, 17] </ref> to address the reverse flow problem. Structural subtyping is more powerful than encoding sub-typing with polymorphism as it permits subtyping at all function applications. By permitting more subtyping, soft type systems based on structural subtyping can infer more precise types.
Reference: [18] <author> O'Keefe, P. M., and Wand, M. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proceedings of the Euro-pean Symposium on Programming, LNCS 582 (1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 408-417. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [8, 10, 18, 22, 23] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [19] <author> R emy, D. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> Proceedings of the 16th Annual Symposium on Principles of Programming Languages (January 1989), </booktitle> <pages> 77-87. </pages>
Reference-contexts: We elected instead to modify Hindley-Milner typing to accommodate union types and subtyping without compromising its computational complexity. To combine union types and subtyping with Hindley-Milner polymorphism, we adapt an encoding Remy developed for record subtyping <ref> [19, 20] </ref>. Our encoding permits many union types to be expressed as terms in a free algebra, as with conventional Hindley-Milner types. Flag variables enable polymorphism to encode subtyping as subset on union types. Types are inferred by a minor variant of the standard Hindley-Milner algorithm. <p> Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an encoding technique Remy developed to reduce record subtyping to polymorphism <ref> [19] </ref>. Their system represents union types in a different manner from ours, but their types can be viewed as the types of Section 3.2 with all type variables having label ;. This precludes type variables from appearing in unions.
Reference: [20] <author> R emy, D. </author> <title> Type inference for records in a natural extension of ML. </title> <type> Tech. Rep. 1431, </type> <institution> INRIA, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: We elected instead to modify Hindley-Milner typing to accommodate union types and subtyping without compromising its computational complexity. To combine union types and subtyping with Hindley-Milner polymorphism, we adapt an encoding Remy developed for record subtyping <ref> [19, 20] </ref>. Our encoding permits many union types to be expressed as terms in a free algebra, as with conventional Hindley-Milner types. Flag variables enable polymorphism to encode subtyping as subset on union types. Types are inferred by a minor variant of the standard Hindley-Milner algorithm.
Reference: [21] <author> Shivers, O. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <note> Also: Tech. Rep. CMU-CS-91-145. </note>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [4, 9, 13, 14, 15, 21] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [22] <author> Thatte, S. R. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, LNCS 317 (July 1988), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 615-629. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [8, 10, 18, 22, 23] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [23] <author> Thatte, S. R. </author> <title> Quasi-static typing. </title> <booktitle> Proceedings of the 17th Annual Symposium on Principles of Programming Languages (January 1990), </booktitle> <pages> 367-381. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [8, 10, 18, 22, 23] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [24] <author> Wright, A. K. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Tech. Rep. 93-200, </type> <institution> Rice University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Assignment and the continuation operator call/cc are important features of Scheme. There are several solutions to typing assignment and continuations in a polymorphic framework. Our prototype uses the simplest method which restricts polymorphism to let-expressions where the bound expression is a syntactic value <ref> [24] </ref>. For Scheme, all expressions are values except those that contain an application of a non-primitive procedure or an "impure" primitive (like cons or call/cc).
Reference: [25] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> To appear in: Information and Computation, 1994. 13 </note>
Reference-contexts: Theorem 3.1 (Type Soundness) If ; ` e : t then either e diverges, or e !7! check, or e !7! v and ; ` v : t . Proof. We use Wright and Felleisen's technique based on subject reduction <ref> [25] </ref>. 3.4 Soft Type Checking The preceding static type system can be used to statically type check Core Scheme programs. The type system will reject programs that contain incorrect uses of unchecked primitives, ensuring safe execution.
References-found: 25

