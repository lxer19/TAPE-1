URL: http://www.research.digital.com/SRC/personal/monika/papers/monika-focs92.ps.gz
Refering-URL: http://www.research.digital.com/SRC/personal/monika/papers.html
Root-URL: http://www.research.digital.com
Title: Fully Dynamic Biconnectivity in Graphs input is a plane graph, the amortized running time for
Author: M. R. Henzinger 
Note: To appear in Algorithmica  If the  
Abstract: We present an algorithm for maintaining the biconnected components of a graph during a sequence of edge insertions and deletions. It requires linear storage and preprocessing time. The amortized running time for insertions and for deletions is O(m 2=3 ), where m is the number of edges in the graph. Any query of the form "Are the vertices u and v biconnected?" can be answered in time O(1). This is the first sublinear algorithm for this problem. We can also output all articulation points separating any two vertices efficiently. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, J. D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: 1 Introduction An undirected graph G = (V; E) is biconnected if there are at least two vertex-disjoint paths from each vertex to every other vertex. It is well known <ref> [1] </ref> that a graph G is not biconnected if and only if there is a vertex whose removal disconnects G. Such a vertex is called an articulation point of G. A graph that is not biconnected is naturally partitioned into biconnected components or blocks. <p> E 1 ; : : :; E h be a partition of E into equivalence classes such that two edges e and e 0 lie in the same class if and only if either e = e 0 or there is a simple cycle containing both e and e 0 <ref> [1] </ref>. For 1 i h, let V i be the set of vertices of the edges in E i . Each subgraph G i = (V i ; E i ) is called a biconnected component or block of G. Every edge belongs to exactly one biconnected component.
Reference: [2] <author> B. Alpern, R. Hoover, B. Rosen, P. Sweeney, and F. K. Zadeck, </author> <title> "Incremental Evaluation of Computational Circuits" Proc. </title> <booktitle> 1st Annual ACM-SIAM Symposioum on Discrete Algorithms, </booktitle> <year> 1990, </year> <pages> 32-42. </pages>
Reference-contexts: Email:mhr@cs.cornell.edu. Au thor's maiden name: M. Rauch 1 The fully dynamic version of the problem allows both insertions and deletions of edges. It is harder than the versions that allow only insertions or only deletions. Dynamic graph algorithms have applications in communication networks, computer-aided design <ref> [2] </ref>, database systems [20], logic programming [3], and incremental data flow analysis [4]. Frederickson [9] gave an algorithm for maintaining 2-edge-connected components in a graph which takes O ( p m) time per update, where m is the number of edges in the graph.
Reference: [3] <author> G . Ausiello, G. F. </author> <title> Italiano, "On-line Algorithms for Polynomially Solvable Satisfiability Problems" J. </title> <booktitle> Logic Programming, 10 (1991), </booktitle> <pages> 69-90. </pages>
Reference-contexts: Rauch 1 The fully dynamic version of the problem allows both insertions and deletions of edges. It is harder than the versions that allow only insertions or only deletions. Dynamic graph algorithms have applications in communication networks, computer-aided design [2], database systems [20], logic programming <ref> [3] </ref>, and incremental data flow analysis [4]. Frederickson [9] gave an algorithm for maintaining 2-edge-connected components in a graph which takes O ( p m) time per update, where m is the number of edges in the graph.
Reference: [4] <author> M. D. Carrol, B. G. Ryder, </author> <title> "Incremental Data Flow Analysis via Dominator and Attribute Updates" Proc. </title> <booktitle> 15th Annueal ACM SIGACT-SIGPLAN SYmpos. on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 274-284. </pages>
Reference-contexts: It is harder than the versions that allow only insertions or only deletions. Dynamic graph algorithms have applications in communication networks, computer-aided design [2], database systems [20], logic programming [3], and incremental data flow analysis <ref> [4] </ref>. Frederickson [9] gave an algorithm for maintaining 2-edge-connected components in a graph which takes O ( p m) time per update, where m is the number of edges in the graph.
Reference: [5] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Planar Graph" Proc. </title> <booktitle> 1st Annual Symp. on Discrete Algorithms 1990, </booktitle> <address> 1 -11. </address>
Reference-contexts: If G is plane, the data structure of Eppstein et al. <ref> [5] </ref> for fully-dynamic connectivity testing in plane graphs is applied to every graph of a local data structure.
Reference: [6] <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> "Sparsification A technique for speeding up dynamic graph algorithms" Proc. </title> <booktitle> 33nd Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1992. </year>
Reference: [7] <author> D. Eppstein, Z. Galil, G. F. </author> <title> Italiano, "Improved Sparsification", </title> <type> Technical Report 93-20, </type> <institution> Dept. of Information and Computer Science, University of California, </institution> <address> Irvine, CA, </address> <year> 1993. </year>
Reference-contexts: Frederickson [9] gave an algorithm for maintaining 2-edge-connected components in a graph which takes O ( p m) time per update, where m is the number of edges in the graph. This bound was consequently reduced to O ( p Eppstein et al. <ref> [7] </ref>, and to O (log 6 n) by Henzinger and King [12]. The running time for maintaining 2-edge-connected components in an embedded planar graph was also improved to O (log 2 n) [13]. We call an embedded planar graph a plane graph. <p> We give an algorithm for general graphs with O (m 2=3 ) amortized update time and O (1) query time. In a later paper we reduce the update time further to O ( p m) [16]. Independently Eppstein et al. <ref> [7] </ref> have developed an algorithm for this problem whose running time per update operation is O (n) and whose running time per query is O (1). They use a general technique to speed up dynamic graph algorithms.
Reference: [8] <author> G. N. Frederickson, </author> <title> "Data Structures for On-line Updating of Minimum Spanning Trees" SIAM J. </title> <journal> Comput. </journal> <volume> 14 (1985), </volume> <pages> 781-798. </pages>
Reference-contexts: It allows us to maintain a plane graph under a sequence of insertions and deletions of edges while at the same time answering queries of the form: "Are u and v connected?" in time O (log n). In the case of a general graph, the data structure of Frederickson <ref> [8] </ref> for fully-dynamic connectivity testing in general graphs is applied to every graph in a local data structure. <p> Since each vertex is contained in at most two look-up data structures, there are at most four such data structures. As shown in <ref> [8] </ref> it takes time O (k) to maintain a topological partition of order k, the graph of groups, and the group pointers at the vertices after an insertion or deletion.
Reference: [9] <author> G. N. Frederickson, </author> <title> "Ambivalent Data Structures for Dynamic 2-edge-connectivity and k smallest spanning trees" Proc. </title> <booktitle> 32nd Annual IEEE Sympos. </booktitle> <institution> on Foundation of Comput. Sci., </institution> <year> 1991, </year> <pages> 632-641. </pages>
Reference-contexts: It is harder than the versions that allow only insertions or only deletions. Dynamic graph algorithms have applications in communication networks, computer-aided design [2], database systems [20], logic programming [3], and incremental data flow analysis [4]. Frederickson <ref> [9] </ref> gave an algorithm for maintaining 2-edge-connected components in a graph which takes O ( p m) time per update, where m is the number of edges in the graph. <p> Next we find a partition of G 0 along the lines of <ref> [9] </ref>. A cluster with respect to T is a set of vertices such that the subgraph of T induced on the cluster is connected. The external degree of a cluster is the number of tree edges with precisely one endpoint in the cluster. <p> Thus clusters with external degree 3 are not incident to non-tree edges. Figure 3 depicts a restricted partition of order 4. The number of clusters in a restricted partition of order k is fi (m=k). A restricted partition can be found in time O (m + n) <ref> [9] </ref>. We extend this definition slightly in the following way: An edge with exactly one endpoint in a cluster C is called incident to C. We require that all dashed edges incident to a cluster belong to the same vertex of G.
Reference: [10] <author> Z. Galil, G. F. </author> <title> Italiano, "Maintaining Biconnected Components of Dynamic Planar Graphs" Proc. </title> <booktitle> 18th ICALP, Lecture Notes in Computer Science, </booktitle> <volume> Vol., </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991, </year> <pages> 339-350. </pages>
Reference-contexts: For a plane graph we achieve O ( p n log n) time per update and O (log 2 n) time per query operation. The best previously known solution requires time O (n 2=3 ) per update or query operation <ref> [10] </ref>. Our algorithm uses linear space and preprocessing time. Eppstein et al. [14] improve the running time for this problem to O ( p The new techniques for fully dynamic graph algorithms introduced in this paper involve pre-computation and "lazy" updating.
Reference: [11] <author> F. Harary, </author> <title> Graph Theory, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: To split the graph into small connected subgraphs, we use a graph of bounded degree. We apply a well-known transformation <ref> [11] </ref> to map G to a graph G 0 , whose vertices have degree no 3 greater than 3. We replace a vertex x of G of degree d 4 by d new vertices x 1 ; : : :; x d . <p> Whenever an artificial edge changes, we recompute the blocks of this graph of size O (d). Now we describe the details. The block tree of G 1 (C) <ref> [11] </ref> consists of a round node for each block of G 1 (C) and a square node for each vertex of G 1 (C).
Reference: [12] <author> M. R. Henzinger, V. King, </author> <title> "Randomized Dynamic Algorithms with Polylogarithmic Time per Operation". </title> <booktitle> To appear in Proc. 27th Annual ACM Sympos. on Theory of Computing </booktitle>
Reference-contexts: This bound was consequently reduced to O ( p Eppstein et al. [7], and to O (log 6 n) by Henzinger and King <ref> [12] </ref>. The running time for maintaining 2-edge-connected components in an embedded planar graph was also improved to O (log 2 n) [13]. We call an embedded planar graph a plane graph. Maintaining blocks adds complications since, unlike 2-edge-connectivity, biconnectivity is not an equivalence relation on the vertices of a graph.
Reference: [13] <author> J. Hershberger, M. Rauch, S. Suri, </author> <title> "Fully Dynamic 2-Edge-Connectivity in Planar Graphs" Proc. </title> <booktitle> 3rd Scandinavian Workshop on Algorithm Theory, </booktitle> <publisher> LNCS 621, Springer-Verlag, </publisher> <year> 1992, </year> <pages> 233-244. </pages>
Reference-contexts: This bound was consequently reduced to O ( p Eppstein et al. [7], and to O (log 6 n) by Henzinger and King [12]. The running time for maintaining 2-edge-connected components in an embedded planar graph was also improved to O (log 2 n) <ref> [13] </ref>. We call an embedded planar graph a plane graph. Maintaining blocks adds complications since, unlike 2-edge-connectivity, biconnectivity is not an equivalence relation on the vertices of a graph.
Reference: [14] <author> G. </author> <title> Italiano, </title> <type> private communication. </type>
Reference-contexts: The best previously known solution requires time O (n 2=3 ) per update or query operation [10]. Our algorithm uses linear space and preprocessing time. Eppstein et al. <ref> [14] </ref> improve the running time for this problem to O ( p The new techniques for fully dynamic graph algorithms introduced in this paper involve pre-computation and "lazy" updating.
Reference: [15] <author> M. Rauch, </author> <title> "Fully Dynamic Biconnectivity in Graphs", </title> <booktitle> Proc. 33nd Annual IEEE Sympos. </booktitle> <institution> on Foundation of Comput. Sci., </institution> <year> 1992, </year> <pages> 50-59. </pages>
Reference: [16] <author> M. Rauch, </author> <title> "Improved Data Structures for Fully Dynamic Biconnectivity", </title> <booktitle> Proc. 26nd Annual ACM Sympos. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> 686-695. </pages>
Reference-contexts: We give an algorithm for general graphs with O (m 2=3 ) amortized update time and O (1) query time. In a later paper we reduce the update time further to O ( p m) <ref> [16] </ref>. Independently Eppstein et al. [7] have developed an algorithm for this problem whose running time per update operation is O (n) and whose running time per query is O (1). They use a general technique to speed up dynamic graph algorithms.
Reference: [17] <author> D. D. Sleator, R. E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees" J. </title> <journal> Comput. System Sci. </journal> <volume> 24 (1983), </volume> <pages> 362-381. </pages>
Reference-contexts: Thus all this information can be computed in time O ((m=k) 2 ). This method is too expensive in the plane case. Instead we keep two dynamic trees, one for the spanning trees of G and one for the spanning tree of H. A dynamic tree <ref> [17] </ref> represents a rooted tree by solid and dashed edges. At most two edges incident to a vertex are solid. To avoid confusion with the dashed edges in our data structure we call the dashed edges in dynamic trees dotted edges.
Reference: [18] <author> R. E. Tarjan, </author> <title> "Depth First Search and Linear Graph Algorithms" SIAM J. </title> <journal> Comput. </journal> <volume> 1 (1972), </volume> <pages> 146-160. </pages>
Reference-contexts: Similarly a graph is 2-edge-connected it there are at least two edge-disjoint paths from each vertex to every other vertex. An edge whose removal disconnects G is called a bridge. Note that biconnectivity implies 2-edge connectivity, but not the other way around. Tarjan <ref> [18] </ref> gave a linear time algorithm for computing the biconnected components and the 2-edge-connected components of a graph. Westbrook and Tarjan [19] solved the problem of maintaining biconnected components under a sequence of edge insertions. <p> We denote by G (u; v) the spanning tree path from u to v in G. If G is understood, we use (u; v). Note that the definition always refers to the same T . We will make use of certain tree traversals like preorder and postorder traversal <ref> [18] </ref>. We call two adjacent tree edges (w; x) and (x; y) covered if there exists a path from w to y that does not contain x. Otherwise, the two tree edges are called uncovered.
Reference: [19] <author> R. E. Tarjan, J. Westbrook, </author> <title> "Maintaining bridge-connected and biconnected components on-line" Algorithmica 7 (1992), </title> <type> 433-464. </type>
Reference-contexts: An edge whose removal disconnects G is called a bridge. Note that biconnectivity implies 2-edge connectivity, but not the other way around. Tarjan [18] gave a linear time algorithm for computing the biconnected components and the 2-edge-connected components of a graph. Westbrook and Tarjan <ref> [19] </ref> solved the problem of maintaining biconnected components under a sequence of edge insertions. The running time for m insertions intermixed with queries of the form: "Are the vertices u and v biconnected?" is O (mff (m; n)), where n is the number of vertices in the graph.
Reference: [20] <author> M. Yannakakis, </author> <title> "Graph Theoretic Methods in Database Theory" Proc. </title> <booktitle> of the ACM Conference on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> 230-242. 38 </pages>
Reference-contexts: Email:mhr@cs.cornell.edu. Au thor's maiden name: M. Rauch 1 The fully dynamic version of the problem allows both insertions and deletions of edges. It is harder than the versions that allow only insertions or only deletions. Dynamic graph algorithms have applications in communication networks, computer-aided design [2], database systems <ref> [20] </ref>, logic programming [3], and incremental data flow analysis [4]. Frederickson [9] gave an algorithm for maintaining 2-edge-connected components in a graph which takes O ( p m) time per update, where m is the number of edges in the graph.
References-found: 20

