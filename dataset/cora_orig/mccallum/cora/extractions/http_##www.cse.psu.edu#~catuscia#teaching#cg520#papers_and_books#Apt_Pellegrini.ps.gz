URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/papers_and_books/Apt_Pellegrini.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/references.html
Root-URL: http://www.cse.psu.edu
Title: On the Occur-check Free Prolog Programs  
Author: Krzysztof R. Apt and Alessandro Pellegrini 
Keyword: Categories and Subject Descriptors: D.2.4 [Software engineering]: Program verification|correctness proofs; D.3.4 [Programming languages]: Processors|preprocessors; I.2.3 [Artificial intelligence]: Deduction and theorem proving|logic programming General terms: Languages Additional Key Words and Phrases: unification algorithm, Prolog programs, occur-check problem, moded programs  
Address: Amsterdam  
Affiliation: CWI and University of  Universita di Padova  
Abstract: In most Prolog implementations for the efficiency reasons so-called occur-check is omitted from the unification algorithm. We provide here natural syntactic conditions which allow the occur-check to be safely omitted. The established results apply to most well-known Prolog programs, including those that use difference-lists, and seem to explain why this omission does not lead in practice to any complications. When applying these results to general programs we show their usefulness for proving absence of floundering. Finally, we propose a program transformation which transforms every program into a program for which only the calls to the built-in unification predicate need to be resolved by a unification algorithm with the occur-check. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> L. Albert, R. Casas, and F. Fages. </author> <title> Average case analysis of unification algorithms. </title> <journal> Theoretical Computer Science, </journal> <volume> 113(1, </volume> 24):3-34, 1993. 
Reference-contexts: An example is the concatenation of the lists by means of the difference-list representation. (For a thorough analysis of the time complexity of the unification algorithm with and without the occur-check see Albert, Casas and Fages <ref> [1] </ref>.) By omitting the occur-check in (5) and deleting action (6) from the Martelli-Montanari algorithm we are still left with two options depending on whether the substitution fx=tg is performed in t itself. <p> Moreover, the nondeterminism built into the Martelli-Montanari algorithm allows us to model executions of various other unification algorithms, On the Occur-check Free Prolog Programs 5 including Robinson's algorithm (see e.g. Albert, Casas and Fages <ref> [1] </ref>). In contrast, no specific unification algorithm in the definition of the LD-resolution is assumed. By Theorem 2.2 if a considered system of equations is unifiable, then it is NSTO, as well. Thus the property of being occur-check free rests exclusively upon those considered systems which are not unifiable. <p> Definition 4.1. |A goal p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called well-moded if for i 2 <ref> [1; n] </ref> Var (s i ) j=1 |A clause p 0 (t 0 ; s n+1 ) p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called well-moded if for i 2 [1; n + 1] Var (s i ) <p> is called well-moded if for i 2 [1; n] Var (s i ) j=1 |A clause p 0 (t 0 ; s n+1 ) p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called well-moded if for i 2 <ref> [1; n + 1] </ref> Var (s i ) j=0 |A program is called well-moded if every clause of it is. 2 On the Occur-check Free Prolog Programs 9 Thus, a goal is well-moded if |every variable occurring in an input position of an atom (i 2 [1; n]) occurs in an <p> if for i 2 [1; n + 1] Var (s i ) j=0 |A program is called well-moded if every clause of it is. 2 On the Occur-check Free Prolog Programs 9 Thus, a goal is well-moded if |every variable occurring in an input position of an atom (i 2 <ref> [1; n] </ref>) occurs in an output position of an earlier (j 2 [1; i 1]) atom. And a clause is well-moded if |(i 2 [1; n]) every variable occurring in an input position of a body atom occurs either in an input position of the head (j = 0), or in <p> j=0 |A program is called well-moded if every clause of it is. 2 On the Occur-check Free Prolog Programs 9 Thus, a goal is well-moded if |every variable occurring in an input position of an atom (i 2 [1; n]) occurs in an output position of an earlier (j 2 <ref> [1; i 1] </ref>) atom. And a clause is well-moded if |(i 2 [1; n]) every variable occurring in an input position of a body atom occurs either in an input position of the head (j = 0), or in an output position of an earlier (j 2 [1; i 1]) body <p> 2 On the Occur-check Free Prolog Programs 9 Thus, a goal is well-moded if |every variable occurring in an input position of an atom (i 2 <ref> [1; n] </ref>) occurs in an output position of an earlier (j 2 [1; i 1]) atom. And a clause is well-moded if |(i 2 [1; n]) every variable occurring in an input position of a body atom occurs either in an input position of the head (j = 0), or in an output position of an earlier (j 2 [1; i 1]) body atom, |(i = n + 1) every variable occurring in an output <p> earlier (j 2 <ref> [1; i 1] </ref>) atom. And a clause is well-moded if |(i 2 [1; n]) every variable occurring in an input position of a body atom occurs either in an input position of the head (j = 0), or in an output position of an earlier (j 2 [1; i 1]) body atom, |(i = n + 1) every variable occurring in an output position of the head occurs in an input position of the head (j = 0), or in an output position of a body atom (j 2 [1; n]). <p> an output position of an earlier (j 2 [1; i 1]) body atom, |(i = n + 1) every variable occurring in an output position of the head occurs in an input position of the head (j = 0), or in an output position of a body atom (j 2 <ref> [1; n] </ref>). A test whether a goal or clause is well-moded can be efficiently performed by noting that a goal G is well-moded iff every first from the left occurrence of a variable in G is within an output position. <p> formulation are ours.) Definition 5.1. |A goal p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called nicely moded if t 1 ; : : : ; t n is a linear family of terms and for i 2 <ref> [1; n] </ref> Var (s i ) " ( j=i |A clause p 0 (s 0 ; t 0 ) p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called nicely moded if p 1 (s 1 ; t 1 ); <p> Definition 7.6. Let P be a program. |A goal p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called weakly moded w.r.t. P if for i 2 <ref> [1; n] </ref> Var (s i ) j=1 ); where p i 1 (s i 1 ; t i 1 ; t i k ) are all the atoms among p 1 (s 1 ; t 1 ); : : :; p i1 (s i1 ; t i1 ) which are well-moded <p> P if for i 2 <ref> [1; n] </ref> Var (s i ) Var (s 0 ) [ j=1 ); where p i 1 (s i 1 ; t i 1 ; t i k ) are all the atoms among p 1 (s 1 ; t 1 ); : : :; p i1 (s i1 ; t <p> P if |every variable occurring in an input position of an atom occurs in an output position of an earlier, well-moded in P , atom. And a clause is weakly moded w.r.t. P if |(i 2 <ref> [1; n] </ref>) every variable occurring in an input position of a body atom occurs either in an input position of the head, or in an output position of an earlier body atom, which is well-moded in P . 20 Krzysztof R. <p> Now, we generalize the notion of well-modedness to general programs and general goals by simply allowing in Definition 4.1 the negation symbol to occur in front of any atom p i (s i ; t i ), where i 2 <ref> [1; n] </ref>. Theorem 4.2 easily generalizes to general programs and general goals. More precisely, we have the following result. Theorem 8.4. Consider a general program P and a general goal G. Let P and G be well-moded. Then all LDNF-derivations of P [ fGg are data driven. Proof.
Reference: 2. <author> K. R. Apt. </author> <title> Logic programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 493-574. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <note> Vol. </note> <author> B. </author> <title> On the Occur-check Free Prolog Programs 31 </title>
Reference-contexts: We allow in programs various first-order built-in's, like =, , &gt;, etc, and assume that they are resolved in the way conforming to their interpretation. Throughout the paper we use the standard notation of Lloyd [18] and Apt <ref> [2] </ref>. In particular, given a syntactic construct E (so for example, a term, an atom or a set of equations) we denote by Var (E) the set of the variables appearing in E.
Reference: 3. <author> K. R. Apt and A. Pellegrini. </author> <title> Why the occur-check is not a problem. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proceedings of the Fourth International Symposium on Programming Language Implementation and Logic Programming (PLILP 92), Lecture Notes in Computer Science 631, </booktitle> <pages> pages 69-86, </pages> <address> Berlin, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This research carried out partly during the second author's stay at Centre for Mathematics and Computer Science, Amsterdam. His stay was supported by the 2060 th District of the Rotary Foundation, Italy. A shorter version of this paper appeared as <ref> [3] </ref>. Authors' current addresses: Krzysztof R. Apt CWI P.O.
Reference: 4. <author> K.R. Apt and K. Doets. </author> <title> A new definition of SLDNF-resolution. ILLC Prepublication Series CT-92-03, </title> <institution> Department of Mathematics and Computer Science, University of Amsterdam, </institution> <address> The Netherlands, </address> <year> 1992. </year> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: SLDNF-tree, which comprises all SLDNF-derivations exists. (The definition provided in Lloyd [18] is for this purpose too restrictive | for example for the program P = fp pg and the general goal G = :p no SLDNF-derivation or tree exists.) Such a definition was recently given in Apt and Doets <ref> [4] </ref>. Here we only need to know what are the general goals which can appear in an LDNF-derivation of P [ fGg. This leads us to the following definition, where for a general goal H and a literal L, H fLg stands for the result of removing L from H. <p> 2 G P;G , (iii) if H 2 G P;G and the first literal, L, of H is negative and ground, then H fLg 2 G P;G , (iv) if H is ground, then H 2 G P;G . 2 Using the definition of SLDNF-resolution provided in Apt and Doets <ref> [4] </ref> it is straightforward to prove the following lemma whose proof we omit. Lemma 8.2. Consider an LDNF-derivation of P [ fGg. Every general goal which appears in belongs to G P;G . 2 When computing with general programs one of the complications is so-called floundering.
Reference: 5. <author> K.R. Apt, P. van Emde Boas, and A. Welling. </author> <title> The NSTO problem is CoNP-Complete. ILLC prepublication series, </title> <institution> Department of Mathematics and Computer Science, University of Amsterdam, </institution> <address> The Netherlands, </address> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: As expected, the property of being occur-check free is undecidable (see Deransart and Maluszynski [14] and for a strengthened version the appendix). On the other hand, the problem whether a set of equations is NSTO, is decidable. In fact, Apt, van Emde Boas and Welling <ref> [5] </ref> recently proved that this problem is CoNP-complete. For further analysis we need the following concepts.
Reference: 6. <author> J. Beer. </author> <title> The occur-check problem revisited. </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 243-261, </pages> <year> 1988. </year>
Reference-contexts: This approach deals with the problem of inserting occur-checks at the source level and is orthogonal to that of Beer <ref> [6] </ref> who proposed to use a revised implementation in which a new tag in the Warren Abstract Machine is used. This tag maintains information about the context in which a variable is used.
Reference: 7. <author> A. Bossi and N. Cocco. </author> <title> Basic transformation operations for logic programs which preserve computed answer substitutions. </title> <type> Technical Report 16, </type> <institution> Dipartimento di Matematica Pura ed Applicata, Universita di Padova, </institution> <year> 1990. </year>
Reference-contexts: Proof. By construction and Theorem 10.1. 2 As behaviour of an unfolded program is closely related to the original program (see e.g. Bossi and Cocco <ref> [7] </ref>), it is indeed justified to summarize this result by saying that every program and goal is equivalent to a nicely moded program and nicely moded goal such that the heads of all clauses, except X = oc X, are input linear.
Reference: 8. <author> R. Chadha and D.A. Plaisted. </author> <title> Correctness of unification without occur check in Prolog. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of North Carolina, Chapel Hill, N.C., </institution> <year> 1991. </year>
Reference-contexts: We use here a result of Deransart, Ferrand and Teguia [13] and build upon it within the context of moded programs. This allows us to extend the results of Deransart and Maluszynski [14], to simplify the arguments of Chadha and Plaisted <ref> [8] </ref> and to offer a uniform presentation. Additionally, the results of the former paper needed here are proved directly, without resorting to the techniques of the attribute grammars theory, The work of the first author was partly supported by ESPRIT Basic Research Action 6810 (Com-pulog 2). <p> Then P [ fGg is occur-check free. Proof. Let A and H be as in the proof of Theorem 3.5. The NSTO via Modes Lemma 3.3 applies and yields that A = H is NSTO. 2 This theorem is implicit in Chadha and Plaisted <ref> [8] </ref> (see the proof of their Theorem 2.2). Clearly, through different "distributions" of the conditions of the NSTO via Modes Lemma 3.3 other applications can be obtained. We found the above two least restrictive. <p> To alleviate this 12 Krzysztof R. Apt and Alessandro Pellegrini restriction we now consider some syntactic restrictions that imply the conditions of Theorem 3.7. The following notion was introduced in Chadha and Plaisted <ref> [8] </ref>. (We found essentially the same concept independently, though later; the name and formulation are ours.) Definition 5.1. |A goal p 1 (s 1 ; t 1 ); : : :; p n (s n ; t n ) is called nicely moded if t 1 ; : : : ; <p> Let P and G be nicely moded. Suppose that |the head of every clause of P is input linear. Then P [ fGg is occur-check free. Proof. By Theorems 3.7 and 5.2. 2 This corollary is stated in Chadha and Plaisted <ref> [8] </ref> as a direct consequence of Theorem 3.7 without mentioning Theorem 5.2. In our opinion the latter theorem is necessary to draw the above conclusion. <p> We shall see later that in presence of difference-lists there is no clear intuition either about the modes of certain positions in the relations. Consequently, as noted by Chadha and Plaisted <ref> [8] </ref>, to apply Corollary 5.4 it is probably more natural to investigate first all the modings for which the program is nicely moded and the heads of all clauses are input linear. Then one should check for which modings the given goal is nicely moded. <p> Then one should check for which modings the given goal is nicely moded. To this end Chadha and Plaisted <ref> [8] </ref> proposed two efficient algorithms for generating modings with the minimal number of input positions, for which the program is nicely moded. These algorithms were implemented and applied to a number of well-known Prolog programs. <p> However, reconsider the program palindrome. In Chadha and Plaisted <ref> [8] </ref> it is shown that no moding exists in which palindrome is nicely moded with the heads of all clauses being input linear. Thus Corollary 5.4 cannot be applied to this program. 2 6. STRICTLY MODED PROGRAMS Next, we consider syntactic restrictions that imply the condition of Theorem 3.9. <p> For example, he reports that 49 occur-checks were invoked for the quicksort program. 11. CONCLUDING REMARKS We provided here a systematic account of an approach for proving occur-check freedom of Prolog programs based on syntactic analysis. In this approach, also advocated by Chadha and Plaisted <ref> [8] </ref>, it is shown that existence of specific relationships between the variables of the goal and the variables of the program implies occur-check freedom. As a side effect we also explained how this approach can be used to prove absence of floundering.
Reference: 9. <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: Clearly, through different "distributions" of the conditions of the NSTO via Modes Lemma 3.3 other applications can be obtained. We found the above two least restrictive. It is useful to note that the theorems established above generalize the following well-known result stated in Clark <ref> [9, page 15] </ref> and established in Deransart, Ferrand and Teguia [13] as a direct consequence of the NSTO Lemma 2.9. Corollary 3.8. Suppose that |the head of every clause of P is linear. Then P [ fGg is occur-check free for every goal G. Proof. <p> We also show here that the concept of well-modedness can be used to prove absence of floundering, i.e. selection of a negative, non-ground literal in a derivation. First, we need to extend the basic definitions. By the LDNF-resolution we mean the SLDNF-resolution of Clark <ref> [9] </ref> with the leftmost selection rule. When studying 22 Krzysztof R.
Reference: 10. <author> H.B. Curry and R. Feys. </author> <title> Combinatory Logic, Volume I, Studies in Logic and the Foundation of Mathematics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: The following delightful example offered to us by On the Occur-check Free Prolog Programs 27 Dino Pedreschi (private communication) shows that it is not so. Consider the typed lambda calculus and Curry's system of type assignment (see Curry and Feys <ref> [10] </ref>). It involves statements of the form x : t which should be read as "term x has type t". Finite sequences of such statements are denoted below by R.
Reference: 11. <author> H. Decker. </author> <title> On generalized cover axioms. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 693-707, </pages> <address> Paris, France, 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: general clauses are output linear, so for a,e ground, sink [ f sink (a, e)g is occur-check free and does not flounder. 2 The usual approach to prove absence of floundering by syntactic means concentrates on SLDNF-resolution and is based on various generalizations of the concept of allowedness (see Decker <ref> [11] </ref> for the strongest results in this direction). However, these techniques in general cannot be applied LDNF-resolution which employs a more specific notion of flounderning. Using Lemma 8.2 it is also possible to generalize the results on nicely and strictly moded programs (viz.
Reference: 12. <author> P. Dembinski and J. Maluszynski. </author> <title> AND-parallelism with intelligent backtracking for annotated logic programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 29-38, </pages> <address> Boston, </address> <year> 1985. </year>
Reference-contexts: The original formulation of this lemma is slightly stronger, but for our purposes the above version is sufficient. 3. MODED PROGRAMS For a further analysis we introduce modes, first considered in Mellish [21], and more extensively studied in Reddy [23] and Dembinski and Maluszynski <ref> [12] </ref>. 6 Krzysztof R. Apt and Alessandro Pellegrini Definition 3.1. Consider an n-ary relation symbol p. By a mode for p we mean a function d p from f1; : : :; ng to the set f+; g. <p> The proofs for the remaining three cases are analogous and omitted. 2 On the Occur-check Free Prolog Programs 7 We now prove two results allowing us to conclude that P [fGg is occur-check free. The first one uses the following notion introduced in Dembinski and Maluszynski <ref> [12] </ref>. Definition 3.4. We call an LD-derivation data driven if all atoms selected in it are ground in their input positions. 2 Theorem 3.5. Suppose that |the head of every clause of P is output linear, |all LD-derivations of P [ fGg are data driven. <p> We then show that these restrictions are satisfied by a number of well-known programs. We use here the notion of a well-moded program. The concept is due to Dembin-ski and Maluszynski <ref> [12] </ref>; we use here an elegant formulation due to Rosenblueth [25] (which is equivalent to that of Drabent [15] where well-moded programs are called simple). The definition of a well-moded program constrains the "flow of data" through the clauses of the programs. <p> The definition of a well-moded program is designed in such a way that the following theorem due to Dembinski and Maluszynski <ref> [12] </ref> holds. Theorem 4.2. Let P and G be well-moded. Then all LD-derivations of P [ fGg are data driven. In Dembinski and Maluszynski [12] a different formulation of well-modedness is given and the above theorem is actually presented without a proof. <p> The definition of a well-moded program is designed in such a way that the following theorem due to Dembinski and Maluszynski <ref> [12] </ref> holds. Theorem 4.2. Let P and G be well-moded. Then all LD-derivations of P [ fGg are data driven. In Dembinski and Maluszynski [12] a different formulation of well-modedness is given and the above theorem is actually presented without a proof. So we allow ourselves to give a proof here.
Reference: 13. <author> P. Deransart, G. Ferrand, and M. Teguia. </author> <title> NSTO programs (not subject to occur-check). </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Proceedings of the International Logic Symposium, </booktitle> <pages> pages 533-547. </pages> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Plaisted [22] and Deransart and Maluszynski [14]). The aim of this paper is to provide easy to check syntactic conditions which ensure that for Prolog programs the occur-check can be safely omitted. We use here a result of Deransart, Ferrand and Teguia <ref> [13] </ref> and build upon it within the context of moded programs. This allows us to extend the results of Deransart and Maluszynski [14], to simplify the arguments of Chadha and Plaisted [8] and to offer a uniform presentation. <p> It is natural then to seek conditions which guarantee that, in absence of the occur-check, in all Prolog evaluations of a given goal w.r.t. a given program unification is correctly performed. This leads us to the following notion due to Deransart, Ferrand and Teguia <ref> [13] </ref>. Definition 2.5. A set of equations E is called not subject to occur-check (NSTO in short) if in no execution of the Martelli-Montanari algorithm started with E action (6) can be performed. 2 We now introduce the key definition of the paper. Definition 2.6. |Let be an LD-derivation. <p> As in the definition of the occur-check freedom all LD-derivations of P [ fGg are considered, all systems of equations that can be considered in a possibly backtracking Prolog evaluation of a goal G w.r.t. the program P are taken into account. In Deransart, Ferrand and Teguia <ref> [13] </ref> a related concept of an NSTO program is studied which essentially states that, independently of the selection rule and the resolution strategy chosen, all considered systems are NSTO. <p> The following result due to Deransart, Ferrand and Teguia <ref> [13] </ref> will be helpful in the sequel. Lemma NSTO. Suppose that the equations in E can be oriented in such a way that the resulting system F is left linear and the relation ! F is cycle-free. <p> We found the above two least restrictive. It is useful to note that the theorems established above generalize the following well-known result stated in Clark [9, page 15] and established in Deransart, Ferrand and Teguia <ref> [13] </ref> as a direct consequence of the NSTO Lemma 2.9. Corollary 3.8. Suppose that |the head of every clause of P is linear. Then P [ fGg is occur-check free for every goal G. Proof. <p> In our opinion the latter theorem is necessary to draw the above conclusion. Pierre Deransart (private communication) pointed out to us that this corollary is a consequence of Theorem 4.1 in Deransart, Ferrand and Teguia <ref> [13] </ref> whose conditions are satisfied for a nicely moded program P and a nicely moded goal G. This suggests a stronger result, namely that such a P and G is NSTO. <p> Such an approximation is determined by suitable functions which approximate the groundness information and the unification algorithm. The approach based on attribute grammars was originated by Deransart and Maluszynski [14] and was further developed in Deransart, Ferrand and Teguia <ref> [13] </ref>. This approach exploits a close relationship between the abstract skeletons associated with the executions of a goal and a program and the derivation trees of the grammar associated with the goal and the program. The attributes are used to model relation between equations (like variable sharing).
Reference: 14. <author> P. Deransart and J. Maluszynski. </author> <title> Relating Logic Programs and Attribute Grammars. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 119-156, </pages> <year> 1985. </year>
Reference-contexts: This omission affects the unification algorithm and introduces a possibility of divergence or may yield incorrect results. This is obviously an undesired situation. This problem was studied in the literature under the name of the occur-check problem (see e.g. Plaisted [22] and Deransart and Maluszynski <ref> [14] </ref>). The aim of this paper is to provide easy to check syntactic conditions which ensure that for Prolog programs the occur-check can be safely omitted. We use here a result of Deransart, Ferrand and Teguia [13] and build upon it within the context of moded programs. <p> We use here a result of Deransart, Ferrand and Teguia [13] and build upon it within the context of moded programs. This allows us to extend the results of Deransart and Maluszynski <ref> [14] </ref>, to simplify the arguments of Chadha and Plaisted [8] and to offer a uniform presentation. <p> The aim of this paper is to offer simple syntactic conditions which imply that P [ fGg is occur-check free. As expected, the property of being occur-check free is undecidable (see Deransart and Maluszynski <ref> [14] </ref> and for a strengthened version the appendix). On the other hand, the problem whether a set of equations is NSTO, is decidable. In fact, Apt, van Emde Boas and Welling [5] recently proved that this problem is CoNP-complete. For further analysis we need the following concepts. <p> Such an approximation is determined by suitable functions which approximate the groundness information and the unification algorithm. The approach based on attribute grammars was originated by Deransart and Maluszynski <ref> [14] </ref> and was further developed in Deransart, Ferrand and Teguia [13]. This approach exploits a close relationship between the abstract skeletons associated with the executions of a goal and a program and the derivation trees of the grammar associated with the goal and the program.
Reference: 15. <author> W. </author> <title> Drabent. </title> <booktitle> Do Logic Programs Resemble Programs in Conventional Languages? In International Symposium on Logic Programming, </booktitle> <pages> pages 389-396. </pages> <address> San Francisco, </address> <publisher> IEEE Computer Society, </publisher> <month> August </month> <year> 1987. </year>
Reference-contexts: We then show that these restrictions are satisfied by a number of well-known programs. We use here the notion of a well-moded program. The concept is due to Dembin-ski and Maluszynski [12]; we use here an elegant formulation due to Rosenblueth [25] (which is equivalent to that of Drabent <ref> [15] </ref> where well-moded programs are called simple). The definition of a well-moded program constrains the "flow of data" through the clauses of the programs. <p> In the table below several programs taken from the book of Sterling and Shapiro [28] are listed. (A similar analysis of the notion of a well-moded program was carried in Drabent <ref> [15] </ref>). Corollary 3.8 can be applied to none of them. For each program it is indicated which of the relevant conditions for a given moding are satisfied. All built-in's are moded completely input.
Reference: 16. <author> B. Dumant. </author> <title> Checking soundness of resolution schemes. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 37-51. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The attributes are used to model relation between equations (like variable sharing). Then it is shown that the occur-check freedom is implied by a combination of syntactic conditions and of non circularity of the attribute dependency scheme. This approach was applied recently by Dumant <ref> [16] </ref> to deal with the problem of inserting occur-checks in arbitrary resolution strategies. The syntactic approach advocated in this paper is much more straightforward and has in our opinion two important advantages. First, it can be trivially implemented. Secondly, it can be easily used "manually".
Reference: 17. <author> J.-L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: then the algorithm successfully terminates and produces a solved set of equations determining a relevant mgu of E, and otherwise it terminates with failure. 2 The Martelli-Montanari algorithm does not generate all relevant mgu's of a set of equations E but the following lemma, proved in Lassez, Marriot and Maher <ref> [17] </ref>, will allow us to cope with this peculiarity. Lemma 2.3. Let 1 and 2 be mgu's of a set of equations. Then for some renaming j we have 2 = 1 j. 2 Finally, the following lemma allows us to search for mgu's in an iterative fashion. Lemma 2.4.
Reference: 18. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: An SLD-derivation in which the leftmost selection rule is used is called an LD-derivation. We allow in programs various first-order built-in's, like =, , &gt;, etc, and assume that they are resolved in the way conforming to their interpretation. Throughout the paper we use the standard notation of Lloyd <ref> [18] </ref> and Apt [2]. In particular, given a syntactic construct E (so for example, a term, an atom or a set of equations) we denote by Var (E) the set of the variables appearing in E. <p> When studying 22 Krzysztof R. Apt and Alessandro Pellegrini the occur-check problem we need to use a definition of SLDNF-resolution which guarantees that for every general program P and a general goal G the SLDNF-tree, which comprises all SLDNF-derivations exists. (The definition provided in Lloyd <ref> [18] </ref> is for this purpose too restrictive | for example for the program P = fp pg and the general goal G = :p no SLDNF-derivation or tree exists.) Such a definition was recently given in Apt and Doets [4].
Reference: 19. <author> K. Marriott, H. So ndergaard, and P. </author> <title> Dart. A Characterization of Non-Floundering Logic Programs. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conference on Logic Programming'90, </booktitle> <pages> pages 661-680. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The absence of circularity guarantees occur-check freedom. The abstract interpretations were also used to prove the absence of floundering. The strongest results were obtained by Marriott, Sondergaard and Dart <ref> [19] </ref>. To this end they expressed a dataflow analysis of a general program by means of a finitely computable approximation of the denotational semantics. Such an approximation is determined by suitable functions which approximate the groundness information and the unification algorithm.
Reference: 20. <author> A. Martelli and U. Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4 </volume> <pages> 258-282, </pages> <year> 1982. </year>
Reference-contexts: Given a substitution and a set of variables V , we denote by jV the substitution obtained from by restricting its domain to V . 2. OCCUR-CHECK FREE PROGRAMS We start our considerations by recalling a unification algorithm due to Martelli and Montanari <ref> [20] </ref>. We use below the notions of sets and of systems of equations interchangingly. Two atoms can unify only if they have the same relation symbol. <p> The algorithm terminates when no action can be performed or when failure arises. To keep the formulation of the algorithm concise we identified here constants with 0-ary functions. Thus action (2) includes the case of two different constants. The following theorem holds (see Martelli and Montanari <ref> [20] </ref>). Theorem Unification. The Martelli-Montanari algorithm always terminates.
Reference: 21. <author> C. S. Mellish. </author> <title> The Automatic Generation of Mode Declarations for Prolog Programs. </title> <type> DAI Research Paper 163, </type> <institution> Department of Artificial Intelligence, Univ. of Edinburgh, </institution> <month> August </month> <year> 1981. </year>
Reference-contexts: The original formulation of this lemma is slightly stronger, but for our purposes the above version is sufficient. 3. MODED PROGRAMS For a further analysis we introduce modes, first considered in Mellish <ref> [21] </ref>, and more extensively studied in Reddy [23] and Dembinski and Maluszynski [12]. 6 Krzysztof R. Apt and Alessandro Pellegrini Definition 3.1. Consider an n-ary relation symbol p. By a mode for p we mean a function d p from f1; : : :; ng to the set f+; g.
Reference: 22. <author> D.A. Plaisted. </author> <title> The occur-check problem in Prolog. </title> <booktitle> In Proc. International Conference on Logic Programming, </booktitle> <pages> pages 272-280. </pages> <publisher> IEEE Computer Science Press, </publisher> <year> 1984. </year>
Reference-contexts: This omission affects the unification algorithm and introduces a possibility of divergence or may yield incorrect results. This is obviously an undesired situation. This problem was studied in the literature under the name of the occur-check problem (see e.g. Plaisted <ref> [22] </ref> and Deransart and Maluszynski [14]). The aim of this paper is to provide easy to check syntactic conditions which ensure that for Prolog programs the occur-check can be safely omitted. <p> Two other approaches to the subject of proving occur-check freedom were proposed in the literature. One is based on the abstract interpretations and another uses the attribute grammars. The first approach originated with Plaisted <ref> [22] </ref> and was further developed in Sondergaard [27]. Sondergaard used an abstract interpretation in which the information on the possibility of creating a sharing of a variable or forming multiple occurrences of the same variable (called spawning ) is maintained.
Reference: 23. <author> U. S. Reddy. </author> <title> Transformation of logic programs into functional programs. </title> <booktitle> In International Symposium on Logic Programming, </booktitle> <pages> pages 187-198, </pages> <address> Silver Spring, MD, </address> <month> February </month> <year> 1984. </year> <title> At-lantic City, </title> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: The original formulation of this lemma is slightly stronger, but for our purposes the above version is sufficient. 3. MODED PROGRAMS For a further analysis we introduce modes, first considered in Mellish [21], and more extensively studied in Reddy <ref> [23] </ref> and Dembinski and Maluszynski [12]. 6 Krzysztof R. Apt and Alessandro Pellegrini Definition 3.1. Consider an n-ary relation symbol p. By a mode for p we mean a function d p from f1; : : :; ng to the set f+; g.
Reference: 24. <author> U.S. Reddy. </author> <title> On the relationship between logic and functional languages. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <booktitle> Functional and Logic Programming, </booktitle> <pages> pages 3-36. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year> <note> 32 Krzysztof R. Apt and Alessandro Pellegrini </note>
Reference-contexts: Reddy <ref> [24] </ref>): curry (R, var (X), T) in ([X, T], R). curry (R, apply (M, N), T) curry (R, M, S ! T), curry (R, N, S). curry (R, lambda (X, M), S ! T) curry ([[X, S] | R], M, T). in (X, [Y | Xs]) X 6= Y, in (X,
Reference: 25. <author> D.A. Rosenblueth. </author> <title> Using program transformation to obtain methods for eliminating backtracking in fixed-mode logic programs. </title> <type> Technical Report 7, </type> <institution> Universidad Nacional Autonoma de Mexico, Instituto de Investigaciones en Matematicas Aplicadas y en Sistemas, </institution> <year> 1991. </year>
Reference-contexts: We then show that these restrictions are satisfied by a number of well-known programs. We use here the notion of a well-moded program. The concept is due to Dembin-ski and Maluszynski [12]; we use here an elegant formulation due to Rosenblueth <ref> [25] </ref> (which is equivalent to that of Drabent [15] where well-moded programs are called simple). The definition of a well-moded program constrains the "flow of data" through the clauses of the programs.
Reference: 26. <author> J. C. Shepherdson. </author> <title> Unsolvable problems for SLDNF resolution. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(1) </volume> <pages> 19-22, </pages> <year> 1991. </year>
Reference: 27. <author> H. Sondergaard. </author> <title> An Application of Abstract Interpretation of Logic Programs: Occur Check Reduction. </title> <booktitle> In Proc. of ESOP'86, </booktitle> <pages> pages 327-338, </pages> <address> Sarrbruecken (FRG), </address> <year> 1986. </year>
Reference-contexts: Two other approaches to the subject of proving occur-check freedom were proposed in the literature. One is based on the abstract interpretations and another uses the attribute grammars. The first approach originated with Plaisted [22] and was further developed in Sondergaard <ref> [27] </ref>. Sondergaard used an abstract interpretation in which the information on the possibility of creating a sharing of a variable or forming multiple occurrences of the same variable (called spawning ) is maintained.
Reference: 28. <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Proof. By Theorem 3.5 by moding every relation completely output or by Theorem 3.7 by moding every relation completely input. 2 This corollary can be applied to some well-known Prolog programs, for example to the unification program (see page 150 in the book of Sterling and Shapiro <ref> [28] </ref>) 8 Krzysztof R. Apt and Alessandro Pellegrini and | paradoxically | to the unification with occur-check program (see page 152). However, to most programs this corollary does not apply. The subsequent sections provide some other options. <p> In contrast to the case of well-moded and nicely moded programs it is difficult to come up with a natural example to which the notion of a strictly moded program could be applied. Still, consider the program derivative from Sterling and Shapiro <ref> [28, page 63] </ref>) which computes a derivative of an expression w.r.t. a variable. To save space we only reproduce here a couple of crucial clauses. <p> For example, Corollary 5.4 immediately implies that for s and t linear and disjoint, empty [ f empty (s, t)g is occur-check free. However, we did found two programs in the book of Sterling and Shapiro <ref> [28] </ref> that use difference-lists and to which we could not apply the results so far established. <p> By Corollary 7.9 we get that when xs is ground and ys is linear, quicksort dl [ f qs (xs, ys)g is occur-check free. (iii) Finally, consider the following program normalize from Sterling and Shapiro <ref> [28, page 248] </ref>, in which we replaced the binary infix symbol "++" (symbolizing the sum still to be performed) by ",": normalize (Exp, Norm) normalize ds (Exp, Norm, 0). normalize ds (A+B, Norm, Space) normalize ds (A, Norm, NormB) normalize ds (B, NormB, Space). normalize ds (A, (A+Space), Space) constant (A). <p> In the table below several programs taken from the book of Sterling and Shapiro <ref> [28] </ref> are listed. (A similar analysis of the notion of a well-moded program was carried in Drabent [15]). Corollary 3.8 can be applied to none of them. For each program it is indicated which of the relevant conditions for a given moding are satisfied. All built-in's are moded completely input.
Reference: 29. <author> K. Stroetman. </author> <title> A completeness result for SLDNF resolution. </title> <journal> The Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 337-357, </pages> <year> 1993. </year>
Reference-contexts: The following simple result shows that the concept of well-modedness is also very helpful for the study of floundering. It was independently discovered by Stroetman <ref> [29] </ref>. Theorem 8.5. Consider a general program P and a general goal G. Suppose that P and G are well-moded and that all relations which appear in negative literals of P and G are moded completely input. Then P [ fGg does not flounder. Proof.
Reference: 30. <author> H. Tamaki and T. Sato. </author> <title> Unfold/Fold Transformation of Logic Programs. </title> <booktitle> In Proceedings of the 2nd International Conference on Logic Programming, Uppsala, </booktitle> <pages> pages 127-137, </pages> <year> 1984. </year>
Reference-contexts: Call the resulting sequence of atoms B 0 . It is easy to see that H B is nicely moded. Note that by unfolding (in the sense of Tamaki and Sato <ref> [30] </ref>) the inserted calls of "= oc " in H B 0 , we obtain the original clause H B. The same transformation applied to an arbitrary goal transforms it into a nicely moded goal. Finally, a similar transformation ensures that the head H of H B is input linear.
References-found: 30

