URL: http://www.tns.lcs.mit.edu/~djw/library/sigcomm96/adiseshu.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/sigcomm96/program.html
Root-URL: 
Email: hari@dworkin.wustl.edu, guru@cs.wustl.edu, and varghese@cs.wustl.edu  
Phone: TEL: (314) 935-6160, FAX: (314) 935-7302  
Title: A Reliable and Scalable Striping Protocol  
Author: Hari Adiseshu, Guru Parulkar and George Varghese 
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: Link striping algorithms are often used to overcome transmission bottlenecks in computer networks. Traditional striping algorithms suffer from two major disadvantages. They provide inadequate load sharing in the presence of variable length packets, and may result in non-FIFO delivery of data. We describe a new family of link striping algorithms that solves both problems. Our scheme applies to any layer that can provide multiple FIFO channels. We deal with variable sized packets by showing how fair queuing algorithms can be transformed into load sharing algorithms. Our transformation results in practical load sharing protocols, and shows a theoretical connection between two seemingly different problems. The same transformation can be applied to obtain load sharing protocols for links with different capacities. We deal with the FIFO requirement for two separate cases. If a sequencenumber can be added to each packet, we show how to speed up packet processing by letting the receiver simulate the sender algorithm. If no header can be added, we show how to provide quasi-FIFO delivery. Quasi-FIFO is FIFO except during occasional periods of loss of synchronization. We argue that quasi-FIFO is adequate for most applications. We also describe a simple technique for speedy restoration of synchronization in the event of loss. We develop an architectural framework for transparently embedding our protocol at the network level by striping IP packets across multiple physical interfaces. The resulting strIPe protocol has been implemented within the NetBSD kernel. Our measurements and simulations show that the protocol offers scalable throughput even when striping is done over dissimilar links, and that the protocol synchronizes quickly after packet loss. Measurements show performance improvements over conventional round robin striping schemes and striping schemes that do not resequence packets. 
Abstract-found: 1
Intro-found: 1
Reference: [Bay95] <institution> Bay Networks Web Page. </institution> <note> http://www.wellfleet.com/Products/Routers/Protocols/Traffic2.html, 1995. </note>
Reference-contexts: Thus none of these schemes meet all our goals. Existing striping schemes which operate at higher levels usually sacrifice either fair load sharing or FIFO delivery. For example, the Random Selection scheme <ref> [Bay95] </ref> relies on random assignment of channels to packets to ensure load sharing, but does not provide FIFO delivery. <p> The same is true for the Shortest Queue First scheme used in the EQL serial line driver in the Linux operating system: in this scheme, the channel with the smallest queue is selected for transmitting the next packet. On the other hand, the Address-based Hashing scheme <ref> [Bay95] </ref> relies on hashing packet addresses to channels to route packets destined for the same address over the same channel. This provides FIFO delivery of packets destined for the same address, but does not provide load sharing for packets addressed to any given destination.
Reference: [CL85] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed Snapshots: De--termining Global States of a Distributed System. </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The marker recovery theorem assumes that the only channel error is detectable packet corruption or packet loss. It is also possible to make the marker algorithm self-stabilizing (i.e., robust against any error in the state) by periodically running a snapshot <ref> [CL85] </ref> and then doing a reset [Var93]. We deal with sender or receiver node crashes by doing a reset. The main idea behind the marker recovery protocol is a way of numbering packets on a channel that depends only on the data sent or received on a channel.
Reference: [DKS89] <author> A. Demers, S. Keshav, and S. Shenker. </author> <title> Analysis and Simulation of a Fair Queueing Algorithm. </title> <booktitle> In Proceedings of the ACM SIG-COMM, </booktitle> <pages> pages 3-12, </pages> <year> 1989. </year>
Reference-contexts: This decision can depend not only on the previously transmitted packets, but also on other parameters, like the size of packets at the head of each queue, the current queue sizes, and so on. For instance, the DKS algorithm <ref> [DKS89] </ref> depends on the packets at the head of each queue in order to simulate bit-by-bit round robin. In the backlogged case, if a FQ algorithm depends only on the previous packets sent to choose the current queue to serve, then we call the algorithm a Causal FQ (CFQ) algorithm. <p> In the backlogged case, if a FQ algorithm depends only on the previous packets sent to choose the current queue to serve, then we call the algorithm a Causal FQ (CFQ) algorithm. All other FQ algorithms are called non-causal algorithms. Thus the DKS fair queuing algorithm <ref> [DKS89] </ref> is non-causal, while ordinary round robin is causal. Why do we restrict ourselves to backlogged FQ behavior? In the non-backlogged case, most FQ algorithms maintain a list of active flows as part of their state. This allows them to skip over empty queues.
Reference: [DP94] <author> Peter Druschel and Larry L. Peterson. </author> <title> Experiences with a High-Speed Network Adaptor: A software Perspective. </title> <booktitle> In Proceedings of the ACM SIGCOMM, </booktitle> <year> 1994. </year>
Reference-contexts: As mentioned earlier, the IBM SIA adaptor [TG93] does striping over 4 STS-3c channels. The Bellcore HAS adaptor [Joh95] stripes HIPPI packets over SONET lines using a First-Come-First-Serve (FCFS) striping policy, while the CASA Gigabit testbed [JD93] uses round robin striping at the byte level. The OSIRIS Adaptor <ref> [DP94] </ref> does cell striping over ATM channels. A single packet is sent as a number of minipackets on each channel and a parallel reassembly of the packets is done at the receiver.
Reference: [Dun94] <author> Jay Duncanson. </author> <title> Inverse Multiplexing. </title> <journal> IEEE Communications Magazine, </journal> <volume> 32(4), </volume> <month> April </month> <year> 1994. </year>
Reference: [Flo93] <author> Sally Floyd. </author> <title> Notes on Guaranteed Service in Resource Management. Unpublished Note, </title> <year> 1993. </year>
Reference-contexts: SRR is based on a modified version of DRR [SV94]. SRR is also identical to a FQ algorithm proposed by Van Jacobson and Sally Floyd <ref> [Flo93] </ref>. In the SRR algorithm, each queue is assigned a quantum of service, measured in units of data, and is associated with a counter called the Deficit Counter (DC), which is initialized to 0. Queues are serviced in a round robin manner.
Reference: [Fre94] <author> Paul H. Fredette. </author> <title> The Past, Present and Future of Inverse Multiplexing. </title> <journal> IEEE Communications Magazine, </journal> <volume> 32(4), </volume> <month> April </month> <year> 1994. </year>
Reference: [Gro92] <institution> Bandwidth ON Demand INteroperability Group. Interoperability Requirements for Nx56/64 kbit/s Calls, </institution> <month> September </month> <year> 1992. </year>
Reference: [JD93] <author> W. St. John and D. DuBois. </author> <title> CASA Gigabit Testbed Annual Report. </title> <type> Technical report, </type> <year> 1993. </year>
Reference-contexts: Similarly, in the wide area the price differential between T1 and T3 lines makes striping across T1 links attractive. On the other hand, many of the Giga-bit testbeds <ref> [TG93, JD93] </ref> have resorted to striping because of the unavailability of high speed equipment: for instance, the IBM SIA adaptor [TG93] emulates a SONET STS-12 line using four STS-3c lines. Thus channel striping, also known as load sharing or inverse multiplexing, is often used in computer networks. <p> As mentioned earlier, the IBM SIA adaptor [TG93] does striping over 4 STS-3c channels. The Bellcore HAS adaptor [Joh95] stripes HIPPI packets over SONET lines using a First-Come-First-Serve (FCFS) striping policy, while the CASA Gigabit testbed <ref> [JD93] </ref> uses round robin striping at the byte level. The OSIRIS Adaptor [DP94] does cell striping over ATM channels. A single packet is sent as a number of minipackets on each channel and a parallel reassembly of the packets is done at the receiver. <p> This is essential for striping over high speed interfaces. Finally, MPPP supplies no algorithm for striping at the sender and resequencing at the receiver, while our strIPe protocol does. While some of the solutions described in <ref> [TG93, Joh95, JD93] </ref> look superficially similar to ours (e.g., the use of queues at the receiving ends of channels), these schemes rely on extra information such as SONET framing for synchronization, which is unavailable for many channels.
Reference: [Joh95] <author> C. Johnston. </author> <note> Presentation at CNRI Gigabit Testbed Workshop , June 1993, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: The establishment of Gigabit testbeds led to the design of several network adaptors which striped data across multiple slower speed ATM links to achieve gigabit throughputs. As mentioned earlier, the IBM SIA adaptor [TG93] does striping over 4 STS-3c channels. The Bellcore HAS adaptor <ref> [Joh95] </ref> stripes HIPPI packets over SONET lines using a First-Come-First-Serve (FCFS) striping policy, while the CASA Gigabit testbed [JD93] uses round robin striping at the byte level. The OSIRIS Adaptor [DP94] does cell striping over ATM channels. <p> This is essential for striping over high speed interfaces. Finally, MPPP supplies no algorithm for striping at the sender and resequencing at the receiver, while our strIPe protocol does. While some of the solutions described in <ref> [TG93, Joh95, JD93] </ref> look superficially similar to ours (e.g., the use of queues at the receiving ends of channels), these schemes rely on extra information such as SONET framing for synchronization, which is unavailable for many channels.
Reference: [KC93] <author> H.T. Kung and Alan Chapman. </author> <title> The FCVC (Flow Controlled Virtual Channel) proposal for ATM networks. </title> <booktitle> In Proceedings of the International Conference on Network Protocols, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: out of order deliveries, with the minimum number of out of order deliveries occuring when the marker was sent either at the beginning or end of the round. * For channels not providing flow control, e.g., UDP channels, a simple credit based flow control scheme proposed by Kung et. al. <ref> [KC93] </ref> proved very effective in eliminating packet loss due to channel congestion.
Reference: [McA93] <author> A. J. McAuley. </author> <title> Parallel Assembly for Broadband Networks, </title> <year> 1993. </year>
Reference-contexts: Even in the case when sequence numbers can be added to packets, logical reception can help simplify the resequencing implementation. Some of the hardware implementations for resequencing, e.g., <ref> [McA93] </ref>, rely on hardware to sort out of order packets and modified packet formats. Logical reception can be used to avoid such sorting. The sequence number inserted by the sender is now needed only for confirmation, since logical reception suffices for FIFO delivery.
Reference: [RF94] <author> Allyn Romanov and Sally Floyd. </author> <title> Dynamics of TCP Traffic over ATM Networks. </title> <booktitle> In Proceedings of the ACM SIGCOMM, </booktitle> <pages> pages 79-88, </pages> <year> 1994. </year>
Reference-contexts: When striping end-to-end across ATM circuits, it seems advisable to stripe at the packet layer. Striping cells across channels would mean that AAL boundaries are unavailable within the ATM networks; however, these boundaries are needed in order to implement early discard policies <ref> [RF94] </ref>. We believe the strIPe protocol based on SRR, logical reception, and periodic resynchronization is suitable for practical implementation, even in hardware.
Reference: [SV94] <author> M. Shreedhar and G. Varghese. </author> <title> Efficient Fair Queueing by Deficit Round Robin. </title> <type> Technical Report WU94-17, </type> <institution> Washington University, </institution> <year> 1994. </year>
Reference-contexts: SRR is based on a modified version of DRR <ref> [SV94] </ref>. SRR is also identical to a FQ algorithm proposed by Van Jacobson and Sally Floyd [Flo93]. In the SRR algorithm, each queue is assigned a quantum of service, measured in units of data, and is associated with a counter called the Deficit Counter (DC), which is initialized to 0. <p> After any K rounds, the difference between the bytes that queue i should have sent, i.e., KQuantum i , and the bytes that queue i actually sends is bounded by M ax + 2 Quantum. The proof is similar to the proof of fairness of DRR <ref> [SV94] </ref>. Transforming SRR into a load sharing algorithm The corresponding load sharing algorithm works as follows. Each channel is associated with a Deficit Counter (DC), and a quantum of service, measured in units of data, proportional to the bandwidth of the channel.
Reference: [TG93] <author> V. Theoharakis and R. Guerin. </author> <title> SONET OC-12Interface for Variable Length Packets. </title> <booktitle> In Proceedings of the Second International Conference on Computer Communications and Networks, </booktitle> <pages> pages 21-25, </pages> <month> June </month> <year> 28-30,1993. </year>
Reference-contexts: Similarly, in the wide area the price differential between T1 and T3 lines makes striping across T1 links attractive. On the other hand, many of the Giga-bit testbeds <ref> [TG93, JD93] </ref> have resorted to striping because of the unavailability of high speed equipment: for instance, the IBM SIA adaptor [TG93] emulates a SONET STS-12 line using four STS-3c lines. Thus channel striping, also known as load sharing or inverse multiplexing, is often used in computer networks. <p> Similarly, in the wide area the price differential between T1 and T3 lines makes striping across T1 links attractive. On the other hand, many of the Giga-bit testbeds [TG93, JD93] have resorted to striping because of the unavailability of high speed equipment: for instance, the IBM SIA adaptor <ref> [TG93] </ref> emulates a SONET STS-12 line using four STS-3c lines. Thus channel striping, also known as load sharing or inverse multiplexing, is often used in computer networks. However, as in other parallel solutions, there are synchronization and fault-tolerance costs that are inherent to channel striping. <p> As with BONDING, this works only when the skew can be bounded tightly. The establishment of Gigabit testbeds led to the design of several network adaptors which striped data across multiple slower speed ATM links to achieve gigabit throughputs. As mentioned earlier, the IBM SIA adaptor <ref> [TG93] </ref> does striping over 4 STS-3c channels. The Bellcore HAS adaptor [Joh95] stripes HIPPI packets over SONET lines using a First-Come-First-Serve (FCFS) striping policy, while the CASA Gigabit testbed [JD93] uses round robin striping at the byte level. The OSIRIS Adaptor [DP94] does cell striping over ATM channels. <p> This is essential for striping over high speed interfaces. Finally, MPPP supplies no algorithm for striping at the sender and resequencing at the receiver, while our strIPe protocol does. While some of the solutions described in <ref> [TG93, Joh95, JD93] </ref> look superficially similar to ours (e.g., the use of queues at the receiving ends of channels), these schemes rely on extra information such as SONET framing for synchronization, which is unavailable for many channels.
Reference: [TS95] <author> C. Brendan S. Traw and Jonathan Smith. </author> <title> Striping within the Network Subsystem . IEEE Network, </title> <address> pages 22-29, </address> <year> 1995. </year>
Reference-contexts: Examples include multiprocessors and RAID systems that use disk striping. Parallel solutions, however, have additional costs for synchronization (e.g., the need to keep multiprocessor caches coherent) and fault-tolerance (e.g., the need for parity disks in disk arrays). Similar considerations apply to computer networks <ref> [TS95] </ref> because of transmission and processing bottlenecks. High end workstations and servers can easily saturate existing Local Area Networks (LANs). Such devices may obtain increased throughput by striping data across multiple adaptors and multiple LANs. Solutions that use striping may even be cheaper than the alternatives. <p> In addition the scheme should be robust enough to recover from bit and burst errors, and be scalable enough to impose little overhead. 2.1 Existing Channel Striping Algorithms <ref> [TS95] </ref> describes a model of load striping, and summarizes various approaches to the problem. Table 1 compares the features of some solutions to striping. The simplest channel striping scheme is round robin striping the sender sends packets in round robin order on the channels.
Reference: [Var93] <author> George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <type> Ph.D. Thesis MIT/LCS/TR-583, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: The marker recovery theorem assumes that the only channel error is detectable packet corruption or packet loss. It is also possible to make the marker algorithm self-stabilizing (i.e., robust against any error in the state) by periodically running a snapshot [CL85] and then doing a reset <ref> [Var93] </ref>. We deal with sender or receiver node crashes by doing a reset. The main idea behind the marker recovery protocol is a way of numbering packets on a channel that depends only on the data sent or received on a channel.
References-found: 17

