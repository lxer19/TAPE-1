URL: ftp://ftp.eecs.umich.edu/techreports/cse/1995/CSE-TR-244-95.ps.Z
Refering-URL: http://www.eecs.umich.edu/~worthing/papers.html
Root-URL: http://www.cs.umich.edu
Title: Aggressive Centralized and Distributed Scheduling of Disk Requests  
Author: by Bruce L. Worthington Professor Edward S. Davidson Professor Trevor N. Mudge Professor Kensall D. Wise 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Science and Engineering) in The  Doctoral Committee: Professor Yale N. Patt, Chair  
Note: Richie Lary, Storage Architect, Digital Equipment Corporation  
Date: 1995  
Affiliation: University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: [Abbo89] <author> R. Abbott, H. Garcia-Molina, </author> <title> "Scheduling Real-Time Transactions with Disk Resident Data", </title> <booktitle> Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <address> Amsterdam, </address> <month> August </month> <year> 1989, </year> <pages> pp. 385-396. </pages>
Reference-contexts: Real-time system research has recently focused on disk scheduling algorithms that use transaction deadlines to reorder outstanding disk requests. Abbott and Garcia-Molina have studied scheduling algorithms that prioritize disk requests based on the priority of the issuing transactions <ref> [Abbo89] </ref> or a combination of transaction priority and seek distance [Abbo90]. They show that the former provide improved performance over FCFS and the latter provide improved performance over traditional seek-reducing algorithms.
Reference: [Abbo90] <author> R. Abbott, H. Garcia-Molina, </author> <title> "Scheduling I/O Requests with Deadlines: a Performance Evaluation", </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <address> Lake Buena Vista, Florida, </address> <month> December </month> <year> 1990, </year> <pages> pp. 113-124. </pages>
Reference-contexts: Real-time system research has recently focused on disk scheduling algorithms that use transaction deadlines to reorder outstanding disk requests. Abbott and Garcia-Molina have studied scheduling algorithms that prioritize disk requests based on the priority of the issuing transactions [Abbo89] or a combination of transaction priority and seek distance <ref> [Abbo90] </ref>. They show that the former provide improved performance over FCFS and the latter provide improved performance over traditional seek-reducing algorithms. <p> They concluded that it is essential to use a priority-based disk scheduler (in conjunction with a priority-based buffer management algorithm) whenever the disk subsystem is a performance bottleneck. Chen, et al., compared the performance of several real-time scheduling algorithms, including the best algorithms from <ref> [Abbo90] </ref> and [Care89] along with two new real-time algorithms based on SSTF [Chen91]. The SSTF-based algorithms use both seek distances and request deadlines in the generation of request orderings. The algorithms can be biased toward either of the criteria by changing certain scheduling parameters.
Reference: [Bate91] <author> K. Bates, </author> <title> VAX I/O Subsystems: Optimizing Performance, </title> <publisher> Professional Press Books, </publisher> <year> 1991. </year>
Reference-contexts: Synthetic or benchmark 1 [Wilh76] constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) [Gang93]. <p> Most use disk models that lack important disk drive characteristics (e.g., request processing overheads, onboard data caches, and complex data layouts). The experiments typically use synthetic workloads with simple probability distributions for request starting locations (e.g., uniform, unimodal, or bimodal), which are unrepresentative of most real-world workloads <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Those studies that did involve actual implementation used very simplistic benchmarks. With few exceptions, previous work ignored host feedback effects (e.g., by using a Poisson process for request arrivals) or oversimplified them (e.g., by maintaining a constant number of outstanding requests).
Reference: [Benn94] <author> S. Bennett, D. Melski, </author> <title> "A Class-Based Disk Scheduling Algorithm: Implementation and Performance Study", Class Project, </title> <institution> University of Wisconsin. </institution>
Reference-contexts: For example, write requests generated because of disk cache pressure (i.e., few available clean cache blocks) should be expedited. Otherwise, the disk block cache may become a performance bottleneck <ref> [Benn94] </ref>. This example suggests an additional scheduling optimization. At the moment when cache pressure raises the priority of subsequent write requests, there may already be writes waiting for service. In order to quickly make space in the cache, the priorities of the outstanding write requests should also be raised (retroactively).
Reference: [Bitt88] <author> D. Bitton, J. Gray, </author> <title> "Disk Shadowing", </title> <booktitle> Proceedings of the 14th International Conference on Very Large Data Bases, </booktitle> <address> Long Beach, California, </address> <month> September </month> <year> 1988, </year> <pages> pp. 331-338. </pages>
Reference-contexts: For example, if an array employs a redundancy scheme that pro 11 vides multiple paths for accessing data (e.g., disk mirroring), the array controller could dynamically route requests to the components that can most quickly service the requests <ref> [Poly93, Sugg93, Ng91, Chen90, Lee90, Bitt88] </ref>. Alternately, the array controller could schedule requests to the components with the shortest pending queues. In this dissertation, all information from "below" the scheduler relates to disk drive configuration and state.
Reference: [Bitt89] <author> D. Bitton, </author> <title> "Arm Scheduling in Shadowed Disks", </title> <booktitle> COMPCON, </booktitle> <month> March </month> <year> 1989, </year> <pages> pp. 132-136. </pages>
Reference: [Care89] <author> M. Carey, R. Jauhari, M. Livny, </author> <title> "Priority in DMBS Resource Scheduling", </title> <booktitle> Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <address> Amsterdam, </address> <month> August </month> <year> 1989, </year> <pages> pp. 397-410. </pages>
Reference-contexts: A Poisson arrival process was used to generate single-track disk requests, and starting locations were uniformly distributed. 19 Carey, et al., used a similar methodology to examine a priority-based LOOK algorithm <ref> [Care89] </ref>. A more complex host model was used to more closely emulate real database activity. Their LOOK algorithm serviced all high priority requests before servicing any low priority requests. <p> They concluded that it is essential to use a priority-based disk scheduler (in conjunction with a priority-based buffer management algorithm) whenever the disk subsystem is a performance bottleneck. Chen, et al., compared the performance of several real-time scheduling algorithms, including the best algorithms from [Abbo90] and <ref> [Care89] </ref> along with two new real-time algorithms based on SSTF [Chen91]. The SSTF-based algorithms use both seek distances and request deadlines in the generation of request orderings. The algorithms can be biased toward either of the criteria by changing certain scheduling parameters.
Reference: [Chen90] <author> P. Chen, G. Gibson, R. Katz, D. Patterson, </author> <title> "An Evaluation of Redundant Arrays of Disks using an Amdahl 5890", </title> <booktitle> Proceedings of the 1990 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Boulder, Colorado, </address> <month> May </month> <year> 1990, </year> <pages> pp. 74-85. </pages>
Reference-contexts: For example, if an array employs a redundancy scheme that pro 11 vides multiple paths for accessing data (e.g., disk mirroring), the array controller could dynamically route requests to the components that can most quickly service the requests <ref> [Poly93, Sugg93, Ng91, Chen90, Lee90, Bitt88] </ref>. Alternately, the array controller could schedule requests to the components with the shortest pending queues. In this dissertation, all information from "below" the scheduler relates to disk drive configuration and state.
Reference: [Chen91] <author> S. Chen, J. Stankovic, J. Kurose, D. Towsley, </author> <title> "Performance Evaluation of Two New Disk Scheduling Algorithms for Real-Time Systems", </title> <journal> Real-Time Systems Journal, </journal> <volume> Vol. 3, No. 3, </volume> <month> September </month> <year> 1991, </year> <pages> pp. 307-336. </pages>
Reference-contexts: Chen, et al., compared the performance of several real-time scheduling algorithms, including the best algorithms from [Abbo90] and [Care89] along with two new real-time algorithms based on SSTF <ref> [Chen91] </ref>. The SSTF-based algorithms use both seek distances and request deadlines in the generation of request orderings. The algorithms can be biased toward either of the criteria by changing certain scheduling parameters.
Reference: [Chen94] <author> S. Chen, D. Towsley, </author> <title> "Scheduling Customers in a Non-Removal Real-Time System with an Application to Disk Scheduling", </title> <journal> Real-Time Systems Journal, </journal> <volume> Vol. 6, No. 1, </volume> <month> January </month> <year> 1994, </year> <pages> pp. 55-72. </pages>
Reference: [Coff72] <author> E. Coffman, L. Klimko, B. Ryan, </author> <title> "Analysis of Scanning Policies for Reducing Disk Seek Times", </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 1, No. 3, </volume> <month> September </month> <year> 1972, </year> <pages> pp. 269-279. 204 205 </pages>
Reference-contexts: The resulting algorithms are classified as either batch or aging algorithms. Batch algorithms service a subset of the pending requests, selected by some set of criteria, before moving on to other requests. Possible criteria include request arrival times and target cylinder numbers <ref> [Jaco91, Selt90, Coff72, Teor72, Fran69] </ref>. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages [Jaco91, Selt90]. Alternately, a time limit may be set after which requests move to a higher priority.
Reference: [Dani83] <author> S. Daniel, R. Geist, "V-SCAN: </author> <title> An Adaptive Disk Scheduling Algorithm", </title> <booktitle> Proceedings of the IEEE International Workshop On Computer Systems Organization, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1983, </year> <pages> pp. 96-103. </pages>
Reference-contexts: They suggested an implementation with some hysteresis at the crossover point between the algorithms. Daniel and Geist proposed VSCAN (R), a continuum of scheduling algorithms between SSTF and LOOK <ref> [Dani83] </ref>. The R parameter indicates the algorithm's bias towards maintaining the current direction of actuator motion. VSCAN (0.0) is equivalent to SSTF, and VSCAN (1.0) is equivalent to LOOK. A subsequent study by the same authors attempted to identify the optimal value for R [Geis87].
Reference: [Denn67] <author> P. Denning, </author> <title> "Effects of Scheduling on File Memory Operations", </title> <booktitle> Proceedings of the AFIPS Spring Joint Computer Conference, </booktitle> <address> Atlantic City, New Jersey, </address> <month> April </month> <year> 1967, </year> <pages> pp. 9-21. </pages>
Reference-contexts: Thus, both seek times and rotational latencies have a large impact on mean request service times. Reducing Mean Seek Time Over 25 years ago, Denning used a simple analytical model to study the advantages of a Shortest Seek Time First (SSTF) policy <ref> [Denn67] </ref>. This algorithm always schedules the pending request that will incur the smallest seek time given the current disk actuator position. Since it is infeasible to exactly predict seek times (see section 2.1.1), schedulers typically approximate SSTF by using seek distances (i.e., the number of cylinders to be traversed).
Reference: [Ebli94] <author> M. Ebling, M. Satyanarayanan, "SynRGen: </author> <title> An Extensible File Reference Generator", </title> <booktitle> Proceedings of the ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Nashville, Tennessee, </address> <month> May </month> <year> 1994, </year> <pages> pp. 108-117. </pages>
Reference-contexts: Traces were captured for two different types of workloads. Compress represents a single 30.7 MB file being compressed to 10.7 MB. The SynRGen traces capture the activity of the SynRGen synthetic file reference generator <ref> [Ebli94] </ref>, configured to emulate an edit/make/debug environment with a parameterized number of users. Each user performs a series of random "tasks" intended to simulate editing, compiling, and executing files. The trace buffer size limits the length of the NCR traces.
Reference: [Fran69] <author> H. Frank, </author> <title> "Analysis and Optimization of Disk Storage Devices for Time-Sharing Systems", </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 16, No. 4, </volume> <month> October </month> <year> 1969, </year> <pages> pp. 602-620. </pages>
Reference-contexts: The resulting algorithms are classified as either batch or aging algorithms. Batch algorithms service a subset of the pending requests, selected by some set of criteria, before moving on to other requests. Possible criteria include request arrival times and target cylinder numbers <ref> [Jaco91, Selt90, Coff72, Teor72, Fran69] </ref>. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages [Jaco91, Selt90]. Alternately, a time limit may be set after which requests move to a higher priority.
Reference: [Fuji91] <author> Fujitsu Limited, </author> <title> "M2622Sx/M2623Sx/M2624Sx Intelligent Disk Drives CE Manual", Specification Number 41FH6868E-01, </title> <month> July </month> <year> 1991. </year>
Reference: [Fuji91a] <author> Fujitsu Limited, </author> <title> "M2622Sx/M2623Sx/M2624Sx Intelligent Disk Drives OEM Manual - SCSI Logical Specification", Specification Number 41FH5057E-01, </title> <month> January </month> <year> 1991. </year>
Reference: [Fuji91b] <author> Fujitsu Limited, </author> <title> "M2622Sx/M2623Sx/M2624Sx Intelligent Disk Drives OEM Manual Specifications& Installation", Specification Number 41FH5055E-01A, </title> <month> June </month> <year> 1991. </year>
Reference: [Gang93a] <author> G. Ganger, B. Worthington, R. Hou, Y. Patt, </author> <title> "Disk Subsystem Load Balancing: Disk Striping vs. Conventional Data Placement", </title> <booktitle> Proceedings of the 26th Hawaii International Conference on System Sciences, </booktitle> <address> Wailea, Hawaii, </address> <month> January </month> <year> 1993, </year> <journal> Vol. </journal> <volume> 1, </volume> <pages> pp. 40-49. </pages>
Reference: [Gang93] <author> G. Ganger, Y. Patt, </author> <title> "The Process-Flow Model: Examining I/O Performance from the System's Point of View", </title> <booktitle> Proceedings of the 1993 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Santa Clara, California, </address> <month> May </month> <year> 1993, </year> <pages> pp. 86-97. </pages>
Reference-contexts: The simulator uses traces taken from systems at several industrial and research installations. Some of the experiments use an open subsystem model, while others use a realistic host model developed at the University of Michigan <ref> [Gang93] </ref>. The host model provides system performance metrics to measure the user-level impact of scheduler design choices. 1.2 Thesis Statement Previous studies of disk scheduling algorithms are inadequate for computer system engineers concerned with optimizing disk subsystem performance. <p> Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) <ref> [Gang93] </ref>. Each of the studies discussed below suffers from one or more of these inadequacies. 3.2.1 Scheduling with Information from "Below" Traditional scheduling algorithms use hardware-specific knowledge to reduce mechanical delays. Some algorithms minimize seek times while others minimize overall positioning times (i.e., combined seek and rotational latencies). <p> The resulting request orderings may actually be "suboptimal" as measured by disk subsystem metrics. Ganger and Patt performed an initial study of disk scheduling using system-level information obtained from a UNIX file system <ref> [Gang93] </ref>. They classified requests as time-critical, time-limited, or time-noncritical based on whether or not host processes block (or will block) after issuing the requests. They modified a device driver executing the LOOK scheduling algorithm to give priority to time-critical and time-limited requests. <p> For experiments driven by full system traces, a more detailed host model provides realistic feedback based on request completions. The process-flow model reproduces the execution of processes in the host system and their interaction with the disk subsystem <ref> [Gang93] </ref>. It recreates each process by consulting a timestamped trace of important events encountered during the lifetime of that process (e.g., fork, exit, sleep, and disk request generation). It also generates and handles clock and I/O interrupts. <p> For a sufficiently large W, both ASPTF (W) and ASPCTF (W) degenerate into FCFS. Request Criticality Information The classification scheme introduced in <ref> [Gang93] </ref> is used for system-level partitioning of requests. Time-critical requests cause processes to immediately wait (or block) for disk service.
Reference: [Gang94] <author> G. Ganger, B. Worthington, R. Hou, Y. Patt, </author> <title> "Disk Arrays: High-Performance, High-Reliability Storage Subsystems", </title> <journal> IEEE Computer, </journal> <volume> Vol. 27, No. 3, </volume> <month> March </month> <year> 1994, </year> <pages> pp. 30-36. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [Geis87] <author> R. Geist, S. Daniel, </author> <title> "A Continuum of Disk Scheduling Algorithms", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February </month> <year> 1987, </year> <pages> pp. 77-92. </pages>
Reference-contexts: The R parameter indicates the algorithm's bias towards maintaining the current direction of actuator motion. VSCAN (0.0) is equivalent to SSTF, and VSCAN (1.0) is equivalent to LOOK. A subsequent study by the same authors attempted to identify the optimal value for R <ref> [Geis87] </ref>. They demonstrated that VSCAN (R) with a low value of R provides mean response times within a few percent of STTF and response time variances within a few percent of LOOK. However, they used simple synthetic work-loads with either uniformly, unimodally, or bimodally distributed request starting locations. <p> So, CVSCAN (1,R) is equivalent to VSCAN (R). Geist, et al., used both simulation and actual implementation to test the performance of CVSCAN (N,R) for various N and R values. Using the same simulator configuration as in <ref> [Geis87] </ref>, they determined the mean and standard deviation for request queue and service times. Values of N greater than unity did not provide significant improvement for CVSCAN (N,R). <p> The R parameter indicates the size of the service window. When the algorithm schedules requests within the window, neither the "current" direction of travel nor the window boundaries change. WSCAN (0.0) is equivalent to LOOK, and WSCAN (1.0) is equivalent to SSTF. Suggs used the same simulator as <ref> [Geis87] </ref> to determine that WSCAN (R) performs best with a value of R between 0.01 and 0.03. He demonstrated that for several very short sequences of requests, WSCAN (R) provides a mean seek time closer to "optimal" than SSTF, SCAN, and VSCAN (0.2).
Reference: [Geis87a] <author> R. Geist, R. Reynolds, E. Pittard, </author> <title> "Disk Scheduling in System V", </title> <booktitle> Proceedings of the ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Banff, Alberta, </address> <month> May </month> <year> 1987, </year> <pages> pp. 59-68. </pages>
Reference-contexts: Although this conclusion was reasonable for previous computer systems, this dissertation shows that the VSCAN (R) algorithm does not effectively exploit the on-board data caches found in current disk drives. The CVSCAN (N,R) algorithm described in <ref> [Geis87a] </ref> augments VSCAN (R) to consider more than just the "closest" request in either direction from the current actuator position. Instead, the algorithm computes the mean seek distance to the closest N requests in each direction. So, CVSCAN (1,R) is equivalent to VSCAN (R). <p> He demonstrated that for several very short sequences of requests, WSCAN (R) provides a mean seek time closer to "optimal" than SSTF, SCAN, and VSCAN (0.2). Using a scheduler implementation and workload similar to <ref> [Geis87a] </ref>, he showed that WSCAN (0.02) provides a 12.8% reduction in mean response time over VSCAN (0.2). The WSCAN (R) algorithm shows more promise than VSCAN (R) for high-performance disk request scheduling, as it will temporarily "turn around" and service sequential requests in logically ascending order (during its descending phase).
Reference: [Geis95] <author> R. Geist, J. Westall, </author> <title> "Disk Scheduling in Linux", </title> <booktitle> Proceedings of the Computer Measurement Group (CMG) Conference, </booktitle> <address> Orlando, Florida, </address> <month> December </month> <year> 1994, </year> <pages> pp. 739-746. 206 </pages>
Reference-contexts: Unfortunately, the WSCAN (R) algorithm is not studied in this dissertation. XSCAN (R), a temporal variation of WSCAN (R), updates the "current" head position at the completion of each request rather than the initiation <ref> [Geis95] </ref>. That is, a request arriving at the scheduler may be chosen as the next to receive service if it is "closest" to the position of the last request completed (i.e., not the request currently being serviced). <p> In this scenario, the automatic prefetching mechanism of the disk provides a much higher cache hit rate | a hit rate of over 50% is reported. Given the poor choice of workload in <ref> [Geis95] </ref>, it is unclear what advantage (if any) XSCAN (R) has over WSCAN (R) or any other scheduling algorithm. 17 Reducing Mean Positioning Time Given detailed disk configuration and state information, a scheduler can choose the pending request that will incur the minimum positioning time.
Reference: [Gotl73] <author> C. Gotlieb, G. MacEwen, </author> <title> "Performance of Movable-Head Disk Storage Devices", </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 20, No. 4, </volume> <month> October </month> <year> 1973, </year> <pages> pp. 604-623. </pages>
Reference-contexts: Some algorithms gradually increase the priority as a request ages [Jaco91, Selt90]. Alternately, a time limit may be set after which requests move to a higher priority. In either case, if an aging algorithm gives too much weight to the queue time (age) component, it degenerates into FCFS <ref> [Gotl73] </ref>. For this reason, aging algorithms must be carefully designed | preferably after a thorough analysis of the specific workload to be scheduled.
Reference: [Gray90] <author> J. Gray, B. Horst, M. Walker, </author> <title> "Parity Striping of Disk Arrays: Low-Cost Reliable Storage with Acceptable Throughput", </title> <booktitle> Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990, </year> <pages> pp. 148-161. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [Henl89] <author> M. Henley, B. McNutt, </author> <title> "DASD I/O Characteristics: A Comparison of MVS to VM", </title> <booktitle> Proceedings of the Computer Measurement Group (CMG) Conference, </booktitle> <address> Reno, Nevada, </address> <month> December </month> <year> 1989, </year> <pages> pp. 566-578. </pages>
Reference-contexts: Synthetic or benchmark 1 [Wilh76] constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) [Gang93]. <p> Most use disk models that lack important disk drive characteristics (e.g., request processing overheads, onboard data caches, and complex data layouts). The experiments typically use synthetic workloads with simple probability distributions for request starting locations (e.g., uniform, unimodal, or bimodal), which are unrepresentative of most real-world workloads <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Those studies that did involve actual implementation used very simplistic benchmarks. With few exceptions, previous work ignored host feedback effects (e.g., by using a Poisson process for request arrivals) or oversimplified them (e.g., by maintaining a constant number of outstanding requests).
Reference: [Holl92] <author> M. Holland, G. Gibson, </author> <title> "Parity Declustering for Continuous Operation in Redundant Disk Arrays", </title> <booktitle> Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Boston, Massachusetts, </address> <month> October </month> <year> 1992, </year> <pages> pp. 23-35. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [Hou93] <author> R. Hou, Y. Patt, </author> <title> "Trading Disk Capacity for Performance", </title> <booktitle> Proceedings of the 2nd International Symposium on High-Performance Distributed Computing, </booktitle> <address> Spokane, Washington, </address> <month> July </month> <year> 1993, </year> <pages> pp. 263-270. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [HP92] <author> Hewlett-Packard Company, </author> <title> "HP C2240 Series 3.5-inch SCSI-2 Disk Drive, Technical Reference Manual", Part Number 5960-8346, </title> <address> Edition 2, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: For the studies reported in this dissertation, the simulator was configured to model the HP C2240 line of disk drives <ref> [HP92] </ref>. Table 4.1 lists some basic specifications for the HP C2247 [HP92a]. To accurately model this line of drives, an extensive set of parameters was obtained from published documentation and by monitoring SCSI activity.
Reference: [HP92a] <author> Hewlett-Packard Company, </author> <title> "HP C2244/45/46/47 3.5-inch SCSI-2 Disk Drive, Technical Reference Manual", Part Number 5960-8346, </title> <address> Edition 3, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: For the studies reported in this dissertation, the simulator was configured to model the HP C2240 line of disk drives [HP92]. Table 4.1 lists some basic specifications for the HP C2247 <ref> [HP92a] </ref>. To accurately model this line of drives, an extensive set of parameters was obtained from published documentation and by monitoring SCSI activity. The experimental platform consisted of an NCR 3550 multiprocessor system equipped with NCR 53C700 SCSI I/O processors and HP C2247 disk drives. <p> This is not unreasonable, since a production line of disks often differs only in the number of platters <ref> [HP92a] </ref>. The second and more important issue is that HP C2240 disks service requests at a different rate than the disks in the disk request traces. To produce heavier or lighter workloads, the traced interarrival times are scaled to produce a range of mean arrival rates.
Reference: [HP93] <author> Hewlett-Packard Company, </author> <title> "HP C2490A 3.5-inch SCSI-2 Disk Drives, Technical Reference Manual", Part Number 5961-4359, </title> <address> Edition 3, </address> <month> September </month> <year> 1993. </year>
Reference: [HP94] <author> Hewlett-Packard Company, </author> <title> "HP C3323A 3.5-inch SCSI-2 Disk Drives, Technical Reference Manual", Part Number 5962-6452, </title> <address> Edition 2, </address> <month> April </month> <year> 1994. </year>
Reference: [Jaco91] <author> D. Jacobson, J. Wilkes, </author> <title> "Disk Scheduling Algorithms Based on Rotational Position", </title> <type> Hewlett-Packard Technical Report, </type> <institution> HPL-CSP-91-7, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: Several studies have examined the performance of such a scheduling algorithm. Denoted as Shortest Time First (STF) in [Selt90] and Shortest Access Time First (SATF) in <ref> [Jaco91] </ref>, the term Shortest Positioning Time First (SPTF) is used in this work to clarify the exact purpose of this algorithm. Seltzer, et al., simulated a disk subsystem with a constant number of pending requests (up to 1000). <p> The resulting algorithms are classified as either batch or aging algorithms. Batch algorithms service a subset of the pending requests, selected by some set of criteria, before moving on to other requests. Possible criteria include request arrival times and target cylinder numbers <ref> [Jaco91, Selt90, Coff72, Teor72, Fran69] </ref>. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages [Jaco91, Selt90]. Alternately, a time limit may be set after which requests move to a higher priority. <p> Possible criteria include request arrival times and target cylinder numbers [Jaco91, Selt90, Coff72, Teor72, Fran69]. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages <ref> [Jaco91, Selt90] </ref>. Alternately, a time limit may be set after which requests move to a higher priority. In either case, if an aging algorithm gives too much weight to the queue time (age) component, it degenerates into FCFS [Gotl73]. <p> Without such information, a scheduler's only recourse is to reduce the possibility of starvation for high priority requests by minimizing response time variance (i.e., reducing starvation in general). For this purpose, an age-weighted SPTF algorithm is also studied. ASPTF (W) is equivalent to the ASATF algorithm proposed in <ref> [Jaco91] </ref>. 3 ASPTF (W) adjusts each positioning time prediction (T pos ) by subtracting the weighted amount of time the request has been waiting for service (W fl T wait ). <p> A scheduler uses the resulting effective positioning time (T eff ) to select the next request to issue: T eff = T pos (W fl T wait ) The age-sensitive algorithm recommended in <ref> [Jaco91] </ref> is equivalent to ASPTF (6.3). <p> In fact, ASPTF (12) has a lower response time variance than C-LOOK, even though its coefficient of variation is slightly higher. Selecting the request with the smallest positioning delay entails significant computation (especially for large queues), cf. <ref> [Jaco91] </ref>. Unless the pending queue size is bounded, it may be unacceptable to simply compute and compare the positioning times for all of the pending requests.
Reference: [Katz89] <author> R.H. Katz, G.A. Gibson, D.A. Patterson, </author> <title> "Disk System Architectures for High Performance Computing", </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> Vol. 77, No. 12, </volume> <month> December </month> <year> 1989, </year> <pages> pp. 1842-1858. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [Kim86] <author> M. Kim, </author> <title> "Synchronized Disk Interleaving", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-35, No. 11, </volume> <month> November </month> <year> 1986, </year> <pages> pp. 978-988. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [Kim91] <author> W. Kim, J. Srivastava, </author> <title> "Enhancing Real-Time DBMS Performance with Multiver-sion Data and Priority Based Disk Scheduling", </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <address> San Antonio, Texas, </address> <month> December </month> <year> 1991, </year> <pages> pp. 222-231. </pages>
Reference-contexts: Most of their experiments, however, assumed a uniform distribution of request starting locations. For their simulation environment, the two SSTF-based algorithms provided the best system performance. Kim and Srivastava examined real-time disk scheduling algorithms that differentiate between reads and writes when assigning request priorities <ref> [Kim91] </ref>. The best performance resulted from an algorithm that assigns read request priorities based on the priority of the issuing transaction and write request priorities based on the priority of the transactions waiting for the release of the corresponding write locks.
Reference: [Lary95] <author> R. Lary, </author> <title> Storage Architect, Digital Equipment Corporation, </title> <type> Personal Communication, </type> <month> May </month> <year> 1995. </year> <month> 207 </month>
Reference-contexts: When a cache-sensitive algorithm is used by a disk-based scheduler, the disk model's cache is probed before selecting a new request for service. This represents a more aggressive approach than exists in current disk-based schedulers, which typically probe the cache (for scheduling purposes) only when a request arrives <ref> [Lary95] </ref>. Enabling command queueing does not affect the values for the command and completion overhead parameters, although some of the overheads may occur in parallel (due to request "pipelining" at the disk). Experiments in this dissertation use two command queueing configurations, denoted Preseek and Full.
Reference: [Lee90] <author> E. Lee, </author> <title> "Software and Performance Issues in the Implementation of a RAID Prototype", </title> <type> Report No. </type> <institution> UCB/CSD 90/573, University of California, Berkeley, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, if an array employs a redundancy scheme that pro 11 vides multiple paths for accessing data (e.g., disk mirroring), the array controller could dynamically route requests to the components that can most quickly service the requests <ref> [Poly93, Sugg93, Ng91, Chen90, Lee90, Bitt88] </ref>. Alternately, the array controller could schedule requests to the components with the shortest pending queues. In this dissertation, all information from "below" the scheduler relates to disk drive configuration and state.
Reference: [Lync72] <author> W. Lynch, </author> <title> "Do Disk Arms Move?", </title> <journal> Performance Evaluation Review, </journal> <volume> Vol. 1, No. 4, </volume> <month> December </month> <year> 1972, </year> <pages> pp. 3-16. </pages>
Reference-contexts: Synthetic or benchmark 1 [Wilh76] constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) [Gang93]. <p> Most use disk models that lack important disk drive characteristics (e.g., request processing overheads, onboard data caches, and complex data layouts). The experiments typically use synthetic workloads with simple probability distributions for request starting locations (e.g., uniform, unimodal, or bimodal), which are unrepresentative of most real-world workloads <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Those studies that did involve actual implementation used very simplistic benchmarks. With few exceptions, previous work ignored host feedback effects (e.g., by using a Poisson process for request arrivals) or oversimplified them (e.g., by maintaining a constant number of outstanding requests).
Reference: [Maxt92] <author> Maxtor Corporation, </author> <title> "MXT-1240S Product Specification and OEM Technical Manual", Document 1028044, Revision A, </title> <month> November </month> <year> 1992. </year>
Reference: [McNu86] <author> B. McNutt, </author> <title> "An Empirical Study of Variations in DASD Volume Activity", </title> <booktitle> Proceedings of the Computer Measurement Group (CMG) Conference, </booktitle> <year> 1986, </year> <pages> pp. 274-283. </pages>
Reference-contexts: Introduction 1.1 Overview Disk subsystems must be effectively utilized to compensate for the growing performance disparity between processing and storage components. Disk workloads are often characterized by intense bursts of activity, creating long queues of pending requests <ref> [McNu86, Ruem93] </ref>. When such queues develop, the disk scheduler dynamically reorders pending requests to decrease service times. A significant portion of disk service time consists of mechanical positioning delays, which are highly dependent on the relative positions of the requested blocks and the current read/write head position. <p> Synthetic or benchmark 1 [Wilh76] constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) [Gang93]. <p> Most use disk models that lack important disk drive characteristics (e.g., request processing overheads, onboard data caches, and complex data layouts). The experiments typically use synthetic workloads with simple probability distributions for request starting locations (e.g., uniform, unimodal, or bimodal), which are unrepresentative of most real-world workloads <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Those studies that did involve actual implementation used very simplistic benchmarks. With few exceptions, previous work ignored host feedback effects (e.g., by using a Poisson process for request arrivals) or oversimplified them (e.g., by maintaining a constant number of outstanding requests).
Reference: [Mert70] <author> A. Merten, </author> <title> "Some Quantitative Techniques for File Organization", </title> <type> Ph.D. Thesis, Technical Report No. 15, </type> <institution> University of Wisconsin Computing Center, </institution> <year> 1970. </year>
Reference-contexts: C-SCAN treats each cylinder equally rather than favoring the center cylinders. The LOOK algorithm, another SCAN variant, reverses 15 the scanning direction when no pending requests exist in the current direction of travel <ref> [Mert70] </ref>. The C-LOOK algorithm combines C-SCAN and LOOK. Teorey and Pinkerton used both analytical and simulation models to analyze the performance of several scheduling algorithms, including FCFS, SSTF, LOOK, C-LOOK, and some hybrid algorithms optimized to handle extremely heavy workloads [Teor72].
Reference: [Ng91] <author> S. Ng, </author> <title> "Improving Disk Performance Via Latency Reduction", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 40, No. 1, </volume> <month> January </month> <year> 1991, </year> <pages> pp. 22-30. </pages>
Reference-contexts: For example, if an array employs a redundancy scheme that pro 11 vides multiple paths for accessing data (e.g., disk mirroring), the array controller could dynamically route requests to the components that can most quickly service the requests <ref> [Poly93, Sugg93, Ng91, Chen90, Lee90, Bitt88] </ref>. Alternately, the array controller could schedule requests to the components with the shortest pending queues. In this dissertation, all information from "below" the scheduler relates to disk drive configuration and state.
Reference: [Patt88] <author> D. Patterson, G. Gibson, R. Katz, </author> <title> "A Case for Redundant Arrays of Inexpensive Disks (RAID)", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Chicago, Illinois, </address> <month> May </month> <year> 1988, </year> <pages> pp. 109-116. </pages>
Reference-contexts: In particular, disk array controllers can contribute significantly to scheduling performance. Disk arrays are becoming commodity items for systems of all sizes. A variety of data placement and redundancy schemes are available to improve performance and/or data reliability <ref> [Gang94, Hou93, Holl92, Gray90, Katz89, Patt88, Kim86] </ref>. An intelligent disk array controller can reorder pending requests based on the state of any caches, disks, and buses under its control.
Reference: [Poly93] <author> C. Polyzois, A. Bhide, D. Dias, </author> <title> "Disk Mirroring with Alternating Deferred Updates", </title> <booktitle> Proceedings of the 19th International Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <year> 1993, </year> <pages> pp. 604-617. </pages>
Reference-contexts: For example, if an array employs a redundancy scheme that pro 11 vides multiple paths for accessing data (e.g., disk mirroring), the array controller could dynamically route requests to the components that can most quickly service the requests <ref> [Poly93, Sugg93, Ng91, Chen90, Lee90, Bitt88] </ref>. Alternately, the array controller could schedule requests to the components with the shortest pending queues. In this dissertation, all information from "below" the scheduler relates to disk drive configuration and state.
Reference: [Quan93] <author> Quantum Corporation, </author> <title> "ProDrive 700/1050/1225S Product Manual", </title> <journal> Publication Number 81-102480-02, </journal> <month> March </month> <year> 1993. </year>
Reference: [Rama92] <author> K. Ramakrishnan, P. Biswas, R. Karedla, </author> <title> "Analysis of File I/O Traces in Commercial Computing Environments", </title> <booktitle> Proceedings of the 1992 ACM SIGMETRICS and PERFORMANCE '92 International Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Newport, Rhode Island, </address> <month> June </month> <year> 1992, </year> <pages> pp. 78-90. </pages>
Reference-contexts: In addition, system and disk activity was traced on an NCR workstation to enable experiments using the process-flow host model. 4.2.1 Disk Request Traces The six HP and DEC traces are described only briefly as they have been discussed elsewhere in more detail <ref> [Ruem93, Rama92] </ref>. The traced workloads span a broad range of environments, and each trace is at least a full workshift (8 hours) in length. Table 4.2 provides some basic information on each trace. Two of the traces come from Hewlett-Packard systems running HP-UX, a version of UNIX [Ruem93]. <p> While these traces are actually two months in length, the experiments in this dissertation use a single week-long snapshot (5/30/92 to 6/6/92), as in [Wort94, Ruem93]. The other four traces are from commercial VAX systems running the VMS operating system <ref> [Rama92] </ref>.
Reference: [Reyn88] <author> R. Reynolds, </author> <title> "Sector-Based Disk Scheduling in the UNIX T M System V Environment", </title> <booktitle> Proceedings of the ACM Southeastern Regional Conference, Mobile, </booktitle> <address> Alabama, </address> <month> April </month> <year> 1987, </year> <pages> pp. 648-652. </pages>
Reference-contexts: These two studies used better disk drive models than those used in previous simulation studies of scheduling algorithms. However, they also used unrealistic workloads with simplistic host models. Sector-VSCAN (R), a variation on VSCAN (R), also takes rotational latency into account <ref> [Reyn88] </ref>. The R parameter indicates the algorithm's bias towards maintaining the current direction of actuator motion. Reynolds showed that Sector-VSCAN (R) provides up to a 5% improvement in mean response time over VSCAN (R) for a synthetic file system workload.
Reference: [Ruem93] <author> C. Ruemmler, J. Wilkes, </author> <title> "UNIX T M Disk Access Patterns", </title> <booktitle> Proceedings of the Winter USENIX Conference, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1993, </year> <pages> pp. 405-420. </pages>
Reference-contexts: Introduction 1.1 Overview Disk subsystems must be effectively utilized to compensate for the growing performance disparity between processing and storage components. Disk workloads are often characterized by intense bursts of activity, creating long queues of pending requests <ref> [McNu86, Ruem93] </ref>. When such queues develop, the disk scheduler dynamically reorders pending requests to decrease service times. A significant portion of disk service time consists of mechanical positioning delays, which are highly dependent on the relative positions of the requested blocks and the current read/write head position. <p> Synthetic or benchmark 1 [Wilh76] constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) [Gang93]. <p> Most use disk models that lack important disk drive characteristics (e.g., request processing overheads, onboard data caches, and complex data layouts). The experiments typically use synthetic workloads with simple probability distributions for request starting locations (e.g., uniform, unimodal, or bimodal), which are unrepresentative of most real-world workloads <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Those studies that did involve actual implementation used very simplistic benchmarks. With few exceptions, previous work ignored host feedback effects (e.g., by using a Poisson process for request arrivals) or oversimplified them (e.g., by maintaining a constant number of outstanding requests). <p> In addition, system and disk activity was traced on an NCR workstation to enable experiments using the process-flow host model. 4.2.1 Disk Request Traces The six HP and DEC traces are described only briefly as they have been discussed elsewhere in more detail <ref> [Ruem93, Rama92] </ref>. The traced workloads span a broad range of environments, and each trace is at least a full workshift (8 hours) in length. Table 4.2 provides some basic information on each trace. Two of the traces come from Hewlett-Packard systems running HP-UX, a version of UNIX [Ruem93]. <p> The traced workloads span a broad range of environments, and each trace is at least a full workshift (8 hours) in length. Table 4.2 provides some basic information on each trace. Two of the traces come from Hewlett-Packard systems running HP-UX, a version of UNIX <ref> [Ruem93] </ref>. Cello comes from a server at Hewlett-Packard Laboratories (Palo Alto, CA) used for program development, simulation, mail, and news. Snake is from a file server at the University of California, Berkeley, used primarily for compilation and editing. <p> Snake is from a file server at the University of California, Berkeley, used primarily for compilation and editing. While these traces are actually two months in length, the experiments in this dissertation use a single week-long snapshot (5/30/92 to 6/6/92), as in <ref> [Wort94, Ruem93] </ref>. The other four traces are from commercial VAX systems running the VMS operating system [Rama92]. <p> When this occurs, the disk services the requests in logically descending order, completely negating the performance advantage of the prefetching cache. For Cello, C-LOOK produces a higher mean response time than the other seek-reducing algorithms. Large bursts of write requests to a single disk dominate the Cello environment <ref> [Ruem93] </ref>. The /usr/spool/news disk services almost half of the requests, with maximum queue lengths approaching 1000 at the identity scaling factor. In addition, this trace contains the smallest fraction of sequential read requests, thus benefiting the least from the prefetching cache.
Reference: [Ruem94] <author> C. Ruemmler, J. Wilkes, </author> <title> "An Introduction to Disk Drive Modeling", </title> <journal> IEEE Computer, </journal> <volume> Vol. 27, No. 3, </volume> <month> March </month> <year> 1994, </year> <pages> pp. 17-28. </pages>
Reference-contexts: Although previous studies provide some insight into the general performance behavior of scheduling algorithms, many of their assumptions are not valid for modern high-performance computer systems. The complex characteristics of current disk drives cannot be duplicated with simple analytical or simulation models <ref> [Ruem94] </ref>. <p> The mean response times of the actual disk and the simulator match to within 0.8% in all cases. Unpredictable (from the disk's view) host delays partially account for the difference. Greater insight can be achieved by comparing the measured and simulated response time distributions <ref> [Ruem94] </ref>. Figure 4.1 shows distributions of measured and simulated response times for a sample validation workload of 10,000 requests. <p> As with most of our validation results, one 23 sequential, 30% local [normal, 10000 sector variance], 8KB mean request size [exponential], 0-22 ms request interarrival time [uniform]) can barely see that two curves are present. <ref> [Ruem94] </ref> defines the root mean square horizontal distance between the two distribution curves as a demerit figure for disk model calibration. The demerit figure for the validation run shown in figure 4.1 is 0.07 ms, which is less than 0.5% of the corresponding mean response time. <p> Figures A.2-A.5 compare the response time distributions for four typical validation runs comparing the model and the actual system. The workloads consist of 95% random reads, 95% random writes, 95% sequential reads and 95% sequential writes, respectively. The demerit figures (defined by <ref> [Ruem94] </ref> as the root mean square horizontal distance between the two distribution curves) are 0.43%, 0.52%, 1.58%, and 0.99% of the mean response times for each run, respectively.
Reference: [Scra83] <author> R. Scranton, D. Thompson, D. Hunter, </author> <title> "The Access Time Myth", </title> <journal> IBM Research Report, </journal> <volume> RC 10197, </volume> <month> September </month> <year> 1983. </year> <title> [SCSI93] "Small Computer System Interface-2", ANSI X3T9.2, Draft Revision 10k, </title> <month> March </month> <year> 1993. </year> <month> 208 </month>
Reference-contexts: Synthetic or benchmark 1 [Wilh76] constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Disk subsystem performance metrics cannot accurately predict the effects of scheduling design and implementation choices on overall system performance (i.e., the elapsed times or throughput of application-level tasks) [Gang93]. <p> Most use disk models that lack important disk drive characteristics (e.g., request processing overheads, onboard data caches, and complex data layouts). The experiments typically use synthetic workloads with simple probability distributions for request starting locations (e.g., uniform, unimodal, or bimodal), which are unrepresentative of most real-world workloads <ref> [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72] </ref>. Those studies that did involve actual implementation used very simplistic benchmarks. With few exceptions, previous work ignored host feedback effects (e.g., by using a Poisson process for request arrivals) or oversimplified them (e.g., by maintaining a constant number of outstanding requests).
Reference: [Seag92] <author> Seagate Technology, Inc., </author> <title> "SCSI Interface Specification, Small Computer System Interface (SCSI), Elite Product Family", Document Number 64721702, Revision D, </title> <month> March </month> <year> 1992. </year>
Reference: [Seag92a] <author> Seagate Technology, Inc., </author> <title> "Seagate Product Specification, ST41600N and ST41601N Elite Disc Drive, SCSI Interface", Document Number 64403103, Revision G, </title> <month> October </month> <year> 1992. </year>
Reference: [Seag93] <author> Seagate Technology, Inc., </author> <title> "Seagate Product Specification, ST11750/1 N/ND and ST12550/1 N/ND Barracuda Disc Drive, SCSI Interface", Document Number 64403700, Revision A, </title> <month> January </month> <year> 1993. </year>
Reference-contexts: The mean response time measured for this combination exceeds 1 second (i.e., a saturated workload). The last few generations of SCSI disks provide queue depths of at least 16, with some disks queueing as many as 64 requests <ref> [Seag93] </ref>.
Reference: [Seam66] <author> P. Seaman, R. Lind, T. </author> <title> Wilson "An Analysis of Auxiliary-Storage Activity", </title> <journal> IBM System Journal, </journal> <volume> Vol. 5, No. 3, </volume> <year> 1966, </year> <pages> pp. 158-170. </pages>
Reference-contexts: Requests to the middle cylinders therefore receive better service. The SCAN algorithm has a number of variations. The Cyclical SCAN algorithm (C-SCAN) replaces the bidirectional scan with a single direction of travel <ref> [Seam66] </ref>. When the actuator reaches the last logical cylinder, a full-stroke seek returns it to the first cylinder without servicing any requests along the way. C-SCAN treats each cylinder equally rather than favoring the center cylinders.
Reference: [Selt90] <author> M. Seltzer, P. Chen, J. Ousterhout, </author> <title> "Disk Scheduling Revisited", </title> <booktitle> Proceedings of the Winter USENIX Conference, </booktitle> <address> Washington, D.C., </address> <month> January </month> <year> 1990, </year> <pages> pp. 313-324. </pages>
Reference-contexts: Several studies have examined the performance of such a scheduling algorithm. Denoted as Shortest Time First (STF) in <ref> [Selt90] </ref> and Shortest Access Time First (SATF) in [Jaco91], the term Shortest Positioning Time First (SPTF) is used in this work to clarify the exact purpose of this algorithm. Seltzer, et al., simulated a disk subsystem with a constant number of pending requests (up to 1000). <p> Seltzer, et al., simulated a disk subsystem with a constant number of pending requests (up to 1000). Jacobson and Wilkes simulated a disk subsystem with a Poisson arrival process for requests. Both studies used workloads with uniformly distributed request starting locations. The disk utilization numbers presented in <ref> [Selt90] </ref> indicate that SPTF provides up to 60% higher performance than C-LOOK or SSTF for the heaviest workloads. At the same time, the request response time variance for SPTF (a greedy algorithm) rises dramatically with increasing workload intensity. <p> The resulting algorithms are classified as either batch or aging algorithms. Batch algorithms service a subset of the pending requests, selected by some set of criteria, before moving on to other requests. Possible criteria include request arrival times and target cylinder numbers <ref> [Jaco91, Selt90, Coff72, Teor72, Fran69] </ref>. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages [Jaco91, Selt90]. Alternately, a time limit may be set after which requests move to a higher priority. <p> Possible criteria include request arrival times and target cylinder numbers [Jaco91, Selt90, Coff72, Teor72, Fran69]. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages <ref> [Jaco91, Selt90] </ref>. Alternately, a time limit may be set after which requests move to a higher priority. In either case, if an aging algorithm gives too much weight to the queue time (age) component, it degenerates into FCFS [Gotl73]. <p> Aged Shortest Positioning (w/Cache) Time First algorithm, which combines age 2 SPCTF classifies a read request as a hit if the first requested sector is resident in the cache or is currently being fetched from the media. 3 The ASATF algorithm was chosen instead of the WSTF algorithm suggested in <ref> [Selt90] </ref> because WSTF is less sensitive to differences in predicted positioning times when comparing requests whose waiting times are near the aging limit. 28 sensitivity and cache-sensitivity, is also included in the experiments. For a sufficiently large W, both ASPTF (W) and ASPCTF (W) degenerate into FCFS.
Reference: [Sugg90] <author> D. Suggs, </author> <title> "The Use of Future Knowledge in the Design of a Disk Scheduling Algorithm", </title> <type> Master's Thesis, </type> <institution> Clemson University, South Carolina, </institution> <year> 1990. </year>
Reference-contexts: As modern operating systems typically cache frequently accessed directory blocks in main memory, this workload was quite unrealistic. WSCAN (R), or Window SCAN, represents a slightly different continuum of scheduling algorithms between SSTF and LOOK <ref> [Sugg90] </ref>. WSCAN (R) emulates the LOOK algorithm while pulling a "service window" along behind. The R parameter indicates the size of the service window. When the algorithm schedules requests within the window, neither the "current" direction of travel nor the window boundaries change.
Reference: [Sugg93] <author> D. Suggs, </author> <title> "Disk Subsystem Performance and Reliability Enhancements Through the Use of Carnival Mirrors", </title> <type> Ph.D. Thesis, </type> <institution> Clemson University, South Carolina, </institution> <year> 1993. </year>
Reference-contexts: For example, if an array employs a redundancy scheme that pro 11 vides multiple paths for accessing data (e.g., disk mirroring), the array controller could dynamically route requests to the components that can most quickly service the requests <ref> [Poly93, Sugg93, Ng91, Chen90, Lee90, Bitt88] </ref>. Alternately, the array controller could schedule requests to the components with the shortest pending queues. In this dissertation, all information from "below" the scheduler relates to disk drive configuration and state.
Reference: [Teor72] <author> T. Teorey, T. Pinkerton, </author> <title> "A Comparative Analysis of Disk Scheduling Policies", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 15, No. 3, </volume> <month> March </month> <year> 1972, </year> <pages> pp. 177-184. </pages>
Reference-contexts: The C-LOOK algorithm combines C-SCAN and LOOK. Teorey and Pinkerton used both analytical and simulation models to analyze the performance of several scheduling algorithms, including FCFS, SSTF, LOOK, C-LOOK, and some hybrid algorithms optimized to handle extremely heavy workloads <ref> [Teor72] </ref>. Their simple models assumed a linear seek curve, zero command and completion overheads, no bus activity, uniformly distributed request starting locations, and a constant number of outstanding requests (i.e., a closed model). They showed that SSTF provides the lowest response times at the cost of poor starvation resistance. <p> However, they used simple synthetic work-loads with either uniformly, unimodally, or bimodally distributed request starting locations. Furthermore, their simulator configuration matched that reported in <ref> [Teor72] </ref>. They also implemented VSCAN (R) in a UNIX device driver on a DEC PDP-11/70 with two 134 MB SMD Fujitsu disk drives. The system workload consisted of eight or more university researchers doing program development, text editing, and some text formatting. <p> The resulting algorithms are classified as either batch or aging algorithms. Batch algorithms service a subset of the pending requests, selected by some set of criteria, before moving on to other requests. Possible criteria include request arrival times and target cylinder numbers <ref> [Jaco91, Selt90, Coff72, Teor72, Fran69] </ref>. Aging algorithms give priority to requests that have been in the request queue for excessive periods of time. Some algorithms gradually increase the priority as a request ages [Jaco91, Selt90]. Alternately, a time limit may be set after which requests move to a higher priority. <p> The squared coefficient of variation ( 2 = 2 ) of request response times is also reported, as in <ref> [Teor72] </ref>. Given a constant mean response time, a decrease in the coefficient of variation implies reduced response time variance (i.e., improved starvation resistance). Reducing starvation can indirectly improve system performance by reducing the possibility of high priority requests incurring excessive queueing time.
Reference: [Wilh76] <author> N. Wilhelm, </author> <title> "An Anomaly in Disk Scheduling: A Comparison of FCFS and SSTF Seek Scheduling Using an Empirical Model for Disk Accesses", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 19, No. 1, </volume> <month> January </month> <year> 1976, </year> <pages> pp. 13-17. </pages>
Reference-contexts: Although previous studies provide some insight into the general performance behavior of scheduling algorithms, many of their assumptions are not valid for modern high-performance computer systems. The complex characteristics of current disk drives cannot be duplicated with simple analytical or simulation models [Ruem94]. Synthetic or benchmark 1 <ref> [Wilh76] </ref> constructs a synthetic workload with very high physical locality for which FCFS provides good performance for some subsaturation arrival rates. 13 14 workloads with simple probability distributions for request starting locations or request inter-arrival times are unrepresentative of real-world systems [Ruem93, Bate91, Henl89, McNu86, Scra83, Lync72].
Reference: [Wort94] <author> B. Worthington, G. Ganger, Y. Patt, </author> <title> "Scheduling Algorithms for Modern Disk Drives", </title> <booktitle> Proceedings of the 1994 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Nashville, Tennessee, </address> <month> May </month> <year> 1994, </year> <pages> pp. 241-251. </pages>
Reference-contexts: Snake is from a file server at the University of California, Berkeley, used primarily for compilation and editing. While these traces are actually two months in length, the experiments in this dissertation use a single week-long snapshot (5/30/92 to 6/6/92), as in <ref> [Wort94, Ruem93] </ref>. The other four traces are from commercial VAX systems running the VMS operating system [Rama92]. <p> Experiments with full-knowledge schedulers use SPTF and a cache-sensitive version of SPTF termed Shortest Positioning (w/Cache) Time First <ref> [Wort94] </ref>. The SPCTF algorithm assumes a positioning time of zero for any read request that will hit in the on-board cache. 2 4.3.2 Scheduling with Information from "Above" The experiments in this dissertation explore overall system performance effects of various algorithms with and without explicit system-level information.
Reference: [Wort94a] <author> B. Worthington, G. Ganger, Y. Patt, </author> <title> "Scheduling for Modern Disk Drives and Non-Random Workloads", </title> <institution> University of Michigan, </institution> <type> Technical Report CSE-TR-194-94, </type> <month> March </month> <year> 1994. </year>
Reference: [Wort95] <author> B. Worthington, G. Ganger, Y. Patt, J. Wilkes, </author> <title> "On-line Extraction of SCSI Disk Drive Parameters", </title> <booktitle> Proceedings of the 1995 ACM SIGMETRICS Joint International Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Ottawa, Ontario, </address> <month> May </month> <year> 1995, </year> <pages> pp. 146-156. </pages>
Reference-contexts: If the necessary monitoring hardware is unavailable, an aggressive scheduler can estimate the current rotational position of a disk by tracking request completion times <ref> [Wort95] </ref>. Disk Controller The resources available to on-board disk controllers increase with each new generation of drives. Current disk drive components include powerful embedded microprocessors and large quantities of memory. <p> In particular, algorithms that reduce combined seek and rotational latencies require detailed information on command processing overheads, mechanical latencies, and data layout. To enable the use of such algorithms, a suite of quick and effective programs have been developed to extract the necessary information from modern SCSI disk drives. <ref> [Wort95] </ref> contains an overview of the extraction process. 2.1.2 Other I/O Path State Although the most important hardware-specific data relates to the disk drives, other I/O path components can also supply useful scheduling information. Bus adapters can provide the current status of intermediate and peripheral buses. <p> As disk technology is expected to improve dramatically in the next decade, studies identifying additional scheduling issues for future high-performance disk subsystems will be needed. * Full-knowledge scheduling algorithms are usually located at the disk drive, since they require extensive knowledge of disk drive configuration and state. However, <ref> [Wort95] </ref> describes how the necessary scheduling information can be extracted from modern SCSI disk drives for use in host-based schedulers. In order for a host-based full-knowledge scheduler to effectively utilize FCFS command-queued disks, it must also be able to predict request completion times and peripheral bus utilization.
References-found: 64

