URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/tcs94.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  kifer@cs.sunysb.edu  
Title: An Overview of Transaction Logic  
Author: Anthony J. Bonner Michael Kifer 
Date: 133:205-265, 1994.  
Note: Appears in Theoretical Computer Science (TCS),  Work supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada and by a Connaught Grant from the University of Toronto. Supported in part by NSF grant CCR-9102159.  
Address: Toronto, Ontario M5S 1A4, Canada  NY 11794-4400, U.S.A.  
Affiliation: Department of Computer Science University of Toronto  Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: This paper presents an overview of Transaction Logic|a new formalism recently introduced in [11, 12] and designed to deal with the phenomenon of state changes in logic programming, databases, and AI. Transaction Logic has a natural model theory and a sound and complete proof theory. Unlike many other logics, however, it is suitable for programming procedures that accomplish state transitions in a logically sound manner. Transaction logic amalgamates such features as hypothetical and committed updates, dynamic constraints on transaction execution, nondeterminism, and bulk updates. Transaction Logic also appears to be suitable as a logical model of hitherto non-logical phenomena, including so-called procedural knowledge in AI, and the behavior of object-oriented databases, especially methods with side effects. This paper is available at the following URL: ftp://db.toronto.edu/pub/bonner/papers/transaction.logic/tcs94.ps.gz 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and declarative database update languages. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 240-250, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: However, we also need a way to specify elementary changes to the database. One way to define such transitions is to build them into the semantics as in <ref> [40, 48, 8, 18, 1, 43] </ref>. The problem with this approach is that adding new 19 kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> In particular, it does not embrace the concept of the execution path, which is fundamental to T R. Consequently, dynamic constraints of the kind discussed in Section 2.6 and in [11] cannot be expressed. Abiteboul and Vianu developed a family of declarative update languages <ref> [1] </ref>, including impressive results on complexity and expressibility. However, these languages lack several features that are present in T R. First, they apply only to relational databases, not to arbitrary sets of first-order formulas. Thus, it is not possible to insert or delete rules from a deductive database. <p> This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require alternating PSPACE, that is, EXPTIME. The works [51, 19] are related to <ref> [1] </ref> in that they all borrow much of their syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory).
Reference: [2] <author> J.F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Like the situation calculus (and unlike T R), the event calculus makes a sharp distinction between actions and queries. However, inspired by James Allen's treatment of time and action <ref> [2] </ref>, the event calculus focuses on time intervals instead of states. <p> Temporal Logics for Reasoning about Action In addition to the situation and event calculi, there are other approaches to formulating action within first-order logic (e:g:; <ref> [2, 45, 31] </ref>). Generally, these approaches are concerned with difficult problems in Artificial Intelligence and Linguistics. Often they are concerned with the the interaction of time and action with belief, intention and causality.
Reference: [3] <editor> F. Bancilhon. A logic-programming/Object-oriented cocktail. </editor> <booktitle> SIGMOD Record, </booktitle> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: However, despite a plethora of action-logics, database researchers continue to complain that there is no clear declarative semantics for database updates <ref> [4, 3, 51] </ref>. In fact, no action logic has ever been adopted by a database or logic programming system, and none has become a core of database or logic-programming theory.
Reference: [4] <author> C. Beeri. </author> <title> New data models and languages|The challenge. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 1-15, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: However, despite a plethora of action-logics, database researchers continue to complain that there is no clear declarative semantics for database updates <ref> [4, 3, 51] </ref>. In fact, no action logic has ever been adopted by a database or logic programming system, and none has become a core of database or logic-programming theory.
Reference: [5] <author> H.A. Blair and V.S. Subrahmanian. </author> <title> Paraconsistent logic programming. </title> <journal> Theoretical Computer Science, </journal> <volume> 68 </volume> <pages> 135-154, </pages> <year> 1989. </year>
Reference-contexts: Our use of &gt; addresses this issue. Inconsistency has been addressed in more sophisticated ways in work on para-consistent logics. We mention, in particular, the works <ref> [5, 36, 37] </ref>, since their ideas can be applied to T R without much difficulty. 5 Hypothetical Reasoning Hypothetical queries play an important role in reasoning about knowledge.
Reference: [6] <author> A.J. Bonner. </author> <title> A logic for hypothetical reasoning. </title> <booktitle> In National Conference on Artificial Intelligence (AAAI), </booktitle> <address> St. Paul, Minn., August 1988. </address> <publisher> AAAI Press, </publisher> <address> Menlo Park, CA. </address>
Reference-contexts: A frequently cited example comes from the British Nationality Act, which states that, "You are eligible for citizenship if your father would be eligible if he were alive" [24]. The reader is referred to <ref> [6, 8, 9] </ref> for numerous other examples of hypothetical queries. Because of such queries, it is often necessary to perform hypothetical updates as well as real ones. <p> It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog <ref> [8, 10, 9, 7, 6] </ref>, including a sophisticated complexity analysis. Like T R, this work combines elementary updates 45 into complex transactions. Both works also use similar tactics to avoid the infamous frame problem [42].
Reference: [7] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Negation and linear recursion. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 286-300, </pages> <address> Philadelphia, PA, March 29-31 1989. </address> <publisher> ACM. </publisher>
Reference-contexts: It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog <ref> [8, 10, 9, 7, 6] </ref>, including a sophisticated complexity analysis. Like T R, this work combines elementary updates 45 into complex transactions. Both works also use similar tactics to avoid the infamous frame problem [42].
Reference: [8] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference-contexts: However, we also need a way to specify elementary changes to the database. One way to define such transitions is to build them into the semantics as in <ref> [40, 48, 8, 18, 1, 43] </ref>. The problem with this approach is that adding new 19 kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> A frequently cited example comes from the British Nationality Act, which states that, "You are eligible for citizenship if your father would be eligible if he were alive" [24]. The reader is referred to <ref> [6, 8, 9] </ref> for numerous other examples of hypothetical queries. Because of such queries, it is often necessary to perform hypothetical updates as well as real ones. <p> It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog <ref> [8, 10, 9, 7, 6] </ref>, including a sophisticated complexity analysis. Like T R, this work combines elementary updates 45 into complex transactions. Both works also use similar tactics to avoid the infamous frame problem [42].
Reference: [9] <author> A.J. Bonner. </author> <title> Hypothetical Reasoning in Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903, USA, </address> <month> October </month> <year> 1991. </year> <note> Published as Rutgers Technical Report DCS-TR-283. </note>
Reference-contexts: A frequently cited example comes from the British Nationality Act, which states that, "You are eligible for citizenship if your father would be eligible if he were alive" [24]. The reader is referred to <ref> [6, 8, 9] </ref> for numerous other examples of hypothetical queries. Because of such queries, it is often necessary to perform hypothetical updates as well as real ones. <p> It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog <ref> [8, 10, 9, 7, 6] </ref>, including a sophisticated complexity analysis. Like T R, this work combines elementary updates 45 into complex transactions. Both works also use similar tactics to avoid the infamous frame problem [42].
Reference: [10] <author> A.J. Bonner. </author> <title> Hypothetical Reasoning with Intuitionistic Logic. </title> <editor> In R. Demolombe and T. Imielin-ski, editors, </editor> <title> Non-Standard Queries and Answers, </title> <journal> Studies on Logic and Computation, </journal> <volume> chapter 8, </volume> <pages> pages 187-219. </pages> <publisher> Oxford University Press, </publisher> <month> October </month> <year> 1994. </year> <month> 52 </month>
Reference-contexts: It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog <ref> [8, 10, 9, 7, 6] </ref>, including a sophisticated complexity analysis. Like T R, this work combines elementary updates 45 into complex transactions. Both works also use similar tactics to avoid the infamous frame problem [42].
Reference: [11] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-270, </type> <institution> University of Toronto, </institution> <month> April </month> <year> 1992. </year> <note> Revised: February 1994. ftp://csri-technical-reports/270/report.ps. </note>
Reference-contexts: The paper also describes other aspects of T R, including hypothetical and retrospective reasoning, negation-as-failure, and updates of non-first-order databases. A general, non-Herbrand semantics and a sound-and-complete proof theory are presented in <ref> [11, 12] </ref>. T R was designed with several application in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. <p> It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. An extensive discussion of a number of applications of T R, both practical and theoretical, appears in <ref> [11, 14] </ref>. We outline several of these applications here. 1. T R provides a logical account for many update-related phenomena. For instance, in logic programming, T R provides a logical treatment of the assert and retract operators in Prolog. <p> For a wide class of problems, T R avoids what is known in AI as the frame problem. The frame problem arises because, to reason about updates, one must specify what does not change, as well as what does. This issue receives extensive treatment in <ref> [11] </ref>. On the surface, there would appear to be many other candidates for a logic of transactions, since many logics reason about updates or about the related phenomena of time and action. <p> Horn T R has a clean and simple proof theory that is sound and complete with respect to T R's model theory; it is described in detail in <ref> [11] </ref>. 2 Overview and Introductory Examples Using T R from the user's point of view is similar to using Prolog or using a relational database system. That is, the user may specify rules, and he may pose queries and request updates. <p> In this paper, we use the insertion and deletion of atomic formulas as canonical examples of elementary updates. However, many other kinds of elementary updates are also useful. In <ref> [11, 14] </ref>, we discuss several of them, including what we call bulk updates and non-deterministic sampling . Elementary updates are atomic in that they cannot be decomposed into simpler updates. We therefore represent them by atomic formulas. <p> T R fixes this problem by providing a simple logical semantics for database updates. The next example uses robot actions to illustrate non-deterministic rules. Planning of robot actions is discussed in detail in <ref> [11] </ref>. Example 2.13 (Non-Deterministic Robot Actions) The rules below define actions that simulate the movements of a robot arm in the blocks world [50]. <p> We illustrate this idea in two ways: first, through an informal example of robot navigation (i :e:; a routing problem), and then through two formal examples. More elaborate and formal examples are given in <ref> [11] </ref>. Consider the following conjunction of two robot actions: "Go to the kitchen" ^ "Don't pass through the bedroom" Note that each conjunct is a non-deterministic action, since there are many ways in which it can be carried out. <p> Instead, it combines them into a single, more tightly constrained transaction. Second, classical conjunction constrains the entire execution of a transaction (i :e:; the way in which it is carried out), not just the final state of the transaction. It can therefore express dynamic integrity constraints (see <ref> [11] </ref> for more details). In general, classical conjunction constrains transactions in two ways: (i) by causing transactions to fail, and (ii) by forcing non-deterministic transactions to execute in certain ways. The following examples illustrate these points. <p> Formally, the following statement is true: 6 P; D; D 0 j= (ins:lost _ ins:f ound) ^ (ins:lost _ ins:won) iff D 0 = D + flostg In this way, classical conjunction reduces non-determinism and, in this particular example, yields a completely deterministic transaction. 2 In <ref> [11] </ref>, we show that T R is a rich language for expressing constraints. Much of this richness comes from serial conjunction, especially when combined with negation. <p> In other words, such theories are not extensible. This is a serious problem, since the ability to add new transitions is by no means an esoteric whim. In <ref> [11, 14] </ref>, for instance, a new kind of transition called relational assignment is introduced for performing bulk updates and non-deterministic sampling. In scientific databases, an elementary transition may be a sophisticated numerical operation, such as a Fourier transform. <p> Such enumerations are not unusual|they are implicit in most logical inference systems, since axiom sets are normally infinite. 10 Moreover, the enumeration can be carried out by using built-in procedures to perform elementary updates <ref> [11] </ref>. The resulting inference system has an efficiency comparable to that of procedural programming languages. Finally, we note that transaction definitions are independent of the contents of the transition base and of the specifics of the enumeration algorithm. <p> Reasoning can still be performed in T R|it is just that T R does not offer specific advantages in this sphere. However, many reasoning problems, such as constraints and planning, can often be reduced to execution <ref> [11] </ref>. In such cases, T R does offer decided advantages over other reasoning systems. In planning, for instance, the infamous frame problem is not an issue [11]. 4 Herbrand-style Semantics This section develops the Herbrand-style semantics of T R, which is most useful in databases and logic programming. <p> However, many reasoning problems, such as constraints and planning, can often be reduced to execution <ref> [11] </ref>. In such cases, T R does offer decided advantages over other reasoning systems. In planning, for instance, the infamous frame problem is not an issue [11]. 4 Herbrand-style Semantics This section develops the Herbrand-style semantics of T R, which is most useful in databases and logic programming. A general, non-Herbrand semantics and a sound-and-complete proof theory are given in [11, 12]. The model theory of T R is based on a few simple ideas. <p> In planning, for instance, the infamous frame problem is not an issue [11]. 4 Herbrand-style Semantics This section develops the Herbrand-style semantics of T R, which is most useful in databases and logic programming. A general, non-Herbrand semantics and a sound-and-complete proof theory are given in <ref> [11, 12] </ref>. The model theory of T R is based on a few simple ideas. We first discuss these ideas, and then develop the Herbrand model theory in detail. 10 Consider common "axioms" such as _ :, [ ^ ( ! )] ! , and De Morgan's Laws. <p> Similar difficulties exist for deletion. Furthermore, insertions and deletions are not always the best choice for elementary updates <ref> [11] </ref>. For these reasons, we take a general approach to elementary updates. For us, an elementary update is a mapping that takes each database D 1 to some other database D 2 , where a database is any first-order formula (actually, an equivalence class of first-order formulas|per the discussion above). <p> Serial disjunction, , in particular, has many interesting applications, such as expressing universal constraints on transaction execution <ref> [11] </ref>. <p> In fact, path is equivalent to _ : for any formula , and thus path does not increase the expressive power of the logic. In contrast, state cannot be independently defined in T R, and so it does increase the expressive power of the logic <ref> [11] </ref>. Section 5 shows that state can be expressed using path and a hypothetical operator. It might seem that state gives a special status to paths of length 1, since T R can now distinguish them from all other paths. <p> Formally, this statement is read as follows: "Under transition base B and transaction base P, transaction succeeds from database D." When the context is clear, we simply say that transaction succeeds. Likewise, when statement (4) is not true, we say that transaction fails. In <ref> [11, 12] </ref>, we present an inference system that allows us to actually find a database sequence D 1 ; : : : ; D n (in fact, to enumerate all sequences) that satisfy Statement (3) whenever a transaction succeeds. Statement (6) is the dual of (4). <p> On the other hand, items 1, 2, and 3 combine existing entailments to infer new truths. Specifically, item 1 infers classical conjunctions; item 2 infers serial conjunctions; and item 3 infers defined transactions. Items 2-5 anticipate the proof procedures spelled out in <ref> [11, 12] </ref>, and indeed, they form the model-theoretic basis of these procedures. Item 1 is the basis for a wide class of dynamic constraints, such as those in Section 2.6. <p> Essentially, it is the user's responsibility to avoid this kind of inconsistency, by writing consistent transaction bases. This is easily accomplished in practice, since modern database and logic programming systems infer only positive facts. They are therefore guaranteed to be consistent. Even the advanced examples developed in <ref> [11, 14] </ref>, which go well beyond current technology, do not infer negative facts, and so do not lead to inconsistency. The second source of inconsistency is the transition base, B, which determines all possible state transitions in the system. <p> Thus, there is no way to insert or to derive a negative fact, so inconsistency is impossible. Even the advanced examples developed in <ref> [11, 14] </ref> do not lead to inconsistent views, since they do not infer negative facts. In other applications, however, especially those in AI, the derivation of both positive and negative facts may be important. <p> T R is the only logic we are aware of that can do both these things. This section extends the syntax and the semantics of T R to deal with hypotheticals. A sound-and-complete proof theory is developed in <ref> [11, 12] </ref>, where applications of hypothetical reasoning in T R are also discussed. One such application is presented at the end of this section. 5.1 Hypothetical Formulas To express hypotheticals, we introduce a modal operator "3" and a closely related operator "2". <p> Instead, we have the following two equivalences: 2 state ^ :3: 3 state ^ :2: However, it is not hard to define new hypotheticals for which the usual duality holds <ref> [11] </ref>. Such operators would be useful for reasoning about program execution, but this is outside the scope of this paper. 5.2 Retrospection There is another class of modal formulas related to hypotheticals. We call them retrospective formulas (abbr., retrospectives). <p> In the special case where P and contain no negation signs, the two definitions are equivalent. 6.1 Perfect-Model Semantics in the Applications In Section 5.3 we saw one example where negation as failure rather than classical negation was needed in T R. In <ref> [11] </ref>, we also show that temporal constraints on transaction execution, such as "unlock before shooting," also require negation as failure and, thus, a canonic model semantics of the kind described earlier. However, syntactically, these applications are not covered by Definition 6.1 of generalized-Horn rules. <p> Thus, many kinds of elementary update can be performed by specialized, efficient algorithms that are commonly used in database systems. Furthermore, many algorithmic features of database systems, such as bulk updates and random sampling, can be relegated to the transition base without sacrificing declarativeness <ref> [11, 14] </ref>. The same is true of heuristic approximations to intractable problems. Indeed, localizing the ad hoc nature of such heuristics to the transition base makes them invisible to the proof theory, the model theory, and the run-time environment of the system. <p> The same is true of heuristic approximations to intractable problems. Indeed, localizing the ad hoc nature of such heuristics to the transition base makes them invisible to the proof theory, the model theory, and the run-time environment of the system. Finally, as explained in <ref> [11] </ref>, elementary transitions need not be recursively enumerable, in general. Testing the emptiness of a predicate in a logic program is one example. <p> This complication is not called for, since, for instance, T R achieves the same effect in a much simpler, monotonic way, via so called bulk updates <ref> [11, 14] </ref>. Third, the syntax is not closed. For instance, negation can be applied to some formulas but not others. <p> The semantics of Hypothetical Datalog is also based on different principles than T R's. In particular, it does not embrace the concept of the execution path, which is fundamental to T R. Consequently, dynamic constraints of the kind discussed in Section 2.6 and in <ref> [11] </ref> cannot be expressed. Abiteboul and Vianu developed a family of declarative update languages [1], including impressive results on complexity and expressibility. However, these languages lack several features that are present in T R. First, they apply only to relational databases, not to arbitrary sets of first-order formulas. <p> Thus, there is no obvious way to materialize an updated database without also materializing all the logical consequences of the theory. In contrast, state materialization is a central feature of T R. This is, perhaps, most apparent in the proof theory in <ref> [11, 12] </ref>, where each new state is explicitly materialized. There is no analogue of this in other logics. Although logics of action can have great expressive power, it is sometimes the wrong kind of expressiveness for databases. <p> To a large extent, the situation calculus is orthogonal to T R: whereas the situation calculus focuses on specifying the effects of primitive actions, T R focuses on combining such actions into complex ones and executing them. A comprehensive comparison of T R with situation calculus appears in <ref> [11] </ref>. The Event Calculus The event calculus is also a methodology for encoding actions in first-order predicate logic. It was developed by Kowalski and Sergot for reasoning about time and events in a logic-programming setting [39, 38] and for overcoming some of the problems of the situation calculus. <p> As such, the number and the complexity of the axioms for these systems is quite large compared to the proof theory of T R. More importantly, developing a declarative programming language (like T R) for specifying and executing transactions is not their main concern. See <ref> [11] </ref> for a more thorough comparison with these works. In [47], Moszkowski develops an imperative programming language called Tempura based on Interval Temporal Logic (ITL) [30, 46]. <p> Consequently, Tempura has no built-in facilities for unification, for backtracking, or for non-determinism. * Although a notion of serial conjunction is defined, the dual notion of serial disjunction is not considered, nor is serial implication. Consequently, the kind of dynamic constraints described in Section 2.6 and in <ref> [11] </ref> were not developed. * Tempura represents an executable fragment of ITL, but a fragment without a clean, simple characterization. In particular, Tempura is not a "Horn" fragment of ITL. * Unlike serial-Horn T R (and classical Horn logic), Tempura lacks an efficient SLD-style inference system. <p> It is probably fair to say that T R is a formalization that accounts for almost all of PRS and more. Further comparison can be found in <ref> [11] </ref>. 9 Conclusions We have reviewed the main ideas underlying Transaction Logic, a novel declarative formalism for specifying and executing actions. A sound-and-complete proof theory and a wide range of applications were alluded to, but their full treatment appears elsewhere [11]. <p> Further comparison can be found in <ref> [11] </ref>. 9 Conclusions We have reviewed the main ideas underlying Transaction Logic, a novel declarative formalism for specifying and executing actions. A sound-and-complete proof theory and a wide range of applications were alluded to, but their full treatment appears elsewhere [11]. Applications include (but are not 51 limited to): view updates in databases, logic programming with "clean" assert and retract, object--oriented logic programming, temporal constraints among actions, planning robot actions, the frame problem in AI, subjunctive and counterfactual reasoning, program verification, and many others.
Reference: [12] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming (ICLP), </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The paper also describes other aspects of T R, including hypothetical and retrospective reasoning, negation-as-failure, and updates of non-first-order databases. A general, non-Herbrand semantics and a sound-and-complete proof theory are presented in <ref> [11, 12] </ref>. T R was designed with several application in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. <p> In planning, for instance, the infamous frame problem is not an issue [11]. 4 Herbrand-style Semantics This section develops the Herbrand-style semantics of T R, which is most useful in databases and logic programming. A general, non-Herbrand semantics and a sound-and-complete proof theory are given in <ref> [11, 12] </ref>. The model theory of T R is based on a few simple ideas. We first discuss these ideas, and then develop the Herbrand model theory in detail. 10 Consider common "axioms" such as _ :, [ ^ ( ! )] ! , and De Morgan's Laws. <p> Formally, this statement is read as follows: "Under transition base B and transaction base P, transaction succeeds from database D." When the context is clear, we simply say that transaction succeeds. Likewise, when statement (4) is not true, we say that transaction fails. In <ref> [11, 12] </ref>, we present an inference system that allows us to actually find a database sequence D 1 ; : : : ; D n (in fact, to enumerate all sequences) that satisfy Statement (3) whenever a transaction succeeds. Statement (6) is the dual of (4). <p> On the other hand, items 1, 2, and 3 combine existing entailments to infer new truths. Specifically, item 1 infers classical conjunctions; item 2 infers serial conjunctions; and item 3 infers defined transactions. Items 2-5 anticipate the proof procedures spelled out in <ref> [11, 12] </ref>, and indeed, they form the model-theoretic basis of these procedures. Item 1 is the basis for a wide class of dynamic constraints, such as those in Section 2.6. <p> T R is the only logic we are aware of that can do both these things. This section extends the syntax and the semantics of T R to deal with hypotheticals. A sound-and-complete proof theory is developed in <ref> [11, 12] </ref>, where applications of hypothetical reasoning in T R are also discussed. One such application is presented at the end of this section. 5.1 Hypothetical Formulas To express hypotheticals, we introduce a modal operator "3" and a closely related operator "2". <p> Thus, there is no obvious way to materialize an updated database without also materializing all the logical consequences of the theory. In contrast, state materialization is a central feature of T R. This is, perhaps, most apparent in the proof theory in <ref> [11, 12] </ref>, where each new state is explicitly materialized. There is no analogue of this in other logics. Although logics of action can have great expressive power, it is sometimes the wrong kind of expressiveness for databases.
Reference: [13] <author> A.J. Bonner and M. Kifer. </author> <title> A general logic of state change. </title> <type> Technical report, </type> <institution> CSRI, University of Toronto, </institution> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: There is no serious technical problem in handling non-ground atoms in elementary transitions. 8 In practice, however, preventing the user from tinkering with the definitions of elementary transitions may be a good software-engineering idea. 9 But see <ref> [13] </ref>, where a more general logic is described. 20 of (transaction) formulas; the current database state, D, which is a set of first-order formulas, and which is updatable by the transactions defined in P; and a transition base, B, which defines the set of elementary transitions.
Reference: [14] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages (DBPL), Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> Febru-ary </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. An extensive discussion of a number of applications of T R, both practical and theoretical, appears in <ref> [11, 14] </ref>. We outline several of these applications here. 1. T R provides a logical account for many update-related phenomena. For instance, in logic programming, T R provides a logical treatment of the assert and retract operators in Prolog. <p> In this paper, we use the insertion and deletion of atomic formulas as canonical examples of elementary updates. However, many other kinds of elementary updates are also useful. In <ref> [11, 14] </ref>, we discuss several of them, including what we call bulk updates and non-deterministic sampling . Elementary updates are atomic in that they cannot be decomposed into simpler updates. We therefore represent them by atomic formulas. <p> In other words, such theories are not extensible. This is a serious problem, since the ability to add new transitions is by no means an esoteric whim. In <ref> [11, 14] </ref>, for instance, a new kind of transition called relational assignment is introduced for performing bulk updates and non-deterministic sampling. In scientific databases, an elementary transition may be a sophisticated numerical operation, such as a Fourier transform. <p> Essentially, it is the user's responsibility to avoid this kind of inconsistency, by writing consistent transaction bases. This is easily accomplished in practice, since modern database and logic programming systems infer only positive facts. They are therefore guaranteed to be consistent. Even the advanced examples developed in <ref> [11, 14] </ref>, which go well beyond current technology, do not infer negative facts, and so do not lead to inconsistency. The second source of inconsistency is the transition base, B, which determines all possible state transitions in the system. <p> Thus, there is no way to insert or to derive a negative fact, so inconsistency is impossible. Even the advanced examples developed in <ref> [11, 14] </ref> do not lead to inconsistent views, since they do not infer negative facts. In other applications, however, especially those in AI, the derivation of both positive and negative facts may be important. <p> Thus, many kinds of elementary update can be performed by specialized, efficient algorithms that are commonly used in database systems. Furthermore, many algorithmic features of database systems, such as bulk updates and random sampling, can be relegated to the transition base without sacrificing declarativeness <ref> [11, 14] </ref>. The same is true of heuristic approximations to intractable problems. Indeed, localizing the ad hoc nature of such heuristics to the transition base makes them invisible to the proof theory, the model theory, and the run-time environment of the system. <p> This complication is not called for, since, for instance, T R achieves the same effect in a much simpler, monotonic way, via so called bulk updates <ref> [11, 14] </ref>. Third, the syntax is not closed. For instance, negation can be applied to some formulas but not others.
Reference: [15] <author> F. Bry. </author> <title> Intensional updates: Abduction via deduction. </title> <booktitle> In Intl. Conference on Logic Programming (ICLP), </booktitle> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: It therefore seems unlikely that this calculus can be developed into a full-blown logic in a straightforward or satisfying way. Furthermore, the calculus itself is very limited as a programming language, since it has no mechanism for defining recursion or subroutines. Bry <ref> [15] </ref> takes a two-tiered approach: first, he uses ordinary queries to determine (generate) the set of atoms to be added/deleted; then, he performs updates meta-logically. Dynamic constraints are also meta-logical; and they involve pairs of different theories. Thus [15] can neither define nor compose complex transactions. <p> Bry <ref> [15] </ref> takes a two-tiered approach: first, he uses ordinary queries to determine (generate) the set of atoms to be added/deleted; then, he performs updates meta-logically. Dynamic constraints are also meta-logical; and they involve pairs of different theories. Thus [15] can neither define nor compose complex transactions. It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. <p> Dynamic constraints are also meta-logical; and they involve pairs of different theories. Thus <ref> [15] </ref> can neither define nor compose complex transactions. It is also impossible to specify constraints on transaction execution or to insert and delete rules. In a sense, [15] provides a methodology for expressing what is to be updated rather than a logic for performing updates. Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog [8, 10, 9, 7, 6], including a sophisticated complexity analysis.
Reference: [16] <author> M.A. Casanova. </author> <title> The Concurrency Control Problem for Database Systems, </title> <booktitle> volume 116 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1981. </year>
Reference-contexts: One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors <ref> [16, 40, 49] </ref> base their approaches to updates on Dynamic Logic [32]. Casanova [16] applies an adaptation of Dynamic Logic to reasoning about concurrent execution of procedural programs that are built out of relational algebra operators plus an explicit relational assignment operator. <p> One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors [16, 40, 49] base their approaches to updates on Dynamic Logic [32]. Casanova <ref> [16] </ref> applies an adaptation of Dynamic Logic to reasoning about concurrent execution of procedural programs that are built out of relational algebra operators plus an explicit relational assignment operator. Updates are done in the hypothetical mode and no complete proof theory is given.
Reference: [17] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Instead, it may depend on the entire execution path of the transaction. Definition 4.9, below, captures this idea. This simple definition is sufficient for our present purposes. However, as with database queries <ref> [17] </ref>, this definition could be augmented with additional requirements, such as computability and genericity.
Reference: [18] <author> W. Chen. </author> <title> Declarative specification and evaluation of database updates. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases (DOOD), volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: However, we also need a way to specify elementary changes to the database. One way to define such transitions is to build them into the semantics as in <ref> [40, 48, 8, 18, 1, 43] </ref>. The problem with this approach is that adding new 19 kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> Chen has developed a calculus and an equivalent algebra for constructing transactions <ref> [18] </ref>. Like T R, this calculus uses logical operators to construct actions from elementary updates. There are several differences however. First, unlike T R, Chen's calculus is not a full-blown logic. It extends the domain calculus to include updates, but there is no notion of logical inference. <p> Because of his interest in deontic concepts, McCarty defines two notions of satisfaction. In one notion, called "strict satisfaction," conjunction, ^, corresponds to parallel action, as it does in Chen's work <ref> [18] </ref>. In the other notion, called "satisfaction," the same symbol corresponds to constraints, as it does in T R. However, since the focus of this work is on strict satisfaction, the development of path constraints was never considered.
Reference: [19] <author> C. de Maindreville and E. Simon. </author> <title> Non-deterministic queries and updates in deductive databases. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB). </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1988. </year>
Reference-contexts: That is, a transaction cannot be given a name, and then be invoked repeatedly from within the language. This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require alternating PSPACE, that is, EXPTIME. The works <ref> [51, 19] </ref> are related to [1] in that they all borrow much of their syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory).
Reference: [20] <author> R. Fagin, G.M. Kuper, J.D. Ullman, and M.Y. Vardi. </author> <title> Updating logical databases. In P.C. </title> <editor> Kanellakis, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 1-18. </pages> <publisher> Plenum Press, </publisher> <year> 1986. </year>
Reference-contexts: While [58, 34] take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi <ref> [21, 20] </ref> approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. <p> While [58, 34] take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi <ref> [21, 20] </ref> approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors [16, 40, 49] base their approaches to updates on Dynamic Logic [32].
Reference: [21] <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> On the semantics of updates in databases. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 352-365, </pages> <address> New York, 1983. </address> <publisher> ACM. </publisher>
Reference-contexts: While [58, 34] take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi <ref> [21, 20] </ref> approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. <p> While [58, 34] take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi <ref> [21, 20] </ref> approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors [16, 40, 49] base their approaches to updates on Dynamic Logic [32].
Reference: [22] <author> R.E. Fikes and N.J. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> <volume> 2 </volume> <pages> 189-208, </pages> <year> 1971. </year>
Reference-contexts: This functionality includes database queries and views; unification and rule-base inference; transaction and subroutine definition; deterministic and non-deterministic actions; static and dynamic 1 STRIPS was an early AI planning system that simulated the actions of a robot arm <ref> [22] </ref>. constraints; hypothetical and retrospective transactions; and a wide class of tests and conditions on actions, including pre-conditions, post-conditions, and intermediate conditions. Furthermore, many problems related to the updating of incomplete information can be dealt with efficiently. Perhaps most important, these diverse capabilities are not built into T R separately.
Reference: [23] <author> J. </author> <title> Finger. Exploiting Constraints in Design Synthesis. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1986. </year>
Reference-contexts: Indeed, there is no notion of database or of persistence in Tempura or in ITL, and there is no analogue to T R's transition base. Furthermore, if applied to databases, Tempura and ITL would both suffer from the frame problem and the ramification problem <ref> [42, 23] </ref>. 17 R. Kowalski, personal communication 50 * Although it has a logical semantics, Tempura is an imperative programming language, not a logic programming language.
Reference: [24] <editor> D.M. Gabbay and U. Reyle. N-prolog: </editor> <title> An extension of Prolog with hypothetical implications. I. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year>
Reference-contexts: A frequently cited example comes from the British Nationality Act, which states that, "You are eligible for citizenship if your father would be eligible if he were alive" <ref> [24] </ref>. The reader is referred to [6, 8, 9] for numerous other examples of hypothetical queries. Because of such queries, it is often necessary to perform hypothetical updates as well as real ones.
Reference: [25] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Logic Programming: Proceedings of the Fifth Conference and Symposium, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: Testing the emptiness of a predicate in a logic program is one example. In logic programming and deductive databases, such problems are typically dealt with by developing non-monotonic, second-order semantics, and by imposing syntactic restrictions on programs (e:g:; <ref> [54, 57, 25] </ref>). T R's transition base factors out such problems from the logic, so they can be treated separately.
Reference: [26] <editor> M.P. Georgeff and A.L. Lansky. </editor> <title> Procedural knowledge. </title> <booktitle> In Proc. IEEE Special Issue on Knowledge Representation, </booktitle> <volume> volume 74, </volume> <pages> pages 1384-1398, </pages> <year> 1986. </year> <month> 53 </month>
Reference-contexts: This is one reason why ITL must be extended in order to define subroutines, since there is no facility for assigning names to complex actions. Procedural Logic Georgeff and Lansky develop a formalism called Procedural Logic whose intent is very similar to that of T R <ref> [27, 26] </ref>. Both systems focus on executable specifications of transactions, both provide a subroutine facility, both allow for arbitrary primitive actions, both allow non-deterministic actions, and both provide some kind of constraints. Indeed, we are in complete agreement with Georgeff and Lansky on the limitations of existing logics of action.
Reference: [27] <author> M.P. Georgeff, A.L. Lansky, and P. Bessiere. </author> <title> A procedural logic. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 516-523, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1985. </year> <note> Morgan Kauf-mann. </note>
Reference-contexts: This is one reason why ITL must be extended in order to define subroutines, since there is no facility for assigning names to complex actions. Procedural Logic Georgeff and Lansky develop a formalism called Procedural Logic whose intent is very similar to that of T R <ref> [27, 26] </ref>. Both systems focus on executable specifications of transactions, both provide a subroutine facility, both allow for arbitrary primitive actions, both allow non-deterministic actions, and both provide some kind of constraints. Indeed, we are in complete agreement with Georgeff and Lansky on the limitations of existing logics of action.
Reference: [28] <author> G. Grahne. </author> <title> Updates and counterfactuals. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 269-276, </pages> <address> Boston, Mass., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Later on, Grahne, Katsuno and Mendelzon <ref> [34, 28, 29] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [29] <author> G. Grahne and A.O. Mendelzon. </author> <title> Updates and subjunctive queries. </title> <type> Technical Report KRR-TR-91-4, </type> <institution> CSRI, University of Toronto, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: This latter mechanism would not be available to ordinary programmers. For this reason, we assume in this paper that the transition base is fixed. The practical issue of how transition bases are to be generated was partly solved for us by Grahne, Mendelzon, and Winslett <ref> [29, 58] </ref>. Winslett showed that, in general, the problem of updating propositional formulas is NP-hard. Subsequently, though, Grahne and Mendelzon proved that updating sets of ground atoms with arbitrary propositional formulas can be done in polynomial time. <p> The semantics of each rule insertion and deletion is specified by the transition base, which may reflect any number of semantics that have been studied in the literature (e.g., <ref> [29, 58] </ref>). This approach works well and is completely general as long as a database is a collection of first-order formulas. However, many logic programs and deductive databases are not purely first-order, since they use negation-as-failure. This section addresses this point. <p> For databases containing arbitrary first-order formulas, the relationship between D and D 0 can be complex, and has been partly worked out by Grahne, Mendelzon, and Winslett <ref> [29, 58] </ref>. A simple case is rule insertion into Horn databases. Here, we would add the following formula to the transition base hD; D [ frgi ins:(r 0 ) for every Horn database, D, and every Horn rule, r, where r 0 is the reflection of r. <p> Later on, Grahne, Katsuno and Mendelzon <ref> [34, 28, 29] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [30] <author> J.Y. Halpern, Z. Manna, and B.C. Moszkowski. </author> <title> A high-level semantics based on interval logic. </title> <booktitle> In International Conference on Automata, Languages and Programming (ICALP), </booktitle> <pages> pages 278-291. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year> <booktitle> Number 154 in Lecture Notes in Computer Science. </booktitle>
Reference-contexts: More importantly, developing a declarative programming language (like T R) for specifying and executing transactions is not their main concern. See [11] for a more thorough comparison with these works. In [47], Moszkowski develops an imperative programming language called Tempura based on Interval Temporal Logic (ITL) <ref> [30, 46] </ref>. Moszkowski shows how each Tempura statement translates into ITL, shows how to specify numerous applications in Tempura, and describes an interpreter for executing Tempura programs. There are important similarities between Tempura and T R. For instance, Tempura emphasizes the execution of programs specified in logic.
Reference: [31] <author> J.Y. Halpern and Y. Shoham. </author> <title> A propositional modal logic of time intervals. </title> <booktitle> In Intl. Symposium on Logic in Computer Science (LICS), </booktitle> <pages> pages 279-292, </pages> <year> 1986. </year>
Reference-contexts: Temporal Logics for Reasoning about Action In addition to the situation and event calculi, there are other approaches to formulating action within first-order logic (e:g:; <ref> [2, 45, 31] </ref>). Generally, these approaches are concerned with difficult problems in Artificial Intelligence and Linguistics. Often they are concerned with the the interaction of time and action with belief, intention and causality.
Reference: [32] <author> D. Harel. </author> <title> First-Order Dynamic Logic, </title> <booktitle> volume 68 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Most other logics are not capable of this uniform treatment, since they see queries as propositions, but updates (or actions) are seen as entities of a different, incompatible nature. For instance, in situation calculus [41, 42], actions are function terms, while in Dynamic and Process Logics <ref> [32, 33] </ref>, actions are modal operators. Although T R is different from logics of action, it is comparable to declarative query languages, like Prolog and SQL. In Prolog, for instance, one does not reason about logic programs. Instead, one specifies and executes them. <p> One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors [16, 40, 49] base their approaches to updates on Dynamic Logic <ref> [32] </ref>. Casanova [16] applies an adaptation of Dynamic Logic to reasoning about concurrent execution of procedural programs that are built out of relational algebra operators plus an explicit relational assignment operator. Updates are done in the hypothetical mode and no complete proof theory is given.
Reference: [33] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidability, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: Most other logics are not capable of this uniform treatment, since they see queries as propositions, but updates (or actions) are seen as entities of a different, incompatible nature. For instance, in situation calculus [41, 42], actions are function terms, while in Dynamic and Process Logics <ref> [32, 33] </ref>, actions are modal operators. Although T R is different from logics of action, it is comparable to declarative query languages, like Prolog and SQL. In Prolog, for instance, one does not reason about logic programs. Instead, one specifies and executes them. <p> Semantically, T R is related to Process Logic <ref> [33] </ref>, but is different from it in several important respects. As in Process Logic, a model in T R consists of a set of states, and actions cause transitions from one state to another. <p> Thus, with just one model-theoretic device, paths, we can give meaning to statements about databases, elementary updates, and general transactions. Our reliance on paths in T R is reminiscent of a version of Process Logic described in <ref> [33] </ref>. However, there is a vast difference in how truth is defined and in what formulas actually denote. Further comparison is provided in Section 8. Database States Another difference between modal logic and Transaction Logic is in the nature of states. <p> This is formalized model-theoretically by the notion of executional entailment (Section 4.4). It is even more apparent in the proof theory, in which each elementary update produces a new database state. Process Logic As mentioned previously, our path structures are reminiscent of the "path models" in Process Logic <ref> [33] </ref>. 15 However, the meaning and intent of dynamic formulas in [33] is fundamentally different from that of transaction formulas in T R. The former is intended to reason about what is true during program execution, while T R was designed to actually execute declaratively specified procedures. <p> It is even more apparent in the proof theory, in which each elementary update produces a new database state. Process Logic As mentioned previously, our path structures are reminiscent of the "path models" in Process Logic <ref> [33] </ref>. 15 However, the meaning and intent of dynamic formulas in [33] is fundamentally different from that of transaction formulas in T R. The former is intended to reason about what is true during program execution, while T R was designed to actually execute declaratively specified procedures. This difference in the intent is reflected in the syntax. <p> This difference in the intent is reflected in the syntax. For instance, Process Logic uses a separate alphabet to represent actions, and a set of modal operators to reason about them. Thus, unlike T R, actions in <ref> [33] </ref> have a different status than propositions. In particular, actions are not logical formulas, but rather are terms used to construct modal operators. One consequence is that only elementary actions have names. <p> One consequence is that only elementary actions have names. Composite actions cannot be named, and thus the logic lacks a subroutine facility. 15 A number of different process logics have been proposed in the literature, beginning with Pratt's original work [52]. The version in <ref> [33] </ref> is closer to T R than any other incarnation of Process Logic we are aware of. 47 Another difference between T R and Process Logic is in the nature of states.
Reference: [34] <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowledge base and revising it. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 387-394, </pages> <address> Boston, Mass., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: In [11, 14], for instance, a new kind of transition called relational assignment is introduced for performing bulk updates and non-deterministic sampling. In scientific databases, an elementary transition may be a sophisticated numerical operation, such as a Fourier transform. Furthermore, Katsuno and Mendelzon <ref> [34] </ref> pointed out that, generally, state transitions belong to two major categories|updates and revisions|and, even within each category, several different flavours of such transitions are worth looking at. Thus, there appears to be no small, single set of elementary state transitions that is best for all purposes. <p> the predicates ins:b and del:b would be defined by an enumerable set of elementary state transitions consisting of the formulas hD; D + fbgi ins:b and hD; D fbgi del:b for every relational database D (if D is a general first-order formula, defining insertion and deletion is more involved; see <ref> [34] </ref>). We refer to the formulas themselves as elementary state transitions, and we call the enumerable set thereof transition base. The names of elementary transitions, such as ins:b and del:b, have no special status in T R. <p> In general, the transition base may represent any kind of update or revision discussed in <ref> [34] </ref>. However, unlike the transaction formulas in P, we do not expect the transition base to be coded by casual users. <p> For example, what does it mean to insert an atom b into a database that entails :b, especially if :b itself is not explicitly present in the database? There is no simple answer to this question, and many solutions have been proposed (see <ref> [34] </ref> for a comprehensive discussion). Similar difficulties exist for deletion. Furthermore, insertions and deletions are not always the best choice for elementary updates [11]. For these reasons, we take a general approach to elementary updates. <p> In such cases, inconsistency is possible, so users must be careful not to build 14 Of course, one may want to delete c, but this is radically different from inserting :c. The operation of deletion was called erasure in <ref> [34] </ref>. For instance, erasure (deletion) of c from D yields D _ D 0 , where D 0 is the result of inserting :c into D. <p> Later on, Grahne, Katsuno and Mendelzon <ref> [34, 28, 29] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results. <p> Later on, Grahne, Katsuno and Mendelzon [34, 28, 29] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results. While <ref> [58, 34] </ref> take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi [21, 20] approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative <p> While <ref> [58, 34] </ref> take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi [21, 20] approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors [16, 40, 49] base their approaches to updates on Dynamic Logic [32].
Reference: [35] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <month> May </month> <year> 1995. </year>
Reference-contexts: For instance, in logic programming, T R provides a logical treatment of the assert and retract operators in Prolog. This effectively extends the theory of logic programming to include updates as well as queries. In object-oriented databases, T R can be combined with object-oriented logics, such as F-logic <ref> [35] </ref>, to provide a logical account of methods, that is, of programs that comprise objects' interfaces and update their internal states. Thus, while F-logic covers the structural aspect of object-oriented databases, its combination with T R covers the behavioral aspect as well.
Reference: [36] <author> M. Kifer and E.L. Lozinskii. RI: </author> <title> A logic for reasoning with inconsistency. </title> <booktitle> In 4-th Intl Symp. on Logic in Computer Science, </booktitle> <pages> pages 253-262, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Our use of &gt; addresses this issue. Inconsistency has been addressed in more sophisticated ways in work on para-consistent logics. We mention, in particular, the works <ref> [5, 36, 37] </ref>, since their ideas can be applied to T R without much difficulty. 5 Hypothetical Reasoning Hypothetical queries play an important role in reasoning about knowledge.
Reference: [37] <author> M. Kifer and E.L. Lozinskii. </author> <title> A logic for reasoning with inconsistency. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(2) </volume> <pages> 179-215, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Our use of &gt; addresses this issue. Inconsistency has been addressed in more sophisticated ways in work on para-consistent logics. We mention, in particular, the works <ref> [5, 36, 37] </ref>, since their ideas can be applied to T R without much difficulty. 5 Hypothetical Reasoning Hypothetical queries play an important role in reasoning about knowledge.
Reference: [38] <author> R.A. Kowalski. </author> <title> Database updates in event calculus. </title> <journal> Journal of Logic Programming, </journal> 12(1&2):121-146, January 1992. 
Reference-contexts: A comprehensive comparison of T R with situation calculus appears in [11]. The Event Calculus The event calculus is also a methodology for encoding actions in first-order predicate logic. It was developed by Kowalski and Sergot for reasoning about time and events in a logic-programming setting <ref> [39, 38] </ref> and for overcoming some of the problems of the situation calculus. Like the situation calculus (and unlike T R), the event calculus makes a sharp distinction between actions and queries. <p> Instead, it records a history of events (database transactions), from which it can infer the state of the database at any given time. Furthermore, under certain conditions, it is possible to index the events and achieve efficiency comparable to assert and retract in Prolog <ref> [38] </ref>. <p> T R can also be of benefit to the event calculus, as it provides a logical mechanism for inserting events and their effects into the database, for revising incorrect assertions, and for combining simple events into complex transactions|a mechanism that is ostensibly lacking in <ref> [38] </ref>. Temporal Logics for Reasoning about Action In addition to the situation and event calculi, there are other approaches to formulating action within first-order logic (e:g:; [2, 45, 31]). Generally, these approaches are concerned with difficult problems in Artificial Intelligence and Linguistics.
Reference: [39] <author> R.A. Kowalski and M. Sergot. </author> <title> A logic-based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 67-95, </pages> <year> 1986. </year>
Reference-contexts: A comprehensive comparison of T R with situation calculus appears in [11]. The Event Calculus The event calculus is also a methodology for encoding actions in first-order predicate logic. It was developed by Kowalski and Sergot for reasoning about time and events in a logic-programming setting <ref> [39, 38] </ref> and for overcoming some of the problems of the situation calculus. Like the situation calculus (and unlike T R), the event calculus makes a sharp distinction between actions and queries.
Reference: [40] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: However, we also need a way to specify elementary changes to the database. One way to define such transitions is to build them into the semantics as in <ref> [40, 48, 8, 18, 1, 43] </ref>. The problem with this approach is that adding new 19 kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors <ref> [16, 40, 49] </ref> base their approaches to updates on Dynamic Logic [32]. Casanova [16] applies an adaptation of Dynamic Logic to reasoning about concurrent execution of procedural programs that are built out of relational algebra operators plus an explicit relational assignment operator. <p> Casanova [16] applies an adaptation of Dynamic Logic to reasoning about concurrent execution of procedural programs that are built out of relational algebra operators plus an explicit relational assignment operator. Updates are done in the hypothetical mode and no complete proof theory is given. Manchanda and Warren <ref> [40] </ref> introduce Dynamic Prolog|a logic system where update transactions "work right," i :e:; they do not leave a residue in the database when a transaction fails (the residue left by assert and retract is the most serious problem that plagues Prolog's update mechanism). <p> A dynamic interpretation associates a pair of states to each proposition, which resembles Dynamic Prolog of Manchanda and Warren <ref> [40] </ref>. However, the states associated with propositions by the dynamic interpretations of [56] are not database states but rather variable assignments. Van Benthem also discusses an algebraic approach to the logic of dynamic systems, which is akin to the action logic of Pratt [53].
Reference: [41] <author> J. McCarthy. </author> <title> Situations, actions, and clausal laws, </title> <type> memo 2. </type> <institution> Stanford Artificial Intelligence Project, </institution> <year> 1963. </year> <month> 54 </month>
Reference-contexts: Most other logics are not capable of this uniform treatment, since they see queries as propositions, but updates (or actions) are seen as entities of a different, incompatible nature. For instance, in situation calculus <ref> [41, 42] </ref>, actions are function terms, while in Dynamic and Process Logics [32, 33], actions are modal operators. Although T R is different from logics of action, it is comparable to declarative query languages, like Prolog and SQL. In Prolog, for instance, one does not reason about logic programs. <p> The Situation Calculus and Related Works The situation calculus is a methodology for specifying the effects of actions in first-order predicate calculus. It was introduced by John McCarthy <ref> [41] </ref> and then further developed by McCarthy and Hayes [42]. To a large extent, the situation calculus is orthogonal to T R: whereas the situation calculus focuses on specifying the effects of primitive actions, T R focuses on combining such actions into complex ones and executing them.
Reference: [42] <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher>
Reference-contexts: Most other logics are not capable of this uniform treatment, since they see queries as propositions, but updates (or actions) are seen as entities of a different, incompatible nature. For instance, in situation calculus <ref> [41, 42] </ref>, actions are function terms, while in Dynamic and Process Logics [32, 33], actions are modal operators. Although T R is different from logics of action, it is comparable to declarative query languages, like Prolog and SQL. In Prolog, for instance, one does not reason about logic programs. <p> Likewise, changes to a circuit design may be forbidden if the new design violates certain conditions (e:g :; limits on cost, size, or power consumption). It is worth noting that post-conditions can be awkward, if not impossible to express in other formalism of action, such as the situation calculus <ref> [42, 55] </ref>. Example 2.5 (Post-Conditions) If the atom happy is a query (i :e:; has no side effects), then the expression ins:won happy denotes an update followed by a test. <p> Bonner has carried out a thorough analysis of reasoning in Hypothetical Datalog [8, 10, 9, 7, 6], including a sophisticated complexity analysis. Like T R, this work combines elementary updates 45 into complex transactions. Both works also use similar tactics to avoid the infamous frame problem <ref> [42] </ref>. However, Hypothetical Datalog does not commit updates, does not deal with arbitrary logical databases, and does not combine updates with other logical connectives in arbitrary ways. Instead, Hypothetical Datalog is a disjunction-free logic programming system for relational databases. <p> The Situation Calculus and Related Works The situation calculus is a methodology for specifying the effects of actions in first-order predicate calculus. It was introduced by John McCarthy [41] and then further developed by McCarthy and Hayes <ref> [42] </ref>. To a large extent, the situation calculus is orthogonal to T R: whereas the situation calculus focuses on specifying the effects of primitive actions, T R focuses on combining such actions into complex ones and executing them. A comprehensive comparison of T R with situation calculus appears in [11]. <p> Indeed, there is no notion of database or of persistence in Tempura or in ITL, and there is no analogue to T R's transition base. Furthermore, if applied to databases, Tempura and ITL would both suffer from the frame problem and the ramification problem <ref> [42, 23] </ref>. 17 R. Kowalski, personal communication 50 * Although it has a logical semantics, Tempura is an imperative programming language, not a logic programming language.
Reference: [43] <author> L.T. McCarty. </author> <title> Permissions and obligations. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 287-294, </pages> <address> San Francisco, CA, 1983. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: However, we also need a way to specify elementary changes to the database. One way to define such transitions is to build them into the semantics as in <ref> [40, 48, 8, 18, 1, 43] </ref>. The problem with this approach is that adding new 19 kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> Van Benthem also discusses an algebraic approach to the logic of dynamic systems, which is akin to the action logic of Pratt [53]. McCarty has outlined a logic of action as part of a larger proposal for reasoning about deontic concepts <ref> [43] </ref>. His proposal contains three distinct layers, each with its own logic: first-order predicate logic, a logic of action, and a logic of permission and obligation.
Reference: [44] <author> L.T. McCarty and R. van der Meyden. </author> <title> Reasoning about indefinite actions. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 59-70, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: For instance, although a model theory based on sequences of partial states is presented, there is no sound-and-complete proof theory, and no mechanism is presented for executing actions or updating the database. In contrast, the recent work of McCarty and Van der Meyden <ref> [44] </ref> is much more detailed, but is very different from T R and is not intended for updating databases. The Situation Calculus and Related Works The situation calculus is a methodology for specifying the effects of actions in first-order predicate calculus.
Reference: [45] <author> D. McDermott. </author> <title> A temporal logic for reasoning about plans and processes. </title> <journal> Cognitive Science, </journal> <volume> 6 </volume> <pages> 101-155, </pages> <year> 1982. </year> <note> Reprinted in Readings in Planning, </note> <editor> J. Allen, J. Hendler, A. Tate (eds.), </editor> <publisher> Morgan-Kaufmann, </publisher> <year> 1990, </year> <pages> 436-463. </pages>
Reference-contexts: Temporal Logics for Reasoning about Action In addition to the situation and event calculi, there are other approaches to formulating action within first-order logic (e:g:; <ref> [2, 45, 31] </ref>). Generally, these approaches are concerned with difficult problems in Artificial Intelligence and Linguistics. Often they are concerned with the the interaction of time and action with belief, intention and causality.
Reference: [46] <author> B.C. Moszkowski. </author> <title> Reasoning about Digital Circuits. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> July </month> <year> 1983. </year> <note> Available as Technical Report STAN-CS-83-970. </note>
Reference-contexts: More importantly, developing a declarative programming language (like T R) for specifying and executing transactions is not their main concern. See [11] for a more thorough comparison with these works. In [47], Moszkowski develops an imperative programming language called Tempura based on Interval Temporal Logic (ITL) <ref> [30, 46] </ref>. Moszkowski shows how each Tempura statement translates into ITL, shows how to specify numerous applications in Tempura, and describes an interpreter for executing Tempura programs. There are important similarities between Tempura and T R. For instance, Tempura emphasizes the execution of programs specified in logic.
Reference: [47] <author> B.C. Moszkowski. </author> <title> Executing Temporal Logic Programs. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, U.K., </address> <year> 1986. </year>
Reference-contexts: More importantly, developing a declarative programming language (like T R) for specifying and executing transactions is not their main concern. See [11] for a more thorough comparison with these works. In <ref> [47] </ref>, Moszkowski develops an imperative programming language called Tempura based on Interval Temporal Logic (ITL) [30, 46]. Moszkowski shows how each Tempura statement translates into ITL, shows how to specify numerous applications in Tempura, and describes an interpreter for executing Tempura programs. <p> In particular, Tempura is not a "Horn" fragment of ITL. * Unlike serial-Horn T R (and classical Horn logic), Tempura lacks an efficient SLD-style inference system. In fact, proof theory is barely mentioned in <ref> [47] </ref>. * Although Tempura has subroutines, they cannot be expressed within ITL [47]. It may be possible to extend ITL to include (recursive) subroutines, perhaps by adding a fixpoint operator, but [47] provides no details. Finally, it is worth comparing T R, ITL and Process Logic (discussed earlier). <p> In particular, Tempura is not a "Horn" fragment of ITL. * Unlike serial-Horn T R (and classical Horn logic), Tempura lacks an efficient SLD-style inference system. In fact, proof theory is barely mentioned in <ref> [47] </ref>. * Although Tempura has subroutines, they cannot be expressed within ITL [47]. It may be possible to extend ITL to include (recursive) subroutines, perhaps by adding a fixpoint operator, but [47] provides no details. Finally, it is worth comparing T R, ITL and Process Logic (discussed earlier). <p> In fact, proof theory is barely mentioned in <ref> [47] </ref>. * Although Tempura has subroutines, they cannot be expressed within ITL [47]. It may be possible to extend ITL to include (recursive) subroutines, perhaps by adding a fixpoint operator, but [47] provides no details. Finally, it is worth comparing T R, ITL and Process Logic (discussed earlier). As in T R and Process Logic, formulas in ITL are true on paths, that is, on sequences of states.
Reference: [48] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: However, we also need a way to specify elementary changes to the database. One way to define such transitions is to build them into the semantics as in <ref> [40, 48, 8, 18, 1, 43] </ref>. The problem with this approach is that adding new 19 kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> To a certain extent, it can be said that Manchanda and Warren have managed to formalize their intuition as a program, but not as an inference system. Naqvi and Krishnamurthy <ref> [48] </ref> extended Datalog with update operators, which were later incorporated in the LDL language [49]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [48, 49] is somewhat limited. <p> Naqvi and Krishnamurthy [48] extended Datalog with update operators, which were later incorporated in the LDL language [49]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in <ref> [48, 49] </ref> is somewhat limited. First, it matches the execution model of LDL only in the propositional case, and so it does not cover bulk updates. Second, it is only defined for update-programs in which commutativity of elementary updates can be assumed. <p> Second, it is only defined for update-programs in which commutativity of elementary updates can be assumed. For sequences of updates in which this does not hold, the semantics turns out to be rather tricky and certainly does not qualify as "model theoretic." Third, the definition of "legal" programs in <ref> [48, 49] </ref> is highly restrictive, making it difficult to build complex transactions out of simpler ones. Chen has developed a calculus and an equivalent algebra for constructing transactions [18]. Like T R, this calculus uses logical operators to construct actions from elementary updates. There are several differences however.
Reference: [49] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors <ref> [16, 40, 49] </ref> base their approaches to updates on Dynamic Logic [32]. Casanova [16] applies an adaptation of Dynamic Logic to reasoning about concurrent execution of procedural programs that are built out of relational algebra operators plus an explicit relational assignment operator. <p> To a certain extent, it can be said that Manchanda and Warren have managed to formalize their intuition as a program, but not as an inference system. Naqvi and Krishnamurthy [48] extended Datalog with update operators, which were later incorporated in the LDL language <ref> [49] </ref>. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [48, 49] is somewhat limited. <p> Naqvi and Krishnamurthy [48] extended Datalog with update operators, which were later incorporated in the LDL language [49]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in <ref> [48, 49] </ref> is somewhat limited. First, it matches the execution model of LDL only in the propositional case, and so it does not cover bulk updates. Second, it is only defined for update-programs in which commutativity of elementary updates can be assumed. <p> Second, it is only defined for update-programs in which commutativity of elementary updates can be assumed. For sequences of updates in which this does not hold, the semantics turns out to be rather tricky and certainly does not qualify as "model theoretic." Third, the definition of "legal" programs in <ref> [48, 49] </ref> is highly restrictive, making it difficult to build complex transactions out of simpler ones. Chen has developed a calculus and an equivalent algebra for constructing transactions [18]. Like T R, this calculus uses logical operators to construct actions from elementary updates. There are several differences however.
Reference: [50] <author> N.J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Tioga Publ. Co., </publisher> <address> Paolo Alto, CA, </address> <year> 1980. </year>
Reference-contexts: The next example uses robot actions to illustrate non-deterministic rules. Planning of robot actions is discussed in detail in [11]. Example 2.13 (Non-Deterministic Robot Actions) The rules below define actions that simulate the movements of a robot arm in the blocks world <ref> [50] </ref>.
Reference: [51] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference-contexts: However, despite a plethora of action-logics, database researchers continue to complain that there is no clear declarative semantics for database updates <ref> [4, 3, 51] </ref>. In fact, no action logic has ever been adopted by a database or logic programming system, and none has become a core of database or logic-programming theory. <p> That is, a transaction cannot be given a name, and then be invoked repeatedly from within the language. This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require alternating PSPACE, that is, EXPTIME. The works <ref> [51, 19] </ref> are related to [1] in that they all borrow much of their syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory).
Reference: [52] <author> V.R. Pratt. </author> <title> Process logic. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 93-100, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: One consequence is that only elementary actions have names. Composite actions cannot be named, and thus the logic lacks a subroutine facility. 15 A number of different process logics have been proposed in the literature, beginning with Pratt's original work <ref> [52] </ref>. The version in [33] is closer to T R than any other incarnation of Process Logic we are aware of. 47 Another difference between T R and Process Logic is in the nature of states.
Reference: [53] <author> V.R. Pratt. </author> <title> Action logic and pure induction. </title> <booktitle> In Workshop on Logics in AI, volume 478 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-120. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Consequently, there is no counterpart to T R's dual connective of serial disjunction, nor to serial implication. Thus, there is no obvious way to express constraints based on these connectives, like the one illustrated in Section 6.1. Action Logics Pratt <ref> [53] </ref> develops a logic, called Action Logic, that is similar to, yet different from T R. Like T R, Action Logic does not distinguish between actions and propositions: actions are simply propositions that hold on intervals. The semantics and the intent of the two formalisms are very different however. <p> Combined with negation, they lead to two kinds of disjunction, and two kinds of implication, in a natural way. In contrast, Action Logic obtains much of its simplicity by having one type of conjunction (serial conjunction), as pointed out in <ref> [53] </ref>. Action algebras have a lattice-like "meet" operator that might form the model-theoretic basis for another kind of conjunction, but unfortunately, the meet operation is not always defined. In [56], van Benthem outlines a number of logical approaches to dynamic information processing. <p> However, the states associated with propositions by the dynamic interpretations of [56] are not database states but rather variable assignments. Van Benthem also discusses an algebraic approach to the logic of dynamic systems, which is akin to the action logic of Pratt <ref> [53] </ref>. McCarty has outlined a logic of action as part of a larger proposal for reasoning about deontic concepts [43]. His proposal contains three distinct layers, each with its own logic: first-order predicate logic, a logic of action, and a logic of permission and obligation.
Reference: [54] <author> T.C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Otherwise, if :a necessarily holds, then c will be executed. The negation ":" here is of the negation-by-failure variety. In Section 6, we shall discuss the perfect-model semantics for such negation, which is an adaptation from <ref> [54] </ref>. In executing transaction ? if 3a b c above, the subtransaction ? a was executed hypothetically, i :e:; without states being changed. If such an execution is possible, then b is executed "for real" and the system may end up in a different state. <p> However, in Logic Programming and in AI, it is common to treat the negation operator as negation-as-failure rather than in the classical sense. One widely accepted formalization of negation-as-failure is based on the so-called perfect-model semantics <ref> [54] </ref>. In this section, we adapt this semantics to T R. We use perfect-model semantics because it is two-valued and, therefore, is easy to transplant to T R. <p> For instance, since the informal meaning of :p is that "p cannot be proved," what is the meaning of the rule p :p ? To avoid such problems, we restrict our attention to locally-stratified transaction bases, which generalize the locally-stratified logic programs defined in <ref> [54] </ref>. To define local stratification, let P be a transaction base. P fl then denotes the ground instantiation of P, i :e:; the set of all ground instances of rules in P. Following [54], we construct a directed graph, D (P), whose nodes are atoms in P fl . <p> problems, we restrict our attention to locally-stratified transaction bases, which generalize the locally-stratified logic programs defined in <ref> [54] </ref>. To define local stratification, let P be a transaction base. P fl then denotes the ground instantiation of P, i :e:; the set of all ground instances of rules in P. Following [54], we construct a directed graph, D (P), whose nodes are atoms in P fl . <p> We can now define the perfect models of a transaction base, P, and a transition base, B. They are defined in terms of a preference order, t, on the models of P and B. Our definition follows the outline of <ref> [54] </ref>. Let M and M 0 be a pair of Herbrand path models of P and B. <p> As in <ref> [54] </ref>, it can be verified that every locally-stratified transaction base has a unique perfect model. Note that in (15) we compare path-models on two different paths, and 0 . The necessity of this should be clear from the following example. <p> This set is usually much smaller than the set of all models and often there is only one canonic model per database. One way to define canonic models is to use the perfect-model semantics of <ref> [54] </ref>. In this section, however, we need not commit ourselves to any specific definition of canonic models. <p> Testing the emptiness of a predicate in a logic program is one example. In logic programming and deductive databases, such problems are typically dealt with by developing non-monotonic, second-order semantics, and by imposing syntactic restrictions on programs (e:g:; <ref> [54, 57, 25] </ref>). T R's transition base factors out such problems from the logic, so they can be treated separately.
Reference: [55] <author> R. Reiter. </author> <title> Formalizing database evolution in the situation calculus. </title> <booktitle> In Conf. on Fifth Generation Computer Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Likewise, changes to a circuit design may be forbidden if the new design violates certain conditions (e:g :; limits on cost, size, or power consumption). It is worth noting that post-conditions can be awkward, if not impossible to express in other formalism of action, such as the situation calculus <ref> [42, 55] </ref>. Example 2.5 (Post-Conditions) If the atom happy is a query (i :e:; has no side effects), then the expression ins:won happy denotes an update followed by a test.
Reference: [56] <author> J. van Benthem. </author> <title> Language in Action: Categories, Lambdas and Dynamic Logic. </title> <publisher> Elsevier Science Pub. Co., </publisher> <address> Amsterdam, New York, </address> <year> 1991. </year> <month> 55 </month>
Reference-contexts: Action algebras have a lattice-like "meet" operator that might form the model-theoretic basis for another kind of conjunction, but unfortunately, the meet operation is not always defined. In <ref> [56] </ref>, van Benthem outlines a number of logical approaches to dynamic information processing. These approaches and T R share the idea that actions are to be represented as propositions, but the similarities end here. <p> These approaches and T R share the idea that actions are to be represented as propositions, but the similarities end here. The proposed logics are not path-based and there is no notion analogous to the transition base of T R. 16 One of the approaches in <ref> [56] </ref> is based on a dynamic interpretation of 16 van Benthem actually mentions that a path-based logic would be desirable, but no such logic was developed in [56]. 48 classical predicate logic. <p> logics are not path-based and there is no notion analogous to the transition base of T R. 16 One of the approaches in <ref> [56] </ref> is based on a dynamic interpretation of 16 van Benthem actually mentions that a path-based logic would be desirable, but no such logic was developed in [56]. 48 classical predicate logic. A dynamic interpretation associates a pair of states to each proposition, which resembles Dynamic Prolog of Manchanda and Warren [40]. However, the states associated with propositions by the dynamic interpretations of [56] are not database states but rather variable assignments. <p> that a path-based logic would be desirable, but no such logic was developed in <ref> [56] </ref>. 48 classical predicate logic. A dynamic interpretation associates a pair of states to each proposition, which resembles Dynamic Prolog of Manchanda and Warren [40]. However, the states associated with propositions by the dynamic interpretations of [56] are not database states but rather variable assignments. Van Benthem also discusses an algebraic approach to the logic of dynamic systems, which is akin to the action logic of Pratt [53].
Reference: [57] <author> A. Van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 221-230, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: Testing the emptiness of a predicate in a logic program is one example. In logic programming and deductive databases, such problems are typically dealt with by developing non-monotonic, second-order semantics, and by imposing syntactic restrictions on programs (e:g:; <ref> [54, 57, 25] </ref>). T R's transition base factors out such problems from the logic, so they can be treated separately.
Reference: [58] <author> M. Winslett. </author> <title> A model based approach to updating databases with incomplete information. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(2) </volume> <pages> 167-196, </pages> <year> 1988. </year> <month> 56 </month>
Reference-contexts: This latter mechanism would not be available to ordinary programmers. For this reason, we assume in this paper that the transition base is fixed. The practical issue of how transition bases are to be generated was partly solved for us by Grahne, Mendelzon, and Winslett <ref> [29, 58] </ref>. Winslett showed that, in general, the problem of updating propositional formulas is NP-hard. Subsequently, though, Grahne and Mendelzon proved that updating sets of ground atoms with arbitrary propositional formulas can be done in polynomial time. <p> The semantics of each rule insertion and deletion is specified by the transition base, which may reflect any number of semantics that have been studied in the literature (e.g., <ref> [29, 58] </ref>). This approach works well and is completely general as long as a database is a collection of first-order formulas. However, many logic programs and deductive databases are not purely first-order, since they use negation-as-failure. This section addresses this point. <p> For databases containing arbitrary first-order formulas, the relationship between D and D 0 can be complex, and has been partly worked out by Grahne, Mendelzon, and Winslett <ref> [29, 58] </ref>. A simple case is rule insertion into Horn databases. Here, we would add the following formula to the transition base hD; D [ frgi ins:(r 0 ) for every Horn database, D, and every Horn rule, r, where r 0 is the reflection of r. <p> T R's transition base factors out such problems from the logic, so they can be treated separately. In this way, T R is able to provide a monotonic, first-order semantics for combining elementary updates (even very nasty ones) into complex transactions. 8.1 Declarative Languages for Database Updates Winslett <ref> [58] </ref> did foundational work by supplying the first generally acceptable semantic definition for the result of updating a logical theory. <p> Later on, Grahne, Katsuno and Mendelzon [34, 28, 29] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results. While <ref> [58, 34] </ref> take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi [21, 20] approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative <p> While <ref> [58, 34] </ref> take a model-theoretic view of elementary updates, Fagin, Kuper, Ullman, and Vardi [21, 20] approach the problem syntactically. One interesting consequence of this is that, while in [58, 34] an elementary update is always deterministic, in [21, 20] updating a theory with a formula may lead to several alternative states. Several authors [16, 40, 49] base their approaches to updates on Dynamic Logic [32].
References-found: 58

