URL: http://www-cad.eecs.berkeley.edu/~orna/publications/cav96a.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: vardi@cs.rice.edu,  Email: pw@montefiore.ulg.ac.be,  
Title: Module Checking  
Author: Orna Kupferman Moshe Y. Vardi Pierre Wolper 
Web: URL: http://www.cs.rice.edu/  URL: http://www.montefiore.ulg.ac.be/ pw.  
Address: Houston, TX 77005-1892, U.S.A.  Address: Institut Montefiore, B28; B-4000 Liege Sart-Tilman; Belgium.  
Note: Address:  vardi. Supported in part by NSF grants CCR-9628400 and CCR-9700061, and by a grant from the Intel  
Date: February 5, 1998  
Affiliation: UC Berkeley  Rice University  Universite de Liege  Department of Computer Science,  Corporation.  
Abstract: In computer system design, we distinguish between closed and open systems. A closed system is a system whose behavior is completely determined by the state of the system. An open system is a system that interacts with its environment and whose behavior depends on this interaction. The ability of temporal logics to describe an ongoing interaction of a reactive program with its environment makes them particularly appropriate for the specification of open systems. Nevertheless, model-checking algorithms used for the verification of closed systems are not appropriate for the verification of open systems. Correct model checking of open systems should check the system with respect to arbitrary environments and should take into account uncertainty regarding the environment. This is not the case with current model-checking algorithms and tools. In this paper we introduce and examine the problem of model checking of open systems (module checking , for short). We show that while module checking and model checking coincide for the linear-time paradigm, module checking is much harder than model checking for the branching-time paradigm. We prove that the problem of module checking is EXPTIME-complete for specifications in CTL and is 2EXPTIME-complete for specifications in CTL ? . This bad news is also carried over when we consider the program-complexity of module checking. As good news, we show that for the commonly-used fragment of CTL (universal, possibly, and always possibly properties), current model-checking tools do work correctly, or can be easily adjusted to work correctly, with respect to both closed and open systems. fl Address: EECS Department, Berkeley, CA 94720-1770, U.S.A. Email: orna@ic.eecs.berkeley.edu, URL: http://www.eecs.berkeley.edu/ ~ orna. Supported in part by ONR YIP award N00014-95-1-0520, by NSF CAREER award CCR-9501708, by NSF grant CCR-9504469, by AFOSR contract F49620-93-1-0056, by ARO MURI grant DAAH-04-96-1-0341, by ARPA grant NAG2-892, and by SRC contract 95-DC-324.036. 
Abstract-found: 1
Intro-found: 1
Reference: [AHK97] <author> R. Alur, T.A. Henzinger, and O. Kupferman. </author> <title> Alternating-time temporal logic. </title> <booktitle> In Proc. 38th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> Florida, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: This then implies that the logic should be extended in order to explicitly specify over which choices path quantifiers should be interpreted. This idea is investigated in <ref> [AHK97] </ref>. We examine the complexity of the module-checking problem for linear and branching temporal logics. Recall that for the linear paradigm, the problem of module checking coincides with the problem of model checking. Hence, the known complexity results for LTL model checking remain valid.
Reference: [ALW89] <author> M. Abadi, L. Lamport, and P. Wolper. </author> <title> Realizable and unrealizable concurrent program specifications. </title> <booktitle> In Proc. 16th Int. Colloquium on Automata, Languages and Programming, </booktitle> <volume> volume 372, </volume> <pages> pages 1-17. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: In other words, when one is checking for the possibility of synthesizing part of the system. Quite interestingly, the reactive module synthesis problem studied in [PR89a, PR89b] or the realizability problem of <ref> [ALW89] </ref> can be described as CTL ? module checking problems. A similar link also exists with the supervisory control problem studied in the context of control theory [Ant95].
Reference: [Ant95] <author> M. Antoniotti. </author> <title> Synthesis and verification of discrete controllers for robotics and manufacturing devices with temporal logic and the Control-D system. </title> <type> PhD thesis, </type> <address> New York University, New York, </address> <year> 1995. </year>
Reference-contexts: Quite interestingly, the reactive module synthesis problem studied in [PR89a, PR89b] or the realizability problem of [ALW89] can be described as CTL ? module checking problems. A similar link also exists with the supervisory control problem studied in the context of control theory <ref> [Ant95] </ref>. Once one adopts this view that what we need is module checking rather than model checking, the usual argument that, from a complexity point of view, CTL is easier than LTL, topples. Indeed, the situation is then similar to the one existing for validity checking.
Reference: [ASSS94] <author> A. Aziz, T.R. Shiple, V. Singhal, and A.L. Sangiovanni-Vincentelli. </author> <title> Formula-dependent equivalence for compositional CTL model checking. </title> <booktitle> In Proc. 6th Conf. on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-337, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Note that jAj is independent of the sizes of and D. Note also that A can be stored in space O (jAj). 4 A different problem where a specification is checked to be correct with respect to any environment is discussed in <ref> [ASSS94] </ref>.
Reference: [BBG + 94] <author> I. Beer, S. Ben-David, D. Geist, R. Gewirtzman, and M. Yoeli. </author> <title> Methodology and system for practical formal verification of reactive hardware. </title> <booktitle> In Proc. 6th Conference on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 182-193, </pages> <address> Stanford, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states [McM93, CGL93] are incorporated into industrial development of new designs <ref> [BBG + 94] </ref>. If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. <p> On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL <ref> [Lon93, BBG + 94, KG96] </ref>, have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. On the other hand, the computational superiority of CTL is also not that clear.
Reference: [BCG88] <author> M.C. Browne, E.M. Clarke, and O. Grumberg. </author> <title> Characterizing finite Kripke structures in propositional temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 115-131, </pages> <year> 1988. </year>
Reference-contexts: Thus, we can check bisimilarity between two modules in linear time, exactly as we check bisimilarity between programs. As in <ref> [BCG88] </ref>, two modules are bisimilar iff they agree on satisfaction (in the module-checking sense) of all CTL ? formulas. Our results are summarized in the table below.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. 5th Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Checking nonemptiness of a Buchi tree automaton can be reduced to calculating a -calculus expression of alternation depth 2 [Rab69, VW86b]. As such, it can be implemented, using symbolic methods, in tools that handle fixed-point calculations (e.g., SMV <ref> [BCM + 90, McM93] </ref>). 5 Pragmatics How bad is our news? In this section we show that from a pragmatic point of view, it is not that bad.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: As the program complexity of model checking for both CTL and CTL ? is NLOGSPACE <ref> [BVW94] </ref>, this is bad news too. As a consolation for the branching-time paradigm, we show that from a practical point of view, our news is not that bad. We show that in the absence of existential quantification, module checking and model checking do coincide. <p> In this section we consider the program complexity [VW86a] of module checking; i.e., the complexity of this problem in terms of the size of the input module, assuming the formula is fixed. It is known that the program complexity of LTL, CTL, and CTL ? model checking is NLOGSPACE <ref> [VW86a, BVW94] </ref>. <p> In particular, it follows from Lemma 5.1 that module checking and model checking coincides for linear temporal logics. Theorem 5.2 now follows from the known complexity results for LTL, 8CTL, and 8CTL ? model checking <ref> [SC85, CES86, BVW94, VW94] </ref>. <p> On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE <ref> [VW86a, BVW94] </ref>. As shown in [Var95, KV95], the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further. <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] <ref> [BVW94] </ref> [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. <p> the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] <ref> [BVW94] </ref> [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems. <p> complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] <ref> [BVW94] </ref> [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems. <p> checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] <ref> [BVW94] </ref> [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems. <p> [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] <ref> [BVW94] </ref> [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: We use M j= to indicate that when we regard M as a program (thus refer to all its states as system states), then M satisfies . The problem of deciding whether M j= is the usual model-checking problem <ref> [CE81, QS81] </ref>. It is easy to see that while M j= r implies that M j= , the other direction is not necessarily true. Also, while M j= implies that M 6j= r : , the other direction is not true as well.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: In fact, it is as hard as sat-isfiability. Thus, CTL module checking is EXPTIME-complete and CTL ? module checking is 2EXPTIME-complete, both worse than the PSPACE complexity we have for LTL. Keeping in mind that CTL model checking can be done in linear time <ref> [CES86] </ref> and CTL ? model checking can be done in polynomial space [EL85], this is really bad news. <p> In particular, it follows from Lemma 5.1 that module checking and model checking coincides for linear temporal logics. Theorem 5.2 now follows from the known complexity results for LTL, 8CTL, and 8CTL ? model checking <ref> [SC85, CES86, BVW94, VW94] </ref>. <p> Indeed, the restricted syntax of CTL limits its expressive power and many important behaviors (e.g., strong fairness) can not be specified in CTL. On the other hand, while model checking for CTL can be done in time O (jP j fl j j) <ref> [CES86] </ref>, it takes time O (jP j fl 2 j j ) for LTL [LP85]. Since LTL model checking is PSPACE-complete [SC85], the latter bound probably cannot be improved. <p> If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL <ref> [CES86] </ref> and of many other extensions to CTL [Lon93, BBG + 94, KG96], have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME <ref> [CES86] </ref> [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. <p> program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME <ref> [CES86] </ref> [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems. <p> checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME <ref> [CES86] </ref> [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems. <p> [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME <ref> [CES86] </ref> [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Decade of Concurrency Reflections and Perspectives (Proceedings of REX School), volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Since LTL model checking is PSPACE-complete [SC85], the latter bound probably cannot be improved. The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states <ref> [McM93, CGL93] </ref> are incorporated into industrial development of new designs [BBG + 94]. If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86].
Reference: [Cle93] <author> R. Cleaveland. </author> <title> A linear-time model-checking algorithm for the alternation-free modal - calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2 </volume> <pages> 121-147, </pages> <year> 1993. </year> <month> 21 </month>
Reference-contexts: Hence, M j= r AGEF ~ , M j= -z:[y:~ _ (s ^ EXy) _ (e ^ AXy)] ^ AXz: So, we reduced module checking of possibly and always possibly properties to model checking of an alternation-free -calculus formula. As the latter can be done in linear running time <ref> [Cle93] </ref>, we are done. Again, as our algorithms involve at most two simple fixed-point computations, they can be easily implemented symbolically.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: More consolation can be found in "possibly" and "always possibly" properties. These classes of properties are considered an advantage of the branching paradigm. While being easily specified using the CTL formulas EF ~ and AGEF ~, these properties cannot be specified in LTL <ref> [EH86] </ref>. We show that module checking of the formulas EF ~ and AGEF ~ can be done in linear time (though the problems 2 Readers familiar with game theory can view module checking as solving an infinite game between the system and the environment. <p> We call properties of this form always possibly properties. It is easy to see that possibly and always possibly properties cannot be specified in linear temporal logics, nor in universal branching logics <ref> [EH86] </ref>. Theorem 5.3 Module checking of possibly and always possibly properties can be done in linear running time. Proof: We describe an efficient algorithm that module checks these properties. For simplicity, we assume that system and environment states are labeled with atomic propositions s and e, respectively. <p> If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback <ref> [EH86] </ref>. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL [Lon93, BBG + 94, KG96], have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: By [VW86b], the nonemptiness problem of Buchi tree automata can be solved in quadratic time, which gives us an algorithm of time complexity O (jRj 2 2 kO (j j) ). The proof is similar for CTL ? . Here, following <ref> [ES84, EJ88] </ref>, we have that A D;: is a Rabin tree automaton with 2 k2 O (j j) states and 2 O (j j) pairs. <p> The proof is similar for CTL ? . Here, following [ES84, EJ88], we have that A D;: is a Rabin tree automaton with 2 k2 O (j j) states and 2 O (j j) pairs. By <ref> [EJ88, PR89a] </ref>, checking the emptiness of L (A M fi A D;: ) can then be done in time (k jRj) 2 O (j j) 2 k2 O (j j) It remains to prove the lower bounds. <p> complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] <ref> [EJ88, VS85] </ref> 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, North Holywood, 1985. </booktitle> <publisher> Western Periodicals Company. </publisher>
Reference-contexts: Thus, CTL module checking is EXPTIME-complete and CTL ? module checking is 2EXPTIME-complete, both worse than the PSPACE complexity we have for LTL. Keeping in mind that CTL model checking can be done in linear time [CES86] and CTL ? model checking can be done in polynomial space <ref> [EL85] </ref>, this is really bad news. <p> All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME <ref> [EL85] </ref> [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: For simplicity, let us first assume that has a single atomic proposition q. Let n be the number of existential quantifiers in plus 1. By the sufficient branching-degree property of CTL, is satisfiable iff there exists a f;; fqgg-labeled tree of branching degree n that satisfies <ref> [Eme90] </ref>. Let P n be a clique with n states. By the above, is satisfiable iff there exists a possibility to label an unwinding of P n such that the resulted f;; fqgg-labeled tree satisfies . This simple idea, due to [Kup97], is the key to our reduction.
Reference: [ES84] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proc. 16th ACM Symposium on Theory of Computing, </booktitle> <address> Washington, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: By [VW86b], the nonemptiness problem of Buchi tree automata can be solved in quadratic time, which gives us an algorithm of time complexity O (jRj 2 2 kO (j j) ). The proof is similar for CTL ? . Here, following <ref> [ES84, EJ88] </ref>, we have that A D;: is a Rabin tree automaton with 2 k2 O (j j) states and 2 O (j j) pairs.
Reference: [FL79] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: To get an EXPTIME lower bound for CTL, we reduce CTL satisfiability, proved to be EXPTIME-complete in <ref> [FL79, Pra80] </ref>, to CTL module checking. <p> Proving that the satisfiability problem for CTL is EXPTIME-hard, Fisher and Lander reduce acceptance of a word x by a linear-space alternating Turing machine to satisfiability of a CTL formula x <ref> [FL79] </ref>. In an alternating Turing machine (with a binary branching degree), each configuration has two possible successor configurations. Some of the configurations are classified as universal and some are classified as existential . A computation of an alternating Turing machine is a tree labeled with configurations. <p> We define a 8CTL formula ' such that T accepts x iff there exists a tree in exec (M ) that satisfies ' (hence, T accepts x iff M does not satisfy ', which is an 9CTL formula). As in <ref> [FL79] </ref>, the formula ' requires that each branch in the tree encodes a sequence of configurations 13 that starts at the initial configuration and ends at an accepting configuration. 4 The Program Complexity of Module Checking When analyzing the complexity of model checking, a distinction should be made between complexity in <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] <ref> [FL79, Pra80] </ref> CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments.
Reference: [Flo67] <author> R.W. Floyd. </author> <title> Assigning meaning to programs. </title> <booktitle> In Proceedings Symposium on Applied Mathematics, </booktitle> <volume> volume 19, </volume> <year> 1967. </year>
Reference-contexts: Therefore, in the context of open systems, formal specification and verification of the design has great importance. Traditional formalisms for specification of systems relate the initial state and the final state of a system <ref> [Flo67, Hoa69] </ref>. In 1977, Pnueli suggested temporal logics as a suitable formalism for reasoning about the correctness of nonterminating systems [Pnu77].
Reference: [FZ88] <author> M.J. Fischer and L.D. Zuck. </author> <title> Reasoning about uncertainty in fault-tolerant distributed systems. </title> <editor> In M. Joseph, editor, </editor> <booktitle> Proc. Symp. on Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 331 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-158. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: In contrast, in an open system, the environment can modify some of the system variables. Designing correct open systems is not an easy task. The design has to be correct with respect to any environment, and often there is much uncertainty regarding the environment <ref> [FZ88] </ref>. Therefore, in the context of open systems, formal specification and verification of the design has great importance. Traditional formalisms for specification of systems relate the initial state and the final state of a system [Flo67, Hoa69].
Reference: [GJ79] <author> M. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness. </title> <publisher> W. Freeman and Co., </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] <ref> [GJ79] </ref> Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Indeed, for every tree hT; V i 2 exec (M ), the relation that maps each node x of T to the node x of hT M ; V M i is a simulation relation between hT; V i and hT M ; V M i. Therefore, by <ref> [GL94] </ref>, all trees in exec (M ) satisfy , and M j= r . In particular, it follows from Lemma 5.1 that module checking and model checking coincides for linear temporal logics.
Reference: [Gol77] <author> L.M. Goldschlager. </author> <title> The monotone and planar circuit value problems are log space complete for P. </title> <journal> SIGACT News, </journal> <volume> 9(2) </volume> <pages> 25-29, </pages> <year> 1977. </year>
Reference-contexts: Proof: Since the algorithms given in the proof of Theorem 3.1 are polynomial in the size of the module, membership in PTIME is immediate. We prove hardness in PTIME by reducing the Monotonic Circuit Value Problem (MCV), proved to be PTIME-hard in <ref> [Gol77] </ref>, to module checking of the CTL formula EF p. In the MCV problem, we are given a monotonic Boolean circuit ff (i.e., a circuit constructed solely of AND gates and OR gates), and a vector hx 1 ; : : :; x n i of Boolean input values.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis of computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference-contexts: Therefore, in the context of open systems, formal specification and verification of the design has great importance. Traditional formalisms for specification of systems relate the initial state and the final state of a system <ref> [Flo67, Hoa69] </ref>. In 1977, Pnueli suggested temporal logics as a suitable formalism for reasoning about the correctness of nonterminating systems [Pnu77].
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The second machine, which is an open system, repeatedly boils water, asks the environment to choose between coffee and tea, and deterministically serves a drink according to the external choice <ref> [Hoa85] </ref>. Both machines induce the same infinite tree of possible executions. Nevertheless, while the behavior of the first machine is determined by internal choices solely, the behavior of the second machine is determined also by external choices, made by its environment.
Reference: [HP85] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume F-13 of NATO Advanced Summer Institutes, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction In computer system design, we distinguish between closed and open systems <ref> [HP85] </ref>. A closed system is a system whose behavior is completely determined by the state of the system. An open system is a system that interacts with its environment and whose behavior depends on this interaction. <p> In 1977, Pnueli suggested temporal logics as a suitable formalism for reasoning about the correctness of nonterminating systems [Pnu77]. The breakthrough that temporal logics brought to the area of specification and verification arises from their ability to describe an ongoing interaction of a reactive module with its environment <ref> [HP85] </ref>. This ability makes temporal logics particularly appropriate for the specification of open systems. Two possible views regarding the nature of time induce two types of temporal logics [Lam80]. In linear temporal logics, time is treated as if each moment in time has a unique possible future.
Reference: [KG96] <author> O. Kupferman and O. Grumberg. </author> <title> Buy one, get one free!!! Journal of Logic and Computation, </title> <booktitle> 6(4) </booktitle> <pages> 523-539, </pages> <year> 1996. </year>
Reference-contexts: When is a CTL formula, the formula f ( ) is not necessarily a CTL formula. Still, it has a restricted syntax: its path formulas have either a single linear-time operator or two linear-time operators connected by a Boolean operator. By <ref> [KG96] </ref>, formulas of this syntax have a linear translation to CTL. Given , let A D;: be a Buchi tree automaton that accepts exactly all the tree models of f (: ) with branching degrees in D. By [VW86b], such A D;: of size 2 kO (j j) exists. <p> On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL <ref> [Lon93, BBG + 94, KG96] </ref>, have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. On the other hand, the computational superiority of CTL is also not that clear.
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: Therefore, w j= (e ^ AXy) and thus, by the definition of f , we have that w 2 f (y). Hence, w 2 y, and we are done. Using -calculus formalism <ref> [Koz83] </ref>, we have that w is safe iff w j= y:~ _ (s ^ EXy) _ (e ^ AXy).
Reference: [Kup97] <author> O. Kupferman. </author> <title> Augmenting branching temporal logics with existential quantification over atomic propositions. </title> <journal> Journal of Logic and Computation, </journal> <volume> 7 </volume> <pages> 1-14, </pages> <year> 1997. </year> <month> 22 </month>
Reference-contexts: Let P n be a clique with n states. By the above, is satisfiable iff there exists a possibility to label an unwinding of P n such that the resulted f;; fqgg-labeled tree satisfies . This simple idea, due to <ref> [Kup97] </ref>, is the key to our reduction. We define a module M n such that each tree in exec (M n ) corresponds to a f;; fqgg-labeling of hT P n ; V P n i.
Reference: [KV95] <author> O. Kupferman and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <booktitle> In Proc. 6th Conferance on Concurrency Theory, volume 962 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-422, </pages> <address> Philadelphia, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE [VW86a, BVW94]. As shown in <ref> [Var95, KV95] </ref>, the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further. <p> Indeed, the situation is then similar to the one existing for validity checking. In both problems, CTL is harder than LTL, and the universal fragment of CTL is easier than its existential one <ref> [KV95] </ref>. Finally, we note that the additional difficulties that need to be faced when we move from verification of closed systems to verification of open systems, do not arise when we consider verification by bisimulation [Mil71]. To see this, consider two modules M and M 0 . <p> complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] <ref> [KV95] </ref> 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems. <p> checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] <ref> [KV95] </ref> 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of programs. </title> <booktitle> In Proc. 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: This ability makes temporal logics particularly appropriate for the specification of open systems. Two possible views regarding the nature of time induce two types of temporal logics <ref> [Lam80] </ref>. In linear temporal logics, time is treated as if each moment in time has a unique possible future. Thus, linear temporal logic formulas are interpreted over linear sequences and we regard them as describing the interaction of the system with its environment along a single computation. <p> Hence, M 0 ff;~x j= r AGEF 0 iff the output of ff on x is 1. 6 Discussion The discussion of the relative merits of linear versus branching temporal logics is almost as early as these paradigms <ref> [Lam80] </ref>. We mainly refer here to the linear temporal logic LTL and the branching temporal logic CTL. One of the beliefs dominating this discussion has been "while specifying is easier in LTL, model checking is easier for CTL".
Reference: [Lar89] <author> K.G. Larsen. </author> <title> Modal specifications. In Automatic Verification Methods for Finite State Systems, </title> <booktitle> Proc. Int. Workshop, Grenoble, </booktitle> <volume> volume 407, </volume> <pages> pages 232-246, </pages> <address> Grenoble, </address> <month> June </month> <year> 1989. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We say that M satisfies iff holds in all the trees obtained by pruning from V M subtrees whose root is a successor of an environment state. The intuition is that each such 1 A similar way for modeling open systems is suggested in <ref> [LT88, Lar89] </ref>. There, Larsen and Thomsen use Modal Transition Systems, where some of the transitions are admissible and some are necessary, in order to specify processes loosely, allowing a refinement ordering between processes. 3 tree corresponds to a different (and possible) environment.
Reference: [Lon93] <author> D.E. </author> <title> Long. Model checking, abstraction and compositional verification. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Pittsburgh, </institution> <year> 1993. </year>
Reference-contexts: On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86]. In addition, the introduction of fair-CTL [CES86] and of many other extensions to CTL <ref> [Lon93, BBG + 94, KG96] </ref>, have made CTL a basis for specification languages that maintain the efficiency of CTL model checking and yet overcome many of its expressiveness limitations. On the other hand, the computational superiority of CTL is also not that clear.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proc. 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: Program Complexity of Module Checking When analyzing the complexity of model checking, a distinction should be made between complexity in the size of the input structure and complexity in the size of the input formula; it is the complexity in size of the structure that is typically the computational bottleneck <ref> [LP85] </ref>. In this section we consider the program complexity [VW86a] of module checking; i.e., the complexity of this problem in terms of the size of the input module, assuming the formula is fixed. <p> On the other hand, while model checking for CTL can be done in time O (jP j fl j j) [CES86], it takes time O (jP j fl 2 j j ) for LTL <ref> [LP85] </ref>. Since LTL model checking is PSPACE-complete [SC85], the latter bound probably cannot be improved.
Reference: [LT88] <author> K.G. Larsen and G.B. Thomsen. </author> <title> A modal process logic. </title> <booktitle> In Proc. 3th Symposium on Logic in Computer Science, </booktitle> <address> Edinburgh, </address> <year> 1988. </year>
Reference-contexts: We say that M satisfies iff holds in all the trees obtained by pruning from V M subtrees whose root is a successor of an environment state. The intuition is that each such 1 A similar way for modeling open systems is suggested in <ref> [LT88, Lar89] </ref>. There, Larsen and Thomsen use Modal Transition Systems, where some of the transitions are admissible and some are necessary, in order to specify processes loosely, allowing a refinement ordering between processes. 3 tree corresponds to a different (and possible) environment.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic model checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Checking nonemptiness of a Buchi tree automaton can be reduced to calculating a -calculus expression of alternation depth 2 [Rab69, VW86b]. As such, it can be implemented, using symbolic methods, in tools that handle fixed-point calculations (e.g., SMV <ref> [BCM + 90, McM93] </ref>). 5 Pragmatics How bad is our news? In this section we show that from a pragmatic point of view, it is not that bad. <p> Since LTL model checking is PSPACE-complete [SC85], the latter bound probably cannot be improved. The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states <ref> [McM93, CGL93] </ref> are incorporated into industrial development of new designs [BBG + 94]. If we examine the history of these issues more closely, we find that things are not that simple. On one hand, the inability of LTL to quantify computations existentially is considered by many a serious drawback [EH86].
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proc. 2nd International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489. </pages> <publisher> British Computer Society, </publisher> <month> September </month> <year> 1971. </year>
Reference-contexts: Finally, we note that the additional difficulties that need to be faced when we move from verification of closed systems to verification of open systems, do not arise when we consider verification by bisimulation <ref> [Mil71] </ref>. To see this, consider two modules M and M 0 .
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> Temporal specification and verification of reactive modules. </title> <year> 1992. </year>
Reference-contexts: They regard M as a program and answer positively. As discussed in <ref> [MP92] </ref>, when the specification is given in linear temporal logic, there is indeed no need to worry about uncertainty with respect to the environment; since all the possible interactions of the system with its environment have to satisfy a linear temporal logic specification in order for M to satisfy the specification,
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: Traditional formalisms for specification of systems relate the initial state and the final state of a system [Flo67, Hoa69]. In 1977, Pnueli suggested temporal logics as a suitable formalism for reasoning about the correctness of nonterminating systems <ref> [Pnu77] </ref>. The breakthrough that temporal logics brought to the area of specification and verification arises from their ability to describe an ongoing interaction of a reactive module with its environment [HP85]. This ability makes temporal logics particularly appropriate for the specification of open systems.
Reference: [PR89a] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: The proof is similar for CTL ? . Here, following [ES84, EJ88], we have that A D;: is a Rabin tree automaton with 2 k2 O (j j) states and 2 O (j j) pairs. By <ref> [EJ88, PR89a] </ref>, checking the emptiness of L (A M fi A D;: ) can then be done in time (k jRj) 2 O (j j) 2 k2 O (j j) It remains to prove the lower bounds. <p> In other words, when one is checking for the possibility of synthesizing part of the system. Quite interestingly, the reactive module synthesis problem studied in <ref> [PR89a, PR89b] </ref> or the realizability problem of [ALW89] can be described as CTL ? module checking problems. A similar link also exists with the supervisory control problem studied in the context of control theory [Ant95].
Reference: [PR89b] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of an asynchronous reactive module. </title> <booktitle> In Proc. 16th Int. Colloquium on Automata, Languages and Programming, </booktitle> <volume> volume 372, </volume> <pages> pages 652-671. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: In other words, when one is checking for the possibility of synthesizing part of the system. Quite interestingly, the reactive module synthesis problem studied in <ref> [PR89a, PR89b] </ref> or the realizability problem of [ALW89] can be described as CTL ? module checking problems. A similar link also exists with the supervisory control problem studied in the context of control theory [Ant95].
Reference: [Pra80] <author> V.R. Pratt. </author> <title> A near-optimal method for reasoning about action. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 20(2) </volume> <pages> 231-254, </pages> <year> 1980. </year>
Reference-contexts: To get an EXPTIME lower bound for CTL, we reduce CTL satisfiability, proved to be EXPTIME-complete in <ref> [FL79, Pra80] </ref>, to CTL module checking. <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] <ref> [FL79, Pra80] </ref> CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments.
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: We use M j= to indicate that when we regard M as a program (thus refer to all its states as system states), then M satisfies . The problem of deciding whether M j= is the usual model-checking problem <ref> [CE81, QS81] </ref>. It is easy to see that while M j= r implies that M j= , the other direction is not necessarily true. Also, while M j= implies that M 6j= r : , the other direction is not true as well.
Reference: [Rab69] <author> M.O. Rabin. </author> <title> Decidability of second order theories and automata on infinite trees. </title> <journal> Transaction of the AMS, </journal> <volume> 141 </volume> <pages> 1-35, </pages> <year> 1969. </year>
Reference-contexts: Recall that for a CTL formula , checking that a module M satisfies reduces to testing emptiness of the automaton A M fi A D;: . Checking nonemptiness of a Buchi tree automaton can be reduced to calculating a -calculus expression of alternation depth 2 <ref> [Rab69, VW86b] </ref>. As such, it can be implemented, using symbolic methods, in tools that handle fixed-point calculations (e.g., SMV [BCM + 90, McM93]). 5 Pragmatics How bad is our news? In this section we show that from a pragmatic point of view, it is not that bad.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> Journal ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: In particular, it follows from Lemma 5.1 that module checking and model checking coincides for linear temporal logics. Theorem 5.2 now follows from the known complexity results for LTL, 8CTL, and 8CTL ? model checking <ref> [SC85, CES86, BVW94, VW94] </ref>. <p> On the other hand, while model checking for CTL can be done in time O (jP j fl j j) [CES86], it takes time O (jP j fl 2 j j ) for LTL [LP85]. Since LTL model checking is PSPACE-complete <ref> [SC85] </ref>, the latter bound probably cannot be improved. The attractive complexity of CTL model checking have compensated for its lack of expressive power and branching-time model-checking tools that can handle systems with more than 10 120 states [McM93, CGL93] are incorporated into industrial development of new designs [BBG + 94]. <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE <ref> [SC85] </ref> [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE <ref> [SC85] </ref> [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94]
Reference: [Var95] <author> M.Y. Vardi. </author> <title> On the complexity of modular model checking. </title> <booktitle> In Proc. 10th IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1995. </year> <month> 23 </month>
Reference-contexts: On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE [VW86a, BVW94]. As shown in <ref> [Var95, KV95] </ref>, the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further.
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: The proof is the same for CTL ? . Here, we do a reduction from satisfiability of CTL ? , proved to be 2EXPTIME-hard in <ref> [VS85] </ref>. We note that the problem of CTL module checking is EXPTIME-complete even for the following restricted versions of the problem. * The modules have only environment states. <p> complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] [VW86b] [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] <ref> [EJ88, VS85] </ref> 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86] [BVW94] [GJ79] Acknowledgments. We are grateful to Martin Abadi for fruitful discussions on the verification 20 of reactive systems.
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proc. First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: In this section we consider the program complexity <ref> [VW86a] </ref> of module checking; i.e., the complexity of this problem in terms of the size of the input module, assuming the formula is fixed. It is known that the program complexity of LTL, CTL, and CTL ? model checking is NLOGSPACE [VW86a, BVW94]. <p> In this section we consider the program complexity [VW86a] of module checking; i.e., the complexity of this problem in terms of the size of the input module, assuming the formula is fixed. It is known that the program complexity of LTL, CTL, and CTL ? model checking is NLOGSPACE <ref> [VW86a, BVW94] </ref>. <p> On the other hand, the computational superiority of CTL is also not that clear. For example, comparing the complexities of CTL and LTL model checking for concurrent programs, both are in PSPACE <ref> [VW86a, BVW94] </ref>. As shown in [Var95, KV95], the advantage that CTL enjoys over LTL disappears also when the complexity of modular verification is considered. The distinction between closed an open systems questions the computational superiority of the branching-time paradigm further.
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: By [KG96], formulas of this syntax have a linear translation to CTL. Given , let A D;: be a Buchi tree automaton that accepts exactly all the tree models of f (: ) with branching degrees in D. By <ref> [VW86b] </ref>, such A D;: of size 2 kO (j j) exists. By the definition of satisfaction, we have that M j= r iff all the trees in exec (M ) satisfy . In other words, if no tree in exec (M ) satisfies : . <p> Hence, checking whether M j= r can be reduced to testing L (A M ) " L (A D;: ) for emptiness. Equivalently, we have to test L (A M fi A D;: ) for emptiness. By <ref> [VW86b] </ref>, the nonemptiness problem of Buchi tree automata can be solved in quadratic time, which gives us an algorithm of time complexity O (jRj 2 2 kO (j j) ). The proof is similar for CTL ? . <p> Recall that for a CTL formula , checking that a module M satisfies reduces to testing emptiness of the automaton A M fi A D;: . Checking nonemptiness of a Buchi tree automaton can be reduced to calculating a -calculus expression of alternation depth 2 <ref> [Rab69, VW86b] </ref>. As such, it can be implemented, using symbolic methods, in tools that handle fixed-point calculations (e.g., SMV [BCM + 90, McM93]). 5 Pragmatics How bad is our news? In this section we show that from a pragmatic point of view, it is not that bad. <p> Our results are summarized in the table below. All the complexities in the table denote tight bounds. program program complexity complexity model module of model of module checking checking checking checking satisfiability LTL PSPACE PSPACE NLOGSPACE NLOGSPACE PSPACE [SC85] <ref> [VW86b] </ref> [SC85] CTL linear-time EXPTIME NLOGSPACE PTIME EXPTIME [CES86] [BVW94] [FL79, Pra80] CTL ? PSPACE 2EXPTIME NLOGSPACE PTIME 2EXPTIME [EL85] [BVW94] [EJ88, VS85] 8CTL linear-time linear-time NLOGSPACE NLOGSPACE PSPACE [CES86] [BVW94] [KV95] 9CTL linear-time EXPTIME NLOGSPACE PTIME NPTIME [CES86] [BVW94] [KV95] EF ~ linear-time linear-time NLOGSPACE PTIME NPTIME AGEF ~ [CES86]
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year> <month> 24 </month>
Reference-contexts: In particular, it follows from Lemma 5.1 that module checking and model checking coincides for linear temporal logics. Theorem 5.2 now follows from the known complexity results for LTL, 8CTL, and 8CTL ? model checking <ref> [SC85, CES86, BVW94, VW94] </ref>.
References-found: 50

