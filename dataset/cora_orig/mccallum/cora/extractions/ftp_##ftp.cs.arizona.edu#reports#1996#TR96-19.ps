URL: ftp://ftp.cs.arizona.edu/reports/1996/TR96-19.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Email: debray@cs.arizona.edu  
Title: Resource-Bounded Partial Evaluation  
Author: Saumya Debray 
Note: This work was supported in part by the National Science Foundation under grant CCR-9502826  
Address: Tucson, AZ 85721, U.S.A.  
Affiliation: Department of Computer Science University of Arizona  
Abstract: Technical Report 96-19 November 1996 Abstract Most partial evaluators do not take the availability of machine-level resources, such as registers or cache, into consideration when making their specialization decisions. The resulting resource contention can lead to severe performance degradation|causing, in extreme cases, the specialized code to run slower than the unspecialized code. In this paper we consider how resource availability considerations can be incorporated within a partial evaluator. We develop an abstract formulation of the problem, show that optimal resource-bounded partial evaluation is NP-complete, and discuss simple heuristics that can be used to address the problem in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. O. Anderson, </author> <title> "Program Analysis and Specialization for the C Programming Language", </title> <type> DIKU Report No. 94/19, </type> <institution> Dept. of Computer Science, University of Copenhagen, </institution> <year> 1994. </year>
Reference-contexts: 1 Introduction The field of partial evaluation has matured greatly in recent years, and partial evaluators have been implemented for a wide variety of programming languages <ref> [1, 4, 5, 6, 13, 19] </ref>. A central concern guiding these implementations has been to ensure that computations in an input program that can be specialized should be specialized as far as possible without compromising termination of the partial evaluator.
Reference: [2] <author> L. O. Andersen and C. K. Gomard, </author> <title> "Speedup Analysis in Partial Evaluation (Preliminary Results)", </title> <booktitle> Proc. ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 1-7. </pages> <note> (Also available as Technical Report YALEU/DCS/RR-909, </note> <institution> Department of Computer Science, Yale University, </institution> <address> New Haven, CT.) </address>
Reference-contexts: There has been some work on identifying those static computations that are "worth specializing", i.e., whose specialization can contribute to good speedups <ref> [2] </ref>, but these do not directly address the particular problem that we are concerned with.
Reference: [3] <author> P. H. Andersen and C. K. Holst, </author> <title> "Termination Analysis for O*ine Partial Evaluation of a Higher Order Programming Language", </title> <booktitle> Proc. Third International Static Analysis Symposium, </booktitle> <year> 1996. </year>
Reference-contexts: Here we explore some of these. 6.1 Termination Considerations In traditional o*ine partial evaluation, since the specializer blindly specializes all computations annotated as "static", the responsibility for ensuring termination falls on the binding time analysis <ref> [3, 11, 14] </ref>. This is undesirable, both for conceptual and pragmatic reasons. Conceptually, it mixes two independent concerns: the question of what can be specialized, and that of what should be specialized.
Reference: [4] <author> R. Baier, R. Gluck, and R. Zochling, </author> <title> "Partial Evaluation of Numerical Programs in Fortran", </title> <booktitle> Proc. ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <year> 1994, </year> <pages> pp. 119-132. </pages> <note> Report 94/9, </note> <institution> Dept. of Computer Science, University of Melbourne. </institution>
Reference-contexts: 1 Introduction The field of partial evaluation has matured greatly in recent years, and partial evaluators have been implemented for a wide variety of programming languages <ref> [1, 4, 5, 6, 13, 19] </ref>. A central concern guiding these implementations has been to ensure that computations in an input program that can be specialized should be specialized as far as possible without compromising termination of the partial evaluator.
Reference: [5] <author> L. Birkedal and M. Welinder, </author> <title> "Partial Evaluation of Standard ML", </title> <type> DIKU Report No. 93/22, </type> <institution> Dept. of Computer Science, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction The field of partial evaluation has matured greatly in recent years, and partial evaluators have been implemented for a wide variety of programming languages <ref> [1, 4, 5, 6, 13, 19] </ref>. A central concern guiding these implementations has been to ensure that computations in an input program that can be specialized should be specialized as far as possible without compromising termination of the partial evaluator.
Reference: [6] <author> A. Bondorf, </author> <title> Similix 5.0 Manual, </title> <institution> Department of Computer Science, University of Copenhagen, Copenhagen, Denmark, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The field of partial evaluation has matured greatly in recent years, and partial evaluators have been implemented for a wide variety of programming languages <ref> [1, 4, 5, 6, 13, 19] </ref>. A central concern guiding these implementations has been to ensure that computations in an input program that can be specialized should be specialized as far as possible without compromising termination of the partial evaluator. <p> For different input sizes, this results in a family of specialized programs where the 1 The numbers are based on a Scheme program that represents a vector as a list, specialized using Similix <ref> [6] </ref> and compiled using Bigloo version 1.8 [20], invoked as bigloo1.8 -O4 -unsafe -farithmetic with gcc version 2.7.2 as the back-end compiler, and run on a 25 MHz SPARC IPC with 64 Kbytes of cache and 32 Mbytes of main memory. <p> We used Similix <ref> [6] </ref> running on the scm Scheme in terpreter for the specialization, and the Bigloo Scheme-to-C translator (version 1.8) [20], with gcc 8 version 2.7.2 as the back-end compiler, to produce executables.
Reference: [7] <author> C. Castelluccia, </author> <title> "Automating Header Prediction", </title> <booktitle> Proc. Workshop on Compiler Support for System Software, </booktitle> <address> Tucson, </address> <month> Feb. </month> <year> 1996, </year> <pages> pp. 44-53. </pages>
Reference-contexts: While our algorithms have not been incorporated into a partial evaluator, preliminary experiments appear encouraging. 2 In operating systems parlance, this kind of selective specialization is referred to as "outlining" <ref> [7, 17, 18] </ref>. 14
Reference: [8] <author> C. Consel, </author> <title> "Binding Time Analysis for Higher Order Untyped Functional Languages", </title> <booktitle> Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 264-272. </pages>
Reference-contexts: This process continues until the accountant terminates the specialization process due to the exhaustion of available resources (or possibly because it identifies a nonterminating specialization sequence) by returning a program where no program point is annotated for specialization. In some ways, this resembles the notion of "mixline" partial evaluation <ref> [8] </ref>, where binding-time annotations of "possibly static" or "sometimes static" are permitted.
Reference: [9] <author> O. Danvy, N. Heintze and K. Malmkjr, </author> <title> "Resource-Bounded Partial Evaluation", </title> <journal> ACM Computing Surveys vol. </journal> <volume> 28 no. 2, </volume> <month> June </month> <year> 1996, </year> <pages> pp. 329-332. </pages>
Reference-contexts: The issue of resource-bounded partial evaluation has been discussed by Danvy et al. <ref> [9] </ref>, who sketch possible approaches to the problem at a very high level but offer few details. 2 Underlying Concepts 2.1 Program Points We assume that the programs under consideration for specialization are expressed in a (untyped) first-order functional language.
Reference: [10] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <publisher> Freeman, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In fact, for higher order programs, it is straightforward to take advantage of the congruence requirement and adapt the reduction for Theorem 3.1 to one where the reduction is from the Partially Ordered Knapsack problem, which is known to be NP-complete in the strong sense <ref> [10] </ref>. It follows that resource-bounded specialization for higher order programs is NP-complete in the strong sense. 4 A Heuristic Algorithm Theorem 3.1 implies that the existence of efficient algorithms for optimal one-step resource-bounded program specialization are unlikely.
Reference: [11] <author> A. J. Glenstrup and N. D. Jones, </author> <title> "BTA Algorithms to Ensure Termination of Off-line Partial Evaluation", </title> <booktitle> in Perspectives of System Informatics: Proceedings of the Andrei Ershov Second International Memorial Conference, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Here we explore some of these. 6.1 Termination Considerations In traditional o*ine partial evaluation, since the specializer blindly specializes all computations annotated as "static", the responsibility for ensuring termination falls on the binding time analysis <ref> [3, 11, 14] </ref>. This is undesirable, both for conceptual and pragmatic reasons. Conceptually, it mixes two independent concerns: the question of what can be specialized, and that of what should be specialized.
Reference: [12] <author> R. Gluck and J. Jtrgensen, </author> <title> "Efficient Multi-Level Generating Extensions for Program Specialization", </title> <booktitle> Proc. International Symposium on Programming Languages, Implementation, Logics and Programs (PLILP), </booktitle> <year> 1995. </year>
Reference-contexts: This potential inflexibility can be handled by considering the resource information to be an additional static input whose value becomes available at some point during a multi-level specialization process <ref> [12] </ref>.
Reference: [13] <author> C. Gurr, </author> <title> A Self-Applicable Partial Evaluator for the Logic Programming Language Godel, </title> <type> Ph.D. Thesis, </type> <institution> University of Bristol, </institution> <year> 1994. </year>
Reference-contexts: 1 Introduction The field of partial evaluation has matured greatly in recent years, and partial evaluators have been implemented for a wide variety of programming languages <ref> [1, 4, 5, 6, 13, 19] </ref>. A central concern guiding these implementations has been to ensure that computations in an input program that can be specialized should be specialized as far as possible without compromising termination of the partial evaluator.
Reference: [14] <author> C. K. Holst, </author> <title> "Finiteness Analysis", </title> <booktitle> Proc. Functional Programming and Computer Architecture, </booktitle> <year> 1991, </year> <pages> pp. 473-495. </pages>
Reference-contexts: Here we explore some of these. 6.1 Termination Considerations In traditional o*ine partial evaluation, since the specializer blindly specializes all computations annotated as "static", the responsibility for ensuring termination falls on the binding time analysis <ref> [3, 11, 14] </ref>. This is undesirable, both for conceptual and pragmatic reasons. Conceptually, it mixes two independent concerns: the question of what can be specialized, and that of what should be specialized.
Reference: [15] <author> N. D. Jones, C. K. Gomard and P. Sestoft, </author> <title> Partial Evaluation and Automatic Program Generation, </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: For these reasons, it would seem desirable to be able to incorporate some awareness of the availability of resources during the partial evaluation process. The potential problem of code growth during partial evaluation has been noted in the past (e.g., see <ref> [15] </ref>), but we do not know of any proposal to address code growth given fixed resources. <p> resource information available late in the multi-level specialization process we can get a generating extension for a particular program that can be used on a variety of different machines. 6.3 Value-selective Specialization using "The Trick" A standard technique for binding-time improvement for variables of bounded static variation is "the trick" <ref> [15] </ref>. The basic idea is as follows: suppose we have the following program fragment from a network communication protocol: process (status, pkt) 13 where status is the status of the previous transmission, and pkt a packet to be sent.
Reference: [16] <author> R, M. Karp, </author> <title> "Reducibility among Combinatorial Problems", in Complexity of Computer Computations, </title> <editor> eds. R. E. Miller and J. W. Thatcher, </editor> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1972, </year> <pages> pp. 85-103. 15 </pages>
Reference-contexts: The following result therefore does not come as a great surprise: Theorem 3.1 Optimal One-Step Resource-Bounded Specialization is NP-complete, even for first order programs. Proof By a straightforward reduction from the Knapsack problem, which is known to be NP-complete <ref> [16] </ref>. 2 It turns out that the reduction from the knapsack problem makes no use of the congruence requirement that specialization annotations are required to satisfy.
Reference: [17] <author> D. Mosberger, L. L. Peterson, P. G. Bridges, and S. O'Malley, </author> <title> "Improving the I-Cache Effective--ness of Network Software", </title> <booktitle> Proc. Workshop on Compiler Support for System Software, </booktitle> <address> Tucson, </address> <month> Feb. </month> <year> 1996, </year> <pages> pp. 29-36. </pages>
Reference-contexts: While our algorithms have not been incorporated into a partial evaluator, preliminary experiments appear encouraging. 2 In operating systems parlance, this kind of selective specialization is referred to as "outlining" <ref> [7, 17, 18] </ref>. 14
Reference: [18] <author> D. Mosberger, L. L. Peterson, P. G. Bridges, and S. O'Malley, </author> <title> "Analysis of Techniques to Improve Protocol Processing Latency", </title> <booktitle> Proc. SIGCOMM '96, </booktitle> <pages> pp. 73-84, </pages> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: While our algorithms have not been incorporated into a partial evaluator, preliminary experiments appear encouraging. 2 In operating systems parlance, this kind of selective specialization is referred to as "outlining" <ref> [7, 17, 18] </ref>. 14
Reference: [19] <author> D. Sahlin, </author> <title> An Automatic Partial Evaluator for Full Prolog, </title> <type> Ph.D. Thesis, </type> <institution> Kungliga Tekniska Hogskolan, Stockholm, Sweden, </institution> <year> 1991. </year> <note> Report TRITA-TCS-9101. </note>
Reference-contexts: 1 Introduction The field of partial evaluation has matured greatly in recent years, and partial evaluators have been implemented for a wide variety of programming languages <ref> [1, 4, 5, 6, 13, 19] </ref>. A central concern guiding these implementations has been to ensure that computations in an input program that can be specialized should be specialized as far as possible without compromising termination of the partial evaluator.
Reference: [20] <author> M. Serrano, </author> <title> Bigloo User's Manual, </title> <institution> INRIA Rocquencourt, France, </institution> <month> April </month> <year> 1996. </year> <month> 16 </month>
Reference-contexts: For different input sizes, this results in a family of specialized programs where the 1 The numbers are based on a Scheme program that represents a vector as a list, specialized using Similix [6] and compiled using Bigloo version 1.8 <ref> [20] </ref>, invoked as bigloo1.8 -O4 -unsafe -farithmetic with gcc version 2.7.2 as the back-end compiler, and run on a 25 MHz SPARC IPC with 64 Kbytes of cache and 32 Mbytes of main memory. <p> We used Similix [6] running on the scm Scheme in terpreter for the specialization, and the Bigloo Scheme-to-C translator (version 1.8) <ref> [20] </ref>, with gcc 8 version 2.7.2 as the back-end compiler, to produce executables. These were run on a 25 MHz SPARC IPC with 64 Kbytes of cache and 32 Mbytes of main memory.
References-found: 20

