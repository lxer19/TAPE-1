URL: http://www.cs.kuleuven.ac.be/~lucdr/filp-papers/shan.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~lucdr/filp.html
Root-URL: 
Email: cheng@cs.few.eur.nl  
Title: Data Mining: From Statistics to Inductive Logic Programming  
Author: Shan-Hwei Nienhuys-Cheng 
Address: P.O. Box 1738, 3000 DR Rotterdam the Netherlands  
Affiliation: Department of Computer Science Erasmus University of Rotterdam  
Abstract: Many different approaches exist in the field of data mining, for instance using inductive logic programming or statistics. In this paper we combine these two paradigms, applying them to the following type of classification problem in data mining. Given is a database of insurance clients. We can consider it as a sample of the population (clients and potential clients). Our task is to partition the population into homogeneous classes w.r.t. causing car-accidents. A homogeneous class is a set of people that can not be divided into subclasses with different risks of causing accidents. A definite program clause can be used to define a class in the sample and hence also a class in the population. A client is in the class if he satisfies the conditions given in the body. Whether this client has caused an accident gives the truth value of the head. We give an algorithm, using a refinement operator and confidence intervals, which can find clauses that correspond to an appropriate partition.
Abstract-found: 1
Intro-found: 1
Reference: [ CQ94 ] <author> R. M. Cameron-Jones and J. R. Quinlan. </author> <title> Efficient top-down induction of logic programs. </title> <journal> SIGART Bulletin, </journal> <volume> 5(1) </volume> <pages> 33-42, </pages> <year> 1994. </year>
Reference: [ Dze96 ] <author> S. Dzeroski. </author> <title> Inductive logic programming and knowledge discovery in data bases. </title> <editor> In Fayyad et al. </editor> [ <address> FPSU96 ] , pages 118-152. </address>
Reference-contexts: At first sight, such a combination seems difficult. For instance, [ HKS96 ] has used a statistical approach for the following problem, which the authors encountered in 1 See [ MD94; LD94; NW97 ] for an introduction into ILP, and [ FPSU96 ] for KDD. In particular, <ref> [ Dze96 ] </ref> gives a survey of ILP in KDD. their implementation of a KDD software. A Dutch insurance company asked them to derive risk-profiles from the car-insurance databases.
Reference: [ FPSU96 ] <editor> U. Fayyad, G. Piatetsky-Shapiro, P. Smyth, and R. Uthurusamy, editors. </editor> <booktitle> Advances in Knowledge Discovery and Data Mining. </booktitle> <publisher> AAAI Press/MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: At first sight, such a combination seems difficult. For instance, [ HKS96 ] has used a statistical approach for the following problem, which the authors encountered in 1 See [ MD94; LD94; NW97 ] for an introduction into ILP, and <ref> [ FPSU96 ] </ref> for KDD. In particular, [ Dze96 ] gives a survey of ILP in KDD. their implementation of a KDD software. A Dutch insurance company asked them to derive risk-profiles from the car-insurance databases.
Reference: [ HKS96 ] <author> M. Holsheimer, M. Kersten, and A. Siebes. </author> <title> Data Surveyor: Searching the nuggets in parallel. </title> <editor> In Fayyad et al. </editor> [ <address> FPSU96 ] , pages 447-470. </address>
Reference-contexts: It might be interesting to see the differences and similarities between the two approaches and to investigate the possibilities of combining them. At first sight, such a combination seems difficult. For instance, <ref> [ HKS96 ] </ref> has used a statistical approach for the following problem, which the authors encountered in 1 See [ MD94; LD94; NW97 ] for an introduction into ILP, and [ FPSU96 ] for KDD. <p> But in a class in the profile we may have one who has caused accident and one who has not, rendering the clause false. Thus the traditional ILP does not work. We should deal with groups that have statistically defined properties. Let us now explain the approach of <ref> [ HKS96 ] </ref> to this problem with some of our own interpretation of termino-logies added. A class is a set of people in the population who share the same properties. A homogeneous class is a class which cannot be subdvided into subclasses with different risks to cause accidents. <p> Given a sample class, if its confidence interval intersects with the confidence intervals of its subclasses, then we have a homogeneous sample class. We say that the associated class in the population is also homogeneous. In <ref> [ HKS96 ] </ref> a set of so-called descriptions are used to give the characteristic of a class. A description is some restriction to individual attribute values, for example age &lt; 20 and sex = man. <p> If C 1 is the first homogeneous clause found w.r.t. Tuples whose class contains z, then z is assigned to its associated class and z is then deleted from Tuples. We do not require that two classes have no intersections in their confidence intervals (contrary to <ref> [ HKS96 ] </ref> ). We do not think that two classes that happen to have the same sample fraction should be put in one class.
Reference: [ Lai88 ] <author> P. D. Laird. </author> <title> Learning from Good and Bad Data. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: The idea of a refinement operator was first introduced by Shapiro [ Sha81 ] . The set (C) contains some specializations which can replace an overly strong clause C. In particular, we consider the following refinement operator ( <ref> [ Lai88; LN93; LN94 ] </ref> ). For every C 2 P we define (C) as follows: If substitution = fx=yg where x; y are differ ent variables in C, then C 2 (C).
Reference: [ LD94 ] <author> N. Lavrac and S. Dzeroski. </author> <title> Inductive Logic Programming: Techniques and Applications. </title> <publisher> Ellis Horwood, </publisher> <address> New York, </address> <year> 1994. </year> <month> 5 </month>
Reference-contexts: At first sight, such a combination seems difficult. For instance, [ HKS96 ] has used a statistical approach for the following problem, which the authors encountered in 1 See <ref> [ MD94; LD94; NW97 ] </ref> for an introduction into ILP, and [ FPSU96 ] for KDD. In particular, [ Dze96 ] gives a survey of ILP in KDD. their implementation of a KDD software. A Dutch insurance company asked them to derive risk-profiles from the car-insurance databases.
Reference: [ Llo87 ] <author> J. W. Lloyd. </author> <title> Foundations of Logic Program--ming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: Both standard probability theory and widely avaiable statistical software can provide the confidence interval, given n; m and the desired confidence level (such as 95%). 2.2 Refinement operators For most definitions concerning logic, we refer to <ref> [ Llo87 ] </ref> , here we include a brief explanation only. Consider a first-order language containing finitely many function and predicate symbols. The Herbrand universe is the set of ground (i.e., variable-free) terms in the language. A Herbrand interpretation assigns a truth-value to each ground atom in the language. <p> For example, Q (x; y) may be interpreted as `person x has a car y'. We may substitute a constant a for x if a represents a person. But if b represents a car, then the substitution fx=bg should be ruled out (see for instance <ref> [ Llo87 ] </ref> ). Every attribute has a type associated with it. For simplicity we use different type symbols for different attributes. There may be finitely many other types defined, for example Number. We can also consider one type as a substype of another.
Reference: [ LN93 ] <author> P. van der Laag and S. H. Nienhuys-Cheng. </author> <title> Subsumption and refinement in model inference. </title> <editor> In P. Brazdil, editor, </editor> <booktitle> Proceedings of the 6th European Conference on Machine Learning (ECML-93), volume 667 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 95-114, </pages> <address> Ber-lin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The idea of a refinement operator was first introduced by Shapiro [ Sha81 ] . The set (C) contains some specializations which can replace an overly strong clause C. In particular, we consider the following refinement operator ( <ref> [ Lai88; LN93; LN94 ] </ref> ). For every C 2 P we define (C) as follows: If substitution = fx=yg where x; y are differ ent variables in C, then C 2 (C).
Reference: [ LN94 ] <author> P. van der Laag and S. H. Nienhuys-Cheng. </author> <title> Existence and nonexistence of complete refinement operators. </title> <editor> In F. Bergadano and L. De Raedt, editors, </editor> <booktitle> Proceedings of the 7th European Conference on Machine Learning (ECML-94), volume 784 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 307-322, </pages> <address> Berlin, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The idea of a refinement operator was first introduced by Shapiro [ Sha81 ] . The set (C) contains some specializations which can replace an overly strong clause C. In particular, we consider the following refinement operator ( <ref> [ Lai88; LN93; LN94 ] </ref> ). For every C 2 P we define (C) as follows: If substitution = fx=yg where x; y are differ ent variables in C, then C 2 (C).
Reference: [ MD94 ] <author> S. Muggleton and L. De Raedt. </author> <title> Inductive logic programming: Theory and methods. </title> <journal> Journal of Logic Programming, </journal> 19/20:629-679, 1994. 
Reference-contexts: At first sight, such a combination seems difficult. For instance, [ HKS96 ] has used a statistical approach for the following problem, which the authors encountered in 1 See <ref> [ MD94; LD94; NW97 ] </ref> for an introduction into ILP, and [ FPSU96 ] for KDD. In particular, [ Dze96 ] gives a survey of ILP in KDD. their implementation of a KDD software. A Dutch insurance company asked them to derive risk-profiles from the car-insurance databases.
Reference: [ NW97 ] <author> S. H. Nienhuys-Cheng and R. de Wolf. </author> <title> Foundations of Inductive Logic Programming. </title> <journal> LNAI-tutorial, </journal> <volume> 1228. </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1997. </year> <month> May </month> <year> 1997. </year>
Reference-contexts: At first sight, such a combination seems difficult. For instance, [ HKS96 ] has used a statistical approach for the following problem, which the authors encountered in 1 See <ref> [ MD94; LD94; NW97 ] </ref> for an introduction into ILP, and [ FPSU96 ] for KDD. In particular, [ Dze96 ] gives a survey of ILP in KDD. their implementation of a KDD software. A Dutch insurance company asked them to derive risk-profiles from the car-insurance databases.
Reference: [ Qui90 ] <author> J. R. Quinlan. </author> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5(3) </volume> <pages> 239-266, </pages> <year> 1990. </year>
Reference-contexts: In particular the amount of salary of a young man has nothing to do with accidents. 4 Possible Implementation We have not yet implemented this algorithm, but we can use the well-known FOIL system <ref> [ Qui90 ] </ref> to give an idea of what the implementation might look like. To use FOIL, we consider a finite set of predicate symbols. One predicate is the target predicate, say P . The other predicates are considered as the background knowledge. They are expressed by ground atoms.
Reference: [ Sha81 ] <author> E. Shapiro. </author> <title> Inductive inference of theories from facts. </title> <type> Technical Report 192, </type> <institution> Department of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <year> 1981. </year> <month> 6 </month>
Reference-contexts: The idea of a refinement operator was first introduced by Shapiro <ref> [ Sha81 ] </ref> . The set (C) contains some specializations which can replace an overly strong clause C. In particular, we consider the following refinement operator ( [ Lai88; LN93; LN94 ] ).
References-found: 13

