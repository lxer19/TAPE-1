URL: ftp://ftp.ifi.unizh.ch/pub/techreports/other_docs/trans_dev.ps.gz
Refering-URL: http://www.ifi.unizh.ch/staff/fuchs.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Transformational Development of Logic Programs from Executable Specifications Schema-Based Visual and Textual Composition of Logic Programs  
Author: Norbert E. Fuchs, Markus P. J. Fromherz, 
Address: Palo Alto  
Affiliation: Department of Computer Science, University of Zurich  Xerox PARC,  
Date: 1994  
Note: C. BECKSTEIN, U. GESKE (EDS.), WORKSHOP ON DEVELOPMENT, TEST AND MAINTENANCE OF DECLARATIVE AI PROGRAMS, GMD STUDIEN NR. 238, GESELLSCHAFT FR MATHEMATIK UND DATENVERARBEITUNG,  
Abstract: In our method that we call Visual and Textual Composition of Logic Programs we have enhanced the schema-based construction of logic programs in two ways intended to bridge the conceptual gap between application domains and the programming domain. First, we define visual and textual views of programs that can be used to construct programs in applicationspecific concepts, and which can be understood as executable specifications of the programs being constructed. Second, in addition to schemata for Prolog programming constructs and techniques we introduce a repository of applicationspecific components. As a further enhancement of the method we have added schema-based transformations to increase the efficiency of the constructed programs. We have implemented both a program development system and a transformation system, and used these systems to develop programs for nontrivial applications like the well-known library data base problem and an automated teller machine. 
Abstract-found: 1
Intro-found: 1
Reference: [Agresti 86] <author> W. W. Agresti (Ed.), </author> <title> New Paradigms in Software Development, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1986 </year>
Reference-contexts: When programs can be derived automatically from their specifications, it has been advocated to maintain the specifications instead of the programs <ref> [Agresti 86] </ref>. The automatic bidirectional mapping between views and programs leads to the rather unusual situation that maintenance of the specification and the program is in fact the same. This supports a form of continuous, cyclical software development that does not distinguish between initial implementation and later maintenance. <p> Instead, we rely on inspecting specifications and on reasoning about their consequences to convince ourselves of their adequacy. As a further and complementary means we can write specifications in executable languages, execute them on a computer, and immediately experience their consequences <ref> [Agresti 86] </ref>. Executing a specification can be especially helpful to validate nonfunctional requirements, e.g. requirements for user interfaces. Requirements of real-life projects are often incomplete and unclear, thus making it impossible to derive a comprehensive and unambiguous specification. <p> These specifications are usually mapped to programs based on generate-and-test schemata. In this case, the program constructed is inefficient and mere compilation will not remove this inefficiency. To get efficient programs in all cases, we decided to follow a variation of the transformational implementation paradigm <ref> [Agresti 86; Rich & Waters 86] </ref>: optionally, programs are transformed by powerful source-to-source transformations before they are compiled.
Reference: [Bowles et al. 93] <author> A. Bowles, D. Robertson, W. Vasconcelos, M. Vargas-Vera, D. Bental, </author> <title> Applying Prolog Programming Techniques, </title> <type> Report DAI Research Paper 641, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1993 </year>
Reference-contexts: Patterns can also be used to abstractly represent programs that use the same programming technique, e.g. accumulators or difference lists [Brna et al. 88]. Sterling and collaborators [Kirschenbaum et al. 94], and Robertson and his group <ref> [Bowles et al. 93] </ref> have developed systematic methods to construct logic programs, specifically Prolog programs, with the help of patterns. Sterling and his collaborators [Kirschenbaum et al. 94] define skeletons as basic Prolog programs with well-understood control flow, e.g. the in-order traversal of a binary tree. <p> Two tools have been built for this purpose: an environment using skeletons, techniques and composition to develop recursive Prolog programs, and a tool that incorporates techniques into Prolog programs by partial evaluation. Robertson and collaborators <ref> [Bowles et al. 93] </ref> define a programming technique as a standard code pattern used by logic programmers in a systematic way, and which is independent of any particular algorithm or application domain. Thus their notion technique overlaps with Sterling's notions skeleton and technique. <p> We believe that the adequate representation of domain knowledge requires also applicationspecific components. These components can be schemata reflecting an abstract property of the application domain, or other elements serving specific purposes. Describing an application domain exhaustively can lead to an explosion of the number of components <ref> [Bowles et al. 93] </ref>. However, a careful selection of the application domain and, particularly, a sufficient degree of abstraction limit the number of components necessary for an adequate description of problems.
Reference: [Brna et al. 88] <author> P. Brna, A. Bundy, T. Dodd, M. Eisenstadt, C. K. Looi, H. Pain, B. Smith, M. van Someren, </author> <title> Prolog Programming Techniques, DAI Research Paper, </title> <type> 403, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1988 </year>
Reference-contexts: By far the most comprehensive set of schemata for list-processing programs was introduced by Gegg-Harrison in the context of a tutoring system [Gegg-Harrison 89]. Patterns can also be used to abstractly represent programs that use the same programming technique, e.g. accumulators or difference lists <ref> [Brna et al. 88] </ref>. Sterling and collaborators [Kirschenbaum et al. 94], and Robertson and his group [Bowles et al. 93] have developed systematic methods to construct logic programs, specifically Prolog programs, with the help of patterns.
Reference: [Deville 90] <author> Y. Deville, </author> <title> Logic Programming, Systematic Program Development, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990 </year>
Reference-contexts: Thus, specifications play a pivotal role in program development. While Robertson and collaborators do not introduce any explicit specifications for the logic programs to be synthesised, Sterling and collaborators define semiformal specifications adapted from <ref> [Deville 90] </ref>. Relations, claims and assumptions are specified in natural language, while formal parts of the specification comprise the types and the directionality of the arguments, the number of solutions, and optionally an executable specification in Prolog.
Reference: [Deville & Burnay 90] <author> Y. Deville, J. Burnay, </author> <title> Generalization and Program Schemata. </title> <booktitle> Proceedings of the North American Conference on Logic Programming 1989, </booktitle> <editor> E. L. Lusk, R. A. Overbeek (eds.), </editor> <publisher> MIT Press, </publisher> <month> October </month> <year> 1989, </year> <pages> pp. 409-425. </pages>
Reference-contexts: Different sets of patterns called schemata, skeletons, techniques, or clichs have been proposed. O'Keefe defined a set of schemata for recursive programs [O'Keefe 90], while Deville and Burnay suggested schemata as a basis for program construction derived from structural induction and generalisation <ref> [Deville & Burnay 90] </ref>. By far the most comprehensive set of schemata for list-processing programs was introduced by Gegg-Harrison in the context of a tutoring system [Gegg-Harrison 89].
Reference: [Fromherz 93] <author> M. P. J. Fromherz, </author> <title> A Methodology for Executable Specifications Combining Logic Programming, ObjectOrientation and Multiple Views. </title> <institution> University of Zurich, Computer Science Dept., </institution> <type> Ph.D. thesis, </type> <year> 1993 </year>
Reference-contexts: Second, in addition to schemata for Prolog programming constructs and techniques we introduce applicationspecific components. As a further enhancement of the method we have added schema-based transformations to increase the efficiency of the constructed programs. We have implemented both a program development system <ref> [Fromherz 93] </ref> and a transformation system [Fuchs & Fromherz 91], and used these systems to develop programs for nontrivial applications like the well-known library data base problem [Kemmerer et al. 87; Wing 88] and simple version of an automated teller machine [Fuchs 89]. <p> The system called Explore has four main features: an objectoriented logic language, problem-oriented views, a repository in the form of an objectoriented framework, and a refinement method for programs <ref> [Fromherz 93] </ref>. 5 We have used the Explore system for nontrivial problems such as the well-known library database problem [Kemmerer et al. 87; Wing 88] and a simple version of an automated teller machine [Fuchs 89]. <p> There is also little or no support to execute incomplete programs, to separate normal from exceptional behaviour, and to represent assertions and test-related procedures. In order to satisfy our requirements, we developed Explore/L, an objectoriented extension of Prolog <ref> [Fromherz 93] </ref>. It features classes and instances with typed attributes, relations, data encapsulation, multiple inheritance, assertions/demons, optional functional notation, and handling of dynamic and incomplete methods. Explore/L programs can access Prolog programs and vice versa.
Reference: [Fromherz & Fuchs 94] <author> Markus P. J. Fromherz, N. E. Fuchs, </author> <title> Software Development Based on Executable Specifications and Transformations, </title> <type> Report 94.07, </type> <institution> Institut fr Informatik, Universitt Zrich, </institution> <year> 1994 </year>
Reference-contexts: have been developed including the techniques editor TED. 2 In our work that we call Schema-Based Visual and Textual Composition of Logic Programs we have enhanced the method exemplified by Sterling's and Robertson's approaches in two ways intended to bridge the conceptual gap between application domains and the programming domain <ref> [Fromherz & Fuchs 94] </ref>. First, we define visual and textual views of programs that can be used to construct programs in applicationspecific concepts, and which can be understood as specifications of the programs being constructed. Second, in addition to schemata for Prolog programming constructs and techniques we introduce applicationspecific components.
Reference: [Fuchs 89] <author> N. E. Fuchs, </author> <title> SimpleMat (Customer's View), </title> <institution> University of Zurich, Computer Science Department, </institution> <note> Working Paper, 1989 12 </note>
Reference-contexts: We have implemented both a program development system [Fromherz 93] and a transformation system [Fuchs & Fromherz 91], and used these systems to develop programs for nontrivial applications like the well-known library data base problem [Kemmerer et al. 87; Wing 88] and simple version of an automated teller machine <ref> [Fuchs 89] </ref>. In section 2 we describe our enhancements to the method and discuss the role of specifications. Section 3 presents Explore, our prototypical implementation of a development system for logic programs. In section 4 we introduce schema-based program transformations and describe an extensible transformation system. <p> views, a repository in the form of an objectoriented framework, and a refinement method for programs [Fromherz 93]. 5 We have used the Explore system for nontrivial problems such as the well-known library database problem [Kemmerer et al. 87; Wing 88] and a simple version of an automated teller machine <ref> [Fuchs 89] </ref>. In the following, it has to be kept in mind that programs are actually being constructed with the help of views editors, i.e. as specifications. <p> This is an incremental, evolutionary process where the program can be validated after each step. 3.5 An Example Specification with Explore To demonstrate working with Explore, we will sketch the development of a logic program for an automated teller machine called SimpleMat <ref> [Fuchs 89] </ref>. As its name indicates, SimpleMat provides the minimal functionality of an ATM identifying customers, and withdrawing money with or without receipt. The development of the SimpleMat program consists of two integration steps and one specialisation step.
Reference: [Fuchs 92] <author> N. E. Fuchs, </author> <title> Specifications Are (Preferably) Executable, </title> <journal> Software Engineering Journal, </journal> <month> September </month> <year> 1992, </year> <pages> pp. 323-334 </pages>
Reference-contexts: Altogether, we get a smooth transition from informal to formal representations, from requirements to programs. 4 2.2 Advantages of Executable Specifications There are essentially two reasons to make specifications executable: validation and prototyping <ref> [Fuchs 92] </ref>. As Hoare pointed out, no formal method exists to validate formal specifications with respect to informal user requirements [Hoare 87]. Instead, we rely on inspecting specifications and on reasoning about their consequences to convince ourselves of their adequacy.
Reference: [Fuchs & Fromherz 91] <author> N. E. Fuchs, M. P. J. Fromherz, </author> <title> Schema-Based Transformations of Logic Programs, </title> <editor> in: K.-K. Lau, T. Clement (Eds.), </editor> <booktitle> Proceedings of LOPSTR '91, </booktitle> <institution> University of Manchester, </institution> <address> 1991, </address> <publisher> Springer, </publisher> <year> 1992 </year>
Reference-contexts: Second, in addition to schemata for Prolog programming constructs and techniques we introduce applicationspecific components. As a further enhancement of the method we have added schema-based transformations to increase the efficiency of the constructed programs. We have implemented both a program development system [Fromherz 93] and a transformation system <ref> [Fuchs & Fromherz 91] </ref>, and used these systems to develop programs for nontrivial applications like the well-known library data base problem [Kemmerer et al. 87; Wing 88] and simple version of an automated teller machine [Fuchs 89]. <p> Thus we may say that we transform an instance of one program schema into an instance of another one. This leads us to the idea of transforming program schemata instead of programs, and to define transformation schemata <ref> [Fuchs & Fromherz 91] </ref>. Transformation schemata are standardised transformations that transform input program schemata into output program schemata. Each transformation schema incorporates a fixed sequence of transformation steps, e.g. applications of unfold/fold rules.
Reference: [Gegg-Harrison 89] <author> T. S. Gegg-Harrison, </author> <title> Basic Prolog Schemata, </title> <institution> CS-1989-20, Department of Computer Science, Duke University, </institution> <month> September </month> <year> 1989 </year>
Reference-contexts: By far the most comprehensive set of schemata for list-processing programs was introduced by Gegg-Harrison in the context of a tutoring system <ref> [Gegg-Harrison 89] </ref>. Patterns can also be used to abstractly represent programs that use the same programming technique, e.g. accumulators or difference lists [Brna et al. 88].
Reference: [Hoare 87] <author> C. A. R. Hoare, </author> <title> An overview of some formal methods for program design, </title> <editor> in: C. A. R. Hoare, C. B. Jones, </editor> <booktitle> Essays in Computing Science, </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987, </year> <pages> pp. 371-387 </pages>
Reference-contexts: As Hoare pointed out, no formal method exists to validate formal specifications with respect to informal user requirements <ref> [Hoare 87] </ref>. Instead, we rely on inspecting specifications and on reasoning about their consequences to convince ourselves of their adequacy. As a further and complementary means we can write specifications in executable languages, execute them on a computer, and immediately experience their consequences [Agresti 86].
Reference: [Kamp & Reyle 93] <author> A H. Kamp, A U. Reyle, </author> <title> From Discourse to Logic; Introduction to Modeltheoretic Semantics of Natural Language, Formal Logic and Discourse Representation Theory, </title> <publisher> Kluwer, </publisher> <year> 1993 </year>
Reference-contexts: Currently, we are adding a further view editor allowing users to specify programs in controlled natural language [Macias & Pulman 92; Pulman 94]. Specifications are formulated in a restricted subset of natural language and translated into Prolog with the help of Discourse Representation Theory <ref> [Kamp & Reyle 93] </ref>. This translation is supported by a concept lexicon that provides a conceptualisation of the application domain as a collection of objects, object relations, and constraints. These concepts lead to additional components of the repository. More work needs to be done for transformation schemata.
Reference: [Kemmerer et al. 87] <author> R. A. Kemmerer, S. White, A. Mili, N. Davis, </author> <booktitle> Problem Set for the Fourth International Workshop on Software Specification and Design, in: IEEE, ACM, Proceedings Fourth International Workshop on Software Specification and Design, </booktitle> <address> Monterey, CA, </address> <year> 1987, </year> <pages> pp. ix - x </pages>
Reference-contexts: We have implemented both a program development system [Fromherz 93] and a transformation system [Fuchs & Fromherz 91], and used these systems to develop programs for nontrivial applications like the well-known library data base problem <ref> [Kemmerer et al. 87; Wing 88] </ref> and simple version of an automated teller machine [Fuchs 89]. In section 2 we describe our enhancements to the method and discuss the role of specifications. Section 3 presents Explore, our prototypical implementation of a development system for logic programs. <p> The system called Explore has four main features: an objectoriented logic language, problem-oriented views, a repository in the form of an objectoriented framework, and a refinement method for programs [Fromherz 93]. 5 We have used the Explore system for nontrivial problems such as the well-known library database problem <ref> [Kemmerer et al. 87; Wing 88] </ref> and a simple version of an automated teller machine [Fuchs 89]. In the following, it has to be kept in mind that programs are actually being constructed with the help of views editors, i.e. as specifications.
Reference: [Kirschenbaum et al. 94] <author> M. Kirschenbaum, S. Michaylov, L. Sterling, </author> <title> Skeletons and Techniques as a Normative Approach to Program Development in Logic Languages, </title> <type> Report CES-94-08, </type> <institution> Case Western Reserve University, </institution> <year> 1994 </year>
Reference-contexts: Patterns can also be used to abstractly represent programs that use the same programming technique, e.g. accumulators or difference lists [Brna et al. 88]. Sterling and collaborators <ref> [Kirschenbaum et al. 94] </ref>, and Robertson and his group [Bowles et al. 93] have developed systematic methods to construct logic programs, specifically Prolog programs, with the help of patterns. Sterling and his collaborators [Kirschenbaum et al. 94] define skeletons as basic Prolog programs with well-understood control flow, e.g. the in-order traversal <p> Sterling and collaborators <ref> [Kirschenbaum et al. 94] </ref>, and Robertson and his group [Bowles et al. 93] have developed systematic methods to construct logic programs, specifically Prolog programs, with the help of patterns. Sterling and his collaborators [Kirschenbaum et al. 94] define skeletons as basic Prolog programs with well-understood control flow, e.g. the in-order traversal of a binary tree. Skeletons describe how structured terms are to be traversed.
Reference: [Kowalski 85] <author> R. A. Kowalski, </author> <title> The relation between logic programming and logic specification, </title> <editor> in: C. A. R. Hoare, J. C. Shepherdson (Eds.), </editor> <booktitle> Mathematical Logic and Programming Languages, Prentice-Hall International, </booktitle> <year> 1985 </year>
Reference-contexts: Altogether, the characteristics of the views induce us to call them specifications of the program. Furthermore, since the views are semantically equivalent to the (executable) program they can even be considered as executable specifications. Though Prolog has been recommended as a suitable executable specification language <ref> [Kowalski 85; Sterling 94] </ref> and has often been used as such, we believe that applicationspecific specification languages as those provided by our views are a better choice since they allow us to express the concepts of the application domain directly, and still can be mapped to Prolog, or other logic languages.
Reference: [Kowalski 93] <author> R. A. Kowalski, </author> <title> Logic without Model Theory, </title> <type> Technical Report, </type> <institution> Imperial College, </institution> <year> 1993 </year>
Reference-contexts: To achieve this goal, we have introduced visual and textual views of the program being constructed, e.g. transition networks for finitestate machines and window-oriented user interfaces. Furthermore, we have associated each view with an editor, and following Kowalski's correspondence theory <ref> [Kowalski 93] </ref> have provided an automatic bidirectional mapping between a program and its views. As will be explained below, we also added a repository of predefined applicationspecific components. 3 Repository Predefined Components Program Textual View Visual View These design decisions have important consequences.
Reference: [Kramer & Mylopoulos 92] <author> B. Kramer, J. Mylopoulos, </author> <title> Knowledge Representation, </title> <editor> in: S. C. Shapiro (ed.), </editor> <booktitle> Encyclopedia of Artificial Intelligence, </booktitle> <publisher> Wiley, </publisher> <year> 1992 </year>
Reference-contexts: By making "true statements about the intended domain of discourse" <ref> [Kramer & Mylopoulos 92] </ref> these specification languages are in the original sense of the word declarative, and have all the practical advantages of declarative programming [Lloyd 94].
Reference: [Lakhotia & Sterling 88] <author> A. Lakhotia, L. Sterling, </author> <title> How to Control Unfolding when Specializing Interpreters, </title> <editor> in L. Sterling (ed.), </editor> <title> The Practice of Prolog, </title> <publisher> MIT Press, </publisher> <year> 1990, </year> <pages> pp. 171 </pages>
Reference: [Lloyd 94] <author> J. Lloyd, </author> <title> Practical Advantages of Declarative Programming, </title> <booktitle> Invited Lecture, </booktitle> <address> GULP-PRODE '94, Peiscola (Spain), </address> <month> September </month> <year> 1994 </year>
Reference-contexts: By making "true statements about the intended domain of discourse" [Kramer & Mylopoulos 92] these specification languages are in the original sense of the word declarative, and have all the practical advantages of declarative programming <ref> [Lloyd 94] </ref>. A similar point of view has been expressed by [Sterling & Turnidge 94] who developed a translator from Z specifications to Prolog, and as a result added executability to a subset of the specification language Z.
Reference: [Macias & Pulman 92] <author> B. Macias, S. Pulman, </author> <title> Natural Language Processing for Requirements Specifications, </title> <editor> in: F. Redmill, T. Anderson (Eds.), </editor> <title> Safety-Critical Systems, Current Issues, Techniques and Standards, </title> <publisher> Chapman & Hall, </publisher> <pages> pp. 67-89, </pages> <year> 1993 </year>
Reference-contexts: Currently, we are adding a further view editor allowing users to specify programs in controlled natural language <ref> [Macias & Pulman 92; Pulman 94] </ref>. Specifications are formulated in a restricted subset of natural language and translated into Prolog with the help of Discourse Representation Theory [Kamp & Reyle 93].
Reference: [O'Keefe 90] <author> R. A. O'Keefe, </author> <title> The Craft of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1990 </year>
Reference-contexts: Different sets of patterns called schemata, skeletons, techniques, or clichs have been proposed. O'Keefe defined a set of schemata for recursive programs <ref> [O'Keefe 90] </ref>, while Deville and Burnay suggested schemata as a basis for program construction derived from structural induction and generalisation [Deville & Burnay 90]. By far the most comprehensive set of schemata for list-processing programs was introduced by Gegg-Harrison in the context of a tutoring system [Gegg-Harrison 89].
Reference: [Pereira & Shieber 87] <author> F. C. N. Pereira, S. M. Shieber, </author> <title> Prolog and Natural-Language Analysis, </title> <type> CSLI, Lectures Notes 10, </type> <year> 1987 </year>
Reference: [Proietti & Pettorossi 90] <author> M. Proietti, A. Pettorossi, </author> <title> Synthesis of Eureka Predicates for Developing Logic Programs, </title> <booktitle> Proceedings of ESOP '90, LNCS 432, </booktitle> <year> 1990, </year> <pages> pp. 306-325 </pages>
Reference: [Pulman 94] <author> S. Pulman, </author> <title> Natural Language Processing and Requirements Specification, Presentation at the Prolog Forum, </title> <institution> Department of Computer Science, University of Zurich, </institution> <month> February </month> <year> 1994 </year>
Reference-contexts: Currently, we are adding a further view editor allowing users to specify programs in controlled natural language <ref> [Macias & Pulman 92; Pulman 94] </ref>. Specifications are formulated in a restricted subset of natural language and translated into Prolog with the help of Discourse Representation Theory [Kamp & Reyle 93].
Reference: [Rich & Waters 86] <editor> C. Rich, R. C. Waters (Eds.), </editor> <booktitle> Readings in Artificial Intelligence and Software Engineering, </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1986 </year>
Reference-contexts: These specifications are usually mapped to programs based on generate-and-test schemata. In this case, the program constructed is inefficient and mere compilation will not remove this inefficiency. To get efficient programs in all cases, we decided to follow a variation of the transformational implementation paradigm <ref> [Agresti 86; Rich & Waters 86] </ref>: optionally, programs are transformed by powerful source-to-source transformations before they are compiled.
Reference: [Sterling 94] <author> L. Sterling, </author> <title> Prolog for Software Engineering, </title> <booktitle> Tutorial at the Second International Conference on the Practical Applications of Prolog PAP'94, </booktitle> <address> London, </address> <month> April </month> <year> 1994 </year>
Reference-contexts: Altogether, the characteristics of the views induce us to call them specifications of the program. Furthermore, since the views are semantically equivalent to the (executable) program they can even be considered as executable specifications. Though Prolog has been recommended as a suitable executable specification language <ref> [Kowalski 85; Sterling 94] </ref> and has often been used as such, we believe that applicationspecific specification languages as those provided by our views are a better choice since they allow us to express the concepts of the application domain directly, and still can be mapped to Prolog, or other logic languages.
Reference: [Sterling & Turnidge 94] <author> L. Sterling, T. Turnidge, </author> <title> Z Specifications: Syntactic Sugar for Prolog?, </title> <editor> in: P. Ciancarini, L. Sterling (eds.), </editor> <booktitle> Proceedings of the Post-Conference 13 Workshop on Applications of Logic Programming to Software Engineering, ICLP 94, </booktitle> <year> 1994 </year>
Reference-contexts: By making "true statements about the intended domain of discourse" [Kramer & Mylopoulos 92] these specification languages are in the original sense of the word declarative, and have all the practical advantages of declarative programming [Lloyd 94]. A similar point of view has been expressed by <ref> [Sterling & Turnidge 94] </ref> who developed a translator from Z specifications to Prolog, and as a result added executability to a subset of the specification language Z. When programs can be derived automatically from their specifications, it has been advocated to maintain the specifications instead of the programs [Agresti 86].
Reference: [Wing 88] <author> J. M. Wing, </author> <title> A Study of 12 Specifications of the Library Problem, </title> <journal> IEEE Software, </journal> <volume> 7, </volume> <pages> pp. 66-76, </pages> <year> 1988 </year>
Reference-contexts: We have implemented both a program development system [Fromherz 93] and a transformation system [Fuchs & Fromherz 91], and used these systems to develop programs for nontrivial applications like the well-known library data base problem <ref> [Kemmerer et al. 87; Wing 88] </ref> and simple version of an automated teller machine [Fuchs 89]. In section 2 we describe our enhancements to the method and discuss the role of specifications. Section 3 presents Explore, our prototypical implementation of a development system for logic programs. <p> The system called Explore has four main features: an objectoriented logic language, problem-oriented views, a repository in the form of an objectoriented framework, and a refinement method for programs [Fromherz 93]. 5 We have used the Explore system for nontrivial problems such as the well-known library database problem <ref> [Kemmerer et al. 87; Wing 88] </ref> and a simple version of an automated teller machine [Fuchs 89]. In the following, it has to be kept in mind that programs are actually being constructed with the help of views editors, i.e. as specifications.
Reference: [Zave & Yeh 81] <author> P. Zave, R. T. Yeh, </author> <title> Executable Requirements Specification for Embedded Systems, </title> <booktitle> Proceedings of the 5th International Conference on Software Engineering, </booktitle> <pages> pp. 295-304, </pages> <address> San Diego, </address> <year> 1981 </year>
Reference-contexts: This division into two phases one problem-oriented, one implementation-oriented corresponds more to the reality of software development than the phases of the standard life-cycle that originated from the idea of milestones <ref> [Zave & Yeh 81] </ref>. We have implemented both a prototypical program development system and a transformation system, and used these systems to develop programs for nontrivial applications like the well-known library data base problem and an automated teller machine.
References-found: 30

