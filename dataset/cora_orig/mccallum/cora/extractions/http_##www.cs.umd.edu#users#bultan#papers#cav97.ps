URL: http://www.cs.umd.edu/users/bultan/papers/cav97.ps
Refering-URL: http://www.cs.umd.edu/users/bultan/publications-abstracts.html
Root-URL: 
Title: Symbolic Model Checking of Infinite State Systems Using Presburger Arithmetic  
Author: Tevfik Bultan, Richard Gerber and William Pugh 
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science University of Maryland,  
Abstract: We present a new symbolic model checker which conservatively evaluates safety and liveness properties on infinite-state programs. We use Presburger formulas to symbolically encode a program's transition system, as well as its model-checking computations. All fixpoint calculations are executed symbolically, and their convergence is guaranteed by using approximation techniques. We demonstrate the promise of this technology on some well-known infinite-state concurrency problems.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger, P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138(1) </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: Since our basic temporal operators require similar computations, we were able to successfully use this method in conjunction with the Omega library. Finally, our encoding of program states is similar to that used by Alur et al. in verifying hybrid systems <ref> [1] </ref>. A hybrid system is a discrete control automaton, which interacts with continuously-changing, external parameters.
Reference: 2. <author> G. R. Andrews. </author> <title> Concurrent Programming, </title> <booktitle> Principles and Practice. </booktitle> <publisher> The Ben jamin/Cummings Publishing Company, </publisher> <year> 1991. </year>
Reference-contexts: Also, we use conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. In this paper we demonstrate our model checker's effectiveness on some classical infinite-state programs, taken from the concurrency literature <ref> [2] </ref>. While relatively small, they possess some interesting subtleties, especially in the tricky way their infinite-state variables influence control flow. ? This work was supported in part by ONR grant N00014-94-10228, NSF YI CCR 9357850 and a Packard Fellowship. <p> Each event is represented with an enabling condition and an action, where the enabling condition constrains the states in which the event can occur, and the action defines a transformation on the variables of the program. Consider the concurrent program shown in Figure 1, which implements the bakery algorithm <ref> [2] </ref> to achieve mutual exclusion between two processes. Here the control points for each process are denoted T; W; C, which stand for thinking, waiting or in critical section, respectively. <p> Indeed, our exact analyzer diverged when we fed it the so-called ticket algorithm <ref> [2] </ref>, along with its related mutual exclusion property (see Figure 3). In particular, note its similarity to the bakery algorithm.
Reference: 3. <author> A. Arnold. </author> <title> Finite Transition Systems: Semantics of Communicating Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: Unlike Clarke et al. [7], we do not require the transition relation X to be total. Rather, the semantics is defined using maximal paths <ref> [3] </ref> (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: 4. <author> R. E. Bryant. </author> <title> Symbolic Boolean manipulation with ordered binary-decision dia grams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <year> 1992. </year>
Reference-contexts: Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [5, 7]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [4, 5] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [6, 9, 14]).
Reference: 5. <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. 5th Annual IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction In recent years, there has been a surge of progress in the area of automated analysis for finite-state systems. Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., <ref> [5, 7] </ref>), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [4, 5]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [6, 9, <p> Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., [5, 7]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., <ref> [4, 5] </ref>); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [6, 9, 14]).
Reference: 6. <author> T. Bultan, J. Fischer, and R. Gerber. </author> <title> Compositional verification by model checking for counter-examples. </title> <booktitle> In Proc. 1996 Int. Symp. on Software Testing and Analysis, </booktitle> <pages> pages 224-238, </pages> <year> 1996. </year>
Reference-contexts: (e.g., [5, 7]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [4, 5]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [6, 9, 14] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also general safety and liveness properties become undecidable for infinite transition systems.
Reference: 7. <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction In recent years, there has been a surge of progress in the area of automated analysis for finite-state systems. Several reasons for this success are: (1) the development of powerful techniques such as model-checking (e.g., <ref> [5, 7] </ref>), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [4, 5]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., [6, 9, <p> A path (s 0 ; s 1 ; s 2 ; : : :) is a (finite or infinite) sequence of states, such that for each successive pair of states (s i ; s i+1 ) 2 X. Unlike Clarke et al. <ref> [7] </ref>, we do not require the transition relation X to be total. Rather, the semantics is defined using maximal paths [3] (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: 8. <author> E. M. Clarke, O. Grumberg, D. E. </author> <title> Long Model checking and abstraction. </title> <booktitle> In Proc. 18th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference-contexts: Other methods have been proposed to deal with infinite-state programs like these, and we note some of them here. In <ref> [8] </ref> Clarke et al. present a conservative model checking technique, by producing a finite abstraction of the program (e.g. via a congruence relation modulo a suitable integer), and then checking the property of interest on the abstraction.
Reference: 9. <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proc. 4th Annual IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <year> 1989. </year>
Reference-contexts: (e.g., [5, 7]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [4, 5]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [6, 9, 14] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also general safety and liveness properties become undecidable for infinite transition systems.
Reference: 10. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. 4th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: There may be cases where abstraction methods can vastly reduce the state space without achieving a finite representation. In these cases our model checker can be used on the infinite abstract models. Our work was influenced by known techniques from abstract interpretation <ref> [10, 11] </ref>; specifically, we use some approximation methods first developed for that domain. Most reachability properties can be formulated as least fixpoints over sets of a program's states; if the state space is infinite, these fixpoints may not be computable. <p> Thus the fixpoint of the ^ Q i 's is an upper approximation to the least fixpoint of the Q i 's. To generate the ^ Q i 's, we currently adopt a method developed by Cousot and Cousot, within the framework of abstract interpretation <ref> [10] </ref>. That is, we define an operator called widening, or "5", which majorizes the union computation as follows: For any pair of sets P; P 0 , P [ P 0 P 5 P 0 .
Reference: 11. <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among vari ables of a program. </title> <booktitle> In Proc. 5th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <year> 1978. </year>
Reference-contexts: There may be cases where abstraction methods can vastly reduce the state space without achieving a finite representation. In these cases our model checker can be used on the infinite abstract models. Our work was influenced by known techniques from abstract interpretation <ref> [10, 11] </ref>; specifically, we use some approximation methods first developed for that domain. Most reachability properties can be formulated as least fixpoints over sets of a program's states; if the state space is infinite, these fixpoints may not be computable. <p> Our goal is to find a widening operator which (1) yields a suitable (i.e., reasonably tight) upper bound for union, and (2) forces the ^ Q i sequences to converge. In defining our widening operator, we generalized a technique used by Cousot and Halbwachs in <ref> [11] </ref>. The idea is to "guess" the direction of growth in the model-checker's Q i iterates, and to extend the successive iterates in these directions. Cousot and Halbwachs' widening operator b 5 does this for convex polyhedra - i.e., regions formed by a conjunction of affine constraints.
Reference: 12. <author> J. Dingel, and T. Filkorn. </author> <title> Model checking for infinite state systems using data ab straction, assumption-commitment style reasoning and theorem proving. </title> <booktitle> In Proc. 7th Int. Conference on Computer Aided Verification, </booktitle> <volume> LNCS 939, </volume> <pages> pages 54-69, </pages> <year> 1995. </year>
Reference-contexts: In [8] Clarke et al. present a conservative model checking technique, by producing a finite abstraction of the program (e.g. via a congruence relation modulo a suitable integer), and then checking the property of interest on the abstraction. In <ref> [12] </ref> Dingel and Filkorn extend this method using "assumption-commitment" style reasoning and theorem proving. While these techniques require the user to find the appropriate abstractions and hence are not completely automatable we see them as being orthogonal to our approach.
Reference: 13. <author> M. J. Fischer and M. O. Rabin. </author> <title> Super-Exponential Complexity of Presburger Arithmetic. </title> <journal> SIAM-AMS Proc., </journal> <volume> Volume 7, </volume> <pages> pages 27-41, </pages> <year> 1974. </year>
Reference-contexts: The set of closed formulas defined by the above grammar forms the theory of integers with addition, called Presburger arithmetic. An important property of Presburger arithmetic is that validity is decidable. In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive <ref> [13] </ref>. Yet we have found that the Omega library [15, 17] is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers.
Reference: 14. <author> P. Godefroid. </author> <title> Partial-order methods for the verification of concurrent systems: An approach to the state-explosion problem. </title> <type> Ph.D. Thesis, </type> <institution> Universite De Liege, </institution> <year> 1994. </year>
Reference-contexts: (e.g., [5, 7]), which can efficiently verify safety and liveness properties; (2) innovative new data structures that symbolically encode large sets of states in compact formats (e.g., [4, 5]); and (3) new ways of carrying out compositional and local analysis, to assuage the "state explosion" usually associated with concurrency (e.g., <ref> [6, 9, 14] </ref>). But when transition systems are not restricted to be finite, most of these techniques are no longer applicable, as they inherently depend on all underlying types being bounded. Also general safety and liveness properties become undecidable for infinite transition systems.
Reference: 15. <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman and D. Won nacott. </author> <title> The Omega Library (version 1.00) interface guide. </title> <note> Available at &lt;http://www.cs.umd.edu/projects/omega&gt;. </note>
Reference-contexts: We have developed a symbolic model checker to attack this problem, which symbolically encodes transition relations and sets of states using affine constraints on integer variables, logical connectives and quantifiers (i.e., Presburger formulas). Then, it efficiently manipulates these formulas (via a fast Presburger solver called the Omega library <ref> [15, 17] </ref>) to derive truth sets of temporal logic formulas and their fixpoint computations. Also, we use conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. <p> An important property of Presburger arithmetic is that validity is decidable. In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive [13]. Yet we have found that the Omega library <ref> [15, 17] </ref> is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers. <p> After partitioning of the state space, we use the Omega library <ref> [15] </ref> to help symbolically compute the truth sets for the temporal properties at hand.
Reference: 16. <author> W. Kelly, W. Pugh, E. Rosser and T. Shpeisman. </author> <title> Transitive closure of infinite graphs and its applications. </title> <type> Technical Report CS-TR-3457, </type> <institution> UMIACS-TR-95-48, Department of Computer Science, University of Maryland, </institution> <year> 1994. </year>
Reference-contexts: The Omega library includes a large collection of object classes to efficiently manipulate Presburger formulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [16, 17] </ref>. The particular Omega functions we use are shown in Figure 2 (A). These functions take symbolic representations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output. <p> While our multiple-polyhedra widening approximation helped solve one of the problems in this paper, it can often be rather coarse. In general it sacrifices precision for finite termination. We are currently developing more precise methods for reachability properties using transitive closure computation techniques for Presburger formulas <ref> [16] </ref>. As we acquire more experience with both types of approximations, we hope to determine which techniques work best for different classes of programs, and why. We also plan to investigate compositional approaches. We currently form our state-partitions over the Cartesian-product of all variable domains.
Reference: 17. <author> W. Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-104, </pages> <year> 1992. </year>
Reference-contexts: We have developed a symbolic model checker to attack this problem, which symbolically encodes transition relations and sets of states using affine constraints on integer variables, logical connectives and quantifiers (i.e., Presburger formulas). Then, it efficiently manipulates these formulas (via a fast Presburger solver called the Omega library <ref> [15, 17] </ref>) to derive truth sets of temporal logic formulas and their fixpoint computations. Also, we use conservative approximation techniques in analysis of infinite state programs, which guarantee convergence by allowing false negatives. <p> An important property of Presburger arithmetic is that validity is decidable. In general, the worst-case time bound for determining validity in Presburger arithmetic is prohibitive [13]. Yet we have found that the Omega library <ref> [15, 17] </ref> is quite efficient at solving the problems that arise in our analysis, which typically possess a small number of constraints, and do not contain multiple levels of alternating quantifiers. <p> The Omega library includes a large collection of object classes to efficiently manipulate Presburger formulas; to date it has mainly been used in high-performance compilers, specifically for dependence analysis, program transformations, and detecting redundant synchronization <ref> [16, 17] </ref>. The particular Omega functions we use are shown in Figure 2 (A). These functions take symbolic representations of sets or relations as inputs (i.e., a Presburger formula representing a set or a relation), and return the symbolic form of a set or a relation as output.
Reference: 18. <author> A. Udaya Shankar. </author> <title> An introduction to assertional reasoning for concurrent sys tems. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(3) </volume> <pages> 225-262, </pages> <year> 1993. </year>
Reference-contexts: The bakery algorithm. 2 Representation of Programs and Properties We use the event-action language from <ref> [18] </ref> as our syntax for concurrent programs, with a semantics defined in terms of infinite transition systems.
References-found: 18

