URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/97-004.ps.Z
Refering-URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/FILE.html
Root-URL: http://www.cs.unc.edu
Email: fzhangh,manocha,hudson,hoffg@cs.unc.edu  
Title: Visibility Culling Using Hierarchical Occlusion Maps  
Author: Hansong Zhang Dinesh Manocha Tom Hudson Kenny Hoff 
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: We present hierarchical occlusion maps (HOM) for visibility culling on complex models with high depth complexity. The culling algorithm uses an object space bounding volume hierarchy and a hierarchy of image space occlusion maps. Occlusion maps represent the aggregate of projections of the occluders onto the image plane. For each frame, the algorithm selects a small set of objects from the model as occluders and renders them to form an initial occlusion map, from which a hierarchy of occlusion maps is built. The occlusion maps are used to conservatively cull away a portion of the model not visible from the current viewpoint. The algorithm is applicable to all models and makes no assumptions about the size, shape, or type of occluders. It has been implemented on current graphics systems and has been applied to large models composed of hundreds of thousands of polygons. In practice, it achieves significant speedup in interactive walkthroughs of models with high depth complexity. Key Words and Phrases: visibility culling, interactive display, image pyramid, occlusion culling, hierarchical data structures 
Abstract-found: 1
Intro-found: 1
Reference: [ARB90] <author> J. Airey, J. Rohlf, and F. Brooks. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 41-50, </pages> <year> 1990. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives <ref> [ARB90, TS91, LG95] </ref>. In particular, Teller et al. [TS91, Tel92, TH93] have presented analytic algorithms for cell-to-cell visibility and also applied them to efficient calculation of form factors for ra-diosity. <p> If a model under some the viewing conditions does not have sufficient occlusion, the overall frame rate may decrease due to the overhead, in which case occlusion culling should be turned off. 17 7.1 Comparison to Object Space Algorithms Work on cells and portals <ref> [ARB90, TS91, LG95] </ref> addresses a special class of densely occluded environments where there are plenty of cell and portal structures, as in an in-door architectural model. [ARB90, TS91] pre-precesses the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the pre-processing. <p> to the overhead, in which case occlusion culling should be turned off. 17 7.1 Comparison to Object Space Algorithms Work on cells and portals [ARB90, TS91, LG95] addresses a special class of densely occluded environments where there are plenty of cell and portal structures, as in an in-door architectural model. <ref> [ARB90, TS91] </ref> pre-precesses the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the pre-processing. These methods works very well for the particular environment, but are not applicable to models without cell/portal structures.
Reference: [BM96] <author> D. Blythe and T. </author> <title> McReynolds Programming with OpenGL: </title> <booktitle> Advanced Sig-graph'96 course notes, </booktitle> <year> 1996. </year>
Reference-contexts: In such cases, the use of texture mapping hardware may slow down the computation of occlusion maps rather than accelerate it and hierarchy building is faster on the host CPU. The break-even point between hardware and software hierarchy construction varies with different graphics systems. <ref> [BM96] </ref> have presented a technique for generating mipmaps by using a hardware accumulation buffer.
Reference: [Br96] <author> R. Brechner et al. </author> <title> Interactive walkthrough of large geometric databases. </title> <booktitle> Siggraph'96 course notes, </booktitle> <year> 1996. </year>
Reference-contexts: A number of techniques for interactive walkthrough of large geometric databases have been proposed. Refer to <ref> [Br96] </ref> for a recent survey. A number of commercial systems like Performer [RH94], used for high performance graphics, and Brush [SBM + 94], used for visualizing architectural and CAD models, are available.
Reference: [Car84] <author> L. Carpenter. </author> <title> The A-buffer, an antialiased hidden surface method. </title> <booktitle> Proc. of ACM Siggraph, </booktitle> <pages> pages 103-108, </pages> <year> 1984. </year>
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: Section 7 analyses our algorithm and compares it with other approaches. Finally, in Section 8 we briefly describe some future directions. 3 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics [FDHF90]. Some of the commonly used visibility algorithms are based on Z-buffer <ref> [Cat74] </ref> and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See [Dor94] for a recent survey.
Reference: [Cla76] <author> J.H. Clark. </author> <title> Hierarchical geometric models for visible surface algorithms. </title> <journal> Communications of the ACM, </journal> 19(10) 547-554, 1976. 
Reference-contexts: Finally, in Section 8 we briefly describe some future directions. 3 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics [FDHF90]. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling <ref> [Cla76, GBW90] </ref>. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See [Dor94] for a recent survey.
Reference: [Co96] <author> J. Cohen et al. </author> <title> Simplification envelopes. </title> <booktitle> In Proc. of ACM Siggraph'96, </booktitle> <pages> pages 119-128, </pages> <year> 1996. </year>
Reference: [CT96a] <author> S. Coorg and S. Teller. </author> <title> A spatially and temproally coherent object space visibility algorithm. </title> <type> Technical Report TM 546, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <year> 1996. </year> <month> 20 </month>
Reference-contexts: They used regular spatial subdivision to partition the model into cells and describe a 2D implementation. However, the resulting algorithm is very memory-intensive and does not scale well to large models. Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96a, CT96b] </ref> and Hudson et al. [Hu96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96a, CT96b] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to <p> Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96a, CT96b] </ref> and Hudson et al. [Hu96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96a, CT96b] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hu96] use shadow frusta and fast interference tests for occlusion culling. <p> Only objects that fail one of the latter two tests (depth or overlap) are rendered. Our approach shares a number of characteristics with earlier work. This includes dynamically selecting the occluders, as in <ref> [CT96b, CT96a] </ref> and [Hu96], and using a combination of object space and image space hierarchy, as in [GKM93] and [Gre96]. <p> In general however, we do not expect to outperform the specialized algorithms in cell/port environments. Two different object space solutions for more general models have been proposed by <ref> [CT96b, CT96a] </ref> and [Hu96]. They dynamically choose polygons and convex objects (or simple convex combination of polygons) as occluders and use them to cull away invisible portions of the model. However, many models do not have single big convex occluders.
Reference: [CT96b] <author> S. Coorg and S. Teller. </author> <title> Temporally coherent conservative visibility. </title> <booktitle> In Proc. of 12th ACM Symposium on Computational Geometry, </booktitle> <year> 1996. </year>
Reference-contexts: They used regular spatial subdivision to partition the model into cells and describe a 2D implementation. However, the resulting algorithm is very memory-intensive and does not scale well to large models. Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96a, CT96b] </ref> and Hudson et al. [Hu96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96a, CT96b] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to <p> Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96a, CT96b] </ref> and Hudson et al. [Hu96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96a, CT96b] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hu96] use shadow frusta and fast interference tests for occlusion culling. <p> Only objects that fail one of the latter two tests (depth or overlap) are rendered. Our approach shares a number of characteristics with earlier work. This includes dynamically selecting the occluders, as in <ref> [CT96b, CT96a] </ref> and [Hu96], and using a combination of object space and image space hierarchy, as in [GKM93] and [Gre96]. <p> In general however, we do not expect to outperform the specialized algorithms in cell/port environments. Two different object space solutions for more general models have been proposed by <ref> [CT96b, CT96a] </ref> and [Hu96]. They dynamically choose polygons and convex objects (or simple convex combination of polygons) as occluders and use them to cull away invisible portions of the model. However, many models do not have single big convex occluders.
Reference: [Dor94] <author> S. E. Dorward. </author> <title> A survey of object-space hidden surface removal. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 4 </volume> <pages> 325-362, </pages> <year> 1994. </year>
Reference-contexts: Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See <ref> [Dor94] </ref> for a recent survey. However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80].
Reference: [FDHF90] <author> J. Foley, A. Van Dam, J. Hughes, and S. </author> <title> Feiner. </title> <booktitle> Computer Graphics: Principles and Practice. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: We describe its implementation and performance in Section 6. Section 7 analyses our algorithm and compares it with other approaches. Finally, in Section 8 we briefly describe some future directions. 3 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics <ref> [FDHF90] </ref>. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. <p> Finally, in Section 8 we briefly describe some future directions. 3 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics <ref> [FDHF90] </ref>. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See [Dor94] for a recent survey. However, the practical utility of these algorithms is unclear at the moment. <p> Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms <ref> [War69, FDHF90] </ref>. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See [Dor94] for a recent survey. However, the practical utility of these algorithms is unclear at the moment. <p> Any rendered image can have an accompanying occlusion map which has the same resolution and stores the opacity for each pixel. In such a case, the occlusion map is essentially the ff channel <ref> [FDHF90] </ref> of the rendered image (assuming ff values for objects are set properly during rendering), though generally speaking a pixel in the occlusion map can correspond to a block of pixels in the screen space.
Reference: [FKN80] <author> H. Fuchs, Z. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <booktitle> Proc. of ACM Siggraph, </booktitle> <volume> 14(3) </volume> <pages> 124-133, </pages> <year> 1980. </year>
Reference-contexts: See [Dor94] for a recent survey. However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree <ref> [FKN80] </ref>. The tree construction may involve considerable preprocessing in terms of time and space requirements for large models. In [Nay92], Naylor has given an output-sensitive visibility algorithm using BSPs.
Reference: [GBR91] <author> R. Coifman G. Beylkin and V. Rokhlin. </author> <title> Fast wavelet transforms and numerical algorithms: I. </title> <journal> Communications of Pure and Applied Mathematics, </journal> <volume> 44(2) </volume> <pages> 141-183, </pages> <year> 1991. </year>
Reference-contexts: The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z-pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition <ref> [GBR91, SDS96] </ref>. 3 Overview In this paper we present a conservative solution to the visibility problem. Given a scene database and a viewpoint, our algorithm culls a subset of the objects not visible.
Reference: [GBW90] <author> B. Garlick, D. Baum, and J. Winget. </author> <title> Interactive viewing of large geometric databases using multiprocessor graphics workstations. Siggraph'90 course notes: Parallel Algorithms and Architectures for 3D Image Generation, </title> <year> 1990. </year>
Reference-contexts: Finally, in Section 8 we briefly describe some future directions. 3 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics [FDHF90]. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling <ref> [Cla76, GBW90] </ref>. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See [Dor94] for a recent survey.
Reference: [GCS91] <author> Z. Gigus, J. Canny, and R. Seidel. </author> <title> Efficiently computing and representing aspect graphs of polyhedral objects. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> 13(6) </volume> <pages> 542-551, </pages> <year> 1991. </year>
Reference-contexts: Another possibility is to pre-compute global visibility information for computing the useful occluders at every viewpoint. The fastest known algorithm for computing the effects on global visibility due to a single polyhedron with m vertices can take O (m 6 log m) time in the worst case <ref> [GCS91] </ref>. We present algorithms to estimate a set of occluders that are used to cull a significant 12 in the occlusion maps. The holes dissolve as we go up in the hierarchy.
Reference: [GK94] <author> N. Greene and M. Kass. </author> <title> Error-bounded antialiased rendering of complex environments. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 59-66, </pages> <year> 1994. </year>
Reference-contexts: These algorithms are unable to combine a "forest" of small non-convex or disjoint occluders to cull away large portions of the model. A hierarchical Z-buffer algorithm combining spatial and temporal coherence has been presented in <ref> [GKM93, GK94, Gre95] </ref>. It uses two hierarchical data structures: an octree and a Z-pyramid. The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models. <p> The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models. However, most current graphics systems do not support the Z-pyramid capa 4 bility in hardware, and simulating it in software can be relatively expensive. In <ref> [GK94] </ref>, Greene and Kass used a quadtree data structure to test visibility throughout image-space regions for anti-aliased rendering. More recently, Greene [Gre96] has presented a hierarchical tiling algorithm using coverage masks. It uses an image hierarchy named a "coverage pyramid" for visibility culling.
Reference: [GKM93] <author> N. Greene, M. Kass, and G. Miller. </author> <title> Hierarchical z-buffer visibility. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 231-238, </pages> <year> 1993. </year>
Reference-contexts: These algorithms are unable to combine a "forest" of small non-convex or disjoint occluders to cull away large portions of the model. A hierarchical Z-buffer algorithm combining spatial and temporal coherence has been presented in <ref> [GKM93, GK94, Gre95] </ref>. It uses two hierarchical data structures: an octree and a Z-pyramid. The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models. <p> They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z-pyramids <ref> [GKM93] </ref>, coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition [GBR91, SDS96]. 3 Overview In this paper we present a conservative solution to the visibility problem. Given a scene database and a viewpoint, our algorithm culls a subset of the objects not visible. <p> Our approach shares a number of characteristics with earlier work. This includes dynamically selecting the occluders, as in [CT96b, CT96a] and [Hu96], and using a combination of object space and image space hierarchy, as in <ref> [GKM93] </ref> and [Gre96]. <p> Our algorithm lies between the object space and the image space and the occluder merging problem is solved in image space. 7.2 Comparison with Hierarchical Z-buffer Algorithm In many ways, we present an alternative approach to hierarchical Z-buffer visibility <ref> [GKM93] </ref>. The main algorithm presented in [GKM93] performs updates of the Z-buffer hierarchy as geometry is rendered. It assumes special-purpose hardware for fast depth updating and querying to obtain interactive performance. In terms of potential, we believe it is perhaps the most powerful and effective algorithm for visibility culling. <p> Our algorithm lies between the object space and the image space and the occluder merging problem is solved in image space. 7.2 Comparison with Hierarchical Z-buffer Algorithm In many ways, we present an alternative approach to hierarchical Z-buffer visibility <ref> [GKM93] </ref>. The main algorithm presented in [GKM93] performs updates of the Z-buffer hierarchy as geometry is rendered. It assumes special-purpose hardware for fast depth updating and querying to obtain interactive performance. In terms of potential, we believe it is perhaps the most powerful and effective algorithm for visibility culling. <p> However, we are not aware of any hardware implementation. There is a possible variation of hierarchical Z-buffer algorithm which selects occlud-ers, renders them, reads back the depth buffer once per frame, builds the Z-pyramid, and use the screen-space bounding boxes for fast culling. (The algorithm proposed in <ref> [GKM93] </ref> uses the exact projection of octree nodes, which requires software scan-conversion.) In this case, the main difference between our approach and the possible variation of hierarchical Z-buffer reduces to that between the properties of the occlusion map hierarchy and the Z pyramid.
Reference: [Gre95] <author> N. Greene. </author> <title> Hierarchical Rendering of Complex Environments. </title> <type> PhD thesis, </type> <institution> University of California at Santa Cruz, </institution> <year> 1995. </year>
Reference-contexts: These algorithms are unable to combine a "forest" of small non-convex or disjoint occluders to cull away large portions of the model. A hierarchical Z-buffer algorithm combining spatial and temporal coherence has been presented in <ref> [GKM93, GK94, Gre95] </ref>. It uses two hierarchical data structures: an octree and a Z-pyramid. The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models.
Reference: [Gre96] <author> N. Greene. </author> <title> Hierarchical polygon tiling with coverage masks. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 65-74, </pages> <year> 1996. </year>
Reference-contexts: However, most current graphics systems do not support the Z-pyramid capa 4 bility in hardware, and simulating it in software can be relatively expensive. In [GK94], Greene and Kass used a quadtree data structure to test visibility throughout image-space regions for anti-aliased rendering. More recently, Greene <ref> [Gre96] </ref> has presented a hierarchical tiling algorithm using coverage masks. It uses an image hierarchy named a "coverage pyramid" for visibility culling. Traversing polygons from front to back, it can process densely occluded scenes efficiently and is well suited to anti-aliasing by oversampling and filtering. <p> The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z-pyramids [GKM93], coverage pyramids <ref> [Gre96] </ref>, and two-dimensional wavelet transforms like the non-standard decomposition [GBR91, SDS96]. 3 Overview In this paper we present a conservative solution to the visibility problem. Given a scene database and a viewpoint, our algorithm culls a subset of the objects not visible. <p> Our approach shares a number of characteristics with earlier work. This includes dynamically selecting the occluders, as in [CT96b, CT96a] and [Hu96], and using a combination of object space and image space hierarchy, as in [GKM93] and <ref> [Gre96] </ref>. <p> Our hierarchical occlusion maps have a number of similarities to and differences from coverage pyramids <ref> [Gre96] </ref>, as discussed in Section 7.3. 4.1 Image Pyramid Given the lowest level occlusion map, the algorithm constructs from it a hierarchy of occlusion maps (HOM) by recursively applying the average operator to rectangular blocks of pixels. This operation forms an image pyramid as shown in Figure 3. <p> Not only is this information used for early termination of the hierarchical test, but also used to adaptively adjust the selection criterion used in the occluder selection algorithm. 7.3 Comparison with Hierarchical Tiling with Coverage Masks Hierarchical polygon tiling <ref> [Gre96] </ref> tiles polygons in front-to-back order and uses a "coverage" pyramid for visibility culling. <p> This has lead to desirable features, as discussed above. Like HOM, the coverage masks do not contain depth information and the algorithm in <ref> [Gre96] </ref> uses a BSP-tree for depth-ordering of polygons. Our algorithm has no restriction in terms of rendering the polygons front to back. Rather it only needs a conservatively estimated boundary between the occluders and potential occludees, which is represented by the depth estimation buffer.
Reference: [Hu96] <author> T. Hudson et al. </author> <title> Accelerated occlusion culling using shadow frusta. </title> <type> Technical Report TR96-052, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1996. </year>
Reference-contexts: However, the resulting algorithm is very memory-intensive and does not scale well to large models. Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller [CT96a, CT96b] and Hudson et al. <ref> [Hu96] </ref>. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96a, CT96b] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hu96] use shadow <p> et al. <ref> [Hu96] </ref>. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96a, CT96b] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hu96] use shadow frusta and fast interference tests for occlusion culling. All of them are object-space algorithms and the choice of occluder is restricted to convex objects or simple combination of convex objects (e.g. two convex polytope sharing an edge). <p> Only objects that fail one of the latter two tests (depth or overlap) are rendered. Our approach shares a number of characteristics with earlier work. This includes dynamically selecting the occluders, as in [CT96b, CT96a] and <ref> [Hu96] </ref>, and using a combination of object space and image space hierarchy, as in [GKM93] and [Gre96]. <p> In general however, we do not expect to outperform the specialized algorithms in cell/port environments. Two different object space solutions for more general models have been proposed by [CT96b, CT96a] and <ref> [Hu96] </ref>. They dynamically choose polygons and convex objects (or simple convex combination of polygons) as occluders and use them to cull away invisible portions of the model. However, many models do not have single big convex occluders.
Reference: [LG95] <author> D. Luebke and C. Georges. </author> <title> Portals and mirrors: Simple, fast evaluation of potentially visible sets. </title> <booktitle> In ACM Interactive 3D Graphics Conference, </booktitle> <address> Mon-terey, CA, </address> <year> 1995. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives <ref> [ARB90, TS91, LG95] </ref>. In particular, Teller et al. [TS91, Tel92, TH93] have presented analytic algorithms for cell-to-cell visibility and also applied them to efficient calculation of form factors for ra-diosity. <p> If a model under some the viewing conditions does not have sufficient occlusion, the overall frame rate may decrease due to the overhead, in which case occlusion culling should be turned off. 17 7.1 Comparison to Object Space Algorithms Work on cells and portals <ref> [ARB90, TS91, LG95] </ref> addresses a special class of densely occluded environments where there are plenty of cell and portal structures, as in an in-door architectural model. [ARB90, TS91] pre-precesses the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the pre-processing. <p> to Object Space Algorithms Work on cells and portals [ARB90, TS91, LG95] addresses a special class of densely occluded environments where there are plenty of cell and portal structures, as in an in-door architectural model. [ARB90, TS91] pre-precesses the model to identify potentially visible set of primitives for each cell. <ref> [LG95] </ref> developed a dynamic version which eliminates the pre-processing. These methods works very well for the particular environment, but are not applicable to models without cell/portal structures. Our algorithm works without modification for environments with cells and portals, but occluder selection can be optimized for these environments.
Reference: [McK87] <author> M. McKenna. </author> <title> Worst-case optimal hidden-surface removal. </title> <journal> ACM Trans. Graph., </journal> <volume> 6 </volume> <pages> 19-28, </pages> <year> 1987. </year>
Reference-contexts: Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal <ref> [Mul89, McK87] </ref>. See [Dor94] for a recent survey. However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80].
Reference: [Mul89] <author> K. Mulmuley. </author> <title> An efficient algorithm for hidden surface removal. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 379-388, </pages> <year> 1989. </year> <month> 21 </month>
Reference-contexts: Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal <ref> [Mul89, McK87] </ref>. See [Dor94] for a recent survey. However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80].
Reference: [Nay92] <author> B. Naylor. </author> <title> Partitioning tree imge representation and generation from 3d geometric models. </title> <booktitle> In Proc. of Graphics Interface, </booktitle> <pages> pages 201-12, </pages> <year> 1992. </year>
Reference-contexts: Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80]. The tree construction may involve considerable preprocessing in terms of time and space requirements for large models. In <ref> [Nay92] </ref>, Naylor has given an output-sensitive visibility algorithm using BSPs. It uses a 2D BSP tree to represent images and presents an algorithm to project a 3D BSP tree, representing the model in object space, into a 2D BSP tree representing its image.
Reference: [RH94] <author> J. Rohlf and J. Helman. Iris performer: </author> <title> A high performance multiprocessor toolkit for realtime 3d graphics. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 381-394, </pages> <year> 1994. </year>
Reference-contexts: A number of techniques for interactive walkthrough of large geometric databases have been proposed. Refer to [Br96] for a recent survey. A number of commercial systems like Performer <ref> [RH94] </ref>, used for high performance graphics, and Brush [SBM + 94], used for visualizing architectural and CAD models, are available. They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models.
Reference: [SBM + 94] <author> B. Schneider, P. Borrel, J. Menon, J. Mittleman, and J. Rossignac. </author> <title> Brush as a walkthrough system for architectural models. </title> <booktitle> In Fifth Eurographics Workshop on Rendering, </booktitle> <pages> pages 389-399, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: A number of techniques for interactive walkthrough of large geometric databases have been proposed. Refer to [Br96] for a recent survey. A number of commercial systems like Performer [RH94], used for high performance graphics, and Brush <ref> [SBM + 94] </ref>, used for visualizing architectural and CAD models, are available. They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models.
Reference: [SDS96] <author> E. Stollnitz, T. Derose, and D. Salesin. </author> <title> Wavelets for Computer Graphics. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1996. </year>
Reference-contexts: The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z-pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition <ref> [GBR91, SDS96] </ref>. 3 Overview In this paper we present a conservative solution to the visibility problem. Given a scene database and a viewpoint, our algorithm culls a subset of the objects not visible.
Reference: [SG96] <author> O. Sudarsky and C. Gotsman. </author> <title> Output sensitive visibility algorithms for dynamic scenes with applications to virtual reality. </title> <journal> Computer Graphics Forum, </journal> <volume> 15(3) </volume> <pages> 249-58, </pages> <year> 1996. </year> <note> Proc. of Eurographics'96. </note>
Reference-contexts: It uses an image hierarchy named a "coverage pyramid" for visibility culling. Traversing polygons from front to back, it can process densely occluded scenes efficiently and is well suited to anti-aliasing by oversampling and filtering. For dynamic environments, Sudarsky and Gotsman <ref> [SG96] </ref> have presented an output-sensitive algorithm which minimizes the time required to update the hierarchical data structure for a dynamic object and minimize the number of dynamic objects for which the structure has to be updated. A number of techniques for interactive walkthrough of large geometric databases have been proposed.
Reference: [Tel92] <author> S. J. Teller. </author> <title> Visibility Computations in Densely Occluded Polyheral Environments. </title> <type> PhD thesis, </type> <institution> CS Division, UC Berkeley, </institution> <year> 1992. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives [ARB90, TS91, LG95]. In particular, Teller et al. <ref> [TS91, Tel92, TH93] </ref> have presented analytic algorithms for cell-to-cell visibility and also applied them to efficient calculation of form factors for ra-diosity.
Reference: [TH93] <author> S. Teller and P. Hanrahan. </author> <title> Global visibility algorithms for illumination computations. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 239-246, </pages> <year> 1993. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives [ARB90, TS91, LG95]. In particular, Teller et al. <ref> [TS91, Tel92, TH93] </ref> have presented analytic algorithms for cell-to-cell visibility and also applied them to efficient calculation of form factors for ra-diosity.
Reference: [TP75] <author> S. Tanimoto and T. Pavlidis. </author> <title> A hierarchical data structure for picture processing. </title> <journal> Computer Graphics and Image Processing, </journal> <volume> 4(2) </volume> <pages> 104-119, </pages> <year> 1975. </year>
Reference-contexts: They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids <ref> [TP75] </ref>, MIP maps [Wil83], Z-pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition [GBR91, SDS96]. 3 Overview In this paper we present a conservative solution to the visibility problem. Given a scene database and a viewpoint, our algorithm culls a subset of the objects not visible.
Reference: [TS91] <author> S. Teller and C.H. Sequin. </author> <title> Visibility preprocessing for interactive walk-throughs. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 61-69, </pages> <year> 1991. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives <ref> [ARB90, TS91, LG95] </ref>. In particular, Teller et al. [TS91, Tel92, TH93] have presented analytic algorithms for cell-to-cell visibility and also applied them to efficient calculation of form factors for ra-diosity. <p> Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives [ARB90, TS91, LG95]. In particular, Teller et al. <ref> [TS91, Tel92, TH93] </ref> have presented analytic algorithms for cell-to-cell visibility and also applied them to efficient calculation of form factors for ra-diosity. <p> If a model under some the viewing conditions does not have sufficient occlusion, the overall frame rate may decrease due to the overhead, in which case occlusion culling should be turned off. 17 7.1 Comparison to Object Space Algorithms Work on cells and portals <ref> [ARB90, TS91, LG95] </ref> addresses a special class of densely occluded environments where there are plenty of cell and portal structures, as in an in-door architectural model. [ARB90, TS91] pre-precesses the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the pre-processing. <p> to the overhead, in which case occlusion culling should be turned off. 17 7.1 Comparison to Object Space Algorithms Work on cells and portals [ARB90, TS91, LG95] addresses a special class of densely occluded environments where there are plenty of cell and portal structures, as in an in-door architectural model. <ref> [ARB90, TS91] </ref> pre-precesses the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the pre-processing. These methods works very well for the particular environment, but are not applicable to models without cell/portal structures.
Reference: [War69] <author> J. Warnock. </author> <title> A hidden-surface algorithm for computer generated half-tone pictures. </title> <type> Technical Report TR 4-15, </type> <institution> NTIS AD-753 671, Department of Computer Science, University of Utah, </institution> <year> 1969. </year>
Reference-contexts: Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms <ref> [War69, FDHF90] </ref>. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87]. See [Dor94] for a recent survey. However, the practical utility of these algorithms is unclear at the moment.
Reference: [Wil83] <editor> L. Williams. Pyramidal parametrics. </editor> <booktitle> ACM Computer Graphics, </booktitle> <pages> pages 1-11, </pages> <year> 1983. </year>
Reference-contexts: They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps <ref> [Wil83] </ref>, Z-pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition [GBR91, SDS96]. 3 Overview In this paper we present a conservative solution to the visibility problem. Given a scene database and a viewpoint, our algorithm culls a subset of the objects not visible.
Reference: [YR96] <author> R. Yagel and W. Ray. </author> <title> Visibility computations for efficient walkthrough of complex environments. </title> <journal> Presence, </journal> <volume> 5(1) </volume> <pages> 1-16, </pages> <year> 1996. </year> <title> 22 show the improvement in frame rate and the right graphs show the percentage of model culled. The statistics were gathered over a path for each model. 23 time to render each model without HOM culling is normalized to 100%. Each bar shows the percentage of time spent in different stages of our algorithm. culling algorithm is about five. 24 count is 986,800. The HOM algorithm achieves 4-5 times speed-up. 25 polygons. Average speed-up is about two due to occlusion culling. </title> <type> 26 </type>
Reference-contexts: It is not apparent that cell-based approaches can be generalized to an arbitrary model. Other algorithms for densely-occluded but somewhat less-structured models have been proposed by Yagel and Ray <ref> [YR96] </ref>. They used regular spatial subdivision to partition the model into cells and describe a 2D implementation. However, the resulting algorithm is very memory-intensive and does not scale well to large models.
References-found: 35

