URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/FTCS-96-VLSI.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Email: akella@ece.ucdavis.edu  vaidya@cs.tamu.edu  redinbo@ece.ucdavis.edu  
Title: Limitations of VLSI Implementation of Delay-Insensitive Codes  
Author: Venkatesh Akella Nitin H. Vaidya G. Robert Redinbo 
Address: Davis, CA 95616  College Station, TX 77843-3112  Davis, CA 95616  
Affiliation: ECE Department University of California  Computer Science Department Texas A&M University  ECE Department University of California  
Abstract: Implementation of delay-insensitive (DI) or unordered codes is the subject of this paper. We present two different architectures for decoding systematic DI codes: (a) enumeration-based decoder, and (b) comparison-based decoder. We argue that enumeration-based decoders are often impractical for many realistic codes. Comparison-based decoders that detect arrival of a code word by comparing the received checkbits with checkbits evaluated using the received data are practical but suffer from the following limitation. If the decoder is to be implemented using asynchronous logic, i.e., if the gate and wire delays are arbitrary (unbounded but finite), then it is impossible to design a comparison-based decoder for any code that is more efficient than a dual-rail code. In other words, the encoded word must contain at least twice as many bits as the data. The paper shows that comparison-based decoders for codes that have the requisite level of redundancy can be implemented using asynchronous logic. The paper also shows that, by relaxing the delay assumptions, it is possible to implement decoders for delay-insensitive codes that are more efficient than dual-rail codes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. M. Berger. </author> <title> A Note on Error Detection Codes for Asymmetric Channels. </title> <journal> Information and Control, </journal> <volume> 4 </volume> <pages> 68-73, </pages> <year> 1961. </year>
Reference-contexts: Finally, we present some practical constraints on circuit delays under which comparison-based decoders could be implemented for codes with smaller redundancy than dual-rail codes. We illustrate this with the implementation of a Berger code <ref> [1] </ref>. The paper is organized as follows. Section 2 discusses our system model. Section 3 discusses the various decoder architectures and their implementation details. Section 4 shows that codes that are not as redundant as dual-rail codes cannot be implemented. <p> The decoder must be hazard-free, otherwise, it may indicate that a code word has been received when the received word, in fact, is not a code word. Consider the (4,2) Berger code <ref> [1] </ref> with 2 data bits (k=2) and 2 checkbits (r=2). The four code words in the (4,2) Berger code are: d1 d0 c1 c0 0 1 0 1 1 1 0 0 where (d1,d0) are the data bits and (c1,c0) are the checkbits.
Reference: [2] <author> M. Blaum, </author> <title> editor. Codes for Detecting and Correcting Unidirectional Errors. </title> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors <ref> [2] </ref>. Application of such codes to asynchronous buses has also been explored [3, 15, 5, 4, 19]. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> While we focus on asynchronous communication as the application of unordered [6] or delay-insensitive codes, the results of this paper have implications for all applications of such codes. This paper deals with design of asynchronous decoders for codes used for communication on asynchronous buses. Past work on decoders <ref> [2] </ref> implicitly assumes synchronous hardware implementation of the decoder. There are at least two reasons why the study of asynchronous decoders is important. First, recently there have been promising results on asynchronous implementation of VLSI systems for high-performance and low-power applications [17, 13, 8]. <p> When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property [19]. Verhoeff [19], Varshavsky [18] and Blaum <ref> [2] </ref> discuss many DI codes and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this paper. We first describe a communication protocol called the four-phase protocol [11] for the exchange of data on an asynchronous bus.
Reference: [3] <author> M. Blaum and J. Bruck. </author> <title> Unordered error-correcting codes and their applications. </title> <booktitle> In Digest of papers: The 22 th Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pages 486-493, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 15, 5, 4, 19] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> Some codes for correcting different types of errors and skews on asynchronous buses have also been proposed (e.g., <ref> [3] </ref>). However, the past work has not explored the issues in VLSI implementations of decoders for the proposed codes. While we focus on asynchronous communication as the application of unordered [6] or delay-insensitive codes, the results of this paper have implications for all applications of such codes. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered <ref> [6, 3, 5] </ref> or delay-insensitive [19]. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C.
Reference: [4] <author> M. Blaum and J. Bruck. </author> <title> Coding for Skew-Tolerant Parallel Asynchronous Communications. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 39(2) </volume> <pages> 379-388, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 15, 5, 4, 19] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> This is not always consistent with the idea of delay-insensitive communication on asynchronous buses in applications such as those reported in <ref> [5, 4] </ref>. As noted above, unordered codes have been proposed for two types of problems: (i) detection of ar rival of data on the asynchronous bus, (ii) detection and correction of various types of errors on the asynchronous bus. <p> Our model is very simple and does not include the idea of pipelined data communication that was proposed by Blaum and Bruck <ref> [4, 5] </ref>. 3 Decoder Architectures Assume that the code being used is an (n; k) systematic unordered code. Thus, each code word contains k data bits, and r = n k checkbits.
Reference: [5] <author> M. Blaum and J. Bruck. </author> <title> Delay-Insensitive Pipelined Communication on Parallel Buses. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(5) </volume> <pages> 660-668, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 15, 5, 4, 19] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> This is not always consistent with the idea of delay-insensitive communication on asynchronous buses in applications such as those reported in <ref> [5, 4] </ref>. As noted above, unordered codes have been proposed for two types of problems: (i) detection of ar rival of data on the asynchronous bus, (ii) detection and correction of various types of errors on the asynchronous bus. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered <ref> [6, 3, 5] </ref> or delay-insensitive [19]. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C. <p> Our model is very simple and does not include the idea of pipelined data communication that was proposed by Blaum and Bruck <ref> [4, 5] </ref>. 3 Decoder Architectures Assume that the code being used is an (n; k) systematic unordered code. Thus, each code word contains k data bits, and r = n k checkbits.
Reference: [6] <author> B. Bose. </author> <title> On Unordered Codes. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40 </volume> <pages> 125-131, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Some codes for correcting different types of errors and skews on asynchronous buses have also been proposed (e.g., [3]). However, the past work has not explored the issues in VLSI implementations of decoders for the proposed codes. While we focus on asynchronous communication as the application of unordered <ref> [6] </ref> or delay-insensitive codes, the results of this paper have implications for all applications of such codes. This paper deals with design of asynchronous decoders for codes used for communication on asynchronous buses. Past work on decoders [2] implicitly assumes synchronous hardware implementation of the decoder. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered <ref> [6, 3, 5] </ref> or delay-insensitive [19]. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C.
Reference: [7] <author> E. B. Eichelberger. </author> <title> Hazard Detection in Combinational and Sequential Switching Circuits. </title> <journal> IBM Journal of Research, </journal> (9):90-99, mar 1965. 
Reference-contexts: of the decoder that produces a 1 on receiving a code word and a 0 otherwise would result in glitches (hazards) at the output of the decoder due to unpredictable order of the arrival of the bits and the distribution of delays in the gates and wires inside the decoder <ref> [7, 16] </ref>. This is not acceptable because we expect the decoder output to go to 1 only if we receive a code word. However, we can take advantage of the four-phase protocol to implement the circuit in a hazard-free manner as follows.
Reference: [8] <author> S. Furber. </author> <title> Computing without Clocks: Micropipelin-ing the ARM Processor. </title> <editor> In G. Birtwistle and A. Davis, editors, </editor> <booktitle> Asynchronous Digital Circuit Design, </booktitle> <pages> pages 211-262. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Past work on decoders [2] implicitly assumes synchronous hardware implementation of the decoder. There are at least two reasons why the study of asynchronous decoders is important. First, recently there have been promising results on asynchronous implementation of VLSI systems for high-performance and low-power applications <ref> [17, 13, 8] </ref>. Such processors have many potential applications, for instance, in mobile and wireless computing and communication. This calls for schemes to implement delay-insensitive communication between various sub-modules efficiently without the use of global clocking, under various gate and wire delay models.
Reference: [9] <author> Z. Kohavi. </author> <title> Switching and Finite Automata Theory. </title> <publisher> Tata McGraw-Hill, </publisher> <year> 1978. </year> <note> Chapter 4 and Chapter 6. </note>
Reference-contexts: positive and unate in all the variables: A function g (x 1 ; x 2 ; : : : ; x n ) is said to be unate with respect to a variable x i if only x i or its complement x i appears in g but not both <ref> [9] </ref>. A function g is said to be positive with respect to a variable x i if only the literal x i appears in g. (2) f is hazard-free for all the allowable transitions under the four-phase protocol that is being used in this discussion. <p> of only AND and OR gates, and the output of an AND gate remains at zero till all its inputs are 1 all inputs of an AND gate become 1 only when the corresponding code word is received. (3) It can be shown that the minimal sum-of-products expression is unique <ref> [9] </ref> which means that all the prime-implicants are essential. So, f is the minimal hazard-free sum-of-products (SOP) realization of the enumeration-based de coder for (4,2) Berger code. Therefore, f cannot be minimized any further in terms of a two-level logic implementation.
Reference: [10] <author> A. J. Martin. </author> <title> The Limitations to Delay-insensitivity in Asynchronous Circuits. </title> <booktitle> In Advanced Research in VLSI : Proceedings of the Sixth MIT Conference. </booktitle> <publisher> MIT Press, </publisher> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: It follows that, c 1 = d 1 and c 0 = d 0 . d 1 d 0 c 1 c 0 0 1 1 0 1 1 0 0 the decoder. The gate marked C denotes a Muller C-element <ref> [11, 10] </ref>. It is a special latch which has the following behavior. <p> An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption <ref> [13, 10, 14] </ref> and the speed-independent circuit theory [12]. Acknowledgements The authors thank Janlung Sung for helpful discussions during the early part of this research.
Reference: [11] <author> C. A. Mead and L. Conway. </author> <title> An Introduction to VLSI Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1980. </year> <note> Chapter 7, entitled "System Timing". </note>
Reference-contexts: Verhoeff [19], Varshavsky [18] and Blaum [2] discuss many DI codes and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this paper. We first describe a communication protocol called the four-phase protocol <ref> [11] </ref> for the exchange of data on an asynchronous bus. Then we define two possible architectures for the decoders. The first is called enumeration-based decoder which examines the entire code word and determines if it is valid or not. It basically implements the membership-test using combinational logic. <p> Data communication in an asynchronous system is accomplished by a handshake protocol <ref> [11] </ref>. There are two popular handshake protocols: the four-phase (or return-to-zero) protocol and the two-phase (or non-return-to-zero) protocol. We will use the four-phase handshake protocol in this study. <p> The dual-rail code is commonly used in asynchronous systems, and for this code k = r. Our design is very similar to the implementations found in asynchronous literature <ref> [11, 13] </ref>. Without loss of generality, let us assume that the number of data bits is 2. Therefore, r = k = 2. The table below shows the code words where d 1 and d 0 are data bits and c 1 and c 0 are check-bits. <p> It follows that, c 1 = d 1 and c 0 = d 0 . d 1 d 0 c 1 c 0 0 1 1 0 1 1 0 0 the decoder. The gate marked C denotes a Muller C-element <ref> [11, 10] </ref>. It is a special latch which has the following behavior.
Reference: [12] <author> R. E. Miller. </author> <title> Switching Theory Volume II: Sequential Circuits and Machines. </title> <publisher> John Wiley & Sons, </publisher> <year> 1965. </year> <title> Chapter 10: Speed Independent Switching Circuit Theory. </title>
Reference-contexts: An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption [13, 10, 14] and the speed-independent circuit theory <ref> [12] </ref>. Acknowledgements The authors thank Janlung Sung for helpful discussions during the early part of this research.
Reference: [13] <author> T. Nanya, Y. Ueno, H. Kayotomi, M. Kuwako, and A. Takamura. TITAC: </author> <title> Design of a Quasi-Delay-Insensitive Microprocessor. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 11(2) </volume> <pages> 50-63, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Past work on decoders [2] implicitly assumes synchronous hardware implementation of the decoder. There are at least two reasons why the study of asynchronous decoders is important. First, recently there have been promising results on asynchronous implementation of VLSI systems for high-performance and low-power applications <ref> [17, 13, 8] </ref>. Such processors have many potential applications, for instance, in mobile and wireless computing and communication. This calls for schemes to implement delay-insensitive communication between various sub-modules efficiently without the use of global clocking, under various gate and wire delay models. <p> The dual-rail code is commonly used in asynchronous systems, and for this code k = r. Our design is very similar to the implementations found in asynchronous literature <ref> [11, 13] </ref>. Without loss of generality, let us assume that the number of data bits is 2. Therefore, r = k = 2. The table below shows the code words where d 1 and d 0 are data bits and c 1 and c 0 are check-bits. <p> An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption <ref> [13, 10, 14] </ref> and the speed-independent circuit theory [12]. Acknowledgements The authors thank Janlung Sung for helpful discussions during the early part of this research.
Reference: [14] <author> S. J. Piestrak and T. Nanya. </author> <title> Towards totally self-checking delay-insensitive systems. </title> <booktitle> In Digest of papers: The 25 th Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pages 228-237, </pages> <year> 1995. </year>
Reference-contexts: An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption <ref> [13, 10, 14] </ref> and the speed-independent circuit theory [12]. Acknowledgements The authors thank Janlung Sung for helpful discussions during the early part of this research.
Reference: [15] <author> L. Tallini, L. Merani, and B. Bose. </author> <title> Balanced codes for noise reductionin VLSI systems. </title> <booktitle> In Digest of papers: The 24 th Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pages 212-218, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 15, 5, 4, 19] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable.
Reference: [16] <author> S. H. Unger. </author> <title> Asynchronous Sequential Switching Circuits. </title> <publisher> Wiley-Interscience, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: of the decoder that produces a 1 on receiving a code word and a 0 otherwise would result in glitches (hazards) at the output of the decoder due to unpredictable order of the arrival of the bits and the distribution of delays in the gates and wires inside the decoder <ref> [7, 16] </ref>. This is not acceptable because we expect the decoder output to go to 1 only if we receive a code word. However, we can take advantage of the four-phase protocol to implement the circuit in a hazard-free manner as follows.
Reference: [17] <author> K. van Berkel, R. Burges, J. Kessels, M. Roncken, F. Schalij, and A. Peeters. </author> <title> Asynchronous Circuits for Low Power: A DCC Error Corrector. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 11(2) </volume> <pages> 22-32, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Past work on decoders [2] implicitly assumes synchronous hardware implementation of the decoder. There are at least two reasons why the study of asynchronous decoders is important. First, recently there have been promising results on asynchronous implementation of VLSI systems for high-performance and low-power applications <ref> [17, 13, 8] </ref>. Such processors have many potential applications, for instance, in mobile and wireless computing and communication. This calls for schemes to implement delay-insensitive communication between various sub-modules efficiently without the use of global clocking, under various gate and wire delay models.
Reference: [18] <author> V. Varshavsky, M. Kishnivsky, V. Markhovsky, V. Peschansky, L. Rosenblum, A. Taubin, and B. Tzirlin. </author> <title> Self-Timed Control of Concurrent Processes. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1990. </year>
Reference-contexts: When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property [19]. Verhoeff [19], Varshavsky <ref> [18] </ref> and Blaum [2] discuss many DI codes and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this paper. We first describe a communication protocol called the four-phase protocol [11] for the exchange of data on an asynchronous bus.
Reference: [19] <author> T. Verhoeff. </author> <title> Delay-insensitive codes an overview. </title> <journal> Distributed Computing, </journal> (3):1-8, 1988. 
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 15, 5, 4, 19] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> been shown to be equivalent to fl Research reported in this paper is supported in part by National Science Foundation grants MIP-930868 at UC Davis and MIP-9423735 at Texas A&M University, and Texas Advanced Technology Program grant 009741-052-C. the problem of designing unordered or all unidirectional error detecting (AUED) codes <ref> [19] </ref> such codes are also useful for unidirectional and asymmetric error control. Some codes for correcting different types of errors and skews on asynchronous buses have also been proposed (e.g., [3]). However, the past work has not explored the issues in VLSI implementations of decoders for the proposed codes. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered [6, 3, 5] or delay-insensitive <ref> [19] </ref>. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C. A code word u 2 C is said to be contained in a code word v 2 C, if v has a 1 in each position where u has a 1. <p> When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property <ref> [19] </ref>. Verhoeff [19], Varshavsky [18] and Blaum [2] discuss many DI codes and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this paper. <p> When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property <ref> [19] </ref>. Verhoeff [19], Varshavsky [18] and Blaum [2] discuss many DI codes and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this paper. <p> At the start of the four phase protocol, the initial values are ack = 0 and B = (000...0). All-0 bus, B = (000...0), is known as the spacer <ref> [19] </ref>. The four-phase protocol has the following four steps (hence the name). (1) Block S (sender) encodes the data and transmits the code word on the asynchronous bus B.
References-found: 19

