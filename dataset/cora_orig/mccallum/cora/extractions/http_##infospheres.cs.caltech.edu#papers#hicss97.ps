URL: http://infospheres.cs.caltech.edu/papers/hicss97.ps
Refering-URL: http://infospheres.cs.caltech.edu/papers/index.html
Root-URL: http://www.cs.caltech.edu
Email: fadam,manig@cs.caltech.edu  
Title: Systematic Composition of Objects in Distributed Internet Applications: Processes and Sessions  
Author: K. Mani Chandy and Adam Rifkin 
Address: Pasadena, California 91125  
Affiliation: Computer Science 256-80 California Institute of Technology  
Abstract: We consider a system with the infrastructure for the creation and interconnection of large numbers of distributed persistent objects. This system is exemplified by the Internet: potentially, every appliance and document on the Internet has both persistent state and the ability to interact with large numbers of other appliances and documents on the Internet. This paper elucidates the characteristics of such a system, and proposes the compositional requirements of its corresponding infrastructure. We explore the problems of specifying, composing, reasoning about, and implementing applications in such a system. A specific concern of our research is developing the infrastructure to support structuring distributed applications by using sequential, choice, and parallel composition, in the anarchic environment where application compositions may be unforeseeable, and interactions may be unknown prior to actually occurring. The structuring concepts discussed are relevant to a wide range of distributed applications; our implementation is illustrated with collaborative Java processes interacting over the Internet, but the methodology provided can be applied independent of specific platforms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: In the structured examples, an application program can be partitioned into components in systematic ways. The computer science community has discovered methodical ways of dividing a task into components, and composing those components using sequential, choice, and parallel composition (c.f., <ref> [1, 2] </ref>). In the anarchic case, the components are given, and the task is to compose them to achieve some end. The application developer needs to determine whether components have compatible interfaces, and whether the components can be composed in a meaningful way. <p> We propose two kinds of compositional units, processes and sessions, and demonstrate properties of these units in the context of other work done on the theory of composition. Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic <ref> [1, 3] </ref>. Sessions are collections of processes composed in parallel [4, 5]. A session is specified in terms of the precondition and postcondi-tion predicates [6] of its component processes. <p> Even if the entire process state is not externally visible, some predicates on the state (which can be defined as "thought" or auxiliary variables) are visible. Process specifications are given in terms of safety properties (e.g., next, stable, and invariant) and progress properties (defined using leads-to) <ref> [1, 3, 19] </ref>. <p> These services are described in detail in [20]. 4 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [21], distributed languages [22], and distributed algorithms <ref> [1, 23] </ref>. Our programming model and theories of structured composition build on this research and recent work in formal methods [7, 2, 4, 5, 3, 19].
Reference: [2] <author> K.M. Chandy and S. Taylor. </author> <title> An Introduction to Parallel Programming. </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, MA, </address> <year> 1992. </year>
Reference-contexts: In the structured examples, an application program can be partitioned into components in systematic ways. The computer science community has discovered methodical ways of dividing a task into components, and composing those components using sequential, choice, and parallel composition (c.f., <ref> [1, 2] </ref>). In the anarchic case, the components are given, and the task is to compose them to achieve some end. The application developer needs to determine whether components have compatible interfaces, and whether the components can be composed in a meaningful way. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [7, 2, 4, 5, 3, 19] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [8], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [3] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year> <note> Also available as DEC SRC Research Report 79. </note>
Reference-contexts: We propose two kinds of compositional units, processes and sessions, and demonstrate properties of these units in the context of other work done on the theory of composition. Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic <ref> [1, 3] </ref>. Sessions are collections of processes composed in parallel [4, 5]. A session is specified in terms of the precondition and postcondi-tion predicates [6] of its component processes. <p> Even if the entire process state is not externally visible, some predicates on the state (which can be defined as "thought" or auxiliary variables) are visible. Process specifications are given in terms of safety properties (e.g., next, stable, and invariant) and progress properties (defined using leads-to) <ref> [1, 3, 19] </ref>. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [7, 2, 4, 5, 3, 19] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [8], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [4] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year> <note> Also available as DEC SRC Research Report 66. </note>
Reference-contexts: Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic [1, 3]. Sessions are collections of processes composed in parallel <ref> [4, 5] </ref>. A session is specified in terms of the precondition and postcondi-tion predicates [6] of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [7]. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [7, 2, 4, 5, 3, 19] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [8], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [5] <author> K.M. Chandy. </author> <title> Properties of concurrent programs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6) </volume> <pages> 607-619, </pages> <year> 1994. </year>
Reference-contexts: Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic [1, 3]. Sessions are collections of processes composed in parallel <ref> [4, 5] </ref>. A session is specified in terms of the precondition and postcondi-tion predicates [6] of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [7]. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [7, 2, 4, 5, 3, 19] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [8], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [6] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> Oc-tober </month> <year> 1969. </year>
Reference-contexts: Processes can be composed in parallel, and we reason about processes using theories of parallel composition in temporal logic [1, 3]. Sessions are collections of processes composed in parallel [4, 5]. A session is specified in terms of the precondition and postcondi-tion predicates <ref> [6] </ref> of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [7]. Distributed applications can be structured by nesting processes and sessions, and our software infrastructure [8] supports such capability.
Reference: [7] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Sessions are collections of processes composed in parallel [4, 5]. A session is specified in terms of the precondition and postcondi-tion predicates [6] of its component processes. Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming <ref> [7] </ref>. Distributed applications can be structured by nesting processes and sessions, and our software infrastructure [8] supports such capability. Composing Distributed Objects on the Internet. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [7, 2, 4, 5, 3, 19] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [8], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [8] <author> K.M. Chandy, A. Rifkin, P.A.G. Sivilotti, J. Mandelson, M. Richardson, W. Tanaka, and L. Weisman. </author> <title> A worldwide distributed system using java and the internet. </title> <booktitle> In Proceedings of the Fifth Workshop on High Performance Distributed Computing, </booktitle> <address> Syracuse, NY, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Sessions can be composed using sequential and choice composition, and we reason about sessions using theory from the field of sequential programming [7]. Distributed applications can be structured by nesting processes and sessions, and our software infrastructure <ref> [8] </ref> supports such capability. Composing Distributed Objects on the Internet. We model every program, appliance, and document connected to the Internet with a state that is persistent for the lifetime of its corresponding entity, as shown in Figure 2. <p> We conjecture that our programming model could handle both client-server and peer-to-peer interactions, though the focus in this paper is on peer-to-peer communication. Implemented Infrastructure. Our Caltech group is designing and implementing an infrastructure <ref> [8] </ref> based on the models and theories of structured composition discussed in this paper. The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java [9], TCP/IP [10], and the World Wide Web [11]. <p> A set of processes is associated with each input queue, only the output queues of these processes can be bound to the input queue. In our implementation, this condition is ensured by the binding mechanism provided by our infrastructure <ref> [8] </ref>. Thus, the infrastructure facilitates control of messages that can be delivered to the input queue of a process. For instance, an input queue may restrict the binding to it to only allow "manager" processes. This set of processes is specified either as an enumerated list or by attributes. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods [7, 2, 4, 5, 3, 19]. To supplement our model, we are designing and implementing a communication infrastructure <ref> [8] </ref>, in which processes can be written as multithreaded Java objects called dapplets. Using the compositional theory described in this paper, dapplets can be composed into sessions, wherein the states of the component dapplets can be modified in a peer-to-peer fashion through transactions. <p> provide formally verified reliable libraries for synchronization between threads (e.g., single-assignment variables, reusable barriers, locks, and semaphores, as specified in [15]), and will be working on formally verified reliable libraries pro viding services for use in sessions (e.g., tokens, clocks, distributed data structures, and stack layering facilities, as specified in <ref> [8] </ref>). Our implementation shares many design features of network objects [24], including distributed typecheck-ing, transparent remote invocation, marshaling, and buffered streams.
Reference: [9] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. Addison-Wesley Developers Press, Sunsoft Java Series, </title> <year> 1996. </year>
Reference-contexts: Our Caltech group is designing and implementing an infrastructure [8] based on the models and theories of structured composition discussed in this paper. The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java <ref> [9] </ref>, TCP/IP [10], and the World Wide Web [11]. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system.
Reference: [10] <author> W.R. Stevens. </author> <title> TCP/IP Illustrated, Volume 1: The Protocols. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java [9], TCP/IP <ref> [10] </ref>, and the World Wide Web [11]. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system.
Reference: [11] <author> T. Berners-Lee, R. Cailliau, J. Groff, and B. Pollermann. </author> <title> World wide web: The information universe. </title> <journal> Electronic Networking: Research, Applications, and Policy, </journal> <volume> 1(2), </volume> <year> 1992. </year>
Reference-contexts: The infrastructure allows application developers to design and implement collaborative processes and sessions over the Internet. Our implementation uses standard platforms that are widely available: Java [9], TCP/IP [10], and the World Wide Web <ref> [11] </ref>. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system.
Reference: [12] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification (CORBA). OMG, </title> <booktitle> 1995. Revision 2.0. </booktitle>
Reference-contexts: Our implementation uses standard platforms that are widely available: Java [9], TCP/IP [10], and the World Wide Web [11]. The focus of our research, however, is on basic ideas about composition applicable to any collaborative distributed system. As discussed in Section 4, CORBA <ref> [12] </ref> can be employed to obtain a more elegant implementation, but our current system does not use this technology. 2 The Structure of Collaborative Ap- plications This section elaborates on the basic objects for composition introduced in Section 1.2: processes and sessions. <p> Although our dapplet support for collaborative distributed application development was implemented using Java, the theories and tools for composition we propose are employable in conjunction with other platforms, such as CORBA-compliant Object Request Brokers <ref> [12] </ref>. CORBA is a language-independent industry standard for remote invocation; through Object Request Brokers, objects in one location in a network can invoke methods on other objects in the network in a location-independent manner.
Reference: [13] <author> J.B. Postel. </author> <title> User Datagram Protocol. </title> <type> RFC 768, </type> <month> August </month> <year> 1980. </year>
Reference-contexts: The state can be changed only by servicing requests received from other processes. From an implementation standpoint, each process is a multithreaded persistent Java object that can communicate with other processes using UDP <ref> [13] </ref>. Requests to Modify State. A process cannot modify the state of another process directly; however, a process P can request a process Q, that Q modify its state in a manner prescribed by P , as illustrated in Figure 3.
Reference: [14] <author> A.D. Birrell and B.J. Nelson. </author> <title> Implementing remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Therefore, the delay between sending a message and the eventual response to the message can vary a great deal. For this reason, asynchronous buffered message-passing mechanisms are used, as illustrated in Figure 3. Therefore, the underlying communication mechanism is not a synchronized remote procedure call (RPC) <ref> [14] </ref>; a process P cannot modify Q's state by executing an RPC on Q. Rather, a process P can send a message to Q requesting that Q execute an asynchronous (i.e., one-way) RPC, and this message is placed in one of process Q's incoming message queues. <p> Putting the concepts discussed in this paper into the distributed object context, processes are objects that interact using remote procedure calls <ref> [14] </ref>, and the interfaces through which they receive messages are the public interfaces they export. Sessions are conglomerations of interacting objects; such object interface definitions are part of the CORBA standard, which defines an implementation language-independent in-terface definition language.
Reference: [15] <author> P.A.G. Sivilotti and K.M. Chandy. </author> <title> Toward high confidence distributed programming with java: Reliable thread libraries. </title> <booktitle> In International Conference on Software Engineering, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages <ref> [15] </ref>, analyzing application performance [16], and reasoning about parallel programs [17, 18], but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes. <p> We provide formally verified reliable libraries for synchronization between threads (e.g., single-assignment variables, reusable barriers, locks, and semaphores, as specified in <ref> [15] </ref>), and will be working on formally verified reliable libraries pro viding services for use in sessions (e.g., tokens, clocks, distributed data structures, and stack layering facilities, as specified in [8]).
Reference: [16] <author> A. Rifkin. </author> <title> Application development using analytic and experimental performance tuning. </title> <type> Technical Report CS-TR-96-09, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages [15], analyzing application performance <ref> [16] </ref>, and reasoning about parallel programs [17, 18], but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes.
Reference: [17] <author> J. Thornley. </author> <title> A Parallel Programming Model with Sequential Semantics. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages [15], analyzing application performance [16], and reasoning about parallel programs <ref> [17, 18] </ref>, but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes.
Reference: [18] <author> B.L. Massingill. </author> <title> Parallel Programming Archetypes in Scientific Computing. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: We do not restrict how a process handles messages or files. We are developing systematic ways for manipulating threads and messages [15], analyzing application performance [16], and reasoning about parallel programs <ref> [17, 18] </ref>, but these methods are not discussed in this paper. Process Persistence. If each appliance and document attached to the Internet is encapsulated within a process, a computer may have to support hundreds or thousands of persistent processes.
Reference: [19] <author> K.M. Chandy and B.A. Sanders. </author> <title> Predicate transformers for reasoning about concurrent computation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24(2) </volume> <pages> 129-147, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Even if the entire process state is not externally visible, some predicates on the state (which can be defined as "thought" or auxiliary variables) are visible. Process specifications are given in terms of safety properties (e.g., next, stable, and invariant) and progress properties (defined using leads-to) <ref> [1, 3, 19] </ref>. <p> Our programming model and theories of structured composition build on this research and recent work in formal methods <ref> [7, 2, 4, 5, 3, 19] </ref>. To supplement our model, we are designing and implementing a communication infrastructure [8], in which processes can be written as multithreaded Java objects called dapplets.
Reference: [20] <author> K.M. Chandy and A. Rifkin. </author> <title> Systematic composition of objects in distributed internet applications: Processes and sessions. </title> <type> Technical Report CS-TR-96-15, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: How those processes communicate and interact through the interface specifications of the input queues and output queues. 3. How those processes can be composed on a net work through the session specifications. Specifications are discussed in greater detail in <ref> [20] </ref>. Reasoning. Specifications allow application developers to reason about the correctness of their processes, interactions, and sessions. Correctness verification is achieved using preconditions and postcondi-tions, which are assertions on the states of program components before and after the execution of statements that cause a transition from one state to another. <p> Our infrastructure supports services to sessions, including tokens, logical clocks, distributed data structures, and process stack layering. In addition, our infrastructure supports session services for finding distributed objects, using URLs and type-based inheritance of interfaces. These services are described in detail in <ref> [20] </ref>. 4 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [21], distributed languages [22], and distributed algorithms [1, 23].
Reference: [21] <author> A.S. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1995. </year>
Reference-contexts: In addition, our infrastructure supports session services for finding distributed objects, using URLs and type-based inheritance of interfaces. These services are described in detail in [20]. 4 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems <ref> [21] </ref>, distributed languages [22], and distributed algorithms [1, 23]. Our programming model and theories of structured composition build on this research and recent work in formal methods [7, 2, 4, 5, 3, 19].
Reference: [22] <author> H.E. Bal, J.G. </author> <title> Steiner, and A.S. Tanenbaum. Programming languages for distributed computing systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 261-322, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In addition, our infrastructure supports session services for finding distributed objects, using URLs and type-based inheritance of interfaces. These services are described in detail in [20]. 4 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [21], distributed languages <ref> [22] </ref>, and distributed algorithms [1, 23]. Our programming model and theories of structured composition build on this research and recent work in formal methods [7, 2, 4, 5, 3, 19].
Reference: [23] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1996. </year>
Reference-contexts: These services are described in detail in [20]. 4 Related Work Research has yielded many theories, methods, and tools to help application developers use distributed systems [21], distributed languages [22], and distributed algorithms <ref> [1, 23] </ref>. Our programming model and theories of structured composition build on this research and recent work in formal methods [7, 2, 4, 5, 3, 19].
Reference: [24] <author> A. Birrell, G. Nelson, S. Owicki, </author> <title> and E.P. Wobber. Network objects. </title> <journal> Software Practice and Experience, </journal> <volume> 25(S4):87-130, </volume> <month> December </month> <year> 1995. </year> <note> Also available as DEC SRC Research Report 115. </note>
Reference-contexts: Our implementation shares many design features of network objects <ref> [24] </ref>, including distributed typecheck-ing, transparent remote invocation, marshaling, and buffered streams.
Reference: [25] <author> L. Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Many systems, including the Obliq distributed scripting language <ref> [25] </ref>, have been built using Modula-3 network objects. Obliq objects have state and are local to a site; Obliq enables a dynamic form of distributed programming, where objects can redirect their behavior over the network, and where computations can roam between network sites.
Reference: [26] <author> J.E. White. </author> <title> Telescript Technology: The Foundation for the Electronic Marketplace. General Magic, </title> <publisher> Inc, </publisher> <year> 1994. </year>
Reference-contexts: Obliq allows mobility of program code as well as the context in which the code operates; similarly, Tele-script <ref> [26] </ref> allows mobile agents that carry their context with them as they move from location to location. Whereas Obliq contexts can include established network connections, agents are self-contained and resource-limited: instead of communicating remotely with other locations, agents move themselves to a remote location site and communicate locally.
Reference: [27] <institution> ILU Group. </institution> <note> Inter-Language Unification. Xerox Parc, </note> <institution> Palo Alto, </institution> <address> CA, </address> <year> 1996. </year>
Reference-contexts: This interface definition provides a convenient framework in which to specify the behavior of services available to sessions as well. An example of a CORBA-like object system is the Inter-Language Unification (ILU) system <ref> [27] </ref>. The object interfaces provided by ILU hide implementation distinctions between different languages, between different address spaces, and between operating system types.
References-found: 27

