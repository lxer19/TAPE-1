URL: http://www.cs.msu.edu/~stire/thesis/Thesis.ps.gz
Refering-URL: http://www.cs.msu.edu/~stire/thesis/index.html
Root-URL: http://www.cs.msu.edu
Title: Automatic Generation of Interactive Systems from Declarative Models  
Author: R. E. Kurt Stirewalt 
Degree: A THESIS Presented to The Academic Faculty By  In Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy in Computer Science  
Date: December, 1997  
Affiliation: Georgia Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Gregory D. Abowd. </author> <title> Formal Aspects of Human-Computer Interaction. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <month> 6 </month> <year> 1991. </year>
Reference-contexts: An interesting application of the constraint view of decomposition comes in the definition of simultaneous constraints over control and data. Suffrin and He [93], for example, combine CSP constructs with the ability to precisely define states using Z [91] schemas. Abowd's agents <ref> [1, 2] </ref> use a similar mixing of CSP and Z to support usability analysis. 3.5 Virtual Machine Design Our strategy for designing the MDL virtual machine and the MMTK toolkit is a twist on what has become a popular idea.
Reference: [2] <author> Gregory D. Abowd and Alan J. Dix. </author> <title> Integrating status and event phenomena in formal specifications of interactive systems. </title> <booktitle> In Proceedings of the ACM SIGSOFT'94 Symposium on the Foundations of Software Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> 12 </month> <year> 1994. </year>
Reference-contexts: An interesting application of the constraint view of decomposition comes in the definition of simultaneous constraints over control and data. Suffrin and He [93], for example, combine CSP constructs with the ability to precisely define states using Z [91] schemas. Abowd's agents <ref> [1, 2] </ref> use a similar mixing of CSP and Z to support usability analysis. 3.5 Virtual Machine Design Our strategy for designing the MDL virtual machine and the MMTK toolkit is a twist on what has become a popular idea.
Reference: [3] <author> Gregory D. Abowd, Hung-Ming Wang, and Andrew F. Monk. </author> <title> A formal techniqe for automated dialogue development. </title> <editor> In Gary M. Olson and Sue Schuon, editors, </editor> <booktitle> Proceedings of the Symposium on Designing Interactive Systems: Processes, Practices, Methods & Techniques, </booktitle> <pages> pages 219-226. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1995. </year>
Reference: [4] <author> Heather Alexander. </author> <title> Structuring dialogues using csp. </title> <booktitle> In Formal Methods in Human-Computer Interaction[45], </booktitle> <pages> pages 273-295. </pages> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Zave argues that in such situations, conceptual structures other than the familiar inter-language procedure call are necessary for composition. The conceptual structure we used views the realization of different models as processes and their binding as synchronizing composition. In her work on the CSP specification of concurrent dialogue, Alexander <ref> [4] </ref> presents a technique for modularizing dialogue through synchronous parallel composition. In her examples, dialogue specifications are separated into presentation and application components which are specified independently and then combined using the k (parallel composition) operator.
Reference: [5] <author> Robert Allen and David Garlan. </author> <title> A formal basis for architectural connection. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(3) </volume> <pages> 213-248, </pages> <month> 7 </month> <year> 1997. </year>
Reference-contexts: Wing et al. also demonstrate the need for abstraction by applying model checking in a case study verifying the cache coherency protocol of a distributed file system [103]. Allen and Garlan <ref> [5] </ref> use the FDR [40] tool to check whether or not one CSP process is a refinement of another. In this thesis, we use the Symbolic Model Verifier (SMV)[66] from Carnegie Mellon University to verify the safe composition of our ordering components.
Reference: [6] <author> J. R. Anderson. </author> <title> The Architecture of Cognition. </title> <publisher> Harvard University Press, </publisher> <year> 1983. </year>
Reference-contexts: The controller C aggregates these sub-controllers and resolves their presentation/abstraction connection needs. It is claimed by Coutaz [29] that this distribution allows the structure of the software to better match the cognitive organization of human knowledge because it does not organize functionality into hermetic layers <ref> [6] </ref>. 42 Paterno's theory of interactors [80] adds precision and mathematical rigor to this connection-oriented view of interface composition. An interactor (not to be confused with the Amulet notion of an interactor) is a software component with a fixed set of incoming and outgoing data-flow paths.
Reference: [7] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: It is then up to the designer to add the behavior to the widgets. In the case of UIMX-generated code, this activity amounts to providing call-back functions which are invoked when the end user interacts with the widgets at run-time. With the emergence of the Java language <ref> [7] </ref> and user interface library AWT [43], palette-based presentation generators have become popular. These allow designers to rapidly construct presentations and then generate code which creates and initializes these presentations.
Reference: [8] <author> Joanne Atlee and John Gannon. </author> <title> State-based model checking of event driven systems requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3), </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: Recent work in symbolic model checking [21] utilizes an efficient representation of finite state spaces to make the checking of large models (on the order of 10 20 states) feasible. Model checking has been used to validate many types of software specifications. Atlee and Gannon <ref> [8] </ref> verify safety properties of requirements expressed in the SCR notation. Their approach maps a finite subset of SCR onto a state machine which is then fed into the model checker. Jackson [53] has investigated using model checking to validate properties of Z and VDM specifications.
Reference: [9] <author> L. Bass, R. Little, R. Pellegrino, S. Reed, R. Seacord, S. Sheppard, and M. R. Szczur. </author> <title> The arch model : Seeheim revisited, </title> <booktitle> 4 1991. User Interface Developer's Workshop Report. </booktitle>
Reference-contexts: On one end of the spectrum are conceptual "architectures" like Seeheim and its derivatives <ref> [82, 9] </ref>, Model-View-Controller (MVC)[62], and Presentation-Abstraction-Control (PAC) [29]. These give general guidelines for separating functionality into components and then linking these components into a final system. On the other end are rigorous semantic models of interactive software structure like Paterno's theory of interactors [80].
Reference: [10] <author> L. Bass and C. Unger, </author> <title> editors. Engineering for Human Computer Interaction. </title> <publisher> Chapman & Hall, </publisher> <year> 1996. </year>
Reference: [11] <author> Len Bass and Joelle Coutaz. </author> <title> Developing Software for the User Interface. SEI Series in Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: The software engineering process side of interactive system design admits the human designer as an evaluator of the fitness of a user interface. The paradigm is one of rapid prototyping and continual evaluation [48]. Bass and Coutaz <ref> [11] </ref> refine this description into an iterative process model similar to the spiral model of Boehm [16]. Within this paradigm, analysis and evaluation occur throughout the life-cycle of a product. The focus of analysis in this domain are user tasks. <p> Like UIMX, designers must follow this generation step with a programming step in which they add behavior to the call-backs of these widgets. Incidentally, not all lexical tools are graphically based. The User Interface Language (UIL) compiler produces presentation code from a textual description of the display <ref> [11] </ref>. Tools at this level generate code which programmers then specialize. This specialization usually 34 takes the form of extension, i.e.-adding call-back functions. Often however, programmers modify the parameters or application of the generated code itself. <p> The model does not require machine concurrency, but it has an expressive feel which is event based rather than thread based. The Propositional Production System (PPS)[76] is an example of such a model, and many UIMS's adopt it. The Serpent <ref> [11] </ref> UIMS, on the other hand, takes a more domain-independent approach. Using Slang (the Serpent dialogue language), functionality is assigned to graphical objects through guarded actions. <p> Multi-agent architectures support a higher degree of interface concurrency, feedback, and locality than layered architectures. At present, there is no consensus on the proper interactive system decomposition <ref> [11] </ref>. The current population of generic decompositions serve rather as design heuristics which may or may not be appropriate to a specific application.
Reference: [12] <author> D. Benyon and P. Palanque, </author> <title> editors. Critical Issues in User Interface Systems Engineering. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference: [13] <author> Gerard Berry and Georges Gonthier. </author> <title> The esterel synchronous programming language; design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19 </volume> <pages> 87-152, </pages> <year> 1992. </year>
Reference-contexts: Without this form of process interaction, concurrent run-time control policies can be simulated quite efficiently on a sequential machine. In defining the Esterel <ref> [13] </ref> notation, Berry and Gonthier proposed a model of concurrency which is appropriate for task-based concrete architectures. They observed that notations which utilize concurrency forces systems to be either concurrent or deterministic, and that the reason for this was that concurrency was based upon an asynchronous implementation model. <p> Though user interfaces should not be overly deterministic, the system should also not non-deterministically make choices with regard to user task performance [32]. Berry and Gonthier propose overcoming this dilemma by applying a synchronous model of concurrency. The essence of synchronous concurrency is the so-called synchrony hypothesis <ref> [13] </ref>, which states that interactions take no time with respect to their environments. The synchrony hypothesis reflects the way current GUI toolkits are implemented in the following sense: when an interaction event is dispatched, it is not preempted by other events.
Reference: [14] <author> F. Bodart, A.-M. Hennebert, J.-M. Leheureux, I. Provot, and J. Vanderdonckt. </author> <title> A model-based approach to presentation: A continuum from task analysis to prototype. </title> <booktitle> In EuroGraph-ics Workshop on Design, Specification, and Verification of Interactive Systems (DSV-IS'94), </booktitle> <year> 1994. </year>
Reference-contexts: Furthermore, these models suggest candidate abstract interaction objects that constitute the presentation of an interactive system <ref> [14] </ref>. The pinnacle of application modeling is the User Interface Design Environment (UIDE)[37, 95]. Systems are expressed in terms of an application model, and the environment provides run-time support for model inferencing. Salient features include explicit pre- and post-conditions which can be attached to any actions in the model.
Reference: [15] <author> F. Bodart, A.-M. Hennebert, J.-M. Leheureux, I. Provot, J. Vanderdonckt, and G. Zucchinetti. </author> <title> Key activities for a development methodology of interactive applications. In Critical Issues in User Interface Systems Engineering [12]. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year> <month> 140 </month>
Reference-contexts: Though Trident does not contain an explicit task model, its representations are derived from a TKS [57] specified hierarchical task model. The melding of methodology and model representation in Trident is impressive. In <ref> [15] </ref>, Bodart et al. demonstrate how TKS models suggest entities and relationships, from which the data model can be derived, and temporal ordering cues from which the Activity Chaining Graph can be derived. Furthermore, these models suggest candidate abstract interaction objects that constitute the presentation of an interactive system [14].
Reference: [16] <author> Barry Boehm. </author> <title> A spiral model of software development and enhancement. </title> <journal> IEEE Computer, </journal> <volume> 21(5) </volume> <pages> 61-72, </pages> <year> 1988. </year>
Reference-contexts: The paradigm is one of rapid prototyping and continual evaluation [48]. Bass and Coutaz [11] refine this description into an iterative process model similar to the spiral model of Boehm <ref> [16] </ref>. Within this paradigm, analysis and evaluation occur throughout the life-cycle of a product. The focus of analysis in this domain are user tasks. According to Diaper [30, preface], task analysis is potentially the most powerful method for producing interactive system requirements specifications.
Reference: [17] <author> Tommaso Bolognesi and Ed Brinksma. </author> <title> Introduction to the ISO specification language lotos. </title> <journal> Computer Network ISDN Systems, </journal> <volume> 14(1), </volume> <year> 1987. </year>
Reference-contexts: Components of this virtual machine comprise the Mastermind toolkit (MMTK). One of the chief technical contributions of this research is the Mastermind Dialogue Language (MDL). MDL is a formal notation for representing user task decompositions. The design of MDL was influenced primarily by the Lotos notation <ref> [17] </ref> with influences from CSP [51], and the User Action Notation (UAN)[46, 49]. Designers can use MDL to specify the behavior of tasks in terms 14 of objects, actions, and the sequencing of actions. Binding enriches task models with presentation functionality. <p> Others, like Goals, Operators, Methods, and Selection (GOMS)[23] and Cognitive Complexity Theory (CCT)[60], incorporate a model of human psychology in order to evaluate the performance of users on tasks. The Mastermind environment, which will be discussed below, uses a task modeling notation derived from Lotos <ref> [17] </ref> in support of an incremental design, evaluate, iterate development model. 33 3.2 Automated Interactive System Development Automated approaches to interactive system development reduce the complexity of development by raising the level of abstraction in system specification. There have been many approaches to this in the history of HCI.
Reference: [18] <author> Thomas Browne, David Davila, Spencer Rugaber, and Kurt Stirewalt. </author> <title> Using declarative descriptions to model user interfaces with mastermind. </title> <editor> In Fabio Paterno and Philippe Palanque, editors, </editor> <title> Formal Methods in Human Computer Interaction. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: It is the thesis of this work that these weaknesses are symptomatic of an unclear delegation of responsibility in model-based code generation technology. Unlike traditional programming language compilers, interactive system code generators seems to require input from multiple models. The Mastermind project <ref> [18, 74] </ref> is concerned with the design, integration, and automatic generation of interactive systems from declarative models. <p> Unlike traditional programming language compilers, interactive system code generators seems to require input from multiple models. The Mastermind project [18, 74] is concerned with the design, integration, and automatic generation of interactive systems from declarative models. In the Mastermind environment <ref> [74, 97, 18] </ref>, interactive systems are subject to three kinds of models: * User task models specifying the protocols of end user interaction in the context of performing a task. <p> The Adept environment [58, 102] supports the evolution of task models throughout a system's lifetime. In addition to iterative task model support, Adept models can be refined into an implementation model for which there is a code generator. The Mastermind environment <ref> [74, 97, 18] </ref>, uses a task model as its design requirements model. 3.3.1.3 Presentation Modeling Systems generated from task and application models often have interfaces that are not highly graphical.
Reference: [19] <editor> H. J. Bullinger and B. Schackel, editors. </editor> <booktitle> Human Computer Interaction - INTERACT'87. </booktitle> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference: [20] <author> T. Bultan, J. Fischer, and R. Gerber. </author> <title> Compositional verification by model-checking for counter-examples. </title> <booktitle> In International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 224-238, </pages> <year> 1996. </year>
Reference-contexts: Applications of this general approach to the validation of Ada task compositions have been performed by Fischer and Gerber [36] and Bultan, Fischer, and Gerber <ref> [20] </ref>. We use model checking to validate properties of MMTK component compositions. Our use deviates from the approaches mentioned above in that we handle compositionality without articulating an explicit interface process. Rather, we prove a theorem about testing adequacy for two compositional properties (receptiveness and freedom from divergence).
Reference: [21] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the 5 th International Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: A counter-example is a sequence of machine behaviors (changes in state or the issuing of events) which serve to demonstrate the failure of a temporal constraint. Recent work in symbolic model checking <ref> [21] </ref> utilizes an efficient representation of finite state spaces to make the checking of large models (on the order of 10 20 states) feasible. Model checking has been used to validate many types of software specifications. Atlee and Gannon [8] verify safety properties of requirements expressed in the SCR notation.
Reference: [22] <author> S. K. Card, T. P. Moran, and A. Newell. </author> <title> The keystroke-level model for user performance. </title> <journal> Communications of the ACM, </journal> <volume> 23 </volume> <pages> 394-410, </pages> <year> 1980. </year>
Reference-contexts: Just as dialogue notations became a unifying feature of UIMS generators, user task models have become the unifying model of different model-based approaches. On the 38 analysis side, tools like Glean [61] allow designers to analyze task models in terms of human mental cognition and observable human action (GOMS <ref> [22] </ref>). Other approaches view task models as evolving entities within the life cycle of an interactive system. The Adept environment [58, 102] supports the evolution of task models throughout a system's lifetime.
Reference: [23] <author> S. K. Card, T. P. Moran, and A. Newell. </author> <title> The Psychology of Human Computer Interaction. </title> <publisher> Lawrence Erlbaum, </publisher> <year> 1983. </year>
Reference: [24] <author> L. Cardelli and R. Pike. Squeak: </author> <title> a language for communicating with mice. </title> <journal> Computer Graphics, </journal> <volume> 19(3), </volume> <year> 1985. </year>
Reference-contexts: In addition to being appropriate for the UI domain, the synchrony hypothesis greatly simplifies the implementation of process notations by precluding the need to resolve race conditions resulting from multiple overlapping device interactions. In fact, synchronous languages are often compilable into deterministic finite automata. The Squeak <ref> [24] </ref> language of Cardelli and Pike assumes the synchrony hypothesis and is able to create single-threaded implementations from a concurrent notation. The Esterel language also shares this property. Design Decision 1.
Reference: [25] <author> P. Castells, P. Szekely, and E. Salcher. </author> <title> Declarative models of presentation. </title> <booktitle> In IUI'97: International Conference on Intelligent User Interfaces, </booktitle> <pages> pages 137-144, </pages> <year> 1997. </year>
Reference-contexts: In the Mastermind environment, the code for presentation objects, like the airspace background and the plane widgets, is generated from a declarative presentation model <ref> [25] </ref> which is specified separately from the task model. Of course, task and presentation models are not entirely orthogonal. When an air-traffic controller performs the ManagePlaneInFlight task, for example, he does so by interacting with the buttons generated by the presentation model. <p> This is feasible when designers are building the components from the bottom up, but it has a consequence which seems inconsistent with the Mastermind vision of modeling. Recall that Paterno's in-teractors have a rigid structure of data paths and connection obligations. Mastermind models, particularly the presentation model <ref> [25] </ref>, have features which do not easily map into this world. 44 We believe that this aspect of Mastermind models makes the connection-oriented approach to implementation unfeasible. Mastermind models match a specialized specification paradigm to a particular problem.
Reference: [26] <author> E. M. Clarke and E. A. Emerson. </author> <title> Synthesis of synchronization skeletons from branching time temporal logic. </title> <booktitle> In Workshop on Logics of Programs, </booktitle> <pages> pages 52-71, </pages> <year> 1981. </year>
Reference-contexts: Moreover, CTL allows the existential and universal quantification of a temporal predicates over paths. 3.5.2 Model Checking Model checking is a technique for validating finite automata for adherence to constraints phrased in temporal logic <ref> [26] </ref>. A model checker is a tool which inputs a description of a finite state model and a set of temporal constraints, builds a representation of all executions of this model, exhaustively checks these executions for adherence to the constraints, and reports violations.
Reference: [27] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference: [28] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 353-362, </pages> <year> 1989. </year>
Reference: [29] <author> J. Coutaz. </author> <title> PAC, an object-oriented model for dialog design. </title> <booktitle> In Human Computer Interaction - INTERACT'87 [19], </booktitle> <pages> pages 431-436. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference-contexts: On one end of the spectrum are conceptual "architectures" like Seeheim and its derivatives [82, 9], Model-View-Controller (MVC)[62], and Presentation-Abstraction-Control (PAC) <ref> [29] </ref>. These give general guidelines for separating functionality into components and then linking these components into a final system. On the other end are rigorous semantic models of interactive software structure like Paterno's theory of interactors [80]. The thesis of our work is that multi-model composition must be rigorously specified. <p> The controller C aggregates these sub-controllers and resolves their presentation/abstraction connection needs. It is claimed by Coutaz <ref> [29] </ref> that this distribution allows the structure of the software to better match the cognitive organization of human knowledge because it does not organize functionality into hermetic layers [6]. 42 Paterno's theory of interactors [80] adds precision and mathematical rigor to this connection-oriented view of interface composition.
Reference: [30] <author> D. Diaper, </author> <title> editor. Task Analysis for Human Computer Interaction. </title> <publisher> Ellis Horwood, </publisher> <year> 1989. </year>
Reference-contexts: At some point, the designer invokes the code generator to synthesize the models into an executable user interface. This interface provides the end-user with access to core application functionality. A view of the process of model design and generation is given in Figure 2. Designers perform user task analysis <ref> [30] </ref> to begin to gain an understanding of the requirements of the system. This analysis results in the initial design model (an hierarchical decomposition of user tasks). Tasks are specified in the Mastermind Dialogue Language (MDL). <p> Bass and Coutaz [11] refine this description into an iterative process model similar to the spiral model of Boehm [16]. Within this paradigm, analysis and evaluation occur throughout the life-cycle of a product. The focus of analysis in this domain are user tasks. According to Diaper <ref> [30, preface] </ref>, task analysis is potentially the most powerful method for producing interactive system requirements specifications. There are many different approaches to task analysis. Some, like Task Analysis for Knowledge Description (TAKD)[31], produce a generalization hierarchy of tasks. <p> This requires an active dialogue manager component that observes the state of the system and reacts by disabling actions whose pre-conditions are not satisfied and enabling actions whose pre-conditions are satisfied. 3.3.1.2 Task Modeling According to Diaper <ref> [30, preface] </ref>, task analysis is potentially the most powerful method for producing interactive system requirements specifications. If this is truly the case, it makes sense to include task models in a model-based development environment.
Reference: [31] <author> D. Diaper. </author> <title> Analysing focused interview data with task analysis for knowledge description (takd). </title> <booktitle> In IFIP INTERACT'90: Human-Computer Interaction, </booktitle> <year> 1990. </year>
Reference: [32] <author> Alan Dix. </author> <title> Non-determinism as a paradigm for understanding the user interface. </title> <booktitle> In Formal Methods in Human-Computer Interaction[45], </booktitle> <pages> pages 97-127. </pages> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: It is not clear, however, that a given domain requires all three characteristics. We chose not to implement support for the competing process aspect of concurrency because it does not seem to be needed in interactive system architecture and because its presence can lead to poorly designed interfaces <ref> [32] </ref>. Without this form of process interaction, concurrent run-time control policies can be simulated quite efficiently on a sequential machine. In defining the Esterel [13] notation, Berry and Gonthier proposed a model of concurrency which is appropriate for task-based concrete architectures. <p> Though user interfaces should not be overly deterministic, the system should also not non-deterministically make choices with regard to user task performance <ref> [32] </ref>. Berry and Gonthier propose overcoming this dilemma by applying a synchronous model of concurrency. The essence of synchronous concurrency is the so-called synchrony hypothesis [13], which states that interactions take no time with respect to their environments.
Reference: [33] <author> W. Keith Edwards, Scott Hudson, Roy Rodenstein, Thomas Rodriguez, and Ian Smith. </author> <title> Sys--tematic output modification in a 2d user interface toolkit. </title> <booktitle> In UIST'97: ACM Symposium on User Interface Software Technology, </booktitle> <year> 1997. </year>
Reference-contexts: In the X-window system, for example, mouse and keyboard events are queued-up and call-back functions are dispatched in sequence so that one function completes before the next event is dispatched. Even though more modern toolkits like Amulet [72] and subArctic <ref> [33] </ref>, support multi-threading, their behavior is consistent with the synchrony hypothesis because methods dispatched by events are not interrupted by other events. Programmers familiar with toolkits understand this and deal with it by keeping callstacks shallow 91 in event handling code.
Reference: [34] <author> Brad A. Myers et. al. Garnet: </author> <title> Comprehensive support for graphical, highly-interactive user interfaces. </title> <journal> IEEE Computer, </journal> <volume> 23(11) </volume> <pages> 71-85, </pages> <month> 11 </month> <year> 1990. </year>
Reference-contexts: Usually this takes the form of special presentation markings to identify actions which are legal or illegal at various points in the performance of a task. Our decisions in this regard leverage abstractions provided by the Garnet <ref> [34] </ref> and Amulet [72] toolkits. The Amulet toolkit [72] provides an interactor model which purports to be a true solution to the independence of input and output. In Amulet, a special type of object called an interactor serves as the controller.
Reference: [35] <author> A. Fantechi, S. Gnesi, and G. Mazzarini. </author> <title> How expressive are lotos behaviour expressions? In Formal Description Techniques, </title> <booktitle> III. Proceedings of IFIP TC/WG 6.1 Third International Conference on Formal Description Techniques for Distributed Systems and Communication Protocols (FORTE'91), </booktitle> <pages> pages 17-32, </pages> <year> 1991. </year>
Reference: [36] <author> J. Fischer and R. Gerber. </author> <title> Compositional model-checking of ada tasking programs. </title> <booktitle> In IEEE Ninth Annual Conference on Computer Assurance (COMPASS'94), </booktitle> <year> 1994. </year>
Reference-contexts: Applications of this general approach to the validation of Ada task compositions have been performed by Fischer and Gerber <ref> [36] </ref> and Bultan, Fischer, and Gerber [20]. We use model checking to validate properties of MMTK component compositions. Our use deviates from the approaches mentioned above in that we handle compositionality without articulating an explicit interface process.
Reference: [37] <author> J. Foley, W. Kim, S. Kovacevic, and K. Murray. </author> <title> Uide an intelligent user interface design environment. </title> <booktitle> In [96], </booktitle> <pages> pages 339-384. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference: [38] <author> J. D. Foley. </author> <title> The structure of interactive command languages. </title> <editor> In R. A. Guedj et. al., editor, </editor> <booktitle> Methodology of Interaction, </booktitle> <pages> pages 227-234. </pages> <publisher> North Holland Publishing Company, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1980. </year>
Reference-contexts: They form 32 the objective grounding to which designers appeal when talking about the structure of a problem. There have so far been two ontologies proposed for the structure of the user interface. The first was proposed by Foley <ref> [38, 39] </ref> and defines the user interface as an input language for the user, an output language for the machine, and a protocol for interaction.
Reference: [39] <author> James D. Foley, Victor L. Wallace, and Peggy Chan. </author> <title> The human factors of computer graphics interaction techniques. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4, </volume> <month> 11 </month> <year> 1984. </year>
Reference-contexts: They form 32 the objective grounding to which designers appeal when talking about the structure of a problem. There have so far been two ontologies proposed for the structure of the user interface. The first was proposed by Foley <ref> [38, 39] </ref> and defines the user interface as an input language for the user, an output language for the machine, and a protocol for interaction.
Reference: [40] <institution> Formal Systems (Europe) Ltd., </institution> <address> Oxford, England. </address> <booktitle> Failures Divergence Refinement: User Manual and Tutorial. </booktitle> <address> 1.2fi, </address> <year> 1992. </year>
Reference-contexts: Wing et al. also demonstrate the need for abstraction by applying model checking in a case study verifying the cache coherency protocol of a distributed file system [103]. Allen and Garlan [5] use the FDR <ref> [40] </ref> tool to check whether or not one CSP process is a refinement of another. In this thesis, we use the Symbolic Model Verifier (SMV)[66] from Carnegie Mellon University to verify the safe composition of our ordering components. Many interface usability properties can be expressed concisely through temporal constraints.
Reference: [41] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: The key observation here is that if we forget about hidden events for the moment, there will be exactly one instance of an event for each different event name. There is an object-oriented design pattern called Singleton <ref> [41] </ref> which applies when there must be exactly one instance of a class which must be accessible to clients from a well-known access point. Clients of event components are input and output communication components, and the well-known access point is the name of the event.
Reference: [42] <author> S. Gnesi and S. Larosa. </author> <title> A sound and complete axiom system for the logic actl. </title> <booktitle> In Fifth Italian Conference on Theoretical Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Paterno [67] uses a logic called ACTL [75] which can express equivalence relationships between CCS [68] terms. This relates task and system models which are both defined as Lotos processes in Paterno's framework. They use an ACTL <ref> [42] </ref> model checker to carry out these validations. The problem they had to overcome is that, in general, Lotos specifications denote infinite state processes and are, therefore, not checkable using model checking techniques.
Reference: [43] <author> James Gosling and Frank Yellin. </author> <title> The Java Application Programming Interface, Volume 2: Window Toolkit and Applets. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: In the case of UIMX-generated code, this activity amounts to providing call-back functions which are invoked when the end user interacts with the widgets at run-time. With the emergence of the Java language [7] and user interface library AWT <ref> [43] </ref>, palette-based presentation generators have become popular. These allow designers to rapidly construct presentations and then generate code which creates and initializes these presentations. Like UIMX, designers must follow this generation step with a programming step in which they add behavior to the call-backs of these widgets.
Reference: [44] <author> David Harel. Statecharts: </author> <title> a visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8, </volume> <year> 1987. </year>
Reference-contexts: Unfortunately, in the beginning, we applied the methods poorly. We took the approach of 137 picking formalism X and trying to model all of the desired task and presentation functionality in X . Chronologically, formalism X was StateCharts <ref> [44] </ref>, then Petri-nets [86], and finally Mealy machines. The problem was we failed to identify acceptance criteria before plunging into the modeling phase. We spent weeks investigating Petri-nets and even began building a Petri-net simulator before realizing they did not compose well with our intended model of presentations.
Reference: [45] <author> M. Harrison and H. Thimbleby, </author> <title> editors. Formal Methods in Human-Computer Interaction. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [46] <author> H. R. Hartson, A. C. Siochi, and D. Hix. </author> <title> The uan: a user-oriented representation for direct manipulation interface designs. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(3) </volume> <pages> 181-203, </pages> <month> 7 </month> <year> 1990. </year>
Reference: [47] <author> H. Rex Hartson and D. </author> <title> Hix, </title> <editor> editors. </editor> <booktitle> Advances in Human-Computer Interaction, </booktitle> <volume> volume 2. </volume> <publisher> Ablex, </publisher> <address> Norwood, </address> <year> 1988. </year>
Reference: [48] <author> H. Rex Hartson and Deborah Hix. </author> <title> Human computer interface development : Concepts and systems for its management. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(1) </volume> <pages> 5-92, </pages> <month> 3 </month> <year> 1989. </year> <month> 142 </month>
Reference-contexts: The software engineering process side of interactive system design admits the human designer as an evaluator of the fitness of a user interface. The paradigm is one of rapid prototyping and continual evaluation <ref> [48] </ref>. Bass and Coutaz [11] refine this description into an iterative process model similar to the spiral model of Boehm [16]. Within this paradigm, analysis and evaluation occur throughout the life-cycle of a product. The focus of analysis in this domain are user tasks.
Reference: [49] <author> H. Rex Hartson and Kevin A. Mayo. </author> <title> A framework for precise, reusable, task abstractions. </title> <booktitle> In Eurographics Workshop: Design, Specification and Verification of Interactive Systems, </booktitle> <pages> pages 147-164, </pages> <year> 1994. </year>
Reference: [50] <author> C. A. R. Hoare. </author> <title> Parallel programming: An axiomatic approach. </title> <journal> Computer Languages, </journal> <volume> 1(2) </volume> <pages> 151-160, </pages> <month> 6 </month> <year> 1975. </year>
Reference-contexts: On sequential machines, concurrency must be simulated. In a classic paper <ref> [50] </ref>, Hoare identified three distinct classes of concurrent processes: 90 1. Competing processes, which require the exclusive use of some global resource during certain phases of their execution, 2. Cooperating processes, which independently make contributions to some desired result, and 3.
Reference: [51] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice/Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: One of the chief technical contributions of this research is the Mastermind Dialogue Language (MDL). MDL is a formal notation for representing user task decompositions. The design of MDL was influenced primarily by the Lotos notation [17] with influences from CSP <ref> [51] </ref>, and the User Action Notation (UAN)[46, 49]. Designers can use MDL to specify the behavior of tasks in terms 14 of objects, actions, and the sequencing of actions. Binding enriches task models with presentation functionality.
Reference: [52] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: We overcame this difficulty by formalizing the control model and then implementing the formalism. If we ignore event synchronization for the moment, the control issues that come up with MMTK components can be conveniently modeled using Mealy machines. A Mealy machine <ref> [52, p. 43] </ref> is a finite automaton extended with the ability to produce output. Mealy machines are often used to formalize reactive systems because they are simple, and they support input and output communication. <p> The internal state changes in response to a signal which communicates a change of status from one component to another. Finally, components often react to signals by issuing their own signals to other components. A formal machine model which can express this kind of behavior is a Mealy machine <ref> [52] </ref>. Mealy machines are finite automata with output. Mealy machines react to an input symbol by changing state and issuing an output symbol all in one step.
Reference: [53] <author> Daniel Jackson. </author> <title> Abstract model checking of infinite specifications. </title> <booktitle> In Formal Methods Europe, </booktitle> <address> Barcelona, </address> <month> 10 </month> <year> 1994. </year>
Reference-contexts: Model checking has been used to validate many types of software specifications. Atlee and Gannon [8] verify safety properties of requirements expressed in the SCR notation. Their approach maps a finite subset of SCR onto a state machine which is then fed into the model checker. Jackson <ref> [53] </ref> has investigated using model checking to validate properties of Z and VDM specifications. Since these specifications often describe infinite state spaces, a finite state abstraction must be applied in order to use the model checker. Jackson takes advantage of equivalence classes 47 on relations to create this abstraction.
Reference: [54] <author> Daniel Jackson and Craig A. Damon. </author> <title> Elements of style: Analyzing a software design feature with a counterexample detector. </title> <booktitle> In International Symposium on Software Testing and Analysis (ISSTA'96), </booktitle> <year> 1996. </year>
Reference-contexts: Since these specifications often describe infinite state spaces, a finite state abstraction must be applied in order to use the model checker. Jackson takes advantage of equivalence classes 47 on relations to create this abstraction. In <ref> [54] </ref>, Jackson and Damon apply these techniques to the design of a style editor in a word processor. Wing et al. also demonstrate the need for abstraction by applying model checking in a case study verifying the cache coherency protocol of a distributed file system [103].
Reference: [55] <author> Christian Janssen, Anette Weisbecker, and Jurgen Ziegler. </author> <title> Generating user interfaces from data models and dialogue net specifications. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference-contexts: Many of these approaches operate directly on software engineering models. The earliest applications of this approach began as semantic level extensions to UIMS architectures and technology. In Genius <ref> [55] </ref>, designers specify data models and augment these with a behavior abstraction called a dialogue net 37 (similar to a Petri-net [86]). From these specifications, Genius uses a knowledge base to select in-teraction objects, arrange layout, and incorporate the dynamics into an executable implementation.
Reference: [56] <author> P. Johnson. </author> <title> Human Computer Interaction: Psychology, Task Analysis, and Software Engineering. </title> <publisher> McGraw-Hill, </publisher> <year> 1989. </year>
Reference: [57] <author> P. Johnson. </author> <title> Human-Computer Interaction, Psychology, Task analysis, and Software Engineering. </title> <publisher> McGraw-Hill, </publisher> <address> London, </address> <year> 1991. </year>
Reference-contexts: In addition, Trident represents lexical attributes in the form of Abstract Interaction Objects (AIOs) and Concrete Interaction Objects (CIOs). Though Trident does not contain an explicit task model, its representations are derived from a TKS <ref> [57] </ref> specified hierarchical task model. The melding of methodology and model representation in Trident is impressive. In [15], Bodart et al. demonstrate how TKS models suggest entities and relationships, from which the data model can be derived, and temporal ordering cues from which the Activity Chaining Graph can be derived.
Reference: [58] <author> P. Johnson, S. Wilson, P. Markopoulos, and J. Pycock. </author> <title> Adept advanced design environment for prototyping with task models. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference-contexts: On the 38 analysis side, tools like Glean [61] allow designers to analyze task models in terms of human mental cognition and observable human action (GOMS [22]). Other approaches view task models as evolving entities within the life cycle of an interactive system. The Adept environment <ref> [58, 102] </ref> supports the evolution of task models throughout a system's lifetime. In addition to iterative task model support, Adept models can be refined into an implementation model for which there is a code generator.
Reference: [59] <author> S. C. Johnson. </author> <title> Yacc-yet another compiler compiler. </title> <type> Technical Report C.S. Technical Report # 32, </type> <institution> Bell Telephone Laboratories, </institution> <address> Murray Hill, Ne Jersey, </address> <year> 1975. </year>
Reference-contexts: They represent some aspects of a system and are neutral with respect to others. Inevitably, in an executable application, model-generated code depends upon (and is depended upon by) non-model generated code. Consider, for example, compilers built in part using parser generator technology like yacc <ref> [59] </ref>. Part of these systems is generated from a model (the grammar), and the other part is written by a programmer. Often the generated code must include snippets of programmer written code in the form of embeddable actions.
Reference: [60] <author> D. Kieras and G. Polson. </author> <title> An approach to the formal analysis of user complexity. </title> <journal> International Journal of Man Machine Studies, </journal> <volume> 22, </volume> <year> 1985. </year>
Reference: [61] <author> David E. Kieras, Scott D. Wood, Kasem Abotel, and Anthony Hornof. Glean: </author> <title> A computer-based tool for rapid goms model usability evaluation of user interface designs. </title> <booktitle> In ACM Symposium on User Interface Software and Technology, </booktitle> <year> 1995. </year>
Reference-contexts: Just as dialogue notations became a unifying feature of UIMS generators, user task models have become the unifying model of different model-based approaches. On the 38 analysis side, tools like Glean <ref> [61] </ref> allow designers to analyze task models in terms of human mental cognition and observable human action (GOMS [22]). Other approaches view task models as evolving entities within the life cycle of an interactive system. The Adept environment [58, 102] supports the evolution of task models throughout a system's lifetime.
Reference: [62] <author> G. E. Krasner and S. T. Pope. </author> <title> A cookbook for using the model view controller user interface paradigm in smalltalk. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 1(3), </volume> <month> 8 </month> <year> 1988. </year>
Reference: [63] <author> P. Markopoulos. </author> <title> On the expression of interaction properties within an interactor model. In Design Specification and Verification of Interactive Systems (DSV-IS'95), </title> <year> 1995. </year>
Reference: [64] <author> P. Markopoulos, J. Rowson, and P. Johnson. </author> <title> On the composition of interactor specifications. </title> <booktitle> In Formal Aspects of the Human Computer Interface, BCS-FACS Workshop, </booktitle> <year> 1996. </year> <month> 143 </month>
Reference: [65] <author> P. Markopoulos, S. Wilson, and P. Johnson. </author> <title> Representation and use of task knowledge in a user interface design environment. </title> <journal> IEE Proceedings-Computers and Digital Techniques, </journal> <volume> 141(2), </volume> <year> 1994. </year>
Reference: [66] <author> K. L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year> <month> CMU-CS-92-131. </month>
Reference-contexts: With this much state inherent in the problem, proofs of composition are still unwieldy. We made the proof tractable by delegating much of the proof tedium to the model checker <ref> [66] </ref>. The proof of the Composition Adequacy Theorem describes how to construct adequate testing configurations for submission to the model checker. The proof, when augmented with successful model checking, demonstrates that MMTK components compose correctly in arbitrary tree configurations.
Reference: [67] <author> M. Mezzanotte and F. Paterno'. </author> <title> Verification of properties of human-computer dialogues with an infinite number of states. </title> <booktitle> In Formal Aspects of the Human Computer Interface BCS-FACS Workshop, </booktitle> <pages> pages 29-39, </pages> <year> 1996. </year>
Reference-contexts: They express dialogue using Olsen's Propositional Production System (PPS)[76] which has been shown to be equivalent in expressive power to the regular expressions. Abowd uses CTL to express these properties and uses SMV to check them. Paterno <ref> [67] </ref> uses a logic called ACTL [75] which can express equivalence relationships between CCS [68] terms. This relates task and system models which are both defined as Lotos processes in Paterno's framework. They use an ACTL [42] model checker to carry out these validations.
Reference: [68] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Abowd uses CTL to express these properties and uses SMV to check them. Paterno [67] uses a logic called ACTL [75] which can express equivalence relationships between CCS <ref> [68] </ref> terms. This relates task and system models which are both defined as Lotos processes in Paterno's framework. They use an ACTL [42] model checker to carry out these validations.
Reference: [69] <author> Thomas P. Moran. </author> <title> The command language grammar: a representation for the user of an interactive computer system. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 15 </volume> <pages> 3-50, </pages> <year> 1981. </year>
Reference-contexts: The first was proposed by Foley [38, 39] and defines the user interface as an input language for the user, an output language for the machine, and a protocol for interaction. The other ontology, due to Moran <ref> [69] </ref>, considers the user interface to be "those aspects of the system that the user comes in contact with-physically, perceptually, or conceptually." Foley's linguistic model has proven particularly influential for automatic generation technology. The idea is that interface design is similar to programming language design.
Reference: [70] <author> Brad A. Myers. </author> <title> A new model for handling input. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(3) </volume> <pages> 289-320, </pages> <year> 1990. </year>
Reference-contexts: When these specifications are realized in code, the communications will actually be initiated by interactors. Interactors <ref> [70] </ref> are user-interface toolkit devices which manage stereotypical gesture behavior and perform actions at various points during a gesture. In Mastermind , a task T is bound to a presentation P using the notation: P k T .
Reference: [71] <author> Brad A. Myers and David S. Kosbie. </author> <title> Reusable hierarchical command objects. </title> <booktitle> In CHI'96: Human Factors in Computing Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Specifically, we assumed that all presentation/task communication could be implemented by event synchronization and that the initiation of a communication could be implemented using Amulet Command <ref> [71] </ref> objects. Clearly things worked out for the examples we tried, but it is reasonable to ask if there exist situations whose complexity exceeds the facilities we have laid down. That is, is our presentation linkage strategy complete with respect to the target toolkit. <p> That is, is our presentation linkage strategy complete with respect to the target toolkit. We believe, in fact, that our approach is complete with respect to the way the Amulet toolkit handles interactor actions <ref> [71] </ref>. In general there are three obstacles to MMTK/presentation linkage: 1. Techniques for connecting UI functionality vary widely depending upon the presentation toolkit and programming language. Connecting with presentation entities often requires set ting values in toolkit objects and being invoked by asynchronous call-backs. 2. <p> We believe that our choice of linkage via Amulet command objects takes care of point two. That is, by design Amulet command objects are generic over presentations and interactors. This makes them trivially "pluggable" in different contexts. In fact, in <ref> [71] </ref>, Myers and Kosbie argue that by virtue of command objects and the interactor model, input in Amulet is completely separable from output in the sense of the model-view-controller (MVC) paradigm. The "late-binding" of our linkage strategy is directly related to the degree to which Myers' claims are true.
Reference: [72] <author> Brad A. Myers, Richard G. McDaniel, Robert C. Miller, Alan S. Ferrency, Andrew Faulring, Bruce D. Kyle, Andrew Mickish, Alex Klimovitski, and Patrick Doane. </author> <title> The amulet environment: New models for effective user interface software development. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(6) </volume> <pages> 347-365, </pages> <month> 6 </month> <year> 1997. </year>
Reference-contexts: On the presentation side, there are Presentation Components which get generated from a presentation model. These components are typically organized into part-hierarchies and are controlled by a run-time system. Mastermind uses the Amulet <ref> [72] </ref> toolkit for presentation support, and so the run-time controller for presentation components is the Amulet Run-time system. Systems with this structure must be generated from the bound task models. <p> We now demonstrate the use of this toolkit in implementing the behavior specification of ManageFlight and comment on the complexity of the toolkit components. This commentary motivates the technical contributions which follow. 26 2.4.1 Example of Generated Code Mastermind implements bound task models in C++ using the Amulet <ref> [72] </ref> user interface toolkit for presentation support. The general strategy is to create a C++ class for each declared binding. The class declarations aggregate: 1. local data corresponding to binding parameters, 2. <p> The code generation meta-model is one in which each Mastermind model has an associated code generator and an elaborate model-based linking process connects data and behavior in the code generated from each model. The presentation model generates code using features from the Amulet <ref> [72] </ref> toolkit, the task model generates code using features from the Mastermind toolkit (MMTK), and the application model code generator is currently under development. 3.3.3 The Multi-Model Binding Problem Models are not programming languages. They represent some aspects of a system and are neutral with respect to others. <p> They represent the enabledness of a presentation interactor and, therefore, are convenient vehicles for explicitly enabling and disabling interaction. The also have a special method called DO () which is invoked whenever an interaction completes. We use command objects in Amulet <ref> [72] </ref> as a means for connecting MMTK components to bound presentations. This section describes the details of this connection. 5.6.1 The Amulet Input Model The Amulet toolkit provides a solution to this problem in the way it handles interaction. <p> In the X-window system, for example, mouse and keyboard events are queued-up and call-back functions are dispatched in sequence so that one function completes before the next event is dispatched. Even though more modern toolkits like Amulet <ref> [72] </ref> and subArctic [33], support multi-threading, their behavior is consistent with the synchrony hypothesis because methods dispatched by events are not interrupted by other events. Programmers familiar with toolkits understand this and deal with it by keeping callstacks shallow 91 in event handling code. <p> Usually this takes the form of special presentation markings to identify actions which are legal or illegal at various points in the performance of a task. Our decisions in this regard leverage abstractions provided by the Garnet [34] and Amulet <ref> [72] </ref> toolkits. The Amulet toolkit [72] provides an interactor model which purports to be a true solution to the independence of input and output. In Amulet, a special type of object called an interactor serves as the controller. <p> Usually this takes the form of special presentation markings to identify actions which are legal or illegal at various points in the performance of a task. Our decisions in this regard leverage abstractions provided by the Garnet [34] and Amulet <ref> [72] </ref> toolkits. The Amulet toolkit [72] provides an interactor model which purports to be a true solution to the independence of input and output. In Amulet, a special type of object called an interactor serves as the controller. Interactors are freely composable with graphical objects (views) and, using an abstraction called command objects, with models. <p> Command objects encapsulate everything about an action, including the status of the action being enabled, the mechanism for performing an action (the DO method), and support for UNDOing the action. Design Decision 2. Presentation interaction entities will be those provided by the Amulet <ref> [72] </ref> user interface toolkit. 92 Chapter 6 Control Correctness of MMTK MDL behavior expressions describe control in a reactive system. MDL programs compile into a communicating hierarchy of components in which each component implements a single operator or communication.
Reference: [73] <author> Brad A. Myers and Mary Beth Rosson. </author> <title> Survey on user interface programming. </title> <booktitle> In SIGCHI'92: Human Factors in Computing Systems, </booktitle> <month> 5 </month> <year> 1992. </year>
Reference-contexts: Systems which accommodate a human actor must provide user interfaces through which the actor receives input from and issues output to other system components. Experience has shown that user interfaces are difficult and costly to design and maintain. In fact, a survey done by Myers <ref> [73] </ref> points out that up to half of the development cost and delivered application are associated with designing and implementing the user interface. HCI researchers and software engineers have concentrated on this domain because of the huge potential in development savings.
Reference: [74] <author> R. Neches, J. Foley, P. Szekely, P. Sukaviriya, P. Luo, S. Kovacevic, and S. Hudson. </author> <title> Knowledgeable development environments using shared design models. </title> <booktitle> In Intelligent Interfaces Workshop, </booktitle> <pages> pages 63-70, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It is the thesis of this work that these weaknesses are symptomatic of an unclear delegation of responsibility in model-based code generation technology. Unlike traditional programming language compilers, interactive system code generators seems to require input from multiple models. The Mastermind project <ref> [18, 74] </ref> is concerned with the design, integration, and automatic generation of interactive systems from declarative models. <p> Unlike traditional programming language compilers, interactive system code generators seems to require input from multiple models. The Mastermind project [18, 74] is concerned with the design, integration, and automatic generation of interactive systems from declarative models. In the Mastermind environment <ref> [74, 97, 18] </ref>, interactive systems are subject to three kinds of models: * User task models specifying the protocols of end user interaction in the context of performing a task. <p> In this sense, presentation entities implement tasks which lends credence to the refinement analogy of binding. Moreover, binding is not fully automatable, but rather must be supported by design tools. In the Mastermind <ref> [74] </ref> vision, binding is postulated as a design phase in which tasks are treated as obligations which must be resolved by attaching presentation functionality. entity which simulates the task virtual machine mentioned earlier. It dispatches control to the Task Components which implement the MDL operators. <p> The Adept environment [58, 102] supports the evolution of task models throughout a system's lifetime. In addition to iterative task model support, Adept models can be refined into an implementation model for which there is a code generator. The Mastermind environment <ref> [74, 97, 18] </ref>, uses a task model as its design requirements model. 3.3.1.3 Presentation Modeling Systems generated from task and application models often have interfaces that are not highly graphical. <p> This is an important point because many of the model-based approaches generate UIMS scripts as their output. A natural conclusion is to extend these approaches with new models. The most common addition is an explicit presentation model. Humanoid [98], and now MASTERMIND <ref> [74] </ref>, provide a more elaborate presentation model. 3.3.2 The MASTERMIND Approach The Mastermind (Models Allowing Shared Tools and Explicit Representations Making Interfaces Natural to Develop) project uses explicit task, presentation, and application models for the design and implementation of interactive systems.
Reference: [75] <author> R. "De Nicola", A. Fantechi, S. Gnesi, and G. Ristori. </author> <title> An action-based framework for verifying logical and behavioural properties of concurrent systems. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 25(7) </volume> <pages> 761-78, </pages> <month> 2 </month> <year> 1993. </year>
Reference-contexts: They express dialogue using Olsen's Propositional Production System (PPS)[76] which has been shown to be equivalent in expressive power to the regular expressions. Abowd uses CTL to express these properties and uses SMV to check them. Paterno [67] uses a logic called ACTL <ref> [75] </ref> which can express equivalence relationships between CCS [68] terms. This relates task and system models which are both defined as Lotos processes in Paterno's framework. They use an ACTL [42] model checker to carry out these validations.
Reference: [76] <author> Dan R. Olsen. </author> <title> Propositional production systems for dialogue description. </title> <booktitle> In Empowering People-CHI'90 Conference Proceedings, </booktitle> <pages> pages 57-63, </pages> <year> 1990. </year>
Reference: [77] <author> P. Palanque, R. Bastide, and V. Senges. </author> <title> Validating interactive system design through the verification of formal task and system models. </title> <booktitle> In Working Conference on Engineering for Human Computer Interaction, </booktitle> <year> 1995. </year>
Reference: [78] <author> P. Palanque, F. Paterno', R. Bastide, and M. Mezzanotte. </author> <title> Towards an integrated proposal for interactive systems design based on tlim and ico. </title> <booktitle> In Third Eurographics Workshop on Design, Specification, Verification of Interactive Systems (DSV-IS'96), </booktitle> <year> 1996. </year>
Reference-contexts: Interactors are defined formally as Lotos processes [81], and can be related to task models specified in Lotos. This theory culminates in a methodology called TLIM for analyzing task models and system models (interactor-based). This is discussed in <ref> [78] </ref>. The idea is that by expressing a task as a Lotos process P T , an interactor-based solution can be derived from this specification.
Reference: [79] <author> Fabio Paterno'. </author> <title> Detection of properties of user interfaces. </title> <booktitle> In 5th International Conference on Software Engineering and Knowledge Engineering (SEKE'93), </booktitle> <year> 1993. </year> <month> 144 </month>
Reference-contexts: The popular idea is the use of model checking to validate properties of formal user interface specifications. This idea was first presented by Paterno <ref> [79] </ref>, and has been followed by Abowd et al.[3] and Paterno et al.[67]. The basic idea is that often formal specifications of user interfaces use only regular subsets of formal notations (like CSP and Lotos) and that many usability properties can be expressed using temporal logic.
Reference: [80] <author> Fabio Paterno'. </author> <title> A theory of user-interaction objects. </title> <journal> Journal of Visual Languages and Com--puting, </journal> <volume> 5 </volume> <pages> 227-249, </pages> <year> 1994. </year>
Reference-contexts: These give general guidelines for separating functionality into components and then linking these components into a final system. On the other end are rigorous semantic models of interactive software structure like Paterno's theory of interactors <ref> [80] </ref>. The thesis of our work is that multi-model composition must be rigorously specified. <p> The view is conceptually appealing because it evokes images of constructing an interactive system by wiring together independent components in much the same way one would wire up a hardware device. The most formal treatment of the approach is Paterno's theory of interactors <ref> [80] </ref>. The approach begins historically with the PAC architecture. The multi-agent frameworks like PAC decompose a user interface implementation by hierarchically distributing functionality. A PAC triad (presentation, abstraction, control), for example, decomposes into PAC sub-triads whose constituents are wired together to implement the higher level functionality. <p> It is claimed by Coutaz [29] that this distribution allows the structure of the software to better match the cognitive organization of human knowledge because it does not organize functionality into hermetic layers [6]. 42 Paterno's theory of interactors <ref> [80] </ref> adds precision and mathematical rigor to this connection-oriented view of interface composition. An interactor (not to be confused with the Amulet notion of an interactor) is a software component with a fixed set of incoming and outgoing data-flow paths.
Reference: [81] <author> Fabio Paterno', Maria Sabrina Sciacchitano, and Jonas Lowgren. </author> <title> A user interface evaluation mapping physical user actions to task-driven formal specifications. </title> <booktitle> In Second Eurographics Workshop on Design, Specification, Verification of Interactive Systems (DSV-IS'95), </booktitle> <year> 1995. </year>
Reference-contexts: In fact, Paterno identifies five different classes of composition which may be attained by connecting data paths in various configurations. Interactors are defined formally as Lotos processes <ref> [81] </ref>, and can be related to task models specified in Lotos. This theory culminates in a methodology called TLIM for analyzing task models and system models (interactor-based). This is discussed in [78].
Reference: [82] <author> G. Pfaff and P. ten Hagen, </author> <title> editors. </title> <booktitle> User Interface Management Systems: proceedings of the Workshop on User Interface Management Systems, held in Seeheim FRG. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: On one end of the spectrum are conceptual "architectures" like Seeheim and its derivatives <ref> [82, 9] </ref>, Model-View-Controller (MVC)[62], and Presentation-Abstraction-Control (PAC) [29]. These give general guidelines for separating functionality into components and then linking these components into a final system. On the other end are rigorous semantic models of interactive software structure like Paterno's theory of interactors [80]. <p> The first so-called UIMS architecture was presented at the Workshop on User Interface Management Systems in Seeheim Germany <ref> [82] </ref>. This architecture equated each of Foley's linguistic levels with a software component. In making the levels components, detail is encapsulated with access provided only through an application programming interface (API). Problems with the rigid approach in the Seeheim architecture led researchers to consider other manifestations of levels.
Reference: [83] <author> G. D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: Specifically, we use structural operational semantics <ref> [83] </ref> (SOS). SOS provides a way to systematically derive the meaning of a behavior expression from the syntax of the expression and is, therefore, a natural mechanism for describing the operators. In process notations like MDL, progress is made when a process performs an observable action. <p> This process is prepared to synchronize on either f or g, as represented by branching in the synchronization tree. We denote the tree edge which maps a process A into another process B as a result of synchronizing on event e, by: A e Plotkin <ref> [83] </ref> observed that we can define the meaning of an ordering operator as a pattern for constructing synchronization trees. Furthermore, these patterns can be expressed using axioms and inference rules.
Reference: [84] <author> A. Puerta. </author> <title> The mecano project: Comprehensive and integrated support for model-based user interface development. </title> <booktitle> In [99], </booktitle> <pages> pages 19-36. </pages> <publisher> Namur University Press, </publisher> <year> 1996. </year>
Reference-contexts: To this end, the Mastermind environment has a model server for storing and retrieving models at run-time. With dynamically queryable models, the Mastermind environment can support design critics and the management of context sensitive run-time help [94]. A similar vision was undertaken by the Mecano (now Mobi-D) project <ref> [85, 84] </ref>. Mobi-D uses an object oriented modeling language called MIMIC to describe and relate a multitude of models. 39 Mastermind is intimately concerned with generating applications from the models.
Reference: [85] <author> A. R. Puerta, H. Eriksson, J. H. Gennari, and M. A. Mussen. </author> <title> Beyond data models for automated user interface generation. </title> <booktitle> In People and Computers IX HCI'94 Conference Proceedings, </booktitle> <pages> pages 353-366. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1994. </year>
Reference-contexts: To this end, the Mastermind environment has a model server for storing and retrieving models at run-time. With dynamically queryable models, the Mastermind environment can support design critics and the management of context sensitive run-time help [94]. A similar vision was undertaken by the Mecano (now Mobi-D) project <ref> [85, 84] </ref>. Mobi-D uses an object oriented modeling language called MIMIC to describe and relate a multitude of models. 39 Mastermind is intimately concerned with generating applications from the models.
Reference: [86] <author> Wolfgang Reisig. </author> <title> Petri Nets: An Introduction, </title> <booktitle> volume 4 of Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Many of these approaches operate directly on software engineering models. The earliest applications of this approach began as semantic level extensions to UIMS architectures and technology. In Genius [55], designers specify data models and augment these with a behavior abstraction called a dialogue net 37 (similar to a Petri-net <ref> [86] </ref>). From these specifications, Genius uses a knowledge base to select in-teraction objects, arrange layout, and incorporate the dynamics into an executable implementation. <p> This aspect of control will, in general, be difficult to detect in a Lotos specification, although many task and interactor specifications use only a regular subset of Lotos. A concurrent modeling notation which captures this distributed locus of control is the Petri-net <ref> [86] </ref>. Petri-nets represent complex concurrent control by passing tokens along control paths in a graph. Palanque et al.[77] use a special variant of nets called hierarchical Petri-nets to represent the relationship of task models and system models in user interface software. <p> Unfortunately, in the beginning, we applied the methods poorly. We took the approach of 137 picking formalism X and trying to model all of the desired task and presentation functionality in X . Chronologically, formalism X was StateCharts [44], then Petri-nets <ref> [86] </ref>, and finally Mealy machines. The problem was we failed to identify acceptance criteria before plunging into the modeling phase. We spent weeks investigating Petri-nets and even began building a Petri-net simulator before realizing they did not compose well with our intended model of presentations.
Reference: [87] <author> Egbert Schlungbaum. </author> <title> Model-based user interface tools: Current state of declarative models. </title> <type> Technical Report GIT-GVU-96-30, </type> <institution> Graphics, Visualization and Usability Center (GVU), Georgia Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: Foley et al.[39] describe two types of models at this level: user-task models and application models. All of the model-based approaches contain at least one of these models, though, at present, different approachs use different models <ref> [87] </ref>. This section investigates current approaches to model-based code generation and identifies a software composition problem inherent in the approach. <p> These tools vary in the models they support and the notations used to express the models <ref> [87] </ref>. All of the approaches contain either a user task model, an application model, or both, with other models (like presentation) augmenting their functionality. We use these models as a basis for comparison. 3.3.1.1 Application Modeling The earlier model-based approaches chose the application model as the cornerstone.
Reference: [88] <author> Egbert Schlungbaum and Thomas Elwert. </author> <title> Dialogue graphs: A formal and visual specification technique for dialogue modelling. </title> <booktitle> In Formal Aspects of the Human Computer Interface, BCS-FACS Workshop, </booktitle> <year> 1996. </year>
Reference-contexts: Petri-nets can not only express concurrency but can also be simulated on sequential machinery by an interpreter. For this reason, they are often used as a target of translation from more abstract user interface description notations. The TADEUS environment <ref> [88] </ref> adopts this approach. 3.4.3 A Constraint Oriented View of Composition The connection-oriented approach to composition is familiar, but it is not the only possible mechanism for composing interactive system software. The approach we appeal to in this thesis views composition as the simultaneous satisfaction of multiple constraints.
Reference: [89] <author> F. B. Schneider. </author> <title> On Concurrent Programming. </title> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: An introduction to the use of temporal logic in concurrent systems programming is provided by Schneider <ref> [89] </ref>. Temporal operators include fl (read "henceforth"), (read "eventually"), and fl (read "next") to name a few.
Reference: [90] <author> J. L. Sibert, W. D. Hurley, and T. W. Bleser. </author> <title> Design and implementation of an object-oriented user interface management system. </title> <booktitle> In Advances in Human-Computer Interaction: </booktitle> <volume> Volume II [47]. </volume> <publisher> Ablex, </publisher> <address> Norwood, </address> <year> 1988. </year>
Reference-contexts: We believe this problem is inherent in automated approaches to interactive system development. As evidence of the problem, consider the following. In their work on the George Washington UIMS, Sibert et al. <ref> [90] </ref> commented that designers experienced difficulty when having to understand behavior at the boundary of the semantic, syntactic, and lexical levels. The success of tools and techniques that focus on a specific level, however, demonstrates that levels contain salient information which cannot be inferred from decisions made at higher levels.
Reference: [91] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: An interesting application of the constraint view of decomposition comes in the definition of simultaneous constraints over control and data. Suffrin and He [93], for example, combine CSP constructs with the ability to precisely define states using Z <ref> [91] </ref> schemas. Abowd's agents [1, 2] use a similar mixing of CSP and Z to support usability analysis. 3.5 Virtual Machine Design Our strategy for designing the MDL virtual machine and the MMTK toolkit is a twist on what has become a popular idea.
Reference: [92] <author> Kurt Stirewalt. </author> <title> The design and implementation of the mastermind toolkit (mmtk). </title> <type> Technical Report GIT-GVU-97-23, </type> <institution> Graphics, Visualization and Usability Center (GVU), Georgia Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: Mealy machines communicate by issuing signals over parent and child channels. In the current implementation, there are twelve such signals <ref> [92] </ref>. These signals communicate the control commands of one machine to another. When a machine m is issued one of these signals, it changes state, and it may, in turn, issue a signal to another machine. <p> We then validated the claim for configurations of arbitrary size by proving the Composition Adequacy Theorem. The next item is the collection of specific Mealy machine definitions. In the examples we have applied, we have not yet discovered a design flaw. The detailed designs appear in <ref> [92] </ref>. One final point to consider. We utilized a great deal of automation in translating MM definitions to SMV input configurations. The details of this translation are provided in the tool documentation [92]. <p> The detailed designs appear in <ref> [92] </ref>. One final point to consider. We utilized a great deal of automation in translating MM definitions to SMV input configurations. The details of this translation are provided in the tool documentation [92]. We did not formally prove that the correctness of the MM compiler. 8.2.2 Completeness of Presentation Linkage Inherent in our definition of binding was an assumption about the complexity of linking MMTK components to presentation components.
Reference: [93] <author> Bernard Suffrin and Jifeng He. </author> <title> Specification, analysis and refinement of interactive processes. In [45]. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: We, therefore, designed the MMTK to support this. 45 Others have looked at using constraint-oriented methods for separating user interface function-ality. An interesting application of the constraint view of decomposition comes in the definition of simultaneous constraints over control and data. Suffrin and He <ref> [93] </ref>, for example, combine CSP constructs with the ability to precisely define states using Z [91] schemas.
Reference: [94] <author> Piyawadee "Noi" Sukaviriya and James D. Foley. </author> <title> Coupling a UI framework with automatic Generation of context-sensitive animated help. </title> <booktitle> In ACM Symposium on User Interface Software and Technology, </booktitle> <year> 1990. </year> <month> 145 </month>
Reference-contexts: To this end, the Mastermind environment has a model server for storing and retrieving models at run-time. With dynamically queryable models, the Mastermind environment can support design critics and the management of context sensitive run-time help <ref> [94] </ref>. A similar vision was undertaken by the Mecano (now Mobi-D) project [85, 84]. Mobi-D uses an object oriented modeling language called MIMIC to describe and relate a multitude of models. 39 Mastermind is intimately concerned with generating applications from the models.
Reference: [95] <author> Piyawadee "Noi" Sukaviriya, James D. Foley, and Todd Griffith. </author> <title> A second generation user interface design environment: The model and runtime architecture. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference: [96] <editor> J. Sullivan and S. Tyler, editors. </editor> <title> Architectures for Intelligent User Interfaces. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference: [97] <author> P. Szekely, P. Sukaviriya, P. Castells, J. Muthukumarasamy, and E. Salcher. </author> <title> Declarative interface models for user interface construction tools : The mastermind approach. </title> <editor> In L. Bass and C. Unger, editors, </editor> <title> Engineering for Human-Computer Interaction [10]. </title> <publisher> Chapman & Hall, </publisher> <year> 1996. </year>
Reference-contexts: Unlike traditional programming language compilers, interactive system code generators seems to require input from multiple models. The Mastermind project [18, 74] is concerned with the design, integration, and automatic generation of interactive systems from declarative models. In the Mastermind environment <ref> [74, 97, 18] </ref>, interactive systems are subject to three kinds of models: * User task models specifying the protocols of end user interaction in the context of performing a task. <p> Model-based user interface development environments (MB-UIDE's) work on the premise that development and support environments may be built around declarative models of a system. Developers using this paradigm build interfaces by building models that describe the desired interface, rather than writing a program that exhibits the behavior <ref> [97] </ref>. Pre-cursors to the model based approach were UIMS architectures and application generators that began to support the semantic level of UI design. Foley et al.[39] describe two types of models at this level: user-task models and application models. <p> The Adept environment [58, 102] supports the evolution of task models throughout a system's lifetime. In addition to iterative task model support, Adept models can be refined into an implementation model for which there is a code generator. The Mastermind environment <ref> [74, 97, 18] </ref>, uses a task model as its design requirements model. 3.3.1.3 Presentation Modeling Systems generated from task and application models often have interfaces that are not highly graphical.
Reference: [98] <author> Pedro Szekely, Ping Luo, and Robert Neches. </author> <title> Beyond interface builders: Model-based interface tools. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: INTER-CHI'93, </booktitle> <pages> pages 383-390. </pages> <publisher> Addison Wesley, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: This research focuses on those models which most directly influence the user interface of an interactive system: user task models and presentation models. Specifically, we investigate the synthesis of these models into running systems and the techniques for automating this synthesis. Szekely <ref> [98] </ref> laments that while several model-based interface development tools have been built, none has achieved a level of maturity to generate industrial strength applications. It is the thesis of this work that these weaknesses are symptomatic of an unclear delegation of responsibility in model-based code generation technology. <p> This is an important point because many of the model-based approaches generate UIMS scripts as their output. A natural conclusion is to extend these approaches with new models. The most common addition is an explicit presentation model. Humanoid <ref> [98] </ref>, and now MASTERMIND [74], provide a more elaborate presentation model. 3.3.2 The MASTERMIND Approach The Mastermind (Models Allowing Shared Tools and Explicit Representations Making Interfaces Natural to Develop) project uses explicit task, presentation, and application models for the design and implementation of interactive systems.
Reference: [99] <editor> J. M. Vanderdonckt, editor. </editor> <booktitle> Computer Aided Design of User Interfaces. </booktitle> <publisher> Namur University Press, </publisher> <address> Namur, </address> <year> 1996. </year>
Reference: [100] <author> J. M. Vanderdonckt and F. </author> <title> Bodart. Encapsulating knowledge for intelligent automatic interaction objects selection. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference-contexts: As a result, interfaces generated by Genius have stereo-typical forms-based presentations. A similar data/behavior approach is used in the Trident environment <ref> [100] </ref>. Data models in Trident are expressed using entity-relationship diagrams, and the behavior is expressed using a notation called an activity chaining graph (ACG). In addition, Trident represents lexical attributes in the form of Abstract Interaction Objects (AIOs) and Concrete Interaction Objects (CIOs).
Reference: [101] <institution> Visual Edge Software Ltd., Cupertino, CA. Extending and Customizing UIMX, </institution> <year> 1993. </year>
Reference: [102] <author> S. Wilson, P. Johnson, C. Kelly, J. Cunningham, and P. Markopoulos. </author> <title> Beyond hacking: A model based approach to user interface design. </title> <editor> In J. L. Alty, D. Diaper, and S. Guest, editors, </editor> <booktitle> People and Computers VIII, Proceedings of the HCI '93 Conference, </booktitle> <pages> pages 217-231, </pages> <month> 9 </month> <year> 1993. </year>
Reference-contexts: On the 38 analysis side, tools like Glean [61] allow designers to analyze task models in terms of human mental cognition and observable human action (GOMS [22]). Other approaches view task models as evolving entities within the life cycle of an interactive system. The Adept environment <ref> [58, 102] </ref> supports the evolution of task models throughout a system's lifetime. In addition to iterative task model support, Adept models can be refined into an implementation model for which there is a code generator.
Reference: [103] <author> Jeannette M. Wing and Mandana Vaziri-Farahani. </author> <title> Model checking software systems: A case study. </title> <booktitle> In Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: In [54], Jackson and Damon apply these techniques to the design of a style editor in a word processor. Wing et al. also demonstrate the need for abstraction by applying model checking in a case study verifying the cache coherency protocol of a distributed file system <ref> [103] </ref>. Allen and Garlan [5] use the FDR [40] tool to check whether or not one CSP process is a refinement of another. In this thesis, we use the Symbolic Model Verifier (SMV)[66] from Carnegie Mellon University to verify the safe composition of our ordering components. <p> work is to identify some finite basis of configuration behavior and apply the model checker to elements in this basis. 111 7.2.1 A More Realistic Use of Model Checking In order to identify a finite set of model checking lemmas, we appealed to an insight suggested by Wing and Vaziri-Farahani <ref> [103] </ref> in their 1995 case study. They suggested model checking a finite state abstraction of an infinite state space (see Figure 30).
Reference: [104] <author> P. Zave and M. Jackson. </author> <title> Conjunction as composition. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(4) </volume> <pages> 371-411, </pages> <year> 1993. </year>
Reference-contexts: Each transformation in the series incorporates a different constraint. Successive transformations enrich a program from an abstract specification into a concrete executable application. Transformations enrich programs without violating their meaning. That is, constraints are additive <ref> [104] </ref>. We feel this is characteristic of how presentation models should relate to task models, and we contend that model-based environments which support task models should use the transformational constraint-oriented techniques for code generation. <p> The functionality of this operator is often used to separate complex behavior into a collection of interacting processes using a principle called composition by conjunction <ref> [104] </ref>. The idea is that complex temporal orderings can be expressed as the simultaneous satisfaction of multiple ordering constraints. The synchronization implied by the k operator is the agent of this simultaneity.
Reference: [105] <author> Pamela Zave. </author> <title> The operational versus the conventional approach to software development. </title> <journal> Communications of the ACM, </journal> <volume> 27(2), </volume> <month> 2 </month> <year> 1984. </year>
Reference-contexts: Of course, constraint oriented composition requires a different way of thinking about software synthesis [106]. Zave <ref> [105] </ref> suggests synthesizing a program by applying a series of transformations to an initial abstract program. Each transformation in the series incorporates a different constraint. Successive transformations enrich a program from an abstract specification into a concrete executable application. Transformations enrich programs without violating their meaning.
Reference: [106] <author> Pamela Zave. </author> <title> A compositional approach to multiparadigm programming. </title> <booktitle> IEEE Computer, </booktitle> <month> 9 </month> <year> 1989. </year>
Reference-contexts: The task model, on the other hand, expresses explicit sequencing within the global control of the system and employs a process notation. The problem of binding models is actually a problem of multi-paradigm composition <ref> [106] </ref>. Zave argues that in such situations, conceptual structures other than the familiar inter-language procedure call are necessary for composition. The conceptual structure we used views the realization of different models as processes and their binding as synchronizing composition. <p> Of course, constraint oriented composition requires a different way of thinking about software synthesis <ref> [106] </ref>. Zave [105] suggests synthesizing a program by applying a series of transformations to an initial abstract program. Each transformation in the series incorporates a different constraint. Successive transformations enrich a program from an abstract specification into a concrete executable application. Transformations enrich programs without violating their meaning.
References-found: 106

