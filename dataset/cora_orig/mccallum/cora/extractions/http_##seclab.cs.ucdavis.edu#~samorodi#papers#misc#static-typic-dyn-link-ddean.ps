URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/misc/static-typic-dyn-link-ddean.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/misc/
Root-URL: http://www.cs.ucdavis.edu
Title: The Security of Static Typing with Dynamic Linking  
Author: Drew Dean 
Address: 333 Ravenswood Avenue Menlo Park, CA 94025  
Affiliation: Computer Science Laboratory SRI International  
Abstract: Dynamic linking is a requirement for portable executable content. Executable content cannot know, ahead of time, where it is going to be executed, nor know the proper operating system interface. This imposes a requirement for dynamic linking. At the same time, we would like languages supporting executable content to be statically typable, for increased efficiency and security. Static typing and dynamic linking interact in a security-relevant way. This interaction is the subject of this paper. One solution is modeled in PVS, and formally proven to be safe. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> CARDELLI, L. </author> <title> A semantics of multiple inheritance. </title> <booktitle> Information and Computation 76 (1988), </booktitle> <pages> 138164. </pages>
Reference-contexts: Interface types fit nicely in the objects as records model <ref> [1] </ref>, so we can define structurally equivalent as having the same fields, where corresponding fields have the same type. For an implementation type Impl, we write Impl Inter for the corresponding interface type. The interested reader is referred to Fisher's thesis [6] for more details.
Reference: [2] <author> CARDELLI, L. </author> <title> Program fragments, linking, </title> <booktitle> and modular-ization. In Proceedings 24th ACM SIGPLAN-SIGACT Symposium on the Principles of Programming Languages (Jan. </booktitle> <year> 1997). </year> <note> To appear. </note>
Reference-contexts: While it accounts for forward references, it assumes that it is looking at an entire program in a closed world. It does not model the interleaving of type checking, linking, and program execution. Cardelli's recent work <ref> [2] </ref> addresses typesafety issues with separate compilation and linking. He introduces a simple language, the simply-typed calculus, with a primitive module system that supports separate compilation.
Reference: [3] <author> DEAN, D., FELTEN, E. W., AND WALL ACH, D. S. </author> <title> Java security: From HotJava to Netscape and beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy (May 1996), </booktitle> <pages> pp. </pages> <year> 190200. </year>
Reference-contexts: Java has become tremendously popular in 1995-96, primarily due to its support of embedding executable content in World Wide Web pages. Of course, executable content dramatically changes the security of the Web. Java was promoted as addressing the security issue; however, several problems have been found <ref> [3] </ref>. Java offers a new challenge to computer security: its protection mechanisms are all language-based. Of course, this is really fl This work was partially supported by DARPA through Rome Laboratory contract F30602-96-C-0204. <p> All security in Java depends upon these properties being enforced. While the work described here has been inspired by Java, and uses Java concepts and terminology, other systems that base their protection on language mechanisms face similar issues. One critical issue is the design of dynamic linking <ref> [3] </ref>. Since Java is a (mostly) statically typed language [10], there exists the potential for a Java applet to run in a different environment than the one in which it was verified, thus leading to a security problem. <p> The original Java Development Kit (JDK) implementation (JDK 1.0.2) did not place any restrictions on the behavior of ClassLoaders. This led to the complete breakage of type safety, where integers could be used as object references, and vice versa <ref> [3] </ref>. The type safety failure led to an untrusted applet being able to run arbitrary machine code, thus completely compromising the security of Java applets [4]. After discussion with Sun, language was added to the definition of Java [10] restricting ClassLoaders to safe behavior.
Reference: [4] <author> DEAN, D., FELTEN, E. W., AND WAL LACH, D. S. </author> <title> Java security: From HotJava to Netscape and beyond. In Computers Under Attack, </title> <editor> P. Denning, Ed., 2nd ed. </editor> <publisher> ACM Press, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: It was shown that the ability to break Java's type system leads to an attacker being able to run arbitrary machine code, at which point Java can make no security claims <ref> [4] </ref>. While type theory is a well developed field, there has been relatively little work on the semantics of linking, and less work where linking is a security-critical operation. This paper addresses the design of a typesafe dynamic linking system. <p> This led to the complete breakage of type safety, where integers could be used as object references, and vice versa [3]. The type safety failure led to an untrusted applet being able to run arbitrary machine code, thus completely compromising the security of Java applets <ref> [4] </ref>. After discussion with Sun, language was added to the definition of Java [10] restricting ClassLoaders to safe behavior. Code to implement this restriction (essentially the same as the linking restriction) has not yet shipped, but is expected shortly in JDK 1.1.
Reference: [5] <author> DROSSOPOULOU, S., AND EISENBACH, S. </author> <booktitle> Is the Java type system sound? In Proceedings of the Fourth International Workshop on Foundations of ObjectOriented Languages (Paris, </booktitle> <month> Jan. </month> <year> 1997). </year> <note> To appear. </note>
Reference-contexts: Well-designed languages have module systems that provide support for separate compilation without these problems [21, 13]. C++ introduced name mangling as a way to encode type information into linking, to prevent inter-module type errors while still using standard linkers [20]. 4 Drossopoulou and Eisenbach's recent work <ref> [5] </ref> considers the type safety of a subset of Java. While it accounts for forward references, it assumes that it is looking at an entire program in a closed world. It does not model the interleaving of type checking, linking, and program execution. <p> The intuitive reading of this proposition is that we can consistently extend the environment without changing typing judgments in a type system that satisfies the proposition. A rigorous proof of this would require a formalization of the Java type system (see <ref> [5] </ref> for work in this direction), and is beyond the scope of this paper. The above definitions are all well and good, but how do they relate to security? Consider a user preparing to run a Java applet embedded in a Web page. <p> The concept, though, is generic: any language whose type system satisfies Proposition 1 (and most do) can use the results of this paper. Given an operational semantics for the language under inspection, a completely formal safety proof can be constructed. Drossopoulou and Eisenbach's work <ref> [5] </ref> is a good beginning, but was not available when this work began. The second contribution is a proof that the requirements of Proposition 1 are satisfied by our model. Here the proofs are discussed at a high level; PVS takes care of the details.
Reference: [6] <author> FISHER, K. </author> <title> Type Systems for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1996. </year>
Reference-contexts: For an implementation type Impl, we write Impl Inter for the corresponding interface type. The interested reader is referred to Fisher's thesis <ref> [6] </ref> for more details. We need to define some standard terms from type-theory before we proceed.
Reference: [7] <author> FISHER, K., AND MITCHEL L, J. C. </author> <title> On the relationship between classes, objects, and data abstraction. </title> <booktitle> In Proceedings of the 17th International Summer School on Mathematics of Program Construction (Marktoberdorf, </booktitle> <address> Germany, </address> <year> 1996), </year> <note> LNCS, Springer-Verlag. To appear. </note>
Reference-contexts: We use Fisher and Mitchell's model <ref> [7] </ref>, where classes are in 1 1 correspondence with implementation types, and implementation types are subtypes of interface types, which define the externally visible structure of the class. (Interface types roughly correspond to Java interfaces.) We say that A is a subtype of B, written A B, if an expression of
Reference: [8] <author> GINGE LL, R. A., LEE, M., DANG, X. T., AND WEEKS, M. S. </author> <title> Shared libraries in SunOS. </title> <booktitle> In USENIX Conference Proceedings (Phoenix, </booktitle> <address> AZ, </address> <year> 1987), </year> <pages> pp. 131145. </pages>
Reference-contexts: The alternative strategy is dynamic linking. Although dynamic linking is an old idea (appearing in Mul-tics [15], among other systems), it did not become popular in the Unix and PC worlds until the late 1980s to early 1990s, with the advent of systems such as SunOS 4.0 <ref> [8] </ref> and Microsoft Windows. <p> Janson argues that the Multics dynamic linker is not security-relevant, so it should not be part of the security kernel. His redesign of dynamic linking moves it into each process, where it happens in user mode rather than kernel mode. (The SunOS 4 dynamic linker design <ref> [8] </ref> is very similar.) However, dynamic linking in Java is security-relevant, unlike Multics, where hardware-based rings were used for protection. The situation in Java is different from either of the above situations.
Reference: [9] <author> GOLDBERG, I., AND WAGNER, D. </author> <title> Randomness and the netscape browser. </title> <journal> Dr. Dobb's Journal (Jan. </journal> <year> 1996). </year>
Reference-contexts: The SSL and S-HTTP protocols were designed to provide cryptographically strong identification of Web servers, and privacy protection for information such as credit card numbers. While an early implementation of SSL had a problem seeding its random number generator <ref> [9] </ref>, and cryptographic protocols are always tricky to design, the situation appeared to be well in hand. Then Java 1 [10] arrived. Java has become tremendously popular in 1995-96, primarily due to its support of embedding executable content in World Wide Web pages.
Reference: [10] <author> GOSLING, J., JOY, B., AND STEELE, G. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: While an early implementation of SSL had a problem seeding its random number generator [9], and cryptographic protocols are always tricky to design, the situation appeared to be well in hand. Then Java 1 <ref> [10] </ref> arrived. Java has become tremendously popular in 1995-96, primarily due to its support of embedding executable content in World Wide Web pages. Of course, executable content dramatically changes the security of the Web. Java was promoted as addressing the security issue; however, several problems have been found [3]. <p> While the work described here has been inspired by Java, and uses Java concepts and terminology, other systems that base their protection on language mechanisms face similar issues. One critical issue is the design of dynamic linking [3]. Since Java is a (mostly) statically typed language <ref> [10] </ref>, there exists the potential for a Java applet to run in a different environment than the one in which it was verified, thus leading to a security problem. <p> This paper considers the security-critical interaction of linking and type checking. 3 Informal Problem Statement The Java runtime system may interleave type checking, linking, and program execution <ref> [10] </ref>. The implementation from JavaSoft (and used by Netscape in their Web browser) takes advantage of this freedom. Since most implementations of Java are statically typed, we need to be sure that a linking action cannot invalidate the results of previously performed type checking. <p> Two implementation types are the same iff they have the same name. (In Java, two classes are the same iff they have the same name and the same classloader <ref> [10] </ref>.) Two interface types are the same if they are structurally equivalent. Interface types fit nicely in the objects as records model [1], so we can define structurally equivalent as having the same fields, where corresponding fields have the same type. <p> The type safety failure led to an untrusted applet being able to run arbitrary machine code, thus completely compromising the security of Java applets [4]. After discussion with Sun, language was added to the definition of Java <ref> [10] </ref> restricting ClassLoaders to safe behavior. Code to implement this restriction (essentially the same as the linking restriction) has not yet shipped, but is expected shortly in JDK 1.1. The absence of the linking restriction directly led to two prob lems in the JDK 1.0.2 implementation: 1.
Reference: [11] <author> JANSON, P. A. </author> <title> Removing the dynamic linker from the security kernel of a computing utility. </title> <type> Master's thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> June </month> <year> 1974. </year> <note> Project MAC TR-132. </note>
Reference-contexts: Janson's work <ref> [11] </ref> removes dynamic linking from the Mul-tics kernel. Janson argues that the Multics dynamic linker is not security-relevant, so it should not be part of the security kernel.
Reference: [12] <author> LINCOLN, P., AND RUSHBY, J. </author> <title> Formal verification of an algorithm for interactive consistency under a hybrid fault model. In Computer-Aided Verification, </title> <booktitle> CAV '93 (Elounda, </booktitle> <address> Greece, </address> <month> June/July </month> <year> 1993), </year> <editor> C. Courcoubetis, Ed., </editor> <volume> vol. </volume> <booktitle> 697 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 292304. </pages>
Reference-contexts: PVS has been used to verify many different projects, including a microprocessor [19], floating point division [18], fault-tolerant algorithms <ref> [12] </ref>, and multimedia frameworks [17], by users at SRI and other sites. PVS combines a specification language with a va riety of theorem proving tools.
Reference: [13] <author> MILNER, R., TOFTE, M., AND HARPER, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Since protection in Java depends on preventing users from forging object references, such a type mismatch would completely undermine the system. Well-designed languages have module systems that provide support for separate compilation without these problems <ref> [21, 13] </ref>. C++ introduced name mangling as a way to encode type information into linking, to prevent inter-module type errors while still using standard linkers [20]. 4 Drossopoulou and Eisenbach's recent work [5] considers the type safety of a subset of Java.
Reference: [14] <author> MITCHELL, J. C. </author> <title> Type systems for programming languages. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <editor> J. van Leeuwen, Ed., </editor> <volume> vol. </volume> <editor> B: </editor> <title> Formal Models and Semantics. </title> <publisher> Else-vier Science Publishers B.V., </publisher> <year> 1990, </year> <note> ch. 8. </note>
Reference-contexts: We write ` M : t to mean that M has type t in context ; this is called a typing judgment. We assume the following proposition holds: Proposition 1 If ` M : t and 0 ; then 0 The justification for this proposition can be found in <ref> [14] </ref>; it is a combination of Mitchell's (add hyp) axiom and his Lemmas 2.2.1 and 2.2.2. The intuitive reading of this proposition is that we can consistently extend the environment without changing typing judgments in a type system that satisfies the proposition.
Reference: [15] <author> ORGANICK, E. </author> <title> The Multics System: An Examination of its Structure. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1972. </year> <month> 6 </month>
Reference-contexts: Static linking copies code (e.g., the 2 Unix is a registered trademark of X/Open, Inc. 1 standard C library's printf () function) and data from the run--time libraries into the executable output. The alternative strategy is dynamic linking. Although dynamic linking is an old idea (appearing in Mul-tics <ref> [15] </ref>, among other systems), it did not become popular in the Unix and PC worlds until the late 1980s to early 1990s, with the advent of systems such as SunOS 4.0 [8] and Microsoft Windows.
Reference: [16] <author> OWRE, S., SHANKAR, N., AND RUSHBY, J. M. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> Feb. </month> <year> 1993. </year> <title> Three volumes: Language, System, and Prover Reference Manuals; A new edition for PVS Version 2 is expected in late 1996. </title>
Reference-contexts: The rest of the paper is structured as follows. Section 2 discusses related work, Section 3 gives an informal statement of the problem, Section 4 informally discusses the problem, its ramifications, and solution, Section 5 discusses the formal treatment of the problem in PVS <ref> [16] </ref>, Section 6 briefly discusses implementation and assurance issues, and Section 7 concludes. The PVS specification is provided in an appendix. 2 Related Work There has been very little recent work in linking. <p> It proves that the initial context (here, a cut down version of the Java runtime library) is consistent. The combination of these properties is an inductive proof of the safety of the system. 5 Formal Treatment in PVS PVS <ref> [16] </ref> 6 is the PROTOTYPE VERIFICATION SYSTEM, the current SRI research project in formal methods and theorem proving. PVS has been used to verify many different projects, including a microprocessor [19], floating point division [18], fault-tolerant algorithms [12], and multimedia frameworks [17], by users at SRI and other sites.
Reference: [17] <author> RAJAN, S., RANGAN, P. V., AND VIN, H. M. </author> <title> A formal basis for structured multimedia collaborations. </title> <booktitle> In Proceedings of the 2nd IEEE International Conference on Multimedia Computing and Systems (Washington, </booktitle> <address> DC, </address> <month> May </month> <year> 1995), </year> <journal> IEEE Computer Society, </journal> <pages> pp. </pages> <year> 194201. </year>
Reference-contexts: PVS has been used to verify many different projects, including a microprocessor [19], floating point division [18], fault-tolerant algorithms [12], and multimedia frameworks <ref> [17] </ref>, by users at SRI and other sites. PVS combines a specification language with a va riety of theorem proving tools. Proposition 1 states that security is preserved if a program is linked and run in a consistent extension of the type context it was compiled in.
Reference: [18] <author> RUESS, H., SHANKAR, N., AND SRIVAS, M. K. </author> <title> Modular verification of SRT division. In Computer-Aided Verification, </title> <address> CAV '96 (New Brunswick, NJ, </address> <month> July/August </month> <year> 1996), </year> <editor> R. Alur and T. A. Henzinger, Eds., </editor> <volume> vol. </volume> <booktitle> 1102 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 123134. </pages>
Reference-contexts: PVS has been used to verify many different projects, including a microprocessor [19], floating point division <ref> [18] </ref>, fault-tolerant algorithms [12], and multimedia frameworks [17], by users at SRI and other sites. PVS combines a specification language with a va riety of theorem proving tools.
Reference: [19] <author> SRIVAS, M. K., AND MILLER, S. P. </author> <title> Formal verification of the AAMP5 microprocessor. In Applications of Formal Methods, </title> <editor> M. G. Hinchey and J. P. Bowen, Eds., </editor> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1995, </year> <journal> ch. </journal> <volume> 7, </volume> <pages> pp. 125180. </pages>
Reference-contexts: PVS has been used to verify many different projects, including a microprocessor <ref> [19] </ref>, floating point division [18], fault-tolerant algorithms [12], and multimedia frameworks [17], by users at SRI and other sites. PVS combines a specification language with a va riety of theorem proving tools.
Reference: [20] <author> STROUSTRUP, B. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Well-designed languages have module systems that provide support for separate compilation without these problems [21, 13]. C++ introduced name mangling as a way to encode type information into linking, to prevent inter-module type errors while still using standard linkers <ref> [20] </ref>. 4 Drossopoulou and Eisenbach's recent work [5] considers the type safety of a subset of Java. While it accounts for forward references, it assumes that it is looking at an entire program in a closed world. It does not model the interleaving of type checking, linking, and program execution.
Reference: [21] <author> WIRTH, N. </author> <title> Programming in Modula-2, 2nd ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year> <month> 7 </month>
Reference-contexts: Since protection in Java depends on preventing users from forging object references, such a type mismatch would completely undermine the system. Well-designed languages have module systems that provide support for separate compilation without these problems <ref> [21, 13] </ref>. C++ introduced name mangling as a way to encode type information into linking, to prevent inter-module type errors while still using standard linkers [20]. 4 Drossopoulou and Eisenbach's recent work [5] considers the type safety of a subset of Java.
References-found: 21

