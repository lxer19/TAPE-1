URL: ftp://ftp.cs.uoregon.edu/pub/ariola/TACS97.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Email: email: ariola@cs.uoregon.edu  email: sccblom@cs.vu.nl  
Phone: 2  
Title: Cyclic Lambda Calculi  
Author: Zena M. Ariola and Stefan Blom 
Address: OR 97401, USA  Boelelaan 1081a, 1081 HV Amsterdam  
Affiliation: 1 Department of Computer Information Sciences University of Oregon. Eugene,  Department of Mathematics and Computer Science Vrije Universiteit, De  
Abstract: We precisely characterize a class of cyclic lambda-graphs, and then give a sound and complete axiomatization of the terms that represent a given graph. The equational axiom system is an extension of lambda calculus with the letrec construct. In contrast to current theories, which impose restrictions on where the rewriting can take place, our theory is very liberal, e.g., it allows rewriting under lambda-abstractions and on cycles. As shown previously, the reduction theory is non-confluent. We thus introduce an approximate notion of confluence. Using this notion we define the infinite normal form or Levy-Longo tree of a cyclic term. We show that the infinite normal form defines a congruence on the set of terms. We relate our cyclic lambda calculus to the traditional lambda calculus and to the infinitary lambda calculus. Since most implementations of non-strict functional languages rely on sharing to avoid repeating computations, we develop a variant of our calculus that enforces the sharing of computations and show that the two calculi are observationally equivalent. For reasoning about strict languages we develop a call-by-value variant of the sharing calculus. We state the difference between strict and non-strict computations in terms of different garbage collection rules. We relate the call-by-value calculus to Moggi's computational lambda calculus and to Hasegawa's calculus.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 375-416, </pages> <year> 1991. </year>
Reference-contexts: We also point out that the axioms to distribute the substitution across a term in a stepwise manner, which are present in the explicit substitution calculi <ref> [1, 35] </ref>, are derivable in our calculus and that they generate the same model. 8 The Cyclic Sharing Calculus ffi share A drawback of the cyclic lambda calculus is that it does not support sharing adequately, since it allows reductions that duplicate work.
Reference: 2. <author> Z. M. Ariola. </author> <title> Relating graph and term rewriting via Bohm models. Applicable Algebra in Engineering, </title> <journal> Communication and Computing, </journal> <volume> 7(5), </volume> <year> 1996. </year>
Reference-contexts: standard rewrites to N (M 7! ffi N ) if M E [R] ! ffi E [R 0 ] N , where R and R 0 stand for a ffi eval -redex and its contractum, and E is defined as follows: E ::= x:E j hE j Di j App <ref> [2; M 1 ; ; M n ] </ref> j App [y; M 1 ; E ; M n ] App ::= 2 j App2 j hApp j Di where the y must be bound by a lambda or free in the final expression. <p> The redex (z:z)(z:z) in hx j x = yi (z:z)(z:z) is not a standard redex, since hx j x = yi2 6= E <ref> [2] </ref>. To make it standard, an external substitution step must first take place. Proposition 27. Given M; N 2 flffi. If M ffi! ffi N then M ' name N . Lemma 28. <p> Theorem 32. Given M; N 2 flffi. If Inf ffi (M ) = Inf ffi (N ) then Inf ffi (C [M ]) = Inf ffi (C [N ]). 7 The Cyclic Lambda Calculus, the Traditional Lambda Calculus and the Infinitary Lambda Calculus As it was done in <ref> [2] </ref> for the first-order case, we can use the model to relate ffi to the traditional lambda calculus. We show that cycles can be explained in terms of their expansions, which are finite lambda calculus terms.
Reference: 3. <author> Z. M. Ariola and S. Blom. </author> <title> Lambda calculi plus letrec. </title> <type> Technical Report CIS-TR--97-05, </type> <institution> Department of computer and information science, University of Oregon. ftp://ftp.cs.uoregon.edu/pub/ariola/cyclic-calculi.ps. </institution>
Reference-contexts: The call-by-value calculus is then equipped with a term model, which allows us to relate our calculus to the commutative version of Moggi's computational lambda calculus [30] and to the recently developed calculus of Hasegawa [18]. The reader can refer to <ref> [3] </ref> for a detailed exposition and the proofs. 2 Graphs as Terms and Terms as Graphs In this section we establish an isomorphism between cyclic lambda-graphs and their syntactic representations. <p> The sharing calculus is the kernel language of Haskell and the functional core of Id and Parallel Haskell. The call-by-value calculus is the functional kernel of languages such as SML. In <ref> [3] </ref> we have also shown how to extend our calculi with data-structures. What distinguishes our calculi from current theories is that we do not impose any restrictions on where the rewriting takes place. This makes our theories useful for reasoning about not only run-time issues but also about compilation issues.
Reference: 4. <author> Z. M. Ariola and M. Felleisen. </author> <title> The call-by-need lambda calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 7(3), </volume> <year> 1997. </year>
Reference-contexts: 0 j C [x:C 0 ] j C [C 0 M ] j C [M C 0 ] C 0 ::= 2 j hC 0 j Di : The sharing calculus adds naming, since it is no longer derivable. ffi share extends the cyclic calculus ( need ) presented in <ref> [4, 5] </ref>, since reductions may occur when they are not needed. For example, need disallows the reduction hx j x = y:wx; w = z:zi!!hx j x = y:(z:z)xi!!hx j x = y:xi. Moreover, in [4, 5], the soundness and completeness of need with respect to traditional lambda calculus were limited <p> is no longer derivable. ffi share extends the cyclic calculus ( need ) presented in <ref> [4, 5] </ref>, since reductions may occur when they are not needed. For example, need disallows the reduction hx j x = y:wx; w = z:zi!!hx j x = y:(z:z)xi!!hx j x = y:xi. Moreover, in [4, 5], the soundness and completeness of need with respect to traditional lambda calculus were limited to the acyclic case. 8.1 Soundness and Completeness of ffi share with respect to ffi name Soundness of ffi share follows from the fact that the sharing theory is a subset of the call-by-name theory. <p> In <ref> [4, 5] </ref>, we proved the completeness of (acyclic) need with respect to lambda calculus using a simple invariant: if M ! name !N then 9P; N 0 ; M ! need !P; N ! name !N 0 and N 0 P . <p> On the set of cyclic terms we have developed three cyclic lambda calculi. These calculi correspond to the parameter-passing techniques of call-by-name, call-by-need and call-by-value. The ability to define mutually recursive objects makes these calculi more suitable then lambda calculus [13], need <ref> [5, 4] </ref> and V [34] to express the operational semantics, compilation and optimization of current functional languages. The sharing calculus is the kernel language of Haskell and the functional core of Id and Parallel Haskell. The call-by-value calculus is the functional kernel of languages such as SML.
Reference: 5. <author> Z. M. Ariola, M. Felleisen, J. Maraist, M. Odersky, and P. Wadler. </author> <title> The call-by-need lambda calculus. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 233-246, </pages> <year> 1995. </year>
Reference-contexts: 0 j C [x:C 0 ] j C [C 0 M ] j C [M C 0 ] C 0 ::= 2 j hC 0 j Di : The sharing calculus adds naming, since it is no longer derivable. ffi share extends the cyclic calculus ( need ) presented in <ref> [4, 5] </ref>, since reductions may occur when they are not needed. For example, need disallows the reduction hx j x = y:wx; w = z:zi!!hx j x = y:(z:z)xi!!hx j x = y:xi. Moreover, in [4, 5], the soundness and completeness of need with respect to traditional lambda calculus were limited <p> is no longer derivable. ffi share extends the cyclic calculus ( need ) presented in <ref> [4, 5] </ref>, since reductions may occur when they are not needed. For example, need disallows the reduction hx j x = y:wx; w = z:zi!!hx j x = y:(z:z)xi!!hx j x = y:xi. Moreover, in [4, 5], the soundness and completeness of need with respect to traditional lambda calculus were limited to the acyclic case. 8.1 Soundness and Completeness of ffi share with respect to ffi name Soundness of ffi share follows from the fact that the sharing theory is a subset of the call-by-name theory. <p> In <ref> [4, 5] </ref>, we proved the completeness of (acyclic) need with respect to lambda calculus using a simple invariant: if M ! name !N then 9P; N 0 ; M ! need !P; N ! name !N 0 and N 0 P . <p> On the set of cyclic terms we have developed three cyclic lambda calculi. These calculi correspond to the parameter-passing techniques of call-by-name, call-by-need and call-by-value. The ability to define mutually recursive objects makes these calculi more suitable then lambda calculus [13], need <ref> [5, 4] </ref> and V [34] to express the operational semantics, compilation and optimization of current functional languages. The sharing calculus is the kernel language of Haskell and the functional core of Id and Parallel Haskell. The call-by-value calculus is the functional kernel of languages such as SML.
Reference: 6. <author> Z. M. Ariola and J. W. Klop. </author> <title> Lambda calculus with explicit recursion. </title> <type> Technical Report CIS-TR-96-04, </type> <institution> Department of computer and information science, University of Oregon. </institution> <note> To appear in Information and computation. </note>
Reference-contexts: Presentation of such a theory is the goal of this paper. What makes a theory of cycles difficult to develop is that confluence is lost once lambda-abstraction and cycles are admitted, unless the theory is powerful enough to represent irregular structures as shown in <ref> [6, 7] </ref>. To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle [6, 7, 15, 31, 35], or adopt a framework based on interaction nets [24]. <p> To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle <ref> [6, 7, 15, 31, 35] </ref>, or adopt a framework based on interaction nets [24]. As discussed in [28] and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity. <p> The same formalism was already introduced in [8] for the first-order case, and extended with lambda-abstraction in <ref> [6, 7] </ref>. However, in that work a precise connection between terms and lambda-graphs was not established. Definition 5. <p> In <ref> [6] </ref> we have called the subterm xy of hx j x = y:xyi an implicit fi-redex which needs to be made explicit, i.e., of the form (x:P )Q, in order to be reduced. <p> By a similar argument, we have introduced a more general form of the garbage collection axiom which allows us to remove subsets of equations. The main difference between ffi name and the -calculi <ref> [6, 7] </ref> involves the substitution and merge operations. Here, these operations may occur in any context, whereas in [6, 7] they cannot occur on a cycle. <p> The main difference between ffi name and the -calculi <ref> [6, 7] </ref> involves the substitution and merge operations. Here, these operations may occur in any context, whereas in [6, 7] they cannot occur on a cycle. For example, the - calculi disallow the step hx j x = z:y (Sz); y = w:x (Sw)i ! hx j x = z:(w:x (Sw))(Sz); y = w:x (Sw)i. <p> If the above step were allowed then confluence would have been lost, since the acylic substitution for y is turned into a cyclic substitution once the internal letrec is removed. In summary, in <ref> [6, 7] </ref>, the focus was on finding a confluent calculus that could express cyclic lambda graph rewriting. Instead, we do not take confluence as the guiding factor in designing the calculus. Thus, we do not restrict the calculus, but introduce a new way of proving the consistency of the calculus. <p> To define call-by-value expansions, we introduce the notation M ! GK (as) ! n N which denotes n-steps of the Gross-Knuth strategy applied to acyclic value substitution redexes occurring in M . The notion of acyclic substitution redex is taken from <ref> [6] </ref>. An acyclic value substitution redex is any value substitution redex that is not of the form hM j x = C [y]; y = V; Di, where x and y are mutually recursive.
Reference: 7. <author> Z. M. Ariola and J. W. Klop. </author> <title> Cyclic lambda graph rewriting. </title> <booktitle> In Proc. Ninth Symposium on Logic in Computer Science (LICS'94), Paris, France, </booktitle> <pages> pages 416-425, </pages> <year> 1994. </year>
Reference-contexts: Presentation of such a theory is the goal of this paper. What makes a theory of cycles difficult to develop is that confluence is lost once lambda-abstraction and cycles are admitted, unless the theory is powerful enough to represent irregular structures as shown in <ref> [6, 7] </ref>. To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle [6, 7, 15, 31, 35], or adopt a framework based on interaction nets [24]. <p> To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle <ref> [6, 7, 15, 31, 35] </ref>, or adopt a framework based on interaction nets [24]. As discussed in [28] and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity. <p> The same formalism was already introduced in [8] for the first-order case, and extended with lambda-abstraction in <ref> [6, 7] </ref>. However, in that work a precise connection between terms and lambda-graphs was not established. Definition 5. <p> The R 1 representational calculus is sound with respect to tree unwinding. To guarantee completeness we need another axiom, as was already pointed out in <ref> [7] </ref> for the first-order case. <p> By a similar argument, we have introduced a more general form of the garbage collection axiom which allows us to remove subsets of equations. The main difference between ffi name and the -calculi <ref> [6, 7] </ref> involves the substitution and merge operations. Here, these operations may occur in any context, whereas in [6, 7] they cannot occur on a cycle. <p> The main difference between ffi name and the -calculi <ref> [6, 7] </ref> involves the substitution and merge operations. Here, these operations may occur in any context, whereas in [6, 7] they cannot occur on a cycle. For example, the - calculi disallow the step hx j x = z:y (Sz); y = w:x (Sw)i ! hx j x = z:(w:x (Sw))(Sz); y = w:x (Sw)i. <p> If the above step were allowed then confluence would have been lost, since the acylic substitution for y is turned into a cyclic substitution once the internal letrec is removed. In summary, in <ref> [6, 7] </ref>, the focus was on finding a confluent calculus that could express cyclic lambda graph rewriting. Instead, we do not take confluence as the guiding factor in designing the calculus. Thus, we do not restrict the calculus, but introduce a new way of proving the consistency of the calculus.
Reference: 8. <author> Z. M. Ariola and J. W. Klop. </author> <title> Equational term graph rewriting. </title> <note> Fundamentae Informaticae, 26(3,4):207-240, 1996. Extended version: CWI Report CS-R9552. </note>
Reference-contexts: The same formalism was already introduced in <ref> [8] </ref> for the first-order case, and extended with lambda-abstraction in [6, 7]. However, in that work a precise connection between terms and lambda-graphs was not established. Definition 5.
Reference: 9. <author> Z. M. Ariola, J. W. Klop, J. R. Kennaway, F. J. de Vries, and M. R. Sleep. </author> <title> Syntactic definitions of undefined: On defining the undefined. </title> <booktitle> In Proc. TACS 94, Sendai, </booktitle> <address> Japan, </address> <year> 1994. </year>
Reference-contexts: The black hole denotes provable non-termination. It was already introduced in the first-order case to be able to reduce a cyclic graph in the presence of collapsing rules, i.e., rules of the form Ix ! x. A more thorough discussion of the black hole is given in <ref> [9] </ref>.
Reference: 10. <author> Arvind, L. Augusston, J. Hicks, R. S. Nikhil, S. Peyton-Jones, J. Stoy, and W. Williams. pH: </author> <title> A Parallel Haskell. </title> <type> Technical report, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Theorem 40. Given M 2 flffi. Inf ffi (M ) = Inf share (M ). ffi share captures the essence of lazy languages, such as Haskell [19], and of the functional core of lenient languages, such as Id [32, 11] and Parallel Haskell <ref> [10] </ref>. This is substantiated by the fact that both the lazy and lenient strategies are complete with respect to different observations. The lazy strategy, as described by Launchbury [25], only allows one to reach the top stable information.
Reference: 11. <author> Arvind, J-W. Maessen, R.S. Nikhil, and J. E. Stoy. </author> <title> s : an implicitly parallel - calculus with letrec, synchronization and side-effects. </title> <type> Technical Report 393, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1997. </year>
Reference-contexts: Theorem 40. Given M 2 flffi. Inf ffi (M ) = Inf share (M ). ffi share captures the essence of lazy languages, such as Haskell [19], and of the functional core of lenient languages, such as Id <ref> [32, 11] </ref> and Parallel Haskell [10]. This is substantiated by the fact that both the lazy and lenient strategies are complete with respect to different observations. The lazy strategy, as described by Launchbury [25], only allows one to reach the top stable information.
Reference: 12. <author> A. Asperti and C. Laneve. </author> <title> Interaction systems I: The theory of optimal reductions. </title> <booktitle> Mathematical structures for computer science, </booktitle> <volume> 4 </volume> <pages> 457-504, </pages> <year> 1994. </year>
Reference-contexts: To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle [6, 7, 15, 31, 35], or adopt a framework based on interaction nets [24]. As discussed in [28] and <ref> [12] </ref>, cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity.
Reference: 13. <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: On the set of cyclic terms we have developed three cyclic lambda calculi. These calculi correspond to the parameter-passing techniques of call-by-name, call-by-need and call-by-value. The ability to define mutually recursive objects makes these calculi more suitable then lambda calculus <ref> [13] </ref>, need [5, 4] and V [34] to express the operational semantics, compilation and optimization of current functional languages. The sharing calculus is the kernel language of Haskell and the functional core of Id and Parallel Haskell. The call-by-value calculus is the functional kernel of languages such as SML.
Reference: 14. <author> H. P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Term graph rewriting. </title> <editor> In J. W. de Bakker, A. J. Nijman, and P. C. Treleaven, editors, </editor> <booktitle> Proc. Conference on Parallel Architecture and Languages Europe (PARLE '87), </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <pages> pages 141-158, </pages> <year> 1987. </year>
Reference-contexts: We start by introducing a basic formalism for cyclic lambda-graphs in a format similar to the one used for first-order term graphs in <ref> [14] </ref>. 2.1 Cyclic Lambda-graphs and Scoped Lambda-graphs Following an idea used by Bourbaki in Elements de Theorie des Ensembles to deal with quantifiers, an occurrence of a bound variable in a lambda-graph is represented by a back-pointer to the corresponding binding lambda-node.
Reference: 15. <author> Z. Benaissa, P. Lescanne, and K.H. Rose. </author> <title> Modeling sharing and recursion for weak reduction strategies using explicit substitution. </title> <booktitle> In PLIP'96, </booktitle> <year> 1996. </year>
Reference-contexts: To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle <ref> [6, 7, 15, 31, 35] </ref>, or adopt a framework based on interaction nets [24]. As discussed in [28] and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity.
Reference: 16. <author> S. Billot and B. Lang. </author> <title> The structure of shared forests in ambiguous parsing. </title> <booktitle> In Proceedings of the Twenty-Seventh Annual Meeting of the Association for Computational Linguistics, 1989. Association for Computational Linguistics. </booktitle>
Reference-contexts: Interestingly enough, a theory of cycles turns out to be useful also for defining a parser. As described by Tomita [38] and Billot et al. <ref> [16] </ref>, a compact representation of all possible parse trees (that could be an infinite number) associated with a string is a cyclic graph, called a parse forest.
Reference: 17. <author> B. Harper. </author> <title> Introduction to Standard ML. </title> <type> Technical report, </type> <institution> ECS-LFCS-86-14, Laboratory for the Foundation of Computer Science, Edinburgh University, </institution> <year> 1986. </year>
Reference-contexts: However, they are unsuitable to reason about strict functional languages such as SML <ref> [17] </ref>. Therefore, we develop another variant of the cyclic calculus, namely a cyclic call-by-value calculus.
Reference: 18. <author> M. Hasegawa. </author> <title> Recursion from cyclic sharing: traced monoidal categories and models of cyclic lambda calculi. </title> <booktitle> In Proc. Conference on Typed Lambda Calculi and Applications, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: The call-by-value calculus is then equipped with a term model, which allows us to relate our calculus to the commutative version of Moggi's computational lambda calculus [30] and to the recently developed calculus of Hasegawa <ref> [18] </ref>. The reader can refer to [3] for a detailed exposition and the proofs. 2 Graphs as Terms and Terms as Graphs In this section we establish an isomorphism between cyclic lambda-graphs and their syntactic representations. <p> If c n V ` M = N then ffi value ` M = N . Given acyclic terms M; N 2 flffi value . If ffi value ` M = N then c n V ` [[M ]] = [[N ]]. Recently, Hasegawa <ref> [18] </ref> proposed a cyclic extension of Moggi's calculus.
Reference: 19. <author> P. Hudak, S. Peyton Jones, P. Wadler, B. Boutel, J. Fairbairn, J. Fasel, K. Hammond, J. Hughes, T. Johnsson, D. Kieburtz, R. Nikhil, W. Partain, and J. Peterson. </author> <title> Report on the programming language Haskell. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5) </volume> <pages> 1-64, </pages> <year> 1992. </year>
Reference-contexts: For example, in the reduction hx j x = (y:y)(y:y)i ! ffi h (y:y)(y:y) j x = (y:y)(y:y)i, the fiffi-redex has been duplicated. Current implementations of functional languages, such as Haskell <ref> [19] </ref> and Id [32], do not allow these kinds of reductions. Therefore, we develop a variant of the cyclic calculus that takes sharing into consideration. Table 5. <p> Theorem 40. Given M 2 flffi. Inf ffi (M ) = Inf share (M ). ffi share captures the essence of lazy languages, such as Haskell <ref> [19] </ref>, and of the functional core of lenient languages, such as Id [32, 11] and Parallel Haskell [10]. This is substantiated by the fact that both the lazy and lenient strategies are complete with respect to different observations.
Reference: 20. <author> G. Huet. </author> <title> Confluent reductions: Abstract properties and applications to term rewriting systems. </title> <journal> JACM, </journal> <volume> 27(4), </volume> <year> 1980. </year>
Reference-contexts: This consists of an approximate notion of confluence confluence up to information content. This new notion is somewhat reminiscent of another `approximate' notion of rewriting and confluence, namely, rewriting modulo an equivalence relation and confluence modulo equivalence <ref> [20] </ref>. However, unlike these notions, we do not combine rewriting with an equivalence relation, but with an equally fundamental notion, namely a quasi order, expressing a comparison between the `information content' of the objects in question.
Reference: 21. <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> Infinitary lambda calculus. </title> <booktitle> In Proc. Rewriting Techniques and Applications, </booktitle> <address> Kaiserslautern, </address> <year> 1995. </year>
Reference-contexts: In Sect. 6, we prove that the infinite normal form defines a congruence with respect to the term formation rules, guaranteeing observational equivalence. In Sect. 7, we relate our cyclic lambda calculus to the traditional lambda calculus and to the infinitary lambda calculus of Kennaway et al. <ref> [21] </ref>. In Sect. 8, we add the notion of sharing to our cyclic calculus for reasoning about current implementations of non-strict functional languages. In the call-by-name calculus every term is substitutable, while in the sharing calculus substitution is restricted to values, thus avoiding duplication of work. <p> Given M 2 flffi. Inf ffi (M ) = S fInf (M i ) j i 0g. Since cyclic terms unwind to infinite trees, it is natural to relate the cyclic calculus to the infinitary lambda calculus ( 1 ) of Kennaway et al. <ref> [21] </ref>. We have soundness, i.e., if M ! ffi !N then M 1 ! 1 ! ! N 1 , where M 1 is lim n!1 M n and ! 1 ! ! stands for a possibly infinite number of steps in 1 .
Reference: 22. <author> P. Klint. </author> <title> A meta-environment for generating programming environments. In Algebraic Methods II: Theory, Tools and Applications. </title> <publisher> Springer-Verlag LNCS 490, </publisher> <pages> pages 105-124, </pages> <year> 1991. </year>
Reference-contexts: The lack of a theory re-garding cyclic objects has forced some research projects investigating automatic programming environment generators, such as the ASF+SDF developed by Klint <ref> [22] </ref>, to apply a disambiguation process to remove the cycles [23] and so retrieving a tree object. Familiar rewriting can then be applied on that object. This disambiguation process would not be required if cycles were part of the rewriting technology.
Reference: 23. <author> P. Klint and E. Visser. </author> <title> Using filters for the disambiguation of context-free grammars. </title> <editor> In G. Pighizzini and P. San Pietro, editors, </editor> <booktitle> Proc. ASMICS Workshop on Parsing Theory, </booktitle> <pages> pages 1-20, </pages> <address> Milano, Italy, </address> <month> October </month> <year> 1994. </year> <type> Tech. Rep. 126-1994, </type> <institution> Dipartimento di Scienze dell'Informazione, Universita di Milano. </institution>
Reference-contexts: The lack of a theory re-garding cyclic objects has forced some research projects investigating automatic programming environment generators, such as the ASF+SDF developed by Klint [22], to apply a disambiguation process to remove the cycles <ref> [23] </ref> and so retrieving a tree object. Familiar rewriting can then be applied on that object. This disambiguation process would not be required if cycles were part of the rewriting technology.
Reference: 24. <author> Y. Lafont. </author> <title> Interaction nets. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <year> 1990. </year>
Reference-contexts: To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle [6, 7, 15, 31, 35], or adopt a framework based on interaction nets <ref> [24] </ref>. As discussed in [28] and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity. <p> This notion points out the main difference between our approach and that based on interaction nets <ref> [24] </ref>: interaction nets come equipped with certain operators that allow partial copying, that is, the copying can occur on a node-to-node basis whereas for us it occurs all at once. Definition 2. <p> Note that all pointers to the indirection node replacing the lambda-node need to be changed from back-pointers to normal pointers. This second step is drawn on the right of Fig. 11. On the left of the same figure we have drawn the fi-reduction principle used by interaction nets <ref> [24] </ref>. There the use of indirection nodes is superfluous because there is exactly one reference to the application node and exactly one back-pointer to the lambda-node. Axiomatization of fi-reduction We now proceed by giving axioms on cyclic terms that describe fi-reduction.
Reference: 25. <author> J. Launchbury. </author> <title> A natural semantics for lazy evaluation. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 144-154, </pages> <year> 1993. </year>
Reference-contexts: This is substantiated by the fact that both the lazy and lenient strategies are complete with respect to different observations. The lazy strategy, as described by Launchbury <ref> [25] </ref>, only allows one to reach the top stable information. The lenient strategy allows reduction of any redex, as long as it does not occur under a lambda. Thus, it allows one to reach more information.
Reference: 26. <author> J.-J. Levy. </author> <title> An algebraic interpretation of the fi-calculus and an application of a labelled -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 2(1) </volume> <pages> 97-114, </pages> <year> 1976. </year>
Reference-contexts: Lemma 35. Given M; N 2 flffi. If M ! ffi !N then there exists an i and P 2 fl such that M i ! fi !P and N name P . If we let Inf (M i ) denote the Levy-Longo tree (as described in <ref> [26] </ref>) associated with a lambda calculus term, we then have the following result: Theorem 36. Given M 2 flffi. Inf ffi (M ) = S fInf (M i ) j i 0g.
Reference: 27. <author> J.-J. Levy. </author> <title> Reductions Correctes et Optimales dans le Lambda-Calcul. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <month> October </month> <year> 1978. </year>
Reference-contexts: The information content corresponds to the approximate normal form of Wadsworth [39], also called direct approximation by Levy <ref> [27] </ref>. In contrast to [27], we do not send all redexes and compatible redexes to . Only fiffi and the occurrences of variables that correspond to external substitution redexes are sent to . <p> The information content corresponds to the approximate normal form of Wadsworth [39], also called direct approximation by Levy <ref> [27] </ref>. In contrast to [27], we do not send all redexes and compatible redexes to . Only fiffi and the occurrences of variables that correspond to external substitution redexes are sent to . As in lambda calculus, M is also sent to , since it could become a fiffi-redex by replacing with a lambda-abstraction. <p> Congruence with respect to the evaluation calculus is easier to prove, since that calculus is confluent by using the complete development method. As in <ref> [27] </ref>, we prove some properties of reduction and of !-reduction. How ever, we formulate these properties in terms of information content. Proposition 31. Given a term M 2 flffi and a context C. <p> We do not study the sharing present in optimal (in the sense of Levy <ref> [27] </ref>) implementations of lambda calculus. Since the emphasis is on sharing and not on a specific reduction strategy, we call the calculus the sharing calculus (ffi share ), because call-by-need normally implies lazy evaluation.
Reference: 28. <author> I.C. Mackie. </author> <title> The geometry of implementation. </title> <type> PhD thesis, </type> <institution> University of London, </institution> <year> 1994. </year>
Reference-contexts: To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle [6, 7, 15, 31, 35], or adopt a framework based on interaction nets [24]. As discussed in <ref> [28] </ref> and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity.
Reference: 29. <author> J. Maraist, M. Odersky, D. Turner, and P. Wadler. </author> <title> Call-by-name, call-by-value, call-by-need, and the linear lambda calculus. </title> <booktitle> In Proc. of Mathematical Foundations of Programming Semantics (MFPS), </booktitle> <year> 1995. </year>
Reference-contexts: i = M Copying: M = N 9 : V ! V; N M and 8x 6 x 0 ; (x) (x 0 ) : (x) bound to a value in M Naming: M = hx j x = Mi x a new variable was made by Maraist et al. <ref> [29] </ref>. In hx:x j y = zi and hx:x j y = z:zi it is safe to eliminate the binding for y, and instead in hx:x j y = yi and hx j y = wzi it is not.
Reference: 30. <author> E. Moggi. </author> <title> Computational lambda calculus and monads. </title> <type> Technical Report ECS-LFCS-88-86, </type> <institution> Edinburgh University, </institution> <year> 1988. </year>
Reference-contexts: This expresses the fact that strict and non-strict computations capture the same amount of sharing. The call-by-value calculus is then equipped with a term model, which allows us to relate our calculus to the commutative version of Moggi's computational lambda calculus <ref> [30] </ref> and to the recently developed calculus of Hasegawa [18]. The reader can refer to [3] for a detailed exposition and the proofs. 2 Graphs as Terms and Terms as Graphs In this section we establish an isomorphism between cyclic lambda-graphs and their syntactic representations. <p> notion of information, denoted by Inf value , also leads to a model. 9.2 The Cyclic Call-by-Value Calculus, Moggi's Computational Lambda Calculus and Hasegawa's Calculus We use the infinite call-by-value normal form to relate our calculus to the commutative version of the computational lambda calculus of Moggi ( c ) <ref> [30] </ref>. However, since Moggi's calculus is acyclic, we first need to relate a cyclic term to the acyclic terms approximating it, as we did for the call-by-name calculus. However, this relation only works for a subset of the set of terms.
Reference: 31. <author> J. Niehren. </author> <title> Functional computation as concurrent computation. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 333-343, </pages> <year> 1996. </year>
Reference-contexts: To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle <ref> [6, 7, 15, 31, 35] </ref>, or adopt a framework based on interaction nets [24]. As discussed in [28] and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity.
Reference: 32. <author> R. S. Nikhil. </author> <title> Id (version 90.1) reference manual. </title> <type> Technical Report 284-2, </type> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, </address> <year> 1991. </year>
Reference-contexts: For example, in the reduction hx j x = (y:y)(y:y)i ! ffi h (y:y)(y:y) j x = (y:y)(y:y)i, the fiffi-redex has been duplicated. Current implementations of functional languages, such as Haskell [19] and Id <ref> [32] </ref>, do not allow these kinds of reductions. Therefore, we develop a variant of the cyclic calculus that takes sharing into consideration. Table 5. <p> Theorem 40. Given M 2 flffi. Inf ffi (M ) = Inf share (M ). ffi share captures the essence of lazy languages, such as Haskell [19], and of the functional core of lenient languages, such as Id <ref> [32, 11] </ref> and Parallel Haskell [10]. This is substantiated by the fact that both the lazy and lenient strategies are complete with respect to different observations. The lazy strategy, as described by Launchbury [25], only allows one to reach the top stable information.
Reference: 33. <editor> S. L. Peyton Jones. </editor> <booktitle> The implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Cyclic lambda-graphs are ubiquitous in a program development system <ref> [33] </ref>. However, previous work falls short of capturing them in an adequate way. This lack of explicit treatment of cycles results in the loss of important intensional information and in weak theories that cannot express many transformations on recursive functions.
Reference: 34. <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: On the set of cyclic terms we have developed three cyclic lambda calculi. These calculi correspond to the parameter-passing techniques of call-by-name, call-by-need and call-by-value. The ability to define mutually recursive objects makes these calculi more suitable then lambda calculus [13], need [5, 4] and V <ref> [34] </ref> to express the operational semantics, compilation and optimization of current functional languages. The sharing calculus is the kernel language of Haskell and the functional core of Id and Parallel Haskell. The call-by-value calculus is the functional kernel of languages such as SML.
Reference: 35. <author> K. H. Rose. </author> <title> Explicit cyclic substitutions. </title> <editor> In M. Rusinowitch and J. L. Remy, editors, </editor> <booktitle> Proc. 3rd International Workshop on Conditional Term Rewriting Systems (CTRS-92), Pont-a-Mousson, </booktitle> <address> France, </address> <publisher> Springer-Verlag LNCS 656, </publisher> <pages> pages 36-50, </pages> <year> 1992. </year>
Reference-contexts: To regain confluence, current formulations of cycles either impose restrictions, such as disallowing reduction under a lambda-abstraction or on a cycle <ref> [6, 7, 15, 31, 35] </ref>, or adopt a framework based on interaction nets [24]. As discussed in [28] and [12], cycles do not destroy confluence in the context of interaction nets, but only at the expense of greater complexity. <p> We also point out that the axioms to distribute the substitution across a term in a stepwise manner, which are present in the explicit substitution calculi <ref> [1, 35] </ref>, are derivable in our calculus and that they generate the same model. 8 The Cyclic Sharing Calculus ffi share A drawback of the cyclic lambda calculus is that it does not support sharing adequately, since it allows reductions that duplicate work.
Reference: 36. <author> D. Sangiorgi and R. Milner. </author> <title> Techniques of "weak bisimulation up to". </title> <type> Technical report, </type> <year> 1993. </year>
Reference-contexts: Explicit studies of such a combination of a rewrite relation with a quasi order are not abundant; the only study that we are aware of is [37]. In the context of process algebra, Sangiorgi and Milner <ref> [36] </ref> consider equivalences of processes up to an asymmetric relation, such as a quasi order, as a technique to prove bisimulation. The paper is organized as follows: We start in Sect. 2 by introducing cyclic lambda-graphs.
Reference: 37. <author> P. Selinger. </author> <title> Order-incompleteness and finite lambda models. </title> <booktitle> In Proc. Symposium on Logic in Computer Science (LICS'96), </booktitle> <year> 1996. </year>
Reference-contexts: Explicit studies of such a combination of a rewrite relation with a quasi order are not abundant; the only study that we are aware of is <ref> [37] </ref>. In the context of process algebra, Sangiorgi and Milner [36] consider equivalences of processes up to an asymmetric relation, such as a quasi order, as a technique to prove bisimulation. The paper is organized as follows: We start in Sect. 2 by introducing cyclic lambda-graphs.
Reference: 38. <author> M. Tomita. </author> <title> Efficient Parsing for Natural Languages. A Fast Algorithm for Practical Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1985. </year>
Reference-contexts: While the execution of M has made only one copy of even, the execution of [[M ]] has created four copies of even and three copies of odd. Interestingly enough, a theory of cycles turns out to be useful also for defining a parser. As described by Tomita <ref> [38] </ref> and Billot et al. [16], a compact representation of all possible parse trees (that could be an infinite number) associated with a string is a cyclic graph, called a parse forest.
Reference: 39. <author> C. Wadsworth. </author> <title> Semantics and Pragmatics of the Lambda-Calculus. 1971. PhD thesis, University of Oxford. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In the context of process algebra, Sangiorgi and Milner [36] consider equivalences of processes up to an asymmetric relation, such as a quasi order, as a technique to prove bisimulation. The paper is organized as follows: We start in Sect. 2 by introducing cyclic lambda-graphs. As in Wadsworth <ref> [39] </ref>, we do not deal with all possible lambda-graphs, but restrict our focus to the set of well-formed lambda-graphs. To define this class we introduce in Sect. 2.1 the notion of a scoped lambda-graph. The well-formed lambda-graphs are those that have associated scoped lambda-graphs. <p> This implies we will not be able to represent the lambda-graph of Fig. 1, which Wadsworth <ref> [39] </ref> calls a non-admissible lambda-graph. Each argument of a node is either a normal pointer to some node, a back-pointer to a lambda-node, or is a free variable from the set of variables V. <p> The information content corresponds to the approximate normal form of Wadsworth <ref> [39] </ref>, also called direct approximation by Levy [27]. In contrast to [27], we do not send all redexes and compatible redexes to . Only fiffi and the occurrences of variables that correspond to external substitution redexes are sent to .
References-found: 39

