URL: http://www.cs.pitt.edu/~suew/suleiman.ps
Refering-URL: http://www.cs.pitt.edu/~suew/dbwshop2.html
Root-URL: 
Email: email: -suleiman, cart, ferrie-@lsi.fr  
Title: Concurrent Operations in a Distributed and Mobile Collaborative Environment  
Author: Maher Suleiman, Michle Cart, Jean Ferri 
Address: Montpellier 860, rue de St Priest, 34090 Montpellier, France  
Affiliation: LSI, University of  
Abstract: In a distributed groupware system, objects shared by users are subject to concurrency and real-time constraints. In order to satisfy these, various concurrency control algorithms [4] [10] [18] have been proposed that exploit the semantic properties of operations. By ordering concurrent operations, they generally guarantee consistency of the different copies of each object. However, in some situations they can result in inconsistent copies, a non-respect of users intentions, and in the need to undo and redo some operations. The principle objective of this paper is to present an algorithm that overcomes these drawbacks in distributed and mobile collaborative environments. The algorithm is based on the notion of users intention, and also on the construction of equivalent histories by exploiting and combining some general semantic properties such as forward/backward transposition. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allison C.; </author> <title> "Concurrency Control for Real Time Groupware," CE94: Concurrent Engineering Research and Applications, A global Perspective, </title> <address> Pittsbourg, </address> <month> August </month> <year> 1994, </year> <pages> pp. 163-170. </pages>
Reference-contexts: The histories of the different copies of the object are guaranteed to be equivalent (i.e. lead to the same final state), although the order of concurrent operations can be different. However, the problem of partial concurrency evoked in <ref> [1] </ref>, that can lead to incoherence, is not solved. The works described in [10] use commutativity and masking properties to reorder the histories associated with object copies so as to respect a unique order defined a priori by timestamps. <p> As op 1 and op 2 are not generated from the same state, the are said to be partially concurrent <ref> [1] </ref>. In this case, application of the forward transposition may lead to a wrong result. The following example illustrates a partial concurrency situation. Example 2. Consider two users who try to change the word "telefone" into "telephone" as in (Fig. 3).
Reference: [2] <author> Cart M., Ferri J., Richy H.; </author> <title> Contrle de l'execution de transactions concurrentes, </title> <journal> Technique et Science Informatiques, </journal> <volume> vol. 8, </volume> <editor> n. </editor> <volume> 3, </volume> <pages> pp. 225-240, </pages> <year> 1989. </year>
Reference: [3] <author> Decouchant D., Quint V., Vatton I.; </author> " <title> L ' d i t i o n Cooprative de documents avec Griffon," </title> <booktitle> Colloque IHM'92, </booktitle> <address> Paris, </address> <month> Dcembre </month> <year> 1992. </year>
Reference-contexts: Consequently, the problem is to conciliate both real-time and consistency constraints, as the object may be modified concurrently by many users. To satisfy these requirements, it is necessary [5] [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] <ref> [3] </ref> [15] use locks for concurrency control, thus preventing simultaneous access to the object. Other systems [10] [4] [18] use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency.
Reference: [4] <author> Ellis C.A., Gibbs S.J.; </author> <title> "Concurency Control in Groupware Systems," </title> <booktitle> in Proc. ACM Int. Conf. on Management of Data (SIGMOD'89), </booktitle> <address> Seattle, </address> <month> May </month> <year> 1989, </year> <pages> pp. 399-407. </pages>
Reference-contexts: To satisfy these requirements, it is necessary [5] [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] [3] [15] use locks for concurrency control, thus preventing simultaneous access to the object. Other systems [10] <ref> [4] </ref> [18] use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency. More precisely, the works described in [4] use a transformation property to construct the history associated with each copy of the object. <p> Other systems [10] <ref> [4] </ref> [18] use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency. More precisely, the works described in [4] use a transformation property to construct the history associated with each copy of the object. The histories of the different copies of the object are guaranteed to be equivalent (i.e. lead to the same final state), although the order of concurrent operations can be different. <p> In [18], the transformation property is used in order to respect the user intention. Moreover, the histories of the different copies of the object are ordered by using the same order to guarantee consistency of the object. But unfortunately, as in <ref> [4] </ref>, the problem of partial concurrency is not solved and as in [10], operations have to be undone and then redone in order to respect the same order. In this paper we aim to design a system that does not have these drawbacks. <p> problem is to construct, for every site S and for every object O, a history H S,O respecting the constraints above in such a way that if the object copies were identical at the beginning of the work session, they will also be identical each time the system is quiescent <ref> [4] </ref>, that is to say when there are no more messages circulating in the network. 3 Respecting the Causality To be able to respect the causality between operations we need a technique that allows us to: (1) compare two operations to determine if one operation precedes the other; (2) deduce, when <p> The technique suggested in <ref> [4] </ref>, like that described in [13], satisfies both these criteria. It uses a state vector for each site that counts operations generated by the other sites and executed on this site. We will adopt this technique to define two procedures for message emission and reception. <p> This determination is possible by defining a function of transposition <ref> [4] </ref>, specific to the application and to the semantic of the operations, that gives for each ordered couple of operations (op 1 , op 2 ) an operation op' 2 realizing the same intention as op 2 , while taking the effects of op 1 into account. <p> To achieve this, the naive method consists of going through the history H S (n) and transposing op forward with each operation concurrent to it <ref> [4] </ref>. This method is implemented by the following algorithm.
Reference: [5] <author> Ellis C.A., Gibbs S.J., Rein G.L.; </author> <title> "Groupware: Some issues and experiences," </title> <journal> Commun. ACM, </journal> <volume> vol. 34, n.1, </volume> <pages> pp. 39-59, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Consequently, the problem is to conciliate both real-time and consistency constraints, as the object may be modified concurrently by many users. To satisfy these requirements, it is necessary <ref> [5] </ref> [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] [3] [15] use locks for concurrency control, thus preventing simultaneous access to the object.
Reference: [6] <author> Fish R.S., Kraut R.E., Leland M.D.P., Cohen M; "Quilt: </author> <title> a collaborative tool for cooperative writing," </title> <booktitle> in Proc. ACM Int. Conf. on Office Information Systems, </booktitle> <address> Palo Alto, </address> <month> March </month> <year> 1988, </year> <pages> pp. 30-37. </pages>
Reference: [7] <author> Greenberg S., Roseman M., Webster D., Bohnet R.; </author> <title> "Issues and Experiences Designing and Implementing Tow Group Drawing Tools," </title> <booktitle> in Proc. 25th Annual Hawaii Int. Conf. on System Sciences, 1992, </booktitle> <volume> vol. 4, </volume> <pages> pp. 139-150. </pages>
Reference: [8] <author> Greenberg S., Marwood D.; </author> <title> "Real Time Groupware as a Distributed System: Concurrency Control and its Effect on the Interface," </title> <booktitle> in Proc. ACM Int. Conf. on Computer Supported Cooperative Work, </booktitle> <address> Canada, </address> <month> October </month> <year> 1994, </year> <pages> pp. 207-217. </pages>
Reference-contexts: Consequently, the problem is to conciliate both real-time and consistency constraints, as the object may be modified concurrently by many users. To satisfy these requirements, it is necessary [5] <ref> [8] </ref> that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] [3] [15] use locks for concurrency control, thus preventing simultaneous access to the object.
Reference: [9] <author> Greif I., Seliger R., Weihl W.; </author> <title> "Atomic Data Abstraction in a Distributed Collaborative Editing System," </title> <booktitle> in Proc. 13th ACM Annual Symposium on Principles of Programming Languages, </booktitle> <address> Petersburg, </address> <month> January </month> <year> 1986, </year> <pages> pp. 160-172. </pages>
Reference-contexts: Consequently, the problem is to conciliate both real-time and consistency constraints, as the object may be modified concurrently by many users. To satisfy these requirements, it is necessary [5] [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems <ref> [9] </ref> [3] [15] use locks for concurrency control, thus preventing simultaneous access to the object. Other systems [10] [4] [18] use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency.
Reference: [10] <author> Karsenty A., Beaudouin-Lafon M.; </author> <title> "An Algorithm for Distributed Groupware Applications," </title> <booktitle> in Proc. 13th Int. Conf. on Distributed Computing Systems (ICDCS'93), </booktitle> <address> Pittsburgh, </address> <month> May </month> <year> 1993, </year> <month> pp.195-202. </month>
Reference-contexts: To satisfy these requirements, it is necessary [5] [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] [3] [15] use locks for concurrency control, thus preventing simultaneous access to the object. Other systems <ref> [10] </ref> [4] [18] use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency. <p> However, the problem of partial concurrency evoked in [1], that can lead to incoherence, is not solved. The works described in <ref> [10] </ref> use commutativity and masking properties to reorder the histories associated with object copies so as to respect a unique order defined a priori by timestamps. Unfortunately, in the absence of commutativity and masking properties, some operations have to be undone and then redone. <p> Moreover, the histories of the different copies of the object are ordered by using the same order to guarantee consistency of the object. But unfortunately, as in [4], the problem of partial concurrency is not solved and as in <ref> [10] </ref>, operations have to be undone and then redone in order to respect the same order. In this paper we aim to design a system that does not have these drawbacks.
Reference: [11] <author> Kanawati R.; </author> <title> "Replicated Data Management Algorithm for Distributed Synchronous Groupware Applications," </title> <booktitle> in Proc. DAPSYS'96 'Environnements and Tools', </booktitle> <address> Miskloc (Hungary), </address> <month> October </month> <year> 1996. </year>
Reference: [12] <author> Lamport L.; </author> <title> "Time, Clocks, and the Ordering of Events in Distributed System, </title> <journal> Commun. ACM, </journal> <volume> vol. 21, n.7, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference: [13] <author> Mattern F.; </author> <title> "Virtual time and global states of Distributed Systems," </title> <booktitle> in Proc. Int. Workshop on Parallel and Distributed Algorithms, </booktitle> <publisher> Elsevier Pub., </publisher> <year> 1989, </year> <pages> pp. 215-276. </pages>
Reference-contexts: The technique suggested in [4], like that described in <ref> [13] </ref>, satisfies both these criteria. It uses a state vector for each site that counts operations generated by the other sites and executed on this site. We will adopt this technique to define two procedures for message emission and reception. These procedures guarantee a causal broadcast [16]. State Vector.
Reference: [14] <author> Prakash A., Knister M.J.; </author> <title> "Undoing Actions in Collaborative Work," </title> <booktitle> in Proc. ACM Int. Conf. on Computer Supported Cooperative Work, </booktitle> <month> November </month> <year> 1992, </year> <pages> pp. 273-280. </pages>
Reference-contexts: To do this, we will use another type of transposition called b a c k w a r d transposition. This transposition was introduced in <ref> [14] </ref> to undo an operation in a history without undoing the operations that follow it. Backward Transposition. Suppose that on a site S, the history op 1 .op 2 realizes I 1 .I 2 .
Reference: [15] <author> Prakash A., Shim H. S.; DistView: </author> <title> Support for Building Efficient Collaborative Applications using Replicated Object, </title> <booktitle> in Proc. ACM Int. Conf. on Computer Supported Cooperative Work, </booktitle> <month> October </month> <year> 1994, </year> <pages> pp. 153-164. </pages>
Reference-contexts: Consequently, the problem is to conciliate both real-time and consistency constraints, as the object may be modified concurrently by many users. To satisfy these requirements, it is necessary [5] [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] [3] <ref> [15] </ref> use locks for concurrency control, thus preventing simultaneous access to the object. Other systems [10] [4] [18] use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency.
Reference: [16] <editor> Raynal M.;"La communication et le temps dans les rseaux et les systmes rpartis," </editor> <publisher> Eyrolles Pub., </publisher> <address> Collection DER-EDF, </address> <year> 1991. </year>
Reference-contexts: Definition 2. Concurrency between two operations. We say that op 1 and op 2 are concurrent (Fig. 1B) iff: not (op 1 precedes op 2 ) and not (op 2 precedes op 1 ). The precede relation expresses the potential causality <ref> [16] </ref> between these operations. If op 1 precedes op 2 , op 2 is supposed to be dependent on the effects produced by op 1 . <p> It uses a state vector for each site that counts operations generated by the other sites and executed on this site. We will adopt this technique to define two procedures for message emission and reception. These procedures guarantee a causal broadcast <ref> [16] </ref>. State Vector. Let N be the number of sites in the collaborative system. These sites are numbered from 1 to N.
Reference: [17] <author> Suleiman M., Cart M., Ferri J.; </author> <title> "Serialization of Concurrent Operations in a Distributed Collaborative Environment," </title> <booktitle> in Proc. ACM Int. Conf. on Supporting Group Work, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: Thanks to this reception procedure, the following lemmas can be proved. The proofs can be found in <ref> [17] </ref>. Lemma 1. Causal precedence between two operations. Given two messages &lt;op 1 , S op1 , V op1 &gt; and &lt;op 2 , S op2 , V op2 &gt;, we have: op 1 precedes op 2 iff V op1 [S op1 ] &lt; V op2 [S op1 ]. <p> We have: O i .[op 1 :op 2 : ...:op n ] fi I 1 .I 2 ....I n . The proof of this lemma can be found in <ref> [17] </ref> 4.5 Serialization of a Sequence Concurrent to an Operation Partial Concurrency Problem.
Reference: [18] <author> Sun C., Yang Y., Zhang Y., Chen D.; </author> <title> Distributed Concurrency Control in Real-time Cooperative Editing Systems, </title> <booktitle> in Proc. 2nd Asian Computing Science Conf. on Concurrency and Parallelism, Programming, Networking, </booktitle> <address> Singapour, </address> <month> December </month> <year> 1996, </year> <month> pp.84-95. </month>
Reference-contexts: To satisfy these requirements, it is necessary [5] [8] that concurrency control does not use a blocking protocol which could defer user actions. Some collaborative systems [9] [3] [15] use locks for concurrency control, thus preventing simultaneous access to the object. Other systems [10] [4] <ref> [18] </ref> use multiple copies to permit concurrent access to the same object, and use semantic properties of the operations to reorder concurrent operations while preserving object consistency. More precisely, the works described in [4] use a transformation property to construct the history associated with each copy of the object. <p> Unfortunately, in the absence of commutativity and masking properties, some operations have to be undone and then redone. In addition, the user intention is not always respected. In <ref> [18] </ref>, the transformation property is used in order to respect the user intention. Moreover, the histories of the different copies of the object are ordered by using the same order to guarantee consistency of the object.
Reference: [19] <institution> Weihl W.E.;"Commutativity-Based Concurrency Control for Abstract Data Type," </institution> <note> IEEE Transactions on Computers, vol. 37, </note> <editor> n. </editor> <volume> 12, </volume> <pages> pp. 1488-1505, </pages> <month> December </month> <year> 1988. </year>
References-found: 19

