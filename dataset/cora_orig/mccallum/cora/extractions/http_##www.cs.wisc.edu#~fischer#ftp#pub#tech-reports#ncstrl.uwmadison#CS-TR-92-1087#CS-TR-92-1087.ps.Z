URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1087/CS-TR-92-1087.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1087/
Root-URL: http://www.cs.wisc.edu
Title: An Incremental Algorithm for a Generalization of the Shortest-Path Problem  
Author: G. Ramalingam and Thomas Reps 
Keyword: General Terms: Algorithms, Theory Additional Key Words and Phrases: shortest-path problem, least-cost path problem, incremental algorithm, dynamic algorithm, Dijkstra's algorithm  
Address: Wisconsin Madison  
Affiliation: University of  
Abstract: The grammar problem, a generalization of the single-source shortest-path problem introduced by Knuth, is to compute the minimum-cost derivation of a terminal string from one or more non-terminals of a given context-free grammar, with the cost of a derivation being suitably defined. In this paper we present an incremental algorithm for a version of the grammar problem. As a special case of this algorithm we obtain an efficient incremental algorithm for the single-source shortest-path problem with positive edge lengths. The aspect of our incremental algorithm that distinguishes it from all other work on the dynamic shortest-path problem is its ability to handle multiple heterogeneous modifications: between updates, the input graph is allowed to be restructured by an arbitrary mixture of edge insertions, edge deletions, and edge-length changes. Categories and Subject Descriptors: E.1 [Data Structures] -- graphs; F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems -- computations on discrete structures; G.2.1 [Discrete Mathematics]: Combinatorics -- combinatorial algorithms; G.2.2 [Discrete Mathematics]: Graph Theory -- graph algorithms 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> Ausiello, G., Italiano, G.F., Spaccamela, A.M., and Nanni, U., </editor> <title> Incremental algorithms for minimal length paths, pp. </title> <booktitle> 12-21 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1990). </address>
Reference-contexts: Thus, Ausiello et al. <ref> [1] </ref>, for instance, use amortized-cost analysis to obtain a better bound on the time complexity of an algorithm they present for maintaining shortest paths in a graph as the graph undergoes a sequence of edge insertions. <p> adjusting the heap. - 14 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DynamicSWSF-FP (G, U) declare G : a dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin <ref> [1] </ref> Heap := [2] for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] <p> previous section, which - 16 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DynamicSSF-G (G, P) declare G : a SSF grammar P : the set of modified productions in G GlobalHeap: a heap of non-terminals preconditions Every production in G-P is consistent. (See Definition 5.1) procedure recomputeProductionValue (p) declare p : a production begin <ref> [1] </ref> let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else <p> Let d (x,y) denote the length of a shortest path from x to y. Then, for any two vertices s and t, d (s,t) can change only if for some i <ref> [1, k ] </ref> both d (s,v i ) and d (u i ,t) change. Hence, by updating the single-source solution for every u i , we can identify the set of vertices t for which the single-sink solution will change. <p> on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. <ref> [1, 2] </ref>, and Ramalingam and Reps [23].
Reference: 2. <editor> Ausiello, G., Italiano, G.F., Spaccamela, A.M., and Nanni, U., </editor> <title> Incremental algorithms for minimal length paths, </title> <journal> Journal of Algorithms, </journal> <pages> (12) pp. </pages> <month> 615-638 </month> <year> (1991). </year>
Reference-contexts: - 14 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DynamicSWSF-FP (G, U) declare G : a dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := <ref> [2] </ref> for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := <p> the set of modified productions in G GlobalHeap: a heap of non-terminals preconditions Every production in G-P is consistent. (See Definition 5.1) procedure recomputeProductionValue (p) declare p : a production begin [1] let p be the production Y fi g (X 1 , . . . , X k ) <ref> [2] </ref> value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) <p> The postcondition established by the algorithm is that every production and non-terminal in the grammar will be consistent. The procedure recomputeProductionValue (p) makes production p consistent by evaluating its value (in line <ref> [2] </ref>) and updating the data structures SP (Y) (line [8]) and Heap (Y) (lines [3]-[7]) appropriately, where Y is the left-hand side of p. These changes are followed by appropriate updates to GlobalHeap in lines [9]-[15]. <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line <ref> [2] </ref>), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap (Y) operations (lines [4] or [6]), and (d) O (1) GlobalHeap (Y) operations (lines [10], [12] or [14]). <p> on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. <ref> [1, 2] </ref>, and Ramalingam and Reps [23]. <p> dynamic shortest-path problem; at least, it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], <ref> [2] </ref> [23], [25], [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii <p> The best algorithm currently known for this problem, developed independently by Lin and Chang [18] and Ausiello et al. <ref> [2] </ref>, restricts the set of pairs of vertices for which the d value is recomputed by a careful traversal of the shortest-path trees of the graph before the modification. <p> The algorithms due to Rohnert [25] and Ramalingam and Reps [23] are based on similar ideas, though they are not as efficient as the algorithms of [18] and <ref> [2] </ref>. All of the above algorithms are bounded algorithms. It is worth mentioning that the improved efficiency of the algorithms described in [18] and [2] is obtained at a cost: these algorithms make use of the shortest-path-tree data structure, the maintenance of which can make the processing of an edge-deletion more <p> due to Rohnert [25] and Ramalingam and Reps [23] are based on similar ideas, though they are not as efficient as the algorithms of [18] and <ref> [2] </ref>. All of the above algorithms are bounded algorithms. It is worth mentioning that the improved efficiency of the algorithms described in [18] and [2] is obtained at a cost: these algorithms make use of the shortest-path-tree data structure, the maintenance of which can make the processing of an edge-deletion more expensive.
Reference: 3. <author> Carroll, </author> <title> M.D., Data flow update via dominator and attribute updates, </title> <type> Ph.D. dissertation, </type> <institution> Rutgers University, </institution> <address> New Brunswick, NJ (May 1988). </address>
Reference-contexts: as Carroll observes, An algorithm with bad worst-case complexity will have good amortized complexity only if there is something about the problem being updated, or about the way in which we update it, or about the kinds of updates which we allow, that pre cludes pathological updates from happening frequently <ref> [3] </ref>. Thus, Ausiello et al. [1], for instance, use amortized-cost analysis to obtain a better bound on the time complexity of an algorithm they present for maintaining shortest paths in a graph as the graph undergoes a sequence of edge insertions. <p> G-P is consistent. (See Definition 5.1) procedure recomputeProductionValue (p) declare p : a production begin [1] let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) <ref> [3] </ref> if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP
Reference: 4. <author> Cheston, </author> <title> G.A., Incremental algorithms in graph theory, </title> <type> Ph.D. dissertation and Tech. Rep. 91, </type> <institution> Dept. of Computer Science, University of Toronto, Toronto, </institution> <address> Canada (March 1976). </address>
Reference-contexts: DynamicSWSF-FP (G, U) declare G : a dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do <ref> [4] </ref> if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v <p> recomputeProductionValue (p) declare p : a production begin [1] let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then <ref> [4] </ref> AdjustHeap ( Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap (Y) operations (lines <ref> [4] </ref> or [6]), and (d) O (1) GlobalHeap (Y) operations (lines [10], [12] or [14]). <p> In other words, no edges are deleted and no edge-length is increased. In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines <ref> [4] </ref>, [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston <ref> [4] </ref>, Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> The algorithms due to Murchland [20], Dionne [7], and Cheston <ref> [4] </ref> are all based on the observation that x is an affected source [sink] iff (x,v ) [(u,x)] is an affected pair. <p> All the above-mentioned algorithms use an adaptation of Dijkstra's algorithm to solve the dynamic SSSP algorithm. The algorithms can, however, be adapted to handle negative length edges using the technique outlined in Section 6.3. The algorithms due to Rodionov [24], Murchland [20], Dionne [7], and Cheston <ref> [4] </ref>, are all based on a different, and less efficient, technique of computing the new d value for every pair in A, the approximation to the set of affected pairs, using an adaptation of Floyd's algorithm for the batch shortest-path problem.
Reference: 5. <author> Cheston, G.A. and Corneil, D.G., </author> <title> Graph property update algorithms and their application to distance matrices, </title> <note> INFOR 20(3) pp. </note> <month> 178-201 (August </month> <year> 1982). </year>
Reference-contexts: dependence graph of a set of SWSF equations U : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs (u) d (u) then <ref> [5] </ref> InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := <p> begin [1] let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) <ref> [5] </ref> else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil <ref> [5] </ref>, Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23].
Reference: 6. <author> Dijkstra, </author> <title> E.W., A note on two problems in connexion with graphs, </title> <journal> Numerische Mathematik 1 pp. </journal> <month> 269-271 </month> <year> (1959). </year>
Reference-contexts: The goal of the grammar problem is to compute the minimum-cost derivation of a terminal string from one or more non-terminals of the given grammar. Knuth showed that it is possible to adapt Dijkstra's shortest-path algorithm <ref> [6] </ref> to solve the grammar problem if the functions defining the costs of derivations satisfy a simple property (see Section 2). <p> : the set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) <ref> [6] </ref> fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . <p> let p be the production Y fi g (X 1 , . . . , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else <ref> [6] </ref> if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap (Y) operations (lines [4] or <ref> [6] </ref>), and (d) O (1) GlobalHeap (Y) operations (lines [10], [12] or [14]). <p> In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines <ref> [6] </ref> and [14] are never executed.
Reference: 7. <author> Dionne, R., </author> <title> Etude et extension d'un algorithme de Murchland, </title> <note> INFOR 16(2) pp. </note> <month> 132-146 (June </month> <year> 1978). </year>
Reference-contexts: . . , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi <ref> [7] </ref> fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne <ref> [7] </ref>, Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> least, it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] <ref> [7] </ref>, [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This <p> constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] <ref> [7] </ref>, [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted <p> The algorithms due to Murchland [20], Dionne <ref> [7] </ref>, and Cheston [4] are all based on the observation that x is an affected source [sink] iff (x,v ) [(u,x)] is an affected pair. <p> All the above-mentioned algorithms use an adaptation of Dijkstra's algorithm to solve the dynamic SSSP algorithm. The algorithms can, however, be adapted to handle negative length edges using the technique outlined in Section 6.3. The algorithms due to Rodionov [24], Murchland [20], Dionne <ref> [7] </ref>, and Cheston [4], are all based on a different, and less efficient, technique of computing the new d value for every pair in A, the approximation to the set of affected pairs, using an adaptation of Floyd's algorithm for the batch shortest-path problem.
Reference: 8. <author> Driscoll, J.R., Gabow, H.N., Shrairman, R., and Tarjan, R.E., </author> <title> Relaxed heaps: An alternative to Fibonacci heaps with applications to parallel computation, </title> <journal> Communications of the ACM 31(11) pp. </journal> <month> 1343-1354 </month> <year> (1988). </year> <month> - 28 </month> - 
Reference-contexts: We now verify that the algorithm does indeed maintain the invariants described above. Thus, we first need to show that all vertices satisfy the invariant whenever execution reaches line <ref> [8] </ref>. The precondition guarantees that all the initially inconsistent vertices must be in U. In lines [1]-[7], the algorithm creates a heap out of all the initially inconsistent vertices in the graph, and simultaneously the value rhs (u) is properly defined for every inconsistent vertex u. <p> In lines [1]-[7], the algorithm creates a heap out of all the initially inconsistent vertices in the graph, and simultaneously the value rhs (u) is properly defined for every inconsistent vertex u. Hence the invariant holds when execution reaches line <ref> [8] </ref> for the first time. The loop in lines [8]-[31] processes and fixes the inconsistencies in the graph one by one, in increasing order of key value. <p> set of modified vertices in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi <ref> [8] </ref> while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d <p> Following the assignment of a new value to d (u) in line [21], only u or some successor of u can fail to satisfy the invariant. These vertices are appropriately processed in lines [22]-[29], and hence the invariant is satisfied whenever execution reaches line <ref> [8] </ref>. To understand how the algorithm makes progress towards the correct solution consider how the correct ness status of the vertices in the graph change. In each iteration of the loop in lines [8]-[31] the value, and hence the correctness status, of only one vertex (namely u) changes. <p> , X k ) [2] value = g (d (X 1 ), . . . , d (X k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi <ref> [8] </ref> if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, <p> The postcondition established by the algorithm is that every production and non-terminal in the grammar will be consistent. The procedure recomputeProductionValue (p) makes production p consistent by evaluating its value (in line [2]) and updating the data structures SP (Y) (line <ref> [8] </ref>) and Heap (Y) (lines [3]-[7]) appropriately, where Y is the left-hand side of p. These changes are followed by appropriate updates to GlobalHeap in lines [9]-[15]. Note that some of these steps can be redundant, in the sense that they do nothing. <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines <ref> [8] </ref> and [9]), (c) O (1) Heap (Y) operations (lines [4] or [6]), and (d) O (1) GlobalHeap (Y) operations (lines [10], [12] or [14]). <p> In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. Consequently, procedure recomputeProductionValue takes time O (1) if relaxed heaps <ref> [8] </ref> or Fibonacci heaps [11] are used. (In the latter case, the time complexity is the amortized complexity.) It can also be verified that the number of elements in any of the heaps is O ( | d | ).
Reference: 9. <author> Edmonds, J. and Karp, </author> <title> R.M., Theoretical improvements in algorithmic efficiency for network flow problems, </title> <journal> J. ACM 19 pp. </journal> <month> 248-264 </month> <year> (1972). </year>
Reference-contexts: in G u, v, w: vertices Heap: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do <ref> [9] </ref> u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] <p> k )) [3] if (value &lt; d (Y)) then [4] AdjustHeap ( Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi <ref> [9] </ref> if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove <p> Let us now consider the time taken by a single execution of procedure recomputeProductionValue. The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and <ref> [9] </ref>), (c) O (1) Heap (Y) operations (lines [4] or [6]), and (d) O (1) GlobalHeap (Y) operations (lines [10], [12] or [14]). <p> The idea is to adapt the technique of Edmonds and Karp for transforming the length of every edge to a non-negative real without changing the graph's shortest paths <ref> [9, 27] </ref>.
Reference: 10. <author> Even, S. and Gazit, H., </author> <title> Updating distances in dynamic graphs, </title> <note> pp. 271-388 in IX Symposium on Operations Research, </note> <author> (Osna-brueck, W. Ger., </author> <month> Aug. </month> <pages> 27-29, </pages> <year> 1984), </year> <journal> Methods of Operations Research, </journal> <volume> Vol. 49, </volume> <editor> ed. P. Brucker and R. </editor> <publisher> Pauly,Verlag Anton Hain (1985). </publisher>
Reference-contexts: a heap of vertices preconditions Every vertex in V (G)-U is consistent begin [1] Heap := [2] for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) <ref> [10] </ref> if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] <p> Heap (Y), p, value) [5] else [6] if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ <ref> [10] </ref> AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for <p> The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap (Y) operations (lines [4] or [6]), and (d) O (1) GlobalHeap (Y) operations (lines <ref> [10] </ref>, [12] or [14]). The set operations on SP (Y) can be done in constant time by associating every production Y fi g (X 1 , . . . , X k ) with a bit that indicates if it is in the set SP (Y) or not. <p> In other words, no edges are deleted and no edge-length is increased. In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], <ref> [10] </ref>, and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit <ref> [10] </ref>, Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> at least, it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], <ref> [10] </ref> [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification <p> in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], <ref> [10] </ref> [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP <p> The algorithm due to Even and Gazit <ref> [10] </ref> is similar and identifies the same set of pairs of vertices but is slightly less efficient since it does not maintain shortest-path trees. <p> The APSP solution can then be updated by updating the single-sink solution for every affected sink. The algorithms due to Rohnert [25] and Even and Gazit <ref> [10] </ref> can also be viewed as consisting of the repeated application of an algorithm for the dynamic SSSP problem, though they are not described as such. These algorithms, however, do not identify the set of affected pairs exactly.
Reference: 11. <author> Fredman, </author> <title> M.L. and Tarjan, R.E., Fibonacci heaps and their uses in improved network optimization algorithms, </title> <journal> J. ACM 34(3) pp. </journal> <month> 596-615 </month> <year> (1987). </year>
Reference-contexts: In view of Lemma 3.11, this converts the over-estimated vertex u into a correct vertex. As a result of the assignment of a new value to d (u) in line <ref> [11] </ref> some of the successors of u may fail to satisfy the invariant, though any vertex which is not a successor of u will continue to satisfy the invariant. When the loop in lines [12]-[19] completes execution all vertices are guaranteed to satisfy the invariant. <p> [1] Heap := [2] for u U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ <ref> [11] </ref> d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap <p> if p Heap (Y) then Remove p from Heap (Y) fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) <ref> [11] </ref> elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue <p> In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. Consequently, procedure recomputeProductionValue takes time O (1) if relaxed heaps [8] or Fibonacci heaps <ref> [11] </ref> are used. (In the latter case, the time complexity is the amortized complexity.) It can also be verified that the number of elements in any of the heaps is O ( | d | ). <p> In particular, if m edges are inserted into an empty graph with n vertices, the algorithm works exactly like the O (m + n log n) implementation of Dijkstra's algorithm due to Fredman and Tarjan <ref> [11] </ref>. The asymptotic complexity of the algorithm can be further improved by using the recently developed AF-heap data structure [12]. 6. Extensions to the Algorithm In this section we briefly outline various possible extensions and applications of the incremental algorithm described in the previous section. 6.1. <p> The above complexity follows from Fredman and Tarjan's <ref> [11] </ref> improvement to Dijkstra's algorithm. The complexity of the above algorithm can be improved slightly by utilising the recent O (m + nlogn /loglogn) shortest path algorithm due to Fredman and Willard [12]).
Reference: 12. <author> Fredman, </author> <title> M.L. and Willard, D.E., Trans-dichotomous algorithms for minimum spanning trees and shortest paths, pp. </title> <booktitle> 719-725 in Proceedings of the 31st Annual Symposium on Foundations of Computer Science Volume II (St. </booktitle> <address> Louis, Missouri, </address> <month> October </month> <year> 1990), </year> <booktitle> IEEE Computer Society, </booktitle> <address> Washington, DC (1990). </address>
Reference-contexts: U do [4] if rhs (u) d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) <ref> [12] </ref> for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi <p> fi [7] fi [8] if (value d (Y)) then SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ <ref> [12] </ref> AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and <p> The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap (Y) operations (lines [4] or [6]), and (d) O (1) GlobalHeap (Y) operations (lines [10], <ref> [12] </ref> or [14]). The set operations on SP (Y) can be done in constant time by associating every production Y fi g (X 1 , . . . , X k ) with a bit that indicates if it is in the set SP (Y) or not. <p> In other words, no edges are deleted and no edge-length is increased. In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], [10], and <ref> [12] </ref>) either perform an insertion or decrease the key of an item. Lines [6] and [14] are never executed. <p> The asymptotic complexity of the algorithm can be further improved by using the recently developed AF-heap data structure <ref> [12] </ref>. 6. Extensions to the Algorithm In this section we briefly outline various possible extensions and applications of the incremental algorithm described in the previous section. 6.1. <p> The above complexity follows from Fredman and Tarjan's [11] improvement to Dijkstra's algorithm. The complexity of the above algorithm can be improved slightly by utilising the recent O (m + nlogn /loglogn) shortest path algorithm due to Fredman and Willard <ref> [12] </ref>). We now consider how our incremental algorithm for the shortest-path problem can be used to solve this problem better. Let u 1 , . . . , u k be the set of all vertices in the graph that have an incoming edge of negative length. Thus k k.
Reference: 13. <author> Gondran, M. and Minoux, M., </author> <title> Graphs and Algorithms, </title> <publisher> John Wiley and Sons, </publisher> <address> New York (1984). </address>
Reference-contexts: 0 if u = source (G) = v Pred (u) min [d (v) + length (v fi u)] otherwise It can be shown that the maximal fixed point of this collection of equations is the solution to the SSSP problem if the input graph contains no negative length cycles. (See <ref> [13] </ref> for instance.) It is necessary to view the unknowns as belonging to the set of reals extended by + so that for every vertex u unreachable from the source vertex d (u) will be in the maximal fixed point, as required. <p> d (u) then [5] InsertIntoHeap ( Heap, u, min (rhs (u),d (u))) [6] fi [8] while Heap do [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do <ref> [13] </ref> rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u <p> SP (Y) := SP (Y) -pelse SP (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) <ref> [13] </ref> else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key
Reference: 14. <author> Goto, S. and Sangiovanni-Vincentelli, A., </author> <title> A new shortest path updating algorithm, Networks 8(4) pp. </title> <month> 341-372 </month> <year> (1978). </year>
Reference-contexts: [9] u := ExtractAndDeleteMin ( Heap ) [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) <ref> [14] </ref> if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := <p> (Y) := SP (Y)-p- fi [9] if (SP (Y) = ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ <ref> [14] </ref> if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d <p> The procedure essentially performs (a) one function computation (line [2]), (b) O (1) set operations (lines [8] and [9]), (c) O (1) Heap (Y) operations (lines [4] or [6]), and (d) O (1) GlobalHeap (Y) operations (lines [10], [12] or <ref> [14] </ref>). The set operations on SP (Y) can be done in constant time by associating every production Y fi g (X 1 , . . . , X k ) with a bit that indicates if it is in the set SP (Y) or not. <p> In this case it can be seen that no under-consistent vertex exists, and that the value of no vertex increases during the update. In particular, the AdjustHeap operations (in lines [4], [10], and [12]) either perform an insertion or decrease the key of an item. Lines [6] and <ref> [14] </ref> are never executed. <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. <ref> [14] </ref>, Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> [18], [2] [23], [25], [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion <ref> [14] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted Edge Insertion This paper [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion <ref> [14] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted Edge Insertion This paper [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c <p> This problem has not received much attention. The algorithm outlined in Section 6.2 for the dynamic APSP&gt;0 problem is the only known incremental algorithm for any version of the dynamic APSP problem that is capable of handling insertions and deletions of edges simultaneously. Goto and Sangiovanni-Vincentelli <ref> [14] </ref> outline an incremental algorithm for updating the solution to multiple SSSP problems on the same graph when the lengths of one or more edges in the graph are decreased. <p> Rodionov [24] considers the problem of updating the solution to the APSP problem when the lengths of one or more edges all of which have a common endpoint are decreased. Versions of the shortest-path problem other than the all-pairs version have not received much attention either. Goto and Sangiovanni-Vincentelli <ref> [14] </ref> consider the dynamic version of the problem of solving multiple single-source shortest-path problem: given a graph G and a set of source vertices S, determine the length of the shortest path between s and u for every source vertex s and every vertex u. Hence, the algorithm in [14] applies <p> Sangiovanni-Vincentelli <ref> [14] </ref> consider the dynamic version of the problem of solving multiple single-source shortest-path problem: given a graph G and a set of source vertices S, determine the length of the shortest path between s and u for every source vertex s and every vertex u. Hence, the algorithm in [14] applies to the single-source problem as a special case. The only other results concerning the dynamic SSSP problem appear in [23] and this paper. <p> Second, the version of the dynamic shortest-path problem we address, namely the single-source version, has been previously considered only in <ref> [14] </ref>. The algorithm described in this paper is more efficient and capable of handling more general modifications than the algorithm described in [14]. (However, the latter algorithm, unlike our algorithm, can handle negative edge lengths.) Finally, we have generalized our algorithm for a version of the dynamic fixed point problem. <p> Second, the version of the dynamic shortest-path problem we address, namely the single-source version, has been previously considered only in <ref> [14] </ref>. The algorithm described in this paper is more efficient and capable of handling more general modifications than the algorithm described in [14]. (However, the latter algorithm, unlike our algorithm, can handle negative edge lengths.) Finally, we have generalized our algorithm for a version of the dynamic fixed point problem.
Reference: 15. <author> Halder, </author> <title> A.K., The method of competing links, </title> <note> Transportation Science 4 pp. </note> <month> 36-51 </month> <year> (1970). </year>
Reference-contexts: [10] if rhs (u) &lt; d (u) then /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then <ref> [15] </ref> AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . <p> ) then /* Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi <ref> [15] </ref> fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder <ref> [15] </ref>, Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion <ref> [15] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted Edge Insertion This paper [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c <p> Hence, the algorithm in [14] applies to the single-source problem as a special case. The only other results concerning the dynamic SSSP problem appear in [23] and this paper. Loubal [19], and Halder <ref> [15] </ref> study a generalization of the all-pairs shortest-path problem, where a subset S of the vertices in the graph is specified and the shortest path between any two vertices in S have to be computed.
Reference: 16. <author> Hsieh, W., Kershenbaum, A., and Golden, B., </author> <title> Constrained routing in large sparse networks, pp. </title> <booktitle> 38.14-38.18 in Proceedings of IEEE International Conference on Communications, </booktitle> , <address> Philadelphia, PA (1976). </address>
Reference-contexts: /* u is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) <ref> [16] </ref> else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] <p> Y is under-consistent */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin <ref> [16] </ref> GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. <ref> [16] </ref>, Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23].
Reference: 17. <author> Knuth, D.E., </author> <title> A generalization of Dijkstra's algorithm, </title> <note> Information Processing Letters 6(1) pp. </note> <month> 1-5 </month> <year> (1977). </year>
Reference-contexts: 1. Introduction Knuth defined the following generalization of the single-source shortest-path problem, called the grammar problem <ref> [17] </ref>: Consider a context-free grammar in which every production is associated with a real-valued function whose arity equals the number of non-terminal occurrences on the right-hand side of the production. <p> However, some simple restrictions on the type of production functions allowed, which we discuss soon, guarantee that m G (Y) is well defined. We now consider some applications and special cases of the grammar problem given in <ref> [17] </ref>. <p> is overconsistent */ [11] d (u) := rhs (u) [12] for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else <ref> [17] </ref> if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs <p> */ [10] AdjustHeap ( GlobalHeap, Y, d (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := <ref> [17] </ref> for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) <p> We have also described how the algorithm can be generalized to handle negative edge lengths under certain conditions, and how the algorithm for the dynamic single-source shortest-path problem can be utilized for the dynamic all-pairs shortest-path problem as well. Knuth <ref> [17] </ref> introduced the grammar problem as a generalization of the shortest-path problem, and generalized Dijkstra's algorithm to solve the batch SF grammar problem. We know of no previous work on incremental algorithms for the dynamic grammar problem.
Reference: 18. <author> Lin, C.-C. and Chang, R.-C., </author> <title> On the dynamic shortest path problem, </title> <journal> Journal of Information Processing 13(4)(1990). </journal>
Reference-contexts: for v Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi <ref> [18] </ref> fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs <p> (Y)) [11] elseif Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do <ref> [18] </ref> recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a <p> Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines <ref> [18] </ref>, [27] and [35]), (b) O ( | Affected | ) operations on GlobalHeap (line [21]), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue. <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang <ref> [18] </ref>, Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> the dynamic shortest-path problem; at least, it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion <ref> [18] </ref>, [2] [23], [25], [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] <p> Most of the known algorithms for this problem do even better by first identifying an approximation A to the set of all affected pairs and then updating d (x,y ) only for (x,y ) A. The best algorithm currently known for this problem, developed independently by Lin and Chang <ref> [18] </ref> and Ausiello et al. [2], restricts the set of pairs of vertices for which the d value is recomputed by a careful traversal of the shortest-path trees of the graph before the modification. <p> The algorithms due to Rohnert [25] and Ramalingam and Reps [23] are based on similar ideas, though they are not as efficient as the algorithms of <ref> [18] </ref> and [2]. All of the above algorithms are bounded algorithms. It is worth mentioning that the improved efficiency of the algorithms described in [18] and [2] is obtained at a cost: these algorithms make use of the shortest-path-tree data structure, the maintenance of which can make the processing of an <p> The algorithms due to Rohnert [25] and Ramalingam and Reps [23] are based on similar ideas, though they are not as efficient as the algorithms of <ref> [18] </ref> and [2]. All of the above algorithms are bounded algorithms. It is worth mentioning that the improved efficiency of the algorithms described in [18] and [2] is obtained at a cost: these algorithms make use of the shortest-path-tree data structure, the maintenance of which can make the processing of an edge-deletion more expensive.
Reference: 19. <author> Loubal, P., </author> <title> A network evaluation procedure, </title> <journal> Highway Research Record 205 pp. </journal> <month> 96-109 </month> <year> (1967). </year>
Reference-contexts: Heap (Y) then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) <ref> [19] </ref> od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal <ref> [19] </ref>, Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] [7], [24], <ref> [19] </ref>, [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii <p> Hence, the algorithm in [14] applies to the single-source problem as a special case. The only other results concerning the dynamic SSSP problem appear in [23] and this paper. Loubal <ref> [19] </ref>, and Halder [15] study a generalization of the all-pairs shortest-path problem, where a subset S of the vertices in the graph is specified and the shortest path between any two vertices in S have to be computed.
Reference: 20. <author> Murchland, J.D., </author> <title> The effect of increasing or decreasing the length of a single arc on all shortest distances in a graph, </title> <type> Tech. Rep. </type> <institution> LBS-TNT-26, London Business School, Transport Network Theory Unit, </institution> <address> London, UK (1967). </address>
Reference-contexts: Succ (u) do [13] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi <ref> [20] </ref> else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) <p> then /* Y is over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od <ref> [20] </ref> while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that <p> In other words, p is consistent iff it satisfies the invariant and, in addition, value (p) d (Y). The precondition we assume to hold at the beginning of the update is that every unmodified production is consistent. The invariant the algorithm maintains is that whenever execution reaches line <ref> [20] </ref> every production satisfies the invariant, and that the GlobalHeap contains exactly the inconsistent non-terminals. The postcondition established by the algorithm is that every production and non-terminal in the grammar will be consistent. <p> Note that some of these steps can be redundant, in the sense that they do nothing. For instance, if the value of the production does not change, then steps [2]-[15] will not make any change to the data structures. We now show that whenever execution reaches line <ref> [20] </ref> every production satisfies the invariant, and GlobalHeap contains exactly the inconsistent non-terminals. The lines [16]-[19] initially establish the invariant. Subsequently, in each iteration of the loop in lines [20]-[38], whenever the value of a nonterminal changes (either in line [23] or line [30]) procedure recomputeProductionValue (p) is called for every <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland <ref> [20, 21] </ref>, Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] [7], [24], [19], <ref> [20] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 <p> for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] [7], [24], [19], <ref> [20] </ref> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted Edge Insertion <p> It is worth mentioning that the improved efficiency of the algorithms described in [18] and [2] is obtained at a cost: these algorithms make use of the shortest-path-tree data structure, the maintenance of which can make the processing of an edge-deletion more expensive. The algorithms due to Murchland <ref> [20] </ref>, Dionne [7], and Cheston [4] are all based on the observation that x is an affected source [sink] iff (x,v ) [(u,x)] is an affected pair. <p> All the above-mentioned algorithms use an adaptation of Dijkstra's algorithm to solve the dynamic SSSP algorithm. The algorithms can, however, be adapted to handle negative length edges using the technique outlined in Section 6.3. The algorithms due to Rodionov [24], Murchland <ref> [20] </ref>, Dionne [7], and Cheston [4], are all based on a different, and less efficient, technique of computing the new d value for every pair in A, the approximation to the set of affected pairs, using an adaptation of Floyd's algorithm for the batch shortest-path problem.
Reference: 21. <author> Murchland, J.D., </author> <title> A fixed matrix method for all shortest distances in a directed graph and for the inverse problem, </title> <type> Doctoral dissertation, </type> <institution> Universita .. t Karlsruhe, Karlsruhe, W. Germany </institution> (). 
Reference-contexts: g v (d (x 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ <ref> [21] </ref> d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else [27] if v Heap then <p> processed (lines <ref> [21] </ref>-[30]) by updating d (u) to equal , followed by an appropriate updating of the heap. In view of Lemma 3.10, this step converts an under-estimated vertex into either an over-estimated vertex or a correct vertex. Following the assignment of a new value to d (u) in line [21], only u or some successor of u can fail to satisfy the invariant. These vertices are appropriately processed in lines [22]-[29], and hence the invariant is satisfied whenever execution reaches line [8]. <p> over-consistent */ [12] AdjustHeap ( GlobalHeap, Y, min key (Heap (Y))) [13] else /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do <ref> [21] </ref> Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d <p> Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines [18], [27] and [35]), (b) O ( | Affected | ) operations on GlobalHeap (line <ref> [21] </ref>), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue. <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland <ref> [20, 21] </ref>, Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23].
Reference: 22. <editor> Pape, U., Netzwerk-veraenderungen und korrektur kuerzester weglaengen von einer wurzelmenge zu allen anderen knoten, </editor> <booktitle> Computing 12 pp. </booktitle> <month> 357-362 </month> <year> (1974). </year>
Reference-contexts: 1 ), . . . , d (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := <ref> [22] </ref> for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else [27] if v Heap then Remove v from Heap <p> /* Y is consistent */ [14] if Y GlobalHeap then Remove Y from GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value <ref> [22] </ref> if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d (X) - [25] Heap (X) := [26] for every production p with X <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape <ref> [22] </ref>, Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23].
Reference: 23. <author> Ramalingam, G. and Reps, T., </author> <title> On the computational complexity of incremental algorithms, </title> <institution> TR-1033, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1991). </note>
Reference-contexts: (x k )) [14] if rhs (v) d (v) then [15] AdjustHeap (Heap, v, min (rhs (v),d (v))) [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do <ref> [23] </ref> rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions <p> GlobalHeap fi [15] fi begin [16] GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ <ref> [23] </ref> d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d (X) - [25] Heap (X) := [26] for every production p with X on the right-hand side do [27] recomputeProductionValue (p) [28] od [29] else /* <p> We now show that whenever execution reaches line [20] every production satisfies the invariant, and GlobalHeap contains exactly the inconsistent non-terminals. The lines [16]-[19] initially establish the invariant. Subsequently, in each iteration of the loop in lines [20]-[38], whenever the value of a nonterminal changes (either in line <ref> [23] </ref> or line [30]) procedure recomputeProductionValue (p) is called for every production p that might have become inconsistent. Thus, the invariant is re-established. It follows from the explanation in the previous paragraph that every non-terminal and production in the grammar is consistent when the algorithm halts. <p> However, we note that for certain special cases, such as updating the solution to the APSP&gt;0 problem after the insertion of an edge, this approach does not yield the best possible incremental algorithm. (See <ref> [23] </ref>, for instance.) 6.3. Handling Edges with Non-Positive Lengths The proof of correctness of our algorithm and the analysis of its time complexity both rely on the fact that all edges have a positive length. <p> problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps <ref> [23] </ref>. These algorithms may be classified into groups based on (a) the information computed by the algorithm (such as the whether the all-pairs or single-source version of the problem is addressed), (b) the assumptions made about the edge lengths, and (c) the type of modification that the algorithm handles. <p> shortest-path problem; at least, it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] <ref> [23] </ref>, [25], [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 <p> (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] <ref> [23] </ref>, [25], [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted Edge Insertion This paper [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c <p> The algorithm due to Even and Gazit [10] is similar and identifies the same set of pairs of vertices but is slightly less efficient since it does not maintain shortest-path trees. The algorithms due to Rohnert [25] and Ramalingam and Reps <ref> [23] </ref> are based on similar ideas, though they are not as efficient as the algorithms of [18] and [2]. All of the above algorithms are bounded algorithms. <p> Most algorithms for processing an edge deletion follow the approach of first identifying an approximation A to the set of all affected pairs, and then computing the new d value for every affected pair. Ramalingam and Reps <ref> [23] </ref> show that it is possible to identify the set of affected pairs exactly if the graph does not have zero-length cycles, and describe the only known bounded incremental algorithm for this problem. <p> Hence, the algorithm in [14] applies to the single-source problem as a special case. The only other results concerning the dynamic SSSP problem appear in <ref> [23] </ref> and this paper. Loubal [19], and Halder [15] study a generalization of the all-pairs shortest-path problem, where a subset S of the vertices in the graph is specified and the shortest path between any two vertices in S have to be computed.
Reference: 24. <author> Rodionov, V., </author> <title> The parametric problem of shortest distances, </title> <journal> U.S.S.R. Computational Math. and Math. Phys. </journal> <pages> 8(5) pp. </pages> <month> 336-343 </month> <year> (1968). </year>
Reference-contexts: [16] else [17] if v Heap then Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) <ref> [24] </ref> if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh An under-consistent vertex u is processed (lines [21]-[30]) by updating <p> GlobalHeap := [17] for every production p P do [18] recomputeProductionValue (p) [19] od [20] while GlobalHeap do [21] Select and remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) <ref> [24] </ref> SP (X) := - p | p is a production for X such that value (p) = d (X) - [25] Heap (X) := [26] for every production p with X on the right-hand side do [27] recomputeProductionValue (p) [28] od [29] else /* X is underconsistent */ [30] d <p> We know of no previous work on incremental algorithms for the dynamic grammar problem. Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov <ref> [24] </ref>, Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert [25], Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] [7], <ref> [24] </ref>, [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper <p> time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], [25], [10] [7], <ref> [24] </ref>, [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP Restricted Edge <p> All the above-mentioned algorithms use an adaptation of Dijkstra's algorithm to solve the dynamic SSSP algorithm. The algorithms can, however, be adapted to handle negative length edges using the technique outlined in Section 6.3. The algorithms due to Rodionov <ref> [24] </ref>, Murchland [20], Dionne [7], and Cheston [4], are all based on a different, and less efficient, technique of computing the new d value for every pair in A, the approximation to the set of affected pairs, using an adaptation of Floyd's algorithm for the batch shortest-path problem. <p> Goto and Sangiovanni-Vincentelli [14] outline an incremental algorithm for updating the solution to multiple SSSP problems on the same graph when the lengths of one or more edges in the graph are decreased. Rodionov <ref> [24] </ref> considers the problem of updating the solution to the APSP problem when the lengths of one or more edges all of which have a common endpoint are decreased. Versions of the shortest-path problem other than the all-pairs version have not received much attention either.
Reference: 25. <author> Rohnert, H., </author> <title> A dynamization of the all pairs least cost path problem, pp. </title> <booktitle> 279-286 in Proceedings of STACS 85: Second Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <editor> (Saarbruecken, W. Ger., </editor> <month> Jan. </month> <pages> 3-5, </pages> <year> 1985), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 182, </volume> <editor> ed. K. Mehlhorn,Springer-Verlag, </editor> <address> New York, NY (1985). </address>
Reference-contexts: Remove v from Heap fi [18] fi [20] else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then <ref> [25] </ref> AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh An under-consistent vertex u is processed (lines [21]-[30]) by updating d (u) to equal , followed by <p> remove from GlobalHeap a non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d (X) - <ref> [25] </ref> Heap (X) := [26] for every production p with X on the right-hand side do [27] recomputeProductionValue (p) [28] od [29] else /* X is underconsistent */ [30] d (X) := [31] SP (X) := - p | p is a production for X - [32] Heap (X) := makeHeap <p> Previous work on algorithms for the dynamic shortest-path problem include papers by Murchland [20, 21], Loubal [19], Rodionov [24], Halder [15], Pape [22], Hsieh et al. [16], Cheston [4], Dionne [7], Goto et al. [14], Cheston and Corneil [5], Rohnert <ref> [25] </ref>, Even and Gazit [10], Lin and Chang [18], Ausiello et al. [1, 2], and Ramalingam and Reps [23]. <p> problem; at least, it is fairly straight-forward to determine d new (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], <ref> [25] </ref>, [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary <p> (x,y) in constant time, for any given pair of vertices (x,y ) since - 23 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Problem Modifications Best bounded algorithm (s) Other bounded algorithms Unbounded algorithms iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Insertion [18], [2] [23], <ref> [25] </ref>, [10] [7], [24], [19], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP Single Edge Deletion [25], [10], [7], [24], [20] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP-Cycle&gt;0 Single Edge Deletion [23] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Single Edge Deletion [15] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii APSP&gt;0 Arbitrary Modification This paper Repeated applications of algorithms for unit changes iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Multiple SSSP Multiple Edges Insertion [14] iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP&gt;0 Arbitrary Modification This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii SSSP-Cycle&gt;0 Multiple Edges Deletion This paper iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii <p> The algorithm due to Even and Gazit [10] is similar and identifies the same set of pairs of vertices but is slightly less efficient since it does not maintain shortest-path trees. The algorithms due to Rohnert <ref> [25] </ref> and Ramalingam and Reps [23] are based on similar ideas, though they are not as efficient as the algorithms of [18] and [2]. All of the above algorithms are bounded algorithms. <p> The APSP solution can then be updated by updating the single-sink solution for every affected sink. The algorithms due to Rohnert <ref> [25] </ref> and Even and Gazit [10] can also be viewed as consisting of the repeated application of an algorithm for the dynamic SSSP problem, though they are not described as such. These algorithms, however, do not identify the set of affected pairs exactly.
Reference: 26. <author> Spira, P.M. and Pan, A., </author> <title> On finding and updating spanning trees and shortest paths, </title> <note> SIAM J. Computing 4(3) pp. 375-380 (Sep-tember 1975). </note>
Reference-contexts: Spira and Pan <ref> [26] </ref>, in fact, show that no incremental algorithm for this problem can do better than the best batch algorithm, under the assumption that the incremental algorithm retains only the shortest-paths information. <p> else /* u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) <ref> [26] </ref> else [27] if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh An under-consistent vertex u is processed (lines [21]-[30]) by updating d (u) to equal , followed by an appropriate updating of the heap. <p> non-terminal X with minimum key value [22] if key (X) &lt; d (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d (X) - [25] Heap (X) := <ref> [26] </ref> for every production p with X on the right-hand side do [27] recomputeProductionValue (p) [28] od [29] else /* X is underconsistent */ [30] d (X) := [31] SP (X) := - p | p is a production for X - [32] Heap (X) := makeHeap (- p | p <p> Consequently, these algorithms are unbounded. Let us now consider the problem of processing the deletion of an edge u fi v from the graph. Edge deletion is not as easy to handle as edge insertion. As Spira and Pan <ref> [26] </ref> show, the batch all-pairs shortest-path problem can, in some sense, be reduced to the problem of updating the solution to the all-pairs shortest-path problem after an edge deletion.
Reference: 27. <author> Tarjan, R.E., </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1983). </address>
Reference-contexts: u is underconsistent */ [21] d (u) := [22] for v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else <ref> [27] </ref> if v Heap then Remove v from Heap fi [28] fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh An under-consistent vertex u is processed (lines [21]-[30]) by updating d (u) to equal , followed by an appropriate updating of the heap. <p> (X) then /* X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d (X) - [25] Heap (X) := [26] for every production p with X on the right-hand side do <ref> [27] </ref> recomputeProductionValue (p) [28] od [29] else /* X is underconsistent */ [30] d (X) := [31] SP (X) := - p | p is a production for X - [32] Heap (X) := makeHeap (- p | p is a production for X with value (p) &lt; d (X) -) <p> Consequently, the steps executed by the main procedure can be divided into (a) O ( || Changed || B ) invocations of the procedure recomputeProductionValue (lines [18], <ref> [27] </ref> and [35]), (b) O ( | Affected | ) operations on GlobalHeap (line [21]), and (c) the remaining steps, which take time O ( || Changed || B ). Let us now consider the time taken by a single execution of procedure recomputeProductionValue. <p> The idea is to adapt the technique of Edmonds and Karp for transforming the length of every edge to a non-negative real without changing the graph's shortest paths <ref> [9, 27] </ref>.
Reference: 28. <author> Yap, C.K., </author> <title> A hybrid algorithm for the shortest path between two nodes in the presence of few negative arcs, </title> <note> Information Processing Letters 16 pp. </note> <month> 181-182 (May </month> <year> 1983). </year>
Reference-contexts: Yap proposed an algorithm for finding the shortest path between two vertices (i.e., for the single-pair shortest-path problem) in graphs with a few negative edges <ref> [28] </ref>. Yap's algorithm is more efficient than the standard algorithms that handle an arbitrary number of negative edges; however, the incremental SSSP&gt;0 algorithm can be employed in an algorithm that is even more efficient. <p> v (Succ (u) -u-) do [23] rhs (v) := g v (d (x 1 ), . . . , d (x k )) [24] if rhs (v) d (v) then [25] AdjustHeap (Heap, v, min (rhs (v),d (v))) [26] else [27] if v Heap then Remove v from Heap fi <ref> [28] </ref> fi [30] fi end postconditions Every vertex in V (G) is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh An under-consistent vertex u is processed (lines [21]-[30]) by updating d (u) to equal , followed by an appropriate updating of the heap. <p> X is overconsistent */ [23] d (X) := key (X) [24] SP (X) := - p | p is a production for X such that value (p) = d (X) - [25] Heap (X) := [26] for every production p with X on the right-hand side do [27] recomputeProductionValue (p) <ref> [28] </ref> od [29] else /* X is underconsistent */ [30] d (X) := [31] SP (X) := - p | p is a production for X - [32] Heap (X) := makeHeap (- p | p is a production for X with value (p) &lt; d (X) -) [33] if Heap <p> We leave the details to the reader. 6.4. The Batch Shortest-Path Problem in the Presence of Few Negative Edges Yap <ref> [28] </ref> describes an algorithm for finding the shortest path between two vertices in a graph that may include edges with negative length. This algorithm works better than the standard Bellman and Ford algorithm when the number of negative length edges is small.
References-found: 28

