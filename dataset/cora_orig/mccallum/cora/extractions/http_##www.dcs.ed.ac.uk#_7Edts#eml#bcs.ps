URL: http://www.dcs.ed.ac.uk/%7Edts/eml/bcs.ps
Refering-URL: http://www.cis.ohio-state.edu/hypertext/faq/usenet/meta-lang-faq/faq.html
Root-URL: 
Title: Formal program development in Extended ML for the working programmer  
Author: Donald Sannella 
Abstract: Extended ML is a framework for the formal development of programs in the Standard ML programming language from high-level specifications of their required input/output behaviour. It strongly supports the development of modular programs consisting of an interconnected collection of generic and reusable units. The Extended ML framework includes a methodology for formal program development which establishes a number of ways of proceeding from a given specification of a programming task towards a program. Each such step gives rise to one or more proof obligations which must be proved in order to establish the correctness of that step. This paper is intended as a user-oriented summary of the Extended ML language and methodology. Theoretical technicalities are avoided whenever possible, with emphasis placed on the practical aspects of formal program development. An extended example of a complete program development in Extended ML is included.
Abstract-found: 1
Intro-found: 1
Reference: [ Note: LNCS n = Springer Lecture Notes in Computer Science, Volume n ] 
Reference: [BW 88] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall (1988). </publisher>
Reference-contexts: The core language provides constructs for programming "in the small" by defining a collection of types and values of those types. Programs written in the core language look very similar to programs in Hope [BMS 80], Miranda <ref> [BW 88] </ref> or Haskell [HW 89]. The module language provides constructs for programming "in the large" by defining and combining a number of self-contained program units. These sub-languages can be viewed as more or less independent since there are relatively few points of contact between the sub-languages.
Reference: [BDMP 85] <author> D. Bjtrner, T. Denvir, E. Meiling and J. Pedersen. </author> <title> The RAISE project: fundamental issues and requirements. </title> <note> Report RAISE/DDC/EM/1/V6, Dansk Datamatic Center (1985). 32 </note>
Reference-contexts: VDM is a method for software specification and development, based on the use of explicitly-defined models of software systems, which has been widely applied in practice. However, it is rigorous rather than fully formal, and lacks formal mathematical foundations and explicit structuring mechanisms (the RAISE project <ref> [BDMP 85] </ref> is attempting to fill these gaps).
Reference: [BMS 80] <author> R. Burstall, D. MacQueen and D. Sannella. </author> <title> Hope: an experimental applicative language. </title> <booktitle> Proc. 1980 LISP Conference, </booktitle> <address> Stanford, California, </address> <pages> pp. </pages> <month> 136-143 </month> <year> (1980). </year>
Reference-contexts: The core language provides constructs for programming "in the small" by defining a collection of types and values of those types. Programs written in the core language look very similar to programs in Hope <ref> [BMS 80] </ref>, Miranda [BW 88] or Haskell [HW 89]. The module language provides constructs for programming "in the large" by defining and combining a number of self-contained program units. These sub-languages can be viewed as more or less independent since there are relatively few points of contact between the sub-languages.
Reference: [GB 84] <author> J. Goguen and R. Burstall. </author> <title> Introducing institutions. </title> <booktitle> Proc. Logics of Programming Workshop, Carnegie-Mellon. </booktitle> <volume> LNCS 164, </volume> <pages> pp. </pages> <month> 221-256 </month> <year> (1984). </year>
Reference-contexts: This choice is rather arbitrary since the formal underpinnings of Extended ML are actually entirely independent of the choice of logic (see [ST 86] for the details; a logic suitable for use is called an institution <ref> [GB 84] </ref>). It is natural to choose a logic which has the Standard ML core language as a subset; this way, the development process comes to an end when all the axioms in structure and functor bodies are expressed in this executable subset.
Reference: [GM 87] <author> J. Goguen and J. Meseguer. </author> <title> Order-sorted algebra solves the constructor-selector, multiple representation and coercion problems. </title> <booktitle> Proc. 2nd IEEE Symp. on Logic in Computer Science, </booktitle> <address> Ithaca, New York, </address> <pages> pp. </pages> <month> 18-29 </month> <year> (1987). </year>
Reference-contexts: The notation of first-order equational logic has been used here to write axioms and signatures/structures contain types and values as in ML, but we could have used order-sorted equational logic <ref> [GM 87] </ref> and imposed a sub-type relation on types as in OBJ3 [GW 88] (although this would have been a awkward choice for producing programs in Standard ML since it is unable to cope with sub-types and coercions).
Reference: [GW 88] <author> J. Goguen and T. Winkler. </author> <title> Introducing OBJ3. </title> <type> Report SRI-CSL-88-9, </type> <institution> Computer Science Laboratory, SRI International (1988). </institution>
Reference-contexts: The notation of first-order equational logic has been used here to write axioms and signatures/structures contain types and values as in ML, but we could have used order-sorted equational logic [GM 87] and imposed a sub-type relation on types as in OBJ3 <ref> [GW 88] </ref> (although this would have been a awkward choice for producing programs in Standard ML since it is unable to cope with sub-types and coercions).
Reference: [Har 89] <author> R. Harper. </author> <title> Introduction to Standard ML. </title> <type> Report ECS-LFCS-86-14, </type> <institution> Univ. of Edinburgh. </institution> <note> Revised edition (1989). </note>
Reference-contexts: The features of Standard ML are introduced at a more tutorial level in [Wik 87] (core language only), [Tofte 89] (mainly module language), <ref> [Har 89] </ref>, and [Reade 89]. Standard ML consists of two sub-languages: the Standard ML "core language" and the Standard ML "module language". The core language provides constructs for programming "in the small" by defining a collection of types and values of those types.
Reference: [HMM 86] <author> R. Harper, D. MacQueen and R. Milner. </author> <title> Standard ML. </title> <type> Report ECS-LFCS-86-2, </type> <institution> Univ. of Edinburgh (1986). </institution>
Reference-contexts: A complete description of the language appears in <ref> [HMM 86] </ref>, and a complete formal semantics is in 3 [HMT 89] which also includes historical comments on the development of the language.
Reference: [HMT 89] <author> R. Harper, R. Milner and M. Tofte. </author> <title> The definition of Standard ML (version 3). </title> <type> Report ECS-LFCS-89-81, </type> <institution> Univ. of Edinburgh (1989). </institution>
Reference-contexts: A complete description of the language appears in [HMM 86], and a complete formal semantics is in 3 <ref> [HMT 89] </ref> which also includes historical comments on the development of the language. The features of Standard ML are introduced at a more tutorial level in [Wik 87] (core language only), [Tofte 89] (mainly module language), [Har 89], and [Reade 89].
Reference: [HW 89] <editor> P. Hudak and P. Wadler et al. </editor> <title> Report on the functional programming language Haskell. </title> <type> Report CSC/89/R5, </type> <institution> Univ. of Glasgow (1989). </institution>
Reference-contexts: The core language provides constructs for programming "in the small" by defining a collection of types and values of those types. Programs written in the core language look very similar to programs in Hope [BMS 80], Miranda [BW 88] or Haskell <ref> [HW 89] </ref>. The module language provides constructs for programming "in the large" by defining and combining a number of self-contained program units. These sub-languages can be viewed as more or less independent since there are relatively few points of contact between the sub-languages.
Reference: [Jones 80] <author> C. Jones. </author> <title> Software Development: A Rigorous Approach. </title> <publisher> Prentice-Hall (1980). </publisher>
Reference-contexts: Developing such a logic will not be an easy job by any means, but it is one which can be tackled separately. The aims of Extended ML are broadly similar to those of work on rigorous program development by the VDM school (see e.g. <ref> [Jones 80] </ref>). VDM is a method for software specification and development, based on the use of explicitly-defined models of software systems, which has been widely applied in practice.
Reference: [MacQ 86] <author> D. MacQueen. </author> <title> Modules for Standard ML. In: [HMM 86] (1986). </title>
Reference-contexts: In Standard ML, the information passed to the outside world about a structure/functor is taken to be that in its signature (s) augmented by any information about type and structure sharing which can be inferred from the body (sharing by construction in <ref> [MacQ 86] </ref>). Extended ML is more strict: only the information which is explicitly recorded in the signature (s) of a structure/functor is available externally. Thus, any program which is well-typed in Extended ML will be well-typed in Standard ML but not vice versa. <p> Without this constraint, the information that the type Elements.elem in the structure Sort'(IntPO) is the type int would be unavailable. (This means that structures in Extended ML are actually abstractions in the sense of <ref> [MacQ 86] </ref>, and functors are parameterized abstractions.) 3 The Extended ML wide-spectrum language This section reviews the main features of the Extended ML specification/programming language. A more complete introduction to the Extended ML language appears in [ST 85].
Reference: [Reade 89] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley (1989). </publisher>
Reference-contexts: The features of Standard ML are introduced at a more tutorial level in [Wik 87] (core language only), [Tofte 89] (mainly module language), [Har 89], and <ref> [Reade 89] </ref>. Standard ML consists of two sub-languages: the Standard ML "core language" and the Standard ML "module language". The core language provides constructs for programming "in the small" by defining a collection of types and values of those types.
Reference: [SB 83] <author> D. Sannella and R. Burstall. </author> <title> Structured theories in LCF. </title> <booktitle> Proc. 8th Colloq. on Trees in Algebra and Programming, </booktitle> <address> L'Aquila, Italy. </address> <publisher> LNCS 159, </publisher> <pages> pp. </pages> <month> 377-391 </month> <year> (1983). </year>
Reference-contexts: A number of theorem provers are available which are able to cope with the proofs involved in program development examples like the one in Section 5, but once one is adopted it will have to be enriched to cope with the modular structure of specifications along the lines described in <ref> [SB 83] </ref>. A component is also needed to generate proof obligations from development steps and to keep track of these and of the programming tasks which remain to be tackled. Other plans are sketched in [ST 88].
Reference: [SS 89] <author> D. Sannella and F. da Silva. </author> <title> Syntax, typechecking and dynamic semantics for Extended ML. </title> <type> Report ECS-LFCS-89-101, </type> <institution> Univ. of Edinburgh (1989). </institution>
Reference-contexts: The version of Extended ML used in this paper is different in certain details from the one presented in [ST 85] 9 but the general motivation and ideas and the overall appearance of specifications remains the same. <ref> [SS 89] </ref> defines the syntax and some aspects of the semantics of Extended ML, and a complete formal semantics will be forthcoming. Extended ML is intended as a vehicle for the systematic formal development of programs from specifications by means of individually-verified steps.
Reference: [SST 89] <author> D. Sannella, S. Soko lowski and A. Tarlecki. </author> <title> Toward formal development of programs from algebraic specifications: parameterisation revisited. </title> <type> Technical Report, </type> <institution> Laboratory for Foundations of Computer Science, Dept. of Computer Science, Univ. </institution> <note> of Edinburgh (to appear). </note>
Reference-contexts: From a methodological point of view, this extension adds considerable power; one intriguing point is that it seems to introduce a bottom-up element into Extended ML's top-down program development methodology. A more detailed discussion of this issue may be found in <ref> [SST 89] </ref>. 16 5 An example In this section the formal development process presented in the previous section is demonstrated by means of an example. Two different developments are given which begin from the same high-level Extended ML requirements specification and yield different Standard ML programs.
Reference: [ST 85] <author> D. Sannella and A. Tarlecki. </author> <title> Program specification and development in Standard ML. </title> <booktitle> Proc. 12th ACM Symp. on Principles of Programming Languages, </booktitle> <address> New Orleans, </address> <pages> pp. </pages> <month> 67-77 </month> <year> (1985). </year>
Reference-contexts: A more complete introduction to the Extended ML language appears in <ref> [ST 85] </ref>. The version of Extended ML used in this paper is different in certain details from the one presented in [ST 85] 9 but the general motivation and ideas and the overall appearance of specifications remains the same. [SS 89] defines the syntax and some aspects of the semantics of <p> A more complete introduction to the Extended ML language appears in <ref> [ST 85] </ref>. The version of Extended ML used in this paper is different in certain details from the one presented in [ST 85] 9 but the general motivation and ideas and the overall appearance of specifications remains the same. [SS 89] defines the syntax and some aspects of the semantics of Extended ML, and a complete formal semantics will be forthcoming.
Reference: [ST 86] <author> D. Sannella and A. Tarlecki. </author> <title> Extended ML: an institution-independent framework for formal program development. </title> <booktitle> Proc. Workshop on Category Theory and Computer Programming, Guildford. </booktitle> <volume> LNCS 240, </volume> <pages> pp. </pages> <month> 364-389 </month> <year> (1986). </year>
Reference-contexts: The examples above and those in the sequel use the notation of first-order equational logic to write axioms. This choice is rather arbitrary since the formal underpinnings of Extended ML are actually entirely independent of the choice of logic (see <ref> [ST 86] </ref> for the details; a logic suitable for use is called an institution [GB 84]). <p> One important feature of Extended ML which has not been stressed in this paper is the fact that the Extended ML language and methodology are practically independent of the logic used to write axioms, as well as of the form of signatures and structures (see <ref> [ST 86] </ref> for details).
Reference: [ST 88] <author> D. Sannella and A. Tarlecki. </author> <title> Tools for formal program development: some fantasies. </title> <journal> LFCS Newsletter, </journal> <volume> No. 1, </volume> <pages> pp. </pages> <month> 10-15 </month> <year> (1988). </year>
Reference-contexts: A component is also needed to generate proof obligations from development steps and to keep track of these and of the programming tasks which remain to be tackled. Other plans are sketched in <ref> [ST 88] </ref>. The support system will be written in Standard ML, which will allow us to experiment with the use of the techniques we advocate in developing the components of the system itself. Acknowledgements Much of this paper is a rehash of ideas from [ST 89].
Reference: [ST 89] <author> D. Sannella and A. Tarlecki. </author> <title> Toward formal development of ML programs: foundations and methodology. </title> <type> Report ECS-LFCS-89-71, </type> <institution> Laboratory for Foundations of Computer Science, Dept. of Computer Science, Univ. </institution> <note> of Edinburgh (1989); extended abstract in Proc. </note> <editor> Colloq. </editor> <booktitle> on Current Issues in Programming Languages, Joint Conf. on Theory and Practice of Software Development (TAPSOFT), Barcelona. </booktitle> <volume> LNCS 352, </volume> <pages> pp. </pages> <month> 375-389 </month> <year> (1989). </year>
Reference-contexts: Finally, Section 6 concludes with some remarks about some potential areas of future progress. Readers who are interested in the theory which underlies Extended ML should consult <ref> [ST 89] </ref>; among other things, this explains in detail why the formal program development process outlined here is guaranteed to yield a program which is correct with respect to the original specification of requirements. 2 An overview of Standard ML The aim of this section is to briefly review the main <p> Because of examples like the one above, validity of implementations is defined in Extended ML in terms of satisfaction of axioms "up to behavioural equivalence" with respect to an appropriate set of "observable types". The details of this may be found in <ref> [ST 89] </ref>. The proper treatment of this issue is one of the most important facets of the design of Extended ML. <p> In principle, this makes the condition easier to satisfy since it only requires the observable consequences of the axioms in SIG to follow from the axioms and definitions in exp 1 ; : : : ; exp n (see <ref> [ST 89] </ref> for full details). In practice, convenient methods for proving such conditions have not yet been established and so the proof itself is rather difficult. Since the examples at hand do not require this extra flexibility, we will use the simple but strict form of the conditions listed above. <p> Other plans are sketched in [ST 88]. The support system will be written in Standard ML, which will allow us to experiment with the use of the techniques we advocate in developing the components of the system itself. Acknowledgements Much of this paper is a rehash of ideas from <ref> [ST 89] </ref>. I gratefully acknowledge the work of Andrzej Tarlecki of the Polish Academy of Sciences in our continuing collaboration on Extended ML and on topics in the foundations of algebraic specification and formal program development on which this work is based.
Reference: [SW 87] <author> D. Sannella and L. Wallen. </author> <title> A calculus for the construction of modular Prolog programs. </title> <booktitle> Proc. 1987 IEEE Symp. on Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pp. </pages> <month> 368-378 </month> <year> (1987). </year> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: These sub-languages can be viewed as more or less independent since there are relatively few points of contact between the sub-languages. A similar modulariza-tion mechanism could be added to other programming languages; see <ref> [SW 87] </ref> for the design of an ML-style module system for Prolog. 2.1 The Standard ML core language Standard ML is a strongly typed language. Every expression has a type which is inferred automatically by the Standard ML compiler. <p> For example, if we switch to untyped first-order predicate logic and regard Horn clauses as the executable subset of this logic, the result is a language and methodology for developing modular Prolog programs (see <ref> [SW 87] </ref>) from specifications. Another consequence is that the present restriction to a small subset of Standard ML (excluding higher-order functions, polymorphism, references, exceptions etc.) is only necessary until a logic is developed which is able to cope with all these features adequately.
Reference: [Sed 88] <author> R. Sedgewick. </author> <title> Algorithms, 2nd edition. </title> <publisher> Addison-Wesley (1988). </publisher>
Reference-contexts: There are many possibilities, including at least the following (see <ref> [Sed 88] </ref> and similar texts for details): 1. Terms built from the constant empty using the constructor function add. 2. Sequences with identifiers kept in the order in which they are added. 3. Like (2), but with duplicates removed.
Reference: [Tofte 89] <author> M. Tofte. </author> <title> Four lectures on Standard ML. </title> <type> Report ECS-LFCS-89-73, </type> <institution> Univ. of Edinburgh (1989). </institution>
Reference-contexts: A complete description of the language appears in [HMM 86], and a complete formal semantics is in 3 [HMT 89] which also includes historical comments on the development of the language. The features of Standard ML are introduced at a more tutorial level in [Wik 87] (core language only), <ref> [Tofte 89] </ref> (mainly module language), [Har 89], and [Reade 89]. Standard ML consists of two sub-languages: the Standard ML "core language" and the Standard ML "module language". The core language provides constructs for programming "in the small" by defining a collection of types and values of those types.
Reference: [Wik 87] <author> A. Wikstrom. </author> <title> Functional Programming Using Standard ML. </title> <publisher> Prentice-Hall (1987). </publisher>
Reference-contexts: A complete description of the language appears in [HMM 86], and a complete formal semantics is in 3 [HMT 89] which also includes historical comments on the development of the language. The features of Standard ML are introduced at a more tutorial level in <ref> [Wik 87] </ref> (core language only), [Tofte 89] (mainly module language), [Har 89], and [Reade 89]. Standard ML consists of two sub-languages: the Standard ML "core language" and the Standard ML "module language".
References-found: 25

