URL: http://www.cs.rice.edu/CS/PLT/Publications/cs96-cf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Program Verification through Soft Typing  
Author: Robert Cartwright Matthias Felleisen 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: During the past 25 years, programming language researchers have developed increasingly sophisticated techniques for statically analyzing program behavior. These techniques have been widely used in optimizing compilers to infer program properties supporting code optimization, but they have had little impact on program development and maintenance. This paper explains how these techniques can be be used to perform a restricted form of program verification, namely the automatic proof of the preconditions of primitive operations. Computations in high-level programming languages are expressed in terms of operations on abstract values such as integers, arrays, lists, and functions. Most of these operations are defined only for selected inputs such as the set of all integers or the set of non-empty lists. Nevertheless, the machine code for an operation always does something regardless of the form of the input. If a language fails to prevent the application of an operation's machine code to illegal inputs (which are bitstrings), it is unsafe because subsequent program behavior is unpredictable. To ensure safety, some high-level languages prevent the misapplication of operations through a combination of static and dynamic checks. Some safe languages, such as ML and Modula III, rely primarily on static checks, while others, such as Scheme and Smalltalk, rely exclusively on dynamic checks. From the perspective of program reliability, static checking is preferable to dynamic checking because it proves preconditions for program operations instead of merely testing them on individual inputs. In essence, static checking is a restricted form of program verification where the invariant assertions are the preconditions of primitive operations. If all the preconditions in a program are valid invariants, then it can never abort with a run-time error. 1 Statically typed languages enforce the preconditions for some operations by including inference rules in the syntax of the language. But the preconditions for many operations, such as extracting the head of a list or an element of an array, cannot be proven by simple syntactic arguments. To support a more aggressive approach to proving operation preconditions, we have developed a generalization of static typing called soft type analysis [1] that is performed by the programming environment rather than the language compiler. A soft type analyzer generates and proves program invariants corresponding to the preconditions of primitive operations. Since these preconditions are undecidable in general, no soft type analyzer can prove every valid precondition. The analyzer flags each primitive operation 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Cartwright, R. and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In Proc. SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <year> 1991, </year> <pages> 278-292. </pages>
Reference-contexts: Since soft typing decouples static analysis from syntax checking, it is applicable to both statically and dynamically typed languages. Over the past five years, we have designed and implemented two different soft type analyzers for Scheme. One is based on a generalization of the familiar Hindley-Milner type discipline <ref> [1, 6] </ref>. Instead of the usual type algebra where basic types are constants and type constructors are operators, the soft type analyzer relies on an augmented type algebra including a restricted union operator. Our second soft type analyzer relies on Heintze's [5] formulation of flow analysis as set-based analysis [3].
Reference: 2. <author> Cousot, P. and R. Cousot. </author> <title> Formal language, grammar, and set-constraint-based program analysis by abstract interpretation. </title> <booktitle> In Proc. 1995 Conference on Functional Programming and Computer Architecture, </booktitle> <pages> 170-181. </pages>
Reference-contexts: Our second soft type analyzer relies on Heintze's [5] formulation of flow analysis as set-based analysis [3]. Set-based analysis interprets <ref> [2] </ref> program constructs as operations on sets of values, capturing the intuitive idea of generalized program evaluation on the set of "all-possible" values for each expression. Both soft type analyzers prove 90% of the preconditions (excluding the analysis of array references) in typical Scheme code.
Reference: 3. <author> Flanagan, C. and M Felleisen. </author> <title> Set based analysis for full Scheme and its use in soft-typing. </title> <type> Manuscript. </type> <note> Submitted for journal publication. 1995. URL: http://www.cs.rice.edu/ cormac/. </note>
Reference-contexts: Instead of the usual type algebra where basic types are constants and type constructors are operators, the soft type analyzer relies on an augmented type algebra including a restricted union operator. Our second soft type analyzer relies on Heintze's [5] formulation of flow analysis as set-based analysis <ref> [3] </ref>. Set-based analysis interprets [2] program constructs as operations on sets of values, capturing the intuitive idea of generalized program evaluation on the set of "all-possible" values for each expression. Both soft type analyzers prove 90% of the preconditions (excluding the analysis of array references) in typical Scheme code.
Reference: 4. <author> Flanagan, C., M. Flatt, Shriram K., S. Weirich, and M. Felleisen. </author> <title> Static debugging or browsing the web of program invariants. </title> <booktitle> In Proc. Sigplan 1996 Conference on Programming Language Design and Implementation, to appear. </booktitle>
Reference-contexts: The analyzer supports a graphical interface that marks up the text of the original program with hyperlinks giving the type of each expression and the flow constraints that produced it. In extensive tests of both analyzers, we have made two important observations <ref> [4] </ref>. First, programmers embrace soft type analysis if it is readily available as an editor command applicable to any compilable program unit. Second, programmers can exploit the results of soft type analysis more effectively if the analyzer clearly explains why it cannot prove a given precondition.
Reference: 5. <author> Heintze, N. </author> <title> Set based analysis of ML programs. </title> <type> Technical Report CMU CS 93-193. </type> <institution> Carnegie Mellon University, </institution> <month> July </month> <year> 1993. </year> <booktitle> In 1994 ACM Conference on LISP and Functional Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Instead of the usual type algebra where basic types are constants and type constructors are operators, the soft type analyzer relies on an augmented type algebra including a restricted union operator. Our second soft type analyzer relies on Heintze's <ref> [5] </ref> formulation of flow analysis as set-based analysis [3]. Set-based analysis interprets [2] program constructs as operations on sets of values, capturing the intuitive idea of generalized program evaluation on the set of "all-possible" values for each expression.
Reference: 6. <author> Wright, A.K. and R. Cartwright. </author> <title> A practical soft type system for Scheme. </title> <booktitle> In 1994 ACM Conference on LISP and Functional Programming, </booktitle> <year> 1994, </year> <pages> 250-262. 3 </pages>
Reference-contexts: Since soft typing decouples static analysis from syntax checking, it is applicable to both statically and dynamically typed languages. Over the past five years, we have designed and implemented two different soft type analyzers for Scheme. One is based on a generalization of the familiar Hindley-Milner type discipline <ref> [1, 6] </ref>. Instead of the usual type algebra where basic types are constants and type constructors are operators, the soft type analyzer relies on an augmented type algebra including a restricted union operator. Our second soft type analyzer relies on Heintze's [5] formulation of flow analysis as set-based analysis [3].
References-found: 6

