URL: http://www.cs.rice.edu/CS/PLT/Publications/jfp96-af.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: The Call-By-Need Lambda Calculus  
Author: Zena M. Ariola Matthias Felleisen 
Address: Houston, Texas  
Affiliation: Computer Information Science Department University of Oregon Eugene, Oregon  Department of Computer Science Rice University  
Date: 1 (1): 1-000, January 1993  
Note: J. Functional Programming  c Cambridge University Press 1  Supported by NSF grant CCR 91-22518  
Abstract: Plotkin [Theor. Comp. Sci. 1975] showed that the lambda calculus is a good model of the evaluation process for call-by-name functional programs. Reducing programs to constants or lambda abstractions according to the leftmost-outermost strategy exactly mirrors execution on an abstract machine like Landin's SECD machine. The machine-based evaluator returns a constant or the token closure if and only if the standard reduction sequence starting at the same program will end in the same constant or in some lambda abstraction. However, the calculus does not capture the sharing of the evaluation of arguments that lazy implementations use to speed up the execution. More precisely, a lazy implementation evaluates procedure arguments only when needed and then only once. All other references to the formal procedure parameter re-use the value of the first argument evaluation. The mismatch between the operational semantics of the lambda calculus and the actual behavior of the prototypical implementation is a major obstacle for compiler writers. Unlike implementors of the leftmost-outermost strategy or of a call-by-value language, implementors of lazy systems cannot easily explain the behavior of their evaluator in terms of source level syntax. Hence, they often cannot explain why a certain syntactic transformation "works" and why another doesn't. In this paper we develop an equational characterization of the most popular lazy implementation technique|traditionally called "call-by-need"|and prove it correct with respect to the original lambda calculus. The theory is a strictly smaller theory than Plotkin's call-by-name lambda calculus. Immediate applications of the theory concern the correctness proofs of a number of implementation strategies, e.g., the call-by-need continuation passing transformation and the realization of sharing via assignments. Note: Some of this material first appeared in a paper presented at the 1995 ACM Conference on the Principles of Programming Languages. The paper was a joint effort with Maraist, Odersky and Wadler, who had independently developed a different equational characterization of call-by-need. We contrast our work with that of Maraist et al. in the body of this paper where appropriate. y Supported by NSF grant CCR-94-10237 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abadi, M., Cardelli, L., Curien, P.-L., & Levy, J.-J. </author> <year> (1991). </year> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1), </volume> <pages> 375-416. </pages>
Reference: <author> Abramsky, S. </author> <year> (1990). </year> <title> The lazy lambda calculus. </title> <editor> Turner, D. (ed), </editor> <booktitle> Declarative Programming. </booktitle> <publisher> Addison-Wesley. </publisher>
Reference: <author> Ariola, Z. M., & Arvind. </author> <year> (1995). </year> <title> Properties of a first-order functional language with sharing. </title> <journal> Theoretical Computer Science, </journal> <volume> 146, </volume> <pages> 69-108. </pages>
Reference-contexts: The key step of the completeness proof is the introduction of an ordering between terms of let . Intuitively, M N if M can be obtained by unwinding N , that is, the -ordering captures the amount of sharing contained in a term <ref> (Ariola & Arvind, 1995) </ref>. The ordering relation expresses whether the terms have homomorphic graphs. For example, the graph of M (x:x)(x:x) can be homomorphically embedded into the graph of N let y = x:x in yy, xxx @@ which shows that M N .
Reference: <author> Ariola, Z. M., & Klop, J. W. </author> <year> (1994). </year> <title> Cyclic lambda graph rewriting. </title> <booktitle> Pages 416-425 of: Proc. Ninth Symposium on Logic in Computer Science (LICS'94), </booktitle> <address> Paris, France. </address>
Reference: <author> Ariola, Z. M., & Klop, J. W. </author> <year> (1996). </year> <title> Lambda calculus with explicit recursion. </title> <type> Tech. </type> <institution> rept. CIS-TR-96-04. Department of computer and information science, University of Oregon. </institution>
Reference-contexts: Suppose M (x:x)(x:x) then M N , yet N does not contain a fi let redex. This is so because the language of dags captures only the sharing in a term but not its let-structure. We thus enrich dags with boxes and labeled edges <ref> (Ariola & Klop, 1996) </ref>. Dag 2 (M ) is the decorated dag associated with a term M . A box can be thought of as a refined version of a node; the label associated with an edge is just a sequence of let-bound variable names.
Reference: <author> Ariola, Z. M., Felleisen, M., Maraist, J., Odersky, M., & Wadler, P. </author> <year> (1995). </year> <title> The call-by-need lambda calculus. </title> <booktitle> Pages 233-246 of: Proc. ACM Conference on Principles of Programming Languages. </booktitle>
Reference-contexts: The key step of the completeness proof is the introduction of an ordering between terms of let . Intuitively, M N if M can be obtained by unwinding N , that is, the -ordering captures the amount of sharing contained in a term <ref> (Ariola & Arvind, 1995) </ref>. The ordering relation expresses whether the terms have homomorphic graphs. For example, the graph of M (x:x)(x:x) can be homomorphically embedded into the graph of N let y = x:x in yy, xxx @@ which shows that M N .
Reference: <author> Arvind, Kathail, V., & Pingali, K. </author> <year> (1984). </year> <title> Sharing of computation in functional language implementations. </title> <booktitle> Pages 5.1-5.12 of: Proc. International Workshop on High-Level Computer Architecture. </booktitle>
Reference: <author> Barendregt, H. P. </author> <year> (1984). </year> <title> The lambda calculus: Its syntax and semantics. </title> <publisher> North-Holland, Amsterdam. </publisher>
Reference-contexts: For example, lazy cons only evaluates its arguments when there is a demand for their respective values (Friedman & Wise, 1976). The evaluation rules for cons can be inferred from the usual encoding of cons and the related destructure operations as functions <ref> (Barendregt, 1984) </ref>: cons = (x 1 x 2 p:px 1 x 2 ), car = p:p (x 1 x 2 :x 1 ), and cdr = p:p (x 1 x 2 :x 2 ). Recursion A deficiency of the call-by-need calculus is its treatment of recursive or cyclic values.
Reference: <author> Bloo, Roel, & Rose, Kristoffer Htgsbro. </author> <year> (1995). </year> <title> Preservation of strong normalisation in named lambda calculi with explicit substitution and garbage collection. </title> <booktitle> Pages 62-72 of: CSN '95 Computer Science in the Netherlands. </booktitle>
Reference: <author> Crank, E., & Felleisen, M. </author> <year> (1990). </year> <title> Parameter-passing and the lambda calculus. </title> <booktitle> Pages 233-244 of: Proc. ACM Conference on Principles of Programming Languages. </booktitle>
Reference: <author> Felleisen, M., & Friedman, D. P. </author> <year> (1986). </year> <title> Control operators, the SECD-machine, and the lambda-calculus. </title> <booktitle> Pages 193-217 of: 3rd Working Conference on the Formal Description of Programming Concepts. </booktitle>
Reference-contexts: Put differently, a correct implementation of the evaluator can simply reduce the standard or leftmost-outermost redex of a program until the program becomes a value. A convenient way of formulating the evaluation relation based on the standard reduction strategy utilizes contexts for identifying the standard redex <ref> (Felleisen & Friedman, 1986) </ref>, where a context is a term with a hole in it (written as [ ]). The evaluation context is such that the redex filling the hole is the standard redex. <p> Verifying that the standard relation, 7! need , is indeed a function from programs to programs relies on the usual Unique Evaluation Context lemma <ref> (Felleisen & Friedman, 1986) </ref>. It states that there is a unique partitioning of a non-answer into an evaluation context and a redex, which implies that there is precisely one way to make progress in the evaluation.
Reference: <author> Felleisen, M., & Friedman, D. P. </author> <year> (1989). </year> <title> A syntactic theory of sequential state. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3), </volume> <pages> 243-287. </pages>
Reference: <author> Felleisen, M., & Hieb, R. </author> <year> (1992). </year> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical computer science, </journal> <volume> 102, </volume> <pages> 235-271. </pages>
Reference: <author> Field, J. </author> <year> (1990). </year> <title> On laziness and optimality in lambda interpreters: Tools for specification and analysis. </title> <booktitle> Pages 1-15 of: Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco. </address>
Reference: <author> Friedman, D. P., & Wise, D. S. </author> <year> (1976). </year> <title> Cons should not evaluate its arguments. </title> <booktitle> Pages 257-284 of: Proc. International Conference on Automata, Languages and Programming. </booktitle>
Reference-contexts: We deal with each of these extensions in turn. 34 Zena M. Ariola and Matthias Felleisen Lazy constructors Most non-strict functional languages provide lazy data constructors. For example, lazy cons only evaluates its arguments when there is a demand for their respective values <ref> (Friedman & Wise, 1976) </ref>.
Reference: <author> Gonthier, G., Abadi, M., & Levy, J.-J. </author> <year> (1992). </year> <title> The geometry of optimal lambda reduction. </title> <booktitle> Pages 15-26 of: Proc. ACM Conference on Principles of Programming Languages. The Call-By-Need Lambda Calculus 37 Henderson, </booktitle> <editor> P., & Morris, J.H. </editor> <year> (1976). </year> <title> A lazy evaluator. </title> <booktitle> Pages 95-103 of: Proc. ACM Conference on Principles of Programming Languages. </booktitle>
Reference: <author> Huet, G., & Levy, L.-J. </author> <year> (1991). </year> <title> Computations in orthogonal rewriting systems 1 and 2. </title> <booktitle> Pages 395-443 of: Computational logic. Essays in Honor of Alan Robinson. </booktitle> <publisher> Ed. J.-L. </publisher>
Reference-contexts: To express that a procedure parameter occurs in leftmost-outermost position, we can write (x:E [x]) : This term expresses that the procedure's body can be partitioned into an evaluation x Call-by-need evaluation contexts define a static notion of need that is quite different from that of Huet and Levy <ref> (Huet & Levy, 1991) </ref>, which in contrast, captures the idea that a redex is needed if it is reduced in every reduction from the program to normal form.
Reference: <editor> Lassez & G.D. </editor> <publisher> Plotkin. </publisher>
Reference: <author> Huet, </author> <title> G.P. (1980). Confluent Reductions: Abstract Properties and Applications to Term Rewriting Systems. </title> <journal> Journal of the ACM, </journal> <volume> 27(4), </volume> <pages> 797-821. </pages>
Reference-contexts: We start with the proof of confluence. To that end, the following lemma proves that reductions do not interfere with each other. Huet refers to this property as "absence of critical pairs" <ref> (Huet, 1980) </ref>.
Reference: <author> Hughes, R. J. M. </author> <year> (1982). </year> <title> Super-combinators: a new implementation method for applicative languages. </title> <booktitle> Pages 1-10 of: Proc. ACM Symposium on Lisp and Functional Programming. </booktitle>
Reference: <author> Kathail, V. K. </author> <year> (1990). </year> <title> Optimal interpreters for lambda-calculus based funtional languages. </title> <type> Ph.D. thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT. </institution>
Reference: <author> Klop, J. W. </author> <year> (1992). </year> <title> Term rewriting systems. Pages 1-116 of: </title> <editor> Abramsky, S., Gabbay, D., & Maibaum, T. (eds), </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> vol. II. </volume> <publisher> Oxford University Press. </publisher>
Reference: <author> Lamping, J. </author> <year> (1990). </year> <title> An algorithm for optimal lambda calculus reduction. </title> <booktitle> Pages 16-30 of: Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco. </address>
Reference: <author> Launchbury, J. </author> <year> (1993). </year> <title> A natural semantics for lazy evaluation. </title> <booktitle> Pages 144-154 of: Proc. ACM Conference on Principles of Programming Languages. </booktitle>
Reference-contexts: It captures implicit operations in both an environment-based implementation and a graph-reduction machine. Specifically, the action of the assoc axiom corresponds to a hidden flattening of the environments in Launchbury's description of a lazy interpreter <ref> (Launchbury, 1993) </ref>: (z 7! II) : w:zw + (z 7! II) : w:zw Let Variable : According to the Variable rule we evaluate let z be II in w:zw in an empty environment.
Reference: <author> Lescanne, P. </author> <year> (1994). </year> <title> From to a journey through calculi of explicit substitutions. </title> <booktitle> Pages 60-69 of: Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> Port-land. </address>
Reference: <author> Maraist, J., Odersky, M., & Wadler, P. </author> <year> (1994). </year> <title> The call-by-need lambda calculus (unabridged). </title> <type> Tech. </type> <institution> rept. 28/94. Universitat Karlsruhe, Fakultat fur Informatik. </institution>
Reference-contexts: A simple example for the strictness of the inclusion is the equation (x:xx) = : As a straightforward corollary of the Standard Reduction Theorem, the call-by-need calculus cannot prove this equation. Intermezzo 5.3 Whereas need is incomparable with V , the call-by-value theory, Maraist et al.'s call-by-need theory <ref> (Maraist et al., 1994) </ref>, mow , is a proper superset of V and a proper subset of , that is, V mow : The Call-By-Need Lambda Calculus 19 To accomplish this relationship, Maraist et al. use the axiom deref 0 (x:C [x])V = (x:C [V ])V as the replacement for (fi).
Reference: <author> Maranget, L. </author> <year> (1991). </year> <title> Optimal derivations in weak lambda-calculi and in orthogonal term rewriting systems. </title> <booktitle> Pages 255-269 of: Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> Orlando, Florida. </address>
Reference: <author> Morrisett, G., Felleisen, M., & Harper, R. </author> <year> (1995). </year> <title> Modeling memory management. </title> <booktitle> Pages 66-77 of: Proc. ACM Conference on Functional Programming Languages and Computer Architecture. </booktitle>
Reference: <author> Nikhil, R.S. </author> <year> (1991). </year> <note> Id (version 90.1) reference manual. Tech. rept. CSG Memo 284-2. </note> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139. </address>
Reference-contexts: We call this evaluation strategy lenient, The Call-By-Need Lambda Calculus 33 that is, the only control mechanism is lambda abstraction (this is the evaluation strategy of the language Id <ref> (Nikhil, 1991) </ref>).
Reference: <author> Okasaki, C., Lee, P., & Tarditi, D. </author> <year> (1994). </year> <title> Call-by-need and continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 7(1), </volume> <pages> 57-81. </pages>
Reference: <author> Ong, C.-H.L. </author> <year> (1988). </year> <title> The lazy calculus: An investigation in the foundations of functional programming. </title> <type> Ph.D. thesis, </type> <institution> Imperial College, </institution> <address> London. </address>
Reference: <editor> Peyton Jones, S. L. </editor> <booktitle> (1987). The implementation of functional programming languages. International Series in Computer Science. </booktitle> <publisher> Prentice Hall. </publisher>
Reference: <editor> Peyton Jones, S. L., & Salkild, J. </editor> <booktitle> (1989). The spineless tagless g-machine. Pages 184-201 of: Proc. ACM Conference on Functional Programming Languages and Computer Architecture. </booktitle>
Reference-contexts: However, some implementations share even more computations than just those of arguments. For example, according to our calculus, the program (f:fI (f I))(w:(II )w) ; will evaluate the redex II twice. This is what happens also in the interpreter of Henderson and Morris (1976) and in the G-machine <ref> (Peyton Jones & Salkild, 1989) </ref>. However, the redex II will be evaluated only once following the combinator machine of Turner (1979), supercombinator approach of Hughes (1982) and Wadsworth's interpreter (1971). We refer to these implementations as fully lazy. Wadsworth (1971) was the first one to provide a fully lazy interpreter.
Reference: <author> Plotkin, G. D. </author> <year> (1975). </year> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1, </volume> <pages> 125-159. </pages>
Reference-contexts: Call-by-need and cps conversion Okasaki et al. (1994) recently suggested a continuation-passing transformation for call-by-need languages. In principle, this transformation should satisfy the same theorems as the continuation-passing transformation for call-by-name and call-by-value calculi <ref> (Plotkin, 1975) </ref>. Plotkin's proof techniques should immediately apply. Since this transformation appears to be used in several implementations of lazy languages [Odersky: personal communication, June 1994] it is important to explore its properties with standard tools.
Reference: <author> Purushothaman, S., & Seaman, J. </author> <year> (1992). </year> <title> An adequate operational semantics of sharing in lazy evaluation. </title> <booktitle> Pages 435-450 of: Proc. 4th European Symposium on Programming, </booktitle> <publisher> Springer Verlag LNCS 582. </publisher>
Reference: <author> Turner, D. A. </author> <year> (1979). </year> <title> A new implementation technique for applicative languages. </title> <journal> Software Practice and Experience, </journal> <volume> 9, </volume> <pages> 31-49. </pages> <editor> van Oostrom, V. </editor> <year> (1994). </year> <title> Confluence for Abstract and Higher-Order Rewriting. </title> <type> Ph.D. thesis, </type> <institution> Vrije Universiteit. </institution> <note> 38 Zena M. </note> <author> Ariola and Matthias Felleisen Wadsworth, C. </author> <year> (1971). </year> <title> Semantics and pragmatics of the lambda-calculus. </title> <type> Ph.D. thesis, </type> <institution> University of Oxford. </institution>
Reference: <author> Yoshida, N. </author> <year> (1993). </year> <title> Optimal reduction in weak--calculus with shared environments. </title> <booktitle> Pages 243-252 of: Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen. </address>
References-found: 37

