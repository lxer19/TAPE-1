URL: http://www.cse.ucsc.edu/~brucem/jn_proj.ps
Refering-URL: http://www.cse.ucsc.edu/~brucem/
Root-URL: http://www.cse.ucsc.edu
Email: brucem@cse.ucsc.edu  
Title: JN: An Operating System for an Embedded Java Network Computer UCSC-CRL-96-29  
Author: Bruce R. Montague 
Keyword: Java, JavaOS, embedded systems, softreal-time, OS implementation, kernel software architecture, JN, TCP/IP, KA9Q, NS486SXF.  
Date: 9 December 1996  
Address: Santa Cruz  
Affiliation: Computer Science Department University of California,  
Abstract: The implementation of an embedded operating system explicitly designed to support the Java Virtual Machine on the National Semiconductor NS486 embedded PC is described. This system, the Java Nanokernel (JN), supports an Internet web server written in Java and a web Camera that can be controlled from a remote web browser. JN in principle can currently run any Java program that does not use a local display device. This paper is primarily a system overview and a summary of lessons learned. 
Abstract-found: 1
Intro-found: 1
Reference: [Bro75] <author> Frederick P. Brooks. </author> <title> The Mythical Man-Month: </title> <booktitle> Essays on Software Engineering. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: Some 20 years ago Brooks made a famous observation that a factor of 9 exists between the effort required to write a program for self-use versus the same program as a product <ref> [Bro75] </ref>. The difference between demoware and a robust engineered product seems at least this large, if not greater. * Engineering requires testing. JN development would have been extremely different without a test harness. Around 100 tests exist, including Java and TCP tests. All tests are always linked in and available.
Reference: [Com65] <author> Webb T. </author> <title> Comfort. A computing system design for user service. </title> <booktitle> In Proceedings of the AFIPS Fall Joint Computer Conference, </booktitle> <pages> pages 619626. </pages> <publisher> Spartan Books, </publisher> <year> 1965. </year>
Reference-contexts: This basic kernel software architecture was used on earlier systems, including the kernel of IBM's massive mid-60's TSS OS effort <ref> [Com65] </ref>. The TSS system architect noted that the basic kernel model was adopted from IBM's TSM supervisor, which adopted the model from the Mercury Programming System developed to support the softreal-time requirements of the project Mercury space program [Kin64] [SH61]. This kernel architecture can be considered a Serially-Reusable Interrupt-Extension.
Reference: [Cus93] <author> Helen Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <year> 1993. </year>
Reference-contexts: Therefore, JN uses a classic software architecture for a softreal-time kernel. This architecture has informally been called a Cutler kernel, as it is the architecture used by the successful line of kernels implemented by teams lead by David Cutler, namely RSX-11, VMS, and NT <ref> [Cus93] </ref>. This basic kernel software architecture was used on earlier systems, including the kernel of IBM's massive mid-60's TSS OS effort [Com65].
Reference: [GAO95] <author> David Garlan, Robert Allen, and John Ockerbloom. </author> <title> Architectural mismatch: Why reuse is so hard. </title> <journal> IEEE Software, </journal> <volume> 17(6):17 26, </volume> <month> November </month> <year> 1995. </year>
Reference-contexts: Difficulties merging code from different software architectures have recently been discussed within the software reuse community <ref> [GAO95] </ref>.
Reference: [Gos95] <author> James Gosling. </author> <title> Java intermediate bytecodes. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(3):111118, </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: 1 Introduction This paper reviews lessons learned from implementing a custom embedded operating system designed specifically to support the Java Virtual Machine (JVM) on a small `single-chip' embedded PC attached to the Internet. JVM interprets Java, a multithreaded language that typically runs on top of a host operating system <ref> [Gos95] </ref>. We use the term JVM to refer to the Java Interpreter and its run-time, that is, the complete body of code needed to execute Java programs. The JVM is written entirely in C.
Reference: [Kar93] <author> Phil Karn. </author> <title> The Qualcomm CDMA digital cellular system. </title> <booktitle> In Proceedings of the USENIX Mobile and Location-Independent Computing Symposium, </booktitle> <pages> pages 3539. </pages> <publisher> USENIX Association, </publisher> <year> 1993. </year>
Reference-contexts: KA9Q is a shareware TCP/IP stack freely available to educational institutions. KA9Q was written by Phil Karn and originally used primarily for amateur packet radio; it has also been used as a TCP/IP stack for mobile laptop computers accessing the Internet via a digital cellular system [Wad92] <ref> [Kar93] </ref>. KA9Q is stable, has been in use since 1991, and has been widely used as a non-commercial TCP/IP stack. KA9Q is written in C and a number of variants (such as JNOS and TNOS) are in use.
Reference: [Kin64] <author> H.A. Kinslow. </author> <title> The time-sharing monitor system. </title> <booktitle> In Proceedings of the AFIPS Fall Joint Computer Conference, </booktitle> <pages> pages 443454. </pages> <publisher> Spar-tan Books, </publisher> <year> 1964. </year>
Reference-contexts: The TSS system architect noted that the basic kernel model was adopted from IBM's TSM supervisor, which adopted the model from the Mercury Programming System developed to support the softreal-time requirements of the project Mercury space program <ref> [Kin64] </ref> [SH61]. This kernel architecture can be considered a Serially-Reusable Interrupt-Extension. Some of its characteristics include: * The kernel is not reentrant. It can be thought of as a single task that runs as an interrupt-enabled follow-on extension to all interrupt routines.
Reference: [Lie96] <author> Jochen Liedtke. </author> <title> Towards real microkernels. </title> <journal> Communications of the ACM, </journal> <volume> 39(9):7077, </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: The selected process is then dispatched. Although we adopted a well-known kernel architecture, a full kernel was not implemented. We refer to the implemented subset as a nanokernel. Although the term has been disparaged, we believe it is warranted <ref> [Lie96] </ref>. Although similar to a microkernel, a nanokernel has the fol lowing identifying characteristics: 6 * There exists only one mandatory nanokernel API routine: run a specified subroutine serialized in kernel context, that is, as a fork routine. There are no other API's defined by the nanokernel.
Reference: [MKKS96] <author> Peter Madany, Susan Keohan, Douglas Kramer, and Tom Saulpaugh. </author> <title> JavaOS: A standalone Java environment. `http:// java. sun. com/ products/ javaos/ javaos. white. html', </title> <month> December </month> <year> 1996. </year>
Reference-contexts: Above JN an application interface (API) has been implemented which provides only: 1) those services that we found necessary to run the JVM as an application; 2) services necessary to port the KA9Q TCP/IP stack. JavaSoft's JavaOS currently implements as much functionality as possible in interpreted Java <ref> [MKKS96] </ref>. Unlike JavaOS, JN, its drivers, and the JN TCP/IP stack are implemented in C. The JVM runs as an application thread. However, unlike Java hosted on Unix or Windows, the only functions included in JN are those required to run Java threads. <p> To this end we obtained another NS486 evaluation board and a $130 Linksys 8-port network hub. We connected the 2 DOS development machines and the 2 NS486 boards to this hub to form our own small intranet. Kona (later named JavaOS) had become available from JavaSoft by this time <ref> [MKKS96] </ref>. As much of Kona as possible was written in Java, including device drivers and the TCP/IP stack. We started a side project to obtain and evaluate the Kona code, with the intent of using the TCP/IP stack written in Java on top of JN.
Reference: [Mon96] <author> Bruce R. Montague. </author> <title> The API of the UCSC Java Nanokernel (JN). </title> <institution> Computer Science Technical Report UCSCCRL9628, UCSC, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: A more complete specification can be found in <ref> [Mon96] </ref>. The API is divided into 4 classes: threading, monitor, file, and exception. 4.1.1 Thread APIs The threading API routines are conventional. Thread priorities range from 0 to 10, as defined by Java. Thread stacks are fixed-size and cannot dynamically expand.
Reference: [Nat95] <author> National Semiconductor. </author> <title> Preliminary CR32A Core Architecture Specification Revision 1.0, </title> <month> October </month> <year> 1995. </year>
Reference-contexts: Our initial target system was the National Semiconductor CR32A, a RISC-like CPU that is a new member of National's CompactRisc family <ref> [Nat95] </ref>. The 16-bit version of this CPU is currently used extensively to form custom cores for special embedded processors. The 32-bit CR32 is expected to be likewise used across all National product lines.
Reference: [Nat96] <author> National Semiconductor. </author> <title> NS486SXF Optimized 32-bit 486-class Controller With On-Chip Peripherals for Embedded Systems, </title> <month> March </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: The components of this system are shown in Figure 1. The Java Nanokernel runs on evaluation boards assembled by National Semiconductor for their NS486SXF part. National describes this chip as a `32-bit 486-class controller with on-chip peripherals for embedded systems' <ref> [Nat96] </ref>. Above JN an application interface (API) has been implemented which provides only: 1) those services that we found necessary to run the JVM as an application; 2) services necessary to port the KA9Q TCP/IP stack. JavaSoft's JavaOS currently implements as much functionality as possible in interpreted Java [MKKS96]. <p> To continue the pace of development over the summer of 1996, a decision was made to port to a National NS486SXF preliminary evaluation board. 2.2.2 The NS486SXF The NS486SXF is intended to be a `single-chip' 32-bit PC, that is, to reduce the motherboard part count to a minimum <ref> [Nat96] </ref>.
Reference: [SH61] <author> Marilyn B. Scott and Robert Hoffman. </author> <title> The Mercury programming system. In Computers Key to Total Systems Control: </title> <booktitle> Proceedings of the Eastern Joint Computer Conference (AFIPS), </booktitle> <pages> pages 4753. </pages> <publisher> Spartan Books, </publisher> <year> 1961. </year> <title> Part B of Project Mercury Real-Time Computational and Data-Flow System. </title>
Reference-contexts: The TSS system architect noted that the basic kernel model was adopted from IBM's TSM supervisor, which adopted the model from the Mercury Programming System developed to support the softreal-time requirements of the project Mercury space program [Kin64] <ref> [SH61] </ref>. This kernel architecture can be considered a Serially-Reusable Interrupt-Extension. Some of its characteristics include: * The kernel is not reentrant. It can be thought of as a single task that runs as an interrupt-enabled follow-on extension to all interrupt routines. The kernel runs from start to completion every invocation.
Reference: [SSK96] <author> Martin Shepperd, Chris Schofield, and Bar-bara Kitchenham. </author> <title> Effort estimation using analogy. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 170178. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: To support the crash dump and on-line debugging, format routines exist for all data structures, and these format routines are kept linked into the kernel. * Software Estimation. Software estimation by analogy has been claimed to be as accurate as any other technique for estimating development time and cost <ref> [SSK96] </ref>. With respect to estimation by analogy, 2 months seems a typical development time for a kernel such as JN, recognizing that driver development, not the kernel itself, is likely to require considerably more time.
Reference: [Wad92] <author> Ian Wade. NOSintro: </author> <title> TCP/IP Over Packet Radio; An introduction to the KA9Q Network Operating System. </title> <address> Dowermain, </address> <year> 1992. </year> <title> Dust-jacket, annotated table of contents, and related links at `http:// www. netro. </title> <publisher> co. </publisher> <address> uk/ nosintro. </address> <note> html'. </note>
Reference-contexts: KA9Q is a shareware TCP/IP stack freely available to educational institutions. KA9Q was written by Phil Karn and originally used primarily for amateur packet radio; it has also been used as a TCP/IP stack for mobile laptop computers accessing the Internet via a digital cellular system <ref> [Wad92] </ref> [Kar93]. KA9Q is stable, has been in use since 1991, and has been widely used as a non-commercial TCP/IP stack. KA9Q is written in C and a number of variants (such as JNOS and TNOS) are in use.
Reference: [Wul81] <author> William Allan Wulf. HYDRA/C.mmp, </author> <title> an Experimental Computer System. </title> <publisher> McGraw-Hill, </publisher> <year> 1981. </year>
Reference-contexts: This reemphasizes a point Bill Wulf made in his description of CM-star, which was that utility, driver, and application development was more important to the success of the system than the oper ating system itself <ref> [Wul81] </ref>. * Avoid using demo schedules to drive development. For software above a certain size, demo driven development leads to fragile non-engineering solutions (demoware). The difference between a system being `up', doing 1 thing, and the system being complete needs constant emphasis.
References-found: 16

