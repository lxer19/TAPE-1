URL: http://www.cs.washington.edu/research/jair/volume9/ledeniov98a.ps
Refering-URL: http://www.cs.washington.edu/research/jair/contents/v9.html
Root-URL: http://www.cs.washington.edu
Email: olleg@cs.technion.ac.il  shaulm@cs.technion.ac.il  
Title: The Divide-and-Conquer Subgoal-Ordering Algorithm for Speeding up Logic Inference  
Author: Oleg Ledeniov Shaul Markovitch 
Address: Haifa 32000, Israel  
Affiliation: Computer Science Department Technion Israel Institute of Technology  
Note: Journal of Artificial Intelligence Research 9 (1998) 37-97 Submitted 2/98; published 9/98  
Abstract: It is common to view programs as a combination of logic and control: the logic part defines what the program must do, the control part how to do it. The Logic Programming paradigm was developed with the intention of separating the logic from the control. Recently, extensive research has been conducted on automatic generation of control for logic programs. Only a few of these works considered the issue of automatic generation of control for improving the efficiency of logic programs. In this paper we present a novel algorithm for automatic finding of lowest-cost subgoal orderings. The algorithm works using the divide-and-conquer strategy. The given set of subgoals is partitioned into smaller sets, based on co-occurrence of free variables. The subsets are ordered recursively and merged, yielding a provably optimal order. We experimentally demonstrate the utility of the algorithm by testing it in several domains, and discuss the possibilities of its cooperation with other existing methods. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Aho, A. V., Hopcroft, J. E., & Ullman, J. D. </author> <year> (1987). </year> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: The permutation test can be completed in O (n) time, by using, for example, a trie structure <ref> (Aho et al., 1987) </ref>, where subgoals in prefixes are sorted lexicographically. <p> The equivalence test of the tree nodes can be performed efficiently with the help of trie structures <ref> (Aho et al., 1987) </ref>, where subgoals are sorted lexicographically. Let there be n subgoals, with v shared variables appearing in m subgoals.
Reference: <author> Boddy, M., & Dean, T. </author> <year> (1989). </year> <title> Solving time-dependent planning problems. </title> <editor> In Sridha-ran, N. S. (Ed.), </editor> <booktitle> Proceedings of the 11th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 979-984, </pages> <address> Detroit, MI, USA. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: This modified algorithm deals with the problem by explicit reasoning about the economy of the control process. The algorithm is anytime, that is, it can be stopped at any moment and return its currently best ordering <ref> (Boddy & Dean, 1989) </ref>. We learn a resource-investment function to compute the expected return in speedup time for additional control time. This function is used to determine a stopping condition for the anytime procedure.
Reference: <author> Bol, R. N., Apt, K. R., & Klop, J. W. </author> <year> (1991). </year> <title> An analysis of loop checking mechanisms for logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 86 (1), </volume> <pages> 35-79. </pages>
Reference: <author> Braem, C., Le Charlier, B., Modar, S., & Van Hentenryck, P. </author> <year> (1994). </year> <title> Cardinality Analysis of Prolog. </title> <editor> In Bruynooghe, M. (Ed.), </editor> <booktitle> Logic Programming Proceedings of the 1994 International Symposium, </booktitle> <pages> pp. 457-471, </pages> <institution> Massachusetts Institute of Technology. The MIT Press. </institution>
Reference: <author> Breiman, L., Friedman, J. H., Olshen, R. A., & Stone, C. J. </author> <year> (1984). </year> <title> Classification and Regression Trees. </title> <booktitle> Wadsworth International Group, </booktitle> <address> Belmont, CA. </address>
Reference: <author> Bruynooghe, M., De Schreye, D., & Krekels, B. </author> <year> (1989). </year> <title> Compiling control. </title> <journal> The Journal of Logic Programming, </journal> <volume> 6, </volume> <pages> 135-162. </pages>
Reference: <author> Clark, K. L., & McCabe, F. </author> <year> (1979). </year> <title> The control facilities of IC-Prolog. </title> <editor> In Michie, D. (Ed.), </editor> <booktitle> Expert Systems in The Microelectronic Age., </booktitle> <pages> pp. 122-149. </pages> <institution> University of Edinburgh, </institution> <address> Scotland. </address>
Reference: <author> Clocksin, W. F., & Mellish, C. S. </author> <year> (1987). </year> <title> Programming in Prolog (Third edition). </title> <publisher> Springer-Verlag, </publisher> <address> New York. </address> <note> 93 Ledeniov & Markovitch Cohen, </note> <author> W. W. </author> <year> (1990). </year> <title> Learning approximate control rules of high utility. </title> <booktitle> In Proceedings of the Seventh International Machine Learning Workshop, </booktitle> <pages> pp. 268-276, </pages> <address> Austin, Texas. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: <author> Cormen, T. H., Leiserson, C. E., & Rivest, R. L. </author> <year> (1991). </year> <title> Introduction To Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address>
Reference-contexts: In particular, if S (N ) is independent under B (N ), then the subgoals of B (N ) bind all the shared free variables of S (N ). To implement the DPart function, we can use the Union-Find data structure <ref> (Cormen, Leiserson, & Rivest, 1991, Chapter 22) </ref>, where subgoals are elements, and indivisible sets are groups. In the beginning, every subgoal constitutes a group by itself. Whenever we discover that two subgoals share a free variable not bound by subgoals of the binding set, we unite their groups into one. <p> An extension is added to the list only when the adjacency restriction test succeeds on its two last subgoals. To make the list operations faster, we can implement it as a heap structure <ref> (Cormen et al., 1991) </ref>. The trace of Algorithm 4 on the set S 0 is shown in Table 3. <p> Let there be n subgoals, with v shared variables appearing in m subgoals. As was already noted in Section 4.3, the partition of subgoals into subsets can be performed in 74 The Divide-and-Conquer Subgoal-Ordering Algorithm O (n) average time, using a Union-Find data structure <ref> (Cormen et al., 1991, Chapter 22) </ref>. In the worst possible case, there are no AND-nodes in the divisibility tree, apart from the root node (whose set is divisible into a dependent set of size m and an independent set of size n m).
Reference: <author> Cortesi, A., Le Charlier, B., & Rossi, S. </author> <year> (1997). </year> <title> Specification-based automatic verification of Prolog programs. </title> <editor> In Gallagher, J. (Ed.), </editor> <booktitle> Proceedings of the 6th International Workshop on Logic Program Synthesis and Transformation, Vol. 1207 of LNCS, </booktitle> <pages> pp. 38-57, </pages> <address> Stockholm, Sweden. </address> <publisher> Springer-Verlag. </publisher>
Reference: <author> De Boeck, P., & Le Charlier, B. </author> <year> (1990). </year> <title> Static type analysis of Prolog procedures for ensuring correctness. </title> <editor> In Deransart, P., & Ma luszynski, J. (Eds.), </editor> <booktitle> Programming Languages Implementation and Logic Programming, Vol. 456 of LNCS, </booktitle> <pages> pp. 222-237, </pages> <address> Linkoping, Sweden. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The folon environment (Henrard & Le Charlier, 1992) was designed to support the methodology for logic program construction that aims at reconciling the declarative semantics with an efficient implementation <ref> (Deville, 1990) </ref>. The construction process starts with 84 The Divide-and-Conquer Subgoal-Ordering Algorithm a specification, converts it into a logic description and finally, into a Prolog program.
Reference: <author> De Schreye, D., & Decorte, S. </author> <year> (1994). </year> <title> Termination of logic programs: The never-ending story. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19 & 20, </volume> <pages> 199-260. </pages>
Reference-contexts: The most obvious aspect of this inefficiency is the possible non-termination of a proof. Several researchers developed compile-time and run-time techniques to detect and avoid infinite computations <ref> (De Schreye & Decorte, 1994) </ref>. A certain success was achieved in providing more advanced control through employment of co-routining for inter-predicate synchronization purposes (Clark & McCabe, 1979; Porto, 1984; Naish, 1984). <p> During the last decade, a significant research effort went into static analysis (SA) of logic programs. There are three types of SA that can be exploited by the dac algorithm to reduce the ordering time. A major part of the SA research deals with program termination <ref> (De Schreye & Decorte, 1994) </ref>. The dac algorithm solves the termination problem, as a special case of the efficiency problem (it always finds a terminating ordering, if such orderings exist). During learning, we set limits on the computation resources available for subgoal execution.
Reference: <author> Debray, S., Lopez-Garcia, P., Hermenegildo, M., & Lin, N.-W. </author> <year> (1997). </year> <title> Lower bound cost estimation for logic programs. </title> <editor> In Ma luszynski, J. (Ed.), </editor> <booktitle> Proceedings of the International Symposium on Logic Programming (ILPS-97), </booktitle> <pages> pp. 291-306, </pages> <address> Cambridge. </address> <publisher> MIT Press. </publisher>
Reference: <author> Debray, S. K., & Lin, N.-W. </author> <year> (1993). </year> <title> Cost analysis of logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15 (5), </volume> <pages> 826-875. </pages>
Reference: <author> Debray, S. K., & Warren, D. S. </author> <year> (1988). </year> <title> Automatic mode inference for logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 5, </volume> <pages> 207-229. </pages>
Reference-contexts: When such declarations are available, it is easy to infer the binding status of each variable upon exiting a subgoal. 3. Even when the user did not supply enough mode declarations, they can often be inferred from the structure of the program by means of static analysis <ref> (Debray & Warren, 1988) </ref>. Note, however, that as was pointed out by Somogyi et al. (1996b), no-one has yet demonstrated a mode inference algorithm that is guaranteed to find accurate mode information for every predicate in the program. 4.
Reference: <author> Dejong, G., & Mooney, R. </author> <year> (1986). </year> <title> Explanation-based learning: An alternative view. </title> <journal> Machine Learning, </journal> <volume> 1, </volume> <pages> 145-176. </pages>
Reference: <author> Deville, Y. </author> <year> (1990). </year> <title> Logic Programming: Systematic Program Development. </title> <booktitle> International Series in Logic Programming, </booktitle> <publisher> Addison-Wesley. </publisher>
Reference-contexts: The folon environment (Henrard & Le Charlier, 1992) was designed to support the methodology for logic program construction that aims at reconciling the declarative semantics with an efficient implementation <ref> (Deville, 1990) </ref>. The construction process starts with 84 The Divide-and-Conquer Subgoal-Ordering Algorithm a specification, converts it into a logic description and finally, into a Prolog program.
Reference: <author> Etzioni, O. </author> <year> (1991). </year> <title> STATIC: A problem-space compiler for PRODIGY. </title> <editor> In Dean, Thomas L.; McKeown, K. (Ed.), </editor> <booktitle> Proceedings of the 9th National Conference on Artificial Intelligence, </booktitle> <pages> pp. 533-540, </pages> <address> Anaheim, California. </address> <publisher> MIT Press. </publisher>
Reference: <author> Etzioni, O. </author> <year> (1993). </year> <title> Acquiring search-control knowledge via static analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 62, </volume> <pages> 255-301. </pages>
Reference: <author> Greiner, R., & Orponen, P. </author> <year> (1996). </year> <title> Probably approximately optimal satisficing strategies. </title> <journal> Artificial Intelligence, </journal> <volume> 82 (1-2), </volume> <pages> 21-44. </pages>
Reference: <author> Henrard, J., & Le Charlier, B. </author> <year> (1992). </year> <title> FOLON: An environment for declarative construction of logic programs. </title> <editor> In Bruynooghe, M., & Wirsing, M. (Eds.), </editor> <booktitle> Proceedings of the Fourth International Symposium on Programming Language Implementation and Logic Programming, Vol. 631 of LNCS, </booktitle> <pages> pp. 217-231, </pages> <address> Leuven, Belgium. </address> <month> Springer-Verlag. </month> <title> 94 The Divide-and-Conquer Subgoal-Ordering Algorithm Itai, </title> <editor> A., & Makowsky, J. A. </editor> <year> (1987). </year> <title> Unification as a complexity measure for logic programming. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4, </volume> <pages> 105-117. </pages>
Reference-contexts: The second type of SA research that can be combined with the dac algorithm is correctness analysis, where the program is tested against specifications given by the user. The folon environment <ref> (Henrard & Le Charlier, 1992) </ref> was designed to support the methodology for logic program construction that aims at reconciling the declarative semantics with an efficient implementation (Deville, 1990).
Reference: <author> Knuth, D. E. </author> <year> (1973). </year> <booktitle> The Art Of Computer Programming, </booktitle> <volume> Vol. 3. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address>
Reference-contexts: For independent sets, there exists an efficient ordering algorithm, listed in Figure 4. The complexity of this algorithm is O (n (o + log n)): O (n o ) to obtain the control values of n subgoals, and O (n log n) to perform the sorting <ref> (Knuth, 1973) </ref>. To enable the division, we must define the cost so that cost (A i ) is always positive. <p> The divide-and-conquer process described above seems analogous to Merge Sort <ref> (Knuth, 1973) </ref>. There, the set of numbers is split into two (or more) subsets, each subset is independently ordered to a sequence consistent with the global order, and these sequences are merged.
Reference: <author> Kowalski, R. A. </author> <year> (1979). </year> <title> Algorithm = Logic + Control. </title> <journal> Communications of the ACM, </journal> <volume> 22(7), </volume> <pages> 424-436. </pages>
Reference-contexts: 1. Introduction It is common to view programs as a combination of logic and control <ref> (Kowalski, 1979) </ref>. The logic part defines what the program must do, the control part how to do it. Traditional programming languages require that the programmers supply both components. The Logic Programming paradigm was developed with the intention of separating the logic from the control (Lloyd, 1987).
Reference: <author> Laird, P. D. </author> <year> (1992). </year> <title> Efficient dynamic optimization of logic programs. </title> <booktitle> In Proceedings of the ML92 Workshop on Knowledge Compilation and Speedup Learning Aberdeen, </booktitle> <address> Scotland. </address>
Reference: <author> Langley, P. </author> <year> (1985). </year> <title> Learning to search: From weak methods to domain-specific heuristics. </title> <journal> Cognitive Science, </journal> <volume> 9, </volume> <pages> 217-260. </pages>
Reference: <author> Lavrac, N., & Dzeroski, S. </author> <year> (1994). </year> <title> Inductive Logic Programming: Techniques and Applications. </title> <booktitle> Artificial Intelligence. </booktitle> <publisher> Ellis Harwood, </publisher> <address> New York. </address>
Reference: <author> Ledeniov, O., & Markovitch, S. </author> <year> (1998a). </year> <title> Controlled utilization of control knowledge for speeding up logic inference. </title> <type> Tech. rep. </type> <institution> CIS9812, Technion, Haifa, Israel. </institution>
Reference-contexts: In this paper we focus upon developing algorithms for minimizing the inference time. Elsewhere <ref> (Ledeniov & Markovitch, 1998a, 1998b) </ref> we present algorithms that attempt to reduce the total execution time. The values of cost and number of solutions can be obtained in various ways: by exact computation, by estimation and bounds, and by learning. <p> Therefore, they must be as efficient as possible. Otherwise the retrieval of control values will take too much time. The problem of efficient learning of control values is further considered elsewhere <ref> (Ledeniov & Markovitch, 1998a) </ref>. Several researchers applied machine learning techniques for accelerating logic inference (Cohen, 1990; Dejong & Mooney, 1986; Langley, 1985; Markovitch & Scott, 1993; Minton, 1988; Mitchell, Keller, & Kedar-Cabelli, 1986; Mooney & Zelle, 1993; Prieditis & Mostow, 1987). <p> Alternatively, off-line learning can be implemented, with training as a part of the compilation process. Another method for combining our algorithm with existing Prolog compilers is to use it for program transformation, and to process the transformed program by a standard compiler. Elsewhere <ref> (Ledeniov & Markovitch, 1998a) </ref> we describe the method for classifying the orderings produced by the dac algorithm. For each rule we build a classification tree, where classes are the different orderings of the rule body, and the tests are applied to the rule head arguments. <p> In such cases we still need to perform the ordering dynamically. To reduce the harmfulness of the utility problem in the case of dynamic ordering, we can use a cost-sensitive variation of the dac algorithm <ref> (Ledeniov & Markovitch, 1998a, 1998b) </ref>. This modified algorithm deals with the problem by explicit reasoning about the economy of the control process. The algorithm is anytime, that is, it can be stopped at any moment and return its currently best ordering (Boddy & Dean, 1989). <p> We consider the issue of learning control values more thoroughly in another paper <ref> (Ledeniov & Markovitch, 1998a) </ref>, together with other issues concerning the dac algorithm (such as minimizing the total time, instead of minimizing the inference time only). Ullman and Vardi (1988) showed that the problem of ordering subgoals to obtain termination is inherently exponential in time.
Reference: <author> Ledeniov, O., & Markovitch, S. </author> <year> (1998b). </year> <title> Learning investment functions for controlling the utility of control knowledge. </title> <booktitle> In Proceedings of the Fifteenth National Conference on Artificial Intelligence, </booktitle> <pages> pp. 463-468, </pages> <address> Madison, Wisconsin. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: <author> Lenat, D. B. </author> <year> (1995). </year> <title> CYC: A large-scale investment in knowledge infrastructure. </title> <journal> Communications of the ACM, </journal> <volume> 38 (11), </volume> <pages> 33-38. </pages>
Reference-contexts: The dac algorithm may be used for speeding up logic inference, making the use of automatic theorem provers more practical. Logic has gained increasing popularity for representation of common-sense knowledge. It has several advantages, including flexibility and well-understood semantics. Indeed, the CYC project <ref> (Lenat, 1995) </ref> has recently moved from frame-based representation to logic 87 Ledeniov & Markovitch based representation. However, the large scale of such knowledge bases is likely to present significant efficiency problems to the inference engines.
Reference: <author> Lloyd, J. W. </author> <year> (1987). </year> <title> Foundations of Logic Programming (Second edition). </title> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The logic part defines what the program must do, the control part how to do it. Traditional programming languages require that the programmers supply both components. The Logic Programming paradigm was developed with the intention of separating the logic from the control <ref> (Lloyd, 1987) </ref>. The goal of the paradigm is that the programmer specifies the logic without bothering about the control, which should be supplied by the interpreter. <p> Theorem 1 The solution set of a set of subgoals does not depend on the order of their execution. Proof: When we are looking for all solutions, the solution set does not depend on the computation rule chosen <ref> (Theorems 9.2 and 10.3 in Lloyd, 1987) </ref>.
Reference: <author> Markovitch, S., & Scott, P. D. </author> <year> (1989). </year> <title> Automatic ordering of subgoals | a machine learning approach. </title> <editor> In Lusk, E. L., & Overbeek, R. A. (Eds.), </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pp. 224-242, </pages> <address> Cleveland, </address> <publisher> Ohio. MIT Press. </publisher>
Reference-contexts: The number of reductions reflects the size of the proof tree. For experimentation we used a new version of the lassy system <ref> (Markovitch & Scott, 1989) </ref>, using regression trees for learning, and the ordering algorithms discussed in this paper. 77 Ledeniov & Markovitch 6.2 Experiments with Artificial Domains In order to ensure the statistical significance of the results of comparing different ordering algorithms, we experimented with many different domains. <p> The program implements a simple planner for the blocks world. * Biblical Family Database: A database similar to that described in Example 1. * Appletalk: A domain describing the physical layout of a local computer network <ref> (Markovitch, 1989) </ref>. * Benchmark: A Prolog benchmark taken from the CMU Artificial Intelligence Repository 2 .
Reference: <author> Markovitch, S. </author> <year> (1989). </year> <title> Information Filtering: Selection Mechanisms in Learning Systems. </title> <type> Ph.D. thesis, </type> <institution> EECS Department, University of Michigan. </institution>
Reference-contexts: The number of reductions reflects the size of the proof tree. For experimentation we used a new version of the lassy system <ref> (Markovitch & Scott, 1989) </ref>, using regression trees for learning, and the ordering algorithms discussed in this paper. 77 Ledeniov & Markovitch 6.2 Experiments with Artificial Domains In order to ensure the statistical significance of the results of comparing different ordering algorithms, we experimented with many different domains. <p> The program implements a simple planner for the blocks world. * Biblical Family Database: A database similar to that described in Example 1. * Appletalk: A domain describing the physical layout of a local computer network <ref> (Markovitch, 1989) </ref>. * Benchmark: A Prolog benchmark taken from the CMU Artificial Intelligence Repository 2 .
Reference: <author> Markovitch, S., & Scott, P. D. </author> <year> (1993). </year> <title> Information filtering: Selection mechanisms in learning systems. </title> <journal> Machine Learning, </journal> <volume> 10, </volume> <pages> 113-151. </pages>
Reference: <author> Minker, J. </author> <year> (1978). </year> <title> Search strategy and selection function for an inferential relational system. </title> <journal> In ACM Transactions on Database Systems, </journal> <volume> Vol. 3, </volume> <pages> pp. 1-31. </pages>
Reference-contexts: Subgoal ordering, as was demonstrated in Example 1, can significantly affect the efficiency of proving a goal. There are two major approaches to subgoal ordering. The first approach uses various heuristics to order subgoals, for example: * Choose a subgoal whose predicate has the smallest number of matching clauses <ref> (Minker, 1978) </ref>. The Divide-and-Conquer Subgoal-Ordering Algorithm * Prefer a subgoal with more constants (Minker, 1978). * Choose a subgoal with the largest size, where the size is defined as the number of occurrences of predicate symbols, function symbols, and variables (Nie & Plaisted, 1990). * Choose a subgoal with the largest <p> There are two major approaches to subgoal ordering. The first approach uses various heuristics to order subgoals, for example: * Choose a subgoal whose predicate has the smallest number of matching clauses <ref> (Minker, 1978) </ref>. The Divide-and-Conquer Subgoal-Ordering Algorithm * Prefer a subgoal with more constants (Minker, 1978). * Choose a subgoal with the largest size, where the size is defined as the number of occurrences of predicate symbols, function symbols, and variables (Nie & Plaisted, 1990). * Choose a subgoal with the largest mass, where the mass of a subgoal depends on the frequency of its
Reference: <author> Minton, S. </author> <year> (1988). </year> <title> Learning Search Control Knowledge: An Explanation-Based Approach. </title> <publisher> Kluwer, </publisher> <address> Boston, MA. </address>
Reference: <author> Mitchell, T. M., Keller, R. M., & Kedar-Cabelli, S. T. </author> <year> (1986). </year> <title> Explanation-based generalization: A unifying view. </title> <journal> Machine Learning, </journal> <volume> 1, </volume> <pages> 47-80. </pages> <note> 95 Ledeniov & Markovitch Mooney, </note> <author> R. J., & Zelle, J. M. </author> <year> (1993). </year> <title> Combining FOIL and EBG to speed-up logic programs. </title>
Reference: <editor> In Bajcsy, R. (Ed.), </editor> <booktitle> Proceedings of The Thirteenth International Joint Conference for Artificial Intelligence, </booktitle> <pages> pp. 1106-1111, </pages> <address> Chambery, France. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: <author> Morris, K. A. </author> <year> (1988). </year> <title> An algorithm for ordering subgoals in NAIL!. </title> <booktitle> In Proceedings of the Seventh ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pp. 82-88, </pages> <address> Austin, TX. </address> <publisher> ACM Press, </publisher> <address> New York. </address>
Reference-contexts: Also, infinite computations can be avoided by pruning infinite branches that do not contain solutions (Vasak & Potter, 1985; Smith, Genesereth, & Ginsberg, 1986; Bol, Apt, & Klop, 1991). In the NAIL! system <ref> (Morris, 1988) </ref> subgoals are automatically reordered to avoid nontermination. Still, even when the proof is finite, it is desirable to make it more efficient. Several researchers studied the problem of clause ordering (Smith, 1989; Cohen, 1990; Etzioni, 1991; Laird, 1992; Mooney & Zelle, 1993; Greiner & Orponen, 1996).
Reference: <author> Muggleton, S., & De Raedt, L. </author> <year> (1994). </year> <title> Inductive logic programming: Theory and methods. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19 & 20, </volume> <pages> 629-680. </pages>
Reference: <author> Naish, L. </author> <year> (1984). </year> <note> MU-Prolog 3.1db Reference Manual. </note> <institution> Dept. of Computer Science, Univ. of Melbourne. </institution>
Reference: <author> Naish, L. </author> <year> (1985a). </year> <title> Automatic control for logic programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 3, </volume> <pages> 167-183. </pages>
Reference-contexts: a subgoal with the largest mass, where the mass of a subgoal depends on the frequency of its arguments and sub-arguments in the entire goal (Nie & Plaisted, 1990). * Choose a subgoal with the least number of solutions (Warren, 1981; Nie & Plaisted, 1990). * Apply "tests" before "generators" <ref> (Naish, 1985a) </ref>. * Prefer calls that fail quickly (Naish, 1985b). The heuristic methods usually execute quickly, but may yield suboptimal orderings. The second approach, which is adopted in this paper, aims at finding optimal order-ings (Smith & Genesereth, 1985; Natarajan, 1987; Markovitch & Scott, 1989). <p> Note that the sorting algorithm reflects a well-known principle: The best implementations of generate-and-test programs are obtained with the tests placed as early as possible in the rule body and the generations as late as possible <ref> (Naish, 1985a) </ref>. Of course, the cheap tests should come first, while the expensive ones should come last.
Reference: <author> Naish, L. </author> <year> (1985b). </year> <title> Prolog control rules. </title> <editor> In Joshi, A. (Ed.), </editor> <booktitle> Proceedings of the 9th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 720-723, </pages> <address> Los Angeles, CA. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: mass of a subgoal depends on the frequency of its arguments and sub-arguments in the entire goal (Nie & Plaisted, 1990). * Choose a subgoal with the least number of solutions (Warren, 1981; Nie & Plaisted, 1990). * Apply "tests" before "generators" (Naish, 1985a). * Prefer calls that fail quickly <ref> (Naish, 1985b) </ref>. The heuristic methods usually execute quickly, but may yield suboptimal orderings. The second approach, which is adopted in this paper, aims at finding optimal order-ings (Smith & Genesereth, 1985; Natarajan, 1987; Markovitch & Scott, 1989).
Reference: <author> Natarajan, K. S. </author> <year> (1987). </year> <title> Optimizing backtrack search for all solutions to conjunctive problems. In McDermott, </title> <editor> J. (Ed.), </editor> <booktitle> Proceedings of the 10th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 955-958, </pages> <address> Milan, Italy. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: <author> Nie, X., & Plaisted, D. A. </author> <year> (1990). </year> <title> Experimental results on subgoal ordering. </title> <journal> In IEEE Transactions On Computers, </journal> <volume> Vol. 39, </volume> <pages> pp. 845-848. </pages>
Reference-contexts: The Divide-and-Conquer Subgoal-Ordering Algorithm * Prefer a subgoal with more constants (Minker, 1978). * Choose a subgoal with the largest size, where the size is defined as the number of occurrences of predicate symbols, function symbols, and variables <ref> (Nie & Plaisted, 1990) </ref>. * Choose a subgoal with the largest mass, where the mass of a subgoal depends on the frequency of its arguments and sub-arguments in the entire goal (Nie & Plaisted, 1990). * Choose a subgoal with the least number of solutions (Warren, 1981; Nie & Plaisted, 1990). <p> largest size, where the size is defined as the number of occurrences of predicate symbols, function symbols, and variables <ref> (Nie & Plaisted, 1990) </ref>. * Choose a subgoal with the largest mass, where the mass of a subgoal depends on the frequency of its arguments and sub-arguments in the entire goal (Nie & Plaisted, 1990). * Choose a subgoal with the least number of solutions (Warren, 1981; Nie & Plaisted, 1990). * Apply "tests" before "generators" (Naish, 1985a). * Prefer calls that fail quickly (Naish, 1985b). The heuristic methods usually execute quickly, but may yield suboptimal orderings.
Reference: <author> Pettorossi, A., & Proietti, M. </author> <year> (1994). </year> <title> Transformation of logic programs: Foundations and techniques. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19 & 20, </volume> <pages> 261-320. </pages>
Reference-contexts: However, they used a generate-and-test approach which can sometimes be prohibitively expensive. Static analysis of cost and number of solutions can be used to obtain the control values, instead of learning them. The efficiency of logic programs can also be increased by methods of program transformation <ref> (Pettorossi & Proietti, 1994, 1996) </ref>. One of the most popular approaches is the "rules+strategies" approach, which consists in starting from an initial program and then applying one or more elementary transformation rules. Transformation strategies are meta-rules which prescribe suitable sequences of applications of transformation rules.
Reference: <author> Pettorossi, A., & Proietti, M. </author> <year> (1996). </year> <title> Rules and strategies for transforming functional and logic programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 28 (2), </volume> <pages> 360-414. </pages>
Reference: <author> Porto, A. </author> <year> (1984). </year> <title> Epilog: A language for extended programming. </title> <editor> In Campbell, J. (Ed.), </editor> <title> Implementations of Prolog. </title> <publisher> Ellis Harwood. </publisher>
Reference: <author> Prieditis, A. E., & Mostow, J. </author> <year> (1987). </year> <title> PROLEARN: Towards a prolog interpreter that learns. </title> <editor> In Forbus, Kenneth; Shrobe, H. (Ed.), </editor> <booktitle> Proceedings of the 6th National Conference on Artificial Intelligence, </booktitle> <pages> pp. 494-498, </pages> <address> Seattle, WA. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: <author> Quinlan, J. R. </author> <year> (1986). </year> <title> Induction of decision trees. </title> <journal> Machine Learning, </journal> <volume> 1, </volume> <pages> 81-106. </pages>
Reference: <author> Quinlan, J. R., & Cameron-Jones, R. M. </author> <year> (1995). </year> <title> Induction of logic programs: FOIL and related systems. </title> <journal> New Generation Computing, Special Issue on Inductive Logic Programming, </journal> <volume> 13 (3-4), </volume> <pages> 287-312. </pages>
Reference-contexts: Using automatic subgoal ordering techniques, such as those described here, may help to solve these problems. The issue of subgoal ordering obtains a new significance with the development of Inductive Logic Programming (Lavrac & Dzeroski, 1994; Muggleton & De Raedt, 1994). Systems using this approach, such as FOIL <ref> (Quinlan & Cameron-Jones, 1995) </ref>, try to build correct programs as fast as possible, without considering the efficiency of the produced programs.
Reference: <author> Simon, H. A., & Kadane, J. B. </author> <year> (1975). </year> <title> Optimal problem-solving search: All-or-none solutions. </title> <journal> Artificial Intelligence, </journal> <volume> 6, </volume> <pages> 235-247. </pages>
Reference: <author> Smith, D. E. </author> <year> (1989). </year> <title> Controlling backward inference. </title> <journal> Artificial Intelligence, </journal> <volume> 39 (1), </volume> <month> 145-208. </month> <title> 96 The Divide-and-Conquer Subgoal-Ordering Algorithm Smith, </title> <editor> D. E., & Genesereth, M. R. </editor> <year> (1985). </year> <title> Ordering conjunctive queries. </title> <journal> Artificial Intelligence, </journal> <volume> 26, </volume> <pages> 171-215. </pages>
Reference: <author> Smith, D. E., Genesereth, M. R., & Ginsberg, M. L. </author> <year> (1986). </year> <title> Controlling recursive inference. </title> <journal> Artificial Intelligence, </journal> <volume> 30 (3), </volume> <pages> 343-389. </pages>
Reference: <author> Somogyi, Z., Henderson, F., Conway, T., Bromage, A., Dowd, T., Jeffery, D., & al. </author> <year> (1996a). </year> <title> Status of the Mercury system. </title> <booktitle> In Proc. of the JICSLP '96 Workshop on Parallelism and Implementation Technology for (Constraint) Logic Programming Languages, </booktitle> <pages> pp. 207-218, </pages> <address> Bonn, Germany. </address>
Reference-contexts: Again, no ordering algorithm is given explicitly. The purpose of the dac algorithm is complementary to the purpose of folon, and it could serve as an auxiliary aid to make the resulting Prolog program more efficient. Recently, the Mercury language was developed at the University of Melbourne <ref> (Somogyi et al., 1996a, 1996b) </ref>. Mercury is a strongly typed and strongly moded language. Type and mode declarations should be supplied by the programmer (though recent releases of the Mercury system already support partial inference of types and modes - Somogyi et al., 1996a).
Reference: <author> Somogyi, Z., Henderson, F., & Conway, T. </author> <year> (1996b). </year> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <volume> 29 (1-3), </volume> <pages> 17-64. </pages>
Reference-contexts: However, it is not appropriate when logic programs are used to manipulate complex data structures containing free variables (such as difference lists). This assumption was used for the experiments described in Section 6. 2. Some dialects of Prolog and other logic languages support mode declarations provided by the user <ref> (Somogyi et al., 1996b) </ref>. When such declarations are available, it is easy to infer the binding status of each variable upon exiting a subgoal. 3. <p> There is a danger that the benefit obtained by ordering will be outweighed by the cost of the ordering process. This is a manifestation of the so-called utility problem (Minton, 1988; Markovitch & Scott, 1993). In systems that are strongly-moded <ref> (such as Mercury - Somogyi et al., 1996b) </ref> we can employ the dac algorithm statically at compilation time for each one of the available modes, thus reducing the run-time ordering time to zero. The mode-based approach performs only syntactic tests of the subgoal arguments. <p> If termination information obtained by SA is available, we can use it to avoid entering infinite branches of proof trees. During ordering, termination information can serve to reduce the size of space of orderings searched by the algorithm. If the termination information comes in the form of allowed modes <ref> (Somogyi et al., 1996b) </ref>, orderings that violate these modes are filtered out, as in the modified algorithm shown in Figure 16. If the termination information comes in the form of a partial order between subgoals, orderings that violate this partial order can be filtered out in a similar manner.
Reference: <author> Sterling, L., & Shapiro, E. </author> <year> (1994). </year> <title> The Art of Prolog (Second edition). </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA. </address>
Reference-contexts: The domain qualitatively simulates moral reasoning: whether a person can be considered guilty, given various aspects of his character and of the crime performed. * Depth-first planner: Program 14.11 from the book "The Art of Prolog" <ref> (Sterling & Shapiro, 1994) </ref>.
Reference: <author> Tamaki, H., & Sato, T. </author> <year> (1984). </year> <title> Unfold/fold transformation of logic programs. </title> <editor> In Tarnlund, S.- A. (Ed.), </editor> <booktitle> Proceedings of the Second International Conference on Logic Programming, </booktitle> <pages> pp. 127-138, </pages> <institution> Uppsala, Sweden. </institution>
Reference-contexts: This technique is in fact a kind of compiling control. Its important property is the use of knowledge collected from experience (the orderings that were made in the past). One transformation method that can significantly benefit from the dac algorithm is unfolding <ref> (Tamaki & Sato, 1984) </ref>. During the unfolding process subgoals are replaced by their associated rule bodies. Even if the initial rules were ordered optimally by a human programmer or a static ordering procedure, the resulting combined sequence may be far from optimal.
Reference: <author> Ullman, J. D., & Vardi, M. Y. </author> <year> (1988). </year> <title> The complexity of ordering subgoals. </title> <booktitle> In Proceedings of the Seventh ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pp. 74-81, </pages> <address> Austin, TX. </address> <publisher> ACM Press, </publisher> <address> New York. </address>
Reference-contexts: In Section 5 we show how this control knowledge can be obtained by inductive learning. 3.2 Ordering of Independent Sets of Subgoals The general subgoal ordering problem is NP-hard <ref> (Ullman & Vardi, 1988) </ref>. However, there is a special case where ordering can be performed efficiently: if all the subgoals in the 45 Ledeniov & Markovitch given set are independent, i.e. do not share free variables. This section begins with the definition of subgoal dependence and related concepts.
Reference: <author> Ullman, J. D. </author> <year> (1982). </year> <title> Principles of Database Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD. </address>
Reference: <author> Vasak, T., & Potter, J. </author> <year> (1985). </year> <title> Metalogical control for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 (3), </volume> <pages> 203-220. </pages>
Reference: <author> Warren, D. H. D. </author> <year> (1981). </year> <title> Efficient processing of interactive relational database queries expressed in logic. </title> <editor> In Zaniola, & Delobel (Eds.), </editor> <booktitle> Proceedings of the 7th International Conference on Very Large Data Bases, </booktitle> <pages> pp. 272-281, </pages> <address> Cannes, France. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 97 </pages>
References-found: 61

