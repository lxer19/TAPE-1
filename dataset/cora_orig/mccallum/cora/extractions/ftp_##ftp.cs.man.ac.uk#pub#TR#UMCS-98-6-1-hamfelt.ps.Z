URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-hamfelt.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Title: Inductive Synthesis of Logic Programs by Composition of Combinatory Program Schemes  
Author: Andreas Hamfelt Jorgen Fischer Nilsson 
Keyword: logic program schemata, logical combinators, synthesis by composition and specialization of schemas, inductive synthesis, metalogic program environment.  
Date: May 25, 1998  
Address: Denmark  
Affiliation: Computing Science Department Uppsala University  Department of Computer Science Technical University of  
Abstract: Based on a variable-free combinatory form of definite clause logic programs we outline a methodology and supporting program environment for inducing logic programs from examples. The combinators comprise fold combinators for recursion on lists. The combinator form avoids confusing object and metavariables in the applied metalogic program environment. Moreover, the combinators enable piecewise composition of semantically meaningful program elements according to the compositional semantics principle. In addition useful algebraic rewriting rules can be formulated conveniently with the combinators. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Backus: </author> <title> Can Programming be Liberated from the von Neumann Style ? A Functional Style and Its Algebra of Programs. </title> <journal> Comm. of the ACM, </journal> <volume> 21, 8, </volume> <year> 1978. </year> <pages> pp. 613-641. </pages>
Reference-contexts: In functional programming functional composition offers itself as one of the forms together with conditionals and certain recursion forms <ref> [1] </ref>. In logic programming it is more difficult to identify combinators since there are no standard combining forms for n-ary predicates. In a recent paper [8] we pursue the compositional principle in the context of logic programming by proposing a variable-free combinator form of definite clauses termed combilog. <p> Thus make <ref> [1; 2; : : : ; n] </ref> is the iden tity combinator for n-ary relations, and the term make [1; 2; : : : ; n](true) yields the n-ary universal relation from the 0-ary true. <p> Thus make <ref> [1; 2; : : : ; n] </ref> is the iden tity combinator for n-ary relations, and the term make [1; 2; : : : ; n](true) yields the n-ary universal relation from the 0-ary true. These definitions are proved in [8] to make the semantics coincide with the usual least model and fix point semantics of definite clauses. <p> ; W ) foldr (P; Q)(Y; T ; Z) ^ P (X; Z; W ): foldl (P; Q)(Y; nil; Z) Q (Y; Z) foldl (P; Q)(Y; X:T; W ) P (X; Y; Z) ^ foldl (P; Q)(Z; T; W ): which are relational counterparts of the well known functional operators <ref> [1, 2, 13] </ref>. Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. <p> Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make <ref> [2; 1; 3] </ref>(foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments. The short and elegant combinatory formulations of append is seductive since combinatory formulations are admittedly sometimes awkward. <p> Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make <ref> [2; 1; 3] </ref>(foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments. The short and elegant combinatory formulations of append is seductive since combinatory formulations are admittedly sometimes awkward. <p> For instance the unit clause make unit list (X; X:nil) via the reformulation make unit list (X; Y ) const nil (Z); cons (X; Z; Y ) which serves to remove non-variable terms, yields the combinatory definition make unit list make <ref> [1; 3] </ref>(and (make [2; 1; 3](const nil ); cons)) being in the canonical form mentioned above. In [7] we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. <p> For instance the unit clause make unit list (X; X:nil) via the reformulation make unit list (X; Y ) const nil (Z); cons (X; Z; Y ) which serves to remove non-variable terms, yields the combinatory definition make unit list make [1; 3](and (make <ref> [2; 1; 3] </ref>(const nil ); cons)) being in the canonical form mentioned above. In [7] we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make <ref> [3; 2; 1] </ref>(foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <ref> [1; 3; 2] </ref>(P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make [1; 3; 2](P ); make <ref> [2; 1] </ref>(Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make <ref> [3; 2; 1] </ref>(foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <ref> [1; 3; 2] </ref>(P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make [1; 3; 2](P ); make <ref> [2; 1] </ref>(Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> The iden tity combinator make <ref> [1; 2; : : :; n] </ref> is left implicit in terms.
Reference: [2] <author> R. Bird & O. de Moor: </author> <title> Algebra of Programming, </title> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: Thus make <ref> [1; 2; : : : ; n] </ref> is the iden tity combinator for n-ary relations, and the term make [1; 2; : : : ; n](true) yields the n-ary universal relation from the 0-ary true. <p> Thus make <ref> [1; 2; : : : ; n] </ref> is the iden tity combinator for n-ary relations, and the term make [1; 2; : : : ; n](true) yields the n-ary universal relation from the 0-ary true. These definitions are proved in [8] to make the semantics coincide with the usual least model and fix point semantics of definite clauses. <p> One way of eliminating these recursive definitions would be to introduce a general fix point combinator (cf. the Y combinator in combinatory logic). However, we prefer to introduce 3 list-oriented recursion operators analogously to functional programming practice <ref> [2, 13] </ref>. <p> ; W ) foldr (P; Q)(Y; T ; Z) ^ P (X; Z; W ): foldl (P; Q)(Y; nil; Z) Q (Y; Z) foldl (P; Q)(Y; X:T; W ) P (X; Y; Z) ^ foldl (P; Q)(Z; T; W ): which are relational counterparts of the well known functional operators <ref> [1, 2, 13] </ref>. Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. <p> Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make <ref> [2; 1; 3] </ref>(foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments. The short and elegant combinatory formulations of append is seductive since combinatory formulations are admittedly sometimes awkward. <p> Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make <ref> [2; 1; 3] </ref>(foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments. The short and elegant combinatory formulations of append is seductive since combinatory formulations are admittedly sometimes awkward. <p> For instance the unit clause make unit list (X; X:nil) via the reformulation make unit list (X; Y ) const nil (Z); cons (X; Z; Y ) which serves to remove non-variable terms, yields the combinatory definition make unit list make [1; 3](and (make <ref> [2; 1; 3] </ref>(const nil ); cons)) being in the canonical form mentioned above. In [7] we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make <ref> [3; 2; 1] </ref>(foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <ref> [1; 3; 2] </ref>(P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make [1; 3; 2](P ); make <ref> [2; 1] </ref>(Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make <ref> [3; 2; 1] </ref>(foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <ref> [1; 3; 2] </ref>(P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make [1; 3; 2](P ); make <ref> [2; 1] </ref>(Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> The iden tity combinator make <ref> [1; 2; : : :; n] </ref> is left implicit in terms.
Reference: [3] <author> P. Flener: </author> <title> Inductive Logic Program Synthesis with dialogs. </title> <booktitle> In [9] pp. </booktitle> <pages> 175-198. </pages>
Reference-contexts: Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make <ref> [2; 1; 3] </ref>(foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments. The short and elegant combinatory formulations of append is seductive since combinatory formulations are admittedly sometimes awkward. <p> Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make <ref> [2; 1; 3] </ref>(foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments. The short and elegant combinatory formulations of append is seductive since combinatory formulations are admittedly sometimes awkward. <p> For instance the unit clause make unit list (X; X:nil) via the reformulation make unit list (X; Y ) const nil (Z); cons (X; Z; Y ) which serves to remove non-variable terms, yields the combinatory definition make unit list make <ref> [1; 3] </ref>(and (make [2; 1; 3](const nil ); cons)) being in the canonical form mentioned above. In [7] we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. <p> For instance the unit clause make unit list (X; X:nil) via the reformulation make unit list (X; Y ) const nil (Z); cons (X; Z; Y ) which serves to remove non-variable terms, yields the combinatory definition make unit list make [1; 3](and (make <ref> [2; 1; 3] </ref>(const nil ); cons)) being in the canonical form mentioned above. In [7] we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. <p> In [7] we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. However, this is a purely theoretical result; in logic programming practice non-linear recursion forms such as and-or problem reduction schemes are convenient, cf. <ref> [3] </ref>. Still the empirical investigation in [7] tells that most common pure logic programs can be naturally formulated within the fold schemes; therefore we confine ourselves to the fold schemes in the present context. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make <ref> [3; 2; 1] </ref>(foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <ref> [1; 3; 2] </ref>(P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make <ref> [3; 2; 1] </ref>(foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs. <p> Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <ref> [1; 3; 2] </ref>(P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic or fix point, understanding of logic programs.
Reference: [4] <author> Gegg-Harrison, T. S.: </author> <title> Representing Logic Program Schemata in Prolog. </title> <editor> In L. Sterling (ed.) </editor> <booktitle> Procs. Twelfth International Conference on Logic Programming 1995, </booktitle> <publisher> MIT Press, </publisher> <address> London, </address> <year> 1995. </year> <pages> pp. 467-481. </pages>
Reference-contexts: Similar recursion operators are proposed in <ref> [4] </ref> applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section. For instance the relational append predicate definition in the extended combilog becomes append make [2; 1; 3](foldr (cons; id )) where make [2; 1; 3] swaps the two first arguments.
Reference: [5] <author> A. Hamfelt & J. Fischer Nilsson: </author> <title> Inductive metalogic programming. </title> <editor> In S. Wrobel (ed.) </editor> <booktitle> Procs. Fourth International Workshop on Inductive Logic programming (ILP-94), </booktitle> <address> Bad Honnef/Bonn, GMD-Studien Nr. 237, </address> <year> 1994. </year> <pages> pp. 85-96. </pages>
Reference-contexts: This approach conforms with induction of logical theories as carried out in the machine learning tradition. It has turned out to be difficult to synthesize recursive program structures (i.e., programs applying recursively defined predicates) from sample facts with no a priori indication of recursive structure. In <ref> [5] </ref> we tried to tackle this problem by suggesting that the program structure to be induced has to comply with given recursion schemes of universal nature. The induction process then essentially reduces to synthesizing of auxiliary argument predicates. <p> In addition to these general constraints various heuristics may be taken advantage of, for instance [[and (P; Q)]] [[P ]]. This combinatory approach is distinguished from MetaInduce <ref> [5] </ref> by avoiding the complications of object variables in synthesized clauses.
Reference: [6] <author> A. Hamfelt & J. Fischer Nilsson: </author> <title> Declarative Logic Programming with Primitive Recursive Relations on Lists. </title> <editor> In M. Maher (ed.) </editor> <booktitle> Procs. Joint International Conference and Symposium on Logic Programming 1996, </booktitle> <publisher> MIT Press, </publisher> <address> London, </address> <year> 1996, </year> <pages> pp. 230-242. </pages>
Reference-contexts: Technical Report Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y Supported by a grant from Volvo Research Foundation, Volvo Educational Foundation and Dr Pehr G. Gyllenhammar's Research Foundation. 1 In a number of more recent papers <ref> [6, 7, 8] </ref> we have introduced a novel combinatory form of logic programs enabling variable-free formulations of definite clauses. <p> One way of eliminating these recursive definitions would be to introduce a general fix point combinator (cf. the Y combinator in combinatory logic). However, we prefer to introduce 3 list-oriented recursion operators analogously to functional programming practice [2, 13]. In <ref> [6, 7] </ref> we propose two fold combinators for list recursion defined e.g., as follows. foldr (P; Q)(Y; nil; Z) Q (Y; Z) foldr (P; Q)(Y; X:T ; W ) foldr (P; Q)(Y; T ; Z) ^ P (X; Z; W ): foldl (P; Q)(Y; nil; Z) Q (Y; Z) foldl (P; <p> Still the empirical investigation in [7] tells that most common pure logic programs can be naturally formulated within the fold schemes; therefore we confine ourselves to the fold schemes in the present context. Actually in [7] we state and in <ref> [6] </ref> we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the declarative, that is model theoretic <p> The mode constraints are critical to our induction approach since absence of the constraints would admit the universal relation as simplest solution in absence of negative examples. Let us introduce the notion of valence for the combined constraints of modes, types and arity, assuming synthesis of well-moded programs only <ref> [6] </ref>. The intuition is that composition of combinators are subject to constraints like valence constraints on chemical atoms and radicals. The heart of the synthesizer are defining clauses for a mutually recursive predicates syn and syn make drawing on the above defining clauses for the combinators.
Reference: [7] <author> A. Hamfelt & J. Fischer Nilsson: </author> <title> Towards a Logic Programming Methodology Based on Higher-order Predicates. </title> <journal> J. New Generation Computing, </journal> <volume> vol 15, no 4, </volume> <year> 1997. </year> <pages> pp. 421-448. </pages>
Reference-contexts: Technical Report Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y Supported by a grant from Volvo Research Foundation, Volvo Educational Foundation and Dr Pehr G. Gyllenhammar's Research Foundation. 1 In a number of more recent papers <ref> [6, 7, 8] </ref> we have introduced a novel combinatory form of logic programs enabling variable-free formulations of definite clauses. <p> One way of eliminating these recursive definitions would be to introduce a general fix point combinator (cf. the Y combinator in combinatory logic). However, we prefer to introduce 3 list-oriented recursion operators analogously to functional programming practice [2, 13]. In <ref> [6, 7] </ref> we propose two fold combinators for list recursion defined e.g., as follows. foldr (P; Q)(Y; nil; Z) Q (Y; Z) foldr (P; Q)(Y; X:T ; W ) foldr (P; Q)(Y; T ; Z) ^ P (X; Z; W ): foldl (P; Q)(Y; nil; Z) Q (Y; Z) foldl (P; <p> In <ref> [7] </ref> we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. However, this is a purely theoretical result; in logic programming practice non-linear recursion forms such as and-or problem reduction schemes are convenient, cf. [3]. Still the empirical investigation in [7] tells <p> In <ref> [7] </ref> we prove that logic program recursion with the fold schemes suffices for expressing all partial and general recursive functions. However, this is a purely theoretical result; in logic programming practice non-linear recursion forms such as and-or problem reduction schemes are convenient, cf. [3]. Still the empirical investigation in [7] tells that most common pure logic programs can be naturally formulated within the fold schemes; therefore we confine ourselves to the fold schemes in the present context. Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make <p> Still the empirical investigation in <ref> [7] </ref> tells that most common pure logic programs can be naturally formulated within the fold schemes; therefore we confine ourselves to the fold schemes in the present context. Actually in [7] we state and in [6] we prove the following duality theorems foldr (P; Q) j make [3; 2; 1](foldl (make [1; 3; 2](P ); make [2; 1](Q))) foldl (P; Q) j make [3; 2; 1](foldr (make [1; 3; 2](P ); make [2; 1](Q))) connecting the two fold operators in the <p> The program synthesis environment is established as a metalogic program where the com-binator terms appear as ordinary terms as explained in <ref> [7, 8, 14] </ref>, by way of a generic predicate apply as exemplified with and apply (and (P; Q); X 1 ) apply (P; X 1 ) ^ apply (Q; X 1 ) apply (and (P; Q); X 1 ; X 2 ) apply (P; X 1 ; X 2 ) ^
Reference: [8] <author> A. Hamfelt, J. Fischer Nilsson & A. Vitoria: </author> <title> A Combinatory Form of Pure Logic Programs and its Compositional Semantics. </title> <note> Submitted for publication 1998. 7 </note>
Reference-contexts: Technical Report Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y Supported by a grant from Volvo Research Foundation, Volvo Educational Foundation and Dr Pehr G. Gyllenhammar's Research Foundation. 1 In a number of more recent papers <ref> [6, 7, 8] </ref> we have introduced a novel combinatory form of logic programs enabling variable-free formulations of definite clauses. <p> In functional programming functional composition offers itself as one of the forms together with conditionals and certain recursion forms [1]. In logic programming it is more difficult to identify combinators since there are no standard combining forms for n-ary predicates. In a recent paper <ref> [8] </ref> we pursue the compositional principle in the context of logic programming by proposing a variable-free combinator form of definite clauses termed combilog. <p> These combinators are of generic arity and in addition make is indexed with m distinct positive index numbers. These combinators are inspired by a proposal by Quine [12] for a variable free form of full first order predicate logic, see <ref> [8] </ref> for a discussion. 2 The predicate identifiers include, besides user introduced predicate names, the four pre- defined predicates cons, true, id, const c defined by the following unit clauses cons (U; V; U:V ) id (X; X ) true const c (c) for all relevant constants c. In [8] is <p> see <ref> [8] </ref> for a discussion. 2 The predicate identifiers include, besides user introduced predicate names, the four pre- defined predicates cons, true, id, const c defined by the following unit clauses cons (U; V; U:V ) id (X; X ) true const c (c) for all relevant constants c. In [8] is proven combinatory completeness relative to definite clauses of these combinators in a canonical form with the defining term or fl (make [ ~ i ](and fl (make [ ~ ij ]q ij ))) where or fl is zero, one or more applications of or and analogously for and. <p> Thus make [1; 2; : : : ; n] is the iden tity combinator for n-ary relations, and the term make [1; 2; : : : ; n](true) yields the n-ary universal relation from the 0-ary true. These definitions are proved in <ref> [8] </ref> to make the semantics coincide with the usual least model and fix point semantics of definite clauses. <p> The program synthesis environment is established as a metalogic program where the com-binator terms appear as ordinary terms as explained in <ref> [7, 8, 14] </ref>, by way of a generic predicate apply as exemplified with and apply (and (P; Q); X 1 ) apply (P; X 1 ) ^ apply (Q; X 1 ) apply (and (P; Q); X 1 ; X 2 ) apply (P; X 1 ; X 2 ) ^ <p> The apply predicates enable execution of combinatory programs in the metalogic programming environment. The resulting semantics is proved equivalent in <ref> [8] </ref> to the semantics described above for the combinators. During the course of the induction the combinator terms being synthesized may be non-ground, the variables representing unknown (sub)combinator terms.
Reference: [9] <editor> S. Muggleton (ed.): </editor> <booktitle> Inductive Logic Programming, Proceedings of the 6th International Work--shop on Inductive Logic Programming, 1996, Lecture Notes in Artificial Intelligence 1314, </booktitle> <publisher> Springer, </publisher> <year> 1996. </year>
Reference: [10] <editor> S.-H. Nienhuys-Cheng, R. de Wolf: </editor> <booktitle> Foundations of Inductive Logic Programming, Lecture Notes in Artificial Intelligence 1228, </booktitle> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Induction of logic programs (ILP) is traditionally conducted as a generalization process in which program clauses are synthesized by generalization involving anti-unification from input/output examples <ref> [10] </ref>. This approach conforms with induction of logical theories as carried out in the machine learning tradition. It has turned out to be difficult to synthesize recursive program structures (i.e., programs applying recursively defined predicates) from sample facts with no a priori indication of recursive structure.
Reference: [11] <author> J. Fischer Nilsson & A. Hamfelt: </author> <title> Constructing Logic Programs with Higher Order Predicates. </title> <editor> In M. Alpuente & M. I. Sessa (eds.) </editor> <booktitle> Procs. Joint Conference on Declarative Programming 1995 (GULP-PRODE'95), </booktitle> <institution> Universita' Degli Studi di Salerno, Salerno, </institution> <year> 1995. </year> <pages> pp. 307-312. </pages>
Reference: [12] <author> W. V. Quine: </author> <title> Predicate-functor Logic. </title> <editor> In J. E. Fenstad (ed.) </editor> <booktitle> Procs. Second Scandinavian Logic Symposium, </booktitle> <publisher> North-Holland, </publisher> <year> 1971. </year> <pages> pp. 309-315. </pages>
Reference-contexts: These combinators are of generic arity and in addition make is indexed with m distinct positive index numbers. These combinators are inspired by a proposal by Quine <ref> [12] </ref> for a variable free form of full first order predicate logic, see [8] for a discussion. 2 The predicate identifiers include, besides user introduced predicate names, the four pre- defined predicates cons, true, id, const c defined by the following unit clauses cons (U; V; U:V ) id (X; X
Reference: [13] <author> C. Reade: </author> <title> Elements of Functional Programming, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: One way of eliminating these recursive definitions would be to introduce a general fix point combinator (cf. the Y combinator in combinatory logic). However, we prefer to introduce 3 list-oriented recursion operators analogously to functional programming practice <ref> [2, 13] </ref>. <p> ; W ) foldr (P; Q)(Y; T ; Z) ^ P (X; Z; W ): foldl (P; Q)(Y; nil; Z) Q (Y; Z) foldl (P; Q)(Y; X:T; W ) P (X; Y; Z) ^ foldl (P; Q)(Z; T; W ): which are relational counterparts of the well known functional operators <ref> [1, 2, 13] </ref>. Similar recursion operators are proposed in [4] applying -Prolog, whereas our combinators are made available in ordinary logic programming as explained in the next section.
Reference: [14] <author> D. H. D. Warren: </author> <title> Higher-order extensions to PROLOG: are they needed ? In D. </title> <editor> Michie (ed.) </editor> <booktitle> Machine Intelligence 10, </booktitle> <publisher> Ellis Horwood and Edinburgh University Press, </publisher> <year> 1982. </year> <pages> pp. 441-454. 8 </pages>
Reference-contexts: The program synthesis environment is established as a metalogic program where the com-binator terms appear as ordinary terms as explained in <ref> [7, 8, 14] </ref>, by way of a generic predicate apply as exemplified with and apply (and (P; Q); X 1 ) apply (P; X 1 ) ^ apply (Q; X 1 ) apply (and (P; Q); X 1 ; X 2 ) apply (P; X 1 ; X 2 ) ^
References-found: 14

