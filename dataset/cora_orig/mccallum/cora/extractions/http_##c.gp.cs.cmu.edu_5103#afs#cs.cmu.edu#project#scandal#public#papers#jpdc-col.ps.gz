URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/scandal/public/papers/jpdc-col.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/guyb/publications.html
Root-URL: http://www.cs.cmu.edu
Title: Compiling Collection-Oriented Languages onto Massively Parallel Computers  
Author: Guy E. Blelloch Gary W. Sabot 
Date: July 17, 1989  
Affiliation: Carnegie Mellon University and  Thinking Machines Corporation  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> APL2 Programming: </author> <title> Language Reference. IBM, </title> <booktitle> first edition, </booktitle> <month> August </month> <year> 1984. </year> <title> Order Number SH20-9227-0. </title>
Reference-contexts: Such hardware includes vector computers and homogeneous parallel computers. The techniques considered are useful for a class of languages we call collection-oriented languages. Collection-oriented languages, such as Paralation Lisp [12], CM-Lisp [15], SETL [13], NIAL [11], SQL [5], APL [8,9] or APL2 <ref> [1] </ref>, are based on data structures which represent collections of elements, and operations for manipulating the collections as a whole, such as multiplying two arrays or taking the intersection of two sets.
Reference: [2] <author> Guy Blelloch. </author> <title> Scans as primitive parallel operations. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 355-362, </pages> <publisher> IEEE Computer Society, </publisher> <year> 1987. </year>
Reference: [3] <author> Guy E. Blelloch. </author> <title> Scan Primitives and Parallel Vector Models. </title> <type> PhD thesis, </type> <institution> Artificial Intelligence Laboratory, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: The compiler is therefore by no means complete: it only supports a small, but important, subset of Paralation Lisp. The compiler does, however, produces efficient output code. The CM-2 code generated by the quicksort 2 Paralation Lisp + This paper SV-Lisp with Segmented Instructions + See <ref> [3] </ref> SV-Lisp without Segmented Instructions + A Common Lisp compiler Vector and Host Machine Instructions + See [3] CM-2 Instructions example described in Section 2 and Section 6 is only a factor of three slower than the fastest existing sorting routine for the CM-2 (an optimized radix sort written in PARIS, <p> The compiler does, however, produces efficient output code. The CM-2 code generated by the quicksort 2 Paralation Lisp + This paper SV-Lisp with Segmented Instructions + See <ref> [3] </ref> SV-Lisp without Segmented Instructions + A Common Lisp compiler Vector and Host Machine Instructions + See [3] CM-2 Instructions example described in Section 2 and Section 6 is only a factor of three slower than the fastest existing sorting routine for the CM-2 (an optimized radix sort written in PARIS, the parallel instruction set of the Connection Machine). <p> Section 7 discusses compiler extensions that remove some of these restrictions. 4 Target Code: Scan-Vector Lisp We now describe the target code of the compiler, SV-Lisp (Scan-Vector Lisp) <ref> [3] </ref>. SV-Lisp is a small subset of Common Lisp with the addition of a new data type, the pvector, and a set of instructions for manipulating this data type, the pvector instructions. <p> When executing a pvector instructions, each processor is responsible for its own elements (see <ref> [3] </ref> for more details). Many of the techniques considered for compiling APL onto both serial and parallel machines [4,6] would also be useful here. SV-Lisp includes a set of segmented instructions which are key to the implementation of nested parallel routines. <p> The segmented version of the scan instructions restart at the beginning of each segment. Elsewhere we show that all the segmented instructions can be implemented with a small constant number of calls to the unsegmented versions <ref> [3] </ref>. It is important to realize that when mapping segmented vectors onto a parallel machine both the value vector and the segment descriptor vector are evenly balanced across the processors. The mapping need not know that the two parts belong to a segmented vector. <p> For example: #F (#F (a 00 a 01 ) #F (a 10 a 11 a 12 ) #F (a 20 )) pfield segdes: <ref> [3] </ref> values: pfield segdes: [2 3 1] values: [a 00 a 01 a 10 a 11 a 12 a 20 ] In this example, the segdes slot of the inner pfield describes the segmentation of the values slot. <p> For example: #F @ u : u 00 u : u 01 u : u 02 1 pfield segdes: <ref> [3] </ref> values: uv-structure u: [u 0 u 1 u 2 ] In this example, the field of three uv-structures is mapped onto a single uv-structure whose slots contain a pvector with the values of all three of the original uv-structures. <p> (let ((field-of-fields #F (#F (7 4) #F (11) #F (8 1 17)))) (elwise ((field field-of-fields)) (elwise ((value field)) (+ value value)))) ) #F (#F (14 8) #F (22) #F (16 2 34)) Based on the representation discussed in Section 5.1, the original field is represented as: field-of-fields = pfield segdes: <ref> [3] </ref> values: pfield segdes: [2 1 3] values: [7 4 11 8 1 17] When entering the outer elwise, the stepping-down code strips off the top pfield leaving: field = pfield segdes: [2 1 3] values: [7 4 11 8 1 17] And when entering the inner elwise, the next pfield <p> field, the result is: [14 8 22 16 2 34] When exiting the inner elwise the stepping-up code appends a pfield back on, return- ing: pfield segdes: [2 1 3] values: [14 8 22 16 2 34] And when exiting the outer elwise another pfield is appended, returning: pfield segdes: <ref> [3] </ref> values: pfield segdes: [2 1 3] values: [14 8 22 16 2 34] Which is the representation of the desired result: #F (#F (14 8) #F (22) #F (16 2 34)) In this example, the code that executes the addition runs in parallel over all elements therefore taking advantage of <p> The general throw, catch and go special forms, however, cannot 21 and are not supported by the subset of Paralation Lisp accepted by the compiler. The translation described in this section is based on a technique called replicating <ref> [3] </ref>. The problem with the parallel (replicated) version of a routine with an if form is that, some of the segments might take one branch while others might take the other. The parallel version therefore might need to execute both branches. <p> If the field is a boolean field, however, the rank can be implemented with two scans and a permute <ref> [3] </ref>. The segdes vector of the mapping contains the number of occurrences of each distinct value in the source field. <p> These might include lists and list operations. Another extension would be to include heterogeneous fields. Heterogeneous fields might be added by using the representation discussed in <ref> [3] </ref>.
Reference: [4] <author> Timothy A. Budd. </author> <title> An APL Compiler for a Vector Processor. </title> <type> Technical Report 82-6, </type> <institution> The University of Arizona, Department of Computer Science, Tuscon, Arizona 85721, </institution> <month> July </month> <year> 1982. </year>
Reference: [5] <author> C. J. Date. </author> <title> Database Systems, Volume I. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <note> fourth edition, </note> <year> 1986. </year>
Reference-contexts: Such hardware includes vector computers and homogeneous parallel computers. The techniques considered are useful for a class of languages we call collection-oriented languages. Collection-oriented languages, such as Paralation Lisp [12], CM-Lisp [15], SETL [13], NIAL [11], SQL <ref> [5] </ref>, APL [8,9] or APL2 [1], are based on data structures which represent collections of elements, and operations for manipulating the collections as a whole, such as multiplying two arrays or taking the intersection of two sets. <p> The first slot contains a definition of a single segment| its length. The second slot contains a pvector with the values of the field. For example: #F (a 0 a 1 a 2 a 3 a 4 ) ! pfield segdes: <ref> [5] </ref> values: [a 0 a 1 a 2 a 3 a 4 ] We use a pfield structure instead of using a pvector directly since it allows us to check if two equal length fields belong to the same paralation. 4 Using the pfield structure also permits a more homogeneous implementation
Reference: [6] <author> Leo J. Guibas and Douglas K. Wyatt. </author> <title> Compilation and delayed evaluation in APL. </title> <booktitle> In Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-8, </pages> <year> 1978. </year>
Reference: [7] <author> C. A. R. Hoare. </author> <title> Quicksort. </title> <journal> Computer J., </journal> <volume> 5(1) </volume> <pages> 10-15, </pages> <year> 1962. </year>
Reference-contexts: top level and one to be called nested. 3 * The stepping-up and stepping-down manipulations used at the entry and exit of the Paralation Lisp apply-to-each form. * The implementation of nested conditionals|perhaps the most elusive aspect of flattening nested parallelism. 2 Quicksort Example This section introduces a quicksort example <ref> [7] </ref>. This parallel quicksort example illustrates the use of nested parallelism, gives a basic idea of the constructs of Para-lation Lisp, and introduces some of the techniques described in the remainder of the paper.
Reference: [8] <author> Kenneth E. Iverson. </author> <title> A Programming Language. </title> <publisher> John Wiley & Sons, Inc, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: If the type cannot be inferred at compile time, the compiler inserts code that executes a type dispatch at run time. 5 This is similar to scalar extension in APL <ref> [8] </ref>, but in Paralation Lisp any value will be extended, not just scalars. 18 (elwise ((a A)) (+ a b)) (simp-elwise ((a A) (b (distribute b (pfield-segdes A)))) (+ a b)) are removed by this manipulation.
Reference: [9] <author> Kenneth E. Iverson. </author> <title> A dictionary of APL. </title> <journal> APL Quote Quad, </journal> <volume> 18(1) </volume> <pages> 5-40, </pages> <month> September </month> <year> 1987. </year>
Reference: [10] <author> Alan H. Karp. </author> <title> Programming for parallelism. </title> <booktitle> IEEE Computer, </booktitle> <pages> 43-57, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Most currently implemented parallel programming models allow only a single level of parallelism <ref> [10] </ref>. For example, a user could define a parallel draw-line routine that given two endpoints determine all the pixels that lie on the line between the points. This routine, however, cannot itself be called in parallel; the user cannot draw multiple lines in parallel.
Reference: [11] <author> Trenchard More. </author> <title> The nested rectangular array as a model of data. </title> <booktitle> In APL79 Conference Proceedings, </booktitle> <pages> pages 55-73, </pages> <publisher> ACM, </publisher> <year> 1979. </year> <month> 30 </month>
Reference-contexts: Such hardware includes vector computers and homogeneous parallel computers. The techniques considered are useful for a class of languages we call collection-oriented languages. Collection-oriented languages, such as Paralation Lisp [12], CM-Lisp [15], SETL [13], NIAL <ref> [11] </ref>, SQL [5], APL [8,9] or APL2 [1], are based on data structures which represent collections of elements, and operations for manipulating the collections as a whole, such as multiplying two arrays or taking the intersection of two sets.
Reference: [12] <author> Gary W. Sabot. </author> <title> The Paralation Model: Architecture-Independent Parallel Pro--gramming. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Such hardware includes vector computers and homogeneous parallel computers. The techniques considered are useful for a class of languages we call collection-oriented languages. Collection-oriented languages, such as Paralation Lisp <ref> [12] </ref>, CM-Lisp [15], SETL [13], NIAL [11], SQL [5], APL [8,9] or APL2 [1], are based on data structures which represent collections of elements, and operations for manipulating the collections as a whole, such as multiplying two arrays or taking the intersection of two sets. <p> Although the techniques discussed in this paper could be used for many nested collection-oriented languages, for the sake of concreteness, the techniques will be presented in the framework of a compiler for a particular nested collection-oriented language, Paralation Lisp <ref> [12] </ref>, and will compile to a particular flat collection-oriented instruction set, SV-Lisp. <p> into a routine which has an expected complexity of O (lg n) calls to a set of simple data parallel operations such as permute, scan, and elementwise arithmetic and logical operations. 3 Source Code: Paralation Lisp This section summarizes the Paralation Lisp language; for more details the reader should see <ref> [12] </ref>. <p> Mappings in Paralation Lisp can be represented in canonical form as a pair of integer vectors: the first vector are indices into the destination from the source, and the second are indices into the source from the destination (see <ref> [12] </ref> for more details). 5.2 Operations This section discusses the manipulations necessary to translate code from the subset of Paralation Lisp into SV-Lisp.
Reference: [13] <author> J. T. Schwartz, R.B.K. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An Introduction to SETL. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Such hardware includes vector computers and homogeneous parallel computers. The techniques considered are useful for a class of languages we call collection-oriented languages. Collection-oriented languages, such as Paralation Lisp [12], CM-Lisp [15], SETL <ref> [13] </ref>, NIAL [11], SQL [5], APL [8,9] or APL2 [1], are based on data structures which represent collections of elements, and operations for manipulating the collections as a whole, such as multiplying two arrays or taking the intersection of two sets.
Reference: [14] <author> Guy L. Steele Jr., Scott E. Fahlman, Richard P. Gabriel, David A. Moon, and Daniel L. Weinreb. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Burlington, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: The Common Lisp operations are defined in the Common Lisp reference manual <ref> [14] </ref>. The pvector instructions are further separated into four subclasses. The elementwise instructions execute an elementary arithmetic or logical operation, such as +; ; fl; or, and not, over the indices of the input vectors (see on another vector of indices.
Reference: [15] <author> Guy L. Steele Jr. and W. Daniel Hillis. </author> <title> Connection Machine LISP: fine-grained parallel symbolic processing. </title> <booktitle> In Proc. 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 279-297, </pages> <publisher> ACM SIGPLAN/SIGACT/SIGART, </publisher> <address> Cam-bridge, Massachusetts, </address> <month> August </month> <year> 1986. </year> <note> Also available as Thinking Machines Technical Report 86.16. </note>
Reference-contexts: Such hardware includes vector computers and homogeneous parallel computers. The techniques considered are useful for a class of languages we call collection-oriented languages. Collection-oriented languages, such as Paralation Lisp [12], CM-Lisp <ref> [15] </ref>, SETL [13], NIAL [11], SQL [5], APL [8,9] or APL2 [1], are based on data structures which represent collections of elements, and operations for manipulating the collections as a whole, such as multiplying two arrays or taking the intersection of two sets.
Reference: [16] <author> Thinking Machines Corporation. </author> <title> The Essential *Lisp Manual. </title> <address> Cambridge, Mas-sachusetts, </address> <year> 1986. </year> <month> 31 </month>
Reference-contexts: The generated code is also faster than a version of quicksort implemented in *Lisp <ref> [16] </ref> (one of the two supported languages for the CM-2) and compiled using the *Lisp compiler. *Lisp does not allow nested constructs, so the code is also significantly more complex (the description of segments and the manipulation of these segments must be included in the code).
References-found: 16

