URL: http://www.cs.unc.edu/~csa/proposals/ponamgi.ps
Refering-URL: http://www.cs.unc.edu/~csa/proposals/
Root-URL: http://www.cs.unc.edu
Title: Collision Detection for Interactive Environments and Simulations  
Author: Madhav K. Ponamgi 
Affiliation: Department of Computer Science University of North Carolina  
Abstract: We propose a new collision detection algorithm for polygonal models in interactive environments and simulations based on incremental computations. The algorithm will be implemented as a system that will provide collision detection for large-scale geometric data sets modeled from primitives such as polygons and polytopes. The overall goal is to develop a demonstrable system that can be used with present-day animation and simulation environments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P.K.Agrawal and M.Sharir. </author> " <title> Red-blue intersection detection algorithms with applications to motion planning and collision detection." </title> <journal> SIAM J. Computing (1990) 19 </journal> <pages> 297-321. </pages>
Reference: [2] <author> A. Alonso, N. Serrano and J. Flaquer. </author> <title> "Solving the Collision Detection Problem" Computer Graphics and Applications (1994) pp. </title> <type> 36-43. </type>
Reference-contexts: We are aiming for exact collision detection, at least to the resolution of the models and the input devices. Bounding box based algorithms <ref> [2, 19, 18] </ref>. These algorithms decompose the objects into tiny cubes (called voxels). Collision detection is done by finding objects with overlapping voxels. The collision accuracy in these techniques is not to the resolution of the models.
Reference: [3] <author> A. Appel and P. </author> <title> Will. "Determining the Three-Dimensional Convex Hull of a Polyhedron" IBM Journal of Research and Development, </title> <note> Nov. 1976 pp. 590-600. </note>
Reference-contexts: Computing a 3-dimensional cap for a general non-convex polygonal object is a difficult task. There has been some work done on computing 2-dimensional caps (caps for non-convex polygons) [22]. An O (n 3 ) algorithm for simple 3-dimensional objects was published <ref> [3] </ref>, but an efficient algorithm for the general problem would be a new research result. * The boundary loop of a concavity can be a 3-dimensional structure.
Reference: [4] <author> D. Baraff. </author> <title> "Curved surfaces and coherence for non-penetrating rigid body simulations" ACM Computer Graphics (1990) 24(4) </title> <type> 19-28. </type>
Reference-contexts: In computer graphics applications, where many objects are in motion, a dynamic approach would be better: Objects move only slightly from frame to frame and the collision detection scheme should take advantage of the previous frame's information to compute in the current frame whether objects intersect <ref> [4] </ref>. Several solutions based on this idea of coherence have been proposed. The one by Lin and Canny has been shown to be highly effective for convex polytopes [24]. Robotics literature deals with collision detection in the context of path planning. <p> These techniques exhibit poor performance times as the complexity of the models increase. Hence, they are unsuitable for complex simulations or interactive applications that we are consid ering. * Incremental algorithms for exact collision detection between pairs of convex polytopes <ref> [4, 24] </ref>. These ideas have been proven to be effective for convex models. We plan to extend these ideas to non-convex polygonal models. None of the algorithms in the state of the art describe an efficient collision detection method for general polygonal models in interactive environments. <p> The underlying assumption is that the time steps are small enough that the objects do not travel large distances between frames. In many situations, assuming coherence is reasonable <ref> [4, 30] </ref>. Further, its assumption can lead to highly efficient incremental algorithms [24, 30].
Reference: [5] <author> J. Boyse. </author> " <title> Interference Detection Among Solids and Surfaces" Communications of the ACM (1979) pp.3-9. </title>
Reference-contexts: Space subdivision methods become a bottleneck when the objects become non-uniformly distributed during the course of a simulation. In some sense, the algorithm we propose can be considered an adaptive space subdivision approach. * Exhaustive all possible feature pair testing algorithms <ref> [5, 26] </ref>. These techniques exhibit poor performance times as the complexity of the models increase. Hence, they are unsuitable for complex simulations or interactive applications that we are consid ering. * Incremental algorithms for exact collision detection between pairs of convex polytopes [4, 24].
Reference: [6] <author> J. Canny. </author> " <title> Collision Detection for Moving Polyhedra" IEEE Trans. </title> <journal> on Pattern Analysis and Machine Intelligence (1986) pp.200-209. </journal>
Reference-contexts: Robotics literature deals with collision detection in the context of path planning. Using sophisticated mathematical tools, several exponential running time algorithms have been developed that plan collision-free paths for a robot for restricted environments <ref> [6] </ref>. The exponential running time makes these algorithms impractical for complex simulated environments. Collision detection for multiple moving objects has recently become a popular research topic due to increased interest in large-scale environments. For example, the human participants may walk through a building where the tables, chairs, etc. remain stationary. <p> These algorithms are only for convex polytopes. They also do not address the problem of multiple objects moving simul taneously. * Collision-free path planning algorithms in robotics <ref> [6] </ref>. These algorithms expect motion as a closed form function of time, which is not possible in interactive environments where the user's behavior is unpredictable. * Approximate collision detection schemes. We are aiming for exact collision detection, at least to the resolution of the models and the input devices.
Reference: [7] <author> B. Chazelle and D. Dobkin. </author> <title> "Intersection of Convex Objects in Two and Three Dimensions" Journal of the ACM (January, </title> <year> 1987) </year> <month> pp.1-27. </month>
Reference-contexts: Many of the algorithms dealing with convex polytopes, although mathematically elegant, are extremely difficult to implement. The best known running time for detecting if two convex polytopes intersect is O (log 2 n), and it can be shown that the lower bound for this problem is O (log n) <ref> [7, 10] </ref>. This algorithm simply detects if there is an intersection, but does not explicitly construct the intersection region. Collision detection for objects constructed using Bezier patches, B-splines, NURBS, etc. falls generally into the approximate category [25]. <p> We summarize the algorithms from above in the state of the art as follows: * Computational geometry algorithms to solve static interference and intersection between pairs of convex polytopes <ref> [7, 9, 8] </ref>. These algorithms are only for convex polytopes. They also do not address the problem of multiple objects moving simul taneously. * Collision-free path planning algorithms in robotics [6].
Reference: [8] <author> B. Chazelle. </author> <title> "An Optimal Algorithm for Intersecting Three-Dimensional Convex Polyhedra" IEEE Symposium on Found. </title> <journal> of Comp. </journal> <note> Sci 30 (1989) pp.586-591. </note>
Reference-contexts: We summarize the algorithms from above in the state of the art as follows: * Computational geometry algorithms to solve static interference and intersection between pairs of convex polytopes <ref> [7, 9, 8] </ref>. These algorithms are only for convex polytopes. They also do not address the problem of multiple objects moving simul taneously. * Collision-free path planning algorithms in robotics [6]. <p> We plan to extend this result to determine the precise intersection points of the two convex objects (i.e. which caps are involved in the intersection). A coherence based algorithm to do this would also be a new result, because the existing results handle the static version of the problem <ref> [8] </ref>. If the convex hulls are intersecting, we enter another layer to determine exactly which 11 features are colliding. The collision between the objects' the convex hulls has three cases which can occur multiple times: 1. The collision is between convex feature sets on both the objects.
Reference: [9] <author> B. Chazelle and D. Dobkin. </author> <note> "Detection is Easier than Computation" Annual ACM Symposium on Theory of Computing (1980) pp.146-153. </note>
Reference-contexts: Each method makes specific assumptions about the environment and designs a solution around them. 3.1 Previous approaches Computational geometry literature has several references dealing with the intersection detection of convex polygons and their extension to 3-D, convex polytopes <ref> [9] </ref>. A convex polytope is the closed intersection of half-planes. For example, a cube with all six faces 3 is a convex polytope. However, a cube with one side or more missing is not a polytope since it is not "closed". <p> We summarize the algorithms from above in the state of the art as follows: * Computational geometry algorithms to solve static interference and intersection between pairs of convex polytopes <ref> [7, 9, 8] </ref>. These algorithms are only for convex polytopes. They also do not address the problem of multiple objects moving simul taneously. * Collision-free path planning algorithms in robotics [6].
Reference: [10] <author> D. Dobkin and D. Kirkpatrick. </author> <title> "Fast Detection of Polyhedral Intersection" Theoretical Computer Science (1983) pp.241-253. </title>
Reference-contexts: Many of the algorithms dealing with convex polytopes, although mathematically elegant, are extremely difficult to implement. The best known running time for detecting if two convex polytopes intersect is O (log 2 n), and it can be shown that the lower bound for this problem is O (log n) <ref> [7, 10] </ref>. This algorithm simply detects if there is an intersection, but does not explicitly construct the intersection region. Collision detection for objects constructed using Bezier patches, B-splines, NURBS, etc. falls generally into the approximate category [25].
Reference: [11] <author> P. Dworkin and D. Zeltzer. </author> <title> "Determining the separation of preprocessed polyhedra - a unified approach" Proceedings of the Fourth Eurographics Workshop on Animation and Simulation (1993). </title>
Reference: [12] <institution> I.Emiris and J.Canny "A general approach to removing degenracies" Proceedings of 32nd Annual Symp. Found. of Computer Science, </institution> <year> 1991, </year> <pages> pp. 405-413. </pages>
Reference-contexts: In addition to implementation difficulties, we expect to encounter robustness problems related to geometric and numeric degeneracies. Implementing geometric algorithms has been shown to be a difficult task because of the many degeneracies that can occur <ref> [12, 17] </ref>. Our implementation will not handle every type of degenerate input, but we plan to handle common ones and be aware of the implications of bad input. 6.1 Geometric Degeneracies Geometric degeneracies occur when the data specifying the geometry of the objects is flawed in some fashion. <p> The imprecise position location can lead to spurious collisions being detected. We plan to introduce tolerances and perturbations when doing numeric computations. The perturbation methods attempt to randomnly distribute degenerate data (such as coplanar vertices) by small perturbations of the original data <ref> [12] </ref>. These reduce the possibility of error but do not eliminate it [17]. We do not plan to deeply pursue numerical analysis of geometric algorithms. 16
Reference: [13] <author> M. Garey and D. Johnson. </author> <title> "Computers and Intractability" W.H. </title> <publisher> Freeman and company, </publisher> <address> New York (1979) </address>
Reference-contexts: This approach though differs from a convex decomposition of the objects and finding collisions between all convex sub-pieces. Convex decompositions are not good for several reasons: an optimal decomposition is NP-complete <ref> [13] </ref>; even a simple decomposition is expensive to compute; and a decomposition introduces many spurious edges and faces to an object. For each non-convex object, our technique begins by statically computing its convex hull and a hierarchical representation of each of its concavities.
Reference: [14] <author> E. Gilbert, D. Johnson and S. Keerthi. </author> <title> "A Fast Procedure for Computing the Minimum of a Quadratic Form on a Convex Set" IEEE J. </title> <booktitle> Robotics Automation vol.4 (1988) pp.193-203. </booktitle>
Reference-contexts: This method cannot deal with arbitrary non-convex polygonal models. It cannot construct a medial axis (an exact internal Voronoi region) for an arbitrary 3-D polygonal object, which it uses for collision detection. In such situations, it does only approximate collision detection. Root finding algorithms <ref> [14, 16] </ref>. These apply only to convex objects and these techniques do not generalize to non-convex polygonal models. * Space subdivision methods [32, 31]. These methods are targeted towards specific applications, such as molecular docking.
Reference: [15] <author> L. Greengard. </author> <title> "The Numerical Solution of the N-Body Problem" Computers in Physics, </title> <booktitle> 1990, </booktitle> <pages> pp. 143-152. 17 </pages>
Reference-contexts: Typically the number of collisions is linear in the number of objects involved, so an output sensitive algorithm that scales with the complexity of the problem is desirable. This multiple body problem is a simpler version of the "N-body" problem faced in gravitation and radiosity calculations <ref> [15] </ref>. In N-body calculations, an object is influenced 4 by other objects in the environment without being in contact with them. In our multiple body problem, objects alter each other's path only when they come in contact (either directly or indirectly through other objects).
Reference: [16] <author> E. Gilbert and C. Foo. </author> <title> "Computing the distance Between General Convex Objects in Three-Dimensional Space" IEEE Transactions on Robotics and Automation 6 (Febru-ary, </title> <year> 1990) </year> <month> pp.53-61. </month>
Reference-contexts: This method cannot deal with arbitrary non-convex polygonal models. It cannot construct a medial axis (an exact internal Voronoi region) for an arbitrary 3-D polygonal object, which it uses for collision detection. In such situations, it does only approximate collision detection. Root finding algorithms <ref> [14, 16] </ref>. These apply only to convex objects and these techniques do not generalize to non-convex polygonal models. * Space subdivision methods [32, 31]. These methods are targeted towards specific applications, such as molecular docking.
Reference: [17] <author> S. Fortune and C. van Wijk. </author> <booktitle> "Numerical stability of algorithms" 7th Annual ACM Symp. on Computational Geometry, </booktitle> <pages> pp. 334-341. </pages>
Reference-contexts: In addition to implementation difficulties, we expect to encounter robustness problems related to geometric and numeric degeneracies. Implementing geometric algorithms has been shown to be a difficult task because of the many degeneracies that can occur <ref> [12, 17] </ref>. Our implementation will not handle every type of degenerate input, but we plan to handle common ones and be aware of the implications of bad input. 6.1 Geometric Degeneracies Geometric degeneracies occur when the data specifying the geometry of the objects is flawed in some fashion. <p> However, we do not guarantee removing all types of errors in the data. 6.2 Numeric Degeneracies Input data that is free of geometric degeneracies can still run into numerical problems. Floating point computations for geometric algorithms are susceptible to numerical errors <ref> [17] </ref>. There are a number of situations where the collision detection algorithm can run into floating point problems: * Construction of the bounding box hierarchy. While grouping the faces into boxes, orthogonal cutting planes are used which cut the existing faces. <p> We plan to introduce tolerances and perturbations when doing numeric computations. The perturbation methods attempt to randomnly distribute degenerate data (such as coplanar vertices) by small perturbations of the original data [12]. These reduce the possibility of error but do not eliminate it <ref> [17] </ref>. We do not plan to deeply pursue numerical analysis of geometric algorithms. 16
Reference: [18] <author> J. Hahn. </author> <note> "Realistic Animation of Rigid Bodies" ACM SIGGRAPH 1988 pp. 299-308. </note>
Reference-contexts: We are aiming for exact collision detection, at least to the resolution of the models and the input devices. Bounding box based algorithms <ref> [2, 19, 18] </ref>. These algorithms decompose the objects into tiny cubes (called voxels). Collision detection is done by finding objects with overlapping voxels. The collision accuracy in these techniques is not to the resolution of the models. <p> The collision accuracy in these techniques is not to the resolution of the models. They also do not exploit the frame to frame coherence that exists in most graphics applications and as a result their published collision detection time is high <ref> [18] </ref>. 5 Sphere based algorithm [21]. This method cannot deal with arbitrary non-convex polygonal models. It cannot construct a medial axis (an exact internal Voronoi region) for an arbitrary 3-D polygonal object, which it uses for collision detection. In such situations, it does only approximate collision detection.
Reference: [19] <author> B. Herzen, A. Barr and H. Zatz. </author> <title> "Geometric collisions for time-dependent parametric surfaces" Computer Graphics (1990) 24(4) </title> <type> 30-48. </type>
Reference-contexts: We are aiming for exact collision detection, at least to the resolution of the models and the input devices. Bounding box based algorithms <ref> [2, 19, 18] </ref>. These algorithms decompose the objects into tiny cubes (called voxels). Collision detection is done by finding objects with overlapping voxels. The collision accuracy in these techniques is not to the resolution of the models.
Reference: [20] <author> J.E. </author> <title> Hopcroft. </title> <journal> "Electronic Prototyping" IEEE Transactions on Aerospace and Electronic Systems, </journal> <volume> Vol. 24 (2): </volume> <pages> 663-667. </pages>
Reference-contexts: Simulations of physical systems have similar requirements in terms of collision detection. A simulation of an experiment that is too costly or impractical to build can be a significant aid in the experimental process. A threaded screw insertion [28], an automobile crash test <ref> [20] </ref>, or a building demolition [20] are potential examples of where a simulation of the events is useful. However, for such simulations to be of use, they need to model the dynamic interactions of the experiment with a degree of realism. <p> Simulations of physical systems have similar requirements in terms of collision detection. A simulation of an experiment that is too costly or impractical to build can be a significant aid in the experimental process. A threaded screw insertion [28], an automobile crash test <ref> [20] </ref>, or a building demolition [20] are potential examples of where a simulation of the events is useful. However, for such simulations to be of use, they need to model the dynamic interactions of the experiment with a degree of realism. <p> However, for such simulations to be of use, they need to model the dynamic interactions of the experiment with a degree of realism. Collision detection has been identified as a major component of the interactions in these simulations <ref> [28, 20] </ref>, so efficiently dealing with it would have practical implications. We claim interactive applications and simulations of physical systems are representative of a large class of simulated environment based applications. As a result, any techniques developed to enhance their performance are widely applicable.
Reference: [21] <author> P. Hubbard. </author> <title> "Interactive collision detection" Proceedings of IEEE Symposium on Research Frontiers in Virtual Reality (1993) October. </title>
Reference-contexts: Space is partitioned into cells, and objects sharing the same cells are tested for intersection. There has been work that uses a combination of all these approaches. One recent approach by Hubbard trades time for accuracy <ref> [21] </ref>. The fundamental problem with this approach is that exact collision points are almost never computed. <p> The collision accuracy in these techniques is not to the resolution of the models. They also do not exploit the frame to frame coherence that exists in most graphics applications and as a result their published collision detection time is high [18]. 5 Sphere based algorithm <ref> [21] </ref>. This method cannot deal with arbitrary non-convex polygonal models. It cannot construct a medial axis (an exact internal Voronoi region) for an arbitrary 3-D polygonal object, which it uses for collision detection. In such situations, it does only approximate collision detection. Root finding algorithms [14, 16]. <p> Success on these datasets will ensure that the ideas are generally applicable. In addition to demonstrations, we plan to make performance measurements. We will make direct comparisons to relevant work such as by Philip Hubbard <ref> [21] </ref> and others. 4.2 Contributions The main contribution is an incremental-computation based collision detection algorithm to compute exact contact points between non-convex polygonal models.
Reference: [22] <author> P. Loutrel. </author> <title> "Determination of Hidden Edges in Polyhedral Figures" Tech Report 400-145, </title> <institution> Dept. of EE, </institution> <address> New York University, </address> <month> September </month> <year> 1966. </year>
Reference-contexts: Computing a 3-dimensional cap for a general non-convex polygonal object is a difficult task. There has been some work done on computing 2-dimensional caps (caps for non-convex polygons) <ref> [22] </ref>. An O (n 3 ) algorithm for simple 3-dimensional objects was published [3], but an efficient algorithm for the general problem would be a new research result. * The boundary loop of a concavity can be a 3-dimensional structure.
Reference: [23] <author> M. Lin, D. Manocha, and M. </author> <title> Ponamgi "Fast algorithms for penetration and contact determination between non-convex polyhedral models" Submitted for publication, </title> <month> September, </month> <year> 1994. </year>
Reference-contexts: Further, its assumption can lead to highly efficient incremental algorithms [24, 30]. The worst case running time for these algorithms is still O (n 2 ) where n is the number of features involved, but evidence suggests this case rarely occurs <ref> [30, 24, 23] </ref>. 6 Using coherence as our central theme, we present an incremental algorithm for collision detection between non-convex polygonal objects. The algorithm description consists of three phases: pre-processing, contact determination algorithm, and implementation. There are several new computational problems that are addressed in the pre-processing stage. <p> If the bounding volumes are overlapping, we check to see whether the objects' convex hulls are intersecting. Detecting when two convex polygonal objects are intersecting using a coherence based method is a new result of ours <ref> [23] </ref>. In the previous Lin-Canny algorithm [24], the exterior of the polytope was partitioned. Then an algorithm to "walk" across the the features of the polytopes was defined that computes the closest features between the objects as long as they are not intersecting.
Reference: [24] <author> M. Lin. </author> <title> "Efficient Collision Detection for Animation and Robotics" PhD Thesis, </title> <institution> University of California at Berkeley, </institution> <month> December </month> <year> 1992. </year> <institution> Department of Electrical Engineering and Computer Science. </institution>
Reference-contexts: Several solutions based on this idea of coherence have been proposed. The one by Lin and Canny has been shown to be highly effective for convex polytopes <ref> [24] </ref>. Robotics literature deals with collision detection in the context of path planning. Using sophisticated mathematical tools, several exponential running time algorithms have been developed that plan collision-free paths for a robot for restricted environments [6]. The exponential running time makes these algorithms impractical for complex simulated environments. <p> These techniques exhibit poor performance times as the complexity of the models increase. Hence, they are unsuitable for complex simulations or interactive applications that we are consid ering. * Incremental algorithms for exact collision detection between pairs of convex polytopes <ref> [4, 24] </ref>. These ideas have been proven to be effective for convex models. We plan to extend these ideas to non-convex polygonal models. None of the algorithms in the state of the art describe an efficient collision detection method for general polygonal models in interactive environments. <p> The underlying assumption is that the time steps are small enough that the objects do not travel large distances between frames. In many situations, assuming coherence is reasonable [4, 30]. Further, its assumption can lead to highly efficient incremental algorithms <ref> [24, 30] </ref>. <p> Further, its assumption can lead to highly efficient incremental algorithms [24, 30]. The worst case running time for these algorithms is still O (n 2 ) where n is the number of features involved, but evidence suggests this case rarely occurs <ref> [30, 24, 23] </ref>. 6 Using coherence as our central theme, we present an incremental algorithm for collision detection between non-convex polygonal objects. The algorithm description consists of three phases: pre-processing, contact determination algorithm, and implementation. There are several new computational problems that are addressed in the pre-processing stage. <p> If the bounding volumes are overlapping, we check to see whether the objects' convex hulls are intersecting. Detecting when two convex polygonal objects are intersecting using a coherence based method is a new result of ours [23]. In the previous Lin-Canny algorithm <ref> [24] </ref>, the exterior of the polytope was partitioned. Then an algorithm to "walk" across the the features of the polytopes was defined that computes the closest features between the objects as long as they are not intersecting.
Reference: [25] <author> M. Lin and D. Manocha. </author> <title> "Interference detection between curved objects for computer animation" Models and Techniques in Computer Animation (1993) pp. </title> <type> 43-57. </type>
Reference-contexts: This algorithm simply detects if there is an intersection, but does not explicitly construct the intersection region. Collision detection for objects constructed using Bezier patches, B-splines, NURBS, etc. falls generally into the approximate category <ref> [25] </ref>. Finding exact collisions between objects modeled out of patches is equivalent to finding whether two functions intersect. If we assume the function determining the intersection is a polynomial, the closed form solution can be found only if its degree is strictly less than five.
Reference: [26] <author> M. Moore, J. Wilhelms. </author> <title> "Collision Detection and Response for Computer Animation" ACM SIGGRAPH (1988) pp. </title> <type> 289-298. </type>
Reference-contexts: Space subdivision methods become a bottleneck when the objects become non-uniformly distributed during the course of a simulation. In some sense, the algorithm we propose can be considered an adaptive space subdivision approach. * Exhaustive all possible feature pair testing algorithms <ref> [5, 26] </ref>. These techniques exhibit poor performance times as the complexity of the models increase. Hence, they are unsuitable for complex simulations or interactive applications that we are consid ering. * Incremental algorithms for exact collision detection between pairs of convex polytopes [4, 24].
Reference: [27] <author> J. Nevins and D. Whitney. </author> <title> "Concurrent Design of Products and Processes" New York, </title> <publisher> McGraw-Hill 1989. </publisher>
Reference: [28] <author> E. Nicolson and R. Fearing. </author> <title> "Compliant Control of Threaded Fastner Insertion" Int. </title> <booktitle> Conf. on Intelligent Robots and Systems, </booktitle> <address> Osaka, Japan, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Simulations of physical systems have similar requirements in terms of collision detection. A simulation of an experiment that is too costly or impractical to build can be a significant aid in the experimental process. A threaded screw insertion <ref> [28] </ref>, an automobile crash test [20], or a building demolition [20] are potential examples of where a simulation of the events is useful. However, for such simulations to be of use, they need to model the dynamic interactions of the experiment with a degree of realism. <p> However, for such simulations to be of use, they need to model the dynamic interactions of the experiment with a degree of realism. Collision detection has been identified as a major component of the interactions in these simulations <ref> [28, 20] </ref>, so efficiently dealing with it would have practical implications. We claim interactive applications and simulations of physical systems are representative of a large class of simulated environment based applications. As a result, any techniques developed to enhance their performance are widely applicable.
Reference: [29] <author> J. O'Rourke. </author> <note> Computational Geometry in C Cambridge University Press, </note> <year> 1994. </year>
Reference-contexts: Problems with coplanar vertices, narrow faces, nested rings, etc. make it a difficult problem. The problem can be compared to computing convex hulls since the caps represent the portions "missing" from an object to make it convex. This problem has been shown to be quite difficult to implement <ref> [29] </ref>. We have implemented an O (n log n) cap computation technique that handles simple 3-dimensional loops with no holes. The idea uses Meister's theorem to compute a cap by 10 triangulating its boundary region [29]. <p> This problem has been shown to be quite difficult to implement <ref> [29] </ref>. We have implemented an O (n log n) cap computation technique that handles simple 3-dimensional loops with no holes. The idea uses Meister's theorem to compute a cap by 10 triangulating its boundary region [29]. Subtracting the original faces of the object from the convex hull we can construct the caps in a more efficient manner. An efficient cap computation is necessary, because if the collision response is a deformation, the cap needs to be recomputed. <p> This affects the feature classification algorithm and leads to missed collisions. * Co-planar polygons. In several parts of the overall algorithm, we make use of the convex hull of an object. It is a well-known problem that taking the convex hull of co-planar faces (hence vertices) causes numerical problems <ref> [29] </ref>. * Backfacing polygons. The Voronoi cone data structure for the external and internal walk used in the penetration detection phase breaks down in the presence of backfacing polygons. * T-vertices.
Reference: [30] <author> J. Cohen, M. Lin, D. Manocha, and M. Ponamgi. </author> <title> "Exact Collision Detection for Multi-Body Environments" Symposium on Interactive 3-D Graphics, </title> <address> Monterey, CA, </address> <month> April </month> <year> 1995. </year> <month> 18 </month>
Reference-contexts: Objects are surrounded by tight fitting bounding volumes. If the volumes overlap, indicating that the objects are near each other, a more precise collision test is computed. The precise collision detection algorithms generally deal with collision detection between convex polytopes <ref> [30] </ref>. The bounding volume approach is frequently used to deal with non-convex objects as well. An object is broken down into convex pieces, and some type of a hierarchical structure is constructed out of the sub-pieces. <p> The underlying assumption is that the time steps are small enough that the objects do not travel large distances between frames. In many situations, assuming coherence is reasonable <ref> [4, 30] </ref>. Further, its assumption can lead to highly efficient incremental algorithms [24, 30]. <p> The underlying assumption is that the time steps are small enough that the objects do not travel large distances between frames. In many situations, assuming coherence is reasonable [4, 30]. Further, its assumption can lead to highly efficient incremental algorithms <ref> [24, 30] </ref>. <p> Further, its assumption can lead to highly efficient incremental algorithms [24, 30]. The worst case running time for these algorithms is still O (n 2 ) where n is the number of features involved, but evidence suggests this case rarely occurs <ref> [30, 24, 23] </ref>. 6 Using coherence as our central theme, we present an incremental algorithm for collision detection between non-convex polygonal objects. The algorithm description consists of three phases: pre-processing, contact determination algorithm, and implementation. There are several new computational problems that are addressed in the pre-processing stage. <p> Our approach to collision detection for non-convex objects builds on our previous work for multiple moving objects <ref> [30] </ref>. There we presented a scheme for efficient collision detection for hundreds of moving complex convex objects. The goal is to apply a similar technique again, treating a pair of non-convex objects as many convex objects interacting. <p> For each non-convex object, our technique begins by statically computing its convex hull and a hierarchical representation of each of its concavities. During the dynamic phase we use our previous work to determine when pairs of convex hulls are interacting <ref> [30] </ref>. Using an extension of this work, we determine when and where the convex regions of a pair of hulls are intersecting. Using these regions, we use the hierarchical representation of each polytope to find the exact contact points. <p> The penetration status of a pair of non-convex objects is determined by a hierarchical algorithm. Initially, using the result of our earlier algorithm <ref> [30] </ref>, we determine if the bounding volumes surrounding a pair of objects are overlapping. If the bounding volumes are overlapping, we check to see whether the objects' convex hulls are intersecting. <p> Because the penetrating object is also represented as a hierarchy of bounding boxes, our goal is to efficiently traverse the two hierarchies and determine exact collision points between the two non-convex objects. We do this by re-applying the Sweep and Prune algorithm from <ref> [30] </ref> on the hierarchies. Initially, we begin with the roots of the hierarchies and determine which of the children overlap. Determining overlap status is done via sorting the bounding boxes as described in the Sweep and Prune algorithm.
Reference: [31] <author> J. Snyder, A. Woodbury, K. Fleischer, B. Currin, and A. Barr. </author> <title> "Set operations on polyhedra using binary space partitioning trees" ACM Computer Graphics (1987) vol. </title> <type> 4. </type>
Reference-contexts: The approximating volumes are refined to the resolution desired, and if at the final level they overlap, a collision is indicated. Methods based on "interval arithmetic" take a similar approach in finding iterative solutions; they solve constrained minimization problems to determine areas of contact <ref> [31] </ref>. Most computational geometry literature deals with collision detection (often referred to as interference detection) of objects in a static frame. Objects are at a fixed location and orientation, and the algorithms determine whether they are interfering. <p> To determine whether two non-convex objects intersect, the hierarchy is efficiently traversed and collision detection between the convex sub-pieces is computed. Using techniques similar to these, space partitioning has also been used to deal with multiple objects <ref> [31] </ref>. Space is partitioned into cells, and objects sharing the same cells are tested for intersection. There has been work that uses a combination of all these approaches. One recent approach by Hubbard trades time for accuracy [21]. <p> In such situations, it does only approximate collision detection. Root finding algorithms [14, 16]. These apply only to convex objects and these techniques do not generalize to non-convex polygonal models. * Space subdivision methods <ref> [32, 31] </ref>. These methods are targeted towards specific applications, such as molecular docking. Space subdivision methods become a bottleneck when the objects become non-uniformly distributed during the course of a simulation.
Reference: [32] <author> G. Turk. </author> <title> "Interactive collision detection for molecular graphics" Master's thesis, </title> <institution> Computer Science Department, University of North Carolina at Chapel Hill (1989). </institution> <month> 19 </month>
Reference-contexts: In such situations, it does only approximate collision detection. Root finding algorithms [14, 16]. These apply only to convex objects and these techniques do not generalize to non-convex polygonal models. * Space subdivision methods <ref> [32, 31] </ref>. These methods are targeted towards specific applications, such as molecular docking. Space subdivision methods become a bottleneck when the objects become non-uniformly distributed during the course of a simulation.
References-found: 32

