URL: http://www.cs.cmu.edu/afs/cs/user/nch/ftp/sba.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/nch/www/sba.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Set-Based Program Analysis (Extended Abstract) Summary program variables are associated with sets of values. Further,
Author: Nevin Heintze and Joxan Jaffar 
Address: Pittsburgh, PA 15213-3890.  PO Box 704, Yorktown Heights, NY 10598.  
Affiliation: School of Computer Science, Carnegie Mellon University,  IBM Thomas J. Watson Research Center,  
Note: Starting with the collecting semantics of a program, it is shown that there is a natural formalization of this approximation in which  
Date: 1 January 1991  
Abstract: Program analysis involves approximating the semantics of programs. One important kind of approximation, that of ignoring intervariable dependencies, is widely used for reasons of decidability and efficiency. This paper addresses program analysis wherein ignoring intervariable dependencies is the only kind of approximation used. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> S. Abramsky and C. Hankin (Eds.), </editor> <title> Abstract Interpretation of Declarative Languages, </title> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: The present paper, in contrast, is based upon a general formalism for collecting semantics, and hence can also be used for top-down execution strategies. Consequently the present algorithm is more general. In abstract interpretation <ref> [1] </ref> approximation is typically formalized by means of a semantic function describing single step approximate computation. The least fixpoint gives the approximate semantics (see, for example, [4] and [5]), and so program analysis reduces to iterative fixpoint computation.
Reference: [2] <author> M. Bruynooghe and G. Janssens, </author> <title> "An Instance of Abstract Interpretation integrating Type and Mode Inference", </title> <booktitle> Proceedings 5 th Int. Conf. on Logic Programming, </booktitle> <editor> K.A. Bowen and R.A. Kowalski (eds), </editor> <publisher> MIT Press, </publisher> <pages> pp 669 - 683, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: For example, while the our algorithm reasons exactly on the class of monadic logic programs, no abstract interpretation algorithm can. Note that abstract interpretation approaches typically ignore intervariable dependencies, in addition to making other approximations, for efficiency reasons (see for example <ref> [2, 3] </ref>). 1.2 Preliminary Definitions The domain of computation is a Herbrand Universe with functors hereafter denoted by small letters, and 1 containing the projections of : ff 1 (i) : f is an n-ary symbol from , 1 i ng.
Reference: [3] <author> S.K. Debray, </author> <title> "Global Optimization of Logic Programs", </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, SUNY at Stony Brook, </institution> <address> 233 pages, </address> <month> December </month> <year> 1986. </year>
Reference-contexts: For example, while the our algorithm reasons exactly on the class of monadic logic programs, no abstract interpretation algorithm can. Note that abstract interpretation approaches typically ignore intervariable dependencies, in addition to making other approximations, for efficiency reasons (see for example <ref> [2, 3] </ref>). 1.2 Preliminary Definitions The domain of computation is a Herbrand Universe with functors hereafter denoted by small letters, and 1 containing the projections of : ff 1 (i) : f is an n-ary symbol from , 1 i ng.
Reference: [4] <author> P. Cousot and R. Cousot, </author> <title> "Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints", </title> <booktitle> Proceedings 4 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977, </year> <pages> pp 238 - 252. </pages>
Reference-contexts: Consequently the present algorithm is more general. In abstract interpretation [1] approximation is typically formalized by means of a semantic function describing single step approximate computation. The least fixpoint gives the approximate semantics (see, for example, <ref> [4] </ref> and [5]), and so program analysis reduces to iterative fixpoint computation. Such an approach is not applicable in this paper because the appropriate semantic function does not converge. For example, while the our algorithm reasons exactly on the class of monadic logic programs, no abstract interpretation algorithm can.
Reference: [5] <author> P. Cousot and R. Cousot, </author> <title> "Systematic Design of Program Analysis Frameworks", </title> <booktitle> Proceedings 6 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1979, </year> <pages> pp 269 - 282. </pages>
Reference-contexts: Consequently the present algorithm is more general. In abstract interpretation [1] approximation is typically formalized by means of a semantic function describing single step approximate computation. The least fixpoint gives the approximate semantics (see, for example, [4] and <ref> [5] </ref>), and so program analysis reduces to iterative fixpoint computation. Such an approach is not applicable in this paper because the appropriate semantic function does not converge. For example, while the our algorithm reasons exactly on the class of monadic logic programs, no abstract interpretation algorithm can.
Reference: [6] <author> F. Gecseg and M. Steinby, </author> <title> "Tree Automata", </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: In each iteration, a collection ESC of explicit constraints is extracted from the current set constraints SC. REDUCE is then applied on SC and ESC to obtain new set constraints for the next iteration. 11 This explicit representation consists of a regular set of terms <ref> [6] </ref> for each variable at hand. 12 input an imperative or logic program P ; obtain the environment constraints EC P of P ; obtain the set constraints SC P from EC P ; i := 0; repeat ESC i+1 := explicit (SC i ); SC i+1 := REDUCE (SC i
Reference: [7] <author> N.C. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <booktitle> Proceedings 17 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990, </year> <pages> pp 197 - 209. </pages>
Reference-contexts: However, their algorithms are considerably simpler, though less accurate, than the one presented in this paper. In logic programming, the notion of program approximation has been used to formalize types [13]. Here, superset approximations of a program's least model were sought. In <ref> [7] </ref>, where the focus was program analysis and not types, the notion of set-based models was introduced, and it was shown that the resulting program approximation was both more accurate and decidable. The logic programming aspect of the present paper advances this work significantly. In [7] program approximation was defined in <p> In <ref> [7] </ref>, where the focus was program analysis and not types, the notion of set-based models was introduced, and it was shown that the resulting program approximation was both more accurate and decidable. The logic programming aspect of the present paper advances this work significantly. In [7] program approximation was defined in terms of the immediate consequence operator, and hence was limited to the approximation of bottom-up program execution. It is, for example, not applicable for the analysis of procedure calls in a top-down execution.
Reference: [8] <author> N.C. Heintze and J. Jaffar, </author> <title> "A Decision Procedure for a Class of Herbrand Set Constraints", </title> <booktitle> Proceedings 5 th IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp 42 - 51. </pages>
Reference-contexts: In each transformation step SC =) SC 0 , a 11 condition on explicit (SC) must be satisfied before the step is applied. Thus some key subroutines of the algorithm are for reasoning about explicit constraints. These subroutines can be adapted from <ref> [8] </ref> which contained an algorithm to construct a representation 11 of the least model of given explicit constraints. Let SC denote the conjunction of set constraints at hand.
Reference: [9] <author> Jaffar, J. and Lassez, J-L. </author> <title> "Constraint Logic Programming", </title> <type> Technical Report 86/73, </type> <institution> Dept. of Computer Science, </institution> <address> Monash University (June 1986). </address> <booktitle> [An abstract appears in the Proceedings 14 th ACM Symposium on Principles of Programming Languages, Munich (Jan-uary 1987), </booktitle> <pages> 111-119.] </pages>
Reference-contexts: Before defining the collecting semantics for logic programs, we use the terminology of CLP <ref> [9] </ref> and recall some basic definitions. A goal is of the form (C; G) where C is a satisfiable conjunction of term equations, and G is a finite sequence of atoms.
Reference: [10] <editor> N.D. Jones and S.S. Muchnick, </editor> <title> "Flow Analysis and Optimization of LISP-like Structures", </title> <booktitle> Proceedings 6 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1979, </year> <pages> pp 244 - 256. </pages>
Reference-contexts: In what follows, both the imperative and logic programming paradigms are considered to emphasize the generality of the result. 1.1 Related Work The early works [14], <ref> [10] </ref> and [12] use set formulas on imperative and functional programs to conservatively estimate variable values.
Reference: [11] <editor> N.D. Jones and S.S. Muchnick, </editor> <title> "Complexity of Flow Analysis, Inductive Assertion Synthesis, and a Language due to Dijkstra", </title> <booktitle> Proceedings 21 st Conference on Foundations of Computer Science, </booktitle> <year> 1980, </year> <pages> pp 185 - 190, </pages> <note> also in, Program Flow Analysis: Theory and Applications, N.D. </note> <editor> Jones and S.S. Muchnick (eds), </editor> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: For decidability reasons, program analyzers must limit their reasoning about intervari-able dependencies. For efficiency reasons, analyzers often completely omit reasoning about intervariable dependencies <ref> [11] </ref>. This is in addition to making other approximations. What has not been addressed is whether or not program analysis is decidable when ignoring intervariable dependencies is the only approximation used.
Reference: [12] <editor> N.D. Jones and S.S. Muchnick, </editor> <title> "A Flexible Approach to Interprocedural Dataflow Analysis and Programs with Recursive Data Structures", </title> <booktitle> Proceedings 9 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982, </year> <pages> pp 244 - 256. </pages>
Reference-contexts: In what follows, both the imperative and logic programming paradigms are considered to emphasize the generality of the result. 1.1 Related Work The early works [14], [10] and <ref> [12] </ref> use set formulas on imperative and functional programs to conservatively estimate variable values. In addition to the approximation of ignoring 2 intervariable dependencies, these formulas omit other information (such as that contained in if-then conditions), and the algorithms do not accommodate the notion of intersection between set expressions.
Reference: [13] <editor> F. Pfenning (Ed.), </editor> <booktitle> Types in Logic Programming, MIT Press Series in Logic Programming, </booktitle> <year> 1991, </year> <month> forthcoming. </month>
Reference-contexts: Consequently, it is not clear how to relate these formulas with an independent definition of approximate semantics. However, their algorithms are considerably simpler, though less accurate, than the one presented in this paper. In logic programming, the notion of program approximation has been used to formalize types <ref> [13] </ref>. Here, superset approximations of a program's least model were sought. In [7], where the focus was program analysis and not types, the notion of set-based models was introduced, and it was shown that the resulting program approximation was both more accurate and decidable.
Reference: [14] <author> J.C. Reynolds, </author> <title> "Automatic Computation of Data Set Definitions", </title> <booktitle> Information Processing 68, </booktitle> <publisher> North-Holland, </publisher> <year> 1969, </year> <pages> pp 456 - 461. </pages>
Reference-contexts: In what follows, both the imperative and logic programming paradigms are considered to emphasize the generality of the result. 1.1 Related Work The early works <ref> [14] </ref>, [10] and [12] use set formulas on imperative and functional programs to conservatively estimate variable values.
References-found: 14

