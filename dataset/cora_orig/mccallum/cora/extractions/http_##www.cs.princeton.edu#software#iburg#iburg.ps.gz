URL: http://www.cs.princeton.edu/software/iburg/iburg.ps.gz
Refering-URL: http://www.cs.princeton.edu/software/iburg/
Root-URL: http://www.cs.princeton.edu
Title: Engineering a Simple, Efficient Code Generator Generator  
Author: CHRISTOPHER W. FRASER DAVID R. HANSON TODD A. PROEBSTING 
Keyword: Categories and Subject Descriptors: D.3.4 [Programming Languages]: Processors code generation, compilers, translator writing systems and compiler generators General terms: Languages Additional Key Words and Phrases: code generation, code generator generator, dynamic programming, tree pattern matching, Icon programming language  
Note: a  
Affiliation: AT&T Bell Laboratories and  Princeton University and  The University of Arizona a  
Abstract: Many code generator generators use tree pattern matching and dynamic programming. This note describes a simple program that generates matchers that are fast, compact, and easy to understand. It is simpler than common alternatives: 200-700 lines of Icon or 950 lines of C versus 3000 lines of C for Twig and 5000 for burg. Its matchers run up to 25 times faster than Twig's. They are necessarily slower than burg's BURS (bottom-up rewrite system) matchers but they are more flexible and still practical. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A. V., and Corasick, M. J. </author> <title> Efficient string matching: An aid to bibliographic search. </title> <journal> Communications of the ACM 18, </journal> <month> 6 (June </month> <year> 1975), </year> <pages> 333-340. </pages>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. 2 dynamic programming at compile time to identify a minimum-cost cover. Twig matchers use a table-driven variant of string matching <ref> [1, 15] </ref> that, in essence, identifies all possible matches at the same time. This algorithm is asymptotically better than trying each possible match one at a time, but overhead is higher. <p> Even with the 7 int state (int op, int left, int right) - int c; struct state *l = (struct state *)left, *r = (struct state *)right, *p; p = malloc (sizeof *p); p-&gt;op = op; p-&gt;left = l; p-&gt;right = r; p-&gt;rule <ref> [1] </ref> = ... = 0; p-&gt;cost [1] = ... = 32767; switch (op) - case ADDI: if (l-&gt;rule [reg_NT] && r-&gt;rule [rc_NT) - c = l-&gt;cost [reg_NT] + r-&gt;cost [rc_NT] + 1; record (p, reg_NT, c, 6); record (p, rc_NT, c + 0, 13); record (p, stmt_NT, c + 0, 5); <p> Even with the 7 int state (int op, int left, int right) - int c; struct state *l = (struct state *)left, *r = (struct state *)right, *p; p = malloc (sizeof *p); p-&gt;op = op; p-&gt;left = l; p-&gt;right = r; p-&gt;rule <ref> [1] </ref> = ... = 0; p-&gt;cost [1] = ... = 32767; switch (op) - case ADDI: if (l-&gt;rule [reg_NT] && r-&gt;rule [rc_NT) - c = l-&gt;cost [reg_NT] + r-&gt;cost [rc_NT] + 1; record (p, reg_NT, c, 6); record (p, rc_NT, c + 0, 13); record (p, stmt_NT, c + 0, 5); - if (l-&gt;rule [reg_NT] && r-&gt;rule
Reference: 2. <author> Aho, A. V., Ganapathi, M., and Tjiang, S. W. K. </author> <title> Code generation using tree matching and dynamic programming. </title> <journal> ACM Transactions on Programming Languages and Systems 11, </journal> <month> 4 (Oct. </month> <year> 1989), </year> <pages> 491-516. </pages>
Reference-contexts: The first pass is bottom up and finds a set of patterns that cover the tree with minimum cost. The second pass executes the semantic actions associated with minimum-cost patterns at the nodes they matched. Code generator generators based on this model include BEG [7], Twig <ref> [2] </ref>, and burg [13]. BEG matchers are hard-coded and mirror the tree patterns in the same way that recursive-descent parsers mirror their input grammars. They use a Authors' addresses: C. W. Fraser, AT&T Bell Laboratories, 600 Mountain Avenue 2C-464, Mur-ray Hill, NJ 07974-0636; D. R.
Reference: 3. <author> Aho, A. V., and Johnson, S. C. </author> <title> Optimal code generation for expression trees. </title> <journal> Journal of the ACM 23, </journal> <month> 3 (July </month> <year> 1976), </year> <pages> 488-501. </pages>
Reference-contexts: 1. INTRODUCTION Many code generator generators use tree pattern matching and dynamic programming (DP) <ref> [3, 4, 8] </ref>. They accept tree patterns and associated costs and semantic actions that, for example, allocate registers and emit object code. They produce tree matchers that make two passes over each subject tree.
Reference: 4. <author> Aho, A. V., Sethi, R., and Ullman, J. D. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: 1. INTRODUCTION Many code generator generators use tree pattern matching and dynamic programming (DP) <ref> [3, 4, 8] </ref>. They accept tree patterns and associated costs and semantic actions that, for example, allocate registers and emit object code. They produce tree matchers that make two passes over each subject tree.
Reference: 5. <author> Balachandran, A., Dhamdhere, D. M., and Bis was, S. </author> <title> Efficient retargetable code generation using bottom-up tree pattern matching. </title> <journal> Journal of Computer Languages 15, </journal> <volume> 3 (1990), </volume> <pages> 127-140. </pages>
Reference-contexts: This algorithm is asymptotically better than trying each possible match one at a time, but overhead is higher. Like BEG matchers, Twig matchers use DP at compile time to identify a minimum-cost cover. burg uses BURS (bottom-up rewrite system) theory <ref> [5, 6, 17, 18] </ref> to move the DP to compile-compile time. BURS table generation is more complicated, but BURS matchers generate optimal code in constant time per node. <p> The rules show that ADDI and ASGNI are binary, CVCI and INDIRC are unary, and ADDRLP, CNSTI, and I0I are leaves. 4 ASGNI ADDRLP i ADDI CVCI INDIRC ADDRLP c CNSTI 4 (11, 0) <ref> [5, 1+0=1] </ref> (11, 0) [5, 1+0=1] (7, 0+1=1) [13, 1+0=1] [5, 2+0=2] (10, 1+0+0=1) (14, 0) disp: ADDRLP reg: disp stmt: reg rc: reg reg: ADDI (rec,rc) stmt: reg rc: reg disp: ADDI (reg,con) stmt: ASGNI (disp,reg) reg: CVCI (INDIRC (disp)) stmt: reg rc: reg con: CNSTI rc: con disp: ADDRLP <p> The rules show that ADDI and ASGNI are binary, CVCI and INDIRC are unary, and ADDRLP, CNSTI, and I0I are leaves. 4 ASGNI ADDRLP i ADDI CVCI INDIRC ADDRLP c CNSTI 4 (11, 0) <ref> [5, 1+0=1] </ref> (11, 0) [5, 1+0=1] (7, 0+1=1) [13, 1+0=1] [5, 2+0=2] (10, 1+0+0=1) (14, 0) disp: ADDRLP reg: disp stmt: reg rc: reg reg: ADDI (rec,rc) stmt: reg rc: reg disp: ADDI (reg,con) stmt: ASGNI (disp,reg) reg: CVCI (INDIRC (disp)) stmt: reg rc: reg con: CNSTI rc: con disp: ADDRLP reg: disp stmt: reg <p> The rules show that ADDI and ASGNI are binary, CVCI and INDIRC are unary, and ADDRLP, CNSTI, and I0I are leaves. 4 ASGNI ADDRLP i ADDI CVCI INDIRC ADDRLP c CNSTI 4 (11, 0) [5, 1+0=1] (11, 0) [5, 1+0=1] (7, 0+1=1) [13, 1+0=1] <ref> [5, 2+0=2] </ref> (10, 1+0+0=1) (14, 0) disp: ADDRLP reg: disp stmt: reg rc: reg reg: ADDI (rec,rc) stmt: reg rc: reg disp: ADDI (reg,con) stmt: ASGNI (disp,reg) reg: CVCI (INDIRC (disp)) stmt: reg rc: reg con: CNSTI rc: con disp: ADDRLP reg: disp stmt: reg rc: reg Fig. 3.
Reference: 6. <author> Chase, D. R. </author> <title> An improvement to bottom-up tree pattern matching. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages (Munich, </booktitle> <month> Jan. </month> <year> 1987), </year> <pages> pp. 168-177. </pages>
Reference-contexts: This algorithm is asymptotically better than trying each possible match one at a time, but overhead is higher. Like BEG matchers, Twig matchers use DP at compile time to identify a minimum-cost cover. burg uses BURS (bottom-up rewrite system) theory <ref> [5, 6, 17, 18] </ref> to move the DP to compile-compile time. BURS table generation is more complicated, but BURS matchers generate optimal code in constant time per node. <p> It generates hard code instead of tables. Its "state numbers" are pointers to state records, which hold vectors of the (M; C) values for successful matches. The state record for the specification in Figure 2 is struct state - int op; struct state *left, *right; short cost <ref> [6] </ref>; short rule [6]; -; 6 iburg also generates integer codes for the non-terminals, which index the cost and rule vectors: #define stmt_NT 1 #define disp_NT 2 #define rc_NT 3 #define reg_NT 4 #define con_NT 5 By convention, the start non-terminal has value 1. <p> Its "state numbers" are pointers to state records, which hold vectors of the (M; C) values for successful matches. The state record for the specification in Figure 2 is struct state - int op; struct state *left, *right; short cost <ref> [6] </ref>; short rule [6]; -; 6 iburg also generates integer codes for the non-terminals, which index the cost and rule vectors: #define stmt_NT 1 #define disp_NT 2 #define rc_NT 3 #define reg_NT 4 #define con_NT 5 By convention, the start non-terminal has value 1. <p> Definitions can be mapped into a compact range of integers and stored in minimum space in state records as bit fields, e.g., struct state - int op; struct state *left, *right; short cost <ref> [6] </ref>; struct - unsigned int stmt:2; unsigned int disp:2; unsigned int rc:2; unsigned int reg:3; unsigned int con:2; rule; -; External rule numbers for matches are retrieved by calling rule with a state number and a goal non-terminal [13]. iburg generates an implementation of rule that uses tables to map the
Reference: 7. <author> Emmelmann, H., Schr oer, F.-W., and Landwehr, R. </author> <title> BEG | a generator for efficient back ends. </title> <booktitle> Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, SIGPLAN Notices 24, </booktitle> <month> 7 (July </month> <year> 1989), </year> <pages> 227-237. </pages>
Reference-contexts: The first pass is bottom up and finds a set of patterns that cover the tree with minimum cost. The second pass executes the semantic actions associated with minimum-cost patterns at the nodes they matched. Code generator generators based on this model include BEG <ref> [7] </ref>, Twig [2], and burg [13]. BEG matchers are hard-coded and mirror the tree patterns in the same way that recursive-descent parsers mirror their input grammars. They use a Authors' addresses: C. W. Fraser, AT&T Bell Laboratories, 600 Mountain Avenue 2C-464, Mur-ray Hill, NJ 07974-0636; D. R. <p> in a first course on compilers. burg and iburg have been used also to produce robust VAX, MIPS, and SPARC code generators for lcc, a retargetable compiler for ANSI C [11]. iburg and BEG produce similar matchers, but this note describes them in more detail than the standard BEG reference <ref> [7] </ref>. In particular, it describes several optimizations that paid off and two that did not, and it quantifies the strengths and weaknesses of such programs when compared with programs like Twig and burg. 2. <p> It returns the state number to assign to that node. For unary operators and leaves, it ignores the last one or two arguments, respectively. 4. IMPLEMENTATION iburg generates a state function that uses a straightforward implementation of tree pattern matching <ref> [7] </ref>. It generates hard code instead of tables. Its "state numbers" are pointers to state records, which hold vectors of the (M; C) values for successful matches. <p> For example, recognizing and using the VAX's indexed addressing mode takes 12 rules in lcc's specification. iburg could easily be extended so that predicates could be specified and tested during matching, much like BEG's conditions <ref> [7] </ref>. iburg can be useful during development. The generated state and label functions are easy to read and to debug. Indeed, they mirror their specification in the same way that the code for a recursive-descent parser mirrors its LL (1) grammar. This attribute has made iburg ideal for teaching.
Reference: 8. <author> Ferdinand, C., Seidl, H., and Wilhelm, R. </author> <title> Tree automata for code selection. In Code Generation | Concepts, Tools, Techniques, </title> <booktitle> Proceedings of the International Workshop on Code Generation, </booktitle> <address> Dagstuhl, </address> <note> Germany (May 1991), </note> <editor> R. Giegerich and S. L. Graham, Eds., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 30-50. </pages>
Reference-contexts: 1. INTRODUCTION Many code generator generators use tree pattern matching and dynamic programming (DP) <ref> [3, 4, 8] </ref>. They accept tree patterns and associated costs and semantic actions that, for example, allocate registers and emit object code. They produce tree matchers that make two passes over each subject tree.
Reference: 9. <author> Fraser, C. W. </author> <title> A language for writing code generators. </title> <booktitle> Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, SIGPLAN Notices 24, </booktitle> <month> 7 (July </month> <year> 1989), </year> <pages> 238-245. </pages>
Reference-contexts: This paper describes a program called iburg that reads a burg specification and writes a matcher that does DP at compile time. The matcher is hard coded, a technique that has proven effective with other types of code generators <ref> [9, 12] </ref>. iburg was built to test early versions of what evolved into burg's specification language and interface, but it is useful in its own right because it is simpler and thus easier for novices to understand, because it allows dynamic cost computation, and because it admits a larger class of
Reference: 10. <author> Fraser, C. W., and Hanson, D. R. </author> <title> A code generation interface for ANSI C. </title> <journal> Software| Practice & Experience 21, </journal> <month> 9 (Sept. </month> <year> 1991), </year> <pages> 963-988. </pages>
Reference-contexts: Only the rules on lines 4, 6, 7, and 9 have non-zero costs. The rules on lines 5, 9, 12, and 13 are chain rules. The operators in Figure 2 are some of the operators in lcc's intermediate language <ref> [10] </ref>. The operator names are formed by concatenating a generic operator name with a one-character type suffix like C, I, or P, which denote character, integer, and pointer operations, respectively.
Reference: 11. <author> Fraser, C. W., and Hanson, D. R. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices 26, </journal> <month> 10 (Oct. </month> <year> 1991), </year> <pages> 29-43. </pages>
Reference-contexts: cost computation, and because it admits a larger class of tree grammars [16]. iburg has been used with good results in a first course on compilers. burg and iburg have been used also to produce robust VAX, MIPS, and SPARC code generators for lcc, a retargetable compiler for ANSI C <ref> [11] </ref>. iburg and BEG produce similar matchers, but this note describes them in more detail than the standard BEG reference [7].
Reference: 12. <author> Fraser, C. W., and Henry, R. R. </author> <title> Hard-coding bottom-up code generation tables to save time and space. </title> <journal> Software|Practice & Experience 21, </journal> <month> 1 (Jan. </month> <year> 1991), </year> <pages> 1-12. </pages>
Reference-contexts: This paper describes a program called iburg that reads a burg specification and writes a matcher that does DP at compile time. The matcher is hard coded, a technique that has proven effective with other types of code generators <ref> [9, 12] </ref>. iburg was built to test early versions of what evolved into burg's specification language and interface, but it is useful in its own right because it is simpler and thus easier for novices to understand, because it allows dynamic cost computation, and because it admits a larger class of
Reference: 13. <author> Fraser, C. W., Henry, R. R., and Proebsting, T. A. </author> <title> BURG|Fast optimal instruction selection and tree parsing. </title> <journal> SIGPLAN Notices 27, </journal> <month> 4 (Apr. </month> <year> 1992), </year> <pages> 68-76. </pages>
Reference-contexts: The first pass is bottom up and finds a set of patterns that cover the tree with minimum cost. The second pass executes the semantic actions associated with minimum-cost patterns at the nodes they matched. Code generator generators based on this model include BEG [7], Twig [2], and burg <ref> [13] </ref>. BEG matchers are hard-coded and mirror the tree patterns in the same way that recursive-descent parsers mirror their input grammars. They use a Authors' addresses: C. W. Fraser, AT&T Bell Laboratories, 600 Mountain Avenue 2C-464, Mur-ray Hill, NJ 07974-0636; D. R. <p> The external rule numbers correspond to the line numbers to simplify interpreting subsequent figures. In practice, these numbers are usually generated by a preprocessor that accepts a richer form of specification (e.g., including YACC-style semantic actions), and emits a burg specification <ref> [13] </ref>. Only the rules on lines 4, 6, 7, and 9 have non-zero costs. The rules on lines 5, 9, 12, and 13 are chain rules. The operators in Figure 2 are some of the operators in lcc's intermediate language [10]. <p> The rules show that ADDI and ASGNI are binary, CVCI and INDIRC are unary, and ADDRLP, CNSTI, and I0I are leaves. 4 ASGNI ADDRLP i ADDI CVCI INDIRC ADDRLP c CNSTI 4 (11, 0) [5, 1+0=1] (11, 0) [5, 1+0=1] (7, 0+1=1) <ref> [13, 1+0=1] </ref> [5, 2+0=2] (10, 1+0+0=1) (14, 0) disp: ADDRLP reg: disp stmt: reg rc: reg reg: ADDI (rec,rc) stmt: reg rc: reg disp: ADDI (reg,con) stmt: ASGNI (disp,reg) reg: CVCI (INDIRC (disp)) stmt: reg rc: reg con: CNSTI rc: con disp: ADDRLP reg: disp stmt: reg rc: reg Fig. 3. <p> Reducers are supplied by clients, but burg generates functions that assist in these traversals, e.g., one function that returns M and another that identifies subtrees for recursive visits. Reference <ref> [13] </ref> elaborates. burg does all dynamic programming at compile-compile time and annotates each node with a single, integral state number, which encodes all of the information concerning matches and costs. iburg does the dynamic programming at compile time and annotates nodes with data equivalent to (M; C). <p> e.g., struct state - int op; struct state *left, *right; short cost [6]; struct - unsigned int stmt:2; unsigned int disp:2; unsigned int rc:2; unsigned int reg:3; unsigned int con:2; rule; -; External rule numbers for matches are retrieved by calling rule with a state number and a goal non-terminal <ref> [13] </ref>. iburg generates an implementation of rule that uses tables to map the integers in the compact representation to external rule numbers, e.g., short decode_disp [] = - 0, 10, 11 -; short decode_rc [] = - 0, 12, 13 -; short decode_stmt [] = - 0, 4, 5 -; short <p> When they make mistakes with iburg, each node explicitly records the 13 matching rules and costs for each non-terminal, so users can easily compare the matcher's actual operation with their expectations. Acknowledgments Section 2 borrows from Reference <ref> [13] </ref>, parts of which were written by Robert Henry. The C version of iburg is available for anonymous ftp in the directory pub from ftp.cs.princeton.edu.
Reference: 14. <author> Griswold, R. E., and Griswold, M. T. </author> <title> The Icon Programming Language, second ed. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1990. </year>
Reference-contexts: Implementation of state. 8 improvements below, iburg takes only 642 lines of Icon <ref> [14] </ref>. The short elements of the rule vector can accommodate any external rule number, but many non-terminals are defined by only a few rules. For example, only lines 10 and 11 in Figure 2 define disp, so only two bits are needed to record one of the two positive values.
Reference: 15. <author> Hoffman, C. M., and O'Donnell, M. J. </author> <title> Pattern matching in trees. </title> <journal> Journal of the ACM 29, </journal> <month> 1 (Jan. </month> <year> 1982), </year> <pages> 68-95. </pages>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. 2 dynamic programming at compile time to identify a minimum-cost cover. Twig matchers use a table-driven variant of string matching <ref> [1, 15] </ref> that, in essence, identifies all possible matches at the same time. This algorithm is asymptotically better than trying each possible match one at a time, but overhead is higher.
Reference: 16. <author> Pelegr i-Llopart, E. </author> <title> Tree Transformation in Compiler Systems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, Berkeley, </institution> <address> CA, </address> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: was built to test early versions of what evolved into burg's specification language and interface, but it is useful in its own right because it is simpler and thus easier for novices to understand, because it allows dynamic cost computation, and because it admits a larger class of tree grammars <ref> [16] </ref>. iburg has been used with good results in a first course on compilers. burg and iburg have been used also to produce robust VAX, MIPS, and SPARC code generators for lcc, a retargetable compiler for ANSI C [11]. iburg and BEG produce similar matchers, but this note describes them in
Reference: 17. <author> Pelegr i-Llopart, E., and Graham, S. L. </author> <title> Optimal code generation for expression trees: An application of BURS theory. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages (San Diego, </booktitle> <address> CA, </address> <month> Jan. </month> <year> 1988), </year> <pages> pp. 294-308. </pages>
Reference-contexts: This algorithm is asymptotically better than trying each possible match one at a time, but overhead is higher. Like BEG matchers, Twig matchers use DP at compile time to identify a minimum-cost cover. burg uses BURS (bottom-up rewrite system) theory <ref> [5, 6, 17, 18] </ref> to move the DP to compile-compile time. BURS table generation is more complicated, but BURS matchers generate optimal code in constant time per node.
Reference: 18. <author> Proebsting, T. A. </author> <title> Simple and efficient BURS table generation. </title> <booktitle> Proceedings of the SIG-PLAN'92 Conference on Programming Language Design and Implementation, SIGPLAN Notices 27, </booktitle> <month> 6 (June </month> <year> 1992), </year> <pages> 331-340. 14 </pages>
Reference-contexts: This algorithm is asymptotically better than trying each possible match one at a time, but overhead is higher. Like BEG matchers, Twig matchers use DP at compile time to identify a minimum-cost cover. burg uses BURS (bottom-up rewrite system) theory <ref> [5, 6, 17, 18] </ref> to move the DP to compile-compile time. BURS table generation is more complicated, but BURS matchers generate optimal code in constant time per node. <p> Computing and encoding all of the state record data about matches at compile-compile time is complicated <ref> [18] </ref>. Leaves, however, always match and the contents of the state record is easily computed by simulating the effect of the assignments and closure function calls shown above. <p> For example, parsing the input and writing the output account for 181 and 159 lines, respectively, in the 642-line final version. By way of comparison, a new version of iburg written in C is 950 lines, and a burg processor is 5100 lines of C <ref> [18] </ref>. 6. DISCUSSION iburg was built to test early versions of what evolved into burg's specification language and interface. Initial tests used Twig and a Twig preprocessor, but Twig produced incorrect matchers for large CISC grammars. The error proved hard to find, so Twig was abandoned and iburg written.

References-found: 18

