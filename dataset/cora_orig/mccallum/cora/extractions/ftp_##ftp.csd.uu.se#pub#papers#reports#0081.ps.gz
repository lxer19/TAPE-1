URL: ftp://ftp.csd.uu.se/pub/papers/reports/0081.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: A Basis for a Multilevel Metalogic Programming Language  
Author: Jonas Barklund, Katrin Boberg and Pierangelo Dell'Acqua 
Address: 311, S-751 05 Uppsala, Sweden  
Affiliation: Box  Uppsala Univ. and Univ. degli Studi di Milano.  
Date: July, 1994  
Note: 31  P. Dell'Acqua has been financially supported by both  
Abstract: UPMAIL Technical Report No. 81 Abstract We are developing a multilevel metalogic programming language that we call Alloy. It is based on first-order predicate calculus extended with metalogical constructs. An Alloy program consists of a collection of theories, all in the same language, and a representation relation over these theories. The whole language is self-representable, including names for expressions with variables. A significant difference, as compared with many previous approaches, is that an arbitrary number of metalevels can be employed and that the object-meta relationship between theories need not be circular. The language is primarily intended for representation of knowledge and metaknowledge and is currently being used in research on hierarchical representation of legal knowledge. We believe that the language allows sophisticated expression and efficient automatic deduction of interesting sets of beliefs of agents. This paper aims to give a preliminary and largely informal definition of the core of the language, a simple but incomplete and inefficient proof system for the language and a sketch of an alternative, more efficient, proof system. The latter is intended to be used as a procedural semantics for the language. It is being implemented by an extension of an abstract machine for Prolog. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiello, L. C., Nardi, D. and Schaerf, M., </author> <title> Reasoning about Knowledge and Ignorance, </title> <editor> in: H. Tanaka and K. Furukawa (eds.), </editor> <booktitle> Proc. Intl. Conf. on Fifth Generation Comp. Sys. 1988, </booktitle> <publisher> Ohmsha, </publisher> <address> Tokyo, </address> <year> 1988. </year>
Reference-contexts: Our hypothesis is that such knowledge can favourably be structured in a collection of theories, where some theories contain theorems about some of the other theories. This hypothesis is supported by previous research conducted by, e.g., Bowen [6], Eshghi [19], Aiello, Nardi & Schaerf <ref> [1] </ref>, Costantini & Lanzarone [16], Kim & Kowalski [21], and Brogi & Turini [11]. In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described. <p> So far the language has been used for representing legal knowledge [5] and for a solution (not yet published) to the `Three Wise Men' puzzle, a well-known benchmark problem for metareasoning formalisms <ref> [1, 21] </ref>. Even though we intend Alloy to become a language with a well-defined concrete syntax we prefer to use an abstract syntax in this report.
Reference: [2] <author> Barklund, J., </author> <title> What is a Meta-Variable in Prolog?, </title> <editor> in: H. Abramson and M. H. Rogers (eds.), </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The added complication is the price to be paid for this richer language. We should add that these "scopes" seem to be quite efficiently implementable (cf. the dictionaries of Barklund <ref> [2] </ref> and the substitutions of Sato [26]). 7 Related Work In constructing this language we have tried to remain closer to work on reflection and encodings in mathematical logic [27] than most other approaches. 11 The language was obviously inspired by Reflective Prolog [18], differing from it in mainly three aspects: <p> The operators by Brogi et al. could serve as a useful basis for defining more specific operators. * The encodings in this language are more abstract than the structural names of Barklund <ref> [2] </ref>, Costantini and Lanzarone [18] and of Cervesato 12 & Rossi [12], but less abstract than those of Hill & Lloyd [20]: We do not commit to a particular ground representation but there is a syntax for the representations. * The truth predicate proposed by Sato [26] is related to Alloy
Reference: [3] <author> Barklund, J., Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Reflection through Constraint Satisfaction, </title> <editor> in: P. Van Hentenryck (ed.), </editor> <booktitle> Logic Programming: Proc. 11th Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: Extending unification to constraint satisfaction over the domain of names is an elegant and implementation-wise straightforward way to get correct linking between levels. We employ the scheme that was proposed recently by Barklund, Costantini, Dell'Acqua and Lanzarone for a somewhat more restricted language <ref> [3, 4] </ref> (see also Christiansen [13]). First, unification and SLD-resolution is re-expressed in terms of equations instead of substitutions. Each resolution step sets up an equation system that either can be transformed to a solved form, corresponding to a most general unifier, or can be shown to have no solution.
Reference: [4] <author> Barklund, J., Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> SLD-Resolution with Reflection, </title> <note> to appear in Proc. ILPS'94, 1994. 13 </note>
Reference-contexts: The language has been influenced by Prolog [15], Reflective Prolog [18] and unnamed languages proposed by Kowalski [22, 23]. The intended procedural semantics is an extension of that proposed by Barklund, Costantini, Dell'Acqua and Lanzarone <ref> [4] </ref>. The procedural semantics will be realized through translation to sequences of instructions for an abstract machine, currently under development. <p> Extending unification to constraint satisfaction over the domain of names is an elegant and implementation-wise straightforward way to get correct linking between levels. We employ the scheme that was proposed recently by Barklund, Costantini, Dell'Acqua and Lanzarone for a somewhat more restricted language <ref> [3, 4] </ref> (see also Christiansen [13]). First, unification and SLD-resolution is re-expressed in terms of equations instead of substitutions. Each resolution step sets up an equation system that either can be transformed to a solved form, corresponding to a most general unifier, or can be shown to have no solution.
Reference: [5] <author> Barklund, J. and Hamfelt, A., </author> <title> Hierarchical Representation of Legal Knowledge with Metaprogramming in Logic, </title> <journal> J. Logic Programming, </journal> <volume> 18 </volume> <month> 55-80 </month> <year> (1994). </year>
Reference-contexts: In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described. A brief description of the language was recently given by Barklund & Ham-felt <ref> [5] </ref>. The purpose of this paper is to summarize the language and its properties in further detail. The language can be characterized as a Horn clause language with resolution [25] that is extended with a representation of the linguistic elements and of its demonstrability. <p> This intention has influenced the development of the 1 language by making us focus on representation of demonstrability. So far the language has been used for representing legal knowledge <ref> [5] </ref> and for a solution (not yet published) to the `Three Wise Men' puzzle, a well-known benchmark problem for metareasoning formalisms [1, 21]. Even though we intend Alloy to become a language with a well-defined concrete syntax we prefer to use an abstract syntax in this report.
Reference: [6] <author> Bowen, K. A., </author> <title> Meta-Level Programming and Knowledge Representation, </title> <journal> New Generation Computing, </journal> <volume> 3 </volume> <month> 359-383 </month> <year> (1985). </year>
Reference-contexts: Our hypothesis is that such knowledge can favourably be structured in a collection of theories, where some theories contain theorems about some of the other theories. This hypothesis is supported by previous research conducted by, e.g., Bowen <ref> [6] </ref>, Eshghi [19], Aiello, Nardi & Schaerf [1], Costantini & Lanzarone [16], Kim & Kowalski [21], and Brogi & Turini [11]. In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described.
Reference: [7] <author> Bowen, K. A. and Kowalski, R. A., </author> <title> Amalgamating Language and Met-alanguage in Logic Programming, </title> <editor> in: K. L. Clark and S. A. Tarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: The following rule is a generalized meta-to-object linking rule <ref> [7, 28] </ref>. t 1 ` t 2 ` p t k ` p t M . t O q q t 1 ` t 2 ` t k ` p t M ` p t O ` q q q q p q To understand the rule, it may help to
Reference: [8] <author> Brogi, A., Mancarella, P., Pedreschi, D. and Turini, F., </author> <title> Composition Operators for Logic Theories, </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Resolving clauses 17 and 13 finally yields the theorem As good as (Gold; Mary) in O 2 . This expressivity is similar to that obtained by Brogi, Mancarella, Pe-dreschi and Turini [9] when applying their work on composition operators for theories <ref> [8] </ref> to modules. <p> There are also other formalisms where a comparison should be useful: * Our language is also related to languages proposed by Kowalski [22, 23] in the use of multiple theories. Our language is indeed an attempt to concretize these ideas. * Brogi, Mancarella, Pedreschi & Turini <ref> [8, 9, 10] </ref> have investigated a collection of operators for composing theories. The "meta-interpretive" definitions of the operators can be expressed directly in Alloy. Although theories in Alloy are not to be thought of as data structures, the language allows theories to be denoted by arbitrary ground expressions.
Reference: [9] <author> Brogi, A., Mancarella, P., Pedreschi, D. and Turini, F., </author> <title> Meta for Modularising Logic Programming, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Resolving clauses 17 and 13 finally yields the theorem As good as (Gold; Mary) in O 2 . This expressivity is similar to that obtained by Brogi, Mancarella, Pe-dreschi and Turini <ref> [9] </ref> when applying their work on composition operators for theories [8] to modules. <p> There are also other formalisms where a comparison should be useful: * Our language is also related to languages proposed by Kowalski [22, 23] in the use of multiple theories. Our language is indeed an attempt to concretize these ideas. * Brogi, Mancarella, Pedreschi & Turini <ref> [8, 9, 10] </ref> have investigated a collection of operators for composing theories. The "meta-interpretive" definitions of the operators can be expressed directly in Alloy. Although theories in Alloy are not to be thought of as data structures, the language allows theories to be denoted by arbitrary ground expressions.
Reference: [10] <author> Brogi, A., </author> <title> Program Construction in Computational Logic, </title> <type> Ph.D. Thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year>
Reference-contexts: There are also other formalisms where a comparison should be useful: * Our language is also related to languages proposed by Kowalski [22, 23] in the use of multiple theories. Our language is indeed an attempt to concretize these ideas. * Brogi, Mancarella, Pedreschi & Turini <ref> [8, 9, 10] </ref> have investigated a collection of operators for composing theories. The "meta-interpretive" definitions of the operators can be expressed directly in Alloy. Although theories in Alloy are not to be thought of as data structures, the language allows theories to be denoted by arbitrary ground expressions.
Reference: [11] <author> Brogi, A. and Turini, F., </author> <title> Metalogic for Knowledge Representation, </title> <editor> in: J. A. Allen, R. Fikes and E. Sandewall (eds.), </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. 2nd Intl. Conf., </booktitle> <publisher> Morgan Kauf-mann, </publisher> <address> Los Altos, Calif., </address> <year> 1991. </year>
Reference-contexts: This hypothesis is supported by previous research conducted by, e.g., Bowen [6], Eshghi [19], Aiello, Nardi & Schaerf [1], Costantini & Lanzarone [16], Kim & Kowalski [21], and Brogi & Turini <ref> [11] </ref>. In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described. A brief description of the language was recently given by Barklund & Ham-felt [5].
Reference: [12] <author> Cervesato, I. and Rossi, G. F., </author> <title> Logic Meta-Programming Facilities in 'LOG, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: The operators by Brogi et al. could serve as a useful basis for defining more specific operators. * The encodings in this language are more abstract than the structural names of Barklund [2], Costantini and Lanzarone [18] and of Cervesato 12 & Rossi <ref> [12] </ref>, but less abstract than those of Hill & Lloyd [20]: We do not commit to a particular ground representation but there is a syntax for the representations. * The truth predicate proposed by Sato [26] is related to Alloy in that it too allows encodings of nonground expressions and reflection.
Reference: [13] <author> Christiansen, H., </author> <title> Efficient and Complete Demo Predicates for Definite Clause Languages, </title> <editor> in: P. Van Hentenryck (ed.), </editor> <booktitle> Logic Programming: Proc. 11th Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: Extending unification to constraint satisfaction over the domain of names is an elegant and implementation-wise straightforward way to get correct linking between levels. We employ the scheme that was proposed recently by Barklund, Costantini, Dell'Acqua and Lanzarone for a somewhat more restricted language [3, 4] (see also Christiansen <ref> [13] </ref>). First, unification and SLD-resolution is re-expressed in terms of equations instead of substitutions. Each resolution step sets up an equation system that either can be transformed to a solved form, corresponding to a most general unifier, or can be shown to have no solution.
Reference: [14] <author> Clark, K. L., </author> <title> Negation as Failure, </title> <editor> in: H. Gallaire and J. Minker (eds.), </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: However, in the second example, instantiating z to an encoding of a nonground term might reveal further variables with the scope of the program clause. 3 ) The equality theory of our language is "Herbrand equality", as defined by Clark <ref> [14] </ref>, extended with three axioms for encodings: p t 0 (t 1 ; : : : ; t k ) q = p u 0 (u 1 ; : : : ; u l ) q ! p t 0 q = p u 0 q ^ p t 1 q
Reference: [15] <author> Colmerauer, A., Kanoui, H., Pasero, R. and Roussel, P., </author> <title> Un Systeme de Communication Homme-Machine en Fran~cais, </title> <type> Technical report, </type> <institution> Groupe de Recherche en Intelligence Artificielle, Univ. </institution> <address> d'Aix-Marseille, Luminy, </address> <year> 1972. </year>
Reference-contexts: The language has been influenced by Prolog <ref> [15] </ref>, Reflective Prolog [18] and unnamed languages proposed by Kowalski [22, 23]. The intended procedural semantics is an extension of that proposed by Barklund, Costantini, Dell'Acqua and Lanzarone [4]. The procedural semantics will be realized through translation to sequences of instructions for an abstract machine, currently under development.
Reference: [16] <author> Costantini, S. and Lanzarone, G. A., </author> <title> Analogical Reasoning in Reflective Prolog, </title> <editor> in: A. A. Martino (ed.), Pre-Proc. </editor> <booktitle> 3rd Intl. Conf. </booktitle> <institution> on Logica Informatica Diritto, Istituto per la documentazione giuridica, Florence, </institution> <year> 1989. </year>
Reference-contexts: Our hypothesis is that such knowledge can favourably be structured in a collection of theories, where some theories contain theorems about some of the other theories. This hypothesis is supported by previous research conducted by, e.g., Bowen [6], Eshghi [19], Aiello, Nardi & Schaerf [1], Costantini & Lanzarone <ref> [16] </ref>, Kim & Kowalski [21], and Brogi & Turini [11]. In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described. A brief description of the language was recently given by Barklund & Ham-felt [5].
Reference: [17] <author> Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Reflective Agents in Metalogic Programming, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: However, incorporation of this fundamental construct explicitly in the language seems justified on grounds of efficiency and convenience. (The interesting multiple theory extension proposed for Reflective Prolog <ref> [17] </ref> was intended for modelling communicating agents, by describing how theories exchange information, and is therefore quite different from the extension described here.) * The view of what is actually reflected between metalevels is conceptually quite different in the two languages, although the views coincide when only ground expressions are transferred.
Reference: [18] <author> Costantini, S. and Lanzarone, G. A., </author> <title> A Metalogic Programming Language, </title> <editor> in: G. Levi and M. Martelli (eds.), </editor> <booktitle> Proc. 6th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The language has been influenced by Prolog [15], Reflective Prolog <ref> [18] </ref> and unnamed languages proposed by Kowalski [22, 23]. The intended procedural semantics is an extension of that proposed by Barklund, Costantini, Dell'Acqua and Lanzarone [4]. The procedural semantics will be realized through translation to sequences of instructions for an abstract machine, currently under development. <p> The following program (from a similar Reflective Prolog program <ref> [18] </ref>) contains three theories denoted by the symbols M , O 1 and O 2 , where M is intended to be a metatheory of O 1 and O 2 . <p> Operationally that would correspond to an addition to the program, preventing or complicating compilation of program clauses. (Even if we were to replace the generalized resolution rule with a generalized SLD-resolution rule, there are no obvious direct replacements of the linking rules.) Just like RSLD-resolution <ref> [18] </ref>, our proof procedure combines reflection inferences with SLD-resolution steps in order to retain the three properties above. This ensures that if an object level deduction invokes a metalevel deduction, or vice versa, then it is because the result is needed. <p> efficiently implementable (cf. the dictionaries of Barklund [2] and the substitutions of Sato [26]). 7 Related Work In constructing this language we have tried to remain closer to work on reflection and encodings in mathematical logic [27] than most other approaches. 11 The language was obviously inspired by Reflective Prolog <ref> [18] </ref>, differing from it in mainly three aspects: * Alloy has names for variables, so nonground expressions can be represented directly. This should make the language suitable for writing program manipulating tools, such as partial evaluators, at least for the language itself. <p> The operators by Brogi et al. could serve as a useful basis for defining more specific operators. * The encodings in this language are more abstract than the structural names of Barklund [2], Costantini and Lanzarone <ref> [18] </ref> and of Cervesato 12 & Rossi [12], but less abstract than those of Hill & Lloyd [20]: We do not commit to a particular ground representation but there is a syntax for the representations. * The truth predicate proposed by Sato [26] is related to Alloy in that it too
Reference: [19] <author> Eshghi, K., </author> <title> Meta-Language in Logic Programming, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computing, Imperial College, </institution> <address> London, </address> <year> 1986. </year>
Reference-contexts: Our hypothesis is that such knowledge can favourably be structured in a collection of theories, where some theories contain theorems about some of the other theories. This hypothesis is supported by previous research conducted by, e.g., Bowen [6], Eshghi <ref> [19] </ref>, Aiello, Nardi & Schaerf [1], Costantini & Lanzarone [16], Kim & Kowalski [21], and Brogi & Turini [11]. In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described.
Reference: [20] <author> Hill, P. M. and Lloyd, J. W., </author> <title> The Godel Programming Language, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: Brogi et al. could serve as a useful basis for defining more specific operators. * The encodings in this language are more abstract than the structural names of Barklund [2], Costantini and Lanzarone [18] and of Cervesato 12 & Rossi [12], but less abstract than those of Hill & Lloyd <ref> [20] </ref>: We do not commit to a particular ground representation but there is a syntax for the representations. * The truth predicate proposed by Sato [26] is related to Alloy in that it too allows encodings of nonground expressions and reflection.
Reference: [21] <author> Kim, J. S. and Kowalski, R. A., </author> <title> An Application of Amalgamated Logic to Multi-Agent Belief, </title> <editor> in: M. Bruynooghe (ed.), </editor> <booktitle> Proc. Second Workshop on Meta-Programming in Logic, </booktitle> <institution> Dept. of Comp. Sci., Katholieke Univ. Leuven, </institution> <year> 1990. </year>
Reference-contexts: This hypothesis is supported by previous research conducted by, e.g., Bowen [6], Eshghi [19], Aiello, Nardi & Schaerf [1], Costantini & Lanzarone [16], Kim & Kowalski <ref> [21] </ref>, and Brogi & Turini [11]. In order to test our hypothesis we are developing a metalogic programming language, Alloy, suited for expressing knowledge of the kind just described. A brief description of the language was recently given by Barklund & Ham-felt [5]. <p> So far the language has been used for representing legal knowledge [5] and for a solution (not yet published) to the `Three Wise Men' puzzle, a well-known benchmark problem for metareasoning formalisms <ref> [1, 21] </ref>. Even though we intend Alloy to become a language with a well-defined concrete syntax we prefer to use an abstract syntax in this report.
Reference: [22] <author> Kowalski, R. A., </author> <title> Meta Matters, </title> <booktitle> invited presentation at Second Workshop on Meta-Programming in Logic, </booktitle> <year> 1990. </year>
Reference-contexts: The language has been influenced by Prolog [15], Reflective Prolog [18] and unnamed languages proposed by Kowalski <ref> [22, 23] </ref>. The intended procedural semantics is an extension of that proposed by Barklund, Costantini, Dell'Acqua and Lanzarone [4]. The procedural semantics will be realized through translation to sequences of instructions for an abstract machine, currently under development. <p> There are also other formalisms where a comparison should be useful: * Our language is also related to languages proposed by Kowalski <ref> [22, 23] </ref> in the use of multiple theories. Our language is indeed an attempt to concretize these ideas. * Brogi, Mancarella, Pedreschi & Turini [8, 9, 10] have investigated a collection of operators for composing theories. The "meta-interpretive" definitions of the operators can be expressed directly in Alloy.
Reference: [23] <author> Kowalski, R. A., </author> <title> Problems and Promises of Computational Logic, </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The language has been influenced by Prolog [15], Reflective Prolog [18] and unnamed languages proposed by Kowalski <ref> [22, 23] </ref>. The intended procedural semantics is an extension of that proposed by Barklund, Costantini, Dell'Acqua and Lanzarone [4]. The procedural semantics will be realized through translation to sequences of instructions for an abstract machine, currently under development. <p> There are also other formalisms where a comparison should be useful: * Our language is also related to languages proposed by Kowalski <ref> [22, 23] </ref> in the use of multiple theories. Our language is indeed an attempt to concretize these ideas. * Brogi, Mancarella, Pedreschi & Turini [8, 9, 10] have investigated a collection of operators for composing theories. The "meta-interpretive" definitions of the operators can be expressed directly in Alloy.
Reference: [24] <author> Lloyd, J. W., </author> <title> Foundations of Logic Programming, Second Edition, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: Such a definition contains theory-tagged program clauses and representation statements, the latter identifying the metatheories for every theory. The language is common for all theories and we describe it in this section. We let terms, definite program clauses and definite goal clauses be as usual <ref> [24] </ref> (but in what follows we will simply write "program clause" or "goal clause" for a definite clause). 1 We will refer to expressions composed from atomic sentences (or "atoms") by conjunction and implication operators as sentences.
Reference: [25] <author> Robinson, J. A., </author> <title> A Machine-oriented Logic Based on the Resolution Principle, </title> <journal> J. ACM, </journal> <volume> 12 </volume> <month> 23-41 </month> <year> (1965). </year>
Reference-contexts: A brief description of the language was recently given by Barklund & Ham-felt [5]. The purpose of this paper is to summarize the language and its properties in further detail. The language can be characterized as a Horn clause language with resolution <ref> [25] </ref> that is extended with a representation of the linguistic elements and of its demonstrability.
Reference: [26] <author> Sato, T., </author> <title> Meta-Programming through a Truth Predicate, </title> <editor> in: K. Apt (ed.), </editor> <booktitle> Proc. Joint Intl. Conf. Symp. on Logic Programming 1992, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: The added complication is the price to be paid for this richer language. We should add that these "scopes" seem to be quite efficiently implementable (cf. the dictionaries of Barklund [2] and the substitutions of Sato <ref> [26] </ref>). 7 Related Work In constructing this language we have tried to remain closer to work on reflection and encodings in mathematical logic [27] than most other approaches. 11 The language was obviously inspired by Reflective Prolog [18], differing from it in mainly three aspects: * Alloy has names for variables, <p> structural names of Barklund [2], Costantini and Lanzarone [18] and of Cervesato 12 & Rossi [12], but less abstract than those of Hill & Lloyd [20]: We do not commit to a particular ground representation but there is a syntax for the representations. * The truth predicate proposed by Sato <ref> [26] </ref> is related to Alloy in that it too allows encodings of nonground expressions and reflection. However, there are also important differences, the most important being that the theory structure of Alloy can be used to prevent a theory from introspecting its own theorems.
Reference: [27] <author> Smorynski, C., </author> <title> The Incompleteness Theorems, </title> <editor> in: J. Barwise (ed.), </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1977. </year>
Reference-contexts: We should add that these "scopes" seem to be quite efficiently implementable (cf. the dictionaries of Barklund [2] and the substitutions of Sato [26]). 7 Related Work In constructing this language we have tried to remain closer to work on reflection and encodings in mathematical logic <ref> [27] </ref> than most other approaches. 11 The language was obviously inspired by Reflective Prolog [18], differing from it in mainly three aspects: * Alloy has names for variables, so nonground expressions can be represented directly.
Reference: [28] <author> Weyhrauch, R. W., </author> <title> Prolegomena to a Theory of Mechanized Formal Reasoning, </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <month> 133-70 </month> <year> (1980). </year> <month> 15 </month>
Reference-contexts: The following rule is a generalized meta-to-object linking rule <ref> [7, 28] </ref>. t 1 ` t 2 ` p t k ` p t M . t O q q t 1 ` t 2 ` t k ` p t M ` p t O ` q q q q p q To understand the rule, it may help to
References-found: 28

