URL: http://www.cs.mtu.edu/~dkkuras/thesis/thesis.ps
Refering-URL: http://www.cs.mtu.edu/~dkkuras/thesis/thesis.html
Root-URL: http://www.cs.mtu.edu
Title: EFFICIENT CODE GENERATION FOR SOFTWARE PIPELINED LOOPS ON VLIW ARCHITECTURES WITH PARTITIONED REGISTER FILES  
Author: By DARLA K. KURAS 
Degree: A THESIS Submitted in partial fulfillment of the requirements for the degree of MASTER OF SCIENCE IN COMPUTER SCIENCE  
Date: 1998  
Affiliation: MICHIGAN TECHNOLOGICAL UNIVERSITY  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Capitanio, N. Dutt, and A. Nicolau. </author> <title> Partitioned Register Files for VLIWs: A Preliminary Analysis of Tradeoffs. </title> <booktitle> Proceedings of the 25th Annual Workshop on Microprogramming (MICRO-25), </booktitle> <pages> pp. 292-300, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Thus, the large number of ports required by the register file for significant levels of ILP makes it difficult to maintain a high clock 3 rate and severely hampers access time <ref> [1] </ref>. This problem is at the center of this research. 1.1 VLIW Architectures VLIW architectures execute very long instructions that contain several low-level operations. These operations are issued concurrently for execution among the machine's hardware resources. <p> For example, consider an 8-wide (capable of executing 8 operations simultaneously) VLIW. If each operation requires two source registers and one register for the result, 24 registers must be accessible at the same time. Currently, more than 12 ports is infeasible <ref> [1] </ref>. To avoid the degradation in performance caused by multi-porting a single register file, but still retain the computational power of many functional units, the register file can be partitioned into banks. <p> As the number of functional units increases, the required interconnection network of the TTA will become complex, costly, and slow. 2.3 Research at the University of California, Irvine Capitanio et. al. have published two papers <ref> [1, 7] </ref> about code generation for machines with partitioned register files. The first considers a limited connectivity VLIW much like our target architecture. <p> The first considers a limited connectivity VLIW much like our target architecture. The second considers an architecture similar to the TTA. 13 2.3.1 Cost Estimation In <ref> [1] </ref>, Capitanio et. al. present an algorithm that generates code for a partitioned VLIW by modifying the code generated for an ideal VLIW. Their partitioning algorithm consists of three phases. 1. Construct the DCG: Phase one generates a directed cyclic graph (DCG) representation of a loop.
Reference: [2] <author> V. Allan, R. Jones, R. Lee, and S. Allan. </author> <title> Software Pipelining. </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 27, no. 3. </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: r1, r2 load r3, xaccel load r4, xpos mult r7, r3, r2 add r6, r4, r5 div r8, r2, 2.0 mult r9, r7, r8 add r10, r6, r9 store xpos, r10 1.2 Software Pipelining The work discussed in this thesis involves a type of instruction scheduling known as software pipelining <ref> [2, 3, 4] </ref>.
Reference: [3] <author> M. Lam. </author> <title> Software Pipelining: An Effective Scheduling Technique for VLIW Machines. </title> <journal> SIG-PLAN Notices, </journal> <volume> vol. 23, </volume> <pages> pp. 318-328. </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: r1, r2 load r3, xaccel load r4, xpos mult r7, r3, r2 add r6, r4, r5 div r8, r2, 2.0 mult r9, r7, r8 add r10, r6, r9 store xpos, r10 1.2 Software Pipelining The work discussed in this thesis involves a type of instruction scheduling known as software pipelining <ref> [2, 3, 4] </ref>. <p> Since much of a program's execution time is spent within loops, careful scheduling of them can significantly help overall performance. A common software pipelining technique is termed modulo scheduling <ref> [3, 4] </ref>. In modulo scheduling a schedule is found for one iteration of the loop so that when successive iterations are scheduled some interval apart, no resource or recurrence constraints are violated.
Reference: [4] <author> B.R. Rau. </author> <title> Iterative Modulo Scheduling: An Algorithm for Software Pipelining Loops. </title> <booktitle> Proceedings of the 27th Annual Workshop on Microprogramming (MICRO-27), </booktitle> <pages> pp. 63-74. </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: r1, r2 load r3, xaccel load r4, xpos mult r7, r3, r2 add r6, r4, r5 div r8, r2, 2.0 mult r9, r7, r8 add r10, r6, r9 store xpos, r10 1.2 Software Pipelining The work discussed in this thesis involves a type of instruction scheduling known as software pipelining <ref> [2, 3, 4] </ref>. <p> Since much of a program's execution time is spent within loops, careful scheduling of them can significantly help overall performance. A common software pipelining technique is termed modulo scheduling <ref> [3, 4] </ref>. In modulo scheduling a schedule is found for one iteration of the loop so that when successive iterations are scheduled some interval apart, no resource or recurrence constraints are violated.
Reference: [5] <author> J.R. Ellis. Bulldog: </author> <title> A Compiler for VLIW Architectures. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year> <type> PhD thesis, </type> <institution> Yale, </institution> <year> 1994. </year>
Reference-contexts: Their approaches tend to involve manipulating a graphical representation of the intermediate code generated for a program. Many rely on a directed acyclic graph that emphasizes the relationships between the program's operations and then distribute the operations amongst clusters. 2.1 Ellis In <ref> [5] </ref>, J. R. Ellis describes how code is generated for the Bulldog VLIW compiler using trace scheduling. Bulldog's code generation process involves three phases: 1. Bulldog picks a trace (a path through several basic blocks that are to be scheduled together) from the intermediate control flow graph.
Reference: [6] <author> Johan Janssen and Henk Corporaal. </author> <title> Partitioned Register Files for TTAs. </title> <booktitle> Proceedings of the 28th Annual Workshop on Microprogramming (MICRO-28), </booktitle> <pages> pp. 303-312, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Instruction Scheduling and Register Assignment: Since Ellis intertwines instruction scheduling and register assignment, his partitioning algorithm utilizes machine-dependent details. Thus, his approach is not easily extendible to a generic VLIW architecture. 2.2 Janssen and Corporaal In <ref> [6] </ref>, Janssen and Corporaal examine the effect of a partitioned register file on transport triggered architectures (TTAs). The partitioned TTA differs from the partitioned VLIW; although its register file is partitioned, all functional units still have direct access to each register through an interconnection network.
Reference: [7] <author> A. Capitanio, N. Dutt, and A. Nicolau. </author> <title> Toward Register Allocation for Multiple Register File VLIW Architectures. </title> <type> Technical Report TR94-6, </type> <month> June </month> <year> 1994. </year>
Reference-contexts: As the number of functional units increases, the required interconnection network of the TTA will become complex, costly, and slow. 2.3 Research at the University of California, Irvine Capitanio et. al. have published two papers <ref> [1, 7] </ref> about code generation for machines with partitioned register files. The first considers a limited connectivity VLIW much like our target architecture. <p> Capitanio et al. handle only straight-line loops, thereby limiting the applicability of their approach, as conditional branches are frequently used within loops. 14 2.3.2 Hypergraph Coloring In <ref> [7] </ref>, Capitanio et al. present a hypergraph coloring algorithm for assigning registers to banks in a partitioned architecture. Their architecture includes an interconnection network where each functional unit has a fixed connection from one register file and a switch between that file and another. <p> Like the hypergraph used by Capitanio et. al. <ref> [7] </ref>, the RCG also emphasizes operands rather than operations. However, unlike the hypergraph, there are no hyperedges; each edge connects only two nodes. This thesis is part of the register component graph research. Our overall code generation process can be broken into the following steps: 1.
Reference: [8] <author> Saurabh Jang. </author> <title> Generating Efficient Code of VLIW Architectures with Partitioned Register Files. </title> <type> MS thesis, </type> <institution> Michigan Technological University, </institution> <year> 1996. </year>
Reference-contexts: The DDG for the code listed in weighted 1, 1. 2.4.2 Jang An initial attempt to partition the register component graph was done by Saurabh Jang for his M.S. thesis <ref> [8] </ref> at Michigan Tech. In his work, Jang used the Lee, Park, and Kim (LPK) algorithm to partition the RCG. <p> Thus, Jang surmised that his approach tended to sequentialize the code by assigning independent operations to the same cluster. Another drawback to the LPK algorithm is that it is slow, and its computation time increases by a factor of the number of partitions <ref> [8] </ref>. Therefore, compilation times on machines with high levels of ILP would probably be too long using this algorithm. 2.4.3 Sweany Given the performance of the LPK partitioning algorithm, Sweany and his colleagues at MTU tried a new approach to partitioning the RCG.
Reference: [9] <author> S. Jang, S. Carr, P. Sweany, and D. Kuras. </author> <title> A Code Generation Framework for VLIW Architectures with Partitioned Register Banks. </title> <booktitle> Proceedings of the 3rd International Conference on Massively Parallel Computing Systems. </booktitle> <month> April </month> <year> 1998. </year> <month> 41 </month>
Reference-contexts: On a 3-wide VLIW, with each functional unit connected to its own register bank, Jang found an average 10% increase in the number of instructions and a 33% increase in the number of cycles over the ideal <ref> [9] </ref>. This is counter-intuitive as copy instructions can often be inserted in empty instruction slots that don't impact the number of cycles. Thus, Jang surmised that his approach tended to sequentialize the code by assigning independent operations to the same cluster.
Reference: [10] <author> Philip H. Sweany and Steven J. Beaty. </author> <title> Overview of the Rocket Retargetable C Compiler. </title> <type> Technical Report CS-94-01, </type> <institution> Department of Computer Science, Michigan Technological University, </institution> <month> January </month> <year> 1994. </year> <month> 42 </month>
Reference-contexts: r3 load r5, [r4] add r6, r5, 1 store [r4], r6 add r7, r2, 1 mult r8, r7, r4 add r9, r1, r8 load r10, [r9] add r11, r10, 1 store [r9], r11 add r2, r2, 2 ble L store I, r2 3.2 Implementation Value cloning was implemented in Rocket <ref> [10] </ref>, a retargetable research compiler under development at Michigan Technological University.
References-found: 10

