URL: http://www.daimi.aau.dk/~tamtoft/Papers/NWPT94.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: ftamtoft,fn,hrng@daimi.aau.dk  
Title: Type and Behaviour Reconstruction for Higher-Order Concurrent Programs  
Author: Torben Amtoft, Flemming Nielson, Hanne Riis Nielson 
Address: Ny Munkegade, DK-8000 Arhus C, Denmark  
Affiliation: DAIMI, Aarhus University  
Abstract: In this paper we develop a sound and complete type and behaviour inference algorithm for a fragment of CML (Standard ML with primitives for concurrency). Behaviours resemble terms of a process algebra and yield a concise presentation of the communications taking place during execution; types are mostly as usual except that function types and "delayed communication types" are labelled by behaviours expressing the communications that will eventually take place. The development of the present paper improves a previously published algorithm in not only achieving a sound algorithm for type inference but also one that is complete, due to an alternative strategy for generalising over types and behaviours. Although we show how to solve special kinds of constraints the problem of a general solution procedure for the constraints generated remains; this is related to an open problem concerning whether all programs typable in Standard ML (with concurrency primitives) are also typable in our system. 
Abstract-found: 1
Intro-found: 1
Reference: [BD93] <author> Dominique Bolignano and Mourad Debabi. </author> <title> A coherent type system for a concurrent, functional and imperative programming language. </title> <booktitle> In AMAST '93, </booktitle> <year> 1993. </year>
Reference-contexts: The former case will arise if ff chan is handled as ff list; whereas the latter case will arise if ff chan is handled by the techniques for ff ref developed in [TJ92b] and <ref> [BD93] </ref>. 13 8.2 An algorithm taking the upwards closure Next define a version of W , to be called W ud for upwards and downwards closure, where N Q is defined in such a way that fi _ wb 2 C 1 and (fv (b) [ ffig) " N Q 6=
Reference: [BS94] <author> Bernard Berthomieu and Thierry Le Sergent. </author> <title> Programming with behaviours in an ML framework: the syntax and semantics of LCS. </title> <booktitle> In ESOP '94, volume 788 of LNCS, </booktitle> <pages> pages 89-104. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Our research has been motivated by the integration of the functional and concurrent programming paradigms. Example programming languages are CML [Rep91] that extends Standard ML with primitives for concurrency, Facile [PGM90] that follows a similar approach but more directly contains syntax for expressing CCS-like process composition, and LCS <ref> [BS94] </ref>. The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking 1 place during execution. One such representation is behaviours, a kind of process algebra expressions.
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types: Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <pages> 48-80, </pages> <year> 1991. </year>
Reference-contexts: A remedy, inspired by <ref> [CC91] </ref> where a similar observation is made concerning recursive types, might be to consider RECfi:b equivalent to its infinite unfolding (cf. rule R1 in Fig. 1 which states that RECfi:b is equivalent to its finite unfoldings). <p> Future work will show how to overcome these problems. One avenue of research is to extend our axiomatization of w such that principal solutions exist; perhaps by identifying recursive behaviours with their infinite unfolding just as done in <ref> [CC91] </ref> for recursive types.
Reference: [Hen93] <author> Fritz Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 253-289, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Finding a solution to C-constraints is feasible as shown in [NN94b]. It is harder to solve S-constraints and in fact they can be seen as a special case of semi-unification; the relationship between type inference for polymorphic languages and semiunification is discussed in <ref> [Hen93] </ref>. The purpose of the present paper is to present a sound and complete reconstruction algorithm. This algorithm also returns S-constraints together with the C-constraints, albeit in a different version than [NN94b]. However, the problem of finding an algorithm for solving these constraints remains.
Reference: [JG91] <author> Pierre Jouvelot and David K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: This algorithm works by unification, but since our behaviours constitute a non-free algebra (due to the laws imposed on them) this approach is not immediately feasible in our framework. Instead we employ the technique of algebraic reconstruction <ref> [JG91, TJ92a] </ref>; that is the algorithm unifies the free part of the type structure and generates constraints to cater for the non-free parts. This idea is carried out in [NN94b], where a reconstruction algorithm is presented which is sound but not complete. <p> 7 by first unifying b 1 with b 0 1 and then unifying b 2 with b 0 2 for then we will lose the possibility that say b 1 = b 0 2 = * and b 0 The remedy (as done in [TJ92a] and [NN94b] but not in <ref> [JG91] </ref> where no unification is performed) is to introduce the notion of simplicity: a type is simple if all the behaviours it contains are behaviour variables (so t 1 ! b t 2 is simple iff t 1 and t 2 are both simple and b = fi for some fi); <p> One difference from the traditional formulation of W is that we generate so-called C-constraints that then have to be solved. This is a consequence of our behaviours being a non-free algebra and is an phenomenon found also in <ref> [JG91] </ref>. Another and major difference from the traditional formulation, as well as that of [JG91], is that we generate so-called S-constraints that also have to be solved. This phenomenon is needed because our C-constraints would seem not to have principal solutions (as was discussed in Section 2). <p> This is a consequence of our behaviours being a non-free algebra and is an phenomenon found also in <ref> [JG91] </ref>. Another and major difference from the traditional formulation, as well as that of [JG91], is that we generate so-called S-constraints that also have to be solved. This phenomenon is needed because our C-constraints would seem not to have principal solutions (as was discussed in Section 2).
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Applications of such information are demonstrated in [NN94a] and [NN94c]. The question remains: how to implement the inference system, i.e. how to reconstruct the types and behaviours? It seems suitable to use a modified version of algorithm W <ref> [Mil78] </ref>. This algorithm works by unification, but since our behaviours constitute a non-free algebra (due to the laws imposed on them) this approach is not immediately feasible in our framework. <p> Suppose that E ` e : t & b. Then also E 0 ` e : t & b. 4 A reconstruction algorithm Our goal is to produce an algorithm which works in the spirit of the well-known algorithm W <ref> [Mil78] </ref>.
Reference: [NN93] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> From CML to process algebras. </title> <booktitle> In CONCUR '93, volume 715 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> An expanded version appears as DAIMI technical report no. PB-433. </note>
Reference-contexts: The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking 1 place during execution. One such representation is behaviours, a kind of process algebra expressions. In <ref> [NN93] </ref> and [NN94a] inference systems are developed that extend the usual notion of types with a formal way of linking behaviours to the syntax of programs. Applications of such information are demonstrated in [NN94a] and [NN94c].
Reference: [NN94a] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking 1 place during execution. One such representation is behaviours, a kind of process algebra expressions. In [NN93] and <ref> [NN94a] </ref> inference systems are developed that extend the usual notion of types with a formal way of linking behaviours to the syntax of programs. Applications of such information are demonstrated in [NN94a] and [NN94c]. <p> One such representation is behaviours, a kind of process algebra expressions. In [NN93] and <ref> [NN94a] </ref> inference systems are developed that extend the usual notion of types with a formal way of linking behaviours to the syntax of programs. Applications of such information are demonstrated in [NN94a] and [NN94c]. The question remains: how to implement the inference system, i.e. how to reconstruct the types and behaviours? It seems suitable to use a modified version of algorithm W [Mil78]. <p> Overview of paper In Section 2 we introduce the basic concepts; apart from the treatment of type schemes and from the introduction of S-constraints and from the notion of "downwards closure" they are pretty standard. In Section 3 we present our version of the inference system from <ref> [NN94a] </ref>. In Section 4 the reconstruction algorithm W is presented. In Section 5 the algorithm is shown to be sound. In Section 6 we motivate our non-standard notion of type schemes, leading to a slightly different (but equivalent) inference system. <p> This is much like ML, the concurrent aspects being taken care of by the constants c. Some of these will be listed in Section 3 together with their types. We refer to <ref> [NN94a] </ref> for a more thorough motivation. Free and bound variables. We shall employ two kinds of variables, and use fl to range over either kind: behaviour variables fi and type variables ff. <p> Thus it makes sense to define (RECfi:b)[ ] = RECfi:b [ ] where fi 62 var ( ). Just as in <ref> [NN94a, Table 3] </ref> we impose a preorder w on behaviours. The intuition behind b 1 wb 2 is that any action performed by b 2 can be performed by b 1 as well (but not necessarily vice-versa). <p> chan ! fi 1 ff com fi 2 ; [fi 1 w*; fi 2 w?ff]) CTypeOf (channel) = 8;:(Unit ! fi ff chan; [fiwff CHAN]) CTypeOf (fork) = 8;:((Unit ! fi 1 ff) ! fi 2 Unit; fi 2 wFORK fi 1 ) The inference system is much as in <ref> [NN94a] </ref>, but there are the following differences: (i) we use the non-standard notation for type schemes that was introduced in Section 2; (ii) we have removed regions from behaviours; (iii) we 6 E ` x : t & b if E (x) O t and bw* E ` c : t <p> :t 1 ] ` e 0 : t & b 0 if bwb 1 ; b 0 where F = (fv (E) [ fv (b 1 )) " fv (t 1 ) avoid coding the constraints present in the definition of CTypeOf () into the types (as in TypeOf of <ref> [NN94a] </ref>). Example 3.1 Consider the following CML-program map2, a version of the well-known map function where a process is forked for each tail while the forking process itself works on the head.
Reference: [NN94b] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Constraints for polymorphic behaviours of concurrent ML. </title> <booktitle> In Constraints in Computational Logics (CCL '94), volume 845 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: Instead we employ the technique of algebraic reconstruction [JG91, TJ92a]; that is the algorithm unifies the free part of the type structure and generates constraints to cater for the non-free parts. This idea is carried out in <ref> [NN94b] </ref>, where a reconstruction algorithm is presented which is sound but not complete. The algorithm returns two kind of constraints: C-constraints and S-constraints. <p> Using S-constraints is not a standard tool when analysing polymorphic languages; they seem to be needed because the C-constraints apparently lack a "principal solution property" (a phenomenon well-known in unification theory). Finding a solution to C-constraints is feasible as shown in <ref> [NN94b] </ref>. It is harder to solve S-constraints and in fact they can be seen as a special case of semi-unification; the relationship between type inference for polymorphic languages and semiunification is discussed in [Hen93]. The purpose of the present paper is to present a sound and complete reconstruction algorithm. <p> The purpose of the present paper is to present a sound and complete reconstruction algorithm. This algorithm also returns S-constraints together with the C-constraints, albeit in a different version than <ref> [NN94b] </ref>. However, the problem of finding an algorithm for solving these constraints remains. Overview of paper In Section 2 we introduce the basic concepts; apart from the treatment of type schemes and from the introduction of S-constraints and from the notion of "downwards closure" they are pretty standard. <p> This inference system allows us to prove the completeness of W in Section 7. In Section 8 we discuss our choice of generalisation strategy for W and compare it to the one used in <ref> [NN94b] </ref>. Then in Section 9 we show how to solve the constraints generated for some special cases; this solution in effect loses all polymorphism. Section 10 concludes. 2 2 Preliminaries CML expressions. <p> Accordingly we do not distinguish between behaviours which are equivalent modulo alpha-conversion, so RECfi:b is considered identical to RECfi 0 :b [fi 7! fi 0 ] if fi 0 does not occur in b (in <ref> [NN94b, Table 3] </ref> this was listed as axiom R2). Thus it makes sense to define (RECfi:b)[ ] = RECfi:b [ ] where fi 62 var ( ). Just as in [NN94a, Table 3] we impose a preorder w on behaviours. <p> The value of CTypeOf () on some constants is tabulated below (adopted from <ref> [NN94b, Table 4] </ref>). <p> always be done "compositionally" 7 by first unifying b 1 with b 0 1 and then unifying b 2 with b 0 2 for then we will lose the possibility that say b 1 = b 0 2 = * and b 0 The remedy (as done in [TJ92a] and <ref> [NN94b] </ref> but not in [JG91] where no unification is performed) is to introduce the notion of simplicity: a type is simple if all the behaviours it contains are behaviour variables (so t 1 ! b t 2 is simple iff t 1 and t 2 are both simple and b = <p> The reconstruction algorithm from <ref> [NN94b] </ref> carries constraints around, together with type schemes in kernel form. Our algorithm carries no constraints in the environment, but in order to preserve soundness the type schemes have to be enriched. This is informally illustrated by the following example. <p> On the positive side (2) still holds so W ud is sound. On the negative side (5) does not hold; in fact completeness fails because we have found a well-typed expression upon which W ud does not succeed. The algorithm presented in <ref> [NN94b] </ref> essentially works similar to W ud . 9 Solving the constraints In this section we discuss how to solve the constraints generated by Algorithm W . <p> This is also the way that C-constraints are solved in <ref> [NN94b] </ref>. 10 Conclusion In this paper we have adapted the traditional algorithm W to our type and behaviour system. The algorithm has been implemented and has provided quite illuminating analyses of example CML programs.
Reference: [NN94c] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Static and dynamic processor allocation for higher-order concurrent languages. </title> <type> Technical Report PB-483, DAIMI, </type> <institution> University of Aarhus, Denmark, </institution> <year> 1994. </year> <note> Also see this volume. </note>
Reference-contexts: One such representation is behaviours, a kind of process algebra expressions. In [NN93] and [NN94a] inference systems are developed that extend the usual notion of types with a formal way of linking behaviours to the syntax of programs. Applications of such information are demonstrated in [NN94a] and <ref> [NN94c] </ref>. The question remains: how to implement the inference system, i.e. how to reconstruct the types and behaviours? It seems suitable to use a modified version of algorithm W [Mil78].
Reference: [PGM90] <author> Sanjiva Prasad, Alessandro Giacalone, and Prateek Mishra. </author> <title> Operational and algebraic semantics for Facile: A symmetric integration of concurrent and functional programming. </title> <booktitle> In ICALP 90, </booktitle> <year> 1990. </year>
Reference-contexts: Our research has been motivated by the integration of the functional and concurrent programming paradigms. Example programming languages are CML [Rep91] that extends Standard ML with primitives for concurrency, Facile <ref> [PGM90] </ref> that follows a similar approach but more directly contains syntax for expressing CCS-like process composition, and LCS [BS94]. The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking 1 place during execution.
Reference: [Rep91] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Our research has been motivated by the integration of the functional and concurrent programming paradigms. Example programming languages are CML <ref> [Rep91] </ref> that extends Standard ML with primitives for concurrency, Facile [PGM90] that follows a similar approach but more directly contains syntax for expressing CCS-like process composition, and LCS [BS94].
Reference: [Sie89] <author> Jorg H. Siekmann. </author> <title> Unification theory. </title> <journal> J. Symbolic Computation, </journal> <volume> 7 </volume> <pages> 207-274, </pages> <year> 1989. </year>
Reference-contexts: This phenomenon is needed because our C-constraints would seem not to have principal solutions (as was discussed in Section 2). This in not the case for the traditional "free" unification of Standard ML, but it is a phenomenon well-known in unification theory <ref> [Sie89] </ref>. As a consequence we have to ensure that the different solutions to the C-constraints (concerning the polymorphic definition and its instantiations) are comparable and this is the purpose of the S-constraints.
Reference: [TJ92a] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programing, </journal> <volume> 2(3) </volume> <pages> 245-271, </pages> <year> 1992. </year>
Reference-contexts: This algorithm works by unification, but since our behaviours constitute a non-free algebra (due to the laws imposed on them) this approach is not immediately feasible in our framework. Instead we employ the technique of algebraic reconstruction <ref> [JG91, TJ92a] </ref>; that is the algorithm unifies the free part of the type structure and generates constraints to cater for the non-free parts. This idea is carried out in [NN94b], where a reconstruction algorithm is presented which is sound but not complete. <p> this cannot always be done "compositionally" 7 by first unifying b 1 with b 0 1 and then unifying b 2 with b 0 2 for then we will lose the possibility that say b 1 = b 0 2 = * and b 0 The remedy (as done in <ref> [TJ92a] </ref> and [NN94b] but not in [JG91] where no unification is performed) is to introduce the notion of simplicity: a type is simple if all the behaviours it contains are behaviour variables (so t 1 ! b t 2 is simple iff t 1 and t 2 are both simple and
Reference: [TJ92b] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> The type and effect discipline. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-173, </pages> <year> 1992. </year> <note> Also see Information and Computation 111 2, 1994. 16 </note>
Reference-contexts: The former case will arise if ff chan is handled as ff list; whereas the latter case will arise if ff chan is handled by the techniques for ff ref developed in <ref> [TJ92b] </ref> and [BD93]. 13 8.2 An algorithm taking the upwards closure Next define a version of W , to be called W ud for upwards and downwards closure, where N Q is defined in such a way that fi _ wb 2 C 1 and (fv (b) [ ffig) " N <p> This problem is closely related to the question of whether all expressions typeable in (C)ML are also typable in our system. More precisely consider an expression e that is typeable in Standard ML when types ff chan are handled by the techniques for ff ref developed in <ref> [TJ92b] </ref>; the (open) question then is whether this expression is always typeable in our system. If this should ever fail it means that the causality espressed in the behaviours constitute an unwarranted restriction upon the language. Future work will show how to overcome these problems.
References-found: 15

