URL: ftp://ftp.cs.washington.edu/homes/chambers/predicate-classes.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/predicate-classes.html
Root-URL: 
Title: P r e d i c a t e C l a s s e s  
Author: Craig Chambers 
Affiliation: Department of Computer Science and Engineering University of Washington  
Date: July 1993  
Note: To appear in ECOOP 93 Conference Proceedings, Kaiserstautern, Germany,  
Abstract: Predicate classes are a new linguistic construct designed to complement normal classes in object-oriented languages. Like a normal class, a predicate class has a set of superclasses, methods, and instance variables. However, unlike a normal class, an object is automatically an instance of a predicate class whenever it satisfies a predicate expression associated with the predicate class. The predicate expression can test the value or state of the object, thus supporting a form of implicit property-based classification that augments the explicit type-based classification provided by normal classes. By associating methods with predicate classes, method lookup can depend not only on the dynamic class of an argument but also on its dynamic value or state. If an object is modified, the property-based classification of an object can change over time, implementing shifts in major behavior modes of the object. A version of predicate classes has been designed and implemented in the context of the Cecil language.
Abstract-found: 1
Intro-found: 1
Reference: [Apple 92] <author> Dylan, </author> <title> an Object-Oriented Dynamic Language. </title> <institution> Apple Computer, </institution> <month> April, </month> <year> 1992. </year>
Reference-contexts: A few object-oriented languages, such as CLOS [Bobrow et al. 88] and Dylan <ref> [Apple 92] </ref>, can dispatch on the identity of an argument, but cannot easily dispatch on a more general condition of an argument, such as being a negative number or an iconified window; prototype-based languages are similar in this regard. 17 5.2 Sets and Polymethods in LAURE The LAURE language is an
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: A few object-oriented languages, such as CLOS <ref> [Bobrow et al. 88] </ref> and Dylan [Apple 92], can dispatch on the identity of an argument, but cannot easily dispatch on a more general condition of an argument, such as being a negative number or an iconified window; prototype-based languages are similar in this regard. 17 5.2 Sets and Polymethods in
Reference: [Caseau 91] <author> Yves Caseau. </author> <title> An Object-Oriented Language for Advanced Applications. </title> <booktitle> In Proceedings of TOOLS USA 91, </booktitle> <year> 1991. </year> <month> 20 </month>
Reference-contexts: but cannot easily dispatch on a more general condition of an argument, such as being a negative number or an iconified window; prototype-based languages are similar in this regard. 17 5.2 Sets and Polymethods in LAURE The LAURE language is an unusual hybrid language with object-oriented, rule-based, and constraint-based features <ref> [Caseau 91, Caseau & Silverstein 92, Caseau & Perron 93] </ref>. Of particular interest is LAUREs ability to define sets of objects and to associate methods (called polymethods) with all members of a set.
Reference: [Caseau & Silverstein 92] <author> Yves Caseau and Glenn Silverstein. </author> <title> Some Original Features of the LAURE Language. </title> <booktitle> In Proceedings of the OOPSLA 92 Workshop on Object-Oriented Programming Languages: The Next Generation, </booktitle> <pages> pp. 35-43, </pages> <address> Vancouver, Canada, </address> <month> October, </month> <year> 1992. </year>
Reference-contexts: but cannot easily dispatch on a more general condition of an argument, such as being a negative number or an iconified window; prototype-based languages are similar in this regard. 17 5.2 Sets and Polymethods in LAURE The LAURE language is an unusual hybrid language with object-oriented, rule-based, and constraint-based features <ref> [Caseau 91, Caseau & Silverstein 92, Caseau & Perron 93] </ref>. Of particular interest is LAUREs ability to define sets of objects and to associate methods (called polymethods) with all members of a set.
Reference: [Caseau & Perron 93] <author> Yves Caseau and Laurent Perron. </author> <title> Attaching Second-Order Types to Methods in an Object-Oriented Language. </title> <booktitle> In In ECOOP 93 Conference Proceedings, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July, </month> <year> 1993. </year>
Reference-contexts: but cannot easily dispatch on a more general condition of an argument, such as being a negative number or an iconified window; prototype-based languages are similar in this regard. 17 5.2 Sets and Polymethods in LAURE The LAURE language is an unusual hybrid language with object-oriented, rule-based, and constraint-based features <ref> [Caseau 91, Caseau & Silverstein 92, Caseau & Perron 93] </ref>. Of particular interest is LAUREs ability to define sets of objects and to associate methods (called polymethods) with all members of a set.
Reference: [Chambers et al. 89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: For example, the following Haskell examples define some standard operations on numbers and lists: -- return the sign of the argument 1. In a classless language like Cecil, the implementation can maintain internal data structures that act like classes, as is done in the SELF implementation <ref> [Chambers et al. 89, Chambers 92a] </ref>. 13 sign x | x &lt; 0 = -1 | x == 0 = 0 -- map the unary function f over the argument list, returning a list of results map f [] = [] -- take a pair of lists of equal length and
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference: [Chambers 92a] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, report STAN-CS-92-1420, </institution> <month> March, </month> <year> 1992. </year>
Reference-contexts: For example, the following Haskell examples define some standard operations on numbers and lists: -- return the sign of the argument 1. In a classless language like Cecil, the implementation can maintain internal data structures that act like classes, as is done in the SELF implementation <ref> [Chambers et al. 89, Chambers 92a] </ref>. 13 sign x | x &lt; 0 = -1 | x == 0 = 0 -- map the unary function f over the argument list, returning a list of results map f [] = [] -- take a pair of lists of equal length and
Reference: [Chambers 92b] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: To the extent that these transient states are important in the application domain, predicate classes can help in modelling and implementing them. Predicate classes are a relatively language-independent idea. For concreteness, however, we have been exploring them in the context of the Cecil language <ref> [Chambers 92b, Chambers 93] </ref>. The next section of this paper presents a brief overview of Cecil. Section 3 then describes in more detail the semantics of predicate classes as included in Cecil, and section 4 presents several examples of predicate objects at work. <p> More information on the Cecil language is available in other papers <ref> [Chambers 92b, Chambers 93] </ref>. 2.1 Objects Cecil is classless, associating methods directly with objects and allowing objects to inherit directly from other objects. <p> If a method is prefixed with the private keyword, access to the method is restricted to methods associated with its argument specializers. Details on encapsulation and the intended programming model for Cecil may be found in an earlier paper <ref> [Chambers 92b] </ref>. 2.3 Fields Instance variables and class variables are realized in Cecil using the field construct. <p> To compensate for the extra separation between objects and methods, Cecil relies on the programming environment to show a view of the program in which methods are directly associated with their specializing objects <ref> [Chambers 92b] </ref>. 4.2 Attributes of People Predicate objects can help organize code for an abstraction that can be considered to have multiple independent attributes and behavior that depends on the state of the attributes.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical report #93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March, </month> <year> 1993. </year>
Reference-contexts: To the extent that these transient states are important in the application domain, predicate classes can help in modelling and implementing them. Predicate classes are a relatively language-independent idea. For concreteness, however, we have been exploring them in the context of the Cecil language <ref> [Chambers 92b, Chambers 93] </ref>. The next section of this paper presents a brief overview of Cecil. Section 3 then describes in more detail the semantics of predicate classes as included in Cecil, and section 4 presents several examples of predicate objects at work. <p> More information on the Cecil language is available in other papers <ref> [Chambers 92b, Chambers 93] </ref>. 2.1 Objects Cecil is classless, associating methods directly with objects and allowing objects to inherit directly from other objects.
Reference: [Cook 89] <author> W. R. Cook. </author> <title> A Proposal for Making Eiffel Type-Safe. </title> <booktitle> In ECOOP 89 Conference Proceedings, </booktitle> <pages> pp. 57-70, </pages> <publisher> Cambridge University Press, </publisher> <month> July, </month> <year> 1989. </year>
Reference-contexts: However, this has two undesirable consequences. First, static type checking of operations in the presence of the undefine construct is quite difficult <ref> [Cook 89] </ref>, leading to a complex, two-phase typing algorithm [Meyer 92].
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In those situations where predicate objects provide sufficient functionality, we believe they are preferable to dynamic inheritance since the purpose and dynamic behavior of predicate objects is clearer. A related mechanism is the become: primitive in Smalltalk-80 1 <ref> [Goldberg & Robson 83] </ref>. This operation allows the identities of two objects to be swapped, and so is more than powerful enough to change the representation and implementation of an object.
Reference: [Hamer 92] <author> John Hamer. </author> <title> Un-Mixing Inheritance with Classifiers. In Multiple Inheritance and Multiple Subtyping: </title> <booktitle> Position Papers of the ECOOP 92 Workshop W1, </booktitle> <pages> pp. 6-9, </pages> <address> Utrect, the Netherlands, June/July, </address> <year> 1992. </year> <note> Also available as Working Paper WP-23, Markku Sakkinen, ed., </note> <institution> Dept. of Computer Science and Information Systems, University of Jyvskyl, Finland, </institution> <month> May, </month> <year> 1992. </year>
Reference-contexts: In LAURE, some of the specificity relationships among sets (the subsumption relation) is inferred automatically based on the structure of the set specifications, while all inheritance relationships among predicate classes must be specified explicitly. 5.3 Classifiers in Kea The Kea language is a functional object-oriented language based on multiple dispatching <ref> [Mugridge et al. 91, Hamer 92] </ref>. Kea supports a notion of dynamic classification of objects. A class may be explicitly divided into a group of mutually-exclusive subclasses, and instances of the class can be classified into one of the disjoint subclasses.
Reference: [Hlzle et al. 91] <author> Urs Hlzle, Bay-Wei Chang, Craig Chambers, Ole Agesen, and David Ungar. </author> <title> The SELF Manual, </title> <note> Version 1.1. Unpublished manual, </note> <month> February, </month> <year> 1991. </year>
Reference-contexts: As described in section 3.8, an optimizing implementation might choose to track inheritance from predicate classes in other ways for faster method lookup. 5.5 Dynamic Inheritance in SELF and Garnet SELF is a prototype-based language with a simple and uniform object model <ref> [Ungar & Smith 87, Hlzle et al. 91] </ref>. One consequence of SELFs uniformity is that an objects parent slots, like other data slots, may be assigned new values at run-time. An assignment to a parent slot effectively changes an objects inheritance at run-time.
Reference: [Hudak et al. 92] <author> Paul Hudak, Simon Peyton Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzmn, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the Programming Language Haskell, Version 1.2. </title> <booktitle> In SIGPLAN Notices 27(5), </booktitle> <month> May, </month> <year> 1992. </year>
Reference-contexts: Each example highlights some strengths and/or weaknesses of predicate objects not previously addressed. 4.1 Pattern Matching-Style Functions Predicate objects can be used to emulate some of the functionality of pattern matching-based function definitions, as found in functional languages such as Standard ML [Milner et al. 90] and Haskell <ref> [Hudak et al. 92] </ref>. With pattern matching, a programmer can write multiple versions of a function, with the system automatically selecting the proper version of the function to call based on the dynamic value of the function arguments.
Reference: [LaLonde et al. 86] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An Exemplar Based Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 322-330, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Additionally, become: is difficult to implement efficiently without slowing down other basic operations of the system. 1. Smalltalk-80 is a trademark of ParcPlace Systems, Inc. 19 5.6 Other Related Work Several other systems have constructs similar to aspects of predicate classes. Boolean classes [McAllester & Zabih 86], Exemplars <ref> [LaLonde et al. 86] </ref>, and Clovers [Stein 91] all address the issue of forming automatic combination or union subclasses to avoid combinatorial explosion and better organize methods; in none of these systems is the classification based on an objects state, however.
Reference: [Lea 92] <author> Doug Lea. </author> <type> Personal communication. </type> <month> December, </month> <year> 1992. </year>
Reference-contexts: Type checking with such state-dependent interfaces might require some more interesting analysis akin to typestate checking in the Hermes language [Strom & Yemini 86, Strom et al. 91] or would fall back on run-time checking for state-dependent operations. Lea is exploring a similar idea which he calls fine-grained types <ref> [Lea 92] </ref>. 12 3.8 Implementation Strategies A straightforward implementation of predicate objects is not difficult. Each object allocates enough space for any field it might inherit from a predicate object, and method lookup is augmented with additional evaluations of predicate expressions for methods attached to predicate objects.
Reference: [McAllester & Zabih 86] <author> David McAllester and Ramin Zabih. </author> <title> Boolean Classes. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 417-428, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Additionally, become: is difficult to implement efficiently without slowing down other basic operations of the system. 1. Smalltalk-80 is a trademark of ParcPlace Systems, Inc. 19 5.6 Other Related Work Several other systems have constructs similar to aspects of predicate classes. Boolean classes <ref> [McAllester & Zabih 86] </ref>, Exemplars [LaLonde et al. 86], and Clovers [Stein 91] all address the issue of forming automatic combination or union subclasses to avoid combinatorial explosion and better organize methods; in none of these systems is the classification based on an objects state, however.
Reference: [Meyer 91] <author> Bertrand Meyer. </author> <title> Static Typing for Eiffel. In An Eiffel Collection. </title> <type> Technical report #TR-EI-20/EC, </type> <institution> Interactive Software Engineering, Goleta, California, </institution> <year> 1991. </year>
Reference-contexts: Similarly, invoking the widen operation on a square will violate the specification of the square. In the Eiffel community, the recommended solution is to undefine the add_vertex operation in the rectangle class and to undefine the widen operation in the square class, thus disallowing illegal modifications <ref> [Meyer 91] </ref>. However, this has two undesirable consequences. First, static type checking of operations in the presence of the undefine construct is quite difficult [Cook 89], leading to a complex, two-phase typing algorithm [Meyer 92].
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: However, this has two undesirable consequences. First, static type checking of operations in the presence of the undefine construct is quite difficult [Cook 89], leading to a complex, two-phase typing algorithm <ref> [Meyer 92] </ref>. Second, the drawing editor application either must realize that certain kinds of polygons cannot have vertices added to them (as must users of the application), or the editor must construct only polygons, forgoing any functionality and performance advantages of the more specialized subclasses.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Each example highlights some strengths and/or weaknesses of predicate objects not previously addressed. 4.1 Pattern Matching-Style Functions Predicate objects can be used to emulate some of the functionality of pattern matching-based function definitions, as found in functional languages such as Standard ML <ref> [Milner et al. 90] </ref> and Haskell [Hudak et al. 92]. With pattern matching, a programmer can write multiple versions of a function, with the system automatically selecting the proper version of the function to call based on the dynamic value of the function arguments.
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year> <note> A later version published in ECOOP 91 Conference Proceedings, </note> <institution> Geneva, Switzerland, </institution> <month> July, </month> <year> 1991. </year>
Reference-contexts: In LAURE, some of the specificity relationships among sets (the subsumption relation) is inferred automatically based on the structure of the set specifications, while all inheritance relationships among predicate classes must be specified explicitly. 5.3 Classifiers in Kea The Kea language is a functional object-oriented language based on multiple dispatching <ref> [Mugridge et al. 91, Hamer 92] </ref>. Kea supports a notion of dynamic classification of objects. A class may be explicitly divided into a group of mutually-exclusive subclasses, and instances of the class can be classified into one of the disjoint subclasses.
Reference: [Myers et al. 92] <author> Brad A. Myers, Dario A. Giuse, and Brad Vander Zanden. </author> <title> Declarative Programming in a Prototype-Instance System: Object-Oriented Programming Without Writing Methods. </title> <booktitle> In OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 184-200, </pages> <address> Vancouver, Canada, </address> <month> October, </month> <year> 1992. </year> <note> Published as SIGPLAN Notices 27(10), </note> <month> October, </month> <year> 1992. </year>
Reference-contexts: Dynamic inheritance has been used in SELF to implement mutable objects with several distinct behavior modes, such as binary trees with empty and non-empty states [Ungar et al. 91]. The example in section 4.4 was inspired by this use of dynamic inheritance in SELF. The Garnet system <ref> [Myers et al. 92] </ref> includes a similar mechanism, also called dynamic inheritance but implemented differently, to effect wholesale changes in the implementation of an objects behavior.
Reference: [Stein 91] <author> Lynn A. Stein. </author> <title> A Unified Methodology for Object-Oriented Programming. In Inheritance Hierarchies in Knowledge Representation and Programming Languages, </title> <publisher> John Wiley & Sons, </publisher> <year> 1991. </year>
Reference-contexts: Smalltalk-80 is a trademark of ParcPlace Systems, Inc. 19 5.6 Other Related Work Several other systems have constructs similar to aspects of predicate classes. Boolean classes [McAllester & Zabih 86], Exemplars [LaLonde et al. 86], and Clovers <ref> [Stein 91] </ref> all address the issue of forming automatic combination or union subclasses to avoid combinatorial explosion and better organize methods; in none of these systems is the classification based on an objects state, however.
Reference: [Strom & Yemini 86] <author> Robert E. Strom and Shaula Alexander Yemini. Typestate: </author> <title> A Programming Language Concept for Enhancing Software Reliability. </title> <journal> In IEEE Transactions on Software Engineering 12(1), </journal> <pages> pp. 157-171, </pages> <month> January, </month> <year> 1986. </year>
Reference-contexts: For example, a stack object might be subdivided into empty_stack and non_empty_stack predicate objects, but only the non_empty_stack predicate object would support a pop operation. Type checking with such state-dependent interfaces might require some more interesting analysis akin to typestate checking in the Hermes language <ref> [Strom & Yemini 86, Strom et al. 91] </ref> or would fall back on run-time checking for state-dependent operations. Lea is exploring a similar idea which he calls fine-grained types [Lea 92]. 12 3.8 Implementation Strategies A straightforward implementation of predicate objects is not difficult.
Reference: [Strom et al. 91] <author> Robert E. Strom, David F. Bacon, Arthur P. Goldberg, Andy Lowry, Daniel M. Yellin, Shaula Alexander Yemini. </author> <title> Hermes, A Language for Distributed Computing. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year> <month> 21 </month>
Reference-contexts: For example, a stack object might be subdivided into empty_stack and non_empty_stack predicate objects, but only the non_empty_stack predicate object would support a pop operation. Type checking with such state-dependent interfaces might require some more interesting analysis akin to typestate checking in the Hermes language <ref> [Strom & Yemini 86, Strom et al. 91] </ref> or would fall back on run-time checking for state-dependent operations. Lea is exploring a similar idea which he calls fine-grained types [Lea 92]. 12 3.8 Implementation Strategies A straightforward implementation of predicate objects is not difficult.
Reference: [Touretzky 86] <author> D. Touretzky. </author> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1986. </year>
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: As described in section 3.8, an optimizing implementation might choose to track inheritance from predicate classes in other ways for faster method lookup. 5.5 Dynamic Inheritance in SELF and Garnet SELF is a prototype-based language with a simple and uniform object model <ref> [Ungar & Smith 87, Hlzle et al. 91] </ref>. One consequence of SELFs uniformity is that an objects parent slots, like other data slots, may be assigned new values at run-time. An assignment to a parent slot effectively changes an objects inheritance at run-time.
Reference: [Ungar et al. 91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Hlzle. </author> <title> Organizing Programs without Classes. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Consequently, the object can inherit different methods and exhibit different behavior. This dynamic inheritance allows part of an objects implementation to change at run-time. Dynamic inheritance has been used in SELF to implement mutable objects with several distinct behavior modes, such as binary trees with empty and non-empty states <ref> [Ungar et al. 91] </ref>. The example in section 4.4 was inspired by this use of dynamic inheritance in SELF. The Garnet system [Myers et al. 92] includes a similar mechanism, also called dynamic inheritance but implemented differently, to effect wholesale changes in the implementation of an objects behavior.
Reference: [Wadler 87] <author> Phillip Wadler. </author> <title> Views: A Way for Pattern Matching to Cohabit with Data Abstraction. </title> <booktitle> In Proceedings of the Fourteenth ACM Conference on Principles of Programming Languages. </booktitle> <address> Munich, Germany, </address> <month> January, </month> <year> 1987. </year>
Reference-contexts: Similarly, patterns can only range over concrete data types, not abstract data types, although Wadler has proposed an extension of pattern matching to support abstract data types <ref> [Wadler 87] </ref>. Predicate objects can be ordered in terms of specificity, and the system with use this information to determine the most appropriate implementation of a method to call. Functional languages typically try functions in the order they were defined, invoking the first version whose patterns match. 1.
Reference: [Yelland 92] <author> Phillip M. Yelland. </author> <title> Experimental Classification Facilities for Smalltalk. </title> <booktitle> In OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 235-246, </pages> <address> Vancouver, Canada, </address> <month> October, </month> <year> 1992. </year> <note> Published as SIGPLAN Notices 27(10), </note> <month> October, </month> <year> 1992. </year>
Reference-contexts: Since Kea is a functional language, it does not address the issue of an object whose classification varies over time. 5.4 Term Classification Yelland developed an experimental extension of Smalltalk that supported term classification <ref> [Yelland 92] </ref>. Yelland introduced two new kinds of class-like constructs into Smalltalk: primitive concepts and defined concepts: Primitive concepts are used for explicit classification of objects. An object is a member of a primitive concept only when explicitly stated. Defined concepts are used for implicit property-based classification.
References-found: 31

