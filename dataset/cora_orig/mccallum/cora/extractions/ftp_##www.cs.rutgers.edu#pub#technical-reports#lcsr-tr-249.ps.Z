URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-249.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Title: Defining Flow Sensitivity in Data Flow Problems  
Author: Thomas J. Marlowe Barbara G. Ryder Michael G. Burke 
Date: July 17, 1995  
Abstract: Since Banning first introduced flow sensitivity in 1978, the term has been used to indicate hard or complex data flow problems, but there is no consensus as to its precise meaning. We look at Banning's original uses of the term and some interpretations they have generated. Then we consider the multiplicity of meanings in more recent interpro-cedural analyses, categorizing a number of data flow problems. We also classify several recent interprocedural approximation techniques with respect to properties related to sensitivity and discuss additional data flow problem properties. Finally, we propose a definition for flow sensitivity that appears to capture much of the original intent and current use.
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: If the functions of F also preserve meets, then D is called distributive. Intuitively, G is the control flow graph <ref> [ASU86] </ref> or call multigraph [Hec77] with root at , L a lattice of data flow solutions, M the assignment of transition functions to edges, and the entry solution at ; F is usually not represented explicitly. <p> Standard Data Flow Problems In the rest of this paper, we will be using a number of standard data flow problems. The best known data flow problems are the four classical intraprocedural problems: Reaching Definitions, Live Uses, Available Expressions, and Very Busy Uses <ref> [ASU86] </ref>.
Reference: [Ban78] <author> J. B. Banning. </author> <title> A Method for Determining the Side Effects of Procedure Calls. </title> <type> PhD thesis, </type> <institution> Stanford Linear Accelerator Center, Stanford U., Stanford, </institution> <address> CA 94305, </address> <month> August </month> <year> 1978. </year>
Reference-contexts: 1 Introduction The distinction between flow sensitive and flow insensitive data flow problems was introduced by Banning <ref> [Ban78, Ban79] </ref>. Although no uniform definition has ever been given, the terms have been used as shorthand in expressing the locality or summarizability of information, the applicability of algorithms, and the difficulty of describing and computing the data flow framework. <p> The real difficulty is that f e in the Merged Flow diagram will modify bound sets corresponding to parameters of C, and in the Straight-Line Flow will modify bound sets for B; thus their flow functions f e will be incomparable.) Banning <ref> [Ban78, Ban79] </ref> gives two problems as illustrative of flow insensitive data flow, Mod and Ref, which are essentially Interprocedural MayBeDefined and MayBeReferenced, respectively (Banning's problems were originally defined at call sites). It is not however clear that these problems are flow insensitive by the Algebraic Criterion. <p> This leads him to the following Collecting Criterion [CC]: A data flow problem is flow insensitive if "the side effect of the whole [structure in a program] can be determined by processing the whole and later determining the side effects of the parts, and taking their union" <ref> [Ban78] </ref>; that is, if the individual contributions of substructures to the global solution are unioned regardless of flow structure.
Reference: [Ban79] <author> J. B. Banning. </author> <title> An efficent way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> Conf. Rec. Sixth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: 1 Introduction The distinction between flow sensitive and flow insensitive data flow problems was introduced by Banning <ref> [Ban78, Ban79] </ref>. Although no uniform definition has ever been given, the terms have been used as shorthand in expressing the locality or summarizability of information, the applicability of algorithms, and the difficulty of describing and computing the data flow framework. <p> variables whose definition survives along some path from procedure entry to the current program point (typically program exit); the latter, the set of variables whose definition will always survive. 3 2 Banning's First Definition: An Algebraic Criterion Attempting to give intuition for a new approach to interprocedural data flow, Banning <ref> [Ban79] </ref> gives three different, although related, informal definitions of flow insensitivity, specialized to the problems he is considering. <p> The real difficulty is that f e in the Merged Flow diagram will modify bound sets corresponding to parameters of C, and in the Straight-Line Flow will modify bound sets for B; thus their flow functions f e will be incomparable.) Banning <ref> [Ban78, Ban79] </ref> gives two problems as illustrative of flow insensitive data flow, Mod and Ref, which are essentially Interprocedural MayBeDefined and MayBeReferenced, respectively (Banning's problems were originally defined at call sites). It is not however clear that these problems are flow insensitive by the Algebraic Criterion.
Reference: [BCCH94] <author> Michael Burke, Paul Carini, J-D. Choi, and M. Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings of the 7th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: This is to be contrasted to the constant summary information of the [IC] criterion. Examples of AFS and AFI Examples of approximation methods we can categorize in this manner are the Pointer-induced MayAlias algorithms of <ref> [BCCH94, LR92] </ref>, the Def-Use analysis of C-like programs [PLR94] and MayBeModified C [LRZ93]. 11 The Burke et.al. algorithm [BCCH94] uses a functional annotation for each procedure computed without consideration of intraprocedural program structure. <p> Examples of AFS and AFI Examples of approximation methods we can categorize in this manner are the Pointer-induced MayAlias algorithms of [BCCH94, LR92], the Def-Use analysis of C-like programs [PLR94] and MayBeModified C [LRZ93]. 11 The Burke et.al. algorithm <ref> [BCCH94] </ref> uses a functional annotation for each procedure computed without consideration of intraprocedural program structure. Between each interprocedural data flow propagation pass, there is an evaluation of each of these procedural annotations, to calculate possible new intraprocedural information to be associated with each node in the call multigraph. <p> Thus, we say that this algorithm is AFS in that the procedure annotations depend on intraprocedural flow. The approximation algorithms for Pointer-induced MayAlias and MayBeModified C in [LR92, LRZ93] and the optimized algorithm using Kill information presented in <ref> [BCCH94] </ref> can be similarly classified as AFS. All of these algorithms can use memoization (i.e., table lookup) to avoid unnecessary recalculation of their annotations on repeated inputs. <p> Clearly, any problem in which information can flow only upward, or only downward, will necessarily be context insensitive; conversely, two-way flow will almost certainly make a problem context sensitive.) Further, consider approximate algorithms for pointer-induced aliasing. Landi-Ryder [LR92] is AFS and context sensitive, whereas Burke et.al <ref> [BCCH94] </ref> is AFI and context insensitive. Ruf presents two algorithms for this problem: one context sensitive and one context insensitive [Ruf95]; both are AFS. Another approach to this problem is given in [WL95]. <p> There are other properties which complicate both definition and computation of data flow problems. 14 We do change these rules if we allow pruning of infeasible paths through constant propagation, using perhaps, parameter values [WZ85]. 16 Alg-Flow Alg-Flow Insensitive Sensitive Context Insensitive Formal Bound Set ProcLastCalled Call-by-Reference MayAlias Pointer-induced MayAlias <ref> [BCCH94] </ref> Context Sensitive MayAlias Partitions [Mye81] Pointer-induced Aliasing [LR92] Constant Propagation Heterogeneous Flow Functions Callahan [Cal88] defines a pair of interprocedural data flow problems, Kill and Use, which have the properties (1) that they require examination of code within procedures beyond just initial annotations, and thus are flow sensitive in the
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data flow analysis. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The best known interprocedural problems are Formal Bound Set, MayAlias and MayBe-Modified F <ref> [Bur90, CK84, CK89, CK87] </ref>. Formal Bound Set asks, for all procedure formals, which formals can be reached over call chains from this given formal. <p> The literature refers to these calculations as procedure summary annotations; for clarity, we distinguish the terms summary and annotation below. When we discuss possible interprocedural flow sensitivity criteria, we also must acknowledge the existence of purely interprocedural problems such as Formal Bound Set and May-Alias <ref> [Bur90, CK84, CK89, CK87, Mye81] </ref>. These problems involve no intraprocedural information.
Reference: [Cal88] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> Proc. SIGPLAN'88 Symp. on Compiler Construction, </booktitle> <volume> 23(7) </volume> <pages> 47-56, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: It is possible to use representations other than the call multigraph for interprocedu-ral structure; most of these preserve some intraprocedural flow information. For example, the Program Summary Graph (PSG) <ref> [Cal88] </ref> preserves the control dependence and sequence between entry, calls, and exit statements, while discarding all other intraproce-dural structure. For a number of interesting problems it is still possible to extract in-traprocedural information in a single pass into annotations on the edges of these structures [Cal88, JPP94, LRZ93, HS94, HRB90]. <p> For a number of interesting problems it is still possible to extract in-traprocedural information in a single pass into annotations on the edges of these structures <ref> [Cal88, JPP94, LRZ93, HS94, HRB90] </ref>. Here, dependence on intraprocedural information is not necessarily completely encapsulated in the annotations, but shared between the 9 The annotations are not, however, required to be constant. 11 annotations and the control flow abstraction in the representation. <p> The former include Pointer-induced MayAlias [LR92] and MayBeModified C [LRZ93]. The latter include Inter-procedural Kill <ref> [Cal88] </ref>, Interprocedural Reaching Definitions [HS94] and Interprocedural Copy Constant Propagation [RHS95, DGS95]. Comparison Consider the utility of these various flow sensitivity measures. [IC] is quite limiting in that the procedural annotations must be, in fact, constant, not dependent on intraprocedural flow, and calculated only once. <p> Recall that representations range from the call multigraph, which contains no intraproce-dural flow information, through representations like the PSG <ref> [Cal88] </ref>, which preserve some 11 All of these algorithms handle multiple levels of indirection in pointer operations. 12 Consider describing these algorithms by regular expressions over the numbered algorithm phases. <p> We do change these rules if we allow pruning of infeasible paths through constant propagation, using perhaps, parameter values [WZ85]. 16 Alg-Flow Alg-Flow Insensitive Sensitive Context Insensitive Formal Bound Set ProcLastCalled Call-by-Reference MayAlias Pointer-induced MayAlias [BCCH94] Context Sensitive MayAlias Partitions [Mye81] Pointer-induced Aliasing [LR92] Constant Propagation Heterogeneous Flow Functions Callahan <ref> [Cal88] </ref> defines a pair of interprocedural data flow problems, Kill and Use, which have the properties (1) that they require examination of code within procedures beyond just initial annotations, and thus are flow sensitive in the sense of [IPC], and (2) that their flow functions are non-uniform, with the algebraic form
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: While both Myers and Sharir-Pnueli use the full call stack, the latter suggests using the tail of the stack as an abstraction, an adaptation used by Choi et.al for an algorithm for Pointer-induced MayAlias <ref> [CBC93, MLR + 93] </ref>. The Landi-Ryder algorithm for Pointer-induced MayAlias [LR92] uses a different approximation of context, reaching alias information at each call site. The table in Figure 7 shows the orthogonality of these two properties by naming problems with algorithms that fall in each of the entries.
Reference: [CCKT86] <author> D. Callahan, K. Cooper, K. Kennedy, and L. Torczon. </author> <title> Interprocedural constant propagation. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 20-24, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Some measure of call-site specificity can be achieved even in a context insensitive algorithm. For example, jump functions in approximate Interprocedural Constant Propagation algorithms <ref> [CCKT86, GT93] </ref> are context insensitive (but AFS) intraprocedural summaries, but pass-through and linear jump functions, among others, will result in different constant information at return sites, as a result of interprocedural effects. Thus, these approximate Interprocedural Constant Propagation algorithms are AFS, but context insensitive.
Reference: [CH92] <author> J-H Chow and W. L. Harrison III. </author> <title> Compile-time analysis of parallel programs that share memory. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <month> January </month> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Recent work discusses how to transform these multisource data flow problems into a k-tuple framework formulation [MMR95]. This model is especially useful for data flow analysis of explicitly parallel programs, where there may be control, synchronization, and call and return edges <ref> [MR93, GS93, CH92] </ref>. Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy [MR79, Dha91] (a generalization of Available Expressions); the approach has been extended to other problems [DP93]. In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems.
Reference: [CH95] <author> Paul Carini and Michael Hind. </author> <title> Flow-sensitive interprocedural constant propagation. </title> <booktitle> In Proceed--ings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-31, </pages> <month> June </month> <year> 1995. </year> <journal> SIGPLAN Notices, </journal> <volume> volume 30, number 6. </volume>
Reference-contexts: Thus, these approximate Interprocedural Constant Propagation algorithms are AFS, but context insensitive. A newer approach to interprocedural constant propagation is presented in <ref> [CH95] </ref>. There are two algorithms: the first is AFI, context insensitive, since it propagates information only downward through calls in the call multigraph, rather than also propagating back through returns.
Reference: [CK84] <author> K. Cooper and K. W. Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <booktitle> Proc. SIGPLAN'84 Symp. on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: The best known interprocedural problems are Formal Bound Set, MayAlias and MayBe-Modified F <ref> [Bur90, CK84, CK89, CK87] </ref>. Formal Bound Set asks, for all procedure formals, which formals can be reached over call chains from this given formal. <p> For bitvector problems, [CC] has the effect of Figure 3. May Problem Criterion [CC] is apparently responsible for the May Problem Criterion [MPC], a definition of flow insensitivity appearing in a number of early papers <ref> [CK84, CK89] </ref>: May, or some-path, problems are flow insensitive, Must, or all-path and no-path, problems are flow sensitive. <p> The literature refers to these calculations as procedure summary annotations; for clarity, we distinguish the terms summary and annotation below. When we discuss possible interprocedural flow sensitivity criteria, we also must acknowledge the existence of purely interprocedural problems such as Formal Bound Set and May-Alias <ref> [Bur90, CK84, CK89, CK87, Mye81] </ref>. These problems involve no intraprocedural information.
Reference: [CK87] <author> K. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <institution> Computer Science Department Technical Report TR87-61, Rice University, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: The best known interprocedural problems are Formal Bound Set, MayAlias and MayBe-Modified F <ref> [Bur90, CK84, CK89, CK87] </ref>. Formal Bound Set asks, for all procedure formals, which formals can be reached over call chains from this given formal. <p> The literature refers to these calculations as procedure summary annotations; for clarity, we distinguish the terms summary and annotation below. When we discuss possible interprocedural flow sensitivity criteria, we also must acknowledge the existence of purely interprocedural problems such as Formal Bound Set and May-Alias <ref> [Bur90, CK84, CK89, CK87, Mye81] </ref>. These problems involve no intraprocedural information.
Reference: [CK89] <author> K. D. Cooper and K. W. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> Conf. Rec. Sixteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <month> January </month> <year> 1989. </year> <institution> Austin, Texas. </institution>
Reference-contexts: The best known interprocedural problems are Formal Bound Set, MayAlias and MayBe-Modified F <ref> [Bur90, CK84, CK89, CK87] </ref>. Formal Bound Set asks, for all procedure formals, which formals can be reached over call chains from this given formal. <p> For bitvector problems, [CC] has the effect of Figure 3. May Problem Criterion [CC] is apparently responsible for the May Problem Criterion [MPC], a definition of flow insensitivity appearing in a number of early papers <ref> [CK84, CK89] </ref>: May, or some-path, problems are flow insensitive, Must, or all-path and no-path, problems are flow sensitive. <p> The literature refers to these calculations as procedure summary annotations; for clarity, we distinguish the terms summary and annotation below. When we discuss possible interprocedural flow sensitivity criteria, we also must acknowledge the existence of purely interprocedural problems such as Formal Bound Set and May-Alias <ref> [Bur90, CK84, CK89, CK87, Mye81] </ref>. These problems involve no intraprocedural information.
Reference: [DGS95] <author> E. Duesterwald, R. Gupta, and M-L Soffa. </author> <title> Demand-driven computation of interprocedural data flow. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: The former include Pointer-induced MayAlias [LR92] and MayBeModified C [LRZ93]. The latter include Inter-procedural Kill [Cal88], Interprocedural Reaching Definitions [HS94] and Interprocedural Copy Constant Propagation <ref> [RHS95, DGS95] </ref>. Comparison Consider the utility of these various flow sensitivity measures. [IC] is quite limiting in that the procedural annotations must be, in fact, constant, not dependent on intraprocedural flow, and calculated only once. Only MayBeModified F is an obvious example of this category.
Reference: [Dha91] <author> D. M. Dhamdhere. </author> <title> Practical adaptation of the global optimization algorithm of Morel and Renvoise. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 291-294, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: This model is especially useful for data flow analysis of explicitly parallel programs, where there may be control, synchronization, and call and return edges [MR93, GS93, CH92]. Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy <ref> [MR79, Dha91] </ref> (a generalization of Available Expressions); the approach has been extended to other problems [DP93]. In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems.
Reference: [DP93] <author> D. M. Dhamdhere and H. Patil. </author> <title> An efficient algorithm for bidirectional data flow analysis using edge placement technique. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 312-336, </pages> <year> 1993. </year>
Reference-contexts: Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy [MR79, Dha91] (a generalization of Available Expressions); the approach has been extended to other problems <ref> [DP93] </ref>. In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems. Since bidirectional problems typically involve non-trivial equations at both node entry and exit, and often different meets, we can view these as a subclass of the heterogeneous problems mentioned above.
Reference: [EGH94] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-257, </pages> <month> June </month> <year> 1994. </year> <note> Published as SIGPLAN Notices, 29 (6). </note>
Reference-contexts: Examples of this are the algorithms for Pointer-induced MayAlias relations in recursive structures [HN90] or in the presence of function pointers <ref> [EGH94] </ref>. 6 Context Sensitivity The term context sensitivity in the literature [EGH94] refers to the use of the calling context of a procedure (e.g., call stack, call history, path history) by an interprocedural analysis, which was first discussed in [Mye81, SP81]. <p> Examples of this are the algorithms for Pointer-induced MayAlias relations in recursive structures [HN90] or in the presence of function pointers <ref> [EGH94] </ref>. 6 Context Sensitivity The term context sensitivity in the literature [EGH94] refers to the use of the calling context of a procedure (e.g., call stack, call history, path history) by an interprocedural analysis, which was first discussed in [Mye81, SP81].
Reference: [GS93] <author> D. Grunwald and H. Srinivasan. </author> <title> Data flow equations for explicitly parallel programs. </title> <booktitle> In Proceedings of Conference on Principles and Practices of Parallel Programming, </booktitle> <pages> pages 159-168, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Recent work discusses how to transform these multisource data flow problems into a k-tuple framework formulation [MMR95]. This model is especially useful for data flow analysis of explicitly parallel programs, where there may be control, synchronization, and call and return edges <ref> [MR93, GS93, CH92] </ref>. Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy [MR79, Dha91] (a generalization of Available Expressions); the approach has been extended to other problems [DP93]. In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems.
Reference: [GT93] <author> Dan Grove and Linda Torczon. </author> <title> Interprocedural constant propagation: A study in jump function implementation. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 90-99, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Some measure of call-site specificity can be achieved even in a context insensitive algorithm. For example, jump functions in approximate Interprocedural Constant Propagation algorithms <ref> [CCKT86, GT93] </ref> are context insensitive (but AFS) intraprocedural summaries, but pass-through and linear jump functions, among others, will result in different constant information at return sites, as a result of interprocedural effects. Thus, these approximate Interprocedural Constant Propagation algorithms are AFS, but context insensitive.
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: An instance of a monotone data flow framework <ref> [Hec77, MR91] </ref> is specified by a tuple, D =&lt; G; L; F; M; &gt;, where G is a rooted digraph &lt; V; E; &gt;, L is usually a meet semilattice, F is a space of monotone (that is, order-preserving) functions mapping L into L, M is a mapping of edges E <p> If the functions of F also preserve meets, then D is called distributive. Intuitively, G is the control flow graph [ASU86] or call multigraph <ref> [Hec77] </ref> with root at , L a lattice of data flow solutions, M the assignment of transition functions to edges, and the entry solution at ; F is usually not represented explicitly. Often M can be thought of as specifying a system of j V j equations [RP86].
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <booktitle> IEEE Transaction on Parallel and Distributed Systems, </booktitle> <year> 1990. </year>
Reference-contexts: In a pure-AFS algorithm, any evaluation of the value of the tentative interprocedu-ral solution for a procedure essentially revisits the procedure (often with special handling for recursion to avoid non-termination). Examples of this are the algorithms for Pointer-induced MayAlias relations in recursive structures <ref> [HN90] </ref> or in the presence of function pointers [EGH94]. 6 Context Sensitivity The term context sensitivity in the literature [EGH94] refers to the use of the calling context of a procedure (e.g., call stack, call history, path history) by an interprocedural analysis, which was first discussed in [Mye81, SP81].
Reference: [HRB90] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: For a number of interesting problems it is still possible to extract in-traprocedural information in a single pass into annotations on the edges of these structures <ref> [Cal88, JPP94, LRZ93, HS94, HRB90] </ref>. Here, dependence on intraprocedural information is not necessarily completely encapsulated in the annotations, but shared between the 9 The annotations are not, however, required to be constant. 11 annotations and the control flow abstraction in the representation.
Reference: [HS94] <author> M. J. Harrold and M. L. Soffa. </author> <title> Efficient computation of interprocedural definition-use chains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(2) </volume> <pages> 175-204, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: For a number of interesting problems it is still possible to extract in-traprocedural information in a single pass into annotations on the edges of these structures <ref> [Cal88, JPP94, LRZ93, HS94, HRB90] </ref>. Here, dependence on intraprocedural information is not necessarily completely encapsulated in the annotations, but shared between the 9 The annotations are not, however, required to be constant. 11 annotations and the control flow abstraction in the representation. <p> The former include Pointer-induced MayAlias [LR92] and MayBeModified C [LRZ93]. The latter include Inter-procedural Kill [Cal88], Interprocedural Reaching Definitions <ref> [HS94] </ref> and Interprocedural Copy Constant Propagation [RHS95, DGS95]. Comparison Consider the utility of these various flow sensitivity measures. [IC] is quite limiting in that the procedural annotations must be, in fact, constant, not dependent on intraprocedural flow, and calculated only once.
Reference: [JGS93] <author> Neil Jones, Karsten Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Indeed, these are orthogonal properties, as we show below. Context sensitivity is also implied by polyvariant analysis in functional languages; polyvariance is a general term which describes an analysis using partial-evaluation-like constant propagation to eliminate infeasible intraprocedural branches and distinguishing between different call sites <ref> [JGS93] </ref>. Any algorithm is context sensitive or insensitive according as it uses call history information or not. This means that both precise and approximate algorithms can be categorized as context sensitive or insensitive. 13 A context sensitive algorithm need not use the full call stack abstraction.
Reference: [JPP94] <author> R. Johnson, D. Pearson, and K. Pingali. </author> <title> The program structure tree: Computing control regions in linear time. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 171-185, </pages> <month> June </month> <year> 1994. </year> <journal> published as SIGPLAN Notices, </journal> <volume> Vol 29, Number 6. </volume>
Reference-contexts: For a number of interesting problems it is still possible to extract in-traprocedural information in a single pass into annotations on the edges of these structures <ref> [Cal88, JPP94, LRZ93, HS94, HRB90] </ref>. Here, dependence on intraprocedural information is not necessarily completely encapsulated in the annotations, but shared between the 9 The annotations are not, however, required to be constant. 11 annotations and the control flow abstraction in the representation.
Reference: [KRS92] <author> J. Knoop, O. Ruething, and B. Steffen. </author> <title> Lazy code motion. </title> <booktitle> In Proc. SIGPLAN'92 Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 224-234, </pages> <month> June </month> <year> 1992. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 27, No. 7. </volume> <pages> 20 </pages>
Reference-contexts: Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy [MR79, Dha91] (a generalization of Available Expressions); the approach has been extended to other problems [DP93]. In <ref> [KRS92] </ref>, it is shown how to solve Partial Redundancy as a sequence of unidirectional problems. Since bidirectional problems typically involve non-trivial equations at both node entry and exit, and often different meets, we can view these as a subclass of the heterogeneous problems mentioned above.
Reference: [LR91] <author> W. L. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem taxonomy. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: This analysis is performed under the common assumption that all apparent execution paths in the program flow graph are actually feasible (i.e., traversable on some program execution); for interprocedural problems, however, paths are often restricted to realizable paths, so that calls match returns, at least approximately <ref> [LR91, LR92, RHS95] </ref>.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for pointer aliasing. </title> <booktitle> In Proc. SIG-PLAN'92 Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 27, No. </volume> <pages> 7. </pages>
Reference-contexts: This analysis is performed under the common assumption that all apparent execution paths in the program flow graph are actually feasible (i.e., traversable on some program execution); for interprocedural problems, however, paths are often restricted to realizable paths, so that calls match returns, at least approximately <ref> [LR91, LR92, RHS95] </ref>. <p> Recent problems which are flow insensitive by [IPC] include two families of interproce-dural problems, one for C-like languages with only a single level of pointer dereferencing and the other for Fortran-like programs without call-by-reference aliasing. The former include Pointer-induced MayAlias <ref> [LR92] </ref> and MayBeModified C [LRZ93]. The latter include Inter-procedural Kill [Cal88], Interprocedural Reaching Definitions [HS94] and Interprocedural Copy Constant Propagation [RHS95, DGS95]. <p> This is to be contrasted to the constant summary information of the [IC] criterion. Examples of AFS and AFI Examples of approximation methods we can categorize in this manner are the Pointer-induced MayAlias algorithms of <ref> [BCCH94, LR92] </ref>, the Def-Use analysis of C-like programs [PLR94] and MayBeModified C [LRZ93]. 11 The Burke et.al. algorithm [BCCH94] uses a functional annotation for each procedure computed without consideration of intraprocedural program structure. <p> Thus, we say that this algorithm is AFS in that the procedure annotations depend on intraprocedural flow. The approximation algorithms for Pointer-induced MayAlias and MayBeModified C in <ref> [LR92, LRZ93] </ref> and the optimized algorithm using Kill information presented in [BCCH94] can be similarly classified as AFS. All of these algorithms can use memoization (i.e., table lookup) to avoid unnecessary recalculation of their annotations on repeated inputs. <p> While both Myers and Sharir-Pnueli use the full call stack, the latter suggests using the tail of the stack as an abstraction, an adaptation used by Choi et.al for an algorithm for Pointer-induced MayAlias [CBC93, MLR + 93]. The Landi-Ryder algorithm for Pointer-induced MayAlias <ref> [LR92] </ref> uses a different approximation of context, reaching alias information at each call site. The table in Figure 7 shows the orthogonality of these two properties by naming problems with algorithms that fall in each of the entries. The entry in (1,2) position is the ProcLastCalled problem. <p> Clearly, any problem in which information can flow only upward, or only downward, will necessarily be context insensitive; conversely, two-way flow will almost certainly make a problem context sensitive.) Further, consider approximate algorithms for pointer-induced aliasing. Landi-Ryder <ref> [LR92] </ref> is AFS and context sensitive, whereas Burke et.al [BCCH94] is AFI and context insensitive. Ruf presents two algorithms for this problem: one context sensitive and one context insensitive [Ruf95]; both are AFS. Another approach to this problem is given in [WL95]. <p> and computation of data flow problems. 14 We do change these rules if we allow pruning of infeasible paths through constant propagation, using perhaps, parameter values [WZ85]. 16 Alg-Flow Alg-Flow Insensitive Sensitive Context Insensitive Formal Bound Set ProcLastCalled Call-by-Reference MayAlias Pointer-induced MayAlias [BCCH94] Context Sensitive MayAlias Partitions [Mye81] Pointer-induced Aliasing <ref> [LR92] </ref> Constant Propagation Heterogeneous Flow Functions Callahan [Cal88] defines a pair of interprocedural data flow problems, Kill and Use, which have the properties (1) that they require examination of code within procedures beyond just initial annotations, and thus are flow sensitive in the sense of [IPC], and (2) that their flow
Reference: [LRZ93] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: For a number of interesting problems it is still possible to extract in-traprocedural information in a single pass into annotations on the edges of these structures <ref> [Cal88, JPP94, LRZ93, HS94, HRB90] </ref>. Here, dependence on intraprocedural information is not necessarily completely encapsulated in the annotations, but shared between the 9 The annotations are not, however, required to be constant. 11 annotations and the control flow abstraction in the representation. <p> Recent problems which are flow insensitive by [IPC] include two families of interproce-dural problems, one for C-like languages with only a single level of pointer dereferencing and the other for Fortran-like programs without call-by-reference aliasing. The former include Pointer-induced MayAlias [LR92] and MayBeModified C <ref> [LRZ93] </ref>. The latter include Inter-procedural Kill [Cal88], Interprocedural Reaching Definitions [HS94] and Interprocedural Copy Constant Propagation [RHS95, DGS95]. <p> This is to be contrasted to the constant summary information of the [IC] criterion. Examples of AFS and AFI Examples of approximation methods we can categorize in this manner are the Pointer-induced MayAlias algorithms of [BCCH94, LR92], the Def-Use analysis of C-like programs [PLR94] and MayBeModified C <ref> [LRZ93] </ref>. 11 The Burke et.al. algorithm [BCCH94] uses a functional annotation for each procedure computed without consideration of intraprocedural program structure. <p> Thus, we say that this algorithm is AFS in that the procedure annotations depend on intraprocedural flow. The approximation algorithms for Pointer-induced MayAlias and MayBeModified C in <ref> [LR92, LRZ93] </ref> and the optimized algorithm using Kill information presented in [BCCH94] can be similarly classified as AFS. All of these algorithms can use memoization (i.e., table lookup) to avoid unnecessary recalculation of their annotations on repeated inputs.
Reference: [Mar89] <author> T. J. Marlowe. </author> <title> Data Flow Analysis and Incremental Iteration. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Rutgers U., </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: In particular, for Kill, evaluation at all nodes except return nodes uses a join operator, but return nodes require a meet. In <ref> [Mar89] </ref>, Marlowe suggested that any problem in which there is a classification of nodes or edges into several types, such that the form of flow function depends on the classification of its underlying edge, or of its two incident vertices, can reasonably be considered to be flow sensitive.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: While both Myers and Sharir-Pnueli use the full call stack, the latter suggests using the tail of the stack as an abstraction, an adaptation used by Choi et.al for an algorithm for Pointer-induced MayAlias <ref> [CBC93, MLR + 93] </ref>. The Landi-Ryder algorithm for Pointer-induced MayAlias [LR92] uses a different approximation of context, reaching alias information at each call site. The table in Figure 7 shows the orthogonality of these two properties by naming problems with algorithms that fall in each of the entries.
Reference: [MMR95] <author> Stephen P. Masticola, Thomas J. Marlowe, and Barbara G. Ryder. </author> <title> Lattice frameworks for multi-source and bidirectional data flow analysis problems. </title> <type> Technical Report LCSR-TR-241, </type> <institution> Department of Computer Science, Rutgers University, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: We now view this edge classification as an orthogonal dimension to alg-flow sensitivity. Recent work discusses how to transform these multisource data flow problems into a k-tuple framework formulation <ref> [MMR95] </ref>. This model is especially useful for data flow analysis of explicitly parallel programs, where there may be control, synchronization, and call and return edges [MR93, GS93, CH92]. <p> In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems. Since bidirectional problems typically involve non-trivial equations at both node entry and exit, and often different meets, we can view these as a subclass of the heterogeneous problems mentioned above. Discussions in <ref> [MMR95] </ref> also show how bidirectional problems can be transformed into k-tuple frameworks. Convergence Properties and Flow Sensitivity Because of the tight restrictions it places on the equation sets of problems, flow insensitivity for [AC] implies 1-semiboundedness, and in fact distributivity and rapidity (for problems which are in any way bounded).
Reference: [MR79] <author> E. Morel and C. </author> <title> Renvoise. Global optimization by supression of partial redundancies. </title> <journal> Comm. ACM, </journal> <volume> 22(2) </volume> <pages> 96-103, </pages> <month> February </month> <year> 1979. </year>
Reference-contexts: This model is especially useful for data flow analysis of explicitly parallel programs, where there may be control, synchronization, and call and return edges [MR93, GS93, CH92]. Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy <ref> [MR79, Dha91] </ref> (a generalization of Available Expressions); the approach has been extended to other problems [DP93]. In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems.
Reference: [MR90] <author> T. J. Marlowe and B. G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Yet we can consider Inter-procedural Reaching Definitions, at least in the absence of aliasing, as an [IPC]-insensitive problem <ref> [MR90] </ref>. Once we accept annotations which are not in the original solution lattice, however, it is difficult to know what forms to allow, although in practice the choice is usually clear. In principle, we could argue that any invariant value, even an invariant function, could be considered an invariant annotation.
Reference: [MR91] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks: A unified model. </title> <journal> Acta Informatica, </journal> <volume> 28(2) </volume> <pages> 121-164, </pages> <year> 1991. </year>
Reference-contexts: In Section 7, we show that neither past characterizations of flow sensitivity, nor those we consider, necessarily provide information about the algebraic (e.g., monotone vs. distributive) or convergence (e.g., fast vs. k-bounded vs. unbounded) properties <ref> [MR91] </ref> of the data flow problem to be solved. We briefly discuss two other sources of complication for data flow problems, heterogeneity and bidirectionality, and how they relate to context and flow sensitivity. <p> An instance of a monotone data flow framework <ref> [Hec77, MR91] </ref> is specified by a tuple, D =&lt; G; L; F; M; &gt;, where G is a rooted digraph &lt; V; E; &gt;, L is usually a meet semilattice, F is a space of monotone (that is, order-preserving) functions mapping L into L, M is a mapping of edges E <p> A data flow framework is k-bounded if, intuitively, fixed point iteration requires k + 1 iterations around a cycle to stabilize; fast is 2-bounded <ref> [MR91] </ref>. Standard Data Flow Problems In the rest of this paper, we will be using a number of standard data flow problems. The best known data flow problems are the four classical intraprocedural problems: Reaching Definitions, Live Uses, Available Expressions, and Very Busy Uses [ASU86].
Reference: [MR93] <author> S. Masticola and B. G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of Conference on Principles and Practices of Parallel Programming, </booktitle> <pages> pages 129-138, </pages> <month> May </month> <year> 1993. </year> <note> published as ACM SIGPLAN Notices, </note> <month> May </month> <year> 1993. </year>
Reference-contexts: Recent work discusses how to transform these multisource data flow problems into a k-tuple framework formulation [MMR95]. This model is especially useful for data flow analysis of explicitly parallel programs, where there may be control, synchronization, and call and return edges <ref> [MR93, GS93, CH92] </ref>. Bidirectionality Bidirectional data flow problems were introduced by Morel and Renvoise for Partial Redundancy [MR79, Dha91] (a generalization of Available Expressions); the approach has been extended to other problems [DP93]. In [KRS92], it is shown how to solve Partial Redundancy as a sequence of unidirectional problems.
Reference: [Mye81] <author> E. W. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> Conf. Rec. Eighth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: There are two other variants which have somewhat different data flow properties: the MustAlias and MayAlias Partitions problems. In the simple case, MustAlias determines alias pairs which will hold on all invocations of a given procedure. MayAlias Partitions <ref> [Mye81] </ref> determines sets of variables at a program point such that exactly that set of variables addresses the same location along some execution path. MayBeModified F for a procedure in a Fortran-like language calculates the set of variables whose values may be changed by execution of that procedure. <p> This definition may also have been influenced by terminology in <ref> [Mye81] </ref>, in which Myers shows the MaySummaryProblem (MayBeModified F ) to be flow insensitive, and the MustSummaryProblem (MustBeModified) to be flow sensitive, using the [IC] criterion of Section 4. Like [CC], [MPC] identifies only MayBeDefined among the first four example problems on page 5 as flow insensitive. <p> The literature refers to these calculations as procedure summary annotations; for clarity, we distinguish the terms summary and annotation below. When we discuss possible interprocedural flow sensitivity criteria, we also must acknowledge the existence of purely interprocedural problems such as Formal Bound Set and May-Alias <ref> [Bur90, CK84, CK89, CK87, Mye81] </ref>. These problems involve no intraprocedural information. <p> A data flow problem is flow insensitive for a given interprocedural criterion if we can demonstrate a precise algorithm for it, which is not flow sensitive by that criterion. Independent of Intraprocedural Control Flow Banning's definition appears to have led Myers <ref> [Mye81] </ref> to the Interprocedural Criterion [IC] for flow insensitivity: a problem is flow insensitive if it uses constant intraprocedural annotations, and its solution does not depend on the intraprocedural structure of the program. <p> be seen to embody an idea similar to separate compilation for efficient analysis; it preserves the significant property that procedure annotations can be extracted by either a single visit preceding interprocedural propagation, or alternatively by an on-demand (non-repeating) calculation during interprocedural propagation. 14 flow information, to representations like the supergraph <ref> [Mye81] </ref>, which in essence inlines procedure flow graphs, either by adding call and return edges, or by actually inlining dynamically, although necessarily eventually identifying recursive instances, and handling them specially. <p> in recursive structures [HN90] or in the presence of function pointers [EGH94]. 6 Context Sensitivity The term context sensitivity in the literature [EGH94] refers to the use of the calling context of a procedure (e.g., call stack, call history, path history) by an interprocedural analysis, which was first discussed in <ref> [Mye81, SP81] </ref>. This should not be confused with the ideas of flow sensitivity in Sections 4 and 5; Myers made the distinction between context and flow sensitivity in discussing the complexity of flow sensitive problems (see Section 4). Indeed, these are orthogonal properties, as we show below. <p> complicate both definition and computation of data flow problems. 14 We do change these rules if we allow pruning of infeasible paths through constant propagation, using perhaps, parameter values [WZ85]. 16 Alg-Flow Alg-Flow Insensitive Sensitive Context Insensitive Formal Bound Set ProcLastCalled Call-by-Reference MayAlias Pointer-induced MayAlias [BCCH94] Context Sensitive MayAlias Partitions <ref> [Mye81] </ref> Pointer-induced Aliasing [LR92] Constant Propagation Heterogeneous Flow Functions Callahan [Cal88] defines a pair of interprocedural data flow problems, Kill and Use, which have the properties (1) that they require examination of code within procedures beyond just initial annotations, and thus are flow sensitive in the sense of [IPC], and (2)
Reference: [PLR94] <author> H. D. Pande, W. Landi, and B. G. Ryder. </author> <title> Interprocedural def-use associations for c systems with single level pointers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 385-403, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This is to be contrasted to the constant summary information of the [IC] criterion. Examples of AFS and AFI Examples of approximation methods we can categorize in this manner are the Pointer-induced MayAlias algorithms of [BCCH94, LR92], the Def-Use analysis of C-like programs <ref> [PLR94] </ref> and MayBeModified C [LRZ93]. 11 The Burke et.al. algorithm [BCCH94] uses a functional annotation for each procedure computed without consideration of intraprocedural program structure. <p> There is a circular dependence between interprocedural analysis and the analysis of individual procedures, since steps (2) and (3) can interact, because the summaries are variable throughout the algorithm (i.e., different summaries may result from different information input to a procedure annotation). 12 The Pande et. al. algorithm <ref> [PLR94] </ref> also uses a functional annotation for each procedure, but this summary incorporates information obtained from propagation on intraprocedural static paths. Thus, we say that this algorithm is AFS in that the procedure annotations depend on intraprocedural flow.
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reach-ability. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: This analysis is performed under the common assumption that all apparent execution paths in the program flow graph are actually feasible (i.e., traversable on some program execution); for interprocedural problems, however, paths are often restricted to realizable paths, so that calls match returns, at least approximately <ref> [LR91, LR92, RHS95] </ref>. <p> The former include Pointer-induced MayAlias [LR92] and MayBeModified C [LRZ93]. The latter include Inter-procedural Kill [Cal88], Interprocedural Reaching Definitions [HS94] and Interprocedural Copy Constant Propagation <ref> [RHS95, DGS95] </ref>. Comparison Consider the utility of these various flow sensitivity measures. [IC] is quite limiting in that the procedural annotations must be, in fact, constant, not dependent on intraprocedural flow, and calculated only once. Only MayBeModified F is an obvious example of this category.
Reference: [RMP88] <author> B. G. Ryder, T. J. Marlowe, and M. C. Paull. </author> <title> Conditions for incremental iteration: Examples and counterexamples. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 1-15, </pages> <year> 1988. </year>
Reference-contexts: We thus get the diagram of Figure 2. Live Uses (cell (2,2)) and MustBePreserved (cell (1,1)) are both flow insensitive by [MAC], while Available Expressions (cell (1,2)) and MayBePreserved (cell (2,1)) are flow sensitive. Formal Bound Set is also flow insensitive (and in cell (2,2)), since the lozenge operator <ref> [RMP88] </ref> has the appropriate algebraic properties. [MAC] also identifies only a limited class of problems as flow insensitive, and groups as flow sensitive relatively simple problems like Available Expressions together with much harder problems.
Reference: [RP86] <author> B. G. Ryder and M. C. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> Computing Surveys, </journal> <volume> 18(3) </volume> <pages> 277-316, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Often M can be thought of as specifying a system of j V j equations <ref> [RP86] </ref>. In forward data flow problems, information flows in the direction of flow graph edges; in backward problems, information flows in the opposite direction. The definitions and examples in this paper are, without loss of generality, mostly in terms of forward data flow problems. <p> The equation is linear if there are constants A (Y;X) and B (Y;X) so that f (Y;X) (S (Y )) = A (Y;X) S (Y ) B (Y;X) (for associative operations and with appropriate algebraic properties <ref> [RP86] </ref>). For monotone problems, solution techniques find the maximum (or minimum) fixed point (MFP); for distributive problems, this will also be the meet over all paths (MOP) solution.
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995. </year> <note> (to appear). </note>
Reference-contexts: Landi-Ryder [LR92] is AFS and context sensitive, whereas Burke et.al [BCCH94] is AFI and context insensitive. Ruf presents two algorithms for this problem: one context sensitive and one context insensitive <ref> [Ruf95] </ref>; both are AFS. Another approach to this problem is given in [WL95]. This algorithm is AFS and context sensitive, but uses still another call stack abstraction, namely an aliasing pattern or template at a call site.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: in recursive structures [HN90] or in the presence of function pointers [EGH94]. 6 Context Sensitivity The term context sensitivity in the literature [EGH94] refers to the use of the calling context of a procedure (e.g., call stack, call history, path history) by an interprocedural analysis, which was first discussed in <ref> [Mye81, SP81] </ref>. This should not be confused with the ideas of flow sensitivity in Sections 4 and 5; Myers made the distinction between context and flow sensitivity in discussing the complexity of flow sensitive problems (see Section 4). Indeed, these are orthogonal properties, as we show below.
Reference: [WL95] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year> <note> also available as SIGPLAN Notices, 30(6). 21 </note>
Reference-contexts: Landi-Ryder [LR92] is AFS and context sensitive, whereas Burke et.al [BCCH94] is AFI and context insensitive. Ruf presents two algorithms for this problem: one context sensitive and one context insensitive [Ruf95]; both are AFS. Another approach to this problem is given in <ref> [WL95] </ref>. This algorithm is AFS and context sensitive, but uses still another call stack abstraction, namely an aliasing pattern or template at a call site. Considering aliases produced by call-by-reference parameter passing, Myers' May Alias Partitions algorithm is context sensitive and AFI.
Reference: [WZ85] <author> M. Wegman and F. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 291-299, </pages> <month> January </month> <year> 1985. </year> <month> 22 </month>
Reference-contexts: algorithms will be solved by call-site specific, context sensitive algorithms. 7 Other Data Flow Problem Properties There are other properties which complicate both definition and computation of data flow problems. 14 We do change these rules if we allow pruning of infeasible paths through constant propagation, using perhaps, parameter values <ref> [WZ85] </ref>. 16 Alg-Flow Alg-Flow Insensitive Sensitive Context Insensitive Formal Bound Set ProcLastCalled Call-by-Reference MayAlias Pointer-induced MayAlias [BCCH94] Context Sensitive MayAlias Partitions [Mye81] Pointer-induced Aliasing [LR92] Constant Propagation Heterogeneous Flow Functions Callahan [Cal88] defines a pair of interprocedural data flow problems, Kill and Use, which have the properties (1) that they require
References-found: 45

