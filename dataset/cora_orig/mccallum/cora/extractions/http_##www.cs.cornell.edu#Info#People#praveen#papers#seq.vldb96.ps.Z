URL: http://www.cs.cornell.edu/Info/People/praveen/papers/seq.vldb96.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/People/praveen/papers.html
Root-URL: http://www.cs.brown.edu/
Email: praveen,miron,raghu@cs.wisc.edu  
Title: The Design and Implementation of a Sequence Database System  
Author: Praveen Seshadri Miron Livny Raghu Ramakrishnan 
Address: U.Wisconsin, Madison WI 53706  
Affiliation: Computer Sciences Department  
Abstract: This paper discusses the design and implementation of SEQ, a database system with support for sequence data. SEQ models a sequence as an ordered collection of records, and supports a declarative sequence query language based on an algebra of query operators, thereby permitting algebraic query optimization and evaluation. SEQ has been built as a component of the PREDATOR database system that provides support for relational and other kinds of complex data as well. There are three distinct contributions made in this paper. (1) We describe the specification of sequence queries using the SEQUIN query language. (2) We quantitatively demonstrate the importance of various storage and optimization techniques by studying their effect on performance. (3) We present a novel nested design paradigm used in PREDATOR to combine se quence and relational data.
Abstract-found: 1
Intro-found: 1
Reference: [BDK92] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis (eds). </editor> <title> Building an Object-Oriented Database System: The Story of O2.. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Most commercial database systems will allow a sequence to be represented as a `blob' which is managed by the system, but 1 PREDATOR is (recursively) the PRedator Enhanced DAta Type Object-Relational DBMS. Page 1 interpreted solely by the application program. Some object--oriented systems like O2 <ref> [BDK92] </ref> provide array and list constructs that allow collections of data to be ordered. The object-relational database system Illustra [Ill94] provides database support for time-series data along with relational data. A time-series is an ADT (Abstract Data Type) value implemented as a large array on disk. <p> However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. While most object-oriented database proposals include constructors for complex types like lists and arrays <ref> [VD91, BDK92] </ref>, they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists.
Reference: [CDF+94] <author> M.J. Carey, D.J. DeWitt, M.J. Franklin, N.E. Hall, M. McAuliffe, J.F. Naughton, D.T. Schuh, M.H. Solomon, C.K. Tan, O. Tsatalos, S. White and M.J. Zwilling. </author> <title> Shoring Up Persistent Objects. </title> <booktitle> In Proceeding of the ACM SIGMOD Conference on Management of Data, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: SEQ is a component of the PREDATOR 1 multi-threaded, client-server database system which supports sequences, as well as relations and other kinds of complex data. The system uses the SHORE storage manager library <ref> [CDF+94] </ref> for low-level database functionality like buffer management, con-currency control and recovery. A novel design paradigm provides query processing support for multiple data types, including both sequences and relations. <p> The server is built on top of a layer of common database utilities that all E-ADTs can use. Code Page 2 to handle arithmetic and boolean expressions, constant values and functions is part of this layer. An important component of the utility layer is the SHORE Storage Manager <ref> [CDF+94] </ref>. SHORE provides facilities for concurrency control, recovery and buffer management for large volumes of data. It also provides a threads package that interacts with the rest of the storage management layers; PREDATOR uses this package to build a multi-threaded server.
Reference: [CS92] <author> Rakesh Chandra and Arie Segev. </author> <title> Managing Temporal Financial Data in an Extensible Database. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 238-249, </pages> <year> 1992. </year>
Reference-contexts: Page 11 5 Related Research Research work directed at modeling time-series data <ref> [SS87, CS92, Sto90] </ref> provided initial direction to our efforts.
Reference: [DKLPY94] <author> D.J. DeWitt, N. Kabra, J. Luo, J.M. Patel and J. Yu. </author> <title> Client-Server Paradise. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The dual mapping from right (records) to the left (positions) leads to operators that are extensions of the relational algebra. Such operators have been extensively investigated in the temporal database community [TCG+93], and they are not considered here. 2 PREDATOR System Design Object-relational systems like Il-lustra [Ill94], and Paradise <ref> [DKLPY94] </ref> allow an attribute of a relational record to belong to an Abstract Data Type (ADT). Each ADT defines methods that may be invoked on values of that type. An ADT can itself be a structured complex type like a sequence, with other ADTs nested inside it.
Reference: [MIM94] <institution> Logical Information Machines. MIM User Manual. </institution> <address> 6869 Marshall Road, Dexter, MI 48130. </address>
Reference-contexts: The PREDATOR system is described in detail in [Ses96], and only a high-level overview is presented here. 1.1 The State Of The Art Financial management products like MIM <ref> [MIM94] </ref> provide special purpose systems for analyzing stock market data. Current general-purpose database systems provide limited support for sequence data. The Order-By clause in SQL only specifies the order in which answers are presented to the user. Most existing support deals with temporal data.
Reference: [GJS92] <author> N.H. Gehani, H.V. Jagadish, and O. Shmueli. </author> <title> Composite Event Specification in Active Databases: Model and Implementation. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 327-338, </pages> <year> 1992. </year>
Reference-contexts: The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have also been languages proposed and systems built to match regular expression patterns over event sequences <ref> [GJS92] </ref>. This work is complementary to ours, since SEQ is oriented to more traditional database queries, and currently does not have powerful pattern-matching capabilities. 6 Conclusions We have described the design and implementation of the support for sequences in SEQ.
Reference: [Ill94] <institution> Illustra Information Technologies, Inc. </institution> <note> Illustra User's Guide, June 1994. 1111 Broadway, Suite 2000, Oakland, CA 94607. </note>
Reference-contexts: Page 1 interpreted solely by the application program. Some object--oriented systems like O2 [BDK92] provide array and list constructs that allow collections of data to be ordered. The object-relational database system Illustra <ref> [Ill94] </ref> provides database support for time-series data along with relational data. A time-series is an ADT (Abstract Data Type) value implemented as a large array on disk. A number of ADT methods are implemented to provide primitive query functionality on a time-series. <p> The dual mapping from right (records) to the left (positions) leads to operators that are extensions of the relational algebra. Such operators have been extensively investigated in the temporal database community [TCG+93], and they are not considered here. 2 PREDATOR System Design Object-relational systems like Il-lustra <ref> [Ill94] </ref>, and Paradise [DKLPY94] allow an attribute of a relational record to belong to an Abstract Data Type (ADT). Each ADT defines methods that may be invoked on values of that type. An ADT can itself be a structured complex type like a sequence, with other ADTs nested inside it. <p> During execution of the SQL query, the nested SEQU IN expression is evaluated just as any other function would be. There are several other implementation details that are described in [Ses96]. 4.2 Comparison with Existing Systems Some current systems like Illustra <ref> [Ill94] </ref> support sequences (more specifically, time-series) as ADTs with a collection of methods providing query primitives. A query is a composition of the primitive functions or methods. While queries in SE QU IN are declarative, queries based on the functional composition of methods have a procedural semantics. <p> When a query expression involves the composition of more than one of these methods, little or no inter-function optimization is performed, and each individual method is evaluated separately. While we did perform a performance comparison with Illus-tra <ref> [Ill94] </ref>, we are not permitted to discuss those results. Instead, we provide a qualitative comparison. Experiments 6 and 7 showed that materialization can perform an order of magnitude worse than pipelining with stream-access. In the ADT-method approach, pipelining is not possible without inter-function optimization.
Reference: [Ric92] <author> Joel Richardson. </author> <title> Supporting Lists in a Data Model. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: While most object-oriented database proposals include constructors for complex types like lists and arrays [VD91, BDK92], they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in <ref> [Ric92] </ref> is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have also been languages proposed and systems built to match regular expression patterns over event sequences [GJS92].
Reference: [SLR96] <author> Praveen Seshadri, Miron Livny and Raghu Ramakrishnan. </author> <title> Design and Implementation of a Sequence Database. </title> <type> Technical Report. </type> <institution> University of Wisconsin, CS-Dept, </institution> <year> 1996. </year>
Reference-contexts: The DBMS should efficiently process queries over large disk-based sequences. Further, in most applications, there is sequence data as well as relational and other kinds of data. Complex values like images, or even entire relations can be associated with a single position in a sequence <ref> [SLR96] </ref>, and conversely, there can be a sequence associated with a single relational tuple. In [SLR95], we proposed an algebra of Positional sequence query operators. In terms of Figure 1, these operators view the sequence mapping from the left (positions) to the right (records). <p> approach is unable to apply optimization techniques that could result in overall performance improvements of approximately two orders of magnitude! In order for these systems to derive some of the efficiencies of the SEQ approach, they will have to adopt some or all of the system design used by PREDATOR <ref> [SLR96, Ses96] </ref>. Page 11 5 Related Research Research work directed at modeling time-series data [SS87, CS92, Sto90] provided initial direction to our efforts.
Reference: [Ses96] <author> Praveen Seshadri. </author> <title> Management of Sequence Data. </title> <type> Ph.D. Thesis. </type> <institution> University of Wisconsin, CS-Dept, </institution> <year> 1996. </year>
Reference-contexts: In this paper, the focus is on the SEQ component which provides the SEQU IN language to specify declarative sequence queries, and an optimization and execution engine to process them. The PREDATOR system is described in detail in <ref> [Ses96] </ref>, and only a high-level overview is presented here. 1.1 The State Of The Art Financial management products like MIM [MIM94] provide special purpose systems for analyzing stock market data. Current general-purpose database systems provide limited support for sequence data. <p> In this current paper, we only wish to place the support for sequence data in the context of the larger database system. The reader is referred to <ref> [Ses96] </ref> for further details on E-ADTs and the PREDATOR system. The design philosophy of E-ADTs is carried directly over into the system architecture. PREDATOR is a client-server database in which the server is a loosely-coupled system of E-ADTs . <p> In other words, neither is the common-subexpression evaluated multiple times, nor is it materialized <ref> [Ses96] </ref>. Experiment 5: We ran the very same query shown above (except that the Stock1 sequence was replaced by 100K 10flds 100dens). We varied the size of the aggregation window from 10 to 100; as the window size increases, so does the cost of the common sub-expression. <p> There is currently no optimization performed across query blocks belonging to different E-ADTs . During execution of the SQL query, the nested SEQU IN expression is evaluated just as any other function would be. There are several other implementation details that are described in <ref> [Ses96] </ref>. 4.2 Comparison with Existing Systems Some current systems like Illustra [Ill94] support sequences (more specifically, time-series) as ADTs with a collection of methods providing query primitives. A query is a composition of the primitive functions or methods. <p> approach is unable to apply optimization techniques that could result in overall performance improvements of approximately two orders of magnitude! In order for these systems to derive some of the efficiencies of the SEQ approach, they will have to adopt some or all of the system design used by PREDATOR <ref> [SLR96, Ses96] </ref>. Page 11 5 Related Research Research work directed at modeling time-series data [SS87, CS92, Sto90] provided initial direction to our efforts.
Reference: [SLR95] <author> Praveen Seshadri, Miron Livny and Raghu Ramakrishnan. SEQ: </author> <title> A Model for Sequence Databases. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Proceedings of the 22nd VLDB Conference Mumbai (Bombay), India, 1996 in the data. In earlier work, we had described a data model that could describe a wide variety of sequence data, and a query algebra that could be used to represent queries over sequences <ref> [SLR95] </ref>. We had also observed that sequence query evaluation could benefit greatly from algebraic optimizations that exploited the order information [SLR94]. This paper describes the issues that were addressed when building the SEQ sequence database system based on these ideas. <p> Complex values like images, or even entire relations can be associated with a single position in a sequence [SLR96], and conversely, there can be a sequence associated with a single relational tuple. In <ref> [SLR95] </ref>, we proposed an algebra of Positional sequence query operators. In terms of Figure 1, these operators view the sequence mapping from the left (positions) to the right (records). <p> A SEQU IN query is parsed into a directed acyclic graph of algebraic operators, which is then optimized by the query optimizer. We have described the algebra operators and some optimization techniques in <ref> [SLR95, SLR94] </ref>. 3.4 Query Optimizations This section describes the effects of four categories of implemented optimizations. Each optimization is first explained in principle, and then demonstrated by means of a performance experiment.
Reference: [SLR94] <author> Praveen Seshadri, Miron Livny and Raghu Ramakrishnan. </author> <title> Sequence Query Processing. </title> <booktitle> In Proceeding of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 430-441, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We had also observed that sequence query evaluation could benefit greatly from algebraic optimizations that exploited the order information <ref> [SLR94] </ref>. This paper describes the issues that were addressed when building the SEQ sequence database system based on these ideas. SEQ is a component of the PREDATOR 1 multi-threaded, client-server database system which supports sequences, as well as relations and other kinds of complex data. <p> A SEQU IN query is parsed into a directed acyclic graph of algebraic operators, which is then optimized by the query optimizer. We have described the algebra operators and some optimization techniques in <ref> [SLR95, SLR94] </ref>. 3.4 Query Optimizations This section describes the effects of four categories of implemented optimizations. Each optimization is first explained in principle, and then demonstrated by means of a performance experiment. <p> Experiment 2 demonstrates the benefits of propagating such selections into the sequence scans. The other source is from statistics on the valid ranges of positions in each sequence. These valid ranges can be propagated through the entire query as described in <ref> [SLR94] </ref>. Experiment 3 demonstrates how the valid-range can be used for optimization. Experiment 2: PROJECT count (*) FROM 100K_10flds_100dens S WHERE S.time &gt; "&lt;timestamp1&gt;" ZOOM ALL; This query is a variant of the query used earlier to measure the performance of a sequence scan. <p> While we have ignored the possibility of materializing the intermediate result, Page 9 the next experiment will show that materialization is very inefficient in general. 3.4.4 Operator Pipelining An important optimization principle in SEQ is to try and ensure stream access <ref> [SLR94] </ref> to the stored sequence data as well as to intermediate data; i.e., each sequence is read in a single continuous pipelined stream without materializing it. This is accomplished by associating buffers with each operator, to cache some relevant portion of the most recent data from its inputs.
Reference: [SS87] <author> Arie Segev and Arie Shoshani. </author> <title> Logical Modeling of Temporal Data. </title> <booktitle> In Proceedings of ACM SIGMOD '87 International Conference on Management of Data, </booktitle> <address> San Francisco, CA, </address> <pages> pages 454-466, </pages> <year> 1987. </year>
Reference-contexts: Page 11 5 Related Research Research work directed at modeling time-series data <ref> [SS87, CS92, Sto90] </ref> provided initial direction to our efforts. <p> Page 11 5 Related Research Research work directed at modeling time-series data [SS87, CS92, Sto90] provided initial direction to our efforts. The model of a time-series in <ref> [SS87] </ref> is similar to ours, and an SQL-like language was also proposed; implementation issues were discussed in the context of how the model could be mapped to a relational data model.The Tangram Stream Processor [Sto90] uses transducers and stream processing to query sequences in a logic programming context; there are many
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of New Types in Relational Data Base Systems. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <year> 1986. </year>
Reference-contexts: An ADT can itself be a structured complex type like a sequence, with other ADTs nested inside it. Relations are the top-level type, and all queries are posed in the relational query language SQL. There has been much research related to ADT technology, beginning with <ref> [Sto86] </ref>. The PREDATOR design enhances the ADT notion by supporting Enhanced Abstract Data Types (E-ADTs ). Both sequences and relations are modeled as E-ADTs . Each E-ADT supports one or more of the following: Storage Management: Each E-ADT can provide multiple physical implementations of values of that type.
Reference: [Sto90] <author> D. Stott Parker. </author> <title> Stream Data Analysis in Prolog. In The Practice of Prolog, Chapter 8, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Page 11 5 Related Research Research work directed at modeling time-series data <ref> [SS87, CS92, Sto90] </ref> provided initial direction to our efforts. <p> The model of a time-series in [SS87] is similar to ours, and an SQL-like language was also proposed; implementation issues were discussed in the context of how the model could be mapped to a relational data model.The Tangram Stream Processor <ref> [Sto90] </ref> uses transducers and stream processing to query sequences in a logic programming context; there are many similarities between the stream processing ideas in this work and in SEQ. The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93].
Reference: [TCG+93] <author> A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, R. Snod-grass (eds). </author> <title> Temporal Databases, Theory, Design and Implementation. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: Many temporal queries can be expressed in SQL-92 using features like correlated subqueries and aggregation, these are typically very inefficient to execute. Research in the temporal database community has focused on enhancing relational data models with temporal semantics <ref> [TCG+93] </ref>, but there have been few implementations. Most commercial database systems will allow a sequence to be represented as a `blob' which is managed by the system, but 1 PREDATOR is (recursively) the PRedator Enhanced DAta Type Object-Relational DBMS. Page 1 interpreted solely by the application program. <p> The dual mapping from right (records) to the left (positions) leads to operators that are extensions of the relational algebra. Such operators have been extensively investigated in the temporal database community <ref> [TCG+93] </ref>, and they are not considered here. 2 PREDATOR System Design Object-relational systems like Il-lustra [Ill94], and Paradise [DKLPY94] allow an attribute of a relational record to belong to an Abstract Data Type (ADT). Each ADT defines methods that may be invoked on values of that type. <p> The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93]. The extensive work on temporal database modeling, query languages, and query processing <ref> [TCG+93] </ref> is mostly complementary to our work, because it involves changes to relations and to SQL [TSQL94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa.
Reference: [TSQL94] <author> TSQL2 Language Design Committee. </author> <title> TSQL2 Language Specification. </title> <booktitle> In ACM SIGMOD Record, </booktitle> <volume> 23, No.1, </volume> <pages> pages 65-86, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of [WJS93]. The extensive work on temporal database modeling, query languages, and query processing [TCG+93] is mostly complementary to our work, because it involves changes to relations and to SQL <ref> [TSQL94] </ref>. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa.
Reference: [VD91] <author> S.L. Vandenberg and D.J. DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance. </title> <booktitle> In Proceedings of ACM SIGMOD '91 International Conference on Management of Data, </booktitle> <pages> pages 158-167, </pages> <year> 1991. </year>
Reference-contexts: However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. While most object-oriented database proposals include constructors for complex types like lists and arrays <ref> [VD91, BDK92] </ref>, they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists.
Reference: [WJS93] <author> Sean X. Wang, Sushil Jajodia, </author> <title> and V.S. Subrahmanian. Temporal Modules: An Approach Toward Federated Temporal Databases. </title> <booktitle> In Proceedings of ACM SIGMOD '93 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <pages> pages 227-237, </pages> <year> 1993. </year> <pages> Page 12 </pages>
Reference-contexts: The dual nature of sequences (Positional versus Record-Oriented) is recognized by the temporal query language of <ref> [WJS93] </ref>. The extensive work on temporal database modeling, query languages, and query processing [TCG+93] is mostly complementary to our work, because it involves changes to relations and to SQL [TSQL94]. However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa.
References-found: 19

