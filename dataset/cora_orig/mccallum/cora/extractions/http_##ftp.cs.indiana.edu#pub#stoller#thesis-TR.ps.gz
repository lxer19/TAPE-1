URL: http://ftp.cs.indiana.edu/pub/stoller/thesis-TR.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Title: A METHOD AND TOOL FOR ANALYZING FAULT-TOLERANCE IN SYSTEMS  
Author: Scott David Stoller 
Degree: A Dissertation Presented to the Faculty of the Graduate School  in Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy by  
Date: May 1997  
Affiliation: of Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [AH87] <editor> Samson Abramsky and Chris Hankin. </editor> <title> An introduction to abstract interpretation. </title> <editor> In Samson Abramsky and Chris Hankin, editors, </editor> <title> Abstract Interpretation of Declarative Languages, chapter 1. </title> <publisher> Ellis-Horwood, </publisher> <year> 1987. </year>
Reference-contexts: Our approach is not based on exhaustive state-space exploration. Instead, it is a novel hybrid of ideas from stream-processing (or data-flow) semantics of networks of processes [Kah74,Bro87,Bro90], abstract interpretation of programs <ref> [AH87] </ref>, and symbolic computation. An important feature of our approach is that flexible and powerful abstraction mechanisms are incorporated directly into the framework. 1 Having these mechanisms plays a crucial role in making fault-tolerance analysis tractable. <p> For example, in a system with replicated processors, detailed analysis of how the results from different replicas are combined (e.g., voted) may be needed, but other aspects of the processing (e.g., the particular state machine implemented by each replica) 1 Following literature on abstract interpretation (e.g., <ref> [AH87] </ref>) and program refinement (e.g., [KMP94]), we use "abstraction" in the sense of "approximation". This has little to do with the meaning of "abstraction" in the theory of functional programming languages (e.g., [Rea89]) or abstract data types. 4 are treated in our approach by coarse approximations. <p> Multiplicities: The number of times each value is sent. Orderings: The order in which values are sent. Values and their multiplicities are approximated using abstract values, each representing a set of possible values, as in abstract interpretation <ref> [AH87] </ref>. We also use symbolic values, which are expressions composed of constants and variables, to capture additional relationships between values. Orderings are approximated by allowing partial orders, rather than just total orders. <p> Abstract Values An abstract value characterizes the concrete values that might be transmitted in particular messages. This idea is familiar from abstract interpretation <ref> [AH87] </ref>: each element of an abstract interpretation represents a set of concrete values. For example, one way to abstract the real numbers is to keep track only of the sign. <p> Section 6.1 looks to the past, discussing related work. Section 6.2 looks to the future, discussing several directions for future work. 6.1 Related Work Abstract Interpretation Abstract interpretation is an extremely general framework for program analysis <ref> [AH87] </ref>. Our analysis is distinguished from pure abstract interpretation by the use of symbolic values to track relationships between values; thus, our fixed-point analysis incorporates symbolic computation as well as abstract interpretation.
Reference: [AMST93] <author> Gul Agha, Ian A. Mason, Scott Smith, and Carolyn Talcott. </author> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming, </journal> <year> 1993. </year>
Reference-contexts: An alternative approach is to give an operational semantics, in the form of a transition system for some specific agent language (e.g., lambda calculus extended with some primitives for agent creation and communication); this is the approach taken for actors in <ref> [AMST93] </ref>. Automated support for abstractions. As mentioned in Section 6.1, we plan to look at mechanized support for applying abstractions in our framework. This would reduce the burden of proving that input-output functions represent processes. To provide automated support, specific languages must be chosen for expressing processes and input-output functions.
Reference: [BA81] <author> J. Dean Brock and William B. Ackerman. </author> <title> Scenarios: A model of non-determinate computation. </title> <editor> In J. Diaz and I. Ramos, editors, </editor> <booktitle> Formalisation of Programming Concepts, volume 107 of Lecture Notes in Computer Science, </booktitle> <pages> pages 252-259. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: An input-output function is sometimes called a stream-processing function [BD92], stream transformer [DS89], or history function <ref> [BA81] </ref>, because it maps a stream of input messages (the input history) to a stream of output messages (the output history).
Reference: [BD92] <author> Manfred Broy and Claus Dendorfer. </author> <title> Modelling operating system structures by timed stream processing functions. </title> <journal> Journal of Functional Programming, </journal> <volume> 2 </volume> <pages> 1-21, </pages> <year> 1992. </year>
Reference-contexts: An input-output function takes as argument the sequences of messages received by a component (during some computation) and returns the sequences of messages sent by that component as a result of receiving those messages. An input-output function is sometimes called a stream-processing function <ref> [BD92] </ref>, stream transformer [DS89], or history function [BA81], because it maps a stream of input messages (the input history) to a stream of output messages (the output history). <p> For example, one might take crash i to denote a crash that occurs after the component sends i messages. Or, if a synchronous system is being 84 modeled using a distinguished value| called "tick"|to model the passage of time <ref> [Bro90, BD92] </ref>, one might take crash i to denote a crash that occurs after i ticks. Abstracting from timing of failures reduces the number of failure scenarios that need to be analyzed and thereby makes the analysis more efficient. <p> This is a special case of Broy and Dendorfer's time progress property <ref> [BD92] </ref>.
Reference: [BKRS96] <author> J. F. Buss, P.C. Kanellakis, P. L. Ragde, and A. Shvartsman. </author> <title> Parallel algorithms with processor failures and delays. </title> <journal> Journal of Algorithms, </journal> <year> 1996. </year>
Reference: [BM82] <author> R. J. R. Back and H. Mannila. </author> <title> A refinement of kahn's semantics to handle non-determinism and communication. </title> <booktitle> In Proc. First ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 111-120, </pages> <year> 1982. </year>
Reference: [Bro83] <author> J. Dean Brock. </author> <title> A Formal Model of Non-Determinate Dataflow Computation. </title> <type> Ph.D. dissertation, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1983. </year> <note> Available as MIT Laboratory for Computer Science Technical Report TR-309. </note>
Reference: [Bro87] <author> Manfred Broy. </author> <title> Semantics of finite and infinite networks of concurrent communicating agents. </title> <journal> Distributed Computing, </journal> <volume> 2(1) </volume> <pages> 13-31, </pages> <year> 1987. </year>
Reference-contexts: Restriction to determinate systems is a severe limitation, and approaches to eliminating this restriction have been suggested [BA81,BM82,SN85,Bro87, Jon89,Bro90,Rus90]. Here, we will adopt a slight variant of an approach due to Broy <ref> [Bro87, Bro90] </ref>. Two ideas are involved: one to handle non-determinism, and a second to handle non-strictness. The idea for handling non-determinism is to represent a non-deterministic process as a set of determinate processes: each determinate process in the set corresponds 15 to one possible behavior of the non-deterministic process.
Reference: [Bro88] <author> Manfred Broy. </author> <title> Nondeterministic data flow programs: how to avoid the merge anomaly. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 10 </volume> <pages> 65-85, </pages> <year> 1988. </year>
Reference: [Bro90] <author> Manfred Broy. </author> <title> Functional specification of time sensitive communicating systems. </title> <booktitle> In Proceedings of the REX Workshop on Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 153-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <pages> 155 156 </pages>
Reference-contexts: Restriction to determinate systems is a severe limitation, and approaches to eliminating this restriction have been suggested [BA81,BM82,SN85,Bro87, Jon89,Bro90,Rus90]. Here, we will adopt a slight variant of an approach due to Broy <ref> [Bro87, Bro90] </ref>. Two ideas are involved: one to handle non-determinism, and a second to handle non-strictness. The idea for handling non-determinism is to represent a non-deterministic process as a set of determinate processes: each determinate process in the set corresponds 15 to one possible behavior of the non-deterministic process. <p> For example, one might take crash i to denote a crash that occurs after the component sends i messages. Or, if a synchronous system is being 84 modeled using a distinguished value| called "tick"|to model the passage of time <ref> [Bro90, BD92] </ref>, one might take crash i to denote a crash that occurs after i ticks. Abstracting from timing of failures reduces the number of failure scenarios that need to be analyzed and thereby makes the analysis more efficient.
Reference: [BZ83] <author> D. Brand and P. Zafiropulo. </author> <title> On communicating finite-state machines. </title> <journal> Journal of the ACM, </journal> <volume> 30(2) </volume> <pages> 323-342, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: In general, the framework supports rather than enforces approximations. With this flexibility comes a burden on the user to select appropriate approximations. This burden seems inevitable, since verification of asynchronous systems with channels of unbounded capacity is undecidable <ref> [BZ83] </ref>. Failure Propagation and Transformation Notation In their work on applying HAZOP and FMECA to computer-based systems, McDermid et al. [FM93,FMNP94,MNPF95] have developed an approach to validation of fault-tolerance that shares with our work the idea of characterizing each component by how it generates and propagates "failures" (perturbations).
Reference: [CdR93] <author> Antonio Cau and Willem-Paul de Roever. </author> <title> Using relative refinement for fault tolerance. </title> <editor> In J.C.P. Woodcock and P.G. Larsen, editors, FME'93: </editor> <title> Industrial-Strength Formal Methods. </title> <booktitle> First International Symposium of Formal Methods Europe, </booktitle> <pages> pages 19-41, </pages> <year> 1993. </year>
Reference: [CGL92] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference: [CGL94] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Proof techniques designed specifically for verification of fault-tolerance have been proposed [CdR93,Web93,PJ94,Sch94]. These techniques do facilitate proofs of fault-tolerance, but still require considerable logical expertise of the user. 3 Automated verification techniques have received increasing attention in recent years, largely as a result of advances in temporal-logic model-checking <ref> [CGL94] </ref> and automata-and process-based verification techniques [Hol91,Kur94,CS96]. The techniques are largely based on exhaustive exploration of finite state spaces. They are particularly well-suited to hardware verification and have been applied predominantly thereto. <p> They also propose so-called symbolic abstractions, which are just abbreviations for finite families of (non-symbolic) abstractions. Our symbolic values are closer to the technique they sketch in the last paragraph of <ref> [CGL94] </ref> for dealing with infinite-state systems. In Kurshan's automata-based verification methodology, approximations are embodied in reductions between verifications [Kur89,Kur94]. A typical use of a reduction is to collapse multiple states of an automaton into a single state of a reduced automaton; this is analogous to introducing abstract values.
Reference: [CR93] <author> Ran Canetti and Tal Rabin. </author> <title> Fast asynchronous Byzantine agreement with optimal resilience. </title> <booktitle> In 25th Symposium on Theory of Computing, </booktitle> <pages> pages 42-51. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Applications. To test and refine the approach|and the tool described in Appendix B| we must apply them to more problems. Possible applications include efficient algorithms for asynchronous Byzantine Agreement <ref> [CR93] </ref>, algorithms for the certified write-all problem [KMS95,BKRS96], secure protocols for group membership and reliable broadcast [Rei96, MR96], and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [CS96] <author> Rance Cleaveland and Steve Sims. </author> <title> The ncsu concurrency workbench. </title> <editor> In Ra-jeev Alur and Tom Henzinger, editors, </editor> <booktitle> Computer-Aided Verification (CAV '96), volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 394-397. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This is attractive because fault-masking properties can be expressed in terms of bisimilarity: 1 a system masks a fault iff the fault causes transitions only between bisimilar states. Thus, this approach allows one to leverage work on checking bisimilarity <ref> [CS96] </ref>. This technique is interesting but limited in applicability to systems in which faults are completely masked. Abstraction in Model Checking Abstractions play an important role in our work. Clarke, Grumberg, and Long studied the use of the abstractions in conjunction with temporal-logic model-checking [CGL92,CGL94].
Reference: [DBC91] <author> Ben L. Di Vito, Ricky W. Butler, and James L. Caldwell. </author> <title> High level design proof of a reliable computing platform. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <title> Dependable Computing for Critical Applications 2, </title> <booktitle> volume 6 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 279-306. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Also, analysis of a Byzantine Agreement algorithm could 1 Their second solution, the Signed Messages algorithm, requires digital signatures and can only be ana lyzed using the techniques presented in Chapter 5. 80 81 provide a starting point for analysis of more complicated systems, such as digital flight control systems <ref> [DBC91] </ref>, in which a Byzantine Agreement algorithm is only one of the fault-tolerance mechanisms. 4.1 Reliable Broadcast Section 4.1.1 introduces a reliable broadcast protocol and its specification; both are adopted from [HT94]. Section 4.1.2 discusses modeling of crash failures for this protocol and gives an analysis of relationships between multiplicities.
Reference: [DS89] <author> Peter Dybjer and Herbert P. Sander. </author> <title> A functional programming approach to the specification and verification of concurrent systems. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1 </volume> <pages> 303-319, </pages> <year> 1989. </year>
Reference-contexts: An input-output function takes as argument the sequences of messages received by a component (during some computation) and returns the sequences of messages sent by that component as a result of receiving those messages. An input-output function is sometimes called a stream-processing function [BD92], stream transformer <ref> [DS89] </ref>, or history function [BA81], because it maps a stream of input messages (the input history) to a stream of output messages (the output history).
Reference: [FM93] <author> P. Fenelon and J. A. McDermid. </author> <title> An integrated toolset for software safety analysis. </title> <journal> Journal of Systems and Software, </journal> <volume> 21(3) </volume> <pages> 279-290, </pages> <year> 1993. </year>
Reference: [FMNP94] <author> P. Fenelon, J. A. McDermid, M. Nicholson, and D. J. Pumfrey. </author> <title> Towards integrated safety analysis and design. </title> <journal> ACM Computing Reviews, </journal> <volume> 2(1) </volume> <pages> 21-32, </pages> <year> 1994. </year>
Reference: [GLR95] <author> Li Gong, Patrick Lincoln, and John Rushby. </author> <title> Byzantine agreement with authentication: Observations and applications in tolerating hybrid and link faults. </title> <booktitle> In Dependable Computing for Critical Applications|5, </booktitle> <pages> pages 79-90. </pages> <booktitle> IFIP WG 10.4, preliminary proceedings, </booktitle> <year> 1995. </year>
Reference-contexts: We plan to look at mechanized support for applying abstractions in our framework. Verification of Byzantine Agreement Algorithms Our approach to fault-tolerance analysis is similar in spirit to the state-exploration technique of Gong, Lincoln, and Rushby <ref> [GLR95] </ref>. In both cases, an automated analysis is used to compute and evaluate the behavior of the system separately in each failure scenario of interest. However, the work described in [GLR95] apparently does not include the use of any form of abstraction. 6.2 Future Work This section describes some possible extensions <p> Agreement Algorithms Our approach to fault-tolerance analysis is similar in spirit to the state-exploration technique of Gong, Lincoln, and Rushby <ref> [GLR95] </ref>. In both cases, an automated analysis is used to compute and evaluate the behavior of the system separately in each failure scenario of interest. However, the work described in [GLR95] apparently does not include the use of any form of abstraction. 6.2 Future Work This section describes some possible extensions of and variations on our work. Inter-channel orderings. Because our representation of runs contains no inter-channel orderings, our analysis suffers (in effect) from the merge anomaly [Kel78,Bro88].
Reference: [Gun92] <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year> <month> 157 </month>
Reference-contexts: A function f 2 S ! S is continuous if it is (1) monotonic and (2) preserves least upper bounds of !-chains, i.e., for all !-chains oe, f (lub (oe)) = lub (hhf (oe [i])ii i2N ). Among the most celebrated and useful properties of !-cpos is <ref> [Gun92, chapter 4] </ref>: Theorem 2.1. Let hS; S i be an !-cpo. Let f be a continuous function in S ! S, and let x 2 S be such that x S f (x). Then f has a fixed-point in the upper-closure of x in S.
Reference: [Hol91] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: This would reduce the burden of proving that input-output functions represent processes. To provide automated support, specific languages must be chosen for expressing processes and input-output functions. For the former, a language like PROMELA could be used <ref> [Hol91] </ref>; for the latter, a functional subset of CAML. An abstraction would be embodied as a transformation T that maps a process P to an input-output function T (p) that represents P (and incorporates the abstraction).
Reference: [HT94] <author> Vassos Hadzilacos and Sam Toueg. </author> <title> A modular approach to fault-tolerant broadcasts and related problems. </title> <type> Technical Report TR 94-1425, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: Limitations of this approach are discussed, motivating the introduction of explicit perturbations, which enable expression of additional correlations between the failure-free and faulty behaviors of a component. Chapter 4 analyzes algorithms for two classic problems in fault-tolerance: Byzantine agreement [LSP82] and reliable broadcast <ref> [HT94] </ref>. These examples illustrate analysis of systems subject to Byzantine failures and crash failures, respectively. Chapter 5 applies our framework to fault-tolerant moving agents, a more recent concern. This illustrates how our analysis methods can be applied to protocols that employ cryptographic techniques. <p> Thus, determining the number of messages is also, in general, impossible. Uncertainty in the number of messages is handled in the abstract framework by using multiplicities, which are approximations of numbers of messages. For example, a component subject to send-omission failures <ref> [HT94, Section 2.3] </ref>, which cause a component to possibly omit the sending of each message normally produced, might emit each output with a multiplicity of either zero or one. <p> To illustrate the use of these two frameworks, we apply each to one classic problem in fault-tolerance. The non-perturbational framework is applied to a protocol for reliable broadcast that tolerates patterns of crash failures that don't partition the network <ref> [HT94, section 6] </ref>. This example demonstrates the power of symbolic multiplicities for efficient analysis of systems subject to crash failures. Showing that the protocol satisfies the basic requirements of validity, agreement and integrity [HT94, section 3] is straightforward, because these properties depend mainly on equalities between multiplicities. <p> This example demonstrates the power of symbolic multiplicities for efficient analysis of systems subject to crash failures. Showing that the protocol satisfies the basic requirements of validity, agreement and integrity <ref> [HT94, section 3] </ref> is straightforward, because these properties depend mainly on equalities between multiplicities. Showing that the protocol also provides FIFO message delivery requires analyzing inequalities between multiplicities. Invariants are useful for this. Next, the perturbational framework is applied to a protocol for Byzantine Agreement. <p> 5. 80 81 provide a starting point for analysis of more complicated systems, such as digital flight control systems [DBC91], in which a Byzantine Agreement algorithm is only one of the fault-tolerance mechanisms. 4.1 Reliable Broadcast Section 4.1.1 introduces a reliable broadcast protocol and its specification; both are adopted from <ref> [HT94] </ref>. Section 4.1.2 discusses modeling of crash failures for this protocol and gives an analysis of relationships between multiplicities. <p> Informally, the reliable broadcast protocol in <ref> [HT94, section 6.3] </ref> is as follows. A client C i initiates a broadcast of a message by sending the message to its server S i . When a server receives a message, it checks whether it has received that message before. <p> When a server receives a message, it checks whether it has received that message before. If so, it ignores the message; if not, it sends the message to all of its neighbors. When a client receives a message from its server, we say it delivers that message. Following <ref> [HT94, section 3.1] </ref>, we assume: Known-Sender: Each message contains the name of its sender. Uniqueness: Clients send each message at most once. This is easily implemented by including a unique identifier, such as a sequence number or timestamp, in each message. <p> Since multiplicities play a central role in analysis of reliable broadcast, we do not elide any multiplicities in figures in Section 4.1. Specification. The defining properties of reliable broadcast are <ref> [HT94, section 3] </ref>: Validity: If a client C i broadcasts a message m and corresponding server S i is non faulty, then C i eventually delivers m. <p> In the figure, x:y abbreviates C 1 :0:x:y. failures; recall from Section 2.2.3 that send-omission failures cause a component to possibly omit the sending of each message normally produced <ref> [HT94, Section 2.3] </ref>.
Reference: [Jon89] <author> Bengt Jonsson. </author> <title> A fully abstract trace model for dataflow networks. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 155-165, </pages> <year> 1989. </year>
Reference: [Kah74] <author> Gilles Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <editor> In J. L. Rosenfeld, editor, </editor> <booktitle> Information Processing 74: Proceedings of the IFIP Congress 74, </booktitle> <pages> pages 471-475. </pages> <publisher> North-Holland, </publisher> <year> 1974. </year>
Reference-contexts: Appendix A contains an index of symbols. Appendix B describes our prototype implementation of and graphical interface for the analysis. Chapter 2 Analyzing Systems that Never Fail Our system model is based on Gilles Kahn's stream-processing model of parallel and distributed systems <ref> [Kah74] </ref>. For concreteness, we, like Kahn, consider systems of components that communicate through asynchronous FIFO channels. However, this assumption is not essential to our approach. The system model presented in this chapter differs from other descendants of Kahn's model mainly by having mechanisms that allow approximation of system behavior. <p> Finally, Section 2.5 discusses conditions under which a fixed-point is guaranteed to exist and under which iterative calculation of the fixed-point is guaranteed to terminate. 9 10 2.1 Concrete Model Kahn's original model <ref> [Kah74] </ref> handles only determinate systems, systems in which each component is: Deterministic: For each possible sequence of inputs, the component has exactly one possible sequence of outputs. <p> system is represented by a run cr satisfying (8x 2 Name : (8y 2 Name : cr (y)(x) = np (x)(cr (x))(y))); (2.7) more precisely, it is represented by the least such run, where the ordering CRun on CRun is the pointwise extension of the ordering CHist on concrete histories <ref> [Kah74] </ref>. Equivalently, this run can be characterized as the least fixed-point of step (np) 2 CRun ! CRun. 1 Thus, the run representing the behavior of system np is crun (np) = lfp (step (np)): (2.8) This model has two main attractions for us, besides its elegance.
Reference: [Kel78] <author> R. M. Keller. </author> <title> Denotational models for parallel programs with indeterminate operators. </title> <editor> In E. J. Neuhold, editor, </editor> <booktitle> Formal Description of Programming Concepts, </booktitle> <pages> pages 337-366. </pages> <publisher> North Holland, </publisher> <year> 1978. </year>
Reference: [KMP94] <author> Yonit Kesten, Zohar Manna, and Amir Pnueli. </author> <title> Temporal verification of simulation and refinement. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proc. REX School/Symposium, volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 273-346. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: example, in a system with replicated processors, detailed analysis of how the results from different replicas are combined (e.g., voted) may be needed, but other aspects of the processing (e.g., the particular state machine implemented by each replica) 1 Following literature on abstract interpretation (e.g., [AH87]) and program refinement (e.g., <ref> [KMP94] </ref>), we use "abstraction" in the sense of "approximation". This has little to do with the meaning of "abstraction" in the theory of functional programming languages (e.g., [Rea89]) or abstract data types. 4 are treated in our approach by coarse approximations. Such abstraction is crucial for making the analysis tractable.
Reference: [KMS95] <author> P.C. Kanellakis, D. Michailidis, and A. Shvartsman. </author> <title> Controlling memory access in efficient fault-tolerant parallel algorithms. </title> <journal> Nordic Journal of Computing, </journal> <year> 1995. </year>
Reference: [Kur89] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proc. of the REX Workshop on Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 414-453. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [Kur94] <author> Robert P. Kurshan. </author> <title> Computer-aided verification of coordinating processes: the automata-theoretic approach. </title> <publisher> Princeton Univesity Press, </publisher> <year> 1994. </year>
Reference-contexts: For example, to verify that a bounded-length queue containing numbers in [1::n] does not drop items, one can use a family of reductions that collapses the set [1::n] of concrete data values to two abstract data values: the one being "focused on", specified as a parameter, and "everything else" <ref> [Kur94, Appendix D] </ref>. The relationship captured here is equality of each value with the concrete 1 Roughly, states s and s 0 are bisimilar if the set of visible behaviors possible starting from state s equals the set of visible behaviors possible starting from state s 0 . <p> Because our representation of runs contains no inter-channel orderings, our analysis suffers (in effect) from the merge anomaly [Kel78,Bro88]. Specifically, 2 Although the method just described is one way to prove that the queue doesn't drop items, it is apparently not the method Kurshan has in mind, since in <ref> [Kur94, Appendix D] </ref>, the reduction is not actually parameterized: the concrete value being focused on is fixed to be 1. Presumably Kurshan has in mind the following method. Let Qred i be the reduced automaton obtained from the reduction h i that focuses on the concrete value i.
Reference: [Lam93] <author> Leslie Lamport. </author> <title> How to write a long formula. </title> <type> Technical Report SRC-119, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: The conjunction in (2.14) is written using Lamport's bullet-style notation <ref> [Lam93] </ref>. In 16 this notation, the conjunction b 1 ^ b 2 ^ ^ b n is written ^ b 1 . . .
Reference: [Ler97] <author> Xavier Leroy. </author> <title> The Caml Light System. </title> <note> INRIA, 1997. Available via http://pauillac.inria.fr/caml/. </note>
Reference-contexts: We also use the following constructs from the functional programming language CAML Light <ref> [Ler97] </ref>, a dialect of Standard ML [MTH90]. 29 Conditionals. The conditional expression if b then e 1 else e 2 has the obvious meaning. Comments. Comments begin with (* and end with *). Binding. <p> This appendix sketches the structure and use of CRAFT. B.1 Overview CRAFT is implemented in the functional programming language CAML Light <ref> [Ler97] </ref>, a dialect of Standard ML [MTH90]. CRAFT provides a collection of CAML types and functions that implement the non-perturbational and perturbational analysis frameworks described in Chapter 3. CRAFT also provides a graphical interface to facilitate entry of systems and inspection of analysis results.
Reference: [LJ92] <author> Zhiming Liu and Mathai Joseph. </author> <title> Transformation of programs for fault-tolerance. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4 </volume> <pages> 442-469, </pages> <year> 1992. </year>
Reference: [LM94] <author> Leslie Lamport and Stephan Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 41-76. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <month> 158 </month>
Reference-contexts: We analyze the first of those, namely, the Oral Messages algorithm. 1 We use the perturbational framework for this problem, because the correctness requirements are easily expressed in terms of acceptable changes. One motivation for analyzing a Byzantine Agreement algorithm that has already been proved correct <ref> [LM94] </ref> is to allow that algorithm to be used as a benchmark for comparison of different verification methods.
Reference: [LR93] <author> Patrick Lincoln and John Rushby. </author> <title> A formally verified algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Proc. 23rd Intl. Symposium on Fault Tolerant Computing, </booktitle> <year> 1993. </year>
Reference-contexts: For example, one might guess that replication and voting is an easy (albeit expensive) way to achieve fault-tolerance. However, the extensive literature on Byzantine agreement, and errors like the one described in <ref> [LR93] </ref>, show that efficiently coordinating non-faulty replicas in the presence of arbitrary behavior by faulty replicas is a difficult problem. The difficulty of analyzing fault-tolerance by informal methods has inspired the development and application of rigorous methods. One approach is to apply general-purpose proof-based verification techniques.
Reference: [LSP82] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Limitations of this approach are discussed, motivating the introduction of explicit perturbations, which enable expression of additional correlations between the failure-free and faulty behaviors of a component. Chapter 4 analyzes algorithms for two classic problems in fault-tolerance: Byzantine agreement <ref> [LSP82] </ref> and reliable broadcast [HT94]. These examples illustrate analysis of systems subject to Byzantine failures and crash failures, respectively. Chapter 5 applies our framework to fault-tolerant moving agents, a more recent concern. This illustrates how our analysis methods can be applied to protocols that employ cryptographic techniques. <p> Showing that the protocol also provides FIFO message delivery requires analyzing inequalities between multiplicities. Invariants are useful for this. Next, the perturbational framework is applied to a protocol for Byzantine Agreement. A seminal paper by Lamport, Shostak, and Pease defines the problem of Byzantine Agreement and presents two solutions <ref> [LSP82] </ref>. We analyze the first of those, namely, the Oral Messages algorithm. 1 We use the perturbational framework for this problem, because the correctness requirements are easily expressed in terms of acceptable changes. <p> The goal of a Byzantine Agreement protocol is for the commander to disseminate a command to the lieutenants, so they can then act on this command. A lieutenant L i acts on (or "decides on", in the terminology of <ref> [LSP82] </ref>) a command by sending a message containing that command to its army A i . Thus, the set of components in the system is Name = fCg [ Ltnts [ ( [ fA i g) (4.11) 95 where Ltnts = [ fL i g The Oral Messages algorithm of [LSP82] <p> <ref> [LSP82] </ref>) a command by sending a message containing that command to its army A i . Thus, the set of components in the system is Name = fCg [ Ltnts [ ( [ fA i g) (4.11) 95 where Ltnts = [ fL i g The Oral Messages algorithm of [LSP82] to solve this problem works under the following assumptions about the underlying communication mechanism: Integrity: Every message that is sent is delivered correctly. Known-Sender: The receiver of a message knows who sent it. Missing-Message-Detection: The absence of a message can be detected. <p> By this convention, receiving tmout corresponds to detecting absence of a message. This convention is used at both the concrete and abstract levels, so we treat timeout as both a concrete value and an abstract value, with [[tmout ]] AVal = ftmout g. The basic Oral Messages algorithm of <ref> [LSP82] </ref> further assumes that the commander and lieutenants can communicate with each other directly. We associate with each component x 2 Name the set nbrs (x) Name of its neighbors, i.e., the set of components with which it can communicate directly. <p> In a framework without explicit perturbations, the specification would have to involve the commander's inputs and outputs as well. The Oral Messages algorithm of <ref> [LSP82] </ref> is essentially a recursive application of majority voting. The interesting aspects of its behavior can already be seen in the case n = 3, which exhibits a single level of recursion plus the base case. <p> To prevent confusion between messages generated by different recursive calls to the Byzantine Agreement protocol, each message is tagged with an identifier indicating which invocation of the protocol it belongs to. A simple scheme for choosing these identifiers is described in <ref> [LSP82] </ref>. Extending the definitions in this section to arbitrary n involves little more than the additional bookkeeping needed to keep track of these identifiers.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: The relationship captured here is equality of each value with the concrete 1 Roughly, states s and s 0 are bisimilar if the set of visible behaviors possible starting from state s equals the set of visible behaviors possible starting from state s 0 . For details, see <ref> [Mil89] </ref>. 133 value being focused on. 2 The parameter of the reduction corresponds in our framework to use of a variable representing the focused-on value. For problems involving related values (e.g., X and F (X)), the reductions must introduce an abstract data value representing each such value.
Reference: [MNPF95] <author> J. A. McDermid, M. Nicholson, D. J. Pumfrey, and P. Fenelon. </author> <title> Experience with the application of HAZOP to computer-based systems. </title> <booktitle> In Proc. 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 37-48, </pages> <year> 1995. </year>
Reference: [MR96] <author> Dalia Malki and Michael Reiter. </author> <title> A high-throughput secure reliable multicast protocol. </title> <booktitle> In Proc. of the 9th IEEE Computer Security Foundations Workshop, </booktitle> <pages> page 9=17. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: Applications. To test and refine the approach|and the tool described in Appendix B| we must apply them to more problems. Possible applications include efficient algorithms for asynchronous Byzantine Agreement [CR93], algorithms for the certified write-all problem [KMS95,BKRS96], secure protocols for group membership and reliable broadcast <ref> [Rei96, MR96] </ref>, and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The set of symbolic values is obtained from SVal 0 by adding the underscore symbol, which is used as a wildcard: 6 SVal = SVal 0 [ f g (2.37) As in pattern-matching in the programming language ML <ref> [MTH90] </ref>, the wildcard can represent any value. This is especially significant when the wildcard appears in ms-atoms 6 We could allow the wildcard to appear within larger symbolic values, but this slightly complicates the semantics, and it's not clear whether it is useful. 23 that may represent multiple messages. <p> We also use the following constructs from the functional programming language CAML Light [Ler97], a dialect of Standard ML <ref> [MTH90] </ref>. 29 Conditionals. The conditional expression if b then e 1 else e 2 has the obvious meaning. Comments. Comments begin with (* and end with *). Binding. <p> This appendix sketches the structure and use of CRAFT. B.1 Overview CRAFT is implemented in the functional programming language CAML Light [Ler97], a dialect of Standard ML <ref> [MTH90] </ref>. CRAFT provides a collection of CAML types and functions that implement the non-perturbational and perturbational analysis frameworks described in Chapter 3. CRAFT also provides a graphical interface to facilitate entry of systems and inspection of analysis results.
Reference: [MvRSS96] <author> Yaron Minsky, Robbert van Renesse, Fred B. Schneider, and Scott Stoller. </author> <title> Cryptographic support for fault-tolerant distributed computing. </title> <booktitle> In Proc. Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 109-114. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: We now describe this protocol in more detail. A message sent by a source with private key k has the form sign (hdata; dest i; k) (5.1) 3 A protocol based on shared secrets is described in <ref> [MvRSS96] </ref>. 109 where data is the data carried by the message, dest is the first service or consolidator to be visited, and sign (x; k) represents x digitally signed with key k. <p> Possible applications include efficient algorithms for asynchronous Byzantine Agreement [CR93], algorithms for the certified write-all problem [KMS95,BKRS96], secure protocols for group membership and reliable broadcast [Rei96, MR96], and cryptographic protocols for fault-tolerant moving agents <ref> [MvRSS96] </ref>.
Reference: [ORSvH95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of pvs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The third step is to check whether a system will satisfy its fault-tolerance requirements. Experience has shown that informal arguments about fault-tolerance are error-prone and do not supply the desired level of assurance for critical systems <ref> [ORSvH95] </ref>. For example, one might guess that replication and voting is an easy (albeit expensive) way to achieve fault-tolerance.
Reference: [PJ94] <author> Doron Peled and Mathai Joseph. </author> <title> A compositional framework for fault-tolerance by specification transformation. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 128(1-2):99-125, </address> <year> 1994. </year>
Reference: [Pra82] <author> Vaughan R. Pratt. </author> <booktitle> On the composition of processes. In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-223. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: A more promising remedy is to add inter-channel orderings to the representation of runs. This is one of the ideas behind Brock and Ackermann's scenarios [BA81,Bro83] and Pratt's model of processes <ref> [Pra82] </ref>. In both of those models, a process is a (potentially infinite) set, each element of which represents a complete (and potentially infinite) behavior.
Reference: [Rea89] <author> Chris Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This has little to do with the meaning of "abstraction" in the theory of functional programming languages (e.g., <ref> [Rea89] </ref>) or abstract data types. 4 are treated in our approach by coarse approximations. Such abstraction is crucial for making the analysis tractable. Our analysis uses a fixed-point calculation to determine three kinds of information that, together, characterize system behavior: Values: The data sent in messages.
Reference: [Rei96] <author> Michael K. Reiter. </author> <title> A secure group membership protocol. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 31-42, </pages> <year> 1996. </year>
Reference-contexts: Applications. To test and refine the approach|and the tool described in Appendix B| we must apply them to more problems. Possible applications include efficient algorithms for asynchronous Byzantine Agreement [CR93], algorithms for the certified write-all problem [KMS95,BKRS96], secure protocols for group membership and reliable broadcast <ref> [Rei96, MR96] </ref>, and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [RSA78] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: We consider a protocol in which digital signatures <ref> [RSA78] </ref> are used by the consolidator to reliably determine this. 3 We assume digital signatures are implemented using public-key cryptography and that each component knows its own private key and the public key of every other component. We also assume each component knows which service is provided by each component.
Reference: [Rus90] <author> James Robert Russell. </author> <title> Full Abstraction and Fixed-Point Principles for Indeterminate Computation. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1990. </year> <month> 159 </month>
Reference: [Sca62] <author> James B. Scarborough. </author> <title> Numerical Mathematical Analysis. </title> <publisher> The Johns Hopkins Press, </publisher> <address> 5th edition, </address> <year> 1962. </year>
Reference-contexts: Explicit perturbations may be unfamiliar in fault-tolerance analysis, but they are analogous to familiar techniques for analysis of numerical error <ref> [Sca62] </ref>. Error analysis focuses on how numerical errors introduced in one part of the computation are propagated by subsequent computation. Analogously, fault-tolerance analysis with explicit perturbations focuses on how perturbations introduced by failures are propagated during subsequent execution of the system.
Reference: [Sch94] <author> Henk Schepers. </author> <title> A trace-based compositional proof theory for fault tolerant distributed systems. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 128(1-2):127-157, </address> <year> 1994. </year>
Reference: [SN85] <author> John Staples and V. L. Nguyen. </author> <title> A fixpoint semantics for nondeterministic data flow. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 411-444, </pages> <month> April </month> <year> 1985. </year>
Reference: [W + 78] <editor> John H. Wensley et al. Sift: </editor> <title> Design and analysis of a fault-tolerant computer for aircraft control. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 66(10) </volume> <pages> 1240-1255, </pages> <year> 1978. </year>
Reference-contexts: The difficulty of analyzing fault-tolerance by informal methods has inspired the development and application of rigorous methods. One approach is to apply general-purpose proof-based verification techniques. Work on SIFT <ref> [W + 78] </ref>, an aircraft control computer, is a classic example; indeed, this is one of the earliest applications of any rigorous approach to fault-tolerance. Mechanized support, in the form of a theorem-proving system, typically helps to manage the large and complex proofs.
Reference: [Web93] <author> Doug G. Weber. </author> <title> Fault tolerance as self-similarity. </title> <editor> In Jan Vytopil, editor, </editor> <booktitle> Formal techniques in real-time and fault-tolerant systems, </booktitle> <pages> pages 33-49. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: For example, in the analysis of the cryptography-based protocol in Chapter 5, we introduce Arb and use it to represent (roughly speaking) the set of cryptographic information known to each faulty component. 132 Fault-Tolerance as Self-Similarity Fault-tolerance as self-similarity <ref> [Web93] </ref> shares with our work the goals of separating the specification of fault-tolerance from other correctness requirements and developing specialized techniques for verification of fault-tolerance requirements. To achieve this, Weber adopts a rigid notion of fault-tolerance: he equates fault-tolerance with fault-masking.
References-found: 54

