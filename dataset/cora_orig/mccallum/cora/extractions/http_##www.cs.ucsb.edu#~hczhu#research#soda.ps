URL: http://www.cs.ucsb.edu/~hczhu/research/soda.ps
Refering-URL: http://www.cs.ucsb.edu/~hczhu/researchlink.html
Root-URL: http://www.cs.ucsb.edu
Title: Adaptive Algorithms for Cache-efficient Trie Search  
Author: Anurag Acharya, Huican Zhu, Kai Shen 
Address: Santa Barbara, CA 93106  
Affiliation: Dept. of Computer Science University of California,  
Abstract: In this paper, we present cache-efficient algorithms for trie search. There are three key features of these algorithms. First, they use different data structures (partitioned-array, B-tree, hashtable, vectors) to represent different nodes in a trie. The choice of the data structure depends on cache characteristics as well as the fanout of the node. Second, they adapt to changes in the fanout at a node by dynamically switching the data structure used to represent the node. Third, the size and the layout of individual data structures is determined based on the size of the symbols in the alphabet as well as characteristics of the cache(s). We evaluate the performance of these algorithms on real and simulated memory hierarchies. Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration. A comparison of the number of instructions executed indicates that these algorithms derive their performance advantage primarily by making better use of the memory hierarchy.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, T. Imielinski, and A. Swami. </author> <title> Mining association rules between sets of items in large data bases. </title> <booktitle> In Proc. of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 207-16, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing [6, 7, 8, 14, 22], itemset lookup for mining association rules in retail transactions <ref> [1, 2] </ref>, IP address lookup in network routers [26, 27] and partial match queries [13, 24]. There has been much work on reducing the storage requirement and the instruction count for tries for example [3, 5, 4, 6, 19, 20, 22]. <p> Tries are used in this application to store the candidate itemsets and to help determine the frequent itemsets. The dataset used in our experiments was generated using the Quest datamining dataset generator which we obtained from IBM Almaden [23]. This dataset generator has been widely used in datamining research <ref> [1, 2, 15, 28, 29] </ref>. The alphabet for this dataset contained 10,000 symbols (corresponding to 10,000 items). Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration. <p> We selected this algorithm for our experiments as an algorithm similar to this is proposed by several researchers for maintaining frequent itemsets for mining association rules <ref> [1, 2, 15] </ref>. 4 Results for the dictionary dataset. The adaptive algorithm significantly outperforms the ternary search tree on all three machines by a factor of 1.7 on the Origin-2000 and by a factor of 4 on the Ultra-2 and the Ultra-30. the hashtable-trie algorithms for the datamining dataset.
Reference: [2] <author> R. Agrawal and R. Srikant. </author> <title> Fast algorithms for mining association rules. </title> <booktitle> In Proceedings of the 20th International Conference on Very Large Databases, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing [6, 7, 8, 14, 22], itemset lookup for mining association rules in retail transactions <ref> [1, 2] </ref>, IP address lookup in network routers [26, 27] and partial match queries [13, 24]. There has been much work on reducing the storage requirement and the instruction count for tries for example [3, 5, 4, 6, 19, 20, 22]. <p> Tries are used in this application to store the candidate itemsets and to help determine the frequent itemsets. The dataset used in our experiments was generated using the Quest datamining dataset generator which we obtained from IBM Almaden [23]. This dataset generator has been widely used in datamining research <ref> [1, 2, 15, 28, 29] </ref>. The alphabet for this dataset contained 10,000 symbols (corresponding to 10,000 items). Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration. <p> We selected this algorithm for our experiments as an algorithm similar to this is proposed by several researchers for maintaining frequent itemsets for mining association rules <ref> [1, 2, 15] </ref>. 4 Results for the dictionary dataset. The adaptive algorithm significantly outperforms the ternary search tree on all three machines by a factor of 1.7 on the Origin-2000 and by a factor of 4 on the Ultra-2 and the Ultra-30. the hashtable-trie algorithms for the datamining dataset.
Reference: [3] <author> E. Ai-Sunwaiyel and E. Horowitz. </author> <title> Algorithms for trie compaction. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(2) </volume> <pages> 243-63, </pages> <year> 1984. </year>
Reference-contexts: There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation <ref> [3, 17, 20] </ref>. The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed [7, 9].
Reference: [4] <author> J. Aoe, K. Marimoto, and T. Sato. </author> <title> An efficient implementation of trie structure. </title> <journal> Software Practice and Experience, </journal> <volume> 22(9) </volume> <pages> 695-721, </pages> <year> 1992. </year>
Reference-contexts: There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The first approach focuses on reducing the number of instructions executed by reducing the number of nodes and levels in the trie <ref> [5, 4, 6, 12, 19, 22] </ref>. The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation [3, 17, 20].
Reference: [5] <author> J. Aoe, K. Morimoto, M. Shishibori, and K. Park. </author> <title> A trie compaction algorithm for a large set of keys. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 8(3) </volume> <pages> 476-91, </pages> <year> 1996. </year>
Reference-contexts: There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The first approach focuses on reducing the number of instructions executed by reducing the number of nodes and levels in the trie <ref> [5, 4, 6, 12, 19, 22] </ref>. The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation [3, 17, 20].
Reference: [6] <author> A. Appel and G. Jacobson. </author> <title> The world's fastest scrabble program. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 572-8, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing <ref> [6, 7, 8, 14, 22] </ref>, itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries [13, 24]. <p> There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The first approach focuses on reducing the number of instructions executed by reducing the number of nodes and levels in the trie <ref> [5, 4, 6, 12, 19, 22] </ref>. The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation [3, 17, 20].
Reference: [7] <author> J. Bentley and R. Sedgewick. </author> <title> Fast algorithms for sorting and searching strings. </title> <booktitle> In Proceedings of SODA'97, </booktitle> <year> 1997. </year> <title> 7 IP addresses (currently) are 32-bits long and arbitrary-length prefixes can appear in network routing tables. </title> <type> 9 </type>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing <ref> [6, 7, 8, 14, 22] </ref>, itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries [13, 24]. <p> For the dictionary dataset, our algorithm was 1.7 times faster on the SGI Origin-2000 and 4 times faster on both the Sun Ultras compared to the ternary search tree algorithm proposed by Bentley and Sedgewick <ref> [7] </ref>. For the datamining dataset, our algorithm was 1.4-1.9 times faster than a B-tree-trie and 1.2-1.5 times faster than a hashtable-trie. A comparison of the number of instructions executed indicates that the algorithms presented in this paper derive their performance advantage primarily by making better use of the memory hierarchy. <p> For this dataset, we used the algorithm for small alphabets and compared its performance to that of the ternary search tree proposed by Bentley and Sedgewick <ref> [7] </ref>. 5 Bentley et al demonstrate that ternary search trees are somewhat faster than hashing for an English dictionary and up to five times faster than hashing for the DIMACS library call number datasets [7]. <p> and compared its performance to that of the ternary search tree proposed by Bentley and Sedgewick <ref> [7] </ref>. 5 Bentley et al demonstrate that ternary search trees are somewhat faster than hashing for an English dictionary and up to five times faster than hashing for the DIMACS library call number datasets [7]. <p> The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed <ref> [7, 9] </ref>. Finally, there has been much recent interest in optimizing the tries used for address lookups in network routers [11, 21, 26]. <p> For the dictionary dataset, our algorithm was 1.7 times faster on the SGI Origin-2000 and 4 times faster on both the Sun Ultras compared to the ternary search tree algorithm proposed by Bentley and Sedgewick <ref> [7] </ref>. For the datamining dataset, our algorithm was 1.4-1.9 times faster than a B-tree-trie and 1.2-1.5 times faster than a hashtable-trie. A comparison of the number of instructions executed indicates that the algorithms presented in this paper derive their performance advantage primarily by making better use of the memory hierarchy.
Reference: [8] <author> A. Blumer, J. Blumer, D. Haussler, and R. McConnel. </author> <title> Complete inverted files for efficient text retrieval and analysis. </title> <journal> Journal of the ACM, </journal> <volume> 34(3) </volume> <pages> 578-95, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing <ref> [6, 7, 8, 14, 22] </ref>, itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries [13, 24].
Reference: [9] <author> H. Clampett. </author> <title> Randomized binary searching with tree structures. </title> <journal> Communications of the ACM, </journal> <volume> 7(3) </volume> <pages> 163-5, </pages> <year> 1964. </year>
Reference-contexts: The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed <ref> [7, 9] </ref>. Finally, there has been much recent interest in optimizing the tries used for address lookups in network routers [11, 21, 26].
Reference: [10] <author> J. Clement, P. Flajolet, and B. Vallee. </author> <title> The analysis of hybrid trie structures. </title> <type> Technical Report 3295, </type> <institution> INRIA, </institution> <month> Nov </month> <year> 1997. </year>
Reference-contexts: Clement et al <ref> [10] </ref> 3 An online version is available at ftp://uiarchive.cso.uiuc.edu/pub/etext/gutenberg/etext96/. 4 An online version is available at ftp://uiarchive.cso.uiuc.edu/pub/etext/gutenberg/etext91/moby.zip. 5 We obtained the code for the ternary search tree algorithm from http://www.cs.princeton.edu/~rs/strings.. 4 analyze the ternary search tree algorithm as a form of trie and conclude that it is an efficient data structure
Reference: [11] <author> M. Degermark, A. Brodnik, S. Carlsson, and S. Pink. </author> <title> Small forwarding tables for fast routing lookups. </title> <journal> Computer Communication Review, </journal> <month> October </month> <year> 1997. </year>
Reference-contexts: The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed [7, 9]. Finally, there has been much recent interest in optimizing the tries used for address lookups in network routers <ref> [11, 21, 26] </ref>. The algorithms proposed by these researchers 8 focus on reducing the number of memory accesses by reducing the number of levels in the trie and the fanout at individual nodes.
Reference: [12] <author> J. Dundas. </author> <title> Implementing dynamic minimal-prefix tries. </title> <journal> Software Practice and Experience, </journal> <volume> 21(10) </volume> <pages> 1027-40, </pages> <year> 1991. </year>
Reference-contexts: The first approach focuses on reducing the number of instructions executed by reducing the number of nodes and levels in the trie <ref> [5, 4, 6, 12, 19, 22] </ref>. The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation [3, 17, 20].
Reference: [13] <author> P. Flajolet and C. Puech. </author> <title> Partial match retrieval of multidimensional data. </title> <journal> Journal of the ACM, </journal> <volume> 33(2) </volume> <pages> 371-407, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing [6, 7, 8, 14, 22], itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries <ref> [13, 24] </ref>. There has been much work on reducing the storage requirement and the instruction count for tries for example [3, 5, 4, 6, 19, 20, 22]. These algorithms, however, do not take the memory hierarchy into account.
Reference: [14] <author> G. Gonnet and R. Baeza-Yates. </author> <title> Handbook of Algorithms and Data Structures: </title> <editor> in Pascal and C. </editor> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing <ref> [6, 7, 8, 14, 22] </ref>, itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries [13, 24].
Reference: [15] <author> E. Han, V. Karypis, and V. Kumar. </author> <title> Scalable parallel data mining for association rules. </title> <booktitle> In Proceedings of SIGMOD'97, </booktitle> <year> 1997. </year>
Reference-contexts: Tries are used in this application to store the candidate itemsets and to help determine the frequent itemsets. The dataset used in our experiments was generated using the Quest datamining dataset generator which we obtained from IBM Almaden [23]. This dataset generator has been widely used in datamining research <ref> [1, 2, 15, 28, 29] </ref>. The alphabet for this dataset contained 10,000 symbols (corresponding to 10,000 items). Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration. <p> We selected this algorithm for our experiments as an algorithm similar to this is proposed by several researchers for maintaining frequent itemsets for mining association rules <ref> [1, 2, 15] </ref>. 4 Results for the dictionary dataset. The adaptive algorithm significantly outperforms the ternary search tree on all three machines by a factor of 1.7 on the Origin-2000 and by a factor of 4 on the Ultra-2 and the Ultra-30. the hashtable-trie algorithms for the datamining dataset.
Reference: [16] <author> J. Hennessy and D. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufman, </publisher> <address> second edition, </address> <year> 1996. </year>
Reference: [17] <author> D. Knuth. </author> <title> The Art of Computer Programming, volume 3: Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation <ref> [3, 17, 20] </ref>. The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed [7, 9].
Reference: [18] <author> A. Lamarca and R. Ladner. </author> <title> The influence of caches on the performance of sorting. </title> <booktitle> In Proceedings of SODA'97, </booktitle> <year> 1997. </year>
Reference-contexts: Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration. A similar conclusion is reached by Lamarca&Ladner in their paper on cache-efficient algorithms for sorting <ref> [18] </ref>. For the dictionary dataset, our algorithm was 1.7 times faster on the SGI Origin-2000 and 4 times faster on both the Sun Ultras compared to the ternary search tree algorithm proposed by Bentley and Sedgewick [7].
Reference: [19] <author> C. Lucchesi and T. Knowaltowski. </author> <title> Applications of finite automata representing large vocabularies. </title> <journal> Software Practice and Experience, </journal> <volume> 23(1) </volume> <pages> 15-30, </pages> <year> 1993. </year>
Reference-contexts: There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The first approach focuses on reducing the number of instructions executed by reducing the number of nodes and levels in the trie <ref> [5, 4, 6, 12, 19, 22] </ref>. The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation [3, 17, 20].
Reference: [20] <author> K. Maly. </author> <title> Compressed tries. </title> <journal> Communications of the ACM, </journal> <volume> 19 </volume> <pages> 409-15, </pages> <year> 1976. </year>
Reference-contexts: There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation <ref> [3, 17, 20] </ref>. The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed [7, 9].
Reference: [21] <author> S. Nilsson and G. Karlsson. </author> <title> Fast address lookup for internet routers. </title> <booktitle> In Proceedings of IEEE Broadband Communications'98, </booktitle> <year> 1998. </year>
Reference-contexts: The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed [7, 9]. Finally, there has been much recent interest in optimizing the tries used for address lookups in network routers <ref> [11, 21, 26] </ref>. The algorithms proposed by these researchers 8 focus on reducing the number of memory accesses by reducing the number of levels in the trie and the fanout at individual nodes.
Reference: [22] <author> J. Peterson. </author> <title> Computer Programs for Spelling Correction. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing <ref> [6, 7, 8, 14, 22] </ref>, itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries [13, 24]. <p> There has been much work on reducing the storage requirement and the instruction count for tries for example <ref> [3, 5, 4, 6, 19, 20, 22] </ref>. These algorithms, however, do not take the memory hierarchy into account. Given the depth of memory hierarchies on modern machines, good cache performance is critical to the performance of an algorithm. In this paper, we present cache-efficient algorithms for trie search. <p> The first approach focuses on reducing the number of instructions executed by reducing the number of nodes and levels in the trie <ref> [5, 4, 6, 12, 19, 22] </ref>. The second approach views tries as collections of m-way vectors and focuses on reducing the space used by these vectors using a list-based representation or a sparse-matrix representation [3, 17, 20].
Reference: [23] <institution> IBM Quest Data Mining Project. </institution> <note> The Quest retail transaction data generator 8 , 1996. </note>
Reference-contexts: Tries are used in this application to store the candidate itemsets and to help determine the frequent itemsets. The dataset used in our experiments was generated using the Quest datamining dataset generator which we obtained from IBM Almaden <ref> [23] </ref>. This dataset generator has been widely used in datamining research [1, 2, 15, 28, 29]. The alphabet for this dataset contained 10,000 symbols (corresponding to 10,000 items). Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration. <p> The second dataset was from the datamining domain and consisted of sets of retail transactions generated by Quest datamining dataset generator which we obtained from IBM Almaden <ref> [23] </ref>. For this application, the alphabet consists of the items that can be purchased in a grocery store and a string consists of a single retail transaction. Recall that the task is to determine the set of items that are frequently purchased together.
Reference: [24] <author> R. Rivest. </author> <title> Partial match retrieval algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> 5 </volume> <pages> 19-50, </pages> <year> 1976. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing [6, 7, 8, 14, 22], itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers [26, 27] and partial match queries <ref> [13, 24] </ref>. There has been much work on reducing the storage requirement and the instruction count for tries for example [3, 5, 4, 6, 19, 20, 22]. These algorithms, however, do not take the memory hierarchy into account.
Reference: [25] <author> S. Sharma and A. Acharya. </author> <title> The msim memory hierarchy simulator. </title> <type> Personal Communication, </type> <year> 1997. </year>
Reference-contexts: To evaluate the impact of variation in cache characteristics on the performance of these algorithms, we simulated architectures that differed in cache line size (32/64-byte) and cache associativity (direct-mapped/2-way/4-way/8-way). We used the msim simulator <ref> [25] </ref> and assumed a 32KB L1 cache and a 2MB L2 cache. We assumed zero delay fetching data from L1 cache, a 5 cycle delay from L2 cache and a 36 cycle delay from main memory.
Reference: [26] <author> S. Venkatachary and G. Varghese. </author> <title> Faster IP Lookups Using Controlled Prefix Expansion. </title> <booktitle> In Proceedings of SIGMETRICS'98, </booktitle> <pages> pages 1-10, </pages> <year> 1998. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing [6, 7, 8, 14, 22], itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers <ref> [26, 27] </ref> and partial match queries [13, 24]. There has been much work on reducing the storage requirement and the instruction count for tries for example [3, 5, 4, 6, 19, 20, 22]. These algorithms, however, do not take the memory hierarchy into account. <p> The third approach focuses on the data structures used to represent trie nodes with the goal of reducing both the space required and the number of instructions executed [7, 9]. Finally, there has been much recent interest in optimizing the tries used for address lookups in network routers <ref> [11, 21, 26] </ref>. The algorithms proposed by these researchers 8 focus on reducing the number of memory accesses by reducing the number of levels in the trie and the fanout at individual nodes.
Reference: [27] <author> M. Waldvogel, G. Varghese, J. Turner, and B. Plattner. </author> <title> Scalable high speed IP routing lookups. </title> <booktitle> In Proceedings of SIGCOMM'97, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Tries are widely used for storing and matching strings over a given alphabet. Applications include dictionary lookup for text processing [6, 7, 8, 14, 22], itemset lookup for mining association rules in retail transactions [1, 2], IP address lookup in network routers <ref> [26, 27] </ref> and partial match queries [13, 24]. There has been much work on reducing the storage requirement and the instruction count for tries for example [3, 5, 4, 6, 19, 20, 22]. These algorithms, however, do not take the memory hierarchy into account.
Reference: [28] <author> M. Zaki, M. Ogihara, S. Parthasarthy, and W. Li. </author> <title> Parallel data mining for association rules on shared-memory multi-processors. </title> <booktitle> In Proceedings of Supercomputing'96, </booktitle> <year> 1996. </year>
Reference-contexts: Tries are used in this application to store the candidate itemsets and to help determine the frequent itemsets. The dataset used in our experiments was generated using the Quest datamining dataset generator which we obtained from IBM Almaden [23]. This dataset generator has been widely used in datamining research <ref> [1, 2, 15, 28, 29] </ref>. The alphabet for this dataset contained 10,000 symbols (corresponding to 10,000 items). Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration.
Reference: [29] <author> M. Zaki, S. Parthasarathy, and W. Li. </author> <title> A localized algorithm for parallel association mining. </title> <booktitle> In Proceedings of the 9th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <year> 1997. </year> <title> 8 Available at http://www.almaden.ibm.com/cs/quest/syndata.html. 10 For example, the shaded box next to n at the second level indicates that the string "an" ends at that node. </title>
Reference-contexts: Tries are used in this application to store the candidate itemsets and to help determine the frequent itemsets. The dataset used in our experiments was generated using the Quest datamining dataset generator which we obtained from IBM Almaden [23]. This dataset generator has been widely used in datamining research <ref> [1, 2, 15, 28, 29] </ref>. The alphabet for this dataset contained 10,000 symbols (corresponding to 10,000 items). Our evaluation indicates that these algorithms out-perform alternatives that are otherwise efficient but do not take cache characteristics into consideration.
References-found: 29

