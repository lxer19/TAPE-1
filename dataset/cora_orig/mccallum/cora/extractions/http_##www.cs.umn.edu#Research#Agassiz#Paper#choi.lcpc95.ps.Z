URL: http://www.cs.umn.edu/Research/Agassiz/Paper/choi.lcpc95.ps.Z
Refering-URL: http://www.cs.umn.edu/Research/Agassiz/agassiz_pubs.html
Root-URL: http://www.cs.umn.edu
Phone: 2  
Title: Interprocedural Array Data-Flow Analysis for Cache Coherence  
Author: Lynn Choi and Pen-Chung Yew 
Address: Urbana, IL 61801-1351, USA  MN 55455-0519, USA  
Affiliation: 1 Center for Supercomputing Research and Development, University of Illinois,  Department of Computer Science, University of Minnesota, Minneapolis,  
Abstract: The presence of procedures and procedure calls introduces side effects, which complicate the analysis of stale reference detection in compiler-directed cache coherence schemes [4, 3, 10]. Previous compiler algorithms use the invalidation of an entire cache at procedure boundary [5, 8] or inlining [8] to avoid reference marking interprocedurally. However, frequent cache invalidations will result in poor performance since locality can not be exploited across the procedure boundary. Also, the in-lining is often prohibitive due to both its code expansion and increase in its compilation time and memory requirements. In this paper, we introduce an improved intraprocedural and interprocedural algorithms for detecting references to stale data. The intraprocedural algorithm can mark potential stale references without relying on any cache invalidation or in-lining at procedure boundaries, thus avoiding unnecessary cache misses for subroutine local data. The interprocedural algorithm performs bottom-up and top-down analysis on the procedure call graph to further exploit locality across procedure boundaries. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Ballance, A. Maccabe, and K. Ottenstein. </author> <title> The Program Dependence Web: a Representation Supporting Control Data- and Demand-Driven Interpretation of Imperative Languages. </title> <booktitle> Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 257-271, </pages> <month> June </month> <year> 1990. </year>
Reference: 2. <author> D. Callahan and K. Kennedy. </author> <title> Analysis of Interprocedural Side Effects in a Parallel Programming Environment. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5 </volume> <pages> 517-550, </pages> <year> 1988. </year>
Reference-contexts: The notion of subarray we use is an extension to the regular section used in <ref> [2, 12] </ref>. A subarray consists of a subscripted variable and one or more ranges for each index in the subscript expression. A range includes expressions for the lower bound, upper bound and stride. The offset field keeps track of the number of epoch boundaries crossed for each definition propagated. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes <ref> [2, 4, 3, 10, 13, 14] </ref> to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 3. <author> Hoichi Cheong. </author> <title> Life Span Strategy A Compiler-Based Approach to Cache Coherence. </title> <booktitle> Proceedings of the 1992 International Conference on Supercomputing, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Procedure calls introduce complications in most global compiler analysis and complicate optimizations due to its side effects and potential aliasing caused by parameter passing. Stale access detection [5, 10] is a compile time analysis to identify potential references to stale data in compiler-directed coherence schemes <ref> [4, 3, 10] </ref>. By identifying these potential stale references at compile time, cache coherence can be maintained by forcing those references to get up-to-date data directly from the main memory, instead of from the cache. <p> The second top-down context analysis allows the context information of a procedure to be visible by passing the summary access information of its previous activation records. The compiler marking algorithms developed here are general enough to be applicable to other compiler-directed coherence schemes <ref> [3, 4] </ref>. We also propose a new condition for a stale access which identifies the memory reference sequences leading to stale accesses at compile time. <p> We call this sequence of events a stale reference sequence. 1.3 Coherence mechanism and hardware support In our cache coherence scheme, each epoch is assigned a unique epoch number which is similar to the version number in previous schemes <ref> [3, 6, 7, 14] </ref>. The epoch number is stored in an n-bit register in each processor, called epoch counter (R counter ), and is incremented at the end of every epoch by each processor individually. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes <ref> [2, 4, 3, 10, 13, 14] </ref> to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 4. <author> Hoichi Cheong and Alex Veidenbaum. </author> <title> A Cache Coherence Scheme with Fast Selective Invalidation. </title> <booktitle> Proceedings of The 15th Annual International Symposium on Computer Architecture, </booktitle> <pages> page 299, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Procedure calls introduce complications in most global compiler analysis and complicate optimizations due to its side effects and potential aliasing caused by parameter passing. Stale access detection [5, 10] is a compile time analysis to identify potential references to stale data in compiler-directed coherence schemes <ref> [4, 3, 10] </ref>. By identifying these potential stale references at compile time, cache coherence can be maintained by forcing those references to get up-to-date data directly from the main memory, instead of from the cache. <p> The second top-down context analysis allows the context information of a procedure to be visible by passing the summary access information of its previous activation records. The compiler marking algorithms developed here are general enough to be applicable to other compiler-directed coherence schemes <ref> [3, 4] </ref>. We also propose a new condition for a stale access which identifies the memory reference sequences leading to stale accesses at compile time. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes <ref> [2, 4, 3, 10, 13, 14] </ref> to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 5. <author> Hoichi Cheong and Alexander V. Veidenbaum. </author> <title> Stale Data Detection and Coherence Enforcement Using Flow Analysis. </title> <booktitle> Proceedings of the 1988 International Conference on Parallel Processing, I, </booktitle> <address> Architecture:138-145, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Procedure calls introduce complications in most global compiler analysis and complicate optimizations due to its side effects and potential aliasing caused by parameter passing. Stale access detection <ref> [5, 10] </ref> is a compile time analysis to identify potential references to stale data in compiler-directed coherence schemes [4, 3, 10]. <p> By identifying these potential stale references at compile time, cache coherence can be maintained by forcing those references to get up-to-date data directly from the main memory, instead of from the cache. In stale reference detection, procedure boundaries force all previous algorithms <ref> [5, 8] </ref> to use conservative approaches such as cache invalidation or inlining to avoid reference marking across procedure calls. In this paper, we develop both intraprocedural and interprocedural compiler algorithms, both of which can perform stale reference detection without relying on either invalidation or inlining. <p> In addition, this also causes another problem at the beginning of procedure since any global COMMON variables and formal parameters could have been previously modified before entering the procedure. To avoid the complications caused by procedure calls, previous algorithms <ref> [5, 8] </ref> use cache invalidation both at the beginning of a procedure and after each call site. Since the algorithms assume a clean cache at procedure boundaries, their analysis can guarantee the correctness of reference marking. <p> For a target reference which does not have a reaching definition inside a procedure, we issue a Time-Read with the minimum offset, implying the data item referenced can be potentially modified before entering the procedure. This is an improvement over previous algorithms <ref> [5, 8] </ref> which use cache invalidation at the procedure beginning since only global and formal variables are affected by the unknown context information. We propagate definitions through the flow graph and increment their offsets when they cross the scheduling edges. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes [2, 4, 3, 10, 13, 14] to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation <ref> [5, 8] </ref> or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 6. <author> Hoichi Cheong and Alexander V. Veidenbaum. </author> <title> A Version Control Approach To Cache Coherence. </title> <booktitle> Proceedings of 1989 ACM/SIGARCH International Conference on Supercomputing, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: We call this sequence of events a stale reference sequence. 1.3 Coherence mechanism and hardware support In our cache coherence scheme, each epoch is assigned a unique epoch number which is similar to the version number in previous schemes <ref> [3, 6, 7, 14] </ref>. The epoch number is stored in an n-bit register in each processor, called epoch counter (R counter ), and is incremented at the end of every epoch by each processor individually.
Reference: 7. <author> T. Chiueh. </author> <title> A Generational Approach to Software-Controlled Multiprocessor Cache Coherence. </title> <booktitle> Proceedings 1993 International Conference on Parallel Processing, </booktitle> <year> 1993. </year>
Reference-contexts: We call this sequence of events a stale reference sequence. 1.3 Coherence mechanism and hardware support In our cache coherence scheme, each epoch is assigned a unique epoch number which is similar to the version number in previous schemes <ref> [3, 6, 7, 14] </ref>. The epoch number is stored in an n-bit register in each processor, called epoch counter (R counter ), and is incremented at the end of every epoch by each processor individually.
Reference: 8. <author> Lynn Choi and Pen-Chung Yew. </author> <title> Eliminating Stale Data References through Array Data-Flow Analysis. </title> <type> CSRD Technical Report No. 1425, </type> <month> April. </month> <year> 1995. </year>
Reference-contexts: By identifying these potential stale references at compile time, cache coherence can be maintained by forcing those references to get up-to-date data directly from the main memory, instead of from the cache. In stale reference detection, procedure boundaries force all previous algorithms <ref> [5, 8] </ref> to use conservative approaches such as cache invalidation or inlining to avoid reference marking across procedure calls. In this paper, we develop both intraprocedural and interprocedural compiler algorithms, both of which can perform stale reference detection without relying on either invalidation or inlining. <p> In addition, this also causes another problem at the beginning of procedure since any global COMMON variables and formal parameters could have been previously modified before entering the procedure. To avoid the complications caused by procedure calls, previous algorithms <ref> [5, 8] </ref> use cache invalidation both at the beginning of a procedure and after each call site. Since the algorithms assume a clean cache at procedure boundaries, their analysis can guarantee the correctness of reference marking. <p> However, note that such invalidations cause unnecessary cache misses for global COMMON variables and parameters as well as for subroutine local variables. Frequent invalidations at procedure boundaries will degrade cache performance significantly because it limits the scope of locality within procedural boundaries. From our execution-driven simulations on Perfect benchmarks <ref> [8] </ref>, the performance degradation could be significant especially if a program contains many small procedures. In the following, we first describe our program representation methods: epoch flow graph [10], array descriptors, and GSA in section 2. <p> In such a case, both array references should be marked as having upwardly-exposed uses. For those partially upwardly-exposed references, we keep only the region of the array that is actually upwardly-exposed and use the subarray information for later analysis. We use the algorithm proposed in <ref> [8] </ref> to mark the target references. 2.3 Stale reference detection The intraprocedural algorithm for stale reference detection is an improved version of the previous algorithm we developed in [8]. We refine the algorithm both to accommodate multi-word cache blocks as well as to eliminate cache invalidation at procedure boundaries. <p> We use the algorithm proposed in <ref> [8] </ref> to mark the target references. 2.3 Stale reference detection The intraprocedural algorithm for stale reference detection is an improved version of the previous algorithm we developed in [8]. We refine the algorithm both to accommodate multi-word cache blocks as well as to eliminate cache invalidation at procedure boundaries. Each definition of a variable v, denoted as d v offset , is associated with an offset. <p> For a target reference which does not have a reaching definition inside a procedure, we issue a Time-Read with the minimum offset, implying the data item referenced can be potentially modified before entering the procedure. This is an improvement over previous algorithms <ref> [5, 8] </ref> which use cache invalidation at the procedure beginning since only global and formal variables are affected by the unknown context information. We propagate definitions through the flow graph and increment their offsets when they cross the scheduling edges. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes [2, 4, 3, 10, 13, 14] to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation <ref> [5, 8] </ref> or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes [2, 4, 3, 10, 13, 14] to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining <ref> [8] </ref> to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path. Inlining allows the most precise analysis but often prohibitive due to its potential code size expansion as well as the compile time increase.
Reference: 9. <author> Lynn Choi and Pen-Chung Yew. </author> <title> Interprocedural Array Data-Flow Analysis for Cache Coherence. </title> <type> CSRD Technical Report No. 1427, </type> <month> May. </month> <year> 1995. </year>
Reference-contexts: Note that for procedure CALL statements, we purposely insert all the actual parameters and global variables in its OUT set, implying that those variables can be modified at the call site. Without having any information for the procedure called, we have 4 The more detail algorithm is presented in <ref> [9] </ref>. to assume that an entire array can be modified by the procedure. Note that this lack of information also affects the analysis of the subroutine local variables since the offset can be unnecessarily too small if the procedure call has at least one parallel epoch inside. <p> Summary context information (IN set of caller at the beginning of procedure) Number of minimum epoch boundaries in a procedure 3.1 Side effect analysis passes on the procedure call graph: the bottom-up side effect analysis pass and the top-down context analysis pass. 5 5 A complete algorithm is presented in <ref> [9] </ref>. Fig. 4. An example of procedure call graph and the overall structure of the two-pass interprocedural analysis. The side effect analysis combines intraprocedural analysis with a bottom-up scan of the procedure call graph to eliminate the side effects caused by each call site.
Reference: 10. <author> Lynn Choi and Pen-Chung Yew. </author> <title> A Compiler-Directed Cache Coherence Scheme with Improved Intertask Locality. </title> <booktitle> Proceedings of the Supercomputing'94, </booktitle> <month> Novem-ber </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Procedure calls introduce complications in most global compiler analysis and complicate optimizations due to its side effects and potential aliasing caused by parameter passing. Stale access detection <ref> [5, 10] </ref> is a compile time analysis to identify potential references to stale data in compiler-directed coherence schemes [4, 3, 10]. <p> 1 Introduction Procedure calls introduce complications in most global compiler analysis and complicate optimizations due to its side effects and potential aliasing caused by parameter passing. Stale access detection [5, 10] is a compile time analysis to identify potential references to stale data in compiler-directed coherence schemes <ref> [4, 3, 10] </ref>. By identifying these potential stale references at compile time, cache coherence can be maintained by forcing those references to get up-to-date data directly from the main memory, instead of from the cache. <p> From our execution-driven simulations on Perfect benchmarks [8], the performance degradation could be significant especially if a program contains many small procedures. In the following, we first describe our program representation methods: epoch flow graph <ref> [10] </ref>, array descriptors, and GSA in section 2. Then, we present an intraprocedural stale reference marking algorithm which can detect stale data references without cache invalidation or inlining in the presence of procedure calls. <p> Figure 2 shows the example program and its GSA form which will be used throughout the discussion in this section. Because the epoch boundary information is essential in identifying potential stale references, we include parallel constructs in our control flow graph, called the epoch flow graph <ref> [10] </ref>. Epoch flow graph Let the directed graph G = (V, E) represent a control flow graph where V is a set of statements, and E is a set of directed edges, representing the control flow between nodes in V. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes <ref> [2, 4, 3, 10, 13, 14] </ref> to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 11. <author> Mary W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> Technical report, </type> <institution> Rice University, Dept. of Computer Science, </institution> <month> April </month> <year> 1991. </year> <type> Ph.D. Thesis. </type>
Reference: 12. <author> Paul Havlak. </author> <title> Interprocedural Symbolic Analysis. </title> <type> Technical report, </type> <institution> Rice University, Dept. of Computer Science, </institution> <month> May </month> <year> 1994. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: The notion of subarray we use is an extension to the regular section used in <ref> [2, 12] </ref>. A subarray consists of a subscripted variable and one or more ranges for each index in the subscript expression. A range includes expressions for the lower bound, upper bound and stride. The offset field keeps track of the number of epoch boundaries crossed for each definition propagated.
Reference: 13. <author> A. Louri and H. Sung. </author> <title> A Compiler Directed Cache Coherence Scheme with Fast and Parallel Explicit Invalidation. </title> <booktitle> Proceedings of the 1992 International Conference on Parallel Processing, I, </booktitle> <address> Architecture:I-2-I-9, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes <ref> [2, 4, 3, 10, 13, 14] </ref> to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 14. <author> S. L. Min and J.-L. Baer. </author> <title> A Timestamp-based Cache Coherence Scheme. </title> <booktitle> 1989 International Conference on Parallel Processing, </booktitle> <address> I:23-32, </address> <year> 1989. </year>
Reference-contexts: We call this sequence of events a stale reference sequence. 1.3 Coherence mechanism and hardware support In our cache coherence scheme, each epoch is assigned a unique epoch number which is similar to the version number in previous schemes <ref> [3, 6, 7, 14] </ref>. The epoch number is stored in an n-bit register in each processor, called epoch counter (R counter ), and is incremented at the end of every epoch by each processor individually. <p> Procedure calls can introduce side effects at a call site and hidden context at the beginning of a procedure, which can limit compiler-directed coherence schemes <ref> [2, 4, 3, 10, 13, 14] </ref> to exploit locality only within procedure boundaries. Previous algorithms use cache invalidation [5, 8] or selective inlining [8] to solve the problem. However, invalidation at procedure boundaries incur significant performance penalty especially if a program contains many small procedures in its critical path.
Reference: 15. <author> D. A. Padua, R. Eigenmann, J. Hoeflinger, P. Peterson, P. Tu, S. Weatherford, and K. Faign. </author> <title> Polaris: A New-Generation Parallelizing Compiler for MPPs. In CSRD Rept. No. </title> <type> 1306. </type> <institution> Univ. of Illinois at Urbana-Champaign., </institution> <month> June, </month> <year> 1993. </year>
Reference-contexts: In addition, the top-down pass updates the reference marking result of the side effect analysis incrementally, minimizing the compilation time. We are currently implementing these algorithms on the Polaris parallelizing compiler <ref> [15] </ref>.
Reference: 16. <author> P. Tu and D. Padua. </author> <title> Gated SSA Based Demand-Driven Symbolic Analysis. </title> <type> CSRD Technical Report No. 1336, </type> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Similarly, by representing the subarray fields in the GSA form, we can perform subarray operations involving symbolic loop bounds. In addition, GSA allows a backward demand-driven symbolic analysis to compute values and conditions across the confluence points <ref> [16] </ref>. Figure 2 shows the example program and its GSA form which will be used throughout the discussion in this section. Because the epoch boundary information is essential in identifying potential stale references, we include parallel constructs in our control flow graph, called the epoch flow graph [10].
Reference: 17. <author> A. V. Veidenbaum. </author> <title> A Compiler-Assisted Cache Coherence Solution for Multiprocessors. </title> <booktitle> Proceedings of the 1986 International Conference on Parallel Processing, </booktitle> <pages> pages 1029-1035, </pages> <month> August </month> <year> 1986. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Barrier synchronizations are used at the end of parallel epochs. 1.2 Memory reference patterns for stale references Let's first define the ordering of events which leads to a stale reference. The following sequence of events creates a stale access <ref> [17] </ref>: (1) a read/write to a memory location x by the processor i; (2) a write to x by another processor j (6= i); (3) a read of x by the processor i.
References-found: 17

