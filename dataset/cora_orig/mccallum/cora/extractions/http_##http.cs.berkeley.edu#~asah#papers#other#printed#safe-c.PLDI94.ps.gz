URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/safe-c.PLDI94.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Email: faustin, breach, sohig@cs.wisc.edu  
Title: Efficient Detection of All Pointer and Array Access Errors  
Author: Todd M. Austin Scott E. Breach Gurindar S. Sohi 
Address: 1210 W. Dayton Street Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: We present a pointer and array access checking technique that provides complete error coverage through a simple set of program transformations. Our technique, based on an extended safe pointer representation, has a number of novel aspects. Foremost, it is the first technique that detects all spatial and temporal access errors. Its use is not limited by the expressiveness of the language; that is, it can be applied successfully to compiled or interpreted languages with subscripted and mutable pointers, local references, and explicit and typeless dynamic storage management, e.g., C. Because it is a source level transformation, it is amenable to both compile- and run-time optimization. Finally, its performance, even without compile-time optimization, is quite good. We implemented a prototype translator for the C language and analyzed the checking overheads of six non-trivial, pointer intensive programs. Execution overheads range from 130% to 540%; with text and data size overheads typically below 100%. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: This operation can be simply and portably implemented if the local capability space and heap capability space are kept disjoint, and function frame capabilities are allocated using an incrementing counter. The allocation of frame capabilities then becomes a depth-first numbering <ref> [ASU86] </ref> of the dynamic call graph. When a nonlocal jump occurs, all elided frame capabilities between the source frame and destination frame are deleted by removing all frame capabilities in the capability store that are larger than the frame capability of the destination frame. <p> In our implementation, we keep separate counters for heap and stack deallocations. 5.2 Compile-Time Check Optimization We have also designed (and are currently implementing) a compile-time optimization framework like that proposed by Gupta [Gup90]. Our algorithm implements a forward data-flow framework similar to that used by common subexpres-sion elimination <ref> [ASU86] </ref>. However, our algorithm extends previous work to include eliding of temporal error checks, and because of our simplified bounds check, there is no need to split the optimization into upper and lower bounds check elimination. Our optimization algorithm is shown in Figure 8.
Reference: [Boe93] <author> Hans-Juergen Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <volume> 28(6) </volume> <pages> 197-204, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Purify supports both spatial and temporal access error checking to heap storage only through the use of a memory state map which is consulted at each load and store the program executes. Purify also provides uninitialized read detection, and storage leak detection through a conservative collector <ref> [Boe93, BW88] </ref>. Spatial access errors are detected by bracketing both ends of any heap allocation with a "red zone". These zones are marked in the memory state map as inaccessible. When a load or store touches a red zone a memory access error is flagged. <p> A closely related area of work, which can benefit from our safe programming technique, is storage leak detection <ref> [Boe93, BW88, ZH88] </ref>. A storage leak is any storage to which the program can no longer generate a name. These leaks occur when the last accessible pointer to a heap object is overwritten.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Purify supports both spatial and temporal access error checking to heap storage only through the use of a memory state map which is consulted at each load and store the program executes. Purify also provides uninitialized read detection, and storage leak detection through a conservative collector <ref> [Boe93, BW88] </ref>. Spatial access errors are detected by bracketing both ends of any heap allocation with a "red zone". These zones are marked in the memory state map as inaccessible. When a load or store touches a red zone a memory access error is flagged. <p> A closely related area of work, which can benefit from our safe programming technique, is storage leak detection <ref> [Boe93, BW88, ZH88] </ref>. A storage leak is any storage to which the program can no longer generate a name. These leaks occur when the last accessible pointer to a heap object is overwritten.
Reference: [ED93] <author> John R. Ellis and David L. Detlefs. </author> <title> Safe, efficient garbage collection for C++. </title> <type> Technical Report 102, </type> <institution> DEC Systems Research Center, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Some researchers have recently proposed providing complete program safety through limiting the constructs allowed in the language. The main thrust of this work is the design of languages that support garbage collection reliably and portably. In <ref> [ED93] </ref>, a safe subset of C++ is defined. The safe subset does not permit any invalid pointers to be created; this restriction, for example, precludes the use of any explicit pointer arithmetic. The safe subset also requires some checking, but much less than our checking technique requires.
Reference: [EP91] <author> D. R. Edelson and I. Pohl. </author> <title> Smart pointers: They're smart but they're not pointers. </title> <booktitle> Proceedings of the 1991 Usenix C++ Conference, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: Run-time optimized executions have slightly larger text and data sizes. 7 Related Work Our first attempt at creating a safe programming environment for C employed reference chaining. The technique is similar to that used by many "smart pointer" implementations <ref> [EP91, Gin92] </ref>. The idea is to insert any pointer which is generated either through use of explicit storage allocation, e.g., malloc (), the reference operator (`&'), or assignment into a reference chain rooted at the referent.
Reference: [FH88] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: Spatial checks have no side effects, thus we can employ memoization <ref> [FH88] </ref> (or function caching) to elide their evaluation. We store the operands to the last check in the safe pointer object attributes, which amounts to the effective address of the last dereference.
Reference: [FL80] <author> Charles N. Fischer and Richard J. LeBlanc. </author> <title> The implementation of run-time diagnostics in Pascal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(4):313-319, </volume> <year> 1980. </year>
Reference-contexts: Bcc C source-to-source yes* no alignment checks, [Ken83] translation overflow checks UW-Pascal Pascal safe yes* yes errant free's, <ref> [FL80] </ref> compiler arithmetic faults, etc. Table 2: Comparison of memory access checking work. Entries with an asterisk (*) indicate that the method detects all errors for that particular error class. accesses it can only verify that the accessed storage is active. <p> The published information on Bcc does not specify how the checking is implemented, however, one figure in the paper, showing the output of the translator, suggests that base and bound object attributes are attached to all pointer values. Fischer and LeBlanc's UW-Pascal compiler <ref> [FL80] </ref> supports both temporal and spatial error checking. However, the lack of mutable pointers and dynamically sized arrays makes access checking much easier. While UW-Pascal detects all spatial access errors, temporal access errors may not be detected if storage is reallocated.
Reference: [Gin92] <author> Andrew Ginter. </author> <title> Design alternatives for a cooperative garbage collector for the C++ programming language. </title> <type> Technical Report 91/417/01, </type> <institution> Department of Computer Science, University of Calgary, </institution> <year> 1992. </year>
Reference-contexts: Run-time optimized executions have slightly larger text and data sizes. 7 Related Work Our first attempt at creating a safe programming environment for C employed reference chaining. The technique is similar to that used by many "smart pointer" implementations <ref> [EP91, Gin92] </ref>. The idea is to insert any pointer which is generated either through use of explicit storage allocation, e.g., malloc (), the reference operator (`&'), or assignment into a reference chain rooted at the referent.
Reference: [Gup90] <author> Rajiv Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 272-282, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In our implementation, we keep separate counters for heap and stack deallocations. 5.2 Compile-Time Check Optimization We have also designed (and are currently implementing) a compile-time optimization framework like that proposed by Gupta <ref> [Gup90] </ref>. Our algorithm implements a forward data-flow framework similar to that used by common subexpres-sion elimination [ASU86].
Reference: [HJ92] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> fast detection of memory leaks and access errors. </title> <booktitle> Proceedings of the Winter Usenix Conference, </booktitle> <year> 1992. </year>
Reference-contexts: The performance is quite good. Instruction execution overheads range from 130% to 540%, and text and data size overheads are typically below 100%. We also benchmarked our prototype system against two commercially available tools that support memory access checking (Purify <ref> [HJ92] </ref> and CodeCenter [KLP88]) and found that our checking technique consistently uses less resources, even while providing better error coverage for memory access errors. This paper is organized as follows. Section 2 introduces our extended safe pointer representation. <p> Table 2 details our work (Safe-C) and five other published systems that support memory access checking. Hastings' and Joyce's Purify <ref> [HJ92] </ref> is a commercially available memory access checking tool. It is particularly convenient to use because it does not require program source all transformations are applied to the object code. <p> These limitations occur because Purify does not determine the intended referent of memory Name Environment Method Error Model Spatial Checks? Temporal Checks? Extensions Safe-C C/C++ source-to-source yes* yes* errant free's translation Purify object files object code yes yes errant free's, uninitialized <ref> [HJ92] </ref> translation limited to heap limited to heap reads, storage leaks RTCC C safe yes* no [Ste92] compiler CodeCenter C/C++ interpreter yes* yes errant free's, uninitialized reads, [KLP88] dynamic type checking, etc.
Reference: [Ken83] <author> Samuel C. Kendall. Bcc: </author> <title> Runtime checking for C programs. </title> <booktitle> Proceedings of the Summer Usenix Conference, </booktitle> <year> 1983. </year>
Reference-contexts: Bcc C source-to-source yes* no alignment checks, <ref> [Ken83] </ref> translation overflow checks UW-Pascal Pascal safe yes* yes errant free's, [FL80] compiler arithmetic faults, etc. Table 2: Comparison of memory access checking work. <p> Since programs run in an interpreter, the execution overheads may discourage its use, and in the case of long running programs, may preclude its use. Due to our use of compile-time instrumentation, resource requirements are significantly lower. Compile-time instrumentation also allows us to employ static check optimizations. Kendall's Bcc <ref> [Ken83] </ref> is a commercial source-to-source translator for the C language. It supports spatial error checking, but temporal error checking is limited to NULL checks at all pointer dereferences.
Reference: [KLP88] <author> Stephen Kaufer, Russel Lopez, and Sesha Pratap. Saber-C: </author> <title> an interpreter-based programming environment for the C language. </title> <booktitle> Proceedings of the Summer Usenix Conference, </booktitle> <pages> pages 161-171, </pages> <year> 1988. </year>
Reference-contexts: The performance is quite good. Instruction execution overheads range from 130% to 540%, and text and data size overheads are typically below 100%. We also benchmarked our prototype system against two commercially available tools that support memory access checking (Purify [HJ92] and CodeCenter <ref> [KLP88] </ref>) and found that our checking technique consistently uses less resources, even while providing better error coverage for memory access errors. This paper is organized as follows. Section 2 introduces our extended safe pointer representation. <p> Spatial Checks? Temporal Checks? Extensions Safe-C C/C++ source-to-source yes* yes* errant free's translation Purify object files object code yes yes errant free's, uninitialized [HJ92] translation limited to heap limited to heap reads, storage leaks RTCC C safe yes* no [Ste92] compiler CodeCenter C/C++ interpreter yes* yes errant free's, uninitialized reads, <ref> [KLP88] </ref> dynamic type checking, etc. Bcc C source-to-source yes* no alignment checks, [Ken83] translation overflow checks UW-Pascal Pascal safe yes* yes errant free's, [FL80] compiler arithmetic faults, etc. Table 2: Comparison of memory access checking work. <p> In the implementation of RTCC the issue of interfacing to library and system calls is addressed through encapsulation; Steffen also augmented sdb to provide users with transparent debugging support. CodeCenter <ref> [KLP88] </ref> is an interpreted C language environment.
Reference: [Lar93] <author> James R. Larus. </author> <title> Efficient program tracing. </title> <journal> IEEE Computer, </journal> <volume> 26(5) </volume> <pages> 52-61, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: All programs were compiled and executed on a DECsta-tion 3100 using AT&T USL cfront version 3.0.1. The output of cfront (C code) was compiled using MIPS cc version 2.1 at optimization level `-O2'. All instruction counts were obtained with QPT <ref> [Lar93] </ref>. For all analyses, object attributes were only attached to pointer values.
Reference: [Lee91] <editor> Peter Lee, editor. </editor> <booktitle> Topics in Advanced Language Implementation. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: The idea is similar to tagged pointers used in many Lisp implementations <ref> [Lee91] </ref>. Figure 2 shows our safe pointer representation. The definitions of the contained fields follow: value: The value of the safe pointer; it may contain any expressible address. base and size: The base address of the referent and its size in bytes.
Reference: [MFS90] <author> Barton P. Miller, Lars Fredriksen, and Bryan So. </author> <title> An empirical study of the reliability of Unix utilities. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 32-44, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: For example, in This work was supported by grants from the National Science Foundation (grant CCR-9303030) and Office of Naval Research (grant N00014-93-1-0465). <ref> [MFS90] </ref>, Miller et. al. injected random inputs (a.k.a "fuzz") into a number of Unix utilities. On systems from six different vendors, nearly all of the seemingly mature programs could be coaxed into dumping core. The most prevalent errors detected were memory access errors.
Reference: [Ros87] <author> Graham Ross. </author> <title> Integral C a practical environment for C programming. </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (SIGPLAN Notices), </booktitle> <pages> pages 42-48. </pages> <institution> Association for Computing Machinery, </institution> <month> January </month> <year> 1987. </year>
Reference: [SC91] <author> Mark Sullivan and Ram Chillarege. </author> <title> Software defects and their impact on system availability a study of field failures in operating systems. </title> <booktitle> Digest of the 21st International Symposium on Fault Tolerant Computing, </booktitle> <pages> pages 2-9, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: On systems from six different vendors, nearly all of the seemingly mature programs could be coaxed into dumping core. The most prevalent errors detected were memory access errors. In <ref> [SC91] </ref>, Sullivan and Chillarege examined IBM MVS software error reports over a four year period. Nearly 50% of all reported software errors examined were due to pointer and array access errors.
Reference: [Ste92] <author> Joseph L. Steffen. </author> <title> Adding run-time checking to the Portable C Compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 22(4) </volume> <pages> 305-316, </pages> <year> 1992. </year>
Reference-contexts: determine the intended referent of memory Name Environment Method Error Model Spatial Checks? Temporal Checks? Extensions Safe-C C/C++ source-to-source yes* yes* errant free's translation Purify object files object code yes yes errant free's, uninitialized [HJ92] translation limited to heap limited to heap reads, storage leaks RTCC C safe yes* no <ref> [Ste92] </ref> compiler CodeCenter C/C++ interpreter yes* yes errant free's, uninitialized reads, [KLP88] dynamic type checking, etc. Bcc C source-to-source yes* no alignment checks, [Ken83] translation overflow checks UW-Pascal Pascal safe yes* yes errant free's, [FL80] compiler arithmetic faults, etc. Table 2: Comparison of memory access checking work. <p> However, our technique is quite portable across different platforms, especially if implemented as a source-to-source translator. Although Purify is portable across languages (on a given platform), it is not portable across platforms. Steffen's RTCC <ref> [Ste92] </ref> extended the functionality of the C language compiler PCC to include spatial error checking. RTCC attaches object attributes to pointers in a fashion similar to our technique; it does not, however, detect temporal access errors, nor does it explore the use of check optimization.
Reference: [ZH88] <author> Benjamin Zorn and Paul Hilfinger. </author> <title> A memory allocation profiler for C and Lisp programs. </title> <booktitle> Proceedings of the Summer Usenix Conference, </booktitle> <pages> pages 223-237, </pages> <year> 1988. </year>
Reference-contexts: A closely related area of work, which can benefit from our safe programming technique, is storage leak detection <ref> [Boe93, BW88, ZH88] </ref>. A storage leak is any storage to which the program can no longer generate a name. These leaks occur when the last accessible pointer to a heap object is overwritten.
References-found: 19

