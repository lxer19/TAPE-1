URL: http://ftp.cs.indiana.edu/pub/stoller/TACS94.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: howe@research.att.com.  stoller@cs.cornell.edu.  
Phone: 2  
Title: An Operational Approach to Combining Classical Set Theory and Functional Programming Languages  
Author: Douglas J. Howe and Scott D. Stoller 
Address: 600 Mountain Ave., Room 2B-438 Murray Hill, NJ 07974, USA  Ithaca, NY 14853, USA.  
Affiliation: 1 AT&T Bell Labs,  Department of Computer Science, Cornell University  
Abstract: We have designed a programming logic based on an integration of functional programming languages with classical set theory. The logic merges a classical view of equality with a constructive one by using equivalence classes, while at the same time allowing computation with representatives of equivalence classes. Given a programming language and its operational semantics, a logic is obtained by extending the language with the operators of set theory and classical logic, and extending the operational semantics with "evaluation" rules for these new operators. This operational approach permits us to give a generic design. We give a general formalism for specifying evaluation semantics, and parameterize our design with respect to languages specifiable in this formalism. This allows us to prove, once and for all, important properties of the semantics such as the coherence of the treatment of equality. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abramsky. </author> <title> The lazy lambda calculus. </title> <booktitle> Proceedings of the Institute of Declarative Programming, </booktitle> <month> August </month> <year> 1987. </year>
Reference-contexts: This allows us to prove once, for a fairly large class of programming languages, that the operational equivalence of the lan guage is compatible with set-theoretic equality, and that equivalence classes can be given a computational interpretation. Congruence proof. Our program equivalence is a generalization of applicative bisimulation <ref> [1] </ref>. We prove it is a congruence using a new extension of the proof method introduced by the first author in [11]. The extension is needed to deal with typed -abstractions. There have been at two other recent attempts to combine set theory with computation.
Reference: 2. <author> M. J. Beeson. </author> <title> Towards a computation system based on set theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 60 </volume> <pages> 297-340, </pages> <year> 1988. </year>
Reference-contexts: We prove it is a congruence using a new extension of the proof method introduced by the first author in [11]. The extension is needed to deal with typed -abstractions. There have been at two other recent attempts to combine set theory with computation. In <ref> [2] </ref>, Beeson extends to ZF set theory Feferman's idea for a classical model of his theory T 0 [8]. This might appear more general than our logic, since one can build function types containing untyped abstractions.
Reference: 3. <author> E. Bishop. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1967. </year>
Reference-contexts: This view is compatible with Bishop's style of constructive mathematics <ref> [3] </ref>. Mathematical modeling of programs and software systems. For example, we want to support at least the general kind of set-theoretic modeling used in the specification language Z [18]. Providing a highly expressive type system for functional programming languages. Types are a good way of organizing knowledge about functional programs.
Reference: 4. <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and computational aspects of programming with sets/bags/lists. </title> <booktitle> In Automata, Languages and Programming: 18 th International Colloquium, Lecture Notes in Computer Science, </booktitle> <pages> pages 60-75. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We give an example of this in Section 5, where we derive a rather conventional rule for proving termination of a recursive program by well-founded induction. The following aspects of our work are new. Computational interpretation of equivalence classes. In <ref> [4] </ref>, Breazu-Tannen and Subrahmanyam give a logic for reasoning about programs using structural recursion over data types involving constructors subject to some equations.
Reference: 5. <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> On extending computational adequacy by data abstraction. </title> <booktitle> In Proc. ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 161-169. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: We might still be able to establish suitable representation independence results, but this will require considerable extra work. (See <ref> [5] </ref> for an approach along these lines.) This is not required in our setting, since in P we can give an implementation of Q by taking the obvious one in P 0 and using quotienting to make it respect the equations of Q. Our operational approach has a few drawbacks.
Reference: 6. <author> R. L. Constable, et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: Providing a highly expressive type system for functional programming languages. Types are a good way of organizing knowledge about functional programs. For example, the Calculus of Constructions [7] and Nuprl <ref> [6] </ref>, have type systems rich enough to serve as specification languages for functional programs.
Reference: 7. <author> T. Coquand and G. Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: For example, we want to support at least the general kind of set-theoretic modeling used in the specification language Z [18]. Providing a highly expressive type system for functional programming languages. Types are a good way of organizing knowledge about functional programs. For example, the Calculus of Constructions <ref> [7] </ref> and Nuprl [6], have type systems rich enough to serve as specification languages for functional programs.
Reference: 8. <author> S. Feferman. </author> <title> A language and axioms for explicit mathematics. </title> <editor> In Dold, A. and B. Eckmann, editor, </editor> <booktitle> Algebra and Logic, volume 450 of Lecture Notes in Mathematics, </booktitle> <pages> pages 87-139. </pages> <publisher> Springer-Verlag, </publisher> <year> 1975. </year>
Reference-contexts: The extension is needed to deal with typed -abstractions. There have been at two other recent attempts to combine set theory with computation. In [2], Beeson extends to ZF set theory Feferman's idea for a classical model of his theory T 0 <ref> [8] </ref>. This might appear more general than our logic, since one can build function types containing untyped abstractions. For example, the type N ! N would contain the polymorphic identity x: x, and, in general, any f such that f (e) evaluates to a number whenever e does.
Reference: 9. <author> M. Gordon. </author> <title> A proof generating system for higher-order logic. </title> <booktitle> In Proceedings of the Hardware Verification Workshop, </booktitle> <year> 1989. </year>
Reference-contexts: For example, the Calculus of Constructions [7] and Nuprl [6], have type systems rich enough to serve as specification languages for functional programs. Many of a program's properties can be expressed in its type, while in less expressive type systems, such as the simple type theory of HOL <ref> [9] </ref>, almost all properties are formalized as a predicate over some simple type. As a suitable logic for these purposes, we propose an integration of a functional programming language with full classical set theory (ZFC). Our approach to accomplishing this integration is to give precedence to operational semantics.
Reference: 10. <author> K. Grue. </author> <title> Map theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 1-133, </pages> <year> 1992. </year>
Reference-contexts: This means that (N ! N ) ! N cannot be understood as a function space in the traditional sense, since no function whose graph is in V can have a sufficiently large domain. Also, Beeson does not deal with equivalence classes. Map theory <ref> [10] </ref> provides an alternate foundation to set theory, in which everything is reduced to a "map".
Reference: 11. <author> D. J. Howe. </author> <title> Equality in lazy computation systems. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 198-203. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Adding an evaluation rule for " is straightforward. The natural notion of equality of programs with meanings is to take t = t 0 if t and t 0 have the same set as their meaning. Following <ref> [11] </ref>, we can also define another equality, which we will denote by , that is based directly on the operational semantics of P , is defined over all programs, and which justifies the usual kinds of equational reasoning about functional programs. <p> Congruence proof. Our program equivalence is a generalization of applicative bisimulation [1]. We prove it is a congruence using a new extension of the proof method introduced by the first author in <ref> [11] </ref>. The extension is needed to deal with typed -abstractions. There have been at two other recent attempts to combine set theory with computation. In [2], Beeson extends to ZF set theory Feferman's idea for a classical model of his theory T 0 [8]. <p> It is easy to show that =[] and that is a preorder. Define a b if a b and b a. Theorem 1 ffi is a precongruence (hence ffi is a congruence). Proof. The proof is a straightforward adaptation of the method first presented in <ref> [11] </ref> and applied in [12]. We just outline the differences here. The key idea in the method is to define, using , an auxiliary relation b that is easy to show a congruence, and then to show that b by coinduction, i.e., by showing b [ b ].
Reference: 12. <author> D. J. Howe. </author> <title> On computational open-endedness in Martin-Lof's type theory. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-172. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: Adequate formalizations of set theory are well-known, but there is no general agreement on what should go into a functional programming language. We give a formalism for specifying evaluation semantics, similar to the one given in <ref> [12] </ref>, and parameterize our account with respect to languages specifiable in this formalism. This allows us, for example, to prove, once and for all, such properties as congruence of equality and adequacy of our semantics for the interpreter (see the discussion of equality below). <p> We could follow <ref> [12] </ref> and attempt to express these restrictions without mentioning P by quantifying over all possible extensions of P 0 , but all the ways to do this that we know of are somewhat arbitrary and complicated. Instead, we will simply make these restrictions directly in terms of P . <p> It is easy to show that =[] and that is a preorder. Define a b if a b and b a. Theorem 1 ffi is a precongruence (hence ffi is a congruence). Proof. The proof is a straightforward adaptation of the method first presented in [11] and applied in <ref> [12] </ref>. We just outline the differences here. The key idea in the method is to define, using , an auxiliary relation b that is easy to show a congruence, and then to show that b by coinduction, i.e., by showing b [ b ]. <p> This is proved by induction on the definition of evaluation. We use the same definition of b as in <ref> [12] </ref> 4 , but we adapt the induction to treat . directly. The proof reduces to showing the following by induction on the definition of + and .. 1. If a . ff, then a b a 0 implies a 0 . ff. 2. <p> For example, with one universe U , we could write a polymorphic list-append procedure and give it a type like A 2 U : A list ! A list ! A list: 4 In <ref> [12] </ref>, b is named fl We could also use sigma-types to represent abstract data types. Our delaying of the evaluation of " 0 in the interpreter, described below, is essential if we are to obtain an executable programming language with explicit polymorphism of the kind we are suggesting. <p> We plan to develop a version of the theory containing unbounded -abstraction, building on the ideas in <ref> [12] </ref>, which gives a classical model of a type theory of Martin-Lof. This will allow more poly-morphism, but will likely place strong restrictions on the permissible kinds of set-theoretic principles for constructing sets.
Reference: 13. <author> P. Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress for Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-175. </pages> <publisher> North Holland, </publisher> <year> 1982. </year> . 
Reference-contexts: Universes (probably one is sufficient) could play a role in our logic similar to the one they play in Martin-Lof's type theory <ref> [13] </ref>. For example, with one universe U , we could write a polymorphic list-append procedure and give it a type like A 2 U : A list ! A list ! A list: 4 In [12], b is named fl We could also use sigma-types to represent abstract data types.
Reference: 14. <author> D. A. McAllester. Ontic: </author> <title> A Knowledge Representation System for Mathematics. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: An important issue here is whether ZF itself is practical for large-scale formal reasoning. There is a substantial body of experience supporting a positive answer. Variants of ZF have been successfully implemented and applied in the theorem-provers Isabelle [15, 16] and Ontic <ref> [14] </ref>. Experience with Nuprl is also relevant, since it shows that a high level of automation of reasoning can be achieved even when the logic strongly favours expressive power over the ability to uniformly apply a powerful automated-reasoning method (such as resolution or term rewriting).
Reference: 15. <author> L. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-385. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: An important issue here is whether ZF itself is practical for large-scale formal reasoning. There is a substantial body of experience supporting a positive answer. Variants of ZF have been successfully implemented and applied in the theorem-provers Isabelle <ref> [15, 16] </ref> and Ontic [14]. Experience with Nuprl is also relevant, since it shows that a high level of automation of reasoning can be achieved even when the logic strongly favours expressive power over the ability to uniformly apply a powerful automated-reasoning method (such as resolution or term rewriting).
Reference: 16. <author> L. C. Paulson. </author> <title> Set theory for verification: I. from foundations to functions. </title> <type> Technical report, </type> <institution> University of Cambridge, </institution> <year> 1993. </year>
Reference-contexts: An important issue here is whether ZF itself is practical for large-scale formal reasoning. There is a substantial body of experience supporting a positive answer. Variants of ZF have been successfully implemented and applied in the theorem-provers Isabelle <ref> [15, 16] </ref> and Ontic [14]. Experience with Nuprl is also relevant, since it shows that a high level of automation of reasoning can be achieved even when the logic strongly favours expressive power over the ability to uniformly apply a powerful automated-reasoning method (such as resolution or term rewriting).
Reference: 17. <author> J. C. Reynolds. </author> <title> Polymorphism is not set-theoretic. </title> <editor> In G. Kahn, D. B. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 145-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: If these exist, the meaning of e is the set-theoretic pair (u 0 ; v 0 ). For functions we need to make a restriction. Assigning a set-theoretic meaning to polymorphic functions such as x: x is problematic <ref> [17] </ref>. We allow such programs, but do not give them a set-theoretic meaning, although they can ap pear in larger programs that do have a meaning.
Reference: 18. <author> J. Spivey. </author> <title> The Z Notation. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: This view is compatible with Bishop's style of constructive mathematics [3]. Mathematical modeling of programs and software systems. For example, we want to support at least the general kind of set-theoretic modeling used in the specification language Z <ref> [18] </ref>. Providing a highly expressive type system for functional programming languages. Types are a good way of organizing knowledge about functional programs. For example, the Calculus of Constructions [7] and Nuprl [6], have type systems rich enough to serve as specification languages for functional programs.
References-found: 18

