URL: http://www.cs.wustl.edu/~pmh/tog96.ps.gz
Refering-URL: http://www.cs.wustl.edu/~pmh/research.html
Root-URL: http://www.cs.wustl.edu
Title: Approximating Polyhedra with Spheres for Time-Critical Collision Detection  
Author: Philip M. Hubbard 
Keyword: Categories and Subject Descriptors: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling|geometric algorithms, languages and systems; object hierarchies; physically based modeling; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism|animation; virtual reality. General Terms: algorithms, human factors, performance. Additional Key Words and Phrases: approximation, collision detection, interactive systems, medial-axis surfaces, spheres, time-critical computing.  
Date: July 26, 1996  
Affiliation: Program of Computer Graphics Cornell University  
Note: ACM Transactions on Graphics, Vol. 15, No. 3, July 1996, pp. 179-210  
Abstract: This paper presents a method for approximating polyhedral objects to support a time-critical collision-detection algorithm. The approximations are hierarchies of spheres, and they allow the time-critical algorithm to progressively refine the accuracy of its detection, stopping as needed to maintain the real-time performance essential for interactive applications. The key to this approach is a preprocess that automatically builds tightly fitting hierarchies for rigid and articulated objects. The preprocess uses medial-axis surfaces, which are skeletal representations of objects. These skeletons guide an optimization technique that gives the hierarchies accuracy properties appropriate for collision detection. In a sample application, hierarchies built this way allow the time-critical collision-detection algorithm to have acceptable accuracy, improving significantly on that possible with hierarchies built by previous techniques. The performance of the time-critical algorithm in this application is consistently 10 to 100 times better than a previous collision-detection algorithm, maintaining low latency and a nearly-constant frame rate of 10 frames per second on a conventional graphics workstation. The time-critical algorithm maintains its real-time performance as objects become more complicated, even as they exceed previously reported complexity levels by a factor of more than 10. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Norman I. Badler, Joseph O'Rourke, and Hasida Toltzis. </author> <title> A spherical representation of a human body for visualizing movement. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 67(10) </volume> <pages> 1397-1403, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: Their algorithm fits spheres to a polyhedron by anchoring big spheres to points on the polyhedron and shrinking the spheres until they just fit inside the polyhedron. Badler, O'Rourke and Toltzis <ref> [1] </ref> extend this approach to build two-level hierarchies, but they do not consider the more general hierarchies of greater depth necessary for a time-critical detection algorithm. <p> By these measures, the inaccuracy of the sphere-trees built with our algorithm is only a fraction of the inaccuracy for octree-based sphere-trees. It is worth comparing the algorithm from Sections 7 through 9 to the work of Badler, O'Rourke and Toltzis <ref> [1, 34] </ref>. Their algorithm also begins with a set of points distributed over the surface of the polyhedron.
Reference: [2] <author> David Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <booktitle> In Proceedings of SIG-GRAPH '90, published as Computer Graphics, </booktitle> <volume> 24(4) </volume> <pages> 19-29, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: A practical disadvantage of this algorithm, however, is that it returns insufficient information for many forms of collision response (it reports only one collision point even if multiple parts of the objects collide). Baraff <ref> [2] </ref> presents an algorithm that exploits inter-frame coherence to efficiently detect collisions between pairs of convex objects. Non-convex objects must be treated as a union of convex pieces, which will cause inefficiency for objects with complicated shapes.
Reference: [3] <author> David Baraff. </author> <title> Dynamic Simulation of Non-Penetrating Rigid Bodies. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: For the broad phase, Turk [47] and Zyda et al. [52] use a regular grid to identify objects that are close to each other. Baraff <ref> [3] </ref> and Cohen et al. [9] describe sweep-and-prune techniques which exploit inter-frame coherence to efficiently sort bounding boxes, identifying those that intersect. Several authors describe ways to adaptively change the broad phase's time step using predictions of objects' 5 future positions, predictions which often are possible for interactively guided objects.
Reference: [4] <author> Harry Blum. </author> <title> A transformation for extracting new descriptors of shape. </title> <editor> In Weiant Wathen-Dunn, editor, </editor> <booktitle> Models for the Perception of Speech and Visual Form, </booktitle> <pages> pages 362-380. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1967. </year>
Reference-contexts: The motivation for this approach is Blum's medial-axis <ref> [4] </ref>, which corresponds to a "skeleton" or "stick figure" representation of a two-dimensional (2D) object. Figure 5 (a) shows an example. A more technical definition involves the locus of points equidistant from two sides of the object.
Reference: [5] <author> Adrian Bowyer. </author> <title> Computing Dirichlet tessellations. </title> <journal> The Computer Journal, </journal> <volume> 24(2) </volume> <pages> 162-166, </pages> <year> 1981. </year>
Reference-contexts: It first creates a random distribution of points and then applies a relaxation technique to make the distribution even. The second step is building a Voronoi diagram for the points. The literature contains several 11 algorithms for 3D Voronoi diagrams. Bowyer <ref> [5] </ref> presents a straightforward algorithm that incremen-tally adds points to the diagram. This algorithm is not numerically robust, however, so Inagaki et al. [24] rephrase the algorithm to use topological properties rather than necessarily-inexact geometric computations. Unfortunately, these extensions compromise accuracy.
Reference: [6] <author> Frederick P. Brooks, Jr. </author> <title> Grasping reality through illusion|interactive graphics serving science. </title> <booktitle> In Proceedings of CHI '88, </booktitle> <pages> pages 1-11, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Performance is paramount for most interactive graphics applications, such as virtual reality systems and vehicle simulators. As Brooks <ref> [6] </ref> discusses for the case of virtual reality, these applications will fl Copyright 1996, ACM. All rights reserved.
Reference: [7] <author> Stephen A. Cameron. </author> <title> Collision detection by four-dimensional intersection testing. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 6(3) </volume> <pages> 291-302, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Samet and Tamminen [41] apply recursive subdivision to the four dimensions of space and time. Canny [8] derives quintic polynomials whose roots represent the time and location of collisions. Cameron <ref> [7] </ref> extends the approach of Samet and Tamminen, adding a mechanism that prunes parts of objects that cannot collide. Von Herzen et al. [50] use Lipshitz conditions to accelerate a form of binary search through space and time. Duff [11] applies interval analysis to generalize the idea of recursive subdivision.
Reference: [8] <author> John Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> 8(2) </volume> <pages> 200-209, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Samet and Tamminen [41] apply recursive subdivision to the four dimensions of space and time. Canny <ref> [8] </ref> derives quintic polynomials whose roots represent the time and location of collisions. Cameron [7] extends the approach of Samet and Tamminen, adding a mechanism that prunes parts of objects that cannot collide.
Reference: [9] <author> Jonathan D. Cohen, Ming C. Lin, Dinesh Manocha, and Madhav K. Ponamgi. I-COLLIDE: </author> <title> An interactive and exact collision detection system for large-scale environments. </title> <booktitle> In Proceedings of the 1995 Symposium on Interactive 3D Graphics (Monterey, California), </booktitle> <pages> pages 189-196, </pages> <year> 1995. </year>
Reference-contexts: For the broad phase, Turk [47] and Zyda et al. [52] use a regular grid to identify objects that are close to each other. Baraff [3] and Cohen et al. <ref> [9] </ref> describe sweep-and-prune techniques which exploit inter-frame coherence to efficiently sort bounding boxes, identifying those that intersect. Several authors describe ways to adaptively change the broad phase's time step using predictions of objects' 5 future positions, predictions which often are possible for interactively guided objects. <p> An intersection here may involve part of a hull that covers a concavity. In this case, the narrow phase descends a precomputed octree subdivision of the concavity, using a hierarchical version of the Cohen et al. sweep-and-prune technique <ref> [9] </ref> to exploit inter-frame coherence. For a sample run in which eight interlocked tori (400 faces each) bounce against each other, this approach gives real-time performance, taking 0.038 seconds per frame. The single, highly regular hole of a torus makes the octree approach particularly effective.
Reference: [10] <author> David P. Dobkin and David G. Kirkpatrick. </author> <title> Fast detection of polyhedral intersection. </title> <journal> Theoretical Computer Science, </journal> <volume> 27(3) </volume> <pages> 241-253, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: Several of these broad-phase algorithms perform well in empirical tests, so we use space-time bounds in our time-critical algorithm and we concentrate on the narrow phase in the remainder of this paper. An early narrow-phase algorithm of theoretical importance is described by Dobkin and Kirk-patrick <ref> [10] </ref>. This algorithm detects the collision of two polyhedra in O (log 2 n) time, where n is the total number of vertices in the polyhedra.
Reference: [11] <author> Tom Duff. </author> <title> Interval arithmetic and recursive subdivision for implicit functions and constructive solid geometry. </title> <booktitle> In Proceedings of SIGGRAPH '92, published as Computer Graphics, </booktitle> <volume> 26(2) </volume> <pages> 131-138, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Cameron [7] extends the approach of Samet and Tamminen, adding a mechanism that prunes parts of objects that cannot collide. Von Herzen et al. [50] use Lipshitz conditions to accelerate a form of binary search through space and time. Duff <ref> [11] </ref> applies interval analysis to generalize the idea of recursive subdivision. Snyder et al. [45] combine interval analysis with the Newton-Raphson root-finding technique, providing the most accurate detection to date for collisions involving curved surfaces. All of these techniques assume knowledge of every object's exact position throughout simulation time.
Reference: [12] <author> Andre Foisy, Vincent Hayward, and Stephane Aubry. </author> <title> The use of awareness in collision prediction. </title> <booktitle> In Proceedings of the 1990 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 338-343, </pages> <year> 1990. </year>
Reference-contexts: Mirtich and Canny [31] use upper bounds on linear and angular velocity in a priority queue that tracks the next possible collision between convex polyhedra. We use bounds on maximum acceleration to derive space-time bounds [20, 22], four-dimensional structures whose intersections predict bounding-sphere collisions. Foisy et al. <ref> [12] </ref> also use maximum accelerations to predict collisions, employing a queuing scheme to efficiently update the predictions.
Reference: [13] <author> Thomas A. Funkhouser and Carlo H. Sequin. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments. </title> <booktitle> In Proceedings of SIGGRAPH '93, published as Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 247-254, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Note the difference between this approach and the traditional use of hierarchies to focus on collisions between the real surfaces. The time-critical detection algorithm is kindred in spirit to recent time-critical algorithms for other graphics problems; examples include rendering algorithms for static walk-throughs by Funkhouser and Sequin <ref> [13] </ref> and Maciel and Shirley [29], the IRIS Performer application framework of Rolhf and Helman [40] and the human-figure animation algorithm of Granieri et al. [17]. This paper extends our earlier paper [20], which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies.
Reference: [14] <author> Alejandro Garcia-Alonso, Nicolas Serrano, and Juan Flaquer. </author> <title> Solving the collision detection problem. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 14(3) </volume> <pages> 36-43, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: One of the earliest examples of this idea is the work of Mantyla and Tamminen [30]. Kitamura et al. [26] present a more modern variation that uses octrees. Three recent algorithms with narrow phases that use subdivision techniques|the work of Smith et al. [44], Garcia-Alonso et al. <ref> [14] </ref> and Ponamgi et al. [36]|deserve particular attention. Although their broad phases create the temporal inaccuracy discussed in Section 2, these algorithms have the advantage that they achieve real-time performance for some challenging situations. <p> Few real applications end at the first collision, however. It is unclear how the algorithm would perform after collision response, which can cause multiple objects to collect in colliding and nearly-colliding configurations for many time steps. The Garcia-Alonso et al. <ref> [14] </ref> algorithm precomputes a one-level grid subdivision for each object. The narrow phase uses these grids to search for intersecting faces within the overlap of object bounding boxes.
Reference: [15] <author> John A. Goldak, Xinhua Yu, Alan Knight, and Lingxian Dong. </author> <title> Constructing discrete medial axis of 3-D objects. </title> <journal> International Journal of Computational Geometry and Applications, </journal> <volume> 1(3) </volume> <pages> 327-339, </pages> <year> 1991. </year>
Reference-contexts: Figure 5 (b) shows an analogous 2D situation. This idea could work for nonpolyhedral objects, but this paper focuses on the polyhedral case. Goldak et al. <ref> [15] </ref> develop this idea into an algorithm. Their algorithm identifies the Voronoi vertices (corners of Voronoi cells) that lie on the medial-axis surface. In their description of the algorithm, Goldak et al. emphasize the general properties at the expense of specific details.
Reference: [16] <author> Jeffrey Goldsmith and John Salmon. </author> <title> Automatic creation of object hierarchies for ray tracing. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7(5) </volume> <pages> 14-20, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Kay and Kajiya [25], for example, build bounding shapes that are cheap to intersect with rays, but these shapes do not have the rotational invariance necessary for moving objects. Goldsmith and Salmon <ref> [16] </ref>, as another example, show that a hierarchy prunes ray-object intersection tests most effectively if it minimizes surface area; this criteria does not necessarily encourage a tight fit around an object, though, as it can create artifacts like "caps" over concavities.
Reference: [17] <author> John P. Granieri, Jonathan Crabtree, and Norman I. Badler. </author> <title> Production and playback of human figure motion for 3D virtual environments. </title> <booktitle> In Proceedings of the IEEE Virtual Reality Annual International Symposium, </booktitle> <pages> pages 127-135, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: detection algorithm is kindred in spirit to recent time-critical algorithms for other graphics problems; examples include rendering algorithms for static walk-throughs by Funkhouser and Sequin [13] and Maciel and Shirley [29], the IRIS Performer application framework of Rolhf and Helman [40] and the human-figure animation algorithm of Granieri et al. <ref> [17] </ref>. This paper extends our earlier paper [20], which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies.
Reference: [18] <author> Lawrence J. Hettinger and Gary E. Riccio. </author> <title> Visually induced motion sickness in virtual environments. </title> <journal> Presence, </journal> <volume> 1(3) </volume> <pages> 306-310, </pages> <month> Summer </month> <year> 1992. </year>
Reference-contexts: Even if inaccuracies are noticeable, they may be better than the alternative, degraded performance with improved accuracy. Hettinger and Riccio <ref> [18] </ref> report that users of vehicle simulators seem to suffer motion sickness more frequently when latency is high.
Reference: [19] <author> Christoph M. Hoffmann. </author> <title> How to construct the skeleton of CSG objects. </title> <editor> In Adrian Bowyer and J. Davenport, editors, </editor> <booktitle> The Mathematics of Surfaces IV. </booktitle> <publisher> Oxford University Press, Oxford, </publisher> <year> 1990. </year> <note> Available as Technical Report CSD-TR-1014, </note> <institution> Computer Sciences Department, Purdue University. </institution>
Reference-contexts: As a precursor to this algorithm, the Section 7 discusses the building of medial-axis surfaces. 7 Building Medial-Axis Surfaces An algorithm that builds a sphere hierarchy from a medial-axis surface must first build the medial-axis surface. This problem is not simple, and the literature contains few solutions. Hoffmann <ref> [19] </ref> presents the only exact algorithm, but it is complicated and limited to constructive solid geometry (CSG) objects. Fortunately, building sphere hierarchies does not require exact medial-axis surfaces; approximations suffice. One way to approximate a medial-axis surface uses a Voronoi diagram [37].
Reference: [20] <author> Philip M. Hubbard. </author> <title> Interactive collision detection. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <pages> pages 24-31, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This paper extends our earlier paper <ref> [20] </ref>, which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies. <p> This application generates frames on a simulation time scale, which may not correspond to the wall-clock time we experience. The detection algorithm is accurate to only t d simulation time units, its minimum temporal resolution. The simple detection algorithm has several weaknesses, as we describe in more detail elsewhere <ref> [20, 22] </ref>. The fixed time step on line 9 can cause inaccuracy or inefficiency, and the all-pairs loop on line 10 can reduce performance. <p> Mirtich and Canny [31] use upper bounds on linear and angular velocity in a priority queue that tracks the next possible collision between convex polyhedra. We use bounds on maximum acceleration to derive space-time bounds <ref> [20, 22] </ref>, four-dimensional structures whose intersections predict bounding-sphere collisions. Foisy et al. [12] also use maximum accelerations to predict collisions, employing a queuing scheme to efficiently update the predictions. <p> Octree-like recursive subdivision is the basis for hierarchy-building algorithms described by Liu et al. [28] and by us in a previous paper <ref> [20] </ref>. An octree for an object defines a sphere-tree if each occupied octant is circumscribed by a sphere. A preprocess based on 9 this approach has the advantages that it is straightforward to implement and quick to execute. <p> The sphere-trees had levels 1 through 3 depicted in the figures plus an additional level 4. The BSP trees were optimized to avoid face-splitting, a heuristic which pilot studies indicated makes the BSP trees more efficient. At runtime, both detection algorithms used a broad phase based on space-time bounds <ref> [20, 22] </ref> to find bounding-sphere collisions. The simulator's collision response is quite simple. When two ships collide, the response algorithm determines if the ships are converging by checking the relative velocities of the colliding spheres (for BSP trees, it uses the bounding spheres).
Reference: [21] <author> Philip M. Hubbard. </author> <title> Collision Detection for Interactive Graphics Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <month> October </month> <year> 1994. </year> <note> Available at ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-08.ps.Z. </note>
Reference-contexts: This algorithm is not numerically robust, however, so Inagaki et al. [24] rephrase the algorithm to use topological properties rather than necessarily-inexact geometric computations. Unfortunately, these extensions compromise accuracy. As a remedy, we extend the algorithm to choose between equally-valid topological situations based on estimated accuracy <ref> [21] </ref>. Each Voronoi vertex is the center of a sphere on which lie four points from the set P . The four points thus associated with a vertex are its forming points. <p> For each such intersection, P gets an additional point, p 0 , the projection of p onto the region of intersection. Complete details of this process appear elsewhere <ref> [21] </ref>. 8 Building Sphere Hierarchies from Medial-Axis Surfaces The previous section's algorithm generates a large set of Voronoi vertices on a polyhedral object's medial-axis surface. Each vertex and its forming points define a sphere, and these spheres tightly approximate the polyhedron. <p> A cost function computing this distance would return low costs in the appropriate cases, but we have found no way to compute this distance exactly for nonconvex polyhedra; as we explain elsewhere <ref> [21] </ref>, a straightforward algorithm (albeit one with a complicated correctness proof) computes this distance exactly for convex polyhedra, but the algorithm seems to overestimate the distance for nonconvex polyhedra, even when expressed as unions of convex pieces. We thus use a function that approximates the Hausdorff distance. <p> Specifically, the following boundary lemma simplifies the problem: the triangle (within the clipping disk) is covered by the disks if an only if for each disk, the part of its boundary inside the triangle (and within the clipping disk) is covered by other disks. We prove this lemma elsewhere <ref> [21] </ref>, but Figure 9 gives an intuitive justification; note that the uncovered region, U , is ringed by uncovered portions of disk boundaries. Implementing a coverage-checker based on the boundary lemma is straightforward, because the book-keeping involves primarily set operations on one-dimensional intervals representing disk boundaries.
Reference: [22] <author> Philip M. Hubbard. </author> <title> Collision detection for interactive graphics applications. </title> <journal> IEEE Transactions on Visualization and Computer Graphics, </journal> <volume> 1(3) </volume> <pages> 218-230, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This paper extends our earlier paper [20], which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies. Our companion papers <ref> [23, 22] </ref>|to our knowledge, the only other descriptions of time-critical collision detection|complement the current paper, focusing more on the framework for the time-critical algorithm and less on important details of building and using the sphere hierarchies. <p> This application generates frames on a simulation time scale, which may not correspond to the wall-clock time we experience. The detection algorithm is accurate to only t d simulation time units, its minimum temporal resolution. The simple detection algorithm has several weaknesses, as we describe in more detail elsewhere <ref> [20, 22] </ref>. The fixed time step on line 9 can cause inaccuracy or inefficiency, and the all-pairs loop on line 10 can reduce performance. <p> Mirtich and Canny [31] use upper bounds on linear and angular velocity in a priority queue that tracks the next possible collision between convex polyhedra. We use bounds on maximum acceleration to derive space-time bounds <ref> [20, 22] </ref>, four-dimensional structures whose intersections predict bounding-sphere collisions. Foisy et al. [12] also use maximum accelerations to predict collisions, employing a queuing scheme to efficiently update the predictions. <p> The sphere-trees had levels 1 through 3 depicted in the figures plus an additional level 4. The BSP trees were optimized to avoid face-splitting, a heuristic which pilot studies indicated makes the BSP trees more efficient. At runtime, both detection algorithms used a broad phase based on space-time bounds <ref> [20, 22] </ref> to find bounding-sphere collisions. The simulator's collision response is quite simple. When two ships collide, the response algorithm determines if the ships are converging by checking the relative velocities of the colliding spheres (for BSP trees, it uses the bounding spheres). <p> It ignores rotational velocity for simplicity. The user's ship has infinite mass, so it affects other ships but is not itself affected. This collision response improves on what we used in our companion paper <ref> [22] </ref>, which "teleports" the colliding objects to their non-colliding positions from the start of the simulation. 11.2 Performance at Each Hierarchy Level The first set of tests studied the performance available from each level in the sphere-trees.
Reference: [23] <author> Philip M. Hubbard. </author> <title> Real-time collision detection and time-critical computing. </title> <booktitle> In Proceedings of the First ACM Workshop on Simulation and Interaction in Virtual Environments, </booktitle> <pages> pages 92-96, </pages> <month> July </month> <year> 1995. </year> <month> 25 </month>
Reference-contexts: This paper extends our earlier paper [20], which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies. Our companion papers <ref> [23, 22] </ref>|to our knowledge, the only other descriptions of time-critical collision detection|complement the current paper, focusing more on the framework for the time-critical algorithm and less on important details of building and using the sphere hierarchies.
Reference: [24] <author> Hiroshi Inagaki, Kokichi Sugihara, and Noboru Sugie. </author> <title> Numerically robust incremental algorithm for constructing three--dimensional voronoi diagrams. </title> <booktitle> In Proceedings of the Fourth Canadian Conference on Computational Geometry, </booktitle> <pages> pages 334-339, </pages> <year> 1992. </year>
Reference-contexts: The second step is building a Voronoi diagram for the points. The literature contains several 11 algorithms for 3D Voronoi diagrams. Bowyer [5] presents a straightforward algorithm that incremen-tally adds points to the diagram. This algorithm is not numerically robust, however, so Inagaki et al. <ref> [24] </ref> rephrase the algorithm to use topological properties rather than necessarily-inexact geometric computations. Unfortunately, these extensions compromise accuracy. As a remedy, we extend the algorithm to choose between equally-valid topological situations based on estimated accuracy [21].
Reference: [25] <author> Timothy L. Kay and James T. Kajiya. </author> <title> Ray tracing complex scenes. </title> <booktitle> In Proceedings of SIGGRAPH '86, published as Computer Graphics, </booktitle> <volume> 20(4) </volume> <pages> 269-277, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Second, these algorithms optimize the hierarchy for the characteristics of ray-object intersection tests, an approach which does not necessarily lead to the tightly fitting sphere hierarchies needed for collision detection. Kay and Kajiya <ref> [25] </ref>, for example, build bounding shapes that are cheap to intersect with rays, but these shapes do not have the rotational invariance necessary for moving objects.
Reference: [26] <author> Yoshifumi Kitamura, Haruo Takemura, Narendra Ahuja, and Fumio Kishino. </author> <title> Efficient collision detection among objects in arbitrary motion using multiple shape representations. </title> <booktitle> In Proceedings 12th IAPR International Conference on Pattern Recognition, </booktitle> <pages> pages 390-396, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Recursive subdivision allows an algorithm to process objects with more general shapes. One of the earliest examples of this idea is the work of Mantyla and Tamminen [30]. Kitamura et al. <ref> [26] </ref> present a more modern variation that uses octrees. Three recent algorithms with narrow phases that use subdivision techniques|the work of Smith et al. [44], Garcia-Alonso et al. [14] and Ponamgi et al. [36]|deserve particular attention.
Reference: [27] <author> Ming C. Lin and John F. Canny. </author> <title> A fast algorithm for incremental distance calculation. </title> <booktitle> In Proceedings 1991 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 1008-1014, </pages> <year> 1991. </year>
Reference-contexts: Thus, rotations reduce the grid's expected efficiency for localizing collisions. 6 Ponamgi et al. [36] use a narrow phase that builds on two previous approaches. It first uses the incremental algorithm of Lin and Canny <ref> [27] </ref> to check the convex hulls of the two objects for intersection. An intersection here may involve part of a hull that covers a concavity.
Reference: [28] <author> Yunhui Liu, Jiroshi Noborio, and Suguru Arimoto. </author> <title> Hierarchical sphere model (HSM) and its application for checking an interference between moving robots. </title> <booktitle> In Proceedings of the IEEE International Workshop on Intelligent Robots and Systems, </booktitle> <pages> pages 801-806, </pages> <year> 1988. </year>
Reference-contexts: Octree-like recursive subdivision is the basis for hierarchy-building algorithms described by Liu et al. <ref> [28] </ref> and by us in a previous paper [20]. An octree for an object defines a sphere-tree if each occupied octant is circumscribed by a sphere. A preprocess based on 9 this approach has the advantages that it is straightforward to implement and quick to execute.
Reference: [29] <author> Paulo W. C. Maciel and Peter Shirley. </author> <title> Visual navigation of large environments using textured clusters. </title> <booktitle> In Proceedings of the 1995 Symposium on Interactive 3D Graphics (Monterey, California), </booktitle> <pages> pages 95-102, </pages> <year> 1995. </year>
Reference-contexts: The time-critical detection algorithm is kindred in spirit to recent time-critical algorithms for other graphics problems; examples include rendering algorithms for static walk-throughs by Funkhouser and Sequin [13] and Maciel and Shirley <ref> [29] </ref>, the IRIS Performer application framework of Rolhf and Helman [40] and the human-figure animation algorithm of Granieri et al. [17]. This paper extends our earlier paper [20], which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies.
Reference: [30] <author> Martti Mantyla and Markku Tamminen. </author> <title> Localized set operations for solid modeling. </title> <booktitle> In Proceedings of SIGGRAPH '83, published as Computer Graphics, </booktitle> <volume> 17(3) </volume> <pages> 279-287, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: This approach works well but applies to only some types of objects, those with spherical topology and "star-shaped" [37] surface features. Recursive subdivision allows an algorithm to process objects with more general shapes. One of the earliest examples of this idea is the work of Mantyla and Tamminen <ref> [30] </ref>. Kitamura et al. [26] present a more modern variation that uses octrees. Three recent algorithms with narrow phases that use subdivision techniques|the work of Smith et al. [44], Garcia-Alonso et al. [14] and Ponamgi et al. [36]|deserve particular attention.
Reference: [31] <author> Brian Mirtich and John Canny. </author> <title> Impulse-based simulation of rigid bodies. </title> <booktitle> In Proceedings of the 1995 Symposium on Interactive 3D Graphics (Monterey, California), </booktitle> <pages> pages 181-188, </pages> <year> 1995. </year>
Reference-contexts: Several authors describe ways to adaptively change the broad phase's time step using predictions of objects' 5 future positions, predictions which often are possible for interactively guided objects. Mirtich and Canny <ref> [31] </ref> use upper bounds on linear and angular velocity in a priority queue that tracks the next possible collision between convex polyhedra. We use bounds on maximum acceleration to derive space-time bounds [20, 22], four-dimensional structures whose intersections predict bounding-sphere collisions.
Reference: [32] <author> Matthew P. Moore and Jane Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <booktitle> In Proceedings of SIGGRAPH '88, published as Computer Graphics, </booktitle> <volume> 22(4) </volume> <pages> 289-298, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: To work in this context, these algorithms would need to predict the future positions of objects; we discuss related ideas later in this section. Other algorithms do improve on the basic algorithm without making assumptions about objects' motions. Moore and Wilhelms <ref> [32] </ref> and Shaffer and Herb [43] use recursive subdivision in the form of an octree. By repeatedly subdividing regions of space that contain more than one object, an octree helps these algorithms avoid testing distant parts of objects for collisions.
Reference: [33] <author> Bruce F. Naylor. </author> <title> Constructing good partitioning trees. </title> <booktitle> In Proceedings of Graphics Interface '93, </booktitle> <pages> pages 181-191, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A precomputed BSP tree transforms naturally to match a moving rigid object, which is not true of a precomputed octree or axis-aligned grid. The preprocess that builds the BSP tree can also optimize the tree's collision-localizing properties, as Naylor describes <ref> [33] </ref>.
Reference: [34] <author> Joseph O'Rourke and Norman Badler. </author> <title> Decomposition of three-dimensional objects into spheres. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> PAMI-1(3):295-305, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: The most successful approach for tightly approximating an object with spheres is the work of O'Rourke and Badler <ref> [34] </ref>. Their algorithm fits spheres to a polyhedron by anchoring big spheres to points on the polyhedron and shrinking the spheres until they just fit inside the polyhedron. <p> By these measures, the inaccuracy of the sphere-trees built with our algorithm is only a fraction of the inaccuracy for octree-based sphere-trees. It is worth comparing the algorithm from Sections 7 through 9 to the work of Badler, O'Rourke and Toltzis <ref> [1, 34] </ref>. Their algorithm also begins with a set of points distributed over the surface of the polyhedron.
Reference: [35] <author> Randy Pausch, Thomas Crea, and Matthew Conway. </author> <title> A literature survey for virtual environments: Military flight simulator visual systems and simulator sickness. </title> <journal> Presence, </journal> <volume> 1(3) </volume> <pages> 344-363, </pages> <month> Summer </month> <year> 1992. </year>
Reference-contexts: Hettinger and Riccio [18] report that users of vehicle simulators seem to suffer motion sickness more frequently when latency is high. When poor performance does not cause "simulator sickness," it can render interactive applications unresponsive and thus ineffective; Pausch et al. <ref> [35] </ref>, for example, cite studies indicating that latency decreases operator performance in vehicle simulators. Full accuracy is also uncommon in the alternatives to the time-critical algorithm.
Reference: [36] <author> Madhav K. Ponamgi, Dinesh Manocha, and Ming C. Lin. </author> <title> Incremental algorithms for collision detection between solid models. </title> <booktitle> In Proceedings of the Third ACM Symposium on Solid Modeling and Applications, </booktitle> <pages> pages 293-304, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Thus, rotations reduce the grid's expected efficiency for localizing collisions. 6 Ponamgi et al. <ref> [36] </ref> use a narrow phase that builds on two previous approaches. It first uses the incremental algorithm of Lin and Canny [27] to check the convex hulls of the two objects for intersection. An intersection here may involve part of a hull that covers a concavity. <p> Another interesting comparison would involve one of the subdivision algorithms, for example, the work of Ponamgi et al <ref> [36] </ref>. This algorithm and the BSP algorithm both traverse trees, and the subdivision algorithm has the advantage that it can sometimes detect the absence of collisions before reaching the leaves. On the other hand, the BSP algorithm makes better use of preprocessing.
Reference: [37] <author> Franco P. Preparata and Michael I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1985. </year>
Reference-contexts: Sclaroff and Pentland [42] improve the narrow phase's performance by approximating each object with a new representation, a deformed superquadric ellipsoid whose surface is modulated by a displacement map. This approach works well but applies to only some types of objects, those with spherical topology and "star-shaped" <ref> [37] </ref> surface features. Recursive subdivision allows an algorithm to process objects with more general shapes. One of the earliest examples of this idea is the work of Mantyla and Tamminen [30]. Kitamura et al. [26] present a more modern variation that uses octrees. <p> Hoffmann [19] presents the only exact algorithm, but it is complicated and limited to constructive solid geometry (CSG) objects. Fortunately, building sphere hierarchies does not require exact medial-axis surfaces; approximations suffice. One way to approximate a medial-axis surface uses a Voronoi diagram <ref> [37] </ref>. The Voronoi diagram for a discrete set of points identifies, for each point, the region of space closer to that point than to any of the other points. The regions are called Voronoi cells. For 2D points the cells are convex polygons; for 3D points they are convex polyhedra. <p> Only the Voronoi vertices interior to the polyhedron lie on the medial-axis surface. The third step of the algorithm identifies these vertices. Inclusion testing is a standard geometric problem, and extensions of 2D algorithms <ref> [37] </ref> apply. Vertices in the Voronoi diagram are adjacent to each other if they lie on the same face of a Voronoi cell. These faces may legitimately have zero area, in which case vertices coincide. <p> The cost function for the optimization must return a low value when the merger of candidates s 1 and s 2 to form s 12 would preserve tightness around the polyhedron. A useful approach is based on the Hausdorff distance <ref> [37] </ref> from s 12 to the polyhedron. This distance is defined as the maximum, over all points on s 12 's surface, of the minimum distance from that point to the polyhedron.
Reference: [38] <author> William H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. </author> <title> Numerical Recipes in C. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, 2nd edition, </address> <year> 1992. </year>
Reference-contexts: The user controls her ship's forward acceleration and rotational velocity, and the simulator computes its motion according to a simplified dynamics model, solving the ordinary differential equations using a second-order Runge-Kutta method with adaptive step size <ref> [38] </ref>. The drones move according to the same model and pick their control parameters at random every few seconds. Each ship is free to collide with each other ship, and the simulator detects all collisions using one of the detection algorithms, or it calls both to compare their performance.
Reference: [39] <author> Jack Ritter. </author> <title> An efficient bounding sphere. </title> <editor> In Andrew S. Glassner, editor, </editor> <booktitle> Graphics Gems, </booktitle> <pages> pages 301-303. </pages> <publisher> Academic Press, </publisher> <address> Boston, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Thus, s 12 is the bounding sphere for the forming points associated with s 1 and s 2 ; we use Ritter's method <ref> [39] </ref> to compute a nearly-optimal bounding sphere. Figure 7 illustrates a 2D example of merging. After the merge, s 12 stores the union of the forming points from s 1 and s 2 , and any future merge involving s 12 must cover these points.
Reference: [40] <author> John Rohlf and James Helman. IRIS performer: </author> <title> A high performance multiprocessing toolkit for real-time 3D graphics. </title> <booktitle> In Proceedings of SIGGRAPH '94, published as Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 381-394, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The time-critical detection algorithm is kindred in spirit to recent time-critical algorithms for other graphics problems; examples include rendering algorithms for static walk-throughs by Funkhouser and Sequin [13] and Maciel and Shirley [29], the IRIS Performer application framework of Rolhf and Helman <ref> [40] </ref> and the human-figure animation algorithm of Granieri et al. [17]. This paper extends our earlier paper [20], which introduced the idea of time-critical collision detection but presented a less sophisticated approach to hierarchies. <p> Another class of algorithms builds a bounding hierarchy from the leaves up, with leaf spheres enclosing "primitive" pieces of an object. These algorithms require an appropriate set of primitives and a way to designate siblings at each hierarchy level. Youn and Wohn [51] and Rolhf and Helman <ref> [40] </ref> assume that the designer of an object addresses both of these issues by modeling the object as a hierarchy of pieces; these algorithms thus do not meet the requirement of producing hierarchies automatically. Ray-tracing renderers commonly use bounding hierarchies to reduce the number ray-object intersection tests.
Reference: [41] <author> Hanan Samet and Markku Tamminen. Bintrees, </author> <title> CSG trees, and time. </title> <booktitle> In Proceedings of SIGGRAPH '85, published as Computer Graphics, </booktitle> <volume> 19(3) </volume> <pages> 121-130, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Samet and Tamminen <ref> [41] </ref> apply recursive subdivision to the four dimensions of space and time. Canny [8] derives quintic polynomials whose roots represent the time and location of collisions. Cameron [7] extends the approach of Samet and Tamminen, adding a mechanism that prunes parts of objects that cannot collide.
Reference: [42] <author> Stan Sclaroff and Alex Pentland. </author> <title> Generalized implicit functions for computer graphics. </title> <booktitle> In Proceedings of SIG-GRAPH '91, published as Computer Graphics, </booktitle> <volume> 25(4) </volume> <pages> 247-250, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Baraff [2] presents an algorithm that exploits inter-frame coherence to efficiently detect collisions between pairs of convex objects. Non-convex objects must be treated as a union of convex pieces, which will cause inefficiency for objects with complicated shapes. Sclaroff and Pentland <ref> [42] </ref> improve the narrow phase's performance by approximating each object with a new representation, a deformed superquadric ellipsoid whose surface is modulated by a displacement map. This approach works well but applies to only some types of objects, those with spherical topology and "star-shaped" [37] surface features.
Reference: [43] <author> Clifford A. Shaffer and Gregory M. Herb. </author> <title> A real-time robot arm collision avoidance system. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 8(2) </volume> <pages> 149-160, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: To work in this context, these algorithms would need to predict the future positions of objects; we discuss related ideas later in this section. Other algorithms do improve on the basic algorithm without making assumptions about objects' motions. Moore and Wilhelms [32] and Shaffer and Herb <ref> [43] </ref> use recursive subdivision in the form of an octree. By repeatedly subdividing regions of space that contain more than one object, an octree helps these algorithms avoid testing distant parts of objects for collisions.
Reference: [44] <author> Andrew Smith, Yoshifumi Kitamura, Haruo Takemura, and Fumio Kishino. </author> <title> A simple and efficient method for accurate collision detection among deformable objects in arbitrary motion. </title> <booktitle> In Proceedings of the IEEE Virtual Reality Annual International Symposium, </booktitle> <pages> pages 136-145, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: One of the earliest examples of this idea is the work of Mantyla and Tamminen [30]. Kitamura et al. [26] present a more modern variation that uses octrees. Three recent algorithms with narrow phases that use subdivision techniques|the work of Smith et al. <ref> [44] </ref>, Garcia-Alonso et al. [14] and Ponamgi et al. [36]|deserve particular attention. Although their broad phases create the temporal inaccuracy discussed in Section 2, these algorithms have the advantage that they achieve real-time performance for some challenging situations. <p> Nine drone ships each used the 10,171-triangle truck geometry from Figure 13, and the user's ship used the lamp geometry. The total number of triangles was thus 92,165, which is more than ten times the number tested by Smith et al. <ref> [44] </ref>, the maximum in the literature for nonconvex objects. With this many triangles, rendering became the bottleneck on our hardware, taking more than 0.9 seconds at almost every frame.
Reference: [45] <author> John M. Snyder, Adam R. Woodbury, Kurt Fleischer, Bena Currin, and Alan H. Barr. </author> <title> Interval methods for multi-point collisions between time-dependent curved surfaces. </title> <booktitle> In Proceedings of SIGGRAPH '93, published as Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 321-334, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Von Herzen et al. [50] use Lipshitz conditions to accelerate a form of binary search through space and time. Duff [11] applies interval analysis to generalize the idea of recursive subdivision. Snyder et al. <ref> [45] </ref> combine interval analysis with the Newton-Raphson root-finding technique, providing the most accurate detection to date for collisions involving curved surfaces. All of these techniques assume knowledge of every object's exact position throughout simulation time.
Reference: [46] <author> William C. Thibault and Bruce F. Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <booktitle> In Proceedings of SIGGRAPH '87, published as Computer Graphics, </booktitle> <volume> 21(4) </volume> <pages> 153-162, </pages> <month> July </month> <year> 1987. </year> <month> 26 </month>
Reference-contexts: Section 11 makes a first step towards this goal by describing a comparison between the time-critical algorithm and one previous algorithm, an algorithm based on binary space partitioning (BSP) trees as described by Thibault and Naylor <ref> [46] </ref>. Another interesting comparison would involve one of the subdivision algorithms, for example, the work of Ponamgi et al [36]. This algorithm and the BSP algorithm both traverse trees, and the subdivision algorithm has the advantage that it can sometimes detect the absence of collisions before reaching the leaves. <p> 1 0.492 0.552 2 0.358 0.439 rocket 1 0.654 0.728 2 0.546 0.690 truck 1 0.571 0.671 2 0.389 0.450 11 Collision Detection Performance To see how well the time-critical detection algorithm exploits the sphere hierarchies, we tested its performance empirically, comparing it to an algorithm based on BSP trees <ref> [46] </ref>. These tests demonstrated that hierarchies built from medial-axis surfaces provide acceptable accuracy (improving on hierarchies built from octrees) and significant speedups.
Reference: [47] <author> Greg Turk. </author> <title> Interactive collision detection for molecular graphics. </title> <type> Technical Report TR90-014, </type> <institution> Department of Computer Science, The University of North Carolina at Chapel Hill, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Line 11 is the narrow phase, and it checks for exact intersections between individual pairs of objects whose simplified forms collide at time t d . For the broad phase, Turk <ref> [47] </ref> and Zyda et al. [52] use a regular grid to identify objects that are close to each other. Baraff [3] and Cohen et al. [9] describe sweep-and-prune techniques which exploit inter-frame coherence to efficiently sort bounding boxes, identifying those that intersect. <p> These faces may legitimately have zero area, in which case vertices coincide. In the algorithm from Section 8, it is convenient to treat a set of coincident vertices as one vertex that inherits the adjacency of the set. To identify coincident vertices, simple space subdivision <ref> [47] </ref> is helpful. Once adjacency is recorded, the medial-axis surface is sufficiently complete for the algorithm from Section 8. There is the possibility of aliasing problems in the medial-axis surface.
Reference: [48] <author> Greg Turk. </author> <title> Generating textures on arbitrary surfaces using reaction-diffusion. </title> <booktitle> In Proceedings of SIGGRAPH '91, published as Computer Graphics, </booktitle> <volume> 25(4) </volume> <pages> 289-298, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The number of points is a parameter set by the user. In our experience, the algorithm works better when P covers the polyhedron uniformly, and the simplest way to achieve this goal is to use Turk's point-placement algorithm <ref> [48] </ref>. It first creates a random distribution of points and then applies a relaxation technique to make the distribution even. The second step is building a Voronoi diagram for the points. The literature contains several 11 algorithms for 3D Voronoi diagrams.
Reference: [49] <author> Andries van Dam. </author> <title> VR as a forcing function: Software implications of a new paradigm. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <pages> pages 5-8, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Most interactive applications are thus forced to do without collision detection. The most promising way to make collision detection possible for more interactive applications is to use time-critical computing. The essence of this approach, which van Dam <ref> [49] </ref> also calls negotiated graceful degradation, is trading accuracy for speed. A time-critical detection algorithm checks for collisions between successively tighter approximations to the objects' real surfaces. After any step of this progressive refinement, the application can stop the algorithm if it exceeds its time budget.
Reference: [50] <author> Brian Von Herzen, Alan H. Barr, and Harold R. Zatz. </author> <title> Geometric collisions for time-dependent parametric surfaces. </title> <booktitle> In Proceedings of SIGGRAPH '90, published as Computer Graphics, </booktitle> <volume> 24(4) </volume> <pages> 39-48, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Canny [8] derives quintic polynomials whose roots represent the time and location of collisions. Cameron [7] extends the approach of Samet and Tamminen, adding a mechanism that prunes parts of objects that cannot collide. Von Herzen et al. <ref> [50] </ref> use Lipshitz conditions to accelerate a form of binary search through space and time. Duff [11] applies interval analysis to generalize the idea of recursive subdivision.
Reference: [51] <author> Ji-Hoon Youn and K. Wohn. </author> <title> Real-time collision detection for virtual reality applications. </title> <booktitle> In Proceedings of the IEEE Virtual Reality Annual International Symposium, </booktitle> <pages> pages 415-421, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Another class of algorithms builds a bounding hierarchy from the leaves up, with leaf spheres enclosing "primitive" pieces of an object. These algorithms require an appropriate set of primitives and a way to designate siblings at each hierarchy level. Youn and Wohn <ref> [51] </ref> and Rolhf and Helman [40] assume that the designer of an object addresses both of these issues by modeling the object as a hierarchy of pieces; these algorithms thus do not meet the requirement of producing hierarchies automatically.
Reference: [52] <author> Michael J. Zyda, William D. Osborne, James G. Monahan, and David R. Pratt. NPSNET: </author> <title> Real-time vehicle collisions, explosions and terrain modifications. </title> <journal> The Journal of Visualization and Computer Animation, </journal> <volume> 4(1) </volume> <pages> 13-24, </pages> <year> 1993. </year> <pages> 27 28 </pages>
Reference-contexts: Line 11 is the narrow phase, and it checks for exact intersections between individual pairs of objects whose simplified forms collide at time t d . For the broad phase, Turk [47] and Zyda et al. <ref> [52] </ref> use a regular grid to identify objects that are close to each other. Baraff [3] and Cohen et al. [9] describe sweep-and-prune techniques which exploit inter-frame coherence to efficiently sort bounding boxes, identifying those that intersect.
References-found: 52

