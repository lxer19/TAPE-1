URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/141.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: fjhr,rieckeg@research.att.com  
Title: Simple objects for Standard ML  
Author: John Reppy Jon Riecke 
Keyword: Word count: approx. 5300 words  
Note: (not including abstract, references, or appendix)  
Date: October 20, 1995  
Affiliation: AT&T Bell Laboratories.  
Abstract: This paper proposes a new approach to adding objects to the statically-typed, higher-order language Standard ML. Our approach sacrifices some of the expressiveness found in recently proposed schemes for typing object-oriented features, but by doing so, we avoid a tremendous amount of complexity in the type system. In fact, our system is a conservative extension of the SML type system, and preserves the important properties of SML: sound static typing, and type inference. Our approach is based on introducing object types, which have an explicitly declared subtyping hierarchy, and object constructors. Just as datatype constructors are used to guide type inference of recursive types, we use object type constructors to guide the inference of subtyping. The introduction of object constructors also has the effect of generalizing the SML case statement to be a typecase on object types. Using this mechanism, we can often recover type information that our type system cannot preserve statically. In addition to describing the features of OML, the paper includes examples of how features found in other object-oriented languages can be emulated in OML. It also discusses the formal properties of OML, and some of the implementation issues. Keywords: Programming language design, object-oriented programming, functional programming, Standard ML. 
Abstract-found: 1
Intro-found: 1
Reference: [AC95a] <author> Abadi, M. and L. Cardelli. </author> <title> An imperative object calculus. </title> <booktitle> In TAPSOFT'95: Theory and Practice of Software Development, number 915 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1995, </year> <pages> pp. 471485. </pages>
Reference-contexts: Typically, this is supported either by a delegation mechanism or a class mechanism. Abadi and Cardelli's object calculi support delegation via object cloning and method override operations <ref> [AC95a] </ref>. While we might have added such operations to OML, the associated typing restrictions are complicated and it may be the case that our type system is not powerful enough to make such operations useful. <p> This research has followed two different avenues: one avenue developed extensions of the -calculus that can encode objects (e.g., [Car84] and [Pie94]), and the other has developed calculi in which objects are a primitive notion (e.g., [Bru94] and <ref> [AC95a] </ref>). The most complete object-oriented type systems require resolving a fundamental conflict between subtyping (in which an object may be used in a context that expects a supertype of the object) and inheritance (in which definitions of objects may be reused to build new objects). <p> The dynamic semantics of our objects is influenced by Abadi and Cardelli's object calculi <ref> [AC95a] </ref>. Their system supports delegation via object cloning and method override operations [AC95a]. While we might have added such operations to OML, the associated typing restrictions are complicated and it may be the case that our type system is not powerful enough to make such operations useful. <p> The dynamic semantics of our objects is influenced by Abadi and Cardelli's object calculi <ref> [AC95a] </ref>. Their system supports delegation via object cloning and method override operations [AC95a]. While we might have added such operations to OML, the associated typing restrictions are complicated and it may be the case that our type system is not powerful enough to make such operations useful.
Reference: [AC95b] <author> Abadi, M. and L. Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> In ECOOP'95, </booktitle> <year> 1995. </year>
Reference-contexts: Nave type systems that identify the two concepts may have problems with type soundness (see [Coo89] for an example in early versions of Eiffel [Mey92]). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping <ref> [AC95b] </ref>, bounded polymorphism [CW85], higher-order and F-bounded polymor-phism [CCH + 89], existential types [PT93a], and matching [Bru94]. In many of these proposed systems, typechecking is not decidable. The problems with typechecking magnify in the context of type inference if one keeps the same goals.
Reference: [AM94] <author> Appel, A. W. and D. B. MacQueen. </author> <title> Separate compilation for Standard ML. </title> <booktitle> In Conference Record of the 1994 ACM Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 1323. </pages>
Reference-contexts: One important property is that type checking and compiling can proceed incrementally; it is not necessary to know the sub-types of an object type when compiling uses of the type. This means that interactive SML programming and separate compilation <ref> [AM94] </ref> are not affected by the addition of object types. SML allows type definitions, such as datatype declarations, to be parameterized. The list type definition on page 3 is one example of such a type constructor.
Reference: [App92] <institution> Apple Computer, </institution> <address> Cambridge, MA. </address> <booktitle> Dylan: An Object-oriented Dynamic Language, </booktitle> <year> 1992. </year>
Reference-contexts: Most object-oriented languages that have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS [Ste90], Dy-lan <ref> [App92] </ref>, Obliq [Car95], Self [US87], or Smalltalk [GR83]); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ [Str94], or Modula-3 [Nel91]). <p> Similar mechanisms can be found in CLOS [Ste90], C ++ [Str94], and Dylan <ref> [App92] </ref>. The extensible nature of object types is also useful for providing open implementations of heterogeneous collections. For example, we can define a base type of items: objtype item = ITEM of -| |- and implement operations over various collections of items.
Reference: [Bru94] <author> Bruce, K. B. </author> <title> A paradigmatic object-oriented language: design, static typing, and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2), </volume> <year> 1994, </year> <pages> pp. 127206. </pages>
Reference-contexts: This research has followed two different avenues: one avenue developed extensions of the -calculus that can encode objects (e.g., [Car84] and [Pie94]), and the other has developed calculi in which objects are a primitive notion (e.g., <ref> [Bru94] </ref> and [AC95a]). The most complete object-oriented type systems require resolving a fundamental conflict between subtyping (in which an object may be used in a context that expects a supertype of the object) and inheritance (in which definitions of objects may be reused to build new objects). <p> the two concepts may have problems with type soundness (see [Coo89] for an example in early versions of Eiffel [Mey92]). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping [AC95b], bounded polymorphism [CW85], higher-order and F-bounded polymor-phism [CCH + 89], existential types [PT93a], and matching <ref> [Bru94] </ref>. In many of these proposed systems, typechecking is not decidable. The problems with typechecking magnify in the context of type inference if one keeps the same goals.
Reference: [Car84] <author> Cardelli, L. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> vol. 173 of Lecture Notes in Computer Science, </booktitle> <address> New York, N.Y., 1984. </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 5167. </pages>
Reference-contexts: This research has followed two different avenues: one avenue developed extensions of the -calculus that can encode objects (e.g., <ref> [Car84] </ref> and [Pie94]), and the other has developed calculi in which objects are a primitive notion (e.g., [Bru94] and [AC95a]).
Reference: [Car95] <author> Cardelli, L. </author> <title> A language with distributed scope. </title> <booktitle> In Conference Record of the 22th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995, </year> <pages> pp. 286297. </pages>
Reference-contexts: Most object-oriented languages that have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS [Ste90], Dy-lan [App92], Obliq <ref> [Car95] </ref>, Self [US87], or Smalltalk [GR83]); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ [Str94], or Modula-3 [Nel91]).
Reference: [CCH + 89] <author> Canning, P., W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Conference Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture. ACM, </booktitle> <year> 1989, </year> <pages> pp. 273280. </pages>
Reference-contexts: Nave type systems that identify the two concepts may have problems with type soundness (see [Coo89] for an example in early versions of Eiffel [Mey92]). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping [AC95b], bounded polymorphism [CW85], higher-order and F-bounded polymor-phism <ref> [CCH + 89] </ref>, existential types [PT93a], and matching [Bru94]. In many of these proposed systems, typechecking is not decidable. The problems with typechecking magnify in the context of type inference if one keeps the same goals.
Reference: [Coo89] <author> Cook, W. R. </author> <title> A proposal for making Eiffel type-safe. </title> <booktitle> In European Conference on Object-Oriented Programming, </booktitle> <year> 1989, </year> <pages> pp. 5772. </pages>
Reference-contexts: Nave type systems that identify the two concepts may have problems with type soundness (see <ref> [Coo89] </ref> for an example in early versions of Eiffel [Mey92]). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping [AC95b], bounded polymorphism [CW85], higher-order and F-bounded polymor-phism [CCH + 89], existential types [PT93a], and matching [Bru94].
Reference: [CW85] <author> Cardelli, L. and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <year> 1985, </year> <pages> pp. 471522. </pages>
Reference-contexts: Nave type systems that identify the two concepts may have problems with type soundness (see [Coo89] for an example in early versions of Eiffel [Mey92]). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping [AC95b], bounded polymorphism <ref> [CW85] </ref>, higher-order and F-bounded polymor-phism [CCH + 89], existential types [PT93a], and matching [Bru94]. In many of these proposed systems, typechecking is not decidable. The problems with typechecking magnify in the context of type inference if one keeps the same goals.
Reference: [DM82] <author> Damas, L. and R. Milner. </author> <title> Principal types for functional programs. </title> <booktitle> In Conference Record of the 9th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1982, </year> <pages> pp. </pages> <year> 207212. </year>
Reference-contexts: We leave the discussion of methods and self to the next section. Our approach to adding object types to SML is guided by an examination of how SML supports recursive types. The SML type system is based on the Damas-Milner type inference system <ref> [DM82] </ref>, which defines a structural view of type equivalence (i.e., two types are equal if they have the same structure). One can extend this structural view to handle recursive types.
Reference: [EST95] <author> Eifrig, J., S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In OOP-SLA'95 Proceedings. ACM, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Existing type inference engines either solve a recursive set of constraints about types [Pal94], or collect a set of recursive constraints about types and report them to the programmer <ref> [EST95] </ref>. Neither solution is simple: it may require substantial insight on the part of the programmer to determine where a type error has occurred, as it is often not obvious when the recursive constraints have a solution.
Reference: [FF86] <author> Felleisen, M. and D. P. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. </title> <editor> In M. Wirsing (ed.), </editor> <booktitle> Formal Description of Programming Concepts III, </booktitle> <pages> pp. </pages> <address> 193219. </address> <publisher> North-Holland, </publisher> <address> New York, N.Y., </address> <year> 1986. </year>
Reference: [FM94] <author> Fisher, K. and J. C. Mitchell. </author> <booktitle> Notes on typed object-oriented programming. In TACS'94: Theoretical Aspects of Computer Science, number 789 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994, </year> <pages> pp. 844885. </pages>
Reference-contexts: Because of this, the attempts to account for object-oriented features in higher-order statically-typed languages have required substantial type-theoretic machinery and complex type systems (see <ref> [FM94] </ref> for a review of the issues). Furthermore, in some cases type-checking is undecidable, and for most others, type inference seems out of the question.
Reference: [GR83] <author> Goldberg, A. and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1983. </year> <month> 14 </month>
Reference-contexts: Most object-oriented languages that have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS [Ste90], Dy-lan [App92], Obliq [Car95], Self [US87], or Smalltalk <ref> [GR83] </ref>); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ [Str94], or Modula-3 [Nel91]).
Reference: [GR93] <author> Gansner, E. R. and J. H. Reppy. </author> <title> A Multi-threaded Higher-order User Interface Toolkit, </title> <booktitle> vol. 1 of Software Trends, </booktitle> <pages> pp. 6180. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: Unfortunately, SML does not provide primitives for object-oriented programming. In particular, there is no support for subtyping or for working with heterogeneous collections. Programmers must use explicit coercions to implement subtyping (for example, see <ref> [GR93] </ref>), and used tagged unions to implement heterogeneous collections. This paper describes, Object ML (OML), which is a simple extension to SML to support object-oriented programming. In designing OML, we have focused on minimizing the disruption to the SML type system, even at the cost of expressiveness.
Reference: [JM88] <author> Jategaonkar, L. and J. C. Mitchell. </author> <title> ML with extended pattern matching and subtypes. </title> <booktitle> In Conference Record of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <month> July </month> <year> 1988, </year> <pages> pp. </pages> <year> 198211. </year>
Reference-contexts: Subsequently, this has been extended to handle object-oriented features. The first extension is simple record subtyping: a record type with more fields is a subtype of a record type with fewer fields. Record subtyping requires a rather substantial change to the type inference system (for example, see <ref> [JM88] </ref>, [Rem94], or [Wan87]). But record subtyping alone is not powerful enough to encode full objects: one requires some form of recursive type, since the types of methods should be able to return objects of the type itself (possibly through self).
Reference: [Mey92] <author> Meyer, B. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: Nave type systems that identify the two concepts may have problems with type soundness (see [Coo89] for an example in early versions of Eiffel <ref> [Mey92] </ref>). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping [AC95b], bounded polymorphism [CW85], higher-order and F-bounded polymor-phism [CCH + 89], existential types [PT93a], and matching [Bru94]. In many of these proposed systems, typechecking is not decidable.
Reference: [Mit84] <author> Mitchell, J. C. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Conference Record of the 11th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1984, </year> <pages> pp. 175 185. </pages>
Reference-contexts: Since a term with a run-time type error cannot be reduced under the reduction rules, both properties imply that well-typed programs do not cause run-time type errors. The third technical result relates the typechecking rules to a type inference algorithm. The algorithm, a modification of the one found in <ref> [Mit84] </ref>, itself relies on a modification of the standard unification algorithm: one finds most general unifiers subject to a set of atomic subtyping constraints. The algorithm finds a principal type (or most general type) for an expression. The interested reader may find the formal statement in the Appendix. <p> We have made a fundamental tradeoff in the design of OML to simplify the type system: the algorithm for OML deduces types with bounded quantification, whereas the algorithm for OML uses simple subtyping. In fact, a rather old example due to Mitchell <ref> [Mit84] </ref> shows that type inference in OML can not produce a principal type in some cases: The code fn p =&gt; case (p, PT$x p) of (x, _) =&gt; x has the type 8 ff pt:ff ! ff in OML- -. <p> In many of these proposed systems, typechecking is not decidable. The problems with typechecking magnify in the context of type inference if one keeps the same goals. Mitchell's seminal work on subtyping and type inference describes an algorithm and type rules for predeclared, fixed subtyping hierarchies <ref> [Mit84] </ref>; this system forms the basis of our OML calculus. Subsequently, this has been extended to handle object-oriented features. The first extension is simple record subtyping: a record type with more fields is a subtype of a record type with fewer fields.
Reference: [MTH90] <author> Milner, R., M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction The higher-order language Standard ML (SML) <ref> [MTH90] </ref> provides a powerful collection of tools to the programmer: higher-order functions, polymorphism, and parameterized modules provide support for code reuse and abstraction; while datatypes and pattern matching support concise specifications of data structures and organization of programs by case analysis. Unfortunately, SML does not provide primitives for object-oriented programming. <p> The typechecking rules and operational semantics are easier to state in this reduced language, and the extension to full OML follows the design of SML <ref> [MTH90] </ref>. We will come back to the relationship between OML and OML in a moment, and first consider three theoretical properties of OML- -. The two first technical result shows that complete, well-typed OML programs do not produce run-time type errors.
Reference: [Nel91] <author> Nelson, G. (ed.). </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1991. </year>
Reference-contexts: have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS [Ste90], Dy-lan [App92], Obliq [Car95], Self [US87], or Smalltalk [GR83]); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ [Str94], or Modula-3 <ref> [Nel91] </ref>). The goal of the research in type systems for object-oriented languages is to account for as much of the behavior of the dynamically typed languages as possible in a statically typed framework. <p> Pattern matching on object constructors provides a form of typecase on objects, similar to that found in Modula-3 <ref> [Nel91] </ref>. For example consider the following expression: case pt of CPT1-|...|- =&gt; print "color point"n" | PT1-|...|- =&gt; print "point"n" If pt is a cpoint1 (or some subtype of cpoint1), then the first case is matched. Otherwise the second case is matched (for example, if pt is a point2).
Reference: [Pal94] <author> Palsberg, J. </author> <title> Efficient inference of object types. </title> <booktitle> In Proceedings, Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1994, </year> <pages> pp. 186195. </pages>
Reference-contexts: Existing type inference engines either solve a recursive set of constraints about types <ref> [Pal94] </ref>, or collect a set of recursive constraints about types and report them to the programmer [EST95].
Reference: [Pie94] <author> Pierce, B. </author> <title> Bounded quantification is undecidable. </title> <editor> In C. A. Gunter and J. C. Mitchell (eds.), </editor> <booktitle> Theoretical Aspects Of Object-Oriented Programming. Types, Semantics and Language Design, </booktitle> <pages> pp. 427459. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This research has followed two different avenues: one avenue developed extensions of the -calculus that can encode objects (e.g., [Car84] and <ref> [Pie94] </ref>), and the other has developed calculi in which objects are a primitive notion (e.g., [Bru94] and [AC95a]).
Reference: [Plo81] <author> Plotkin, G. D. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus Univ., Computer Science Dept., Denmark, </institution> <year> 1981. </year>
Reference: [PT93a] <author> Pierce, B. C. and D. N. Turner. </author> <title> Object-oriented programming without recursive types. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993, </year> <pages> pp. 299312. </pages>
Reference-contexts: systems that identify the two concepts may have problems with type soundness (see [Coo89] for an example in early versions of Eiffel [Mey92]). 12 To avoid the problem, typed languages have used substantial type-theoretic machinery: higher--order subtyping [AC95b], bounded polymorphism [CW85], higher-order and F-bounded polymor-phism [CCH + 89], existential types <ref> [PT93a] </ref>, and matching [Bru94]. In many of these proposed systems, typechecking is not decidable. The problems with typechecking magnify in the context of type inference if one keeps the same goals.
Reference: [PT93b] <author> Pierce, B. C. and D. N. Turner. </author> <title> Statically typed friendly functions via partially abstract types. </title> <type> Technical Report ECS-LFCS-93-256, </type> <institution> University of Edinburgh, LFCS, </institution> <month> April </month> <year> 1993. </year> <note> Also available as INRIA-Rocquencourt Rapport de Recherche No. 1899. </note>
Reference-contexts: Following Pierce and Turner <ref> [PT93b] </ref>, we can use partially abstract object types to implement a form of friend functions. The basic idea is that we define a base object type that contains the public operations, and a derived type that extends the public interface with private members.
Reference: [Rem94] <author> Remy, D. </author> <title> Type inference for records in a natural extension of ML. </title> <editor> In C. A. Gunter and J. C. Mitchell (eds.), </editor> <booktitle> Theoretical Aspects Of Object-Oriented Programming. Types, Semantics and Language Design, </booktitle> <pages> pp. 6795. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year> <note> Also available as Research Report 1431, </note> <month> May </month> <year> 1991, </year> <institution> INRIA-Rocquencourt, France. </institution>
Reference-contexts: Subsequently, this has been extended to handle object-oriented features. The first extension is simple record subtyping: a record type with more fields is a subtype of a record type with fewer fields. Record subtyping requires a rather substantial change to the type inference system (for example, see [JM88], <ref> [Rem94] </ref>, or [Wan87]). But record subtyping alone is not powerful enough to encode full objects: one requires some form of recursive type, since the types of methods should be able to return objects of the type itself (possibly through self).
Reference: [RR] <author> Reppy, J. H. and J. G. Riecke. </author> <title> Simple object types for SML. </title> <note> In preparation. </note>
Reference-contexts: Our technical report describes the theoretical foundations of OML <ref> [RR] </ref>, but the interested reader may consult the Appendix for an overview. We illustrate the formal properties via a language called OML -, a version of OML without re-als, strings, pairs, lists, and other basic data types, and without side effects and recursive functions.
Reference: [Sha94] <author> Shao, Z. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> Ph.D. dissertation, </type> <institution> Princeton University, Department of Computer Science, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Furthermore, the compiler may need to treat method functions specially to avoid the problems with the standard closure representation, although recent improvements in compiler techniques for SML may make this unnecessary <ref> [Sha94] </ref>. 9 Related work Over the past decade, many researchers have attempted to bridge the gap between the practice of dynamically typed object-oriented programming and the desire for static typechecking.
Reference: [Sol78] <author> Solomon, M. </author> <title> Type definitions with parameters. </title> <booktitle> In Conference Record of the 5th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1978, </year> <pages> pp. 3138. </pages>
Reference-contexts: Unfortunately, we encounter problems if we extend this to recursive type constructors (e.g., ff list), because there is no known algorithm for determining type equality in such a setting <ref> [Sol78] </ref>, and type equality is at the core of the Damas-Milner type inference system. SML follows a different approach and introduces datatype definitions, where each definition defines a new unique type.
Reference: [Ste90] <author> Steele, Jr., G. L. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Lastly, the new constructs in OML have efficient constant-time implementations; there are no hidden costs, such as dynamic searching for methods. Most object-oriented languages that have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS <ref> [Ste90] </ref>, Dy-lan [App92], Obliq [Car95], Self [US87], or Smalltalk [GR83]); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ [Str94], or Modula-3 [Nel91]). <p> Similar mechanisms can be found in CLOS <ref> [Ste90] </ref>, C ++ [Str94], and Dylan [App92]. The extensible nature of object types is also useful for providing open implementations of heterogeneous collections. For example, we can define a base type of items: objtype item = ITEM of -| |- and implement operations over various collections of items.
Reference: [Str94] <author> Stroustrup, B. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1994. </year>
Reference-contexts: object-oriented languages that have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS [Ste90], Dy-lan [App92], Obliq [Car95], Self [US87], or Smalltalk [GR83]); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ <ref> [Str94] </ref>, or Modula-3 [Nel91]). The goal of the research in type systems for object-oriented languages is to account for as much of the behavior of the dynamically typed languages as possible in a statically typed framework. <p> Similar mechanisms can be found in CLOS [Ste90], C ++ <ref> [Str94] </ref>, and Dylan [App92]. The extensible nature of object types is also useful for providing open implementations of heterogeneous collections. For example, we can define a base type of items: objtype item = ITEM of -| |- and implement operations over various collections of items. <p> that this technique can also be used to implement multi-methods methods that dispatch on the type of more than one argument. 5.3 Friend functions Another concept that is related to binary methods are C ++ friend functions, which are functions that have access to the private members of an object <ref> [Str94] </ref>. Following Pierce and Turner [PT93b], we can use partially abstract object types to implement a form of friend functions. The basic idea is that we define a base object type that contains the public operations, and a derived type that extends the public interface with private members.
Reference: [US87] <author> Ungar, D. and R. B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In OOPSLA'87 Proceedings, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 227242. </pages>
Reference-contexts: Most object-oriented languages that have widespread use fall into one of two camps: either they are dynamically typed, and support very flexible uses of objects (e.g., CLOS [Ste90], Dy-lan [App92], Obliq [Car95], Self <ref> [US87] </ref>, or Smalltalk [GR83]); or they are first-order languages with fairly restrictive static type systems (e.g., C ++ [Str94], or Modula-3 [Nel91]).
Reference: [Wan87] <author> Wand, M. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings, Symposium on Logic in Computer Science. IEEE, </booktitle> <year> 1987, </year> <pages> pp. 3744. </pages> <booktitle> Corrigendum in Proceedings, Symposium on Logic in Computer Science, </booktitle> <pages> page 132. </pages> <publisher> IEEE, </publisher> <year> 1988. </year> <month> 15 </month>
Reference-contexts: The first extension is simple record subtyping: a record type with more fields is a subtype of a record type with fewer fields. Record subtyping requires a rather substantial change to the type inference system (for example, see [JM88], [Rem94], or <ref> [Wan87] </ref>). But record subtyping alone is not powerful enough to encode full objects: one requires some form of recursive type, since the types of methods should be able to return objects of the type itself (possibly through self).
References-found: 34

