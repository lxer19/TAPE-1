URL: http://www.cs.bu.edu/techreports/98-008-quant.ps.Z
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Title: Determining Acceptance Possibility for a Quantum Computation is Hard for PH  
Author: Stephen Fenner Frederic Green Clark University Steven Homer Randall Pruim 
Date: November 14, 1997  
Address: Calvin College  
Affiliation: University of Southern Maine  Boston University  Boston University  
Abstract: It is shown that determining whether a quantum computation has a nonzero probability of accepting is at least as hard as the polynomial time hierarchy. This hardness result also applies to determining in general whether a given quantum basis state appears with nonzero amplitude in a superposition, or whether a given quantum bit has positive expectation value at the end of a quantum computation.
Abstract-found: 1
Intro-found: 1
Reference: [ADH97] <author> L. Adelman, J. DeMarrais, and M. Huang. </author> <title> Quantum computability. </title> <journal> sicom, </journal> <volume> 26 </volume> <pages> 1524-1540, </pages> <year> 1997. </year>
Reference: [BB92] <author> Andre Berthiaume and Gilles Brassard. </author> <title> The quantum challenge to struc-tural complexity theory. </title> <booktitle> In Proceedings of the 7th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 132-137. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: While the main research focus has been on finding efficient quantum algorithms for hard problems, attention has also been paid to determining the strength of quantum computation vis-a-vis its classical (probabilistic) counterpart <ref> [BB92] </ref>. In this paper we take a further step in this direction by proving that testing for nonzero acceptance probability of a quantum machine is classically an extremely hard problem.
Reference: [BBBV] <author> C.H. Bennet, E. Bernstein, G. Brassard, and U. Vazirani. </author> <title> Strengths and weaknesses of quantum computation. </title> <type> Manuscript. </type>
Reference-contexts: By analogy, one might have hoped QAP would be significantly easier than the problem of determining the exact accepting probability of a quantum computation, and possibly even to locate QAP within the polynomial hierarchy. Our work shows that this is not the case. Work of Bennet et al. <ref> [BBBV] </ref> and recently of Fortnow and Rogers [FR97] has suggested that quantum computation with bounded error probability (BQP) is most likely unable to solve NP-hard problems. Combined with our result, this implies that BQP is even less likely than PH to contain QAP .
Reference: [Ben82] <author> P.A. Benioff. </author> <title> Quantum mechanical hamiltonian models of turing ma-chines. </title> <journal> Journal of Statistical Physics, </journal> <volume> 29 </volume> <pages> 515-546, </pages> <year> 1982. </year>
Reference-contexts: Thus Q scanning the first m bits of the tape t corresponds to the global transition jx; ~ 0; 0i 7! 2 m=2 ~y Q then simulates the deterministic computation of L (x; ~y) in a reversible manner, using other work tapes <ref> [Deu85, Ben82] </ref>. 1 Let b ~y be the one-bit result of the 1 This computation is also done obliviously so that the internal state and tape head position of the machine is the same for all components of the superposition at any given time.
Reference: [Ber97] <author> Andre Berthiaume. </author> <title> Quantum computation. </title> <editor> In L. Hemaspaandra and A. L. Selman, editors, </editor> <title> Complexity Theory Retrospective II, </title> <booktitle> chapter 2, </booktitle> <pages> pages 23-50. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Our development is based on Turing machines, but can just as easily be based on quantum circuits [Deu85], which are polynomially equivalent to quantum Turing machines [Yao93]. See the references for more details regarding the models used here (e.g., [Sim94]) as well as equivalent formulations (e.g., <ref> [Ber97] </ref>). A classical probabilistic computation can be viewed as a tree. Each node in the tree is labeled with a configuration (instantaneous description of tape contents, head location and internal state) of the Turing Machine.
Reference: [Deu85] <author> D. Deutsch. </author> <booktitle> Quantum theory. In Proceedings of the Royal Society of London, </booktitle> <pages> pages 97-117, </pages> <year> 1985. </year>
Reference-contexts: Those who are already familiar with quantum models of computation can skip the rest of this section. Our development is based on Turing machines, but can just as easily be based on quantum circuits <ref> [Deu85] </ref>, which are polynomially equivalent to quantum Turing machines [Yao93]. See the references for more details regarding the models used here (e.g., [Sim94]) as well as equivalent formulations (e.g., [Ber97]). A classical probabilistic computation can be viewed as a tree. <p> Thus Q scanning the first m bits of the tape t corresponds to the global transition jx; ~ 0; 0i 7! 2 m=2 ~y Q then simulates the deterministic computation of L (x; ~y) in a reversible manner, using other work tapes <ref> [Deu85, Ben82] </ref>. 1 Let b ~y be the one-bit result of the 1 This computation is also done obliviously so that the internal state and tape head position of the machine is the same for all components of the superposition at any given time.
Reference: [DJ92] <author> D. Deutsch and R. Jozsa. </author> <title> Rapid solutions of problems by quantum com-putation. </title> <booktitle> In Proceedings of the Royal Society of London, </booktitle> <pages> pages 553-558, </pages> <year> 1992. </year>
Reference-contexts: Proof Sketch: Our proof directly uses techniques of Simon [Sim94] and Deutsch and Jozsa <ref> [DJ92] </ref>. Let k 2 N and let L fl be a set in P such that for all x of length n, f (x) = " L x j j n k 2 Fix an input x of length n and let m = n k . <p> j0i 7! p (j0i + j1i) 1 2 In general, scanning an arbitrary state jx; ~y; bi in this way yields jx; ~y; bi 7! 2 m=2 ~y 0 jx; ~y 0 ; bi; where ~y ~y 0 is the dot product of the bit vectors ~y and ~y 0 <ref> [DJ92, Sim94] </ref>.
Reference: [FFK94] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48(1) </volume> <pages> 116-148, </pages> <year> 1994. </year> <note> An ear-lier version appeared in Proceedings of the 6th Annual IEEE Structure in Complexity Theory Conference, </note> <year> 1991, </year> <pages> pp. 30-42. </pages>
Reference-contexts: let L x = fy 2 fl j hx; yi 2 Lg A function f : f0; 1g fl ! Z is in GapP if there is a language L in P and an integer k such that f (x) = " L x j j n k 2 See <ref> [FFK94] </ref> for more information about the intuition behind this definition and the basic properties of the class GapP. Now we are ready to prove the technical theorem on which Theorem 1.1 rests.
Reference: [FR97] <author> Lance Fortnow and John Rogers. </author> <title> Complexity limitations on quantum computation. </title> <type> Unpublished manuscript, </type> <year> 1997. </year>
Reference-contexts: Our work shows that this is not the case. Work of Bennet et al. [BBBV] and recently of Fortnow and Rogers <ref> [FR97] </ref> has suggested that quantum computation with bounded error probability (BQP) is most likely unable to solve NP-hard problems. Combined with our result, this implies that BQP is even less likely than PH to contain QAP . <p> Thus jx; ~ 0; 1i is the unique accepting configuration of Q, and it has probability amplitude p 1 which implies the theorem by setting p (n) = 2m 1 = 2n k 1. A converse to Theorem 3.2 directly follows from work of Fortnow and Rogers <ref> [FR97] </ref>. <p> Corollary 3.6 QAP is hard for PH under randomized reductions. Hence if QAP is anywhere in PH, then PH collapses; in fact, the counting hierarchy 2 also collapses. Combining our results with those of Fortnow and Rogers <ref> [FR97] </ref>, we find that QAP 2 BQP also implies the collapse of the counting hierarchy. 4 Conclusion One may ask if a polynomial-time nondeterministic Turing machine has a non-zero acceptance probability. This problem exactly characterizes the class NP.
Reference: [Sho94] <author> Peter W. Shor. </author> <title> Algorithms for quantum computation: Discrete loga-rithms and factoring. </title> <booktitle> In Proceedings of the 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 124-134. </pages> <publisher> IEEE, </publisher> <year> 1994. </year> <month> 9 </month>
Reference-contexts: E-mail: homer@cs.bu.edu. Supported in part by the NSF under grant NSF-CCR-9400229. x Computer Science Department, Boston University, Boston, MA 02215. E-mail: rpruim@calvin.edu. On leave from Department of Mathematics and Statistics, Calvin College, Grand Rapids, MI 49546. 1 discrete logarithm and integer factoring on both a quantum Turing machine <ref> [Sho94] </ref> and (equivalently) quantum circuits [Sho97]. This opens the possibility that if such machines can be constructed, or effectively simulated, then one can rapidly factor large integers and compromise a good deal of modern cryptography.
Reference: [Sho97] <author> Peter W. Shor. </author> <title> Polynomial-time algorithms for prime number factoriza--tion and discrete logarithms on a quantum computer. </title> <journal> SIAM J. Comp., </journal> <volume> 26 </volume> <pages> 1484-1509, </pages> <year> 1997. </year>
Reference-contexts: E-mail: rpruim@calvin.edu. On leave from Department of Mathematics and Statistics, Calvin College, Grand Rapids, MI 49546. 1 discrete logarithm and integer factoring on both a quantum Turing machine [Sho94] and (equivalently) quantum circuits <ref> [Sho97] </ref>. This opens the possibility that if such machines can be constructed, or effectively simulated, then one can rapidly factor large integers and compromise a good deal of modern cryptography.
Reference: [Sim94] <editor> D. Simon. </editor> <booktitle> On the power of quantum computation. In Proceedings of the 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 124-134. </pages> <publisher> IEEE, </publisher> <year> 1994. </year>
Reference-contexts: Our development is based on Turing machines, but can just as easily be based on quantum circuits [Deu85], which are polynomially equivalent to quantum Turing machines [Yao93]. See the references for more details regarding the models used here (e.g., <ref> [Sim94] </ref>) as well as equivalent formulations (e.g., [Ber97]). A classical probabilistic computation can be viewed as a tree. Each node in the tree is labeled with a configuration (instantaneous description of tape contents, head location and internal state) of the Turing Machine. <p> Proof Sketch: Our proof directly uses techniques of Simon <ref> [Sim94] </ref> and Deutsch and Jozsa [DJ92]. <p> j0i 7! p (j0i + j1i) 1 2 In general, scanning an arbitrary state jx; ~y; bi in this way yields jx; ~y; bi 7! 2 m=2 ~y 0 jx; ~y 0 ; bi; where ~y ~y 0 is the dot product of the bit vectors ~y and ~y 0 <ref> [DJ92, Sim94] </ref>.
Reference: [SY96] <author> R. Solovay and A. Yao. </author> <type> Manuscript., </type> <year> 1996. </year>
Reference: [Tar93] <author> J. Tarui. </author> <title> Probabilistic polynomials, AC (0) functions and the polynomialtime hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 113 </volume> <pages> 167-183, </pages> <year> 1993. </year>
Reference-contexts: Corollary 3.5 shows that there is a quantum machine that takes two graphs as input and accepts with probability zero iff the two graphs are isomorphic. It is known that C = P is hard for the polynomial hierarchy under randomized reductions <ref> [TO92, Tar93] </ref>. Corollary 3.6 QAP is hard for PH under randomized reductions. Hence if QAP is anywhere in PH, then PH collapses; in fact, the counting hierarchy 2 also collapses.
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: In fact, we prove that this problem, which we call QAP ("quantum acceptance possibility") is hard for the polynomial-time hierarchy, by showing that QAP is equivalent to the problem of exact counting [Wag86a]. Exact counting, in turn, is hard for PH under randomized reductions <ref> [Tod91, TO92] </ref>, and may still be hard even if P = NP. Our main result is Theorem 1.1 The problem of determining if the acceptance probability of a quantum computation is non-zero (QAP ) is hard for the polynomial time hierarchy under polynomial-time randomized reductions. <p> Corollary 3.5 shows that there is a quantum machine that takes two graphs as input and accepts with probability zero iff the two graphs are isomorphic. It is known that C = P is hard for the polynomial hierarchy under randomized reductions <ref> [TO92, Tar93] </ref>. Corollary 3.6 QAP is hard for PH under randomized reductions. Hence if QAP is anywhere in PH, then PH collapses; in fact, the counting hierarchy 2 also collapses.
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: In fact, we prove that this problem, which we call QAP ("quantum acceptance possibility") is hard for the polynomial-time hierarchy, by showing that QAP is equivalent to the problem of exact counting [Wag86a]. Exact counting, in turn, is hard for PH under randomized reductions <ref> [Tod91, TO92] </ref>, and may still be hard even if P = NP. Our main result is Theorem 1.1 The problem of determining if the acceptance probability of a quantum computation is non-zero (QAP ) is hard for the polynomial time hierarchy under polynomial-time randomized reductions.
Reference: [Wag86a] <author> K. Wagner. </author> <title> Compact descriptions and the counting polynomial time hierarchy. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year>
Reference-contexts: In fact, we prove that this problem, which we call QAP ("quantum acceptance possibility") is hard for the polynomial-time hierarchy, by showing that QAP is equivalent to the problem of exact counting <ref> [Wag86a] </ref>. Exact counting, in turn, is hard for PH under randomized reductions [Tod91, TO92], and may still be hard even if P = NP.
Reference: [Wag86b] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year>
Reference-contexts: See <ref> [Wag86b] </ref> for a definition. 8 Also, we found here that if QAP 2 BQP, then the counting hierarchy collapses to PP. It would be interesting to see if it collapses even further (say, to BQP). This would give us a better understanding of how much harder QAP is than BQP.
Reference: [Yao93] <author> A.C.-C. Yao. </author> <title> Quantum circuit complexity. </title> <booktitle> In Proceedings of the 34th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 352-361, </pages> <year> 1993. </year>
Reference-contexts: Those who are already familiar with quantum models of computation can skip the rest of this section. Our development is based on Turing machines, but can just as easily be based on quantum circuits [Deu85], which are polynomially equivalent to quantum Turing machines <ref> [Yao93] </ref>. See the references for more details regarding the models used here (e.g., [Sim94]) as well as equivalent formulations (e.g., [Ber97]). A classical probabilistic computation can be viewed as a tree.
References-found: 19

