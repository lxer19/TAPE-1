URL: ftp://theory.lcs.mit.edu/pub/people/oded/ggl.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/cryptography.html
Root-URL: 
Title: Fault-tolerant Computation in the Full Information Model  
Author: Oded Goldreich Shafi Goldwasser Nathan Linial 
Address: Rehovot, Israel.  Cambridge, USA.  Jerusalem, Israel.  
Affiliation: Department of Computer Science and Applied Mathematics, Weizmann Institute of Science,  Laboratory for Computer Science, MIT,  Institute of Computer Science, Hebrew University,  
Note: Supported by grants No. 89-00312, 89-00126 and 92-00226 from the United States Israel Binational Science Foundation (BSF), Jerusalem, Israel. An extended abstract of this work has appeared in the proceedings of the 32nd FOCS, pp. 447-457, 1991.  
Date: October 18, 1995  
Abstract: We initiate an investigation of general fault-tolerant distributed computation in the full-information model. In the full information model no restrictions are made on the computational power of the faulty parties or the information available to them. (Namely, the faulty players may be infinitely powerful and there are no private channels connecting pairs of honest players). Previous work, in this model, has concentrated on the particular problem of simulating a single bounded-bias global coin flip (e.g. Ben-Or and Linial [4] and Alon and Naor [1]). We widen the scope of investigation to the general question of how well arbitrary fault-tolerant computations can be performed in this model. The results we obtain should be considered as first steps in this direction. We present efficient two-party protocols for fault-tolerant computation of any bivariate function. We prove that the advantage of dishonest player in these protocols is the minimum one possible (up to polylogarithmic factors). We also present efficient m-party fault-tolerant protocols for sampling a general distribution (m 2). Such an algorithm seems an important building block towards the design of efficient multi-party protocols for fault-tolerant computation of multivariate functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alon N., and M. Naor, </author> <title> "Coin-flipping games immune against linear-sized coalitions", </title> <journal> SIAM J. on Computing, </journal> <note> to appear. Extended abstract in Proc. of 31st FOCS. </note>
Reference-contexts: Previous Work in the Full Information Model Collective coin flipping, i.e., common bounded-biased sampling in f0; 1g has been considered in this full-information model before <ref> [4, 5, 16, 1] </ref>. Matching lower and (constructive) upper bounds of 1 m ) have been shown (by Ben-Or and Linial [4] and Alon and Naor [1], 2 respectively). <p> Matching lower and (constructive) upper bounds of 1 m ) have been shown (by Ben-Or and Linial [4] and Alon and Naor <ref> [1] </ref>, 2 respectively). Our work can be viewed as an extension of these investigations which were concerned with the influences of players on Boolean functions (i.e., Range (f ) = f0; 1g). The general case, considered in this paper, gives rise to additional difficulties. <p> In "sampling" we mean producing a single string in f0; 1g l so that, for every subset S f0; 1g l , the probability that the sample hits S is related to the density of S. Our protocol uses the collective coin flipping of <ref> [1] </ref> as a subroutine. In fact, our sampling protocol can be viewed as a deterministic reduction to the problem of collective coin tossing. The collective coin can be viewed as a slightly random source in the sense of Santha and Vazirani [22], i.e., an SV-source 4 . <p> outcome to be in S with probability at least 1 , by biasing each coin-flip towards 1. 2 Furthermore, the upper bound can be met by protocols of logarithmic round-complexity [9, 19]. 3 An alternative method which also fails is to try to generalize the work of Alon and Naor <ref> [1] </ref> as follows: the method of [1] consists of randomly selecting one of the players who is appointed to flip a fair coin. <p> probability at least 1 , by biasing each coin-flip towards 1. 2 Furthermore, the upper bound can be met by protocols of logarithmic round-complexity [9, 19]. 3 An alternative method which also fails is to try to generalize the work of Alon and Naor <ref> [1] </ref> as follows: the method of [1] consists of randomly selecting one of the players who is appointed to flip a fair coin. Letting this player select a random string is a natural idea, but it is obvious that this approach performs very poorly for a sample space of non-constant size. <p> Specifically, the protocol proceeds in l rounds. In each round, the m parties first select at random (using a simpler sampling protocol) a poly (n m)-degree polynomial specifying a partition of the residual sample space, and next use the collective-coin tossing protocol of Alon and Naor <ref> [1] </ref> to choose one side of this partition. The sampling protocol used to choose poly (nm)- degree polynomials is similar except that the partitions are specified by linear transformations (as in the protocol of Proposition 21). <p> These linear transformations are selected using a trivial sampling protocol which consists of selecting each bit individually by the collective-coin tossing protocol of Alon and Naor <ref> [1] </ref>. We prefer an alternative presentation of our proof, in which the construction of multi-party sampling protocols is reduced to the construction of sampling algorithms that use an SV -source as their source of randomness.
Reference: [2] <author> Beaver D., and S. Goldwasser, </author> <title> "Distributed Computation with Faulty Majority ", FOCS, </title> <year> 1989. </year>
Reference-contexts: 1 Introduction The problem of how to perform general distributed computation in an unreliable environment has been extensively addressed. Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time <ref> [24, 13, 25, 14, 11, 2] </ref>. The second model postulates that private channels exist between every pair of players [3, 7, 8, 17, 15]. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults.
Reference: [3] <author> Ben-or M., S. Goldwasser, and A. Wigderson, </author> <title> "Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation", </title> <booktitle> Proc. of 20th STOC, </booktitle> <year> 1988, </year> <pages> pp. 1-10. </pages>
Reference-contexts: Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time [24, 13, 25, 14, 11, 2]. The second model postulates that private channels exist between every pair of players <ref> [3, 7, 8, 17, 15] </ref>. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults. We want to avoid any such assumption and examine the problem of fault-tolerant distributed computation where the faults are computationally unrestricted, and no private channels are available.
Reference: [4] <author> Ben-or M., and N. Linial, </author> <title> "Collective coin flipping", Randomness and Computation, </title> <editor> (S. Micali, ed.), </editor> <publisher> JAI Press, </publisher> <pages> pp. 91-115, </pages> <year> 1989. </year>
Reference-contexts: Previous Work in the Full Information Model Collective coin flipping, i.e., common bounded-biased sampling in f0; 1g has been considered in this full-information model before <ref> [4, 5, 16, 1] </ref>. Matching lower and (constructive) upper bounds of 1 m ) have been shown (by Ben-Or and Linial [4] and Alon and Naor [1], 2 respectively). <p> Previous Work in the Full Information Model Collective coin flipping, i.e., common bounded-biased sampling in f0; 1g has been considered in this full-information model before [4, 5, 16, 1]. Matching lower and (constructive) upper bounds of 1 m ) have been shown (by Ben-Or and Linial <ref> [4] </ref> and Alon and Naor [1], 2 respectively). Our work can be viewed as an extension of these investigations which were concerned with the influences of players on Boolean functions (i.e., Range (f ) = f0; 1g). The general case, considered in this paper, gives rise to additional difficulties. <p> Then at least one of the players can, by playing (possibly) dishonestly force the outcome to be v with probability at least maxfq v ; p p v g (the other party plays honestly). Proof of Theorem 1: The proof is very similar to that of Theorem 5 in <ref> [4] </ref>, though some changes are required. One observes first that if the time complexity of the protocol is no issue, and the only consideration is to keep influences down, then nothing is lost if all actions are taken sequentially and not in parallel. <p> For each input value in D i , the protocol specifies a probability distribution according to which the next node, a child of the present one, is selected (assuming P i is honest). The key observation, beyond the technique of <ref> [4] </ref>, is that these distributions (together with the input distribution over D i ) induce a single distribution for the next move of (honest) player i, conditioned on the execution having reached the present node. <p> max i2I &lt;z i &gt; R , Now, denoting &lt;z i &gt; R by a i;R (where R [m]; jRj = t) and p v;z i by b i , the inductive step reduces to proving the following numerical lemma, which in turn is a generalization of Lemma 5.3 in <ref> [4] </ref>. <p> Also, let fi = P Then, Y ff R fi ( m1 Lemma 5.3 in <ref> [4] </ref> is a special case of Lemma 3 (in which jIj = 2 and 1 = 2 = 1 2 ). However, the ideas presented in the proof of Lemma 5.3 in [4] suffice for proving the general case. <p> Also, let fi = P Then, Y ff R fi ( m1 Lemma 5.3 in <ref> [4] </ref> is a special case of Lemma 3 (in which jIj = 2 and 1 = 2 = 1 2 ). However, the ideas presented in the proof of Lemma 5.3 in [4] suffice for proving the general case.
Reference: [5] <author> Ben-Or, M., Linial, N., Saks, M., </author> <title> "Collective coin flipping and other models of imperfect randomness", Colloq. </title> <journal> Math Soc. Janos Bolyai no. </journal> <volume> 52, </volume> <booktitle> Combinatorics Eger 1987, </booktitle> <pages> pp. 75-112. </pages>
Reference-contexts: Previous Work in the Full Information Model Collective coin flipping, i.e., common bounded-biased sampling in f0; 1g has been considered in this full-information model before <ref> [4, 5, 16, 1] </ref>. Matching lower and (constructive) upper bounds of 1 m ) have been shown (by Ben-Or and Linial [4] and Alon and Naor [1], 2 respectively).
Reference: [6] <author> Chor, B., and O. Goldreich, </author> <title> "Unbiased Bits from Sources of Weak Randomness and Probabilistic Communication Complexity", </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 17, </volume> <pages> pp. 230-261, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: This simulation method is different from the original method of Vazirani and Vazirani [23] (adopted also in <ref> [6] </ref>) where the BPP-algorithm is invoked many times, each time with a different sequence of coin tosses. Other Related Work We also present efficient sampling protocols for the two-party case.
Reference: [7] <author> Chaum, D., C. Crepeau, and I. Damgard, </author> <title> "Multiparty Unconditionally Secure Protocols", </title> <booktitle> Proc. of 20th STOC, </booktitle> <year> 1988, </year> <pages> pp. 11-19. </pages>
Reference-contexts: Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time [24, 13, 25, 14, 11, 2]. The second model postulates that private channels exist between every pair of players <ref> [3, 7, 8, 17, 15] </ref>. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults. We want to avoid any such assumption and examine the problem of fault-tolerant distributed computation where the faults are computationally unrestricted, and no private channels are available.
Reference: [8] <author> Chor, B., and E. Kushilevitz, </author> <title> "A Zero-One Law for Boolean Privacy", </title> <journal> SIAM Jour. on Disc. Math., </journal> <volume> Vol. 4, </volume> <month> Feb. </month> <year> 1991, </year> <pages> pp. 36-47. </pages>
Reference-contexts: Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time [24, 13, 25, 14, 11, 2]. The second model postulates that private channels exist between every pair of players <ref> [3, 7, 8, 17, 15] </ref>. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults. We want to avoid any such assumption and examine the problem of fault-tolerant distributed computation where the faults are computationally unrestricted, and no private channels are available.
Reference: [9] <author> J. Cooper and N. Linial, </author> <title> Fast perfect-information leader election protocol with linear immunity, Combinatorica, accepted for publication. Extended abstract: </title> <booktitle> 25th Symposium on the Theory of Computing, </booktitle> <address> San Diego, </address> <year> 1993, </year> <pages> 662 - 671. </pages>
Reference-contexts: On the other hand, when repeated collective-coin-flippings are used, t faulty players can influence the outcome to be in S with probability at least 1 , by biasing each coin-flip towards 1. 2 Furthermore, the upper bound can be met by protocols of logarithmic round-complexity <ref> [9, 19] </ref>. 3 An alternative method which also fails is to try to generalize the work of Alon and Naor [1] as follows: the method of [1] consists of randomly selecting one of the players who is appointed to flip a fair coin.
Reference: [10] <author> I. Damg-ard, </author> <title> "Interactive Hashing can Simplify Zero-Knowledge Protocol Design Without Computational Assumptions", </title> <booktitle> Advances in Cryptology Proceedings of Crypto93, </booktitle>
Reference-contexts: Interactive hashing has found many applications in cryptography (cf. <ref> [20, 18, 21, 10] </ref>). For details see Remark 2. 2 Preliminaries 2.1 Bivariate Functions Throughout the paper we represent the bivariate function f : f0; 1g n fif0; 1g n 7! f0; 1g fl as an N - by-N matrix, where N def = 2 n . <p> Also, interactive hashing terminates after l 1 (rather than l) rounds. Interactive hashing was invented for completely different purposes and consequently its analysis as in [20] (and subsequent studies), is very different from what appears above. Interactive hashing was used in implementing various types of commitment protocols (cf. <ref> [20, 18, 21, 10] </ref>). Main Result Combining Propositions 20 and 21 with Theorem 15, we get Theorem 22 (efficient protocol meeting the lower bound): There exists a (generic) two-party protocol, for evaluating an arbitrary bivariate function f .
Reference: [11] <author> Galil, Haber, and Yung., </author> <title> "Cryptographic Computation: Secure Faulty-Tolerant Protocols and the Public Key Model", </title> <booktitle> Advances in Cryptology Proceedings of Crypto89, </booktitle>
Reference-contexts: 1 Introduction The problem of how to perform general distributed computation in an unreliable environment has been extensively addressed. Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time <ref> [24, 13, 25, 14, 11, 2] </ref>. The second model postulates that private channels exist between every pair of players [3, 7, 8, 17, 15]. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults.
Reference: [12] <author> Goldreich, O., S. Goldwasser, and N. Linial, </author> <title> "Fault-tolerant Computation in the Full Information Model", </title> <institution> TR-682, Computer Science Dept., Technion, Haifa, Israel, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: that this set S which forms a negligible fraction of f0; 1g l is hit with negligible probability (for, say, t &lt; m=2c). 1 The above sampling protocol can be used to present a (generic probabilistic polynomial-time) protocol that works well for computing almost all functions (see our technical report <ref> [12] </ref>). Previous Work in the Full Information Model Collective coin flipping, i.e., common bounded-biased sampling in f0; 1g has been considered in this full-information model before [4, 5, 16, 1].
Reference: [13] <author> Goldreich, O., S. Micali, and A. Wigderson, </author> <title> "Proofs that Yield Nothing but their Validity and a Methodology for Cryptographic Protocol Design", </title> <journal> JACM, </journal> <volume> Vol. 38, </volume> <month> July </month> <year> 1991, </year> <pages> pp. 691-729. </pages> <note> Extended abstract in 27th FOCS, </note> <year> 1986, </year> <pages> pp. 174-187. </pages>
Reference-contexts: 1 Introduction The problem of how to perform general distributed computation in an unreliable environment has been extensively addressed. Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time <ref> [24, 13, 25, 14, 11, 2] </ref>. The second model postulates that private channels exist between every pair of players [3, 7, 8, 17, 15]. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults.
Reference: [14] <author> Goldreich, O., S. Micali, and A. Wigderson, </author> <title> "How to Play Any Mental Game", </title> <booktitle> Proc. of 19th STOC, </booktitle> <year> 1987, </year> <pages> pp. 218-229. 41 </pages>
Reference-contexts: 1 Introduction The problem of how to perform general distributed computation in an unreliable environment has been extensively addressed. Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time <ref> [24, 13, 25, 14, 11, 2] </ref>. The second model postulates that private channels exist between every pair of players [3, 7, 8, 17, 15]. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults.
Reference: [15] <author> Goldwasser, S. and L.A. Levin, </author> <title> "Fair Computation of General Functions in Presence of Immoral Majority", </title> <booktitle> Advances in Cryptology Proceedings of Crypto90, </booktitle>
Reference-contexts: Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time [24, 13, 25, 14, 11, 2]. The second model postulates that private channels exist between every pair of players <ref> [3, 7, 8, 17, 15] </ref>. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults. We want to avoid any such assumption and examine the problem of fault-tolerant distributed computation where the faults are computationally unrestricted, and no private channels are available.
Reference: [16] <author> J. Kahn, G. Kalai and N. Linial, </author> <title> "The influence of variables on boolean functions", </title> <booktitle> 29th FOCS, </booktitle> <year> 1988, </year> <pages> pp. 68-80. </pages>
Reference-contexts: Previous Work in the Full Information Model Collective coin flipping, i.e., common bounded-biased sampling in f0; 1g has been considered in this full-information model before <ref> [4, 5, 16, 1] </ref>. Matching lower and (constructive) upper bounds of 1 m ) have been shown (by Ben-Or and Linial [4] and Alon and Naor [1], 2 respectively).
Reference: [17] <author> Kilian, J., </author> <title> "Founding Cryptography on Oblivious Transfer", </title> <booktitle> 20 th STOC (1988), </booktitle> <pages> 20-29. </pages>
Reference-contexts: Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time [24, 13, 25, 14, 11, 2]. The second model postulates that private channels exist between every pair of players <ref> [3, 7, 8, 17, 15] </ref>. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults. We want to avoid any such assumption and examine the problem of fault-tolerant distributed computation where the faults are computationally unrestricted, and no private channels are available.
Reference: [18] <author> M. Naor, R. Ostrovsky, R. Venkatesan and M. Yung, </author> <title> "Perfect Zero-Knowledge Arguments for NP Can Be Based on General Complexity Assumptions", </title> <booktitle> Advances in Cryptology - Proceedings of Crypto92, Springer-Verlag Lecture Notes in Computer Science. To appear in J. of Cryptology. </booktitle>
Reference-contexts: Interactive hashing has found many applications in cryptography (cf. <ref> [20, 18, 21, 10] </ref>). For details see Remark 2. 2 Preliminaries 2.1 Bivariate Functions Throughout the paper we represent the bivariate function f : f0; 1g n fif0; 1g n 7! f0; 1g fl as an N - by-N matrix, where N def = 2 n . <p> Also, interactive hashing terminates after l 1 (rather than l) rounds. Interactive hashing was invented for completely different purposes and consequently its analysis as in [20] (and subsequent studies), is very different from what appears above. Interactive hashing was used in implementing various types of commitment protocols (cf. <ref> [20, 18, 21, 10] </ref>). Main Result Combining Propositions 20 and 21 with Theorem 15, we get Theorem 22 (efficient protocol meeting the lower bound): There exists a (generic) two-party protocol, for evaluating an arbitrary bivariate function f .
Reference: [19] <author> R. Ostrovsky, S. Rajagopalan, and U. Vazirani, </author> <title> "Simple and Efficient Leader Election in the Full Information Model", </title> <booktitle> STOC 1994, </booktitle> <pages> 234-242. </pages>
Reference-contexts: On the other hand, when repeated collective-coin-flippings are used, t faulty players can influence the outcome to be in S with probability at least 1 , by biasing each coin-flip towards 1. 2 Furthermore, the upper bound can be met by protocols of logarithmic round-complexity <ref> [9, 19] </ref>. 3 An alternative method which also fails is to try to generalize the work of Alon and Naor [1] as follows: the method of [1] consists of randomly selecting one of the players who is appointed to flip a fair coin.
Reference: [20] <author> R. Ostrovsky, R. Venkatesan and M. Yung, </author> <title> "Fair Games Against an All-Powerful Adversary", </title> <booktitle> Presented at DIMACS Complexity and Cryptography Workshop, </booktitle> <month> October </month> <year> 1990, </year> <title> Princeton. </title> <booktitle> AMS DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> Vol. 13, </volume> <booktitle> Jin-Yi Cai editor, </booktitle> <pages> pp. 155-169, </pages> <year> 1993. </year>
Reference-contexts: Interestingly, it the basic sampling protocol is also used as a building block for a better sampling protocol, which is optimal up to a constant factor.) Our basic two-party sampling protocol is very similar to a protocol, called interactive hashing, which was discovered independently by Ostrovsky et. al. <ref> [20] </ref>. Interactive hashing has found many applications in cryptography (cf. [20, 18, 21, 10]). <p> Interactive hashing has found many applications in cryptography (cf. <ref> [20, 18, 21, 10] </ref>). For details see Remark 2. 2 Preliminaries 2.1 Bivariate Functions Throughout the paper we represent the bivariate function f : f0; 1g n fif0; 1g n 7! f0; 1g fl as an N - by-N matrix, where N def = 2 n . <p> Remark 2 : Our two-party sampling protocol is very similar to interactive hashing, a protocol, that was discovered independently by Ostrovsky et. al. <ref> [20] </ref>. However, in interactive hashing one party always picks the partition and the other always chooses the side. Also, interactive hashing terminates after l 1 (rather than l) rounds. Interactive hashing was invented for completely different purposes and consequently its analysis as in [20] (and subsequent studies), is very different from <p> was discovered independently by Ostrovsky et. al. <ref> [20] </ref>. However, in interactive hashing one party always picks the partition and the other always chooses the side. Also, interactive hashing terminates after l 1 (rather than l) rounds. Interactive hashing was invented for completely different purposes and consequently its analysis as in [20] (and subsequent studies), is very different from what appears above. Interactive hashing was used in implementing various types of commitment protocols (cf. [20, 18, 21, 10]). <p> Also, interactive hashing terminates after l 1 (rather than l) rounds. Interactive hashing was invented for completely different purposes and consequently its analysis as in [20] (and subsequent studies), is very different from what appears above. Interactive hashing was used in implementing various types of commitment protocols (cf. <ref> [20, 18, 21, 10] </ref>). Main Result Combining Propositions 20 and 21 with Theorem 15, we get Theorem 22 (efficient protocol meeting the lower bound): There exists a (generic) two-party protocol, for evaluating an arbitrary bivariate function f .
Reference: [21] <author> R. Ostrovsky, R. Venkatesan and M. Yung, </author> <title> "Interactive Hashing Simplifies Zero-Knowledge Protocol Design", </title> <publisher> Eurocrypt93. </publisher>
Reference-contexts: Interactive hashing has found many applications in cryptography (cf. <ref> [20, 18, 21, 10] </ref>). For details see Remark 2. 2 Preliminaries 2.1 Bivariate Functions Throughout the paper we represent the bivariate function f : f0; 1g n fif0; 1g n 7! f0; 1g fl as an N - by-N matrix, where N def = 2 n . <p> Also, interactive hashing terminates after l 1 (rather than l) rounds. Interactive hashing was invented for completely different purposes and consequently its analysis as in [20] (and subsequent studies), is very different from what appears above. Interactive hashing was used in implementing various types of commitment protocols (cf. <ref> [20, 18, 21, 10] </ref>). Main Result Combining Propositions 20 and 21 with Theorem 15, we get Theorem 22 (efficient protocol meeting the lower bound): There exists a (generic) two-party protocol, for evaluating an arbitrary bivariate function f .
Reference: [22] <author> Santha, M., and U.V. Vazirani, </author> <title> "Generating Quasi-Random Sequences from Slightly-Random Sources", </title> <booktitle> 25th Symp. on Foundation of Computer Science, </booktitle> <pages> pp. 434-440, </pages> <year> 1984. </year>
Reference-contexts: Our protocol uses the collective coin flipping of [1] as a subroutine. In fact, our sampling protocol can be viewed as a deterministic reduction to the problem of collective coin tossing. The collective coin can be viewed as a slightly random source in the sense of Santha and Vazirani <ref> [22] </ref>, i.e., an SV-source 4 . Hence, our result can be interpreted as presenting a sampling algorithm which uses a SV-source (with a parameter fl &lt; 1 p 2 ). <p> We prefer an alternative presentation of our proof, in which the construction of multi-party sampling protocols is reduced to the construction of sampling algorithms that use an SV -source as their source of randomness. Recall that an SV-source with parameter fl 1 2 (cf. <ref> [22] </ref>) is a sequence of Boolean random variables, X 1 ; X 2 ; :::, so that for each i and every ff 2 f0; 1g i and every 2 f0; 1g: Prob (X i+1 = jX 1 X i = ff) fl Theorem 24 follows from Proposition 25 (sampling with
Reference: [23] <author> U.V. Vazirani, and V.V. Vazirani, </author> <title> "Random Polynomial Time is equal to Slightly-Random Polynomial Time", </title> <booktitle> 26th Symp. on Foundation of Computer Science, </booktitle> <pages> pp. 417-428, </pages> <year> 1985. </year>
Reference-contexts: This simulation method is different from the original method of Vazirani and Vazirani <ref> [23] </ref> (adopted also in [6]) where the BPP-algorithm is invoked many times, each time with a different sequence of coin tosses. Other Related Work We also present efficient sampling protocols for the two-party case.
Reference: [24] <author> Yao, A. C., </author> <title> "Protocols for Secure Computations", </title> <booktitle> 23th FOCS, </booktitle> <pages> pp. 160-164, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction The problem of how to perform general distributed computation in an unreliable environment has been extensively addressed. Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time <ref> [24, 13, 25, 14, 11, 2] </ref>. The second model postulates that private channels exist between every pair of players [3, 7, 8, 17, 15]. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults.
Reference: [25] <author> Yao, A. C., </author> <title> "How to Generate and Exchange Secrets", </title> <booktitle> 27th FOCS, </booktitle> <year> 1986, </year> <pages> pp. 162-167. 42 </pages>
Reference-contexts: 1 Introduction The problem of how to perform general distributed computation in an unreliable environment has been extensively addressed. Two types of models have been considered. The first model assumes that one-way functions exist and considers adversaries (faults) which are computationally restricted to probabilistic polynomial time <ref> [24, 13, 25, 14, 11, 2] </ref>. The second model postulates that private channels exist between every pair of players [3, 7, 8, 17, 15]. Hence, in both models fault-tolerance is achieved at the cost of restricting the type of faults.
References-found: 25

