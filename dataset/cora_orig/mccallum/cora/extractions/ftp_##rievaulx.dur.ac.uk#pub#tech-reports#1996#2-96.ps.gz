URL: ftp://rievaulx.dur.ac.uk/pub/tech-reports/1996/2-96.ps.gz
Refering-URL: http://www.dur.ac.uk/~dcs0www/tech-reports.html
Root-URL: 
Title: Defect Detection in Code know the types of faults they are looking for and to
Keyword: reviews testing techniques and taxonomies and considers fault clustering and isolation. Keywords: faults taxonomy- fault clustering  
Note: To allow testers to  The paper  
Abstract: Ishbel Duncan, Dave Robson and Malcolm Munro Testing Research Group, Computer Science, University of Durham, DH1 3LE, UK (Computer Science Technical Report 2/96) Abstract 
Abstract-found: 1
Intro-found: 1
Reference: [Bei90] <author> B. Beizer. </author> <title> Software Testing Techniques. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Section five focusses on defect detection and the use of metrics and test suite adequacy. The next section compares techniques and is followed by the conclusion which also indicates future work in this area. 2 Testing Techniques There are many techniques for testing code at various levels of development <ref> [Bei90] </ref>. At the code level these include data flow and coverage testing, generically named as structural or white box testing. Black box, or functional, testing includes domain testing, partition testing and special values testing. Functional testing investigates the system in terms of its expected features or functionality. <p> Most suggest that functional testing is a useful preliminary to code testing, creating a base of useful test cases with generally high code coverage [POC93, BS87, Mye78, HH79, KL95, HLL94]. It is agreed that tests performed later in the software development process are more expensive to correct <ref> [Bei90, Mar91] </ref> and hence functional testing coupled with heavy unit testing can be a cheap and effective strategy. <p> Some experiments also attempted to determine which (structural) technique was more likely to display faults. Coverage testing usually came out with a higher fault determination and localisation than data flow testing and (weak) mutation testing was also considered a powerful technique. Beizer, Knuth and the IEEE Standard 1044-1993 <ref> [Bei90, Knu89, IEE94] </ref> all categorise faults for non-OO code. Beizer's taxonomy and the IEEE classification are larger than Knuth's which is very simple, comprising only 15 general categories. <p> Several authors comment on the fact that categorisation is very much dependent on the frame of mind of the tester and also on how the fault was discovered <ref> [Knu89, Wey94, Bei90, PW91] </ref>. If it was discovered during data analysis then a fault is more likely to be placed under that category. A fault discovered as part of an integration test may well be placed in a category pertaining to integration or module mismatch.
Reference: [BKL90] <author> S.S. Brilliant, J.C. Knight, and N.G. Leveson. </author> <title> Analysis of Faults in an N-Version Software Experiment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(2), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: Knowledge of what faults are common for a particular language, system product type (e.g. data base manager, word processor, data reduction system etc), or programmers can be used to focus testing. These ideas have been proposed by several researchers <ref> [DR91, BKL90, BP84] </ref>. Also, if it is cheaper to detect and eliminate faults early in the life-cycle then designers should be encouraged to avoid common faults resulting from design patterns or method (ologie)s. <p> Thus, fault taxonomies must be addressed alongside techniques for determining fault position and cause. 5.1 Fault Clustering It is known that the type of system product and the abilities of the programmers (and testers) affect the fault commonality [DR91, MP94]. Also, experiments have shown that fault clustering is nonuniform <ref> [EIP + 91, POC93, SB91, Dun93, BKL90, KZT94, HLL94, MP94] </ref>. Moller and Paulish also 5 reasoned that over 77% of faults affect only one module, thus affirming theories on the necessity for heavy unit testing. They also confirmed that faults affecting more than one module were more costly to correct.
Reference: [BP84] <author> V.R. Basili and B.T Perricone. </author> <title> Software Errors and Complexity: An Empirical Investigation. </title> <journal> CACM, </journal> <volume> 27(1) </volume> <pages> 42-52, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: improve the testing process for an industrial system? Also, what are the important factors required from a test? Research demonstrates that the efficiency and effectiveness of any testing technique is dependent on the code, how well it was written and what it does, and on the abilities of the testers <ref> [MP94, DR91, BP84] </ref>. Also, the later in the software life-cycle that testing is done, the higher the expense of corrective maintenance. <p> Knowledge of what faults are common for a particular language, system product type (e.g. data base manager, word processor, data reduction system etc), or programmers can be used to focus testing. These ideas have been proposed by several researchers <ref> [DR91, BKL90, BP84] </ref>. Also, if it is cheaper to detect and eliminate faults early in the life-cycle then designers should be encouraged to avoid common faults resulting from design patterns or method (ologie)s. <p> It is therefore necessary to classify faults and to determine those of higher frequency for particular dependencies. 4 Taxonomies of Faults In the testing literature there are many references to classifications of faults for particular experiments <ref> [BP84, BS87, Wei79, Gla81, OW84, Mar90, RT88] </ref>. Some experiments also attempted to determine which (structural) technique was more likely to display faults. Coverage testing usually came out with a higher fault determination and localisation than data flow testing and (weak) mutation testing was also considered a powerful technique. <p> The smaller the percentage of new or modified code the greater the fault rate. Another experiment showed that the number of faults per line of code is higher in modified functions and yet another showed that faults are more likely in small or large functions <ref> [BP84, SYTP85] </ref>. Brilliant et al. demonstrated that some failures are logically related, occurring in the same code region or exhibiting the same type. Those that weren't logically related appeared to fail due to a common mishandling of inputs. That is, faulty paths have common input domains. <p> It is unlikely that modified classes in the OO environment would require any less rigorous testing. 5.2 Metrics, Sufficiency and Adequacy Experiments have shown that complexity metrics are either related to the number or faults in code or are not! <ref> [MK92, SB91, Gaf84, SYTP85, TK89, MP94, BP84] </ref> There is therefore some debate, which will no doubt continue for some time, with regard to the relationship between complexity and fault concentration. The results are confusing and there are obviously other factors involved other than code complexity in fault location.
Reference: [BS87] <author> V.R. Basili and R.W. Selby. </author> <title> Comparing the Effectiveness of Software Testing Strategies. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-13(12), </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: Most suggest that functional testing is a useful preliminary to code testing, creating a base of useful test cases with generally high code coverage <ref> [POC93, BS87, Mye78, HH79, KL95, HLL94] </ref>. It is agreed that tests performed later in the software development process are more expensive to correct [Bei90, Mar91] and hence functional testing coupled with heavy unit testing can be a cheap and effective strategy. <p> Errors have a close relation to software productivity and reliability [MKK + 87]. Correctness is certainly an issue but proving correctness is expensive and all but impossible for a system of more than a few modules. Experiments have been performed to compare various testing strategies <ref> [KL95, BS87, GW86, Mar90, Mat91] </ref>, but they have invariably been small scale academic studies on differing languages and differing sets of test programs. The results have shown that structural techniques are all useful for defect detection and isolation, but efficiency issues have not been considered. <p> It is therefore necessary to classify faults and to determine those of higher frequency for particular dependencies. 4 Taxonomies of Faults In the testing literature there are many references to classifications of faults for particular experiments <ref> [BP84, BS87, Wei79, Gla81, OW84, Mar90, RT88] </ref>. Some experiments also attempted to determine which (structural) technique was more likely to display faults. Coverage testing usually came out with a higher fault determination and localisation than data flow testing and (weak) mutation testing was also considered a powerful technique.
Reference: [DMR96] <author> Ishbel Duncan, Malcolm Munro, and Dave Robson. </author> <title> Test case development during oo Life-cycle and Evolution. </title> <institution> Computer Science Technical Report 4/96, University of Durham, </institution> <year> 1996. </year>
Reference-contexts: It is therefore important to bring the testing phase further forward into the early stages of software development, and is an argument in favour of rapid prototyping or, for more stringent testing, the use of a new life-cycle model which incorporates testing at all phases <ref> [DMR96] </ref>. Three main issues in testing are those of efficiency, effectiveness and knowledge acquisition. A test must be efficient in terms of resource usage and cost otherwise it will simply be abandoned or cut short. To reduce costs, testing must be encouraged as early as possible in the software development.
Reference: [DR91] <author> I.M.M. Duncan and D.J. Robson. </author> <title> An Exploratory Study of Common Coding Faults in C Programs. </title> <institution> Computer Science Technical Report 5/91, University of Durham, </institution> <year> 1991. </year>
Reference-contexts: improve the testing process for an industrial system? Also, what are the important factors required from a test? Research demonstrates that the efficiency and effectiveness of any testing technique is dependent on the code, how well it was written and what it does, and on the abilities of the testers <ref> [MP94, DR91, BP84] </ref>. Also, the later in the software life-cycle that testing is done, the higher the expense of corrective maintenance. <p> Knowledge of what faults are common for a particular language, system product type (e.g. data base manager, word processor, data reduction system etc), or programmers can be used to focus testing. These ideas have been proposed by several researchers <ref> [DR91, BKL90, BP84] </ref>. Also, if it is cheaper to detect and eliminate faults early in the life-cycle then designers should be encouraged to avoid common faults resulting from design patterns or method (ologie)s. <p> Thus, fault taxonomies must be addressed alongside techniques for determining fault position and cause. 5.1 Fault Clustering It is known that the type of system product and the abilities of the programmers (and testers) affect the fault commonality <ref> [DR91, MP94] </ref>. Also, experiments have shown that fault clustering is nonuniform [EIP + 91, POC93, SB91, Dun93, BKL90, KZT94, HLL94, MP94]. Moller and Paulish also 5 reasoned that over 77% of faults affect only one module, thus affirming theories on the necessity for heavy unit testing.
Reference: [Dun93] <author> I.M.M. Duncan. </author> <title> Strong Mutation Testing Strategies. </title> <type> PhD thesis, </type> <institution> Computer Science, University of Durham, Science Site, Durham, U.K., </institution> <year> 1993. </year>
Reference-contexts: Thus, fault taxonomies must be addressed alongside techniques for determining fault position and cause. 5.1 Fault Clustering It is known that the type of system product and the abilities of the programmers (and testers) affect the fault commonality [DR91, MP94]. Also, experiments have shown that fault clustering is nonuniform <ref> [EIP + 91, POC93, SB91, Dun93, BKL90, KZT94, HLL94, MP94] </ref>. Moller and Paulish also 5 reasoned that over 77% of faults affect only one module, thus affirming theories on the necessity for heavy unit testing. They also confirmed that faults affecting more than one module were more costly to correct. <p> The results are confusing and there are obviously other factors involved other than code complexity in fault location. It has been shown that coverage is not sufficient for a rigorous test <ref> [WHH80, Dun93, HLL94] </ref>. Although high coverage is attainable from a functional test [KL95, POC93] it is considered inadequate for determining the worth of a test. Test suite inadequacy is a common problem.
Reference: [EIP + 91] <author> W.K. Ehrlich, A. Iannino, B.S. Prasanna, J.P. Stampfel, and J.R. Wu. </author> <title> How Faults Cause Software Failures: Implications for Software Reliability Engineering. </title> <booktitle> In Int. Symposium on Software Reliabity Engineering, </booktitle> <pages> pages 233-241, </pages> <year> 1991. </year>
Reference-contexts: Thus, fault taxonomies must be addressed alongside techniques for determining fault position and cause. 5.1 Fault Clustering It is known that the type of system product and the abilities of the programmers (and testers) affect the fault commonality [DR91, MP94]. Also, experiments have shown that fault clustering is nonuniform <ref> [EIP + 91, POC93, SB91, Dun93, BKL90, KZT94, HLL94, MP94] </ref>. Moller and Paulish also 5 reasoned that over 77% of faults affect only one module, thus affirming theories on the necessity for heavy unit testing. They also confirmed that faults affecting more than one module were more costly to correct.
Reference: [Eis93] <author> M. </author> <title> Eisenstadt. Tales of Debugging From the Front Lines. </title> <booktitle> In Procs. Fifth Workshop on Empirical Studies of Programmers, </booktitle> <year> 1993. </year>
Reference-contexts: These map onto Beizer's taxonomy of fault numbers 2,3,4 5 and 6 (functionality as implemented, structural, data, implementation and integration faults). Beizer notes that categories 2,3 and 4 (functionality as implemented, structural and data) account for over 63% of his categorised faults. In his anecdotal survey, Eisenstadt <ref> [Eis93] </ref>, used Knuth's categorisation and found that faults lay in categories A,B,D,L, S and T, where S is Surprising Scenario and T is Typographical errors.
Reference: [Fir93] <author> D. Firesmith. </author> <title> Testing Object-Oriented Software. </title> <booktitle> In Proceedings of TOOLS, </booktitle> <month> March </month> <year> 1993. </year> <month> 8 </month>
Reference-contexts: Beizer, Knuth and the IEEE Standard 1044-1993 [Bei90, Knu89, IEE94] all categorise faults for non-OO code. Beizer's taxonomy and the IEEE classification are larger than Knuth's which is very simple, comprising only 15 general categories. In the OO environment, some work has been done on fault classification <ref> [Hay94, Fir93, PW91, Ove93] </ref> although experiments to show what faults are commonly occurring are lacking. Koenig and Hatton [Koe89, Hat95] both lists faults in the C language and Spuler [Spu94] lists faults in C++. The latter is currently cataloging bug reports.
Reference: [Gaf84] <author> J.E. Gaffney. </author> <title> Estimating the Number of Faults in Code. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):459-465, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: It is unlikely that modified classes in the OO environment would require any less rigorous testing. 5.2 Metrics, Sufficiency and Adequacy Experiments have shown that complexity metrics are either related to the number or faults in code or are not! <ref> [MK92, SB91, Gaf84, SYTP85, TK89, MP94, BP84] </ref> There is therefore some debate, which will no doubt continue for some time, with regard to the relationship between complexity and fault concentration. The results are confusing and there are obviously other factors involved other than code complexity in fault location.
Reference: [Gla81] <author> R.L. Glass. </author> <title> Persistent Software Errors. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 7(2) </volume> <pages> 162-168, </pages> <month> March </month> <year> 1981. </year>
Reference-contexts: It is therefore necessary to classify faults and to determine those of higher frequency for particular dependencies. 4 Taxonomies of Faults In the testing literature there are many references to classifications of faults for particular experiments <ref> [BP84, BS87, Wei79, Gla81, OW84, Mar90, RT88] </ref>. Some experiments also attempted to determine which (structural) technique was more likely to display faults. Coverage testing usually came out with a higher fault determination and localisation than data flow testing and (weak) mutation testing was also considered a powerful technique.
Reference: [GW86] <author> M. R. Girgis and M. R. Woodward. </author> <title> An Experimental Comparison of the Error Exposing Ability of Program Testing Criteria. </title> <publisher> In IEEE Computer Society Press, </publisher> <pages> pages 64-73, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Errors have a close relation to software productivity and reliability [MKK + 87]. Correctness is certainly an issue but proving correctness is expensive and all but impossible for a system of more than a few modules. Experiments have been performed to compare various testing strategies <ref> [KL95, BS87, GW86, Mar90, Mat91] </ref>, but they have invariably been small scale academic studies on differing languages and differing sets of test programs. The results have shown that structural techniques are all useful for defect detection and isolation, but efficiency issues have not been considered.
Reference: [Hat95] <author> Les Hatton. </author> <title> Safer C : Developing Software for High-integrity and Safety-critical systems. </title> <publisher> McGraw-Hill, </publisher> <year> 1995. </year>
Reference-contexts: Beizer's taxonomy and the IEEE classification are larger than Knuth's which is very simple, comprising only 15 general categories. In the OO environment, some work has been done on fault classification [Hay94, Fir93, PW91, Ove93] although experiments to show what faults are commonly occurring are lacking. Koenig and Hatton <ref> [Koe89, Hat95] </ref> both lists faults in the C language and Spuler [Spu94] lists faults in C++. The latter is currently cataloging bug reports. Knuth's work on the development of T E X led to his rough division of faults. <p> Further work is required on real data before the fault taxonomies for OO code can be developed and work on this is on-going <ref> [Spu94, Ove93, Hat95] </ref>. 5 Defect Detection and Isolation As faults are classified, to however rough a taxonomy, an information base is developed for a system. It is true that a knowledge of faults for one particular system may not be of much use to the next development [Wey94, MP94].
Reference: [Hay94] <author> J. Huffman Hayes. </author> <title> Testing of Object-Oriented Programming Systems (OOPS): A Fault-Based Approach. </title> <editor> In Bertino and Urban, editors, </editor> <booktitle> Proceedings of the Int. Symposium on OO Methodologies and Systems. </booktitle> <publisher> Springer Verlag, </publisher> <month> Spetember </month> <year> 1994. </year>
Reference-contexts: Beizer, Knuth and the IEEE Standard 1044-1993 [Bei90, Knu89, IEE94] all categorise faults for non-OO code. Beizer's taxonomy and the IEEE classification are larger than Knuth's which is very simple, comprising only 15 general categories. In the OO environment, some work has been done on fault classification <ref> [Hay94, Fir93, PW91, Ove93] </ref> although experiments to show what faults are commonly occurring are lacking. Koenig and Hatton [Koe89, Hat95] both lists faults in the C language and Spuler [Spu94] lists faults in C++. The latter is currently cataloging bug reports.
Reference: [HH79] <author> M.A. Holthouse and M.J. Hatch. </author> <title> Experience with Automated Testing Analysis. </title> <journal> IEEE Computer, </journal> <volume> 12(8) </volume> <pages> 33-6, </pages> <month> Aug </month> <year> 1979. </year>
Reference-contexts: Most suggest that functional testing is a useful preliminary to code testing, creating a base of useful test cases with generally high code coverage <ref> [POC93, BS87, Mye78, HH79, KL95, HLL94] </ref>. It is agreed that tests performed later in the software development process are more expensive to correct [Bei90, Mar91] and hence functional testing coupled with heavy unit testing can be a cheap and effective strategy.
Reference: [HLL94] <author> J.R. Horgan, S. </author> <title> London, and M.R. Lyu. Achieving Software Quality with Testing Coverage Measures. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 60 - 69, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Most suggest that functional testing is a useful preliminary to code testing, creating a base of useful test cases with generally high code coverage <ref> [POC93, BS87, Mye78, HH79, KL95, HLL94] </ref>. It is agreed that tests performed later in the software development process are more expensive to correct [Bei90, Mar91] and hence functional testing coupled with heavy unit testing can be a cheap and effective strategy. <p> It is agreed that tests performed later in the software development process are more expensive to correct [Bei90, Mar91] and hence functional testing coupled with heavy unit testing can be a cheap and effective strategy. Horgan et al. <ref> [HLL94] </ref> also recommend that both functional and structural testing be performed but caution that there is a law of diminishing returns whereby the cost of increasing coverage, and hopefully test quality, may not be worthwhile in terms of extra fault detection. 3 Testing Requirements Given the above basic advantages and disadvantages <p> Thus, fault taxonomies must be addressed alongside techniques for determining fault position and cause. 5.1 Fault Clustering It is known that the type of system product and the abilities of the programmers (and testers) affect the fault commonality [DR91, MP94]. Also, experiments have shown that fault clustering is nonuniform <ref> [EIP + 91, POC93, SB91, Dun93, BKL90, KZT94, HLL94, MP94] </ref>. Moller and Paulish also 5 reasoned that over 77% of faults affect only one module, thus affirming theories on the necessity for heavy unit testing. They also confirmed that faults affecting more than one module were more costly to correct. <p> The results are confusing and there are obviously other factors involved other than code complexity in fault location. It has been shown that coverage is not sufficient for a rigorous test <ref> [WHH80, Dun93, HLL94] </ref>. Although high coverage is attainable from a functional test [KL95, POC93] it is considered inadequate for determining the worth of a test. Test suite inadequacy is a common problem.
Reference: [HMF92] <author> M. J. Harrold, J.D. McGregor, and K.J. Fitzpatrick. </author> <title> Incremental Testing of Object-Oriented Class Structure. </title> <booktitle> In 14th Int. Conference on Software Engineering, </booktitle> <year> 1992. </year>
Reference-contexts: Object Oriented (OO) testing is very much in its infancy and although the literature is growing, the majority of papers refer to theoretical work. Little experimentation has been done and most concentrates on the state based testing of classes or small libraries <ref> [TR92, HMF92, HSS94] </ref>. There is some elementary fault based work [KZT94]. McGregor and Korson [MK94] remark that unit testing (class testing) in OO has a higher pay-off than in procedural languages because a class is comprised of methods and attributes which may interact as a small sub-system.
Reference: [HSS94] <author> D. M. Hoffman, J. Smillie, and P. A. Strooper. </author> <title> Automated Class Testing: Methods and Experience. </title> <booktitle> In First Asia-Pacific Software Engineering Conference (APSEC), </booktitle> <year> 1994. </year>
Reference-contexts: Object Oriented (OO) testing is very much in its infancy and although the literature is growing, the majority of papers refer to theoretical work. Little experimentation has been done and most concentrates on the state based testing of classes or small libraries <ref> [TR92, HMF92, HSS94] </ref>. There is some elementary fault based work [KZT94]. McGregor and Korson [MK94] remark that unit testing (class testing) in OO has a higher pay-off than in procedural languages because a class is comprised of methods and attributes which may interact as a small sub-system.
Reference: [IEE94] <institution> IEEE Standard Classification for Software Anomalies. IEEE, </institution> <year> 1994. </year>
Reference-contexts: Some experiments also attempted to determine which (structural) technique was more likely to display faults. Coverage testing usually came out with a higher fault determination and localisation than data flow testing and (weak) mutation testing was also considered a powerful technique. Beizer, Knuth and the IEEE Standard 1044-1993 <ref> [Bei90, Knu89, IEE94] </ref> all categorise faults for non-OO code. Beizer's taxonomy and the IEEE classification are larger than Knuth's which is very simple, comprising only 15 general categories.
Reference: [JCJO94] <author> I. Jacobsen, M. Christerson, P. Jonsson, and G. Overgaard. </author> <title> Object Oriented Software Engineering </title>
Reference-contexts: They identified nine bug types for OO code [PW91]; perceptual, specification, abstraction, algorithmic, re-use, logical, semantic, syntactic and domain adherance. Jacobsen et al <ref> [JCJO94] </ref> also identify errors that occur in the test execution, test case specification, test drivers, stubs etc and the test environment. It can be seen that all the above taxonomies contribute but are in-complete.
References-found: 21

