URL: http://www.cosc.brocku.ca/Research/TechRep/cs9702.ps
Refering-URL: http://www.cosc.brocku.ca/Research/TechRep/
Root-URL: 
Title: On Random Shuffles Subsets  
Author: T. A. Jenkyns, D. McCarthy, 
Address: St. Catharines, Ontario Canada L2S 3A1  
Affiliation: Department of Mathematics  Dept. of Computer Science Brock University,  
Abstract: Four simple algorithms are presented for producing a random rearrangement of the values in an array X[1], X[2], ..., X[n] using a pseudorandom number generator. These range from one that is naive, inefficient, and biased to one that is elegeant, efficient, and unbiased. By taking the first k entries in X one obtains a random (ordered) subset of size k. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Bentley, </author> <title> Programming Pearls, </title> <publisher> Addison-Wesley, </publisher> <address> Readinf, MA, </address> <year> 1986. </year>
Reference-contexts: For further study of the design and analysis of algorithms we also suggest <ref> [1] </ref> and [2]. 2. Mixing the Values in X We begin by devising a method to imitate shuffling cards in a deck where the values in array X change their positions in some unpredictable manner and where any value may end up in any position. <p> Since 2M values are moved, each value moves 2M/n = 2n times on average and may end up in any position. The computational cost of this algorithm is: 2M calls of RAND, and M interchanges of elements of X. 3. The Effect of the Mixing Process Let X <ref> [1] </ref>, X [2], ..., X [n] denote the final values in the array, and lets examine what happens to each input value as it travels to its final position. <p> Taking the input values in order, we see that X [j] must have an equal chance of ending up in any available position; i.e., any position except where X <ref> [1] </ref>, X [2], ..., X [j-1] ended. Thus we need some way to mark the available positions for the value X [j]. Lets use a second array X indexed from 1 to n and initialized to some special value Z which does not occur in X. <p> To indicate X [j] is an ineligible value for X'[2] we could mark it so by assigning it the value Z or we could set it "aside" by interchanging its value with X <ref> [1] </ref>. 4 j - eligible values for X'[2] Now we select one of these eligible values of X'[2] at random and interchange it with X [2]. j - eligible values for X'[3] Continuing in this way, we do not need array X', and we obtain our final solution to the shuffling
Reference: 2. <author> S.E. Goodman, S.T.Hedetniemi, </author> <title> Introduction to the Design and Analysis of Algorithms, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: For further study of the design and analysis of algorithms we also suggest [1] and <ref> [2] </ref>. 2. Mixing the Values in X We begin by devising a method to imitate shuffling cards in a deck where the values in array X change their positions in some unpredictable manner and where any value may end up in any position. <p> The computational cost of this algorithm is: 2M calls of RAND, and M interchanges of elements of X. 3. The Effect of the Mixing Process Let X [1], X <ref> [2] </ref>, ..., X [n] denote the final values in the array, and lets examine what happens to each input value as it travels to its final position. <p> Taking the input values in order, we see that X [j] must have an equal chance of ending up in any available position; i.e., any position except where X [1], X <ref> [2] </ref>, ..., X [j-1] ended. Thus we need some way to mark the available positions for the value X [j]. Lets use a second array X indexed from 1 to n and initialized to some special value Z which does not occur in X. <p> for X'<ref> [2] </ref> we could mark it so by assigning it the value Z or we could set it "aside" by interchanging its value with X [1]. 4 j - eligible values for X'[2] Now we select one of these eligible values of X'[2] at random and interchange it with X [2]. j - eligible values for X'[3] Continuing in this way, we do not need array X', and we obtain our final solution to the shuffling problem. <p> Finally we note that usually the ordering of the elements of a k-subset of an n-set is irrelevant but in some applications we might want them in increasing order. This can be done without first selecting the k elements and then sorting them, by algorithms which appear in <ref> [2] </ref>, [3], and [4].
Reference: 3. <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming, Seminumerical Algorithms, </booktitle> <volume> Vol. 2, </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: We implicitly assume that the values RAND generates are independent; that is, any particular call of RAND and the value it produces have no effect on the outcome of any other call. Section 3.5 of Knuth <ref> [3] </ref> is a detailed discussion of the philosophical and practical difficulties of constructing such generators. Using an intuitive notion of randomness, we develop three different algorithms to produce a random shuffle, and we determine the computational cost of each. <p> Finally we note that usually the ordering of the elements of a k-subset of an n-set is irrelevant but in some applications we might want them in increasing order. This can be done without first selecting the k elements and then sorting them, by algorithms which appear in [2], <ref> [3] </ref>, and [4].
Reference: 4. <author> A. Nijenhuis, H.S. Wilf, </author> <title> Combinatorial Algorithms, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: A fourth algorithm that appears to use more "randomness" is then proved to be biased. The final section shows that a minor modification of this algorithm may be used to produce a random subset. 2 The book by Nijenhuis and Wilf <ref> [4] </ref> is a wonderful catalogue of algorithms for solving combinatorial problems especially those involving sequences and subsets. For further study of the design and analysis of algorithms we also suggest [1] and [2]. 2. <p> This can be done without first selecting the k elements and then sorting them, by algorithms which appear in [2], [3], and <ref> [4] </ref>.
References-found: 4

