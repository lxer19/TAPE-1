URL: http://foxnet.cs.cmu.edu/people/fp/papers/pldi98ccam.ps.gz
Refering-URL: 
Root-URL: 
Email: fphilipw,petel,fpg@cs.cmu.edu  
Title: Run-time Code Generation and Modal-ML  
Author: Philip Wickline Peter Lee Frank Pfenning 
Address: Pittsburgh, Pennsylvania 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: This paper presents a typed programming language and compiler for run-time code generation. The language, called ML 2 , extends ML with modal operators in the style of the MiniML 2 e language of Davies and Pfenning. ML 2 allows programmers to use types to specify precisely the stages of computation in a program. The types also guide the compiler in generating target code that exploits the staging information through the use of run-time code generation. The target machine is currently a version of the Categorical Abstract Machine, called the CCAM, which we have extended with facilities for run-time code generation. This approach allows the programmer to express the staging that he wants directly to the compiler. It also provides a typed framework in which to verify the correctness of his staging intentions, and to discuss his staging decisions with other programmers. Finally, it supports in a natural way multiple stages of run-time specialization, so that dynamically generated code can be used in the generation of yet further specialized code. This paper presents an overview of the language, with several examples of programs that illustrate key concepts and programming techniques. Then, it discusses the CCAM and the compilation of ML 2 programs into CCAM code. Finally, the results of some experiments are shown, to demonstrate the benefits of this style of run-time code generation for some applications.
Abstract-found: 1
Intro-found: 1
Reference: <author> Auslander, J., M. Philipose, C. Chambers, S. Eggers, and B. Bershad (1996, </author> <month> May). </month> <title> Fast, effective dynamic compilation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, Pennsylvania. </address>
Reference: <author> Consel, C. and F. Noel (1996, </author> <month> 21-24 January). </month> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 145-156. </pages>
Reference-contexts: This information is used to synthesize a generating extension that will generate specialized code for the late stages of the computation when given the firststage inputs. Both the Tempo system <ref> (Consel and Noel 1996) </ref> and DyC (Grant, Mock, Philipose, Chambers, and Eggers 1997) use forms of binding-time analysis for the automatic staging of C programs. <p> Obviously, this technique is extremely expensive. Less expensive schemes have been developed for run-time specialization, notably template filling, which is used by the Tempo system <ref> (Consel and Noel 1996) </ref> and the Synthesis kernel (Massalin and Pu 1989). Template filling compiles selected parts of the program to sequences of machine code with "holes", that is, sections whose instructions need to be filled in at run time. <p> Fabius compiles a pure, first-order subset of ML into native MIPS code. It chooses curried functions as the sites for specialization, compiling them into generating extensions parameterized by their early arguments. Tempo <ref> (Consel and Noel 1996) </ref> is a compiler which extends several techniques from traditional partial evaluation in order to stage C programs semiautomatically. Programmers can supply an initial division of a program into stages via auxiliary data files which are used to guide a binding-time analysis.
Reference: <editor> Cousineau, G., P.-L. Curien, and M. </editor> <booktitle> Mauny (1987). The categorical abstract machine. Science of Computer Programming, </booktitle> <pages> 173-202. </pages>
Reference-contexts: In order to demonstrate these advantages, we have implemented a prototype compiler for our language. The compiler generates code for a version of the Categorical Abstract Machine <ref> (Cousineau, Curien, and Mauny 1987) </ref>, called the CCAM, which is extended with a facility for emitting fresh code at run time. An interesting technical issue arises in the compilation process. <p> Furthermore, generic memoization routines can accommodate most common memoization needs. 5 The CCAM In this section we present the CCAM, an ad hoc extension of the CAM <ref> (Cousineau, Curien, and Mauny 1987) </ref> which provides facilities for run-time code generation and is the target of the compiler detailed in the next section. <p> In contrast, conventional offline partial evaluation will fail to serve such a program well because even multilevel partial evaluation has no way to specialize on each of the variably many inputs. 5.2 The CAM The CAM <ref> (Cousineau, Curien, and Mauny 1987) </ref> is a simple abstract machine which uses categorical combinators as its instructions. The CAM allows a great deal of flexibility in manipulating environments, which are represented as nested pairs of values. <p> At run time, the term M will be evaluated in an environment which matches , supplying values for its value variables and code generators for its code variables. For the base ML constructs, compilation is done in exactly the same way as described for the CAM <ref> (Cousineau, Curien, and Mauny 1987) </ref>.
Reference: <author> Davies, R. </author> <year> (1996, </year> <month> 27-30 July). </month> <title> A temporal-logic approach to binding-time analysis. </title> <booktitle> In Proceedings, 11 th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> New Brunswick, New Jersey, </address> <pages> pp. 184-195. </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We claim that ML 2 can be used as a clear and expressive notation for staged computation. Drawing on previous work on the language MiniML 2 e <ref> (Davies and Pfenning 1996) </ref>, and on the interpretation of this language for run-time code generation described in Wickline, Lee, Pfenning, and Davies (1998), we present an implementation of a prototype compiler for a version of the ML language that uses modal operators to specify precisely the stages of a program's computation. <p> This arises, for example, when dynamically generated code is used to compute values that are used in the special ization of yet more code. 3 Modal ML We briefly introduce the language ML 2 , our extension of MiniML 2 e <ref> (Davies and Pfenning 1996) </ref>. While we present only the most basic and important operators of ML 2 here because of space considerations, the compilation technique described in Section 6 extends easily to all core ML con structs. <p> For example, ` code (x:x) : 2 (ff ! ff) is a generator which, when invoked, generates code for the identity function. Figure 1 presents the syntax of ML 2 which renames the box and let box constructs in <ref> (Davies and Pfenning 1996) </ref> to code and let cogen, respectively. Note that there are two kinds of variables: value variables bound by (denoted by x) and code variables bound by let cogen (denoted by u).
Reference: <author> Davies, R. and F. Pfenning (1996, </author> <month> 21-24 January). </month> <title> A modal analysis of staged computation. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 258-270. </pages>
Reference-contexts: We claim that ML 2 can be used as a clear and expressive notation for staged computation. Drawing on previous work on the language MiniML 2 e <ref> (Davies and Pfenning 1996) </ref>, and on the interpretation of this language for run-time code generation described in Wickline, Lee, Pfenning, and Davies (1998), we present an implementation of a prototype compiler for a version of the ML language that uses modal operators to specify precisely the stages of a program's computation. <p> This arises, for example, when dynamically generated code is used to compute values that are used in the special ization of yet more code. 3 Modal ML We briefly introduce the language ML 2 , our extension of MiniML 2 e <ref> (Davies and Pfenning 1996) </ref>. While we present only the most basic and important operators of ML 2 here because of space considerations, the compilation technique described in Section 6 extends easily to all core ML con structs. <p> For example, ` code (x:x) : 2 (ff ! ff) is a generator which, when invoked, generates code for the identity function. Figure 1 presents the syntax of ML 2 which renames the box and let box constructs in <ref> (Davies and Pfenning 1996) </ref> to code and let cogen, respectively. Note that there are two kinds of variables: value variables bound by (denoted by x) and code variables bound by let cogen (denoted by u).
Reference: <author> Engler, D. R., W. C. Hsieh, and M. F. </author> <month> Kaashoek </month> <year> (1996, </year> <month> 21-24 January). </month> <title> `C: A language for high-level, efficient, and machine-independent dynamic code generation. </title> <booktitle> In Conference Record of POPL '96: The 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 131-144. </pages>
Reference-contexts: This has motivated relatively complex "hygienic" macro systems (Kohlbecker, Friedman, Felleisen, and Duba 1986). Problems involving infinite expansion of macros are also quite common in practice. More recently, this notion of backquote/antiquote has been introduced as an extension to the C programming language, in the language `C <ref> (Engler, Hsieh, and Kaashoek 1996) </ref>. While `C has an advantage over Lisp in providing a degree of static type checking, the fundamental problems of variable capture and infinite expansion remain. The Fabius system (Lee and Leone 1996) uses another approach to programmerspecified staging.
Reference: <author> Engler, D. R., D. Wallach, and M. F. </author> <title> Kaashoek (1995, March). Efficient, safe, application-specific message processing. </title> <type> Technical Memorandum MIT/LCS/TM533, </type> <institution> MIT Laboratory for Computer Science. </institution>
Reference: <author> Gluck, R. and J. </author> <month> Jtrgensen </month> <year> (1995). </year> <title> Efficient multilevel generating extensions. </title> <booktitle> In Programming Languages, Implementations, Logics and Programs (PLILP'95), volume 1181 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: While much work on partial evaluation has focused on programs with two stages, more recent work has extended the partial evaluation framework to account for multiple computation stages <ref> (Gluck and Jtrgensen 1995) </ref>. More common is the use of a programming notation or annotation scheme to support programmerspecified staging. The backquote and antiquote notation of Lisp macros, for example, provides an intuitive though highly error-prone approach to staged computation.
Reference: <author> Grant, B., M. Mock, M. Philipose, C. Chambers, and S. J. Eggers (1997). DyC: </author> <title> An expressive annotation-directed dynamic compiler for C. </title> <type> Technical Report UW-CSE-97-03-03, </type> <institution> Department of Computer Science, University of Washington. </institution>
Reference-contexts: This information is used to synthesize a generating extension that will generate specialized code for the late stages of the computation when given the firststage inputs. Both the Tempo system (Consel and Noel 1996) and DyC <ref> (Grant, Mock, Philipose, Chambers, and Eggers 1997) </ref> use forms of binding-time analysis for the automatic staging of C programs.
Reference: <author> Jtrring, U. and W. L. </author> <month> Scherlis </month> <year> (1986, </year> <month> 21-24 January). </month> <title> Compilers and staging transformations. </title> <booktitle> In Conference Record of POPL '86: The th th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 86-96. </pages>
Reference: <author> Jones, N. D., C. K. Gomard, and P. </author> <title> Sestoft (1993). Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: We end with a brief discussion of related work. 2 Program Staging The temporal separation of the computations of a program, or "staging," is usually done manually. A notable exception to this is partial evaluation <ref> (Jones, Gomard, and Ses-toft 1993) </ref>, in which the staging of programs is performed semiautomatically, according to a programmer-supplied indication of which program inputs will be available in the first stage of computation.
Reference: <author> Keppel, D., S. J. Eggers, and R. R. Henry (1993, Novem-ber). </author> <title> Evaluating runtime-compiled value-specific optimizations. </title> <type> Technical Report 93-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington. </institution>
Reference: <author> Kohlbecker, E., D. P. Friedman, M. Felleisen, and B. </author> <title> Duba (1986). Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 151-159. </pages>
Reference-contexts: The backquote and antiquote notation of Lisp macros, for example, provides an intuitive though highly error-prone approach to staged computation. A particularly nasty error is the inadvertent capture of variables, leading to the evaluation of variables in incorrect contexts. This has motivated relatively complex "hygienic" macro systems <ref> (Kohlbecker, Friedman, Felleisen, and Duba 1986) </ref>. Problems involving infinite expansion of macros are also quite common in practice. More recently, this notion of backquote/antiquote has been introduced as an extension to the C programming language, in the language `C (Engler, Hsieh, and Kaashoek 1996).
Reference: <author> Lee, P. and M. </author> <month> Leone </month> <year> (1996, </year> <month> May). </month> <title> Optimizing ML with run-time code generation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, Philadelphia, Pennsylva-nia, </booktitle> <pages> pp. 137-148. </pages>
Reference-contexts: While `C has an advantage over Lisp in providing a degree of static type checking, the fundamental problems of variable capture and infinite expansion remain. The Fabius system <ref> (Lee and Leone 1996) </ref> uses another approach to programmerspecified staging. <p> For reasons explained below, we would like to model the form of run-time code generation provided by the Fabius compiler <ref> (Lee and Leone 1996) </ref>, which does not manipulate source terms at run time. The design of an abstract machine for this kind of code generation must strike a delicate balance. On one hand, we want to abstract away from the details of individual architectures as much as possible. <p> This and other similar optimizations are performed, for example, by the Fabius compiler <ref> (Lee and Leone 1996) </ref>. We now consider the problem of nested code generators. <p> evalPoly (47; poly1) 807 specPoly poly1 443 poly1Target 47 175 compPoly poly1 553 eval codeGenerator 200 mlPolyFun 47 74 Table 1: Reduction steps on the CCAM for various functions in the text 8 Related Work The style of run-time specialization described in Section 5.1 is inspired by the Fabius system <ref> (Lee and Leone 1996) </ref>. Fabius compiles a pure, first-order subset of ML into native MIPS code. It chooses curried functions as the sites for specialization, compiling them into generating extensions parameterized by their early arguments.
Reference: <author> Leone, M. and P. </author> <title> Lee (1998). Dynamic specialization in the Fabius system. </title> <journal> ACM Computing Surveys 1998 Symposium on Partial Evaluation. </journal> <note> To appear. </note>
Reference-contexts: A compiler is free to augment the staging requirements from a hand-staged program using other means. * The language naturally handles situations in which more than two stages are desired, such as Fabius-style multistage specialization <ref> (Leone and Lee 1998) </ref>. This arises, for example, when dynamically generated code is used to compute values that are used in the special ization of yet more code. 3 Modal ML We briefly introduce the language ML 2 , our extension of MiniML 2 e (Davies and Pfenning 1996).
Reference: <author> Massalin, H. and C. </author> <title> Pu (1989, December). Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 191-201. </pages>
Reference-contexts: Obviously, this technique is extremely expensive. Less expensive schemes have been developed for run-time specialization, notably template filling, which is used by the Tempo system (Consel and Noel 1996) and the Synthesis kernel <ref> (Massalin and Pu 1989) </ref>. Template filling compiles selected parts of the program to sequences of machine code with "holes", that is, sections whose instructions need to be filled in at run time. These templates may then be copied and have their holes plugged to produce specialized machine code.
Reference: <author> McCanne, S. and V. Jacobson (1993, </author> <month> January). </month> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In The Winter 1993 USENIX Conference, </booktitle> <pages> pp. 259-269. </pages> <publisher> USENIX Association. </publisher>
Reference-contexts: A commonly adopted solution to this problem is to allow user-level processes to install a program that implements a selection predicate into the kernel's address space <ref> (McCanne and Jacobson 1993) </ref>. In order to ensure that the selection predicate will not corrupt internal kernel structures, the predicate must be expressed in a "safe" programming language. Unfortunately, this approach has a substantial overhead, since the safe programming language is typically implemented by a simple (and therefore easy-to-trust) interpreter. <p> To demonstrate this idea in our language, consider the following excerpt of the implementation of a simple interpreter for the BSD packet filter language <ref> (McCanne and Jacobson 1993) </ref> in ML. (* val evalpf : instruction array * * int array * * int * int * int -&gt; int * Return 1 to select packet, 0 to reject, * ~1 if error *) fun evalpf (filter, pkt, A, X, pc) = if pc &gt; length
Reference: <author> Pike, R., B. Locanthi, and J. Reiser (1985, </author> <month> February). </month> <title> Hardware/software trade-offs for bitmap graphics on the Blit. </title> <booktitle> Software | Practice and Experience 15 (2), </booktitle> <pages> 131-151. </pages>
Reference: <author> Sirer, E. G., S. Savage, P. Pardyak, G. P. DeFouw, and B. N. Bershad (1996, </author> <month> February). </month> <title> Writing an operating system with Modula-3. </title> <booktitle> In The Inaugural Workshop on Compiler Support for Systems Software, </booktitle> <pages> pp. 134-140. </pages>
Reference: <author> Taha, W. and T. </author> <title> Sheard (1997). Multistage programming with explicit annotations. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> Amsterdam, The Netherlands, </address> <month> June </month> <year> 1997, </year> <pages> pp. 203-217. </pages>
Reference: <author> Wickline, P., P. Lee, F. Pfenning, and R. </author> <title> Davies (1998). Modal types as staging specifications for run-time code generation. </title> <journal> ACM Computing Surveys 1998 Symposium on Partial Evaluation. </journal> <note> To appear. 12 </note>
References-found: 21

