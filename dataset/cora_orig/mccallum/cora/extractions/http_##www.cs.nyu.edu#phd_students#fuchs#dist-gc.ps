URL: http://www.cs.nyu.edu/phd_students/fuchs/dist-gc.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/fuchs/index.html
Root-URL: http://www.cs.nyu.edu
Email: fuchs@cerc.wvu.edu  
Title: Garbage Collection on an Open Network  
Author: Matthew Fuchs 
Address: Ridge Road, POB 6506; West  WV 26506 USA;  
Affiliation: Concurrent Engineering Research Center; 886 Chestnut  Virginia University; Morgantown,  
Abstract: We present a distributed garbage collection algorithm that eventually collects all cycles in an open network. As with recent reference counting algorithms, it explicitly maintain the distributed inverse reference graph (i.e., each object maintains a list of sites known to have references to it). We show that a modified depth-first traversal of this inverse graph is sufficient to locate any garbage it contains. We also provide a heuristic to control the frequency of distributed collections. The inverse graph has other uses, such as maintaining distributed consistency, which makes it particularly useful in a network where cooperation is not assured. Keywords: Distributed Garbage Collection, Memory Management of Dis tributed Objects
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. I. Bevan. </author> <title> Distributed garbage collection using reference counting. </title> <booktitle> In PARLE '87. </booktitle> <publisher> Springer Verlag LNCS 259, </publisher> <year> 1987. </year>
Reference-contexts: Garbage may need to be examined several times before being definitively established as garbage. Traditional RC requires increment and decrement messages; incorrectly ordered messages can lead to collection of live objects. Distributed RC algorithms, starting with weighted reference counting (WRC) <ref> [1, 13] </ref>, generally eliminate the increment messages. In WRC, each object is given a large value which is spread around when a reference is copied. Each outstanding reference contains a weight, and all these weights add up to the weight of the object.
Reference: 2. <author> Andrew Birrell et al. </author> <title> Distributed garbage collection for network objects. </title> <type> Technical Report 116, </type> <institution> DEC Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: Mark-and-sweep algorithms [7, 8, 10] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [5, 4, 9, 11, 2] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage.
Reference: 3. <author> David Chaiken. </author> <title> Cache coherence protocols for large-scale multiprocessors. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1990. </year>
Reference-contexts: The same information can be used to maintain consistent states among repli cated objects, as in a software cache consistency protocol <ref> [3] </ref>. 2. Nodes can implement a variety of garbage collection strategies, such as charging for the continued existence of an object, migrating objects to accessor nodes, or arbitrarily collecting an object and informing its referents of their dangling pointers.
Reference: 4. <author> H. Corporaal. </author> <title> Distributed heapmanagement using reference weights. In Distributed Memory Computing. </title> <publisher> Springer Verlag LNCS 487, </publisher> <year> 1991. </year>
Reference-contexts: Mark-and-sweep algorithms [7, 8, 10] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [5, 4, 9, 11, 2] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> Decrement messages are sent when remote references are collected and are accompanied by the former reference's weight. Because weights cannot be divided when they sink to one, the initial algorithm required indirection cells, proxies for the object with their own trees of references. A number of improvements and alternatives <ref> [5, 4, 9] </ref> have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [9] and continues with Shapiro et al.[11].
Reference: 5. <author> Benjamin Goldberg. </author> <title> Generational reference counting. </title> <booktitle> In Conference on Programming Language Design and Implementation. ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Mark-and-sweep algorithms [7, 8, 10] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [5, 4, 9, 11, 2] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> Decrement messages are sent when remote references are collected and are accompanied by the former reference's weight. Because weights cannot be divided when they sink to one, the initial algorithm required indirection cells, proxies for the object with their own trees of references. A number of improvements and alternatives <ref> [5, 4, 9] </ref> have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [9] and continues with Shapiro et al.[11].
Reference: 6. <author> Dennis Kafura et al. </author> <title> Garbage collection of actors. </title> <booktitle> In OOPSLA/ECOOP Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: For scaling to larger networks, the article proposes dividing the network into areas, each with its own server and a global server to sit above for inter-area references. Puaut [10] provides another client/server model for distributed collection of active objects. This extends Ka-fura's <ref> [6] </ref> algorithm for collecting agents by allowing lost messages and removing synchronization constraints. The various nodes of a system send timestamped information to a global collector containing intra-node edges. <p> Basic Algorithm, continued some of the back edges may actually be cross edges. A slight modification is also necessary to handle active objects, as neither the IRG nor the FRG is sufficient <ref> [6, 10] </ref>. If an active object is encountered, then it must traverse both its IRG and the FRG for which it is the root.
Reference: 7. <author> Rivka Ladin and Barbara Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In 12th Int. Conf. on Distributed Computing Systems. IEEE, </booktitle> <year> 1992. </year>
Reference-contexts: The final section contains the conclusion. 2 Related Work Distributed garbage collection algorithms generally follow one of the two techniques used for collecting a single address space: mark-and-sweep or reference counting. Mark-and-sweep algorithms <ref> [7, 8, 10] </ref> first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. <p> However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. Ladin and Liskov <ref> [7] </ref> gives an algorithm for collecting cyclical garbage using a client/server model. Distributed references are tracked by the server, which can use them to determine where garbage is.
Reference: 8. <author> Bernard Lang et al. </author> <title> Garbage collecting the world. </title> <booktitle> In 19th Symposium on Principles of Programming Languages. ACM, </booktitle> <year> 1992. </year>
Reference-contexts: The final section contains the conclusion. 2 Related Work Distributed garbage collection algorithms generally follow one of the two techniques used for collecting a single address space: mark-and-sweep or reference counting. Mark-and-sweep algorithms <ref> [7, 8, 10] </ref> first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage.
Reference: 9. <author> Jose M. Piquer. </author> <title> Indirect reference counting. </title> <booktitle> In PARLE '91. </booktitle> <publisher> Springer Verlag LNCS 505, </publisher> <year> 1991. </year>
Reference-contexts: The algorithm can be seen as an extension of Piquer <ref> [9] </ref> and Birrell et al.[2], both of which augment reference counting (RC) algorithms by maintaining the distributed inverse reference graph (IRG): each object, ff, maintains a list of pointers to other sites known to have references to it. <p> Mark-and-sweep algorithms [7, 8, 10] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [5, 4, 9, 11, 2] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> Decrement messages are sent when remote references are collected and are accompanied by the former reference's weight. Because weights cannot be divided when they sink to one, the initial algorithm required indirection cells, proxies for the object with their own trees of references. A number of improvements and alternatives <ref> [5, 4, 9] </ref> have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [9] and continues with Shapiro et al.[11]. <p> A number of improvements and alternatives [5, 4, 9] have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer <ref> [9] </ref> and continues with Shapiro et al.[11]. Scion-Stub Pointer Chains [11] exploit the use of parent pointers (called scions) to track where distributed references to an object reside. These parent pointers establish the inverse reference chain from an object to its accessors. <p> We are still examining how to use this heuristic to minimize the overhead of Distributed Garbage Collection. 9 Implementation Up to this point we have not discussed any actual implementation issues. In terms of data structures, we can reutilize the algorithms in Birrell et al.[2] and Piquer <ref> [9] </ref>. We should also be able to adapt the SSP Chains in Shapiro et al.[11]. The major local effort in producing an implementation will be establishing the IRG within each node, as this is normally not maintained.
Reference: 10. <author> Isabelle Puaut. </author> <title> Distributed Garbage Collection of Active Objects with no Global Synchronisation. </title> <booktitle> In International Workshop on Memory Management. </booktitle> <publisher> Springer Verlag LNCS 637, </publisher> <year> 1992. </year>
Reference-contexts: The final section contains the conclusion. 2 Related Work Distributed garbage collection algorithms generally follow one of the two techniques used for collecting a single address space: mark-and-sweep or reference counting. Mark-and-sweep algorithms <ref> [7, 8, 10] </ref> first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. <p> Distributed references are tracked by the server, which can use them to determine where garbage is. For scaling to larger networks, the article proposes dividing the network into areas, each with its own server and a global server to sit above for inter-area references. Puaut <ref> [10] </ref> provides another client/server model for distributed collection of active objects. This extends Ka-fura's [6] algorithm for collecting agents by allowing lost messages and removing synchronization constraints. The various nodes of a system send timestamped information to a global collector containing intra-node edges. <p> Basic Algorithm, continued some of the back edges may actually be cross edges. A slight modification is also necessary to handle active objects, as neither the IRG nor the FRG is sufficient <ref> [6, 10] </ref>. If an active object is encountered, then it must traverse both its IRG and the FRG for which it is the root.
Reference: 11. <author> Marc Shapiro et al. </author> <title> SSP Chains. </title> <booktitle> In Symposium on Principles of Distributed Computing. ACM, </booktitle> <year> 1992. </year>
Reference-contexts: Mark-and-sweep algorithms [7, 8, 10] first choose an area of distributed memory (although not blocking processing), determine the distributed root set, and organize inter-node references. Then they determine the transitive closure of the references from the root set. Everything else is garbage. Reference counting techniques <ref> [5, 4, 9, 11, 2] </ref> require much less coordination. However, they do not locate distributed cycles. Both kinds of algorithms generally have two phases. In the local phase, completely unreferenced objects are garbage collected. In the second phase inter-node information is propagated through the network, identifying more garbage. <p> A number of improvements and alternatives [5, 4, 9] have eliminated these. None of these algorithms handles cycles, and the object must trust the sender of the decrement message. A different approach starts with Piquer [9] and continues with Shapiro et al.<ref> [11] </ref>. Scion-Stub Pointer Chains [11] exploit the use of parent pointers (called scions) to track where distributed references to an object reside. These parent pointers establish the inverse reference chain from an object to its accessors.
Reference: 12. <author> Andrew Tannenbaum. </author> <title> Computer Networks, 2nd Ed. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: We will present an algorithm in which certain GCOs will block. Retreat is sim-pler and can be combined with a restart policy similar that used in CSMA/CD networks, such as Ethernet <ref> [12] </ref>. No performance bounds can be given for such an algorithm, but it might be quite practical in actual networks; a final judgement can only be given once real information is available about distributed object access patterns.
Reference: 13. <author> P. Watson and I. Watson. </author> <title> An efficient garbage collection scheme for parallel computer architectures. </title> <booktitle> In PARLE '87. </booktitle> <publisher> Springer Verlag LNCS 259, </publisher> <year> 1987. </year>
Reference-contexts: Garbage may need to be examined several times before being definitively established as garbage. Traditional RC requires increment and decrement messages; incorrectly ordered messages can lead to collection of live objects. Distributed RC algorithms, starting with weighted reference counting (WRC) <ref> [1, 13] </ref>, generally eliminate the increment messages. In WRC, each object is given a large value which is spread around when a reference is copied. Each outstanding reference contains a weight, and all these weights add up to the weight of the object.
Reference: 14. <author> Paul Wilson. </author> <title> Uniprocessor garbage collection techniques. Technical report, University of Texas. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Incremental algorithms which do not halt processing, such as the one we will present, are frequently explained in terms of a tri-color marking scheme <ref> [14] </ref>. In such schemes, persistent roots are initially colored grey and all other objects are white. The algorithm then describes how the children of grey objects are also turned grey. Whenever all of an object's children are grey, the object is turned black.
References-found: 14

