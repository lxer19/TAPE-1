URL: http://www.cs.nyu.edu/phd_students/wyckoff/ndss99.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/wyckoff/index.html
Root-URL: http://www.cs.nyu.edu
Title: Distributed Execution with Remote Audit  
Author: Fabian Monrose Peter Wyckoff Aviel D. Rubin 
Address: New York, NY Morristown, NJ Florham Park, NJ  
Affiliation: New York University Bellcore AT&T Labs Research  
Abstract: Recently, there has been a rapidly expanding body of work with the vision of seamlessly integrating idle networked computers into virtual computing environments. This is enabled primarily by the success of research efforts promoting parallel and distributed computing on networks of workstations and the wide acceptance of Java. The proliferation of work in this area has provided new Internet-based infrastructures that harness the power of computing bases comprising hundreds of loosely-connected volunteered machines (i.e., hosts). While many of these systems have proposed the use of non-altruistic market-based schemes for promoting large-scale participation, mechanisms for ensuring that hosts participating in collaborative computing environments perform the work assigned to them have been largely ignored. This paper presents our implementation of one framework that layers a remote audit mechanism on top of an existing distributed computing model, and provides efficient methods for verifying, with a tunable level of certainty, whether a remote host performed the task it was assigned. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and J. Feigenbaum. </author> <title> Secure Circuit Evaluation. </title> <journal> Journal of Cryptography, </journal> <volume> 2(1) </volume> <pages> 1-12, </pages> <year> 1990. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques [30, 39], even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin [34, 33] proposed the use of computing with encrypted functions <ref> [32, 1] </ref> to address the issues pertaining to publicly readable executable content. While the idea of computing with encrypted functions is appealing, numerous obstacles, both theoretical and practical, still need to be overcome before its application to mobile cryptography can be fully realized. <p> Since the de-mangling time is much less than that of typical coarse-grain parallel computations, this approach is not applicable to our goals. The approach of Sanders et al. [34, 33] for protecting mobile agents against malicious hosts is based on the idea of computing with encrypted functions <ref> [32, 1] </ref>. The intuition is as follows: given a function f (x) which can be represented by a program P , rather than distribute P , the encrypted function E (P ) is distributed instead. <p> DLSearch extends Thread f private int whoami, window, result=0; private final int prime = 9311, g=17, z = 5653; private int [] zp; /* variable which captures past computations */ B0: public static void main ( String args [] )f DLSearch d = new DLSearch (Integer.parseInt (args [0]), Integer.parseInt (args <ref> [1] </ref>)); g B1: DLSearch ( int who, int slice) f this.whoami = who; this.window = slice; this.setPriority ( 6 ); zp = new int [prime/window]; this.start (); g /* divide work based on striping technique */ B2: public void run () f int i = 0; B73: while ( (whoami+(i*window)) &lt;
Reference: [2] <author> N. Ahituv, Y. Lapid, and S. Neumann. </author> <title> Processing Encrypted Data. </title> <journal> Communications of the ACM, </journal> <volume> 30(9) </volume> <pages> 777-780, </pages> <year> 1987. </year>
Reference-contexts: The caveat is that computing with encrypted functions for general programs is an open problem and many strong arguments which largely discourage the idea of computing with encrypted data have already been put forth (see <ref> [2, 11, 32] </ref>). Furthermore, efficient encryption schemes with the desired homomorphic properties (see [34]) for arbitrary functions are not known and since P is executed in its encrypted form, exactly how this approach will be realized in practice is unclear.
Reference: [3] <author> Aho, Sethi, and Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: That is, there is at least one object (for example, an array) whose values correspond to the computation, and therefore, reflect the computation between traces. This ensures that successive traces include some actual state that was computed. 4.1.1 Code transformation Our compile-time module uses the control flow graph (CFG) <ref> [3] </ref> for a given computational component, P, to generate its corresponding checkable units. Intuitively, the key to the instrumentation process is: (1) the execution of the checkable units is captured in the traces and (2) each trace corresponds to the output of exactly one checkable unit.
Reference: [4] <author> T. E. Anderson, D. E. Culler, and D. A. Patter-son. </author> <title> A Case for Networks of Workstations: NOW. </title> <booktitle> IEEE Micro, </booktitle> <month> Feb </month> <year> 1995. </year>
Reference-contexts: The distinctive feature of this model is the exploitation of code mobility and mechanisms developed for parallel computing on loosely coupled machines <ref> [4] </ref>. Platforms that support Metacomputing, such as Atlas [7], Charlotte [8], Javelin [13], and ParaWeb [10] provide programming models that support the single-program-multiple-data (SPMD) computational model in heterogeneous computing environments.
Reference: [5] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction The popularity of the World Wide Web and Java <ref> [5, 25] </ref> has promoted a new model for distributing code | down-loadable active content. This new model has lead to a proliferation of research in Metacomputing, that is, the transparent integration of multiple computer platforms, possibly across geographically dispersed areas, into a single virtual computing environment.
Reference: [6] <author> S. Arora and S. Safra. </author> <title> Probabilistic Checking of Proofs. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-13. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Octo-ber </month> <year> 1992. </year>
Reference-contexts: Our contribution is in providing a more efficient execution environment for detecting misbehavior by hosts participating in Metacomputing infrastructures. A promising approach to improving the guarantees provided by our system involves the application of techniques such as those of Arora and Safra <ref> [6] </ref> for devising probabilistically checkable proofs (PCP) to the verification of the transitions between checkable units.
Reference: [7] <author> J. E. Baldeschwieler, R. D. Blumofe, and E. A. Brewer. </author> <title> ATLAS: An Infrastructure for Global Computing. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop on System Support for Worldwide Applications, </booktitle> <year> 1996. </year>
Reference-contexts: The distinctive feature of this model is the exploitation of code mobility and mechanisms developed for parallel computing on loosely coupled machines [4]. Platforms that support Metacomputing, such as Atlas <ref> [7] </ref>, Charlotte [8], Javelin [13], and ParaWeb [10] provide programming models that support the single-program-multiple-data (SPMD) computational model in heterogeneous computing environments.
Reference: [8] <author> A. Baratloo, M. Karaul, Z. M. Kedem, and P. Wyckoff. </author> <title> Charlotte: Metacomputing on the Web. </title> <booktitle> In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, </booktitle> <year> 1996. </year>
Reference-contexts: The distinctive feature of this model is the exploitation of code mobility and mechanisms developed for parallel computing on loosely coupled machines [4]. Platforms that support Metacomputing, such as Atlas [7], Charlotte <ref> [8] </ref>, Javelin [13], and ParaWeb [10] provide programming models that support the single-program-multiple-data (SPMD) computational model in heterogeneous computing environments. These platforms address the issues of scalability and fault tolerance, and for the most part, make efficient use of re sources for supporting parallel computation within the Java framework.
Reference: [9] <author> M. Blum and S. Kannan. </author> <title> Programs That Check Their Work. </title> <booktitle> In Proceedings of the Twenty First Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1989. </year>
Reference-contexts: The theory and ideas put forth in that research provide a sound formal background for work in this area. The work of Blum et al. <ref> [9] </ref>, on program checking is concerned with verifying that a given program returns a correct answer on a given input rather than on all inputs, and, with the adaption of interactive proof systems [19], provides the basic intuition for our work.
Reference: [10] <author> T. Brecht, H. Sandhu, M. Shan, and J. Talbot. ParaWeb: </author> <title> Towards World-Wide Supercomputing. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS Euro-pean Workshop on System Support for Worldwide Applications, </booktitle> <year> 1996. </year>
Reference-contexts: The distinctive feature of this model is the exploitation of code mobility and mechanisms developed for parallel computing on loosely coupled machines [4]. Platforms that support Metacomputing, such as Atlas [7], Charlotte [8], Javelin [13], and ParaWeb <ref> [10] </ref> provide programming models that support the single-program-multiple-data (SPMD) computational model in heterogeneous computing environments. These platforms address the issues of scalability and fault tolerance, and for the most part, make efficient use of re sources for supporting parallel computation within the Java framework.
Reference: [11] <author> Ernest F. Brickell and Yacov Yacobi. </author> <title> On Privacy Homomorphisms (Extended Abstract). </title> <booktitle> Eurocrypt, 1987. Abstracts: </booktitle> <address> IV-7-IV-14. </address>
Reference-contexts: The caveat is that computing with encrypted functions for general programs is an open problem and many strong arguments which largely discourage the idea of computing with encrypted data have already been put forth (see <ref> [2, 11, 32] </ref>). Furthermore, efficient encryption schemes with the desired homomorphic properties (see [34]) for arbitrary functions are not known and since P is executed in its encrypted form, exactly how this approach will be realized in practice is unclear.
Reference: [12] <author> Z. Budlimic and K. Kennedy. </author> <title> Optimizing Java: </title> <journal> Theory and Practice. Concurrency Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 445-464, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: This method specifies when a computational component's state should be saved and triggers the remote agent whenever this condition is true. Action S i is created based on simple data analysis techniques and can be overwritten by the programmer. Work on optimizing Java compilers <ref> [15, 12] </ref> utilize significantly more powerful analysis techniques than those we currently use, and we hope to borrow some design and implementation from their research to enhance our functionality. All objects are loaded on-demand across the network by the remote agent, transparently to the worker.
Reference: [13] <author> P. Capello, B. Christiansen, M. Ionescu, M. Neary, K. Schauser, and D. Wu. Javelin: </author> <title> Internet-Based Parallel Computing Using Java. </title> <booktitle> ACM Workshop on Java for Science and Engineering Computation, </booktitle> <year> 1997. </year>
Reference-contexts: The distinctive feature of this model is the exploitation of code mobility and mechanisms developed for parallel computing on loosely coupled machines [4]. Platforms that support Metacomputing, such as Atlas [7], Charlotte [8], Javelin <ref> [13] </ref>, and ParaWeb [10] provide programming models that support the single-program-multiple-data (SPMD) computational model in heterogeneous computing environments. These platforms address the issues of scalability and fault tolerance, and for the most part, make efficient use of re sources for supporting parallel computation within the Java framework.
Reference: [14] <institution> Center for Human-Machine System Research. </institution> <month> JavaPVM: </month> <title> The Java to PVM Interface, </title> <month> August </month> <year> 1997. </year>
Reference-contexts: In addition, the functionality provided by the remote debugging environment requires access to privileged system targets beyond the normal confines of the Java sandbox. However, in environments where the principals participating in distributed computations are represented by Java applications, as is the case with JavaPVM <ref> [14] </ref>, object signing is not an issue.
Reference: [15] <author> M. Cierniak and W. Li. </author> <title> Optimizing Java Byte-codes. </title> <journal> Concurrency Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 427-444, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: This method specifies when a computational component's state should be saved and triggers the remote agent whenever this condition is true. Action S i is created based on simple data analysis techniques and can be overwritten by the programmer. Work on optimizing Java compilers <ref> [15, 12] </ref> utilize significantly more powerful analysis techniques than those we currently use, and we hope to borrow some design and implementation from their research to enhance our functionality. All objects are loaded on-demand across the network by the remote agent, transparently to the worker.
Reference: [16] <author> Drew Dean, Ed Felten, and Dan Wallach. </author> <title> Java Security: From HotJava to Netscape and Beyond. </title> <booktitle> In Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 190-200, </pages> <year> 1996. </year>
Reference-contexts: To avoid this, we chose the most common Metacomputing environment implementation language, Java, as our runtime system's implementation platform. While a number of inherent security flaws have been outlined <ref> [26, 16, 23] </ref>, we provide a framework that assumes that these concerns will be resolved as Java matures; however, our verification technique will not be compromised even if a worker tampers with its JVM. 4.2.1 Remote monitoring Java.
Reference: [17] <author> W. Diffie and M. E. Hellman. </author> <title> New Directions in Cryptography. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 22(6) </volume> <pages> 644-654, </pages> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: validating traces is significantly less than the time it would take if the manager executed the entire component locally (i.e., spot-checking [35]). 5 Example: computing a dis- crete logarithm As proof of concept, we consider an example where a party, Alice, uses the same secret exponent (x) for multiple Diffie-Hellman <ref> [17] </ref> key exchanges. Mallot, Alice's adversary, has knowledge of this fact, and wants to impersonate Alice. However, he has only limited resources and exhaustively searching for the secret exponent is the only method available.
Reference: [18] <author> William Farmer, Joshua Guttman, and Vipin Swarup. </author> <title> Security for Mobile Agents: Issues and Requirements. </title> <booktitle> In Proceedings of the 19th National Information Systems Security Conference, </booktitle> <pages> pages 591-597, </pages> <year> 1996. </year>
Reference-contexts: misbehavior through the use of assertion mechanisms that rely on inserting secret keys within the active content, is inadequate | since the content distributed across these platforms must be readable by a potentially large group of hosts, the keys are also readable, and thus can be easily recovered and reused <ref> [18] </ref>. Furthermore, the availability of efficient decompila-tion techniques [30, 39], even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving.
Reference: [19] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proof Systems. </title> <booktitle> 17th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 291-304, </pages> <year> 1985. </year>
Reference-contexts: The work of Blum et al. [9], on program checking is concerned with verifying that a given program returns a correct answer on a given input rather than on all inputs, and, with the adaption of interactive proof systems <ref> [19] </ref>, provides the basic intuition for our work. Recently, research on validating remote execution has been conducted within the mobile agent framework.
Reference: [20] <author> Li Gong, M. Mueller, H. Prafullchandra, and R. Schemers. </author> <title> Going Beyond the Sandbox: An Overview of the New Security Architecture in the Java Development Kit 1.2. </title> <booktitle> In Proceedings of the USENIX Sysposium on Internet Technologies and Systems, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: Although the security policies which define the behavior of local versus remote code are being designed to be more flexible and extensible <ref> [21, 20] </ref>, if one intends to support this framework entirely within Java enabled browsers then issues pertaining to object signing, need to be taken into consideration. 8 Conclusion and future work In this paper, we presented a technique for auditing the execution of SPMD tasks in a distributed environment based on
Reference: [21] <author> Li Gong and Roland Schemers. </author> <title> Implementing Protection Domains in the Java Development Kit 1.2. </title> <booktitle> In Proc. Internet Society Symposium on Network and Distributed System Security, </booktitle> <pages> pages 125-134, </pages> <month> March </month> <year> 1998. </year>
Reference-contexts: Although the security policies which define the behavior of local versus remote code are being designed to be more flexible and extensible <ref> [21, 20] </ref>, if one intends to support this framework entirely within Java enabled browsers then issues pertaining to object signing, need to be taken into consideration. 8 Conclusion and future work In this paper, we presented a technique for auditing the execution of SPMD tasks in a distributed environment based on
Reference: [22] <author> Fritz Hohl. </author> <title> An Approach to Solve the Problem of Malicious Hosts. </title> <type> Technical Report TR-1997-03, </type> <institution> Universitat Stuttgart, Fakultat Informatik, Ger-many, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques [30, 39], even in light of code obfuscation <ref> [22] </ref>, make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin [34, 33] proposed the use of computing with encrypted functions [32, 1] to address the issues pertaining to publicly readable executable content. <p> Mobile agents are defined as processes which can autonomously migrate to new hosts while executing their task. Approaches to solve the problem of malicious hosts within these environments have been proposed by Hohl <ref> [22] </ref>, Sanders and Tschudin [34, 33], and Vigna [38]. To address the problem of misbehavior by hosts, Hohl [22] proposes a combination of code mess-up (i.e., obfuscation) and placing time critical restrictions on the mobile code. <p> Approaches to solve the problem of malicious hosts within these environments have been proposed by Hohl <ref> [22] </ref>, Sanders and Tschudin [34, 33], and Vigna [38]. To address the problem of misbehavior by hosts, Hohl [22] proposes a combination of code mess-up (i.e., obfuscation) and placing time critical restrictions on the mobile code. These restrictions are encapsulated as part of the code, with the intention that nodes which host agents comply with the restrictions placed on the code.
Reference: [23] <author> Mark D. Ladue. </author> <title> Java Insecurity. </title> <publisher> Computer Society, </publisher> <month> Spring </month> <year> 1997. </year>
Reference-contexts: To avoid this, we chose the most common Metacomputing environment implementation language, Java, as our runtime system's implementation platform. While a number of inherent security flaws have been outlined <ref> [26, 16, 23] </ref>, we provide a framework that assumes that these concerns will be resolved as Java matures; however, our verification technique will not be compromised even if a worker tampers with its JVM. 4.2.1 Remote monitoring Java.
Reference: [24] <author> C. J. Li and W. K. Fuchs. </author> <title> CATCH: Compiler-Assisted Techniques for Checkpointing. </title> <booktitle> In 20th International Symposium on Fault Tolerant Com--puting, </booktitle> <pages> pages 74-81, </pages> <year> 1990. </year>
Reference-contexts: Java is used as our platform for implementation because of its portability and heterogeneity. The fixed format of Java class files makes it ideal for recovering high-level structure [30] needed to build the CFGs. In a manner similar to the work on compiler-assisted checkpointing <ref> [24] </ref>, given the CFG our compile-time module adds the target nodes, i, of any back-edges to a set of breakpoint candidates S. Additionally, every exit node in P is added to S.
Reference: [25] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, California, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction The popularity of the World Wide Web and Java <ref> [5, 25] </ref> has promoted a new model for distributing code | down-loadable active content. This new model has lead to a proliferation of research in Metacomputing, that is, the transparent integration of multiple computer platforms, possibly across geographically dispersed areas, into a single virtual computing environment. <p> The Java model for remote debugging is depicted in Figure 3. The model consists of a debugger client, a debug-ger server, and a TCP/IP socket-based communication protocol. The API allows a process to connect and communicate with the JVM <ref> [25] </ref> of the target and obtain low-level information about the internal states of executing threads. All communication to and from the debugger server is performed over two socket connections created when the RemoteDebugger class is instantiated.
Reference: [26] <author> Gary McGraw and Edward Felten. </author> <title> Java Security: Hostile Applets, Holes and Antidotes. </title> <publisher> John Wiley and Sons. </publisher> <address> New York. New York, </address> <year> 1996. </year>
Reference-contexts: To avoid this, we chose the most common Metacomputing environment implementation language, Java, as our runtime system's implementation platform. While a number of inherent security flaws have been outlined <ref> [26, 16, 23] </ref>, we provide a framework that assumes that these concerns will be resolved as Java matures; however, our verification technique will not be compromised even if a worker tampers with its JVM. 4.2.1 Remote monitoring Java.
Reference: [27] <author> G. Medvinsky and B. C. Neuman. NetCash: </author> <title> A Design for Practical Electronic Currency on the Internet. </title> <booktitle> In Proceedings of the First ACM Conference on Computer and Communications Security, </booktitle> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: The payment mechanism is outside the scope of this paper. We assume that there is some arrangement between the manager and the workers, and payment is facilitated by some other mechanism (perhaps Net-Cash <ref> [27] </ref> or NetBill [36]). Our goal is to audit workers so that the manager can detect misbehavior.
Reference: [28] <author> Y. Minsky, R. van Renesse, F. B. Schneider, and S. D. Stoller. </author> <title> Cryptographic Support for Fault-Tolerant Distributed Computing. </title> <booktitle> In Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 109-114, </pages> <address> Connemara, Ireland, </address> <year> 1996. </year>
Reference-contexts: Although it is possible to provide simple result checkers for specific SPMD-style applications such as matrix multiplication and factoring, providing result checkers for arbitrary SPMD programs is not easily accomplished. With the exception of redundant computation and voting schemes <ref> [35, 28] </ref>, no additional mechanisms for verifying the work performed by remote hosts participating in coarse-grained parallel computations has yet been proposed.
Reference: [29] <author> J. Ousterhout, J. Levy, and B. Welch. </author> <title> The Safe-Tcl Security Model. </title> <type> Technical report, </type> <institution> Sun Mi-crosystems, </institution> <month> Nov </month> <year> 1996. </year>
Reference-contexts: Our implementation is Java-specific and makes use of the Java execution environment. However, the same principles and techniques could also be applied to other environments such as Safe-Tcl <ref> [29, 41] </ref>. Section 2 introduces a high-level overview of our model for verifying the work performed by remote hosts. Some preliminary work on mobile agent security, as well as other approaches within different contexts, but with similar desirable goals as ours, is presented in Section 3. <p> In the event that tampering of an agent's code is suspected, tampering can be proven by verifying the agent program against a supposed history of its execution i.e., simulating the entire program locally. The system is implemented in a restricted subset of Safe-Tcl <ref> [29] </ref> and tracing is accomplished by adding new instructions to the language. It is assumed that the code is static, therefore performance enhancements such as just-in-time compilation are not possible.
Reference: [30] <author> Todd A. Proebsting and Scott A. Watterson. </author> <title> Krakatoa: Decompilation in Java. </title> <booktitle> In Proceedings of the 3rd USENIX Conference on Object-Oriented Technologies and Systems, </booktitle> <pages> pages 185-197, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques <ref> [30, 39] </ref>, even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin [34, 33] proposed the use of computing with encrypted functions [32, 1] to address the issues pertaining to publicly readable executable content. <p> Java is used as our platform for implementation because of its portability and heterogeneity. The fixed format of Java class files makes it ideal for recovering high-level structure <ref> [30] </ref> needed to build the CFGs. In a manner similar to the work on compiler-assisted checkpointing [24], given the CFG our compile-time module adds the target nodes, i, of any back-edges to a set of breakpoint candidates S. Additionally, every exit node in P is added to S.
Reference: [31] <author> R. Riggs, J. Waldo, and A. Wollrath. </author> <title> Pickling State in Java. </title> <booktitle> In Proceedings of the 2nd Conference on Object-Oriented Technologies and Systems, </booktitle> <pages> pages 241-250, </pages> <address> Toronto, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The remote agent's task of capturing the state of the computational object in a serialized form suitable for transmission is accomplished through the use of an object serialization mechanism known as pickling <ref> [31] </ref>. The complementary process of unpickling is used by the verifier for initializing frames in its local call stack to those transmitted by the remote agent. 4.2.2 Verification The verifier is depicted in Figure 4.
Reference: [32] <author> R. Rivest, L. Adleman, and M. Dertouzos. </author> <title> On Data Banks and Privacy Homomorphisms. </title> <booktitle> Foundations of Secure Computation, </booktitle> <pages> pages 169-177, </pages> <year> 1978. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques [30, 39], even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin [34, 33] proposed the use of computing with encrypted functions <ref> [32, 1] </ref> to address the issues pertaining to publicly readable executable content. While the idea of computing with encrypted functions is appealing, numerous obstacles, both theoretical and practical, still need to be overcome before its application to mobile cryptography can be fully realized. <p> Since the de-mangling time is much less than that of typical coarse-grain parallel computations, this approach is not applicable to our goals. The approach of Sanders et al. [34, 33] for protecting mobile agents against malicious hosts is based on the idea of computing with encrypted functions <ref> [32, 1] </ref>. The intuition is as follows: given a function f (x) which can be represented by a program P , rather than distribute P , the encrypted function E (P ) is distributed instead. <p> The caveat is that computing with encrypted functions for general programs is an open problem and many strong arguments which largely discourage the idea of computing with encrypted data have already been put forth (see <ref> [2, 11, 32] </ref>). Furthermore, efficient encryption schemes with the desired homomorphic properties (see [34]) for arbitrary functions are not known and since P is executed in its encrypted form, exactly how this approach will be realized in practice is unclear.
Reference: [33] <author> T. Sanders and C. Tschudin. </author> <title> Protecting Mobile Agents Against Malicious Hosts. Mobile Agent Security, </title> <year> 1997. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques [30, 39], even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin <ref> [34, 33] </ref> proposed the use of computing with encrypted functions [32, 1] to address the issues pertaining to publicly readable executable content. <p> Mobile agents are defined as processes which can autonomously migrate to new hosts while executing their task. Approaches to solve the problem of malicious hosts within these environments have been proposed by Hohl [22], Sanders and Tschudin <ref> [34, 33] </ref>, and Vigna [38]. To address the problem of misbehavior by hosts, Hohl [22] proposes a combination of code mess-up (i.e., obfuscation) and placing time critical restrictions on the mobile code. <p> Since the de-mangling time is much less than that of typical coarse-grain parallel computations, this approach is not applicable to our goals. The approach of Sanders et al. <ref> [34, 33] </ref> for protecting mobile agents against malicious hosts is based on the idea of computing with encrypted functions [32, 1].
Reference: [34] <author> T. Sanders and C. Tschudin. </author> <title> Toward Mobile Cryptography. </title> <booktitle> IEEE Symposium on Security and Privacy, </booktitle> <year> 1998. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques [30, 39], even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin <ref> [34, 33] </ref> proposed the use of computing with encrypted functions [32, 1] to address the issues pertaining to publicly readable executable content. <p> Mobile agents are defined as processes which can autonomously migrate to new hosts while executing their task. Approaches to solve the problem of malicious hosts within these environments have been proposed by Hohl [22], Sanders and Tschudin <ref> [34, 33] </ref>, and Vigna [38]. To address the problem of misbehavior by hosts, Hohl [22] proposes a combination of code mess-up (i.e., obfuscation) and placing time critical restrictions on the mobile code. <p> Since the de-mangling time is much less than that of typical coarse-grain parallel computations, this approach is not applicable to our goals. The approach of Sanders et al. <ref> [34, 33] </ref> for protecting mobile agents against malicious hosts is based on the idea of computing with encrypted functions [32, 1]. <p> The caveat is that computing with encrypted functions for general programs is an open problem and many strong arguments which largely discourage the idea of computing with encrypted data have already been put forth (see [2, 11, 32]). Furthermore, efficient encryption schemes with the desired homomorphic properties (see <ref> [34] </ref>) for arbitrary functions are not known and since P is executed in its encrypted form, exactly how this approach will be realized in practice is unclear.
Reference: [35] <author> Luis F. G. Sarmenta. Bayanihan: </author> <title> Web-Based Volunteer Computing Using Java. </title> <booktitle> In Proceedings of the 2nd International Conference of World-Wide Computing and its Applications, </booktitle> <year> 1998. </year>
Reference-contexts: Although it is possible to provide simple result checkers for specific SPMD-style applications such as matrix multiplication and factoring, providing result checkers for arbitrary SPMD programs is not easily accomplished. With the exception of redundant computation and voting schemes <ref> [35, 28] </ref>, no additional mechanisms for verifying the work performed by remote hosts participating in coarse-grained parallel computations has yet been proposed. <p> The procedure may be repeated for any number of the remaining traces|depending on the level of assurance required by the manager. We show that the run-time associated with validating traces is significantly less than the time it would take if the manager executed the entire component locally (i.e., spot-checking <ref> [35] </ref>). 5 Example: computing a dis- crete logarithm As proof of concept, we consider an example where a party, Alice, uses the same secret exponent (x) for multiple Diffie-Hellman [17] key exchanges. Mallot, Alice's adversary, has knowledge of this fact, and wants to impersonate Alice. <p> Assume that the adversary wants to (or only has the resources to) execute 95% of the total work neccessary to complete the 100 jobs in their entirety. We compare the minimum probability of catching such a cheating worker in our system with spot checking <ref> [35] </ref>. The minimum probability of catching the worker is computed by finding the probability of catching a worker that is employing an optimal cheating strategy.
Reference: [36] <author> M. Sirbu and J. D. Tygar. Netbill: </author> <title> An Internet Commerce System Optimized for Network Delivered Service. </title> <journal> IEEE Personal Communications, </journal> <pages> pages 34-39, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: The payment mechanism is outside the scope of this paper. We assume that there is some arrangement between the manager and the workers, and payment is facilitated by some other mechanism (perhaps Net-Cash [27] or NetBill <ref> [36] </ref>). Our goal is to audit workers so that the manager can detect misbehavior.
Reference: [37] <author> Glenn Vanderburg. </author> <title> Tricks of the Java Programming Gurus. Sams Net, </title> <year> 1997. </year>
Reference: [38] <author> G. Vigna. </author> <title> Protecting Mobile Agents through Tracing. </title> <booktitle> In Proceedings of the 3rd Workshop on Mobile Object Systems, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Mobile agents are defined as processes which can autonomously migrate to new hosts while executing their task. Approaches to solve the problem of malicious hosts within these environments have been proposed by Hohl [22], Sanders and Tschudin [34, 33], and Vigna <ref> [38] </ref>. To address the problem of misbehavior by hosts, Hohl [22] proposes a combination of code mess-up (i.e., obfuscation) and placing time critical restrictions on the mobile code. <p> Furthermore, efficient encryption schemes with the desired homomorphic properties (see [34]) for arbitrary functions are not known and since P is executed in its encrypted form, exactly how this approach will be realized in practice is unclear. The solution put forth by Vigna <ref> [38] </ref> is to verify program execution by tracing the operations performed by a mobile agent during its lifetime. In Vigna's model, a roaming agent is composed of code and a state that is determined, at some specified point, by code execution.
Reference: [39] <author> Hanpeter van Vliet. The Mocha Decompiler, </author> <year> 1996. </year>
Reference-contexts: Furthermore, the availability of efficient decompila-tion techniques <ref> [30, 39] </ref>, even in light of code obfuscation [22], make these approaches unsatisfactory for deterring hosts from misbehaving. Recently, Sanders and Tschudin [34, 33] proposed the use of computing with encrypted functions [32, 1] to address the issues pertaining to publicly readable executable content.
Reference: [40] <author> Frank Yellin. </author> <title> Low Level Security in Java. </title> <booktitle> In Proceedings of the 4th International World Wide Web Conference, </booktitle> <address> Boston, Massachusetts, </address> <month> Decem-ber </month> <year> 1995. </year>
Reference-contexts: They support the execution of coarse-grained parallel computations on numerous anonymous machines on the Internet, and rely on Java's security architecture <ref> [40] </ref> to ensure safety to hosts. However, the issue of detecting misbehavior by hosts has been largely ignored. Although it is possible to provide simple result checkers for specific SPMD-style applications such as matrix multiplication and factoring, providing result checkers for arbitrary SPMD programs is not easily accomplished.
Reference: [41] <author> X. N. Zhang. </author> <title> Secure Code Distribution. </title> <journal> Computer, </journal> <volume> 30(6) </volume> <pages> 76-79, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Our implementation is Java-specific and makes use of the Java execution environment. However, the same principles and techniques could also be applied to other environments such as Safe-Tcl <ref> [29, 41] </ref>. Section 2 introduces a high-level overview of our model for verifying the work performed by remote hosts. Some preliminary work on mobile agent security, as well as other approaches within different contexts, but with similar desirable goals as ours, is presented in Section 3.
References-found: 41

