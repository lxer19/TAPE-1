URL: http://www-cad.eecs.berkeley.edu/~sriramr/orna.paper.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~sriramr/reading.html
Root-URL: 
Title: An Automata-Theoretic Approach to Branching-Time Model Checking  
Author: Orna Kupferman Moshe Y. Vardi Pierre Wolper 
Date: October 17, 1996  
Affiliation: UC Berkeley  Rice University  Universite de Liege  
Abstract: Translating linear temporal logic formulas to automata has proven to be an effective approach for implementing linear-time model-checking, and for obtaining many extensions and improvements to this verification method. On the other hand, for branching temporal logic, automata-theoretic techniques have long been thought to introduce an exponential penalty, making them essentially useless for model-checking. Recently, Bernholtz and Grum-berg have shown that this exponential penalty can be avoided, though they did not match the linear complexity of non-automata-theoretic algorithms. In this paper we show that alternating tree automata are the key to a comprehensive automata-theoretic framework for branching temporal logics. Not only, as was shown by Muller et al., can they be used to obtain optimal decision procedures, but, as we show here, they also make it possible to derive optimal model-checking algorithms. Moreover, the simple combinatorial structure that emerges from the automata-theoretic approach opens up new possibilities for the implementation of branching-time model checking, and has enabled us to derive improved space complexity bounds for this long-standing problem.
Abstract-found: 1
Intro-found: 1
Reference: [AB95] <author> H.R. Andersen and B.Vergauwen. </author> <title> Efficient checking of behavioral relations and modal assertions using fixed-point inversion. </title> <editor> In P. Wolper, editor, </editor> <booktitle> Computer Aided Verification, Proc. 7th Int. Conference, volume 939 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-154, </pages> <address> Liege, 1995. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: A similar approach, where Boolean graphs are used for model checking and for bisimulation checking is presented in <ref> [And92, Lar92, AB95] </ref>.
Reference: [And92] <author> H.R. Anderson. </author> <title> Model checking and boolean graphs. </title> <booktitle> In Proc. European Symposium on Programming (ESOP), volume 582 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A similar approach, where Boolean graphs are used for model checking and for bisimulation checking is presented in <ref> [And92, Lar92, AB95] </ref>.
Reference: [BB87] <editor> B. Banieqbal and H. Barringer. </editor> <title> Temporal logic with fixed points. </title> <editor> In B. Banieqbal, H. Bar-ringer, and A. Pnueli, editors, </editor> <booktitle> Temporal Logic in Specification, volume 398 of Lecture Notes in Computer Science, </booktitle> <pages> pages 62-74. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: For example, the formula y:(p_EXy) is guarded and the formula y:(p_y) is not guarded. We assume that all -calculus formulas are guarded. By the theorem below, stated without a proof in <ref> [BB87] </ref>, this can be done without loss of generality. Theorem 2.1 Given a -calculus formula, we can construct, in linear time, an equivalent guarded formula.
Reference: [BC96] <author> G. Bhat and R. Cleaveland. </author> <title> Efficient local model-checking for fragments of the modal - calculus. </title> <booktitle> In Proceedings of the 1996 Workshop on Tools and Algorithms for the Construction and Analysis of Systems, </booktitle> <year> 1996. </year>
Reference-contexts: For a -calculus sentence and a subformula ' = y:f (y) of , we define the alternation level of ' in , denoted al ('), as follows <ref> [BC96] </ref>. * If ' is a sentence, then al (') = 1. * Otherwise, let ~ = 0 x:g (x) be the innermost or - subformula of that has ' as a strict subformula. <p> Our transition relation is very similar to the one suggested in [EJ91]. Splitting the formulas in the right-hand side avoids the epsilon-transitions implicitly assumed there, and explicitly given in the proof rules in <ref> [BC96] </ref>. Indeed, the split guarantees that when the automaton is tracing a fixed-point formula ', it keeps visiting the state ' itself. * The Rabin acceptance condition is as in [BC96], dualizing the Streett condition in [EJ91]. Let d be the maximal alternation level of subformulas of . <p> the formulas in the right-hand side avoids the epsilon-transitions implicitly assumed there, and explicitly given in the proof rules in <ref> [BC96] </ref>. Indeed, the split guarantees that when the automaton is tracing a fixed-point formula ', it keeps visiting the state ' itself. * The Rabin acceptance condition is as in [BC96], dualizing the Streett condition in [EJ91]. Let d be the maximal alternation level of subformulas of . Denote by G i the set of all the --formulas in cl ( ) of alternation level i. <p> The proof of the construction is given, in terms of LTL model checking of And-Or Kripke structures, in <ref> [BC96] </ref>. Theorem 4.9 The 1-letter nonemptiness problem for alternating Rabin word automata is decidable in nondeterministic polynomial running time. Proof: According to Theorem 3.1, the 1-letter nonemptiness problem for alternating Rabin word automata is of the same complexity as the nonemptiness problem for nondeterministic Rabin tree automata.
Reference: [Bee80] <author> C. Beeri. </author> <title> On the membership problem for functional and multivalued dependencies in relational databases. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 5 </volume> <pages> 241-259, </pages> <year> 1980. </year> <month> 46 </month>
Reference-contexts: Using an AND/OR graph, as suggested in <ref> [Bee80] </ref>, the algorithm can be implemented in linear running time. The graph, G, induced by the transition function, maintains the labeling and the propagation of labeling performed during the algorithm execution. In more details, each node of G corresponds to a state q 2 Q.
Reference: [BG93] <author> O. Bernholtz and O. Grumberg. </author> <title> Branching time temporal logic and amorphous tree au-tomata. </title> <booktitle> In Proc. 4th Conferance on Concurrency Theory, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 262-277, </pages> <address> Hildesheim, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: can only yield algorithms which are far from optimal. (Indeed, the proof in [EJS93] avoids the construction of tree automata that correspond to -calculus formulas.) A different automata-theoretic approach to branching-time model checking, based on the concepts of amorphous automata and simultaneous trees, was suggested by Bernholtz and Grum-berg in <ref> [BG93] </ref>. Amorphous automata have a flexible transition relation that can adapt to trees with varying branching degree. Simultaneous trees are trees in which each sub-tree is duplicated twice as the two leftmost successors of its root.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchroniza tion and communication protocols can be modeled as finite-state programs, as well as from the fl Address: EECS Department, Berkeley, CA 94720-1770, U.S.A. Email: orna@ic.eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A. <p> Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. Indeed, model checking can be done in linear running time for CTL <ref> [CES86, QS81] </ref> and for the alternation-free fragment of the -calculus [Cle93], and is in NP"co-NP for the general -calculus [EJS93], whereas there is an exponential blow-up involved in going from formulas to automata. <p> We prove here that the 1-letter nonemptiness of alternating Rabin word automata is in NP, which entails that model checking of -calculus formulas is in NP"co-NP. 3 As the algorithms obtained by our approach match known complexity bounds for branching temporal logics <ref> [CES86, Cle93, EJS93] </ref>, what are the advantages offered by our approach? The first advantage is that it immediately broadens the scope of efficient model checking to other, and more expressive, branching temporal logics. <p> follows that the size of the transitions in A K; is bounded by jRj j j, implying its linear size. the algorithm used in the proof of Theorem 4.7 is clearly reminiscent of the bottom-up labeling that takes place in the standard algorithms for CTL and alternation-free -calculus model checking <ref> [CES86, Cle93] </ref>. Thus, the automata-theoretic approach seems to capture the combinatorial essence of branching-time model checking. 4.2 Model Checking for the -Calculus The intimate connection between the -calculus and alternating automata has been noted in [EJ91, Eme94].
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model-checking algorithms. </title> <booktitle> In Proc. 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: Theorem 5.9 The 1-letter nonemptiness problem for weak alternating word automata is P-complete. Proof: Membership in P follows from Theorem 4.7. Hardness in P follows by a reduction from the Alternating Graph Accessibility problem, proved to be P-complete in <ref> [Imm81, CKS81, GHR95] </ref>, to nonemptiness of weak alternating word automata. In the Alternating Graph Accessibility problem, we are given a directed graph G = hV; Ei, a partition E [ U of V , and two designated vertices s and t. <p> Proof: Clearly, the problem can be solved in EXPTIME by building the nondeterministic program corresponding to the concurrent program and using the model-checking algorithm from Section 4.1. To prove that it is hard in EXPTIME, we do a reduction from alternating linear-space Turing machines, proved to be EXPTIME-hard in <ref> [CKS81] </ref>.
Reference: [Cle93] <author> R. Cleaveland. </author> <title> A linear-time model-checking algorithm for the alternation-free modal - calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2 </volume> <pages> 121-147, </pages> <year> 1993. </year>
Reference-contexts: Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. Indeed, model checking can be done in linear running time for CTL [CES86, QS81] and for the alternation-free fragment of the -calculus <ref> [Cle93] </ref>, and is in NP"co-NP for the general -calculus [EJS93], whereas there is an exponential blow-up involved in going from formulas to automata. Similarly, while model checking for the full branching time logic CTL fl is PSPACE-complete, going from CTL fl formulas to automata involves a doubly-exponential blow up [ES84]. <p> We prove here that the 1-letter nonemptiness of alternating Rabin word automata is in NP, which entails that model checking of -calculus formulas is in NP"co-NP. 3 As the algorithms obtained by our approach match known complexity bounds for branching temporal logics <ref> [CES86, Cle93, EJS93] </ref>, what are the advantages offered by our approach? The first advantage is that it immediately broadens the scope of efficient model checking to other, and more expressive, branching temporal logics. <p> follows that the size of the transitions in A K; is bounded by jRj j j, implying its linear size. the algorithm used in the proof of Theorem 4.7 is clearly reminiscent of the bottom-up labeling that takes place in the standard algorithms for CTL and alternation-free -calculus model checking <ref> [CES86, Cle93] </ref>. Thus, the automata-theoretic approach seems to capture the combinatorial essence of branching-time model checking. 4.2 Model Checking for the -Calculus The intimate connection between the -calculus and alternating automata has been noted in [EJ91, Eme94].
Reference: [CVWY92] <author> C. Courcoubetis, M.Y. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year>
Reference-contexts: This enables the reduction of linear temporal logic problems, such as satisfiability and model-checking, to known automata-theoretic problems, yielding clean and asymptotically optimal algorithms. Furthermore, these reductions are very helpful for implementing temporal-logic based verification methods, and are the key to techniques such as on-the-fly verification <ref> [VW86a, JJ89, CVWY92] </ref> that help coping with the "state-explosion" problem. For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics [Eme85, EJ88, ES84, SE84, VW86b]. <p> Pragmatically, this is very significant and is, to some extent, exploited in the "on the fly" approaches to model checking and in related memory saving techniques <ref> [CVWY92, MP94] </ref>. Is the same true of branching-time model-checking? The answer to this question was long thought to be negative. Indeed, the bottom-up nature of the known model-checking algorithms seemed to imply that storing the whole structure was required.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: Accordingly, we show that for this logic, as well as for the general -calculus, model checking for concurrent programs is EXPTIME-complete. 2 Preliminaries 2.1 Temporal Logics and -Calculi 2.1.1 The Temporal Logics CTL fl and CTL The logic CTL fl combines both branching-time and linear-time operators <ref> [EH86] </ref>. A path quantifier, either A ("for all paths") or E ("for some path"), can prefix an assertion composed of 4 an arbitrary combination of the linear-time operators X ("next time"), and U ("until").
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 328-337, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics <ref> [Eme85, EJ88, ES84, SE84, VW86b] </ref>. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking.
Reference: [EJ91] <author> E.A. Emerson and C. Jutla. </author> <title> Tree automata, mu-calculus and determinacy. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> San Juan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: It is known that while the translation from branching temporal logic formulas to nondeterministic tree automata is exponential, the translation to alternating tree automata is linear <ref> [MSS88, EJ91] </ref>. In fact, Emerson stated that "-calculus formulas are simply alternating tree automata" [Eme94]. Muller et al. showed that this explains the exponential decidability of satisfiability for various branching temporal logics. We show here that this also explains the efficiency of model checking for those logics. <p> We present a linear translation from alternation-free -calculus formulas to weak alternating automata. This implies, using the same technique, that model checking for this logic can be done in linear running time. For the general -calculus, it follows from the results in <ref> [EJ91] </ref> that -calculus formulas can be linearly translated to alternating Rabin automata. <p> Thus, the automata-theoretic approach seems to capture the combinatorial essence of branching-time model checking. 4.2 Model Checking for the -Calculus The intimate connection between the -calculus and alternating automata has been noted in <ref> [EJ91, Eme94] </ref>. We show here that our automata-theoretic approach provides a clean proof that model checking for the -calculus is in NP"co-NP. <p> Our transition relation is very similar to the one suggested in <ref> [EJ91] </ref>. Splitting the formulas in the right-hand side avoids the epsilon-transitions implicitly assumed there, and explicitly given in the proof rules in [BC96]. <p> Indeed, the split guarantees that when the automaton is tracing a fixed-point formula ', it keeps visiting the state ' itself. * The Rabin acceptance condition is as in [BC96], dualizing the Streett condition in <ref> [EJ91] </ref>. Let d be the maximal alternation level of subformulas of . Denote by G i the set of all the --formulas in cl ( ) of alternation level i.
Reference: [EJS93] <author> E.A. Emerson, C. Jutla, and A.P. Sistla. </author> <title> On model-checking for fragments of -calculus. </title> <booktitle> In Computer Aided Verification, Proc. 5th Int. Workshop, </booktitle> <volume> volume 697, </volume> <pages> pages 385-396, </pages> <address> Elounda, Crete, </address> <month> June </month> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. Indeed, model checking can be done in linear running time for CTL [CES86, QS81] and for the alternation-free fragment of the -calculus [Cle93], and is in NP"co-NP for the general -calculus <ref> [EJS93] </ref>, whereas there is an exponential blow-up involved in going from formulas to automata. Similarly, while model checking for the full branching time logic CTL fl is PSPACE-complete, going from CTL fl formulas to automata involves a doubly-exponential blow up [ES84]. <p> Thus, using the construction of a tree automaton as a step in a model-checking algorithm seems a non-starter, which can only yield algorithms which are far from optimal. (Indeed, the proof in <ref> [EJS93] </ref> avoids the construction of tree automata that correspond to -calculus formulas.) A different automata-theoretic approach to branching-time model checking, based on the concepts of amorphous automata and simultaneous trees, was suggested by Bernholtz and Grum-berg in [BG93]. <p> We prove here that the 1-letter nonemptiness of alternating Rabin word automata is in NP, which entails that model checking of -calculus formulas is in NP"co-NP. 3 As the algorithms obtained by our approach match known complexity bounds for branching temporal logics <ref> [CES86, Cle93, EJS93] </ref>, what are the advantages offered by our approach? The first advantage is that it immediately broadens the scope of efficient model checking to other, and more expressive, branching temporal logics. <p> As in the previous direction, it is easy to see that hT r ; r 0 i is an accepting run of A D; over hT K ; V K i. Proposition 3.2 can be viewed as an automata-theoretic generalization of Theorem 4.1 in <ref> [EJS93] </ref>. <p> Proof: According to Theorem 3.1, the 1-letter nonemptiness problem for alternating Rabin word automata is of the same complexity as the nonemptiness problem for nondeterministic Rabin tree automata. By [Eme85, VS85], the later is in NP. Combining Theorems 4.8 and 4.9, Proposition 3.2, and the observation in <ref> [EJS93] </ref> that checking for satisfaction of a formula and a formula : has the same complexity, we get that the model-checking problem for the -calculus is in NP"co-NP. 29 5 The Space Complexity of Model Checking Pnueli and Lichtenstein argued that when analyzing the complexity of model checking, a distinction should
Reference: [EL86] <author> E.A. Emerson and C.-L. Lei. </author> <title> Efficient model checking in fragments of the proposoitional mu-calculus. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Proof: Clearly, hardness in EXPTIME follows from Theorem 6.3. To prove membership in EXPTIME we use the algorithm suggested in <ref> [EL86] </ref>. Given a concurrent program P and a - calculus formula , the size of a Kripke structure K that models the nondeterministic expansion of P is of size exponential in the size of P . According to [EL86], model checking of a Kripke structure K with respect to a -calculus <p> To prove membership in EXPTIME we use the algorithm suggested in <ref> [EL86] </ref>. Given a concurrent program P and a - calculus formula , the size of a Kripke structure K that models the nondeterministic expansion of P is of size exponential in the size of P . According to [EL86], model checking of a Kripke structure K with respect to a -calculus formula is of time complexity O ((k k fl kKk) n+1 ), where n is the alternation depth of . <p> The alternation depth of a formula is the maximal number of alternations between and on any syntactic path from an occurrence of y or -y to an occurrence of y (see <ref> [EL86] </ref>). We clearly have that n &lt; k k and, therefore, model checking of K with respect to is of time complexity O ((k k fl 2 jP j ) k k ).
Reference: [Eme85] <author> E.A. Emerson. </author> <title> Automata, tableaux, and temporal logics. In Logic of Programs, </title> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 79-87. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics <ref> [Eme85, EJ88, ES84, SE84, VW86b] </ref>. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. <p> Theorem 4.9 The 1-letter nonemptiness problem for alternating Rabin word automata is decidable in nondeterministic polynomial running time. Proof: According to Theorem 3.1, the 1-letter nonemptiness problem for alternating Rabin word automata is of the same complexity as the nonemptiness problem for nondeterministic Rabin tree automata. By <ref> [Eme85, VS85] </ref>, the later is in NP.
Reference: [Eme94] <author> E.A. Emerson. </author> <title> Automated temporal reasoning about reactive systems. </title> <booktitle> In VIII-th BANFF Higher Order Workshop, </booktitle> <year> 1994. </year> <note> unpublished abstract of forthcoming talk. </note>
Reference-contexts: It is known that while the translation from branching temporal logic formulas to nondeterministic tree automata is exponential, the translation to alternating tree automata is linear [MSS88, EJ91]. In fact, Emerson stated that "-calculus formulas are simply alternating tree automata" <ref> [Eme94] </ref>. Muller et al. showed that this explains the exponential decidability of satisfiability for various branching temporal logics. We show here that this also explains the efficiency of model checking for those logics. <p> Thus, the automata-theoretic approach seems to capture the combinatorial essence of branching-time model checking. 4.2 Model Checking for the -Calculus The intimate connection between the -calculus and alternating automata has been noted in <ref> [EJ91, Eme94] </ref>. We show here that our automata-theoretic approach provides a clean proof that model checking for the -calculus is in NP"co-NP.
Reference: [ES84] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 14-24, </pages> <address> Washington, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics <ref> [Eme85, EJ88, ES84, SE84, VW86b] </ref>. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. <p> Similarly, while model checking for the full branching time logic CTL fl is PSPACE-complete, going from CTL fl formulas to automata involves a doubly-exponential blow up <ref> [ES84] </ref>. <p> It is easy to see that all the paths in such hT r ; ri are either finite or reach a state associated with a ~ U -formula and stay there thereafter. Thus, hT r ; ri is accepting. 21 By the sufficient degree property <ref> [ES84] </ref>, a CTL formula is satisfiable if and only if it is satisfied in an fng-tree, where n is the number of occurrences of the path quantifier E in . Hence, satisfiability of can be reduced to the nonemptiness of A fng; .
Reference: [FL79] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: We first consider the general nonemptiness problem for them. Theorem 4.6 The nonemptiness problem for weak alternating automata is EXPTIME-complete. Proof: Membership in EXPTIME is proved in [MSS86]. Hardness in EXPTIME follows from reduction of satisfiability of CTL, proved to be EXPTIME-hard in <ref> [FL79] </ref>. Thus, the general nonemptiness problem for WAAs, the one required for solving the sat-isfiability problem, cannot be solved efficiently. Doing model checking, we do not have to solve the general nonemptiness problem. Taking the product with the Kripke structure, we get a 1-letter WAA over words.
Reference: [GHR95] <author> R. Greenlaw, H.J. Hoover, and W.L. Ruzzo. </author> <title> Limits of parallel computation. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Theorem 5.9 The 1-letter nonemptiness problem for weak alternating word automata is P-complete. Proof: Membership in P follows from Theorem 4.7. Hardness in P follows by a reduction from the Alternating Graph Accessibility problem, proved to be P-complete in <ref> [Imm81, CKS81, GHR95] </ref>, to nonemptiness of weak alternating word automata. In the Alternating Graph Accessibility problem, we are given a directed graph G = hV; Ei, a partition E [ U of V , and two designated vertices s and t.
Reference: [Imm81] <author> N. Immerman. </author> <title> Number of quantifiers is better than number of tape cells. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 22(3) </volume> <pages> 384-406, </pages> <year> 1981. </year> <month> 47 </month>
Reference-contexts: Theorem 5.9 The 1-letter nonemptiness problem for weak alternating word automata is P-complete. Proof: Membership in P follows from Theorem 4.7. Hardness in P follows by a reduction from the Alternating Graph Accessibility problem, proved to be P-complete in <ref> [Imm81, CKS81, GHR95] </ref>, to nonemptiness of weak alternating word automata. In the Alternating Graph Accessibility problem, we are given a directed graph G = hV; Ei, a partition E [ U of V , and two designated vertices s and t.
Reference: [JJ89] <author> C. Jard and T. Jeron. </author> <title> On-line model-checking for finite linear temporal logic specifications. In Automatic Verification Methods for Finite State Systems, </title> <booktitle> Proc. Int. Workshop, Greno-ble, </booktitle> <volume> volume 407, </volume> <pages> pages 189-196, </pages> <address> Grenoble, </address> <month> June </month> <year> 1989. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This enables the reduction of linear temporal logic problems, such as satisfiability and model-checking, to known automata-theoretic problems, yielding clean and asymptotically optimal algorithms. Furthermore, these reductions are very helpful for implementing temporal-logic based verification methods, and are the key to techniques such as on-the-fly verification <ref> [VW86a, JJ89, CVWY92] </ref> that help coping with the "state-explosion" problem. For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics [Eme85, EJ88, ES84, SE84, VW86b].
Reference: [Jon75] <author> N.D. Jones. </author> <title> Space-bounded reducibility among combinatorial problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 11 </volume> <pages> 68-75, </pages> <year> 1975. </year>
Reference-contexts: Thus, determining whether a certain state in Q i is immediately reachable from another certain state in Q i , assuming we have Boolean values for all states in sets lower than Q i , can be done nondeterministically using space O (log n). It is known, by <ref> [Jon75] </ref>, that the graph accessibility problem is in NLOGSPACE. Now, to check whether q 00 is reachable from q 0 , we restrict the graph accessibility test, replacing immediate accessibility with immediate reachability. <p> Thus, so is the program complexity of CTL and CTL fl model checking. Hardness in NLOGSPACE is immediate by a reduction from the graph accessibility problem, proved to be NLOGSPACE-complete in <ref> [Jon75] </ref>. The fact that CTL and CTL fl formulas can be translated to HAAs plays a crucial role in our upper bounds. To see this, we prove in Theorem 5.9 bellow, that the 1-letter nonemptiness problem for weak alternating word automata is P-complete.
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: Another way to understand the ~ U operator is to interpret 1 ~ U 2 by "as long as 1 is false, 2 must be true". 2.1.2 The Propositional -calculus The propositional -calculus is a propositional modal logic augmented with least and greatest fixpoint operators <ref> [Koz83] </ref>. Specifically, we consider a -calculus where formulas are constructed from Boolean propositions with Boolean connectives, the temporal operators EX and AX, as 6 well as least () and greatest (-) fixpoint operators. <p> For example, for ' = y:(q _ (p ^ EXy)), cl (') = f'; q _ (p ^ EX'); q; p ^ EX'; p; EX'g. As proved in <ref> [Koz83] </ref>, for every -calculus formula ', we have that the number of elements in cl (') is linear in the size k'k of '.
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of programs. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in [CG87, Wol89]. We distinguish between two types of temporal logics: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [Lar92] <author> K.G. Larsen. </author> <title> Efficient local correctness checking. </title> <booktitle> In Proc. 4th Workshop on Computer Aided Verification, volume 663 of Lecture Notes in Computer Science, </booktitle> <pages> pages 30-43, </pages> <address> Montreal, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A similar approach, where Boolean graphs are used for model checking and for bisimulation checking is presented in <ref> [And92, Lar92, AB95] </ref>.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchroniza tion and communication protocols can be modeled as finite-state programs, as well as from the fl Address: EECS Department, Berkeley, CA 94720-1770, U.S.A. Email: orna@ic.eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A. <p> and Lichtenstein argued that when analyzing the complexity of model checking, a distinction should be made between complexity in the size of the input structure and complexity in the size of the input formula; it is the complexity in the size of the structure that is typically the computational bottleneck <ref> [LP85] </ref> 2 . The Kripke structures to which model-checking is applied are often obtained by constructing the reachability graph of concurrent programs, and can thus be very large. So, even linear complexity, in terms of the input structure, can be excessive, especially as far as space is concerned.
Reference: [Lyn77] <author> N. Lynch. </author> <title> Log space recognition and translation of parenthesis languages. </title> <journal> J. ACM, </journal> <volume> 24 </volume> <pages> 583-590, </pages> <year> 1977. </year>
Reference-contexts: We start with q that belongs to a transient set. There, we have to evaluate the transition from q. It is known that the problem of evaluating Boolean expressions is in NLOGSPACE <ref> [Lyn77] </ref>. Here, we evaluate expressions over Q and the length of each expression is linear in n.
Reference: [MH84] <author> S. Miyano and T. Hayashi. </author> <title> Alternating finite automata on !-words. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 321-330, </pages> <year> 1984. </year>
Reference-contexts: Taking the product with the Kripke structure, we get a 1-letter WAA over words. As we prove below, the nonemptiness these automata can be solved in linear time. We note that the general nonemptiness problem for WAA over words is PSPACE-complete <ref> [MH84] </ref>, which is still unsatisfactory. Thus, the transition to a 1-letter automaton is essential. Also, as follows from Theorem 3.1, the best upper-bound known for 1-letter nonemptiness of Buchi alternating word automata is quadratic [VW86a]. Thus, the weakness of the automaton is also essential.
Reference: [MP94] <author> M. Mihail and C.H. Papademitriou. </author> <title> On the random walk method for protocol testing. </title> <booktitle> In Proc. 5th Workshop on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 132-141, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Pragmatically, this is very significant and is, to some extent, exploited in the "on the fly" approaches to model checking and in related memory saving techniques <ref> [CVWY92, MP94] </ref>. Is the same true of branching-time model-checking? The answer to this question was long thought to be negative. Indeed, the bottom-up nature of the known model-checking algorithms seemed to imply that storing the whole structure was required.
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: Given a set D IN, a D-tree is a computation tree in which all the nodes have degree in D. Automata over infinite trees (tree automata) run over -labeled trees that have no leaves. Alternating automata generalize nondeterministic tree automata and were first introduced in <ref> [MS87] </ref>. For simplicity, we refer first to automata over binary trees (i.e., when T = f0; 1g fl ). Consider a nondeterministic tree automaton A = h; Q; ffi; q 0 ; F i. <p> In <ref> [MS87] </ref>, Muller and Schupp prove that ~ A complements A. We prove here that when A is a HAA with F = hG; Bi, then ~ F = hB; Gi satisfies the required property. Consider a path in a run of A.
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating automata, the weak monadic theory of the tree and its complexity. </title> <editor> In L. Kott, editor, </editor> <booktitle> Automata, Languages and Programming, Proc. 13th Int. Colloquium (ICALP '86), volume 226 of Lecture Notes in Computer Science, </booktitle> <pages> pages 275-283. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: To obtain an exponential decision procedure for the satisfiability of CTL and related branching temporal logics, Muller et al. used the fact that the nonemptiness problem for these automata is in exponential time <ref> [MSS86] </ref>. (In fact, as we show here, it is EXPTIME-complete.) We prove that the 1-letter nonemptiness of weak alternating word automata is decidable in linear running time, which yields an automata-based model checking algorithm of linear running time for CTL. <p> Formally, we define an alternating automaton over infinite words as A = h; Q; ffi; q 0 ; F i where ffi : Q fi ! B + (Q). In <ref> [MSS86] </ref>, Muller et al. introduce weak alternating automata (WAAs). <p> Hence, satisfiability of can be reduced to the nonemptiness of A fng; . As the nonemptiness problem for WAAs is in exponential time <ref> [MSS86] </ref>, the above described WAAs provide also an exponential-time satisfiability procedure for CTL. Example 4.2 Consider the CTL formula = A (trueU (Afalse ~ U p)). <p> We now turn to study the complexity of the nonemptiness problem for WAAs. We first consider the general nonemptiness problem for them. Theorem 4.6 The nonemptiness problem for weak alternating automata is EXPTIME-complete. Proof: Membership in EXPTIME is proved in <ref> [MSS86] </ref>. Hardness in EXPTIME follows from reduction of satisfiability of CTL, proved to be EXPTIME-hard in [FL79]. Thus, the general nonemptiness problem for WAAs, the one required for solving the sat-isfiability problem, cannot be solved efficiently. Doing model checking, we do not have to solve the general nonemptiness problem. <p> Since each set in the HAA corresponds to a single formula in cl ( ), the depth of the HAA is at most k k. We now present a translation of CTL fl formulas to HAAs. Weak alternating automata define exactly the set of weakly definable languages <ref> [MSS86] </ref>. The logic CTL fl can define languages that are not weakly definable. For example, the set of trees that satisfy the CTL fl formula AF Gp is not weakly definable [Rab70]. Therefore, a stronger acceptance condition is required for automata corresponding to formulas of CTL fl .
Reference: [MSS88] <author> D. E. Muller, A. Saoudi, and P. E. Schupp. </author> <title> Weak alternating automata give a simple explanation of why most temporal and dynamic logics are decidable in exponential time. </title> <booktitle> In Proceedings 3rd IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 422-427, </pages> <address> Edinburgh, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: It is known that while the translation from branching temporal logic formulas to nondeterministic tree automata is exponential, the translation to alternating tree automata is linear <ref> [MSS88, EJ91] </ref>. In fact, Emerson stated that "-calculus formulas are simply alternating tree automata" [Eme94]. Muller et al. showed that this explains the exponential decidability of satisfiability for various branching temporal logics. We show here that this also explains the efficiency of model checking for those logics. <p> Thus, alternating automata provide a unifying and optimal framework for both the satisfiability and model-checking problems for branching temporal logic. We first show how our automata-theoretic approach unifies previously known results about model checking for branching temporal logics. The alternating automata used by Muller et al. in <ref> [MSS88] </ref> are of a restricted type called weak alternating automata. <p> For example, the dynamic logic considered in <ref> [MSS88] </ref> allows, in the spirit of [Wol83], nondeterministic tree automata as operators. Since this logic has a linear translation to weak alternating automata, it follows directly from our results that it also has a linear model-checking algorithm. <p> Muller et al. provided a simpler proof, via a linear translation of branching dynamic logic formulas to WAAs <ref> [MSS88] </ref>. We exploit here the ideas of Muller et al. by demonstrating a linear translation from CTL formulas to WAAs.
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal or dering of events, have been adopted as a powerful tool for specifying and verifying concur rent programs <ref> [Pnu81] </ref>. One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81].
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Int. Symp. on programming, Proc. 5th Int. Symposium, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 337-351. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchroniza tion and communication protocols can be modeled as finite-state programs, as well as from the fl Address: EECS Department, Berkeley, CA 94720-1770, U.S.A. Email: orna@ic.eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A. <p> Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. Indeed, model checking can be done in linear running time for CTL <ref> [CES86, QS81] </ref> and for the alternation-free fragment of the -calculus [Cle93], and is in NP"co-NP for the general -calculus [EJS93], whereas there is an exponential blow-up involved in going from formulas to automata.
Reference: [Rab69] <author> M.O. Rabin. </author> <title> Decidability of second order theories and automata on infinite trees. </title> <journal> Transaction of the AMS, </journal> <volume> 141 </volume> <pages> 1-35, </pages> <year> 1969. </year>
Reference-contexts: Furthermore, these reductions are very helpful for implementing temporal-logic based verification methods, and are the key to techniques such as on-the-fly verification [VW86a, JJ89, CVWY92] that help coping with the "state-explosion" problem. For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees <ref> [Rab69, VW86b] </ref>. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics [Eme85, EJ88, ES84, SE84, VW86b]. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. <p> It is also easy to see that the type of A is preserved. It is left to reduce problem 3 to problem 1. The nonemptiness problem for nondeterministic tree automata is reducible to their 1-letter nonemptiness problem <ref> [Rab69] </ref>. In addition, the reduction preserves the type of the automaton. Hence, as nondeterministic tree automata are a special case of alternating tree automata, we reduce the problem of 1-letter nonemptiness for alternating fixed-ary tree automata to problem 1. Consider a 1-letter alternating tree automaton A over n-ary trees.
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <editor> In Y. Bar-Hilel, editor, </editor> <booktitle> Proc. Symp. Math. Logic and Foundations of Set Theory, </booktitle> <pages> pages 1-23. </pages> <publisher> North Holland, </publisher> <year> 1970. </year> <month> 48 </month>
Reference-contexts: Weak alternating automata define exactly the set of weakly definable languages [MSS86]. The logic CTL fl can define languages that are not weakly definable. For example, the set of trees that satisfy the CTL fl formula AF Gp is not weakly definable <ref> [Rab70] </ref>. Therefore, a stronger acceptance condition is required for automata corresponding to formulas of CTL fl . As we shall see later, the stronger acceptance condition does not harm the complexity of the 1-letter nonemptiness problem. We first show that complementation is easy for HAAs.
Reference: [Sav70] <author> W.J. Savitch. </author> <title> Relationship between nondeterministic and deterministic tape complexities. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year>
Reference-contexts: There, we have to evaluate the transition from q. It is known that the problem of evaluating Boolean expressions is in NLOGSPACE [Lyn77]. Here, we evaluate expressions over Q and the length of each expression is linear in n. Hence, by <ref> [Sav70] </ref>, evaluating the Boolean value of a transient state in Q i , assuming we have Boolean values for all states in sets lower than Q i , can be done deterministically in space O (log 2 n). <p> Hence, as the labeling of q 2 Q i only involves a search for reachable states, we can determine its labeling nondeterministically in space O (log n), or, by <ref> [Sav70] </ref>, deterministically in space O (log 2 n). The case where q 2 Q i for a universal set Q i is symmetric. Theorems 5.1 and 5.3 provide us with the sizes and depths of the HAAs associated with formulas of CTL and CTL fl .
Reference: [SE84] <author> R. S. Streett and E. A. Emerson. </author> <title> The propositional mu-calculus is elementary. </title> <editor> In J. Paredaens, editor, </editor> <booktitle> Automata, Languages and Programming, Proc. 11th Int. Colloquium (ICALP '84), volume 172 of Lecture Notes in Computer Science, </booktitle> <pages> pages 465-472. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics <ref> [Eme85, EJ88, ES84, SE84, VW86b] </ref>. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking.
Reference: [SW91] <author> C. Stirling and D. Walker. </author> <title> Local model checking in the modal mu-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 89(1) </volume> <pages> 161-177, </pages> <year> 1991. </year>
Reference-contexts: This avoids exploring the parts of the Kripke structure that are irrelevant for the formula to be checked, and hence addresses the issue raised in the work on local model checking <ref> [SW91, VL93] </ref>, while preserving optimal complexity and ease of implementation. The third advantage of the automata-theoretic approach is that it offers new and significant insights into the space complexity of branching-time model checking.
Reference: [Tar72] <author> R.E. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 1(2) </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: Thus, all the copies of A q are accepting and the language of A q is not empty. The proof is symmetric for the case Q i is an existential set. Since partitioning each graph into maximal strongly connected components can be done in linear running time <ref> [Tar72] </ref>, the overall running time remains linear, as with WAAs. The data structure used for a linear-time implementation is an AND/OR graph similar to the one described for WAAs.
Reference: [Var82] <author> M.Y. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In Proc. 14th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <address> San Francisco, </address> <year> 1982. </year>
Reference-contexts: The states of A K; are elements of W fi cl ( ) and they are partitioned into sets Q i according to their second component (two states are in the same Q i if and only if their second 2 For a similar distinction in database query evaluation, see <ref> [Var82] </ref>. 30 components are identical). Thus, the number of Q i 's is bounded by the size of cl ( ) and is independent of the size of the Kripke structure.
Reference: [VL93] <author> B. Vergauwen and J. Lewi. </author> <title> A linear local model checking algorithm for CTL. </title> <booktitle> In Proc. CONCUR '93, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 447-461, </pages> <address> Hildesheim, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: This avoids exploring the parts of the Kripke structure that are irrelevant for the formula to be checked, and hence addresses the issue raised in the work on local model checking <ref> [SW91, VL93] </ref>, while preserving optimal complexity and ease of implementation. The third advantage of the automata-theoretic approach is that it offers new and significant insights into the space complexity of branching-time model checking. <p> With these changes, the algorithm of the proof of Theorem 5.6 becomes an automata-theoretic counterpart of the algorithm presented in <ref> [VL93] </ref>. Now, let us define the program complexity [VW86a] of model checking as the complexity of this problem in terms of the size of the input Kripke structure; i.e., assuming the formula fixed.
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: Theorem 4.9 The 1-letter nonemptiness problem for alternating Rabin word automata is decidable in nondeterministic polynomial running time. Proof: According to Theorem 3.1, the 1-letter nonemptiness problem for alternating Rabin word automata is of the same complexity as the nonemptiness problem for nondeterministic Rabin tree automata. By <ref> [Eme85, VS85] </ref>, the later is in NP.
Reference: [VW84] <author> M.Y. Vardi and P. Wolper. </author> <title> Yet another process logic. </title> <booktitle> In Logics of Programs, </booktitle> <volume> volume 164, </volume> <pages> pages 501-512. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Since comple menting an HAA does not change its size, the result for ' follows. Finally, since each subformula of induces exactly one set, the depth of A is linear in j j. We note that the same construction holds also for ECTL fl <ref> [VW84] </ref>. In ECTL fl , formulas are constructed from Boolean connectives and automata connectives. As the construction above handles a formula E~ by translating the path formula ~ into an automaton, allowing automaton operators in the path formulas causes no difficulty.
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures. For linear temporal logics, a close and fruitful connection with the theory of automata over infinite words has been developed <ref> [VW86a, VW94] </ref>. The basic idea is to associate with each linear temporal logic formula a finite automaton over infinite words that accepts exactly all the computations that satisfy the formula. <p> This enables the reduction of linear temporal logic problems, such as satisfiability and model-checking, to known automata-theoretic problems, yielding clean and asymptotically optimal algorithms. Furthermore, these reductions are very helpful for implementing temporal-logic based verification methods, and are the key to techniques such as on-the-fly verification <ref> [VW86a, JJ89, CVWY92] </ref> that help coping with the "state-explosion" problem. For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics [Eme85, EJ88, ES84, SE84, VW86b]. <p> Recall that for linear temporal logic, each Kripke structure may correspond to infinitely many computations. Model checking is thus reduced to checking inclusion between the set of computations allowed by the Kripke structure and the language of an automaton describing the formula <ref> [VW86a] </ref>. For branching temporal logic, each Kripke structure corresponds to a single non-deterministic computation. On that account, model checking is reduced to checking the membership of this computation in the language of the automaton describing the formula [Wol89]. <p> we present an application of the method with respect to CTL, the alternation-free -calculus, and the -calculus. 4.1 Model Checking for CTL and Alternation-free -Calculus Vardi and Wolper showed how to solve the satisfiability problem for CTL via an exponential translation of CTL formulas to Buchi automata over infinite trees <ref> [VW86a] </ref> 1 . Muller et al. provided a simpler proof, via a linear translation of branching dynamic logic formulas to WAAs [MSS88]. We exploit here the ideas of Muller et al. by demonstrating a linear translation from CTL formulas to WAAs. <p> ffi (:p; ; k) = true if p 62 . * ffi (:p; ; k) = false if p 2 . * ffi (' 1 ^ ' 2 ; ; k) = ffi (' 1 ; ; k) ^ ffi (' 2 ; ; k). 1 The translation described in <ref> [VW86a] </ref> handles PDL formulas, but can be easily adjusted to CTL. 20 * ffi (AX'; ; k) = c=0 (c; '). <p> We note that the general nonemptiness problem for WAA over words is PSPACE-complete [MH84], which is still unsatisfactory. Thus, the transition to a 1-letter automaton is essential. Also, as follows from Theorem 3.1, the best upper-bound known for 1-letter nonemptiness of Buchi alternating word automata is quadratic <ref> [VW86a] </ref>. Thus, the weakness of the automaton is also essential. Theorem 4.7 The 1-letter nonemptiness problem for weak alternating word automata is decidable in linear running time. Proof: Following Theorem 3.1, we prove that the 1-letter nonemptiness problem for simple weak alternating word automata is decidable in linear running time. <p> The question is then whether it is possible to perform model-checking without ever holding the whole structure to be checked in memory at any one time. For linear temporal formulas, the answer as long been known to be positive <ref> [VW86a] </ref>. Indeed, this problem reduces to checking the emptiness of a Buchi automaton over words, which is NLOGSPACE-complete. <p> With these changes, the algorithm of the proof of Theorem 5.6 becomes an automata-theoretic counterpart of the algorithm presented in [VL93]. Now, let us define the program complexity <ref> [VW86a] </ref> of model checking as the complexity of this problem in terms of the size of the input Kripke structure; i.e., assuming the formula fixed.
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-21, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Furthermore, these reductions are very helpful for implementing temporal-logic based verification methods, and are the key to techniques such as on-the-fly verification [VW86a, JJ89, CVWY92] that help coping with the "state-explosion" problem. For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees <ref> [Rab69, VW86b] </ref>. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics [Eme85, EJ88, ES84, SE84, VW86b]. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking. <p> For branching temporal logics, the automata-theoretic counterpart are automata over infinite trees [Rab69, VW86b]. By reducing satisfiability to the nonemptiness problem for these automata, optimal decision procedures have been obtained for various branching temporal logics <ref> [Eme85, EJ88, ES84, SE84, VW86b] </ref>. Unfortunately, the automata-theoretic approach does not seem to be applicable to branching-time model checking.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <year> 1994. </year>
Reference-contexts: In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures. For linear temporal logics, a close and fruitful connection with the theory of automata over infinite words has been developed <ref> [VW86a, VW94] </ref>. The basic idea is to associate with each linear temporal logic formula a finite automaton over infinite words that accepts exactly all the computations that satisfy the formula. <p> That is, A 0 ' regards the formulas maximal in ' as atomic propositions. Let U ~ = h 0 ; Q; M; q 0 ; F i be a nondeterministic Buchi automaton on infinite words such that U ~ accepts exactly all the word models of ~ <ref> [VW94] </ref>. Then, A 0 ' = h 0 ; Q; ffi 0 ; q 0 ; hF; ;ii extends U ~ by tracing it in a single branch. <p> By the induction hypothesis, kA ' 1 k is exponential in k' 1 k and kA ' 2 k is exponential in k' 2 k. Thus, kA ' k is surely exponential in k'k. * For ' = E~, we know, by <ref> [VW94] </ref>, that the size of the word automaton U ~ is exponential in k~k. Therefore, A 0 ' is exponential in k'k. <p> Since the product of the components of a concurrent program is at 43 most exponentially larger than the program, membership in PSPACE follows directly by an argument similar to the one developed in <ref> [VW94] </ref>. To prove that it is hard in PSPACE, we do a reduction from polynomial space Turing machines.
Reference: [Wol83] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56(1-2):72-99, </volume> <year> 1983. </year>
Reference-contexts: For example, the dynamic logic considered in [MSS88] allows, in the spirit of <ref> [Wol83] </ref>, nondeterministic tree automata as operators. Since this logic has a linear translation to weak alternating automata, it follows directly from our results that it also has a linear model-checking algorithm.
Reference: [Wol89] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. In Temporal Logic in Specification, </title> <booktitle> Proc., volume 398 of Lecture Notes in Computer Science, </booktitle> <pages> pages 75-123. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year> <month> 49 </month>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures. <p> For branching temporal logic, each Kripke structure corresponds to a single non-deterministic computation. On that account, model checking is reduced to checking the membership of this computation in the language of the automaton describing the formula <ref> [Wol89] </ref>. We show here that alternating automata are the suitable framework for automata-based model-checking algorithms. Alternation is used to reduce the size of the automaton from exponential in the length of to linear in the length of .
References-found: 51

