URL: http://www.cs.virginia.edu/~sullivan/publications/rams97.ps
Refering-URL: http://www.cs.virginia.edu/~sullivan/publications/rams97.html
Root-URL: http://www.cs.virginia.edu
Title: Better, Faster, Cheaper Tools: A Case Study and Demonstration  
Author: Kevin J. Sullivan 
Keyword: Key Words: Software; Reuse; Shrink-wrapped; COTS; Integration; Fault tree  
Note: SUMMARY AND CONCLUSIONS  
Address: Charlottesville  
Affiliation: University of Virginia  
Abstract: In this paper we describe our approach to the rapid construction of high-quality software tools for engineering, based on the integration of very large-scale components|in this case, existing, commercial off-the-shelf, shrink-wrapped application packages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brooks, </author> <title> F.P., "The State and Future of Software Engineering," in The Mythical Man-Month, Anniversary Edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1995, </year> <pages> pp. 284-287. </pages>
Reference-contexts: Microsoft markets PC applications as integratable components, and capabilities such as OLE Automation and Visual Basic as enablers of such integration. Moreover, Fred Brooks has predicted that building new software systems on existing packages will become more common <ref> [1] </ref>. The economics are compelling: You get millions of lines of code and the results of tens or hundreds of person years of effort at the cost of a few hours of an engineer's time.
Reference: [2] <author> Garlan, D., R. Allen and J. Ockerbloom, </author> <title> "Architectural Mismatch: Why Reuse is so Hard," </title> <journal> IEEE Software, </journal> <volume> vol. 12 No. 6, </volume> <month> Nov. </month> <year> 1995, </year> <pages> pp. 17-26. </pages>
Reference-contexts: One approach to solving this problem would be to build superstructure code from large-scale, reusable components. Unfortunately, a second impediment to tool development has been the difficulty of doing this. Garlan et al. documented the problem in a paper <ref> [2] </ref> that describes a tool development experience in which an apparently straightforward exercise in reuse ballooned into a difficult and costly effort focused on ways of compensating for incompatibilities between components. <p> Consequently, large numbers of them integrated in complex designs are needed to realize systems of major significance [4]. On the other hand, attempts to scale up component sizes has been less than wholly successful owing in part to the phenomenon of architectural mismatch <ref> [2] </ref>. The idea of using application packages as components is also not new. In a sense, system integrators have been tying together applications into more complex systems for decades.
Reference: [3] <author> Sullivan, K.J., and J.C. Knight, </author> <title> "Experience Assessing an Architectural Approach to Large-Scale Systematic Reuse," </title> <booktitle> Proc. 18th International Conference on Software Engineering, </booktitle> <address> Berlin, </address> <month> March </month> <year> 1996, </year> <pages> pp. 220-229. </pages> <note> RF 97RM-102, page 3 -RF </note>
Reference-contexts: 1. INTRODUCTION It is too hard to build specialized, high-quality software tools for engineering modeling and analysis quickly and cost-effectively. The high cost of software thus impedes the transition of specialized new modeling techniques into engineering practice <ref> [3] </ref>. In this paper we describe work on a new approach to developing high-quality tools quickly and at low-cost by using large-scale application packages as components. Our case study is a tool that supports new fault-tree [8] analysis techniques developed by Dugan at the University of Virginia.
Reference: [4] <author> Sullivan, K.J., J.C. Knight, J. Cockrell and S. Zhang, </author> <title> "Prod--uct Development with Massive Components," to appear, </title> <booktitle> Proc. 21st Software Engineering Workshop, </booktitle> <address> Greenbelt, MD, </address> <year> 1996. </year>
Reference-contexts: One problem with traditional approaches based on subroutine and class libraries is that the parts are so small. Consequently, large numbers of them integrated in complex designs are needed to realize systems of major significance <ref> [4] </ref>. On the other hand, attempts to scale up component sizes has been less than wholly successful owing in part to the phenomenon of architectural mismatch [2]. The idea of using application packages as components is also not new.
Reference: [5] <author> Sullivan, K.J., I.J. Kalet and D. Notkin, </author> <title> "Evaluating the Mediator Method: Prism as a Case Study," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 22, No. 8, </volume> <month> August, </month> <year> 1996, </year> <pages> pp. 563-579. </pages>
Reference-contexts: In another dimension, we have investigated software design techniques for structuring integrated systems. We have shown that integration requirements generally lead to hard-to-maintain designs when common software design approaches are employed. To overcome this problem we developed the mediator software design approach <ref> [7, 6, 5] </ref> One key idea in this approach is that separate representations (e.g., text and graphical representations of a model) should be developed as visible, independent components: as stand-alone parts that can be manipulated directly by users and by other system components. <p> Visibility into the representation maintained by Word is not as well supported, but a basic level of integration is still feasible. To integrate the packages, we used the mediator approach <ref> [7, 6, 5] </ref>. At a high level, our tool functions as a mediator that integrates a set of stand-alone application packages, with each other and with the core modeling and analysis data types. 4.
Reference: [6] <author> Sullivan, K.J., Mediators: </author> <title> Easing the Design and Evolution of Integrated Systems, </title> <type> Ph.D. Dissertation, </type> <institution> University of Wash-ington Department of Computer Science and Engineering, </institution> <address> Seattle, WA, </address> <year> 1994. </year> <note> Also available as University of Washington Department of Computer Science and Engineering Technical Report 94-08-01. </note>
Reference-contexts: In another dimension, we have investigated software design techniques for structuring integrated systems. We have shown that integration requirements generally lead to hard-to-maintain designs when common software design approaches are employed. To overcome this problem we developed the mediator software design approach <ref> [7, 6, 5] </ref> One key idea in this approach is that separate representations (e.g., text and graphical representations of a model) should be developed as visible, independent components: as stand-alone parts that can be manipulated directly by users and by other system components. <p> Visibility into the representation maintained by Word is not as well supported, but a basic level of integration is still feasible. To integrate the packages, we used the mediator approach <ref> [7, 6, 5] </ref>. At a high level, our tool functions as a mediator that integrates a set of stand-alone application packages, with each other and with the core modeling and analysis data types. 4.
Reference: [7] <author> Sullivan, K.J. and D. Notkin, </author> <title> "Reconciling Environment Integration and Software Evolution," </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> Vol. 1, No. 3, </volume> <month> July, </month> <year> 1992, </year> <pages> pp. 229-268. </pages>
Reference-contexts: In another dimension, we have investigated software design techniques for structuring integrated systems. We have shown that integration requirements generally lead to hard-to-maintain designs when common software design approaches are employed. To overcome this problem we developed the mediator software design approach <ref> [7, 6, 5] </ref> One key idea in this approach is that separate representations (e.g., text and graphical representations of a model) should be developed as visible, independent components: as stand-alone parts that can be manipulated directly by users and by other system components. <p> Visibility into the representation maintained by Word is not as well supported, but a basic level of integration is still feasible. To integrate the packages, we used the mediator approach <ref> [7, 6, 5] </ref>. At a high level, our tool functions as a mediator that integrates a set of stand-alone application packages, with each other and with the core modeling and analysis data types. 4.

References-found: 7

