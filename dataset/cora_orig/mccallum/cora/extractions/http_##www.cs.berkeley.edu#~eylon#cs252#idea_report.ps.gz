URL: http://www.cs.berkeley.edu/~eylon/cs252/idea_report.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~eylon/cs252/index.html
Root-URL: 
Title: IDEA as a Benchmark for Reconfigurable Computing  
Author: Eylon Caspi and Nicholas Weaver 
Date: December 9, 1996  
Abstract: There is an increasing interest in using reconfigurable hardware for performing computational tasks. Yet despite this interest, there are no suitable metrics for comparing the performance of reconfigurable systems. We propose that the core encryption of the International Data Encryption Algorithm (IDEA), a popular 128-bit block cipher, be used for this purpose. We implemented the IDEA algorithm on two classes of reconfigurable devices, the Xilinx 4000 series of field programmable gate arrays and the proposed Garp (Gate Array Risc Processor, part of the UC Berkeley BRASS project) reconfigurable array. The performance on these two devices was characterized and compared with other implementations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Asanovic, B. Kingsbury, B. Irissou, J. Beck, and J. Wawrzynek. T0: </author> <title> A Single-Chip Vector Microprocessor with Reconfigurable Pipelines. </title> <booktitle> In Proceedings 22nd European Solid-State Circuits Conference, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: This processor encrypts data at a rate of 15.7 Mb s with a latency of 3.9 s for one block of data. The vector processor implementation of IDEA was written by Krste Asanovic [2] for the Torrent 0 vector microprocessor <ref> [1, 8] </ref>. The T0 vector microprocessor consists of a 32-bit fixed-point vector processor attached to a simple, single-issue, in-order MIPS processor core. It has two arithmetic and one load/store pipeline which operate on 8 elements simultaneously, allowing it to perform up to 24 operations per clock cycle.
Reference: [2] <author> Krste Asanovic. </author> <title> Work in progress as part of a Ph. </title> <editor> D. </editor> <booktitle> thesis on vector microprocessors. </booktitle>
Reference-contexts: This processor encrypts data at a rate of 15.7 Mb s with a latency of 3.9 s for one block of data. The vector processor implementation of IDEA was written by Krste Asanovic <ref> [2] </ref> for the Torrent 0 vector microprocessor [1, 8]. The T0 vector microprocessor consists of a 32-bit fixed-point vector processor attached to a simple, single-issue, in-order MIPS processor core.
Reference: [3] <institution> The Programmable Electronics Performance Corporation. </institution> <note> http://www.prep.org/stand.htm. </note>
Reference-contexts: Currently, such devices are used for digital logic operations where a custom VLSI implementation is either too costly or too time consuming to develop. Several companies, notably Xilinx, Altera, and AT&T, manufacture FPGAs in a range of designs and capabilities. Existing benchmarks for FPGAs <ref> [3] </ref> are designed to test an FPGA's performance on relatively small, logic-oriented tasks, such as 16 bit counters and small state machines.
Reference: [4] <author> A. V. Curiger, H. Bonnenberg, and H. Kaeslin. </author> <title> Regular VLSI Architectures for Multiplication Modulo (2 n + 1). </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 26(7) </volume> <pages> 990-994, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: This representation relies on the cryptographic principle that every operation must be reversible, so a number should never be multiplied by 0. Although it might seem that the modulo operation complicates matters, there is a relatively easy way to perform the modulo operation <ref> [4] </ref> based on the following arithmetic identities: x mod (2 n + 1) = (x mod (2 n ) x div (2 n )) mod (2 n + 1) (1) (x mod (2 n )) (x div (2 n )) otherwise (2) Equation 2 maps efficiently to both hardware and software.
Reference: [5] <author> Andre DeHon. </author> <title> Reconfigurable Architectures for General-Purpose Computing. </title> <type> PhD thesis, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <year> 1996. </year>
Reference-contexts: (1) X i Z j (r) 16-bit plaintext subblock 16-bit cyphertext subblock 16-bit sub-key in round r 16-bit parallel bitwise XOR addition modulo 2 16 multiplication modulo 2 16 +1 with the zero-word corresponding to value 2 16 one round seven more rounds output transformation 3 contexts (such as DPGAs <ref> [5] </ref>), this technique is not feasible due to the sheer number of separate multipliers and contexts required. IDEA is one of the most computationally challenging tasks one would consider implementing on a device lacking a hardware multiplier. If 32-bit multiplications are required, they become space prohibitive.
Reference: [6] <author> John Hauser. Garp: </author> <title> Combining a Processor with a Reconfigurable Gate Array. </title> <address> http://www.cs.berkeley.edu/Research/Projects/brass/garp.html. </address>
Reference-contexts: building a design and then having the tools reveal how fast it can operate, the nondeterministic nature of 6 Taken from The Garp Architecture the place and route tools may pose problems for some designers. 4 The Garp implementation The Garp (Gate Array RISC Processor) is a Berkeley research design <ref> [7, 6] </ref> which combines a MIPS processor and FPGA co-processor on one die. As a coprocessor, the gate array augments the main processor's capability with fast reconfigurable hardware for small time-critical computations.
Reference: [7] <author> John Hauser. </author> <title> The Garp Architecture. Draft of work in progress, </title> <month> September </month> <year> 1996. </year>
Reference-contexts: building a design and then having the tools reveal how fast it can operate, the nondeterministic nature of 6 Taken from The Garp Architecture the place and route tools may pose problems for some designers. 4 The Garp implementation The Garp (Gate Array RISC Processor) is a Berkeley research design <ref> [7, 6] </ref> which combines a MIPS processor and FPGA co-processor on one die. As a coprocessor, the gate array augments the main processor's capability with fast reconfigurable hardware for small time-critical computations.
Reference: [8] <institution> The International Computer Science Institute. T0 Vector Microprocessor Homepage. </institution> <note> http://www.icsi.berkeley.edu/real/spert/t0-intro.html. </note>
Reference-contexts: This processor encrypts data at a rate of 15.7 Mb s with a latency of 3.9 s for one block of data. The vector processor implementation of IDEA was written by Krste Asanovic [2] for the Torrent 0 vector microprocessor <ref> [1, 8] </ref>. The T0 vector microprocessor consists of a 32-bit fixed-point vector processor attached to a simple, single-issue, in-order MIPS processor core. It has two arithmetic and one load/store pipeline which operate on 8 elements simultaneously, allowing it to perform up to 24 operations per clock cycle.
Reference: [9] <author> T. R. Madhusudan Sastry, T. Ganesan, B. Madhukar, and N. Srinivasa. </author> <title> Time is right for a good, secure "IDEA". Electronic Engineering Times, </title> <address> Oct. </address> <month> 23 </month> <year> 1995. </year>
Reference-contexts: For comparison, we reference a low end DSP implementation, a conventional microprocessor implementation, a vector microprocessor implementation, and a VLSI implementation. The DSP implementation <ref> [9] </ref> was done on a Motorola 56166 DSP running at 60 MHz. This low-end, 16-bit, fixed point DSP can only produce a 16-bit result from a multiply, so the designers used the fixed-point arithmetic options to produce a 32-bit value for use in the modulo correction.
Reference: [10] <author> Bruce Schneier. </author> <title> Applied Cryptography: Protocols, Algorithms, and Source Code in C. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year> <month> 12 </month>
Reference-contexts: Furthermore, each benchmark must be representative of a wide range of potential applications. 2 The IDEA algorithm The International Data Encryption Algorithm (IDEA) was first proposed in 1991 as a modification of a previous algorithm called PES <ref> [10] </ref>. Although relatively young, IDEA has found considerable use and is becoming one of the standard encryption algorithms thanks to its perceived security and (relatively) good performance on conventional microprocessors. <p> Although our design time was significant, considerable overhead was spent in problems with the design tools. An experienced designer should have little difficulty in implementing the core algorithm. Reference implementations of IDEA are available as source code 1 in a variety of packages, including the appendix of Applied Cryptography <ref> [10] </ref> 2 , the Pretty Good Privacy package, and the RSAREF cryptographic library. The final criterion for a reasonable benchmark is to have useful metrics. For IDEA, there are two: Latency of a single block encryption, and sustained bandwidth through the device.
Reference: [11] <author> S. Wolter, H. Matz, A. Schubert, and R. Laur. </author> <title> On the VLSI Implementation of the International Data Encryption Algorithm IDEA. </title> <booktitle> In Proceedings IEEE International Symposium on Circuits and Systems, </booktitle> <pages> pages 397-400, </pages> <year> 1995. </year>
Reference-contexts: By using vector condition codes or bitwise operations, the modulo operation can be implemented efficiently for an entire vector of 32 elements. The multiplier pipeline's reconfigurable hardware further aids the modulo operation. Several VLSI implementations of IDEA encryption have appeared in the literature <ref> [11, 13] </ref>, boasting impressive performance. The best implementation found [11] has a maximum throughput of 355 Mbit/sec and a block latency of approximately 1.8 s. <p> The multiplier pipeline's reconfigurable hardware further aids the modulo operation. Several VLSI implementations of IDEA encryption have appeared in the literature [11, 13], boasting impressive performance. The best implementation found <ref> [11] </ref> has a maximum throughput of 355 Mbit/sec and a block latency of approximately 1.8 s. The speed of this VLSI implementation owes mainly to a very fast, pipelined, modulo (2 16 + 1) multiplier design based on a Booth-encoded multiplier and balanced Wallace Tree.
Reference: [12] <author> Xilinx Corporation. </author> <title> The Programmable Logic Data Book, </title> <booktitle> third edition, </booktitle> <year> 1994. </year>
Reference-contexts: Larger versions of the same device should have performance improvement scaling roughly linearly with area. 3 The Xilinx 4000 implementation The first implementation of IDEA was on the Xilinx 4000 family of gate arrays. These readily available devices are commonly used for a wide variety of digital-logic problems <ref> [12] </ref>. Although the basic design dates back to 1990 and has seen little improvement clock speed (roughly a 100-200% speedup over the past 6 years), the latest members of the XC4000 are significantly larger than their predecessors.
Reference: [13] <author> R. Zimmerman, A. Curiger, H. Bonnenberg, H. Kaeslin, N. Felber, and W. Fichter. </author> <title> A 177 Mb/s VLSI Implementation of the International Data Encryption Algorithm. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 29(3) </volume> <pages> 303-307, </pages> <month> March </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: By using vector condition codes or bitwise operations, the modulo operation can be implemented efficiently for an entire vector of 32 elements. The multiplier pipeline's reconfigurable hardware further aids the modulo operation. Several VLSI implementations of IDEA encryption have appeared in the literature <ref> [11, 13] </ref>, boasting impressive performance. The best implementation found [11] has a maximum throughput of 355 Mbit/sec and a block latency of approximately 1.8 s.
References-found: 13

