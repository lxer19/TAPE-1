URL: http://www.cs.purdue.edu/homes/palsberg/paper/fac97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: E-mail: palsberg@theory.lcs.mit.edu.  E-mail: wand@ccs.neu.edu.  E-mail: pmo@world.std.com.  
Title: Type Inference with Non-structural Subtyping  
Author: Jens Palsberg Mitchell Wand zx Patrick O'Keefe 
Address: NE43-340, 545 Technology Square, Cambridge, MA 02139, USA.  360 Huntington Avenue, 161CN, Boston, MA 02115, USA.  -151 Coolidge Avenue #211, Watertown, MA 02172, USA.  
Affiliation: Massachusetts Institute of Technology,  College of Computer Science, Northeastern University,  
Note: Formal Aspects of Computing, 9:49-67, 1997.  Work supported by the National Science Foundation under grants CCR-9304144 and CCR-9404646.  
Date: July 21, 1997  
Abstract: We present an O(n 3 ) time type inference algorithm for a type system with a largest type &gt;, a smallest type ?, and the usual ordering between function types. The algorithm infers type annotations of least shape, and it works equally well for recursive types. For the problem of typability, our algorithm is simpler than the one of Kozen, Palsberg, and Schwartzbach for type inference without ?. This may be surprising, especially because the system with ? is strictly more powerful. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: The type system PTB is a convenient setting for studying certain aspects of non-structural subtyping, especially the ordering of function types. The type system PTB can be extended with recursive types, yielding Amadio and Cardelli's system <ref> [1] </ref>, here denoted PTB . The further extension of PTB with the type Int of integers will be denoted PTB [ fIntg. We have earlier shown that PTB is strictly more powerful than PT [10], and recursive types add further power. <p> For s; t 2 T , define s t if s (ff) ff t (ff) for all ff 2 D (s) " D (t). 2 Kozen, Palsberg, and Schwartzbach [3] showed that the relation is equivalent to the order defined by Amadio and Cardelli <ref> [1] </ref>. The relation is a partial order with ? t &gt; for all t 2 T , and s ! t s 0 ! t 0 if and only if s 0 s and t t 0 [1, 3]. <p> The relation is a partial order with ? t &gt; for all t 2 T , and s ! t s 0 ! t 0 if and only if s 0 s and t t 0 <ref> [1, 3] </ref>. Moreover, on F , coincides with the type ordering defined in Section 1 [3]. 8 2.4 Graphs In this section we reduce the problem of solving constraint systems to a problem of solving a certain kind of constraint graph. <p> Allowing types to be represented succinctly by the automata M s , we get our main result. Corollary 19 The type inference problem for PTB is solvable in O (n 3 ) time. Recursive types are just regular trees <ref> [1] </ref>. The least-shape solution we have constructed, although possibly infinite, is a regular tree for every node in the constraint graph. Thus, we get the following result. 22 Corollary 20 For PTB , we can infer a least-shape type annotation in O (n 3 ) time.
Reference: [2] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year> <note> Preliminary version in Proc. </note> <editor> FOCS'92, </editor> <booktitle> 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <address> Pitts-burgh, Pennsylvania, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: We have earlier shown that PTB is strictly more powerful than PT [10], and recursive types add further power. It is known that type inference for PT is computable in O (n 3 ) time <ref> [2] </ref>. It is well known that all -terms are typable in PTB by the type ff:ff ! ff. It is also known that type inference for PTB [ fIntg is computable in O (n 3 ) time, by reduction to a flow analysis problem [6]. <p> In this paper we show that type inference for PTB and PTB is also computable in O (n 3 ) time, by an algorithm similar to that in <ref> [2] </ref>. The algorithm 2 infers type annotations of least shape. A type is a tree (which can be infinite if we consider recursive types), so its shape is the set of paths from the root. In general, there can be several types of least shape. <p> By contrast, in the type system PT, every typable -term has exactly one type annotation of least shape. The algorithm by Kozen, Palsberg, and Schwartzbach <ref> [2] </ref> infers this least-shape type annotation. The type inference algorithm by Palsberg and O'Keefe [6] for PTB [fIntg does in general not infer type annotations of least shape. It remains open if our result can be extended to PTB [ fIntg. <p> In particular, if E is closed, then E is typable with type t if and only if there exists a solution of T (E) such that ([[E]]) = t. Proof. Similar to the proof of Theorem 2.1 in the journal version of <ref> [2] </ref>, in outline as follows. Given a solution of the constraint system, it is straightforward to construct a derivation of A ` E: t. <p> The sequence of 0's and 1's that were seen gives a string in L (s), and all strings in L (s) are obtained in this way. For comparison, the automaton that was defined in <ref> [2] </ref> for doing type inference without ? had eight rather than four rules for generating transitions. It turns out that once we have M, we can construct a solution with domain L (s) for each s.
Reference: [3] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5(1) </volume> <pages> 113-125, </pages> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> POPL'93, </editor> <booktitle> Twentieth Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 419-428, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Starting at the root, as long as the nodes along the path are labeled with an arrow, a 0 in the path selects the left subtree, a 1 selects the right subtree. In the following we formalize this intuition, along the lines of for example <ref> [3, 6] </ref>. Let = f!; ?; &gt;g be the ranked alphabet where ! is binary and ?; &gt; are nullary. A type is a finite tree over . <p> Notice that the notation # is overloaded. Which definition is being used will be clear from context. 2 The following properties are immediate from the definitions: (i) (s ! T t) # 0 = s (iii) (t # ff) # fi = t # fffi Following <ref> [3] </ref>, we henceforth omit the superscript T on the operators ! T , ? T , &gt; T . We will say that a term s has smaller shape than a term t if D (s) D (t). Our type inference algorithm will infer types that are of least shape. <p> For s; t 2 T , define s t if s (ff) ff t (ff) for all ff 2 D (s) " D (t). 2 Kozen, Palsberg, and Schwartzbach <ref> [3] </ref> showed that the relation is equivalent to the order defined by Amadio and Cardelli [1]. <p> The relation is a partial order with ? t &gt; for all t 2 T , and s ! t s 0 ! t 0 if and only if s 0 s and t t 0 <ref> [1, 3] </ref>. Moreover, on F , coincides with the type ordering defined in Section 1 [3]. 8 2.4 Graphs In this section we reduce the problem of solving constraint systems to a problem of solving a certain kind of constraint graph. <p> Moreover, on F , coincides with the type ordering defined in Section 1 <ref> [3] </ref>. 8 2.4 Graphs In this section we reduce the problem of solving constraint systems to a problem of solving a certain kind of constraint graph. The graphs yield a convenient setting for applying algorithms like transitive closure.
Reference: [4] <author> John Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Eleventh Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference-contexts: Subtyping in PTB and PT is non-structural, that is, two types can be related by even in cases where they have different structures. For example &gt; ! &gt; &gt; and &gt; ! &gt; (&gt; ! &gt;) ! &gt;. In contrast, type systems with atomic subtyping <ref> [4] </ref> have the property that if s is a subtype of t, then s and t have the same structure; only the leaves of s and t can be different.
Reference: [5] <author> John C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 245-285, </pages> <year> 1991. </year>
Reference-contexts: This is proved by straightforward induction on the structure of the derivation of A ` E : t <ref> [5] </ref>. This system types -terms which are not typable in the simply-typed - calculus. For example, consider f:(f K (f I)), where K and I are the usual combinators.
Reference: [6] <author> Jens Palsberg and Patrick M. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> POPL'95, </editor> <booktitle> 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-378, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: It is well known that all -terms are typable in PTB by the type ff:ff ! ff. It is also known that type inference for PTB [ fIntg is computable in O (n 3 ) time, by reduction to a flow analysis problem <ref> [6] </ref>. In this paper we show that type inference for PTB and PTB is also computable in O (n 3 ) time, by an algorithm similar to that in [2]. The algorithm 2 infers type annotations of least shape. <p> By contrast, in the type system PT, every typable -term has exactly one type annotation of least shape. The algorithm by Kozen, Palsberg, and Schwartzbach [2] infers this least-shape type annotation. The type inference algorithm by Palsberg and O'Keefe <ref> [6] </ref> for PTB [fIntg does in general not infer type annotations of least shape. It remains open if our result can be extended to PTB [ fIntg. For the problem of typability, our algorithm is simpler than the one of Kozen, Palsberg, and Schwartzbach for type inference without ?. <p> Starting at the root, as long as the nodes along the path are labeled with an arrow, a 0 in the path selects the left subtree, a 1 selects the right subtree. In the following we formalize this intuition, along the lines of for example <ref> [3, 6] </ref>. Let = f!; ?; &gt;g be the ranked alphabet where ! is binary and ?; &gt; are nullary. A type is a finite tree over . <p> It remains open how to extend this result to PTB [ fIntg. 7 Example We now give an example of how our type inference algorithm works. Consider the -term E = (x:xx)(y:y) which was also treated in <ref> [6] </ref>. We give each of the two occurrences of x a label so that the -term reads (x:x 1 x 2 )(y:y). <p> For comparison, we can apply the algorithm of <ref> [6] </ref> for type inference for PTB extended with recursive types to E. The result is that both x and y get annotated by the infinite type ff:ff ! ff [6]. <p> For comparison, we can apply the algorithm of <ref> [6] </ref> for type inference for PTB extended with recursive types to E. The result is that both x and y get annotated by the infinite type ff:ff ! ff [6].
Reference: [7] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 175-180, </pages> <year> 1992. </year>
Reference-contexts: Conversely, observe that if A ` E: t is derivable, then there exists a derivation of A ` E: t such that each use of one of the ordinary rules is followed by exactly one use of the subsumption rule. The approach in for example <ref> [9, 7] </ref> then gives a set of inequalities of the desired form. 2 We now begin the running example of this paper. It is small and does not fully illustrate all constructions, but it may be helpful for understanding the basic ideas. A larger example is presented in Section 7.
Reference: [8] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. Interna--tional Colloquium on Automata, Languages, and Programming 1988, </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag (LNCS 317), </publisher> <year> 1988. </year>
Reference-contexts: Following [10], we denote this type system by PTB (PTB indicates Partial Types with Bottom). Thatte's system of partial types <ref> [8] </ref> did not include ?; the fragment of PTB without ? will be denoted PT [10]. Subtyping in PTB and PT is non-structural, that is, two types can be related by even in cases where they have different structures.
Reference: [9] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 1-15, </pages> <year> 1991. </year>
Reference-contexts: Conversely, observe that if A ` E: t is derivable, then there exists a derivation of A ` E: t such that each use of one of the ordinary rules is followed by exactly one use of the subsumption rule. The approach in for example <ref> [9, 7] </ref> then gives a set of inequalities of the desired form. 2 We now begin the running example of this paper. It is small and does not fully illustrate all constructions, but it may be helpful for understanding the basic ideas. A larger example is presented in Section 7.
Reference: [10] <author> Mitchell Wand, Patrick M. O'Keefe, and Jens Palsberg. </author> <title> Strong normalization with non-structural subtyping. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5(3) </volume> <pages> 419-430, </pages> <year> 1995. </year> <month> 27 </month>
Reference-contexts: Types are partially ordered by which is the smallest binary relation on types such that 1. ? t &gt; for all types t; and 2. s ! t s 0 ! t 0 if and only if s 0 s and t t 0 . Following <ref> [10] </ref>, we denote this type system by PTB (PTB indicates Partial Types with Bottom). Thatte's system of partial types [8] did not include ?; the fragment of PTB without ? will be denoted PT [10]. <p> Following <ref> [10] </ref>, we denote this type system by PTB (PTB indicates Partial Types with Bottom). Thatte's system of partial types [8] did not include ?; the fragment of PTB without ? will be denoted PT [10]. Subtyping in PTB and PT is non-structural, that is, two types can be related by even in cases where they have different structures. For example &gt; ! &gt; &gt; and &gt; ! &gt; (&gt; ! &gt;) ! &gt;. <p> The type system PTB can be extended with recursive types, yielding Amadio and Cardelli's system [1], here denoted PTB . The further extension of PTB with the type Int of integers will be denoted PTB [ fIntg. We have earlier shown that PTB is strictly more powerful than PT <ref> [10] </ref>, and recursive types add further power. It is known that type inference for PT is computable in O (n 3 ) time [2]. It is well known that all -terms are typable in PTB by the type ff:ff ! ff. <p> Similarly, some self-application is possible: (x:xx) has type (&gt; ! t) ! t for all t, since the final x can be coerced to &gt;. 4 However, not all -terms are typable in this system. Any -term typable in PTB is strongly normalizing <ref> [10] </ref>. To indicate the flavor of those strongly normalizing -terms which are not typable in this system, we have earlier [10] showed that (x:xxx)(y:y) is not typable in PTB. We also showed that (f:f (f x))(v:vy) is typable in PTB but not in PT. <p> Any -term typable in PTB is strongly normalizing <ref> [10] </ref>. To indicate the flavor of those strongly normalizing -terms which are not typable in this system, we have earlier [10] showed that (x:xxx)(y:y) is not typable in PTB. We also showed that (f:f (f x))(v:vy) is typable in PTB but not in PT.
References-found: 10

