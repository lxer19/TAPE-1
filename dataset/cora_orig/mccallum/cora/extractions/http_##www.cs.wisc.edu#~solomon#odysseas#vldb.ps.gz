URL: http://www.cs.wisc.edu/~solomon/odysseas/vldb.ps.gz
Refering-URL: http://www.cs.wisc.edu/~solomon/solomon.html
Root-URL: 
Email: fodysseas,solomon,yannisg@cs.wisc.edu  
Title: The GMAP: A Versatile Tool for Physical Data Independence  
Author: Odysseas G. Tsatalos Marvin H. Solomon Yannis E. Ioannidis 
Address: WI 53706  
Affiliation: Computer Sciences Dept., Univ. of Wisconsin-Madison,  
Abstract: Physical data independence is touted as a central feature of modern database systems. Both relational and object-oriented systems, however, force users to frame their queries in terms of a logical schema that is directly tied to physical structures. Our approach eliminates this dependence. All storage structures are defined in a declarative language based on relational algebra as functions of a logical schema. We present an algorithm, integrated with a conventional query optimizer, that translates queries over this logical schema into plans that access the storage structures. We also show how to compile update requests into plans that update all relevant storage structures consistently and optimally. Finally, we report on experiments with a prototype implementation of our approach that demonstrate how it allows storage structures to be tuned to the expected or observed workload to achieve significantly better performance than is possible with conventional techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, Y. Sagiv, and J. Ullman. </author> <title> Equivalences Among Relational Expressions. </title> <journal> SIAM Journal of Computing, </journal> <volume> 8(2) </volume> <pages> 218-247, </pages> <year> 1979. </year>
Reference-contexts: Two psj-queries Q 1 and Q 2 are equivalent, denoted Q 1 Q 2 , if they produce the same result for any valid instance of the database schema. Equivalence testing of arbitrary conjunctive queries, even without taking into account any dependencies, is NP-complete <ref> [1, 7] </ref>. On the other hand, we can efficiently compare two psj-queries syntactically to see if they are identical (up to trivial differences such as the ordering of the join terms). This is a sufficient condition for equivalence, which we use in our translation algorithm.
Reference: [2] <author> E. Bertino and W. Kim. </author> <title> Indexing Techniques for Queries on Nested Objects. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 196-214, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In this paper, we restrict both gmap definitions and queries to project-select-join (psj) expressions over a simple semantic data model. We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices <ref> [2, 16] </ref>, field repli Page 1 cation [11, 23], and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> Previous proposals for the maintenance of complex access paths suggest using ad hoc techniques to accelerate expensive updates, such as internal links between instances in nested indices and field replication <ref> [23, 2] </ref> or links from instances to their collections [16, 18]. We can achieve the same effect by using simple gmaps along the paths that need to be traversed during the update propagation. <p> Such replication is very beneficial for our workload since it can eliminate the most expensive 1 We use the term path indices collectively for what Bertino and Kim <ref> [2] </ref> call path indices, nested indices, and multi-indices. Page 10 step of the medium and large queries Q5, Q7, and Q8. The exact cost savings and overheads that are caused by each additional access path are shown in Table 6. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices <ref> [2, 14, 16] </ref>, join indices [26], and field replication [11, 23], noting their restrictions and comparing their performance to our scheme.
Reference: [3] <author> J. Blakeley, N. Coburn, and P. Larson. </author> <title> Updating derived relations. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Updates, however, are much simpler. Translating them into the physical schema turns into the materialized view maintenance problem, which accepts simple solutions. As discussed elsewhere <ref> [3] </ref>, propagating updates into materialized views requires the execution of queries over the base relations and the inserted or deleted tuples. However, here we do not necessarily have the base relations stored, and the actual data are replicated in many places. <p> However, since gmap queries do not support unions, they cannot represent outer joins, and therefore cannot store incomplete instances of chains. With respect to the translation algorithm, our work most closely resembles research at the University of Waterloo on materialized views <ref> [3, 28] </ref>. Our algorithm supports a more restricted query language, but uses information about inclusion and functional dependencies as well as "topological" information implicit in a graph-based logical schema. This information allows us to identify solutions that would be missed by the more general algorithm. <p> In addition to the work on materialized views <ref> [3, 28] </ref>, such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query [9] or between multiple queries [22], reusing results of previous queries [8], and using integrity constraints for semantic query optimization [6].
Reference: [4] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, and M. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: of the structure can be described by a psj-query on the logical schema, it can be treated like a gmap. 7 Implementation To verify the applicability and practicality of our algorithms and obtain a feeling for their performance, we built a prototype implementation of our system on top of SHORE <ref> [4] </ref>. SHORE is an object-oriented database system under construction at the University of Wisconsin. Logical schema definitions are parsed and stored in a logical-schema catalog. Physical storage structures are created from gmap definitions. The parsed gmap query is stored persistently in a second physical-schema catalog.
Reference: [5] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A Data Model and Query Language for Exodus. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 413-423, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. Object-oriented systems that store instances in explicit Page 3 collections rather than class extents <ref> [5, 16, 18] </ref> allow the creation of collection indices, which provide fast access paths only to the subsets of the domains that are included in the collection. Our gmap definition language is powerful enough to express such indices by using restrictions. <p> For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [15] and Zoo [10]) and every collection in collection-based OO systems (e.g., GemStone [16], Extra/Excess <ref> [5] </ref>, and ObjectStore [18]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [6] <author> U. Chakravarthy. </author> <title> Logic-Based Approach to Semantic Query Optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 163-207, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Examples include research on reusing common subexpressions within a query [9] or between multiple queries [22], reusing results of previous queries [8], and using integrity constraints for semantic query optimization <ref> [6] </ref>. Kemper and Moerkotte [13] opt for a unified approach of translation and op Page 11 timization for the ASRs by extending a rule based op-timizer to include appropriate rewriting rules.
Reference: [7] <author> A. Chandra and P. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational data bases. </title> <booktitle> In Proc. of Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <month> May </month> <year> 1977. </year>
Reference-contexts: Two psj-queries Q 1 and Q 2 are equivalent, denoted Q 1 Q 2 , if they produce the same result for any valid instance of the database schema. Equivalence testing of arbitrary conjunctive queries, even without taking into account any dependencies, is NP-complete <ref> [1, 7] </ref>. On the other hand, we can efficiently compare two psj-queries syntactically to see if they are identical (up to trivial differences such as the ordering of the join terms). This is a sufficient condition for equivalence, which we use in our translation algorithm.
Reference: [8] <author> S. Finkelstein. </author> <title> Common expression analysis in database applications. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 364-374, </pages> <year> 1982. </year>
Reference-contexts: Query signatures, an encoding of the names of all the relations used by the query, can be used to perform these comparisons efficiently <ref> [8] </ref>. It is interesting to see how the new algorithm behaves when it is given a set of gmaps that represents a traditional relational physical schema. <p> In addition to the work on materialized views [3, 28], such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query [9] or between multiple queries [22], reusing results of previous queries <ref> [8] </ref>, and using integrity constraints for semantic query optimization [6]. Kemper and Moerkotte [13] opt for a unified approach of translation and op Page 11 timization for the ASRs by extending a rule based op-timizer to include appropriate rewriting rules.
Reference: [9] <author> P. Hall. </author> <title> Optimization of a single relational expression in a RDBMS. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 20(3), </volume> <month> May </month> <year> 1976. </year>
Reference-contexts: In addition to the work on materialized views [3, 28], such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query <ref> [9] </ref> or between multiple queries [22], reusing results of previous queries [8], and using integrity constraints for semantic query optimization [6].
Reference: [10] <author> Y. Ioannidis, M. Livny, E. Haber, R. Miller, O. Tsatalos, and J. Wiener. </author> <title> Desktop Experiment Management. </title> <journal> IEEE Data Engineering, </journal> <volume> 16(1) </volume> <pages> 19-23, </pages> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [15] and Zoo <ref> [10] </ref>) and every collection in collection-based OO systems (e.g., GemStone [16], Extra/Excess [5], and ObjectStore [18]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [11] <author> K. Kato and T. Masuda. </author> <title> Persistent Caching. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(7) </volume> <pages> 631-645, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices [2, 16], field repli Page 1 cation <ref> [11, 23] </ref>, and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> The department name is in this case a nested attribute of the Faculty domain. This essentially implements field replication <ref> [11, 23] </ref>, which has been shown to offer several advantages. The only change necessary is to add "Dept.name" to the select clause. In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. <p> The data replication adds 2MB of additional space bringing the total database size to 77MB. The new database offers a 7% performance gain over the previous one. It is interesting to note that the technique of field replication as originally described <ref> [11, 23] </ref> cannot be applied to any other field in our database because it is restricted to edges from classes to single-valued attributes. Similar restrictions also prohibit any useful application of path indices in our database. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices [2, 14, 16], join indices [26], and field replication <ref> [11, 23] </ref>, noting their restrictions and comparing their performance to our scheme. Another approach to decomposing the database is hierarchical join indices [27], a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph.
Reference: [12] <author> A. Kemper and G. Moerkotte. </author> <title> Access Support in Object Bases. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 290-301, </pages> <year> 1990. </year>
Reference-contexts: Another approach to decomposing the database is hierarchical join indices [27], a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph. Access Support Relations (ASR) offer a different generalization of join indices <ref> [12] </ref>, which allows the definition of indices over the instances of arbitrary chains of logical schema nodes. This scheme offers a higher degree of flexibility and allows the definition of indices that store both complete and partial instances of each chain.
Reference: [13] <author> A. Kemper and G. Moerkotte. </author> <title> Advanced Query Processing in Object Bases Using Access Support Relations. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <pages> pages 290-301, </pages> <year> 1990. </year>
Reference-contexts: Examples include research on reusing common subexpressions within a query [9] or between multiple queries [22], reusing results of previous queries [8], and using integrity constraints for semantic query optimization [6]. Kemper and Moerkotte <ref> [13] </ref> opt for a unified approach of translation and op Page 11 timization for the ASRs by extending a rule based op-timizer to include appropriate rewriting rules.
Reference: [14] <author> W. Kim, E. Bertino, and J. Garza. </author> <title> Composite Objects Revisited. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 337-347, </pages> <year> 1989. </year>
Reference-contexts: Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices <ref> [2, 14, 16] </ref>, join indices [26], and field replication [11, 23], noting their restrictions and comparing their performance to our scheme.
Reference: [15] <author> W. Kim, J. F. Garza, N. Ballou, and D. Woelk. </author> <title> Architecture of the ORION Next-generation Database System. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 109-124, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion <ref> [15] </ref> and Zoo [10]) and every collection in collection-based OO systems (e.g., GemStone [16], Extra/Excess [5], and ObjectStore [18]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [16] <author> D. Maier and J. Stein. </author> <title> Indexing in an Object-Oriented DBMS. </title> <booktitle> In 2nd Int. Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 171-182, </pages> <address> Asilomar, CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: In this paper, we restrict both gmap definitions and queries to project-select-join (psj) expressions over a simple semantic data model. We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices <ref> [2, 16] </ref>, field repli Page 1 cation [11, 23], and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. Object-oriented systems that store instances in explicit Page 3 collections rather than class extents <ref> [5, 16, 18] </ref> allow the creation of collection indices, which provide fast access paths only to the subsets of the domains that are included in the collection. Our gmap definition language is powerful enough to express such indices by using restrictions. <p> Previous proposals for the maintenance of complex access paths suggest using ad hoc techniques to accelerate expensive updates, such as internal links between instances in nested indices and field replication [23, 2] or links from instances to their collections <ref> [16, 18] </ref>. We can achieve the same effect by using simple gmaps along the paths that need to be traversed during the update propagation. Gmaps placed at points where expensive joins are performed act like join accelerators in the same way that internal links accelerate joins. <p> For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [15] and Zoo [10]) and every collection in collection-based OO systems (e.g., GemStone <ref> [16] </ref>, Extra/Excess [5], and ObjectStore [18]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices <ref> [2, 14, 16] </ref>, join indices [26], and field replication [11, 23], noting their restrictions and comparing their performance to our scheme.
Reference: [17] <author> R. Miller, Y. Ioannidis, and R. Ramakrishnan. </author> <title> The Use of Information Capacity in Schema Integration and Translation. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <pages> pages 120-133, </pages> <year> 1993. </year>
Reference-contexts: Although the semantics of the update query depends only on the logical schema, its validity may depend on the choice of gmaps used to define the physical schema. For example, the physical schema must have sufficient "information capacity" to hold the inserted data <ref> [17] </ref>. These issues are not addressed in this paper.
Reference: [18] <author> J. Orenstein, S. Haradhvala, B. Marguiles, and D. Saka-hara. </author> <title> Query Processing in the ObjectStore Database System. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <year> 1992. </year>
Reference-contexts: In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. Object-oriented systems that store instances in explicit Page 3 collections rather than class extents <ref> [5, 16, 18] </ref> allow the creation of collection indices, which provide fast access paths only to the subsets of the domains that are included in the collection. Our gmap definition language is powerful enough to express such indices by using restrictions. <p> Previous proposals for the maintenance of complex access paths suggest using ad hoc techniques to accelerate expensive updates, such as internal links between instances in nested indices and field replication [23, 2] or links from instances to their collections <ref> [16, 18] </ref>. We can achieve the same effect by using simple gmaps along the paths that need to be traversed during the update propagation. Gmaps placed at points where expensive joins are performed act like join accelerators in the same way that internal links accelerate joins. <p> For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [15] and Zoo [10]) and every collection in collection-based OO systems (e.g., GemStone [16], Extra/Excess [5], and ObjectStore <ref> [18] </ref>) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [19] <author> N. Roussopoulos. </author> <title> View Indexing in Relational Database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2) </volume> <pages> 259-290, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: As long as the data contents of all these distinct sources can be described by psj-queries over a single logical schema, the query optimizer can translate logical queries into access plans over them. This strategy is similar to the ADMS handling of database interoperability <ref> [19, 20] </ref>. Another application of gmaps is to support cached data in transient main-memory data structures such as arrays or hash tables.
Reference: [20] <author> N. Roussopoulos, N. Economou, and A. Stamenas. </author> <month> ADMS: </month>
Reference-contexts: As long as the data contents of all these distinct sources can be described by psj-queries over a single logical schema, the query optimizer can translate logical queries into access plans over them. This strategy is similar to the ADMS handling of database interoperability <ref> [19, 20] </ref>. Another application of gmaps is to support cached data in transient main-memory data structures such as arrays or hash tables.
References-found: 20

