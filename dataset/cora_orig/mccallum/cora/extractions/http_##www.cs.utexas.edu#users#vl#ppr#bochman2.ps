URL: http://www.cs.utexas.edu/users/vl/ppr/bochman2.ps
Refering-URL: http://www.cs.utexas.edu/users/vl/ppr/reviews97.html
Root-URL: 
Email: email: bochman@macs.biu.ac.il  
Title: A Logical Foundation for Logic Programming II: Semantics of General Logic Programs Foundations of logic
Author: Alexander Bochman 
Note: Keywords.  
Abstract: We suggested in [12] a general logical formalism for Logic Programming based on a four-valued inference. In this paper we give a uniform representation of various semantics for logic programs based on this formalism. The main conclusion from this representation is that the distinction between these semantics can be largely attributed to the difference in their underlying (monotonic) logical systems. Moreover, in most cases the difference can even be reduced to that of the language, that is, to the difference in the logical connectives allowed for representing derivable information.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.J. Alferes and L.M. Pereira. </author> <title> (1992) On logic program semantics with two kinds of negation. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Logic Programming: Proc. 1992 Joint Int. Conf. and Symp., </booktitle> <pages> pages 574-589, </pages> <address> Cambridge, Mass., </address> <publisher> MIT Press. </publisher>
Reference-contexts: See [7, 6, 10] for some initial results in this direction. 2 Actually, our coherence rules for such languages are strongly related to the coherence rule for the second negation from <ref> [1] </ref>. 21
Reference: [2] <author> C. </author> <title> Baral (1992) Generalized negation as failure and semantics of normal disjunctive logic programs. </title> <editor> In A. </editor> <booktitle> Voronkov (ed) Logic Programming and Automated Reasoning (LNAI 624), </booktitle> <pages> pp. 309-319. </pages>
Reference-contexts: The above theorem shows, in effect, that in computing the set of f_; ~g-propositions provable or refutable in the f_; ~g-completion, we can consider provability in the corresponding invariant completion. Remark. f_; ~g-propositions can be considered as describing generalized states in the sense of Baral <ref> [2] </ref>. It remains to be seen how our construction is related to that suggested by Baral. 17 To end this section, we will consider a relatively simple logical procedure for computing the p-stable semantics.
Reference: [3] <author> C. </author> <title> Baral and V.S. Subrahmanian (1991) Dualities between alternative semantics for logic programming and nonmonotonic reasoning (Extended abstract). </title> <booktitle> Proc. First Int. Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <pages> pp. 69-86. </pages>
Reference-contexts: Stable Classes. Surprisingly enough, the language f_; :g turns out to be also appropriate for describing a semantics of stable classes for normal programs suggested by Baral and Subrahmanian <ref> [3, 4] </ref>. Stable classes are defined in these papers as sets of sets of propositions S satisfying the following condition: S = fF (s) j s 2 Sg; where F is a Gelfond-Lifschitz operator giving the least model of the corresponding Gelfond-Lifschitz transformation of a normal program. <p> It can be shown that the set of all sets of the form fA i g constitutes a stable class of the program. However, the corresponding f_; :g-coherent 1 Note that finiteness has been made a part of the definition of stable classes in <ref> [3] </ref>. 12 biconsequence relation admits also (At; At) as its bimodel, where At is a set of all atoms. Summing up the above considerations, we can claim that stationary expansions can serve as a natural generalization of the stable class semantics to more general programs. <p> Baral and Subrahmanian considered some `preferred' stable classes as determining the meaning of a logic program. To begin with, they restricted their attention to strict (inclusion minimal) stable classes. (The latter correspond to maximal stationary expansions.) In <ref> [3] </ref> the authors studied two possible preference orders on such stable classes.
Reference: [4] <author> C. </author> <title> Baral and V.S. Subrahmanian (1992) Stable and extension class theory for logic programs and default logics. </title> <journal> J. of Automated Reasoning, </journal> <volume> 8: </volume> <pages> 345-366. </pages>
Reference-contexts: Stable Classes. Surprisingly enough, the language f_; :g turns out to be also appropriate for describing a semantics of stable classes for normal programs suggested by Baral and Subrahmanian <ref> [3, 4] </ref>. Stable classes are defined in these papers as sets of sets of propositions S satisfying the following condition: S = fF (s) j s 2 Sg; where F is a Gelfond-Lifschitz operator giving the least model of the corresponding Gelfond-Lifschitz transformation of a normal program.
Reference: [5] <author> A. </author> <title> Bochman (1995) Default consequence relations as a logical framework for logic programs. </title> <booktitle> Proc. Third International Conference on Logic Programming and Nonmonotonic Reasoning, LPNMR'95 , Lecture Notes in Artificial Intelligence, </booktitle> <volume> 928, </volume> <pages> pp. 245-258. </pages>
Reference: [6] <author> A. </author> <title> Bochman (1995) On bimodal nonmonotonic logics and their unimodal and nonmodal equivalents. </title> <booktitle> Proc. </booktitle> <publisher> IJCAI'95 , Morgan Kaufmann, </publisher> <pages> pp. 1518-1524. </pages>
Reference-contexts: Thus, the correspondence between our construction and stationary semantics can be used to show that f_; :g-coherence rules can also be used before (as well as in the course of) circumscription. Taking another example, the Consistency rule is admissible in this sense with respect to the stable semantics (see <ref> [8, 6] </ref>), though the Completeness rule is not. In fact, some alternative semantics for logic programs, not described in this paper, can be obtained by imposing certain logical rules on the source biconsequence relation, e.g., Schlipf's stable-by-case semantics [29] (see [8] for details). <p> In this way we can also obtain a representation of extended logic programs containing a second, `classical' negation 2 . In addition, such an extension provides a natural framework for capturing some recent attempts to `transfer' semantics for logic program to broader nonmonotonic contexts. See <ref> [7, 6, 10] </ref> for some initial results in this direction. 2 Actually, our coherence rules for such languages are strongly related to the coherence rule for the second negation from [1]. 21
Reference: [7] <author> A. </author> <title> Bochman (1996) Biconsequence relations for nonmonotonic reasoning. In L.C. </title> <editor> Aiello, J. Doyle, and S.C. Shapiro (eds.) </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. Fifth Int. Conference (KR'96), </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA. </address>
Reference-contexts: Finally, as we mentioned in the first part of this study, there is a fairly general way of `lifting' our formalism to a formalism that subsumes classical inference (see <ref> [7] </ref>). In this way we can also obtain a representation of extended logic programs containing a second, `classical' negation 2 . In addition, such an extension provides a natural framework for capturing some recent attempts to `transfer' semantics for logic program to broader nonmonotonic contexts. <p> In this way we can also obtain a representation of extended logic programs containing a second, `classical' negation 2 . In addition, such an extension provides a natural framework for capturing some recent attempts to `transfer' semantics for logic program to broader nonmonotonic contexts. See <ref> [7, 6, 10] </ref> for some initial results in this direction. 2 Actually, our coherence rules for such languages are strongly related to the coherence rule for the second negation from [1]. 21
Reference: [8] <author> A. </author> <title> Bochman (1996) On a logical basis of normal logic programs. </title> <journal> Fun-damenta Informaticae, </journal> <volume> 28 </volume> <pages> 223-245. </pages>
Reference-contexts: The correspondence between stable classes and our construction is based on an easily established fact (cf. <ref> [8] </ref>) that a pair (u; v) is a positively minimal bimodel of a normal program if and only if u = F (v). Consequently, stable classes turn out to correspond to certain sets of positively minimal bimodels. <p> Thus, the correspondence between our construction and stationary semantics can be used to show that f_; :g-coherence rules can also be used before (as well as in the course of) circumscription. Taking another example, the Consistency rule is admissible in this sense with respect to the stable semantics (see <ref> [8, 6] </ref>), though the Completeness rule is not. In fact, some alternative semantics for logic programs, not described in this paper, can be obtained by imposing certain logical rules on the source biconsequence relation, e.g., Schlipf's stable-by-case semantics [29] (see [8] for details). <p> In fact, some alternative semantics for logic programs, not described in this paper, can be obtained by imposing certain logical rules on the source biconsequence relation, e.g., Schlipf's stable-by-case semantics [29] (see <ref> [8] </ref> for details).
Reference: [9] <author> A. </author> <title> Bochman (1996) What is a four-valued reasoning and how it can be nonmonotonic. </title> <note> (Submitted to J. of Logic and Computation) 22 </note>
Reference: [10] <author> A. </author> <title> Bochman (1996) A study of Przymusinski's static semantics. </title> <note> To ap-pear in Proc. LPNMR'97 </note> . 
Reference-contexts: As can be seen, our four-valued translation is quite similar, the only distinction being the treatment of not. Moreover, the construction of the static semantics involves minimization with respect to objective propositions that has the same effect as circumscription in our construction (see <ref> [10] </ref> for details). As is shown in [15], the static semantic is stronger than D-WFS. In an accompanying paper [10] we present a detailed description of this semantics. <p> Moreover, the construction of the static semantics involves minimization with respect to objective propositions that has the same effect as circumscription in our construction (see <ref> [10] </ref> for details). As is shown in [15], the static semantic is stronger than D-WFS. In an accompanying paper [10] we present a detailed description of this semantics. <p> In this way we can also obtain a representation of extended logic programs containing a second, `classical' negation 2 . In addition, such an extension provides a natural framework for capturing some recent attempts to `transfer' semantics for logic program to broader nonmonotonic contexts. See <ref> [7, 6, 10] </ref> for some initial results in this direction. 2 Actually, our coherence rules for such languages are strongly related to the coherence rule for the second negation from [1]. 21
Reference: [11] <author> A. </author> <title> Bochman (1997) Biconsequence relations: A general formalism of reasoning with inconsistency and incompleteness. </title> <note> (Submitted) </note>
Reference-contexts: Hence, a natural step is to extend the language at least by adding disjunction. If the language contains disjunction, Positive Coherence is al ready equivalent to the following structural rule (see <ref> [11] </ref>): fl a : 2 (where a is a set of propositions), though Negative Coherence is still re-ducible to its singular variant. It turns out that for disjunctive programs, the resulting semantics will coincide with the Disjunctive Well-Founded Semantics (D-WFS), suggested recently by Brass and Dix (see [14]). <p> Local negation and disjunction generate an important class of connectives we call local ones. These are the connectives that are determined `locally' with respect to truth and falsity and behave classically in each of these contexts. As is shown in <ref> [11] </ref>, the Positive and Negative Coherence rules in the language f_; :g are already equivalent, and each of them amounts to the following structural rule: a : fl c : The rule can be informally described as saying that any data consistent with respect to non-falsity should be also consistent with <p> This requirement can be met by restricting our logical connectives to those having identical characterizations with respect to truth and non-falsity. Making precise this latter restriction would lead us to the class of connectives we call invariant (see <ref> [11] </ref>). It turns out that invariant connectives are exactly the classical four-valued connectives that are expressible via f_; :; ~g. As we will show now, the corresponding non-monotonic completion will give us a generalization of Przymusinski's partial stable semantics from [24]. It is shown in [11] that the coherence rules in <p> connectives we call invariant (see <ref> [11] </ref>). It turns out that invariant connectives are exactly the classical four-valued connectives that are expressible via f_; :; ~g. As we will show now, the corresponding non-monotonic completion will give us a generalization of Przymusinski's partial stable semantics from [24]. It is shown in [11] that the coherence rules in the the language f_; :; ~g amount to the following structural rule: a : b fl c : d (Invariance) Any f_; :; ~g-coherent biconsequence relation will be also called invariant . <p> Note first that a bimodel (u; v) is consistent iff (v; u) is complete. Consequently, in computing the p-stable semantics we can restrict our attention to bimodels that are either consistent or complete. This restriction can be expressed with the help of the following structural rule (see <ref> [11] </ref> for details): A : A fl B : B (CC) Biconsequence relations satisfying the rule CC will be called ordered . Recall that any bisequent is expressible by a formula in an invariant language (see Proposition 2.1 in [12]). <p> Applying now Theorem 4.4, we obtain Corollary 4.8. A f_; ~g-proposition belongs to all p-stable bimodels of fl iff it is provable from K i (fl) using (CC) as the only additional rule. Further details on provability in ordered biconsequence relations can be found in <ref> [11] </ref>. 5 Classical Completion and Stable Semantics The following proposition, proved in [11], can be used to show that coherent biconsequence relations in the language with all the classical connectives coincide with ordinary `classical' consequence relations. Proposition 5.1. <p> A f_; ~g-proposition belongs to all p-stable bimodels of fl iff it is provable from K i (fl) using (CC) as the only additional rule. Further details on provability in ordered biconsequence relations can be found in <ref> [11] </ref>. 5 Classical Completion and Stable Semantics The following proposition, proved in [11], can be used to show that coherent biconsequence relations in the language with all the classical connectives coincide with ordinary `classical' consequence relations. Proposition 5.1.
Reference: [12] <author> A. </author> <title> Bochman (1997) A logical foundation for logic programming I: Bi-consequence relations and nonmonotonic completion. </title> <journal> J. of Logic Programming </journal>
Reference-contexts: 1 Introduction This is a second part of the study of a general logical formalism for logic programming (see <ref> [12] </ref>). Briefly, the formalism, called biconsequence relations, involves rules (bisequents) of the form a : b fl c : d that serve as direct representations of program rules of a most general kind, including disjunctive heads with possibly negative literals. <p> This is a reductive version of the Monotonicity rule for biconsequence relation. * The Generalized Principle of Partial Evaluation (GPPE) see <ref> [12] </ref>. * Positive Reduction: if an atom A does not belong to heads of clauses of a program, then all occurrences of A in negative premises can be eliminated. <p> This is due to a special character of the coherence rules in this case that generate a negative extension of the source biconsequence relation (see Definition 3.2 in <ref> [12] </ref>). The following theorem shows that D-WFS coincides with the _-semantics of a program. Notice that in this case SEM + contains disjunctions of atoms, while SEM atomic propositions only. <p> Actually, the language of [26] does not allow for iterations of not at all and treats formulas of the form not A (where A is a classical proposition in the language f_; :g) as new propositional atoms. As is shown in the first part <ref> [12] </ref> (Proposition 2.1), any bisequent can be represented by a formula in the language f_; :; ~g. Consequently, any theory P in Przymusinski's formalism can be directly identified with a biconsequence relation fl P in the language f_; :g. <p> For example, the f_; :g-completion still enjoys the confluence property (see above), and hence the coherence rules can be applied before and in the course of circumscription. In addition, such a semantics always exists for affirmative logic programs (see Proposition 5.2 in <ref> [12] </ref>). However, there are some seemingly plausible desiderata suggested for logic programs that this semantics still does not satisfy. For example, in the case of stratified disjunctive programs, it is weaker than the perfect semantics. 10 3.3 Stationary Expansions vs. Stable Classes. <p> Recall that any bisequent is expressible by a formula in an invariant language (see Proposition 2.1 in <ref> [12] </ref>). Hence, the set of invariant propositions provable in a nonmonotonic completion provides, in a sense, an equivalent description of the whole completion. Note also that a proposition ~A is true in a bimodel if and only A is false in it. <p> The following result shows that ordinary classical models of this theory coincide with stable models of fl. It follows from the fact that the classical completion of a biconsequence relation is the least classical (bi)consequence relation containing the kernel K (fl) (see Theorem 3.4 in the first part <ref> [12] </ref>). Corollary 5.3. If fl is a locally finite biconsequence relation, then stable models of fl are exactly classical models of K s (fl). As a result, the computation of the stable semantics is reducible to checking provability and consistency with respect to a certain classical theory. 19 Remark.
Reference: [13] <author> S. Brass and J. </author> <title> Dix (1995) A general approach to bottom-up computation of disjunctive semantics. </title> <editor> In J. Dix, L. Pereira, and T. Przymusin-ski (eds.) </editor> <booktitle> Nonmonotonic Extensions of Logic Programming, </booktitle> <publisher> LNAI 927, Springer, </publisher> <pages> pp. 127-155. </pages>
Reference-contexts: As a result, the computation of the stable semantics is reducible to checking provability and consistency with respect to a certain classical theory. 19 Remark. In the case of disjunctive programs, the above procedure coincides with the procedure of computing the stable semantics suggested by Brass and Dix in <ref> [13] </ref>. The stable semantics for logic programs constitutes, in a sense, a limit case no nontrivial extension of it is possible in the framework of our general construction.
Reference: [14] <author> S. Brass and J. </author> <title> Dix (1997) Characterizations of the Disjunctive Well-founded Semantics: Confluent Calculi and Iterated GCWA. </title> <journal> Journal of Automated Reasoning, </journal> <note> to appear. </note>
Reference-contexts: It turns out that for disjunctive programs, the resulting semantics will coincide with the Disjunctive Well-Founded Semantics (D-WFS), suggested recently by Brass and Dix (see <ref> [14] </ref>). D-WFS is definable as the least semantics that is invariant under the following "Reduction & Elimination" transformations of a disjunctive program: * Elimination of Tautologies: elimination of program clauses containing common atoms in heads and bodies.
Reference: [15] <author> S. Brass, J. Dix I. Niemela and T. </author> <title> Przymusinski (1997) Comparison and efficient computation of the static and the Disjunctive WFS. </title> <editor> In G. Brewka, E. Weydert, and C. Witteveen, editors, </editor> <booktitle> Proceedings of the third Dutch-German Workshop on Nonmonotonic Reasoning and its Applications, </booktitle> <pages> pages 37-42. </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: In other words, this reduction calculus provides a fairly general way of transforming our purely declarative description into a computation procedure. The above semantics is also closely connected with Przymusinski's static semantics of general logic programs [27] (see <ref> [15] </ref>). The latter is defined in the framework of the Autoepistemic Logic of minimal Beliefs (AEB) which is formulated in the classical language augmented with a modal belief operator B. <p> Moreover, the construction of the static semantics involves minimization with respect to objective propositions that has the same effect as circumscription in our construction (see [10] for details). As is shown in <ref> [15] </ref>, the static semantic is stronger than D-WFS. In an accompanying paper [10] we present a detailed description of this semantics.
Reference: [16] <author> S. Brass, J. Dix and T. </author> <title> Przymusinski (1996) Super logic programs. In L.C. </title> <editor> Aiello, J. Doyle, and S.C. Shapiro (eds.) </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. Fifth Int. Conference (KR'96), </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA., </address> <pages> pages 529-541. </pages>
Reference: [17] <author> J. Dix and M. </author> <title> Muller (1994) Partial evaluation and relevance for approximations of the stable semantics. </title> <editor> Z.W. Raz and M. Zemankova (eds) Proc. </editor> <publisher> ISMIS'94 , LNAI 869, </publisher> <pages> pp. 511-520. </pages>
Reference: [18] <author> L. Giordano and A. </author> <title> Martelli (1995) A logical characterization for truth maintenance systems with dependency-directed backtracking. </title> <booktitle> Computational Intelligence 11: </booktitle> <pages> 11-46. </pages>
Reference-contexts: In addition, the issue is intimately connected with some current approaches to nonmonotonic revision of logic programs (see, e.g., <ref> [18, 32] </ref>), according to which in cases when the resulting nonmonotonic semantics is inconsistent, we can extend the source program by new rules (e.g., contrapositions of some of the existing rules) that would restore consistency.
Reference: [19] <author> K. Inoue and C. </author> <title> Sakama (1994) On positive occurrences of negation as failure. </title> <booktitle> In Proc. 4th Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <address> KR'94, </address> <publisher> Morgan Kauffman, </publisher> <address> San Francisco, CA., </address> <year> 1994, </year> <pages> pages 293-304. 23 </pages>
Reference-contexts: Consequently, the resulting system becomes identical to an ordinary classical sequent calculus. The following result shows that the classical completion corresponds to stable, or answer set, semantics of general logic programs (see, e.g., <ref> [19, 20, 21] </ref>). Theorem 5.2. Stable models of any program P coincide with bimodels of the nonmonotonic completion of P in the full classical language.
Reference: [20] <author> V. </author> <title> Lifschitz (1994) Minimal belief and negation as failure. </title> <journal> Artificial In--telligence, </journal> <volume> 70 </volume> <pages> 53-72, </pages> <year> 1994. </year>
Reference-contexts: Consequently, the resulting system becomes identical to an ordinary classical sequent calculus. The following result shows that the classical completion corresponds to stable, or answer set, semantics of general logic programs (see, e.g., <ref> [19, 20, 21] </ref>). Theorem 5.2. Stable models of any program P coincide with bimodels of the nonmonotonic completion of P in the full classical language.
Reference: [21] <author> V. Lifschitz and T. </author> <title> Woo (1992) Answer sets in general nonmonotonic reasoning (preliminary report). </title> <booktitle> In Proc. Third Int. Conf. on Principles of Knowledge Representation and Reasoning, KR`92, </booktitle> <publisher> Morgan Kauffman, </publisher> <year> 1992, </year> <pages> pages 603-614. </pages>
Reference-contexts: Consequently, the resulting system becomes identical to an ordinary classical sequent calculus. The following result shows that the classical completion corresponds to stable, or answer set, semantics of general logic programs (see, e.g., <ref> [19, 20, 21] </ref>). Theorem 5.2. Stable models of any program P coincide with bimodels of the nonmonotonic completion of P in the full classical language.
Reference: [22] <author> M. Muller and J. </author> <title> Dix (1993) Implementing semantics of disjunctive logic programs using fringes and abstract properties (extended abstract). </title> <booktitle> In Proc. Second Int. Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <editor> L.M. Pereira and A. Nerode (eds.), </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993, </year> <pages> pages 43-59. </pages>
Reference-contexts: The resulting `extended' stationary semantics has many interesting features that we are intending to discuss elsewhere. We mention here only that two special cases of DIR, used in <ref> [22] </ref> for defining the stationary semantics, have turned out to be structural equivalents of the coherence rules in the language f_; ^; Lg.
Reference: [23] <author> T.C. </author> <title> Przymusinski (1988) On the declarative semantics of stratified deductive databases and logic programs. </title> <editor> In J. </editor> <booktitle> Minker (ed) Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pp. 193-216, </pages> <publisher> Morgan Kauffman, </publisher> <address> Los Altos, CA. </address>
Reference: [24] <author> T.C. </author> <title> Przymusinski (1990) The well-founded semantics coincides with the three-valued stable semantics. </title> <journal> Fundamenta Informaticae, </journal> <volume> 13: </volume> <pages> 445-464. </pages>
Reference-contexts: It turns out that invariant connectives are exactly the classical four-valued connectives that are expressible via f_; :; ~g. As we will show now, the corresponding non-monotonic completion will give us a generalization of Przymusinski's partial stable semantics from <ref> [24] </ref>. It is shown in [11] that the coherence rules in the the language f_; :; ~g amount to the following structural rule: a : b fl c : d (Invariance) Any f_; :; ~g-coherent biconsequence relation will be also called invariant .
Reference: [25] <author> T.C. </author> <title> Przymusinski (1991) Stable semantics for disjunctive programs New Generation Computing, </title> <booktitle> 9: </booktitle> <pages> 401-424. </pages>
Reference-contexts: Namely, the partial stable semantics is obtained by restricting the set of stable classes to ordered classes containing at most two elements. Przymusinski has also suggested a generalization of partial stable semantics for disjunctive programs (see <ref> [25] </ref>). The resulting disjunctive partial stable semantics is somewhat weaker, however, than ours. To begin with, the following result shows that any p-stable bimodel is a disjunctive partial stable model. Theorem 4.3. <p> In fact, the only thing we must do in order to obtain a characterization of p-stable bimodels is to drop the restriction to consistent models in the definition of a minimal model, given in <ref> [25] </ref>. Still, the two definitions can be shown to coincide for normal programs. They also give the same results for total stable models (see below). It can be shown that any disjunctive partial stable model in the sense of Przymusinski is also a positively minimal bimodel of a program. <p> A f_; ~g-proposition A is false in some p-stable bimodel of a biconse-quence relation fl iff it can be classically false with respect to fl cc , that is, if : A 1 cc A :. As follows from the results of Przymusinski in <ref> [25] </ref>, p-stable semantics subsumes both the well-founded semantics of normal logic programs and the perfect semantics for stratified disjunctive programs. Unfortunately, the following example given in [25] shows that it is not always consistent even for disjunctive programs: W ork _ T ired _ Sleep W ork not T ired Sleep <p> As follows from the results of Przymusinski in <ref> [25] </ref>, p-stable semantics subsumes both the well-founded semantics of normal logic programs and the perfect semantics for stratified disjunctive programs. Unfortunately, the following example given in [25] shows that it is not always consistent even for disjunctive programs: W ork _ T ired _ Sleep W ork not T ired Sleep not W ork T ired not Sleep The static, and even stable class semantics for this program contains W ork _ T ired _ Sleep, and
Reference: [26] <author> T.C. </author> <title> Przymusinski (1991) Semantics of disjunctive logic programs and deductive databases. </title> <booktitle> In Proc. Second Int. Conf. on Deductive and Object-Oriented Databases, </booktitle> <publisher> DOOD'91 , Springer Verlag, </publisher> <pages> pp. 85-107. </pages>
Reference-contexts: We begin with an earlier version of the stationary semantics, suggested by Przymusinski in <ref> [26] </ref>. In fact, the formalism used by Przymusinski in that paper is almost identical with the four-valued logic in the language f_; :; ~g, the only addition being that our switching negation ~ (that corresponds to not in Przymusinski's formalism) satisfies the rule of double negation. Actually, the language of [26] <p> <ref> [26] </ref>. In fact, the formalism used by Przymusinski in that paper is almost identical with the four-valued logic in the language f_; :; ~g, the only addition being that our switching negation ~ (that corresponds to not in Przymusinski's formalism) satisfies the rule of double negation. Actually, the language of [26] does not allow for iterations of not at all and treats formulas of the form not A (where A is a classical proposition in the language f_; :g) as new propositional atoms. <p> ) is a pure stationary completion of a disjunctive program P and SEM P = (SEM + ; SEM ) is a f_; ^g-semantics of P , then * A 2 SEM + iff not :A 2 S (P ); The construction of the stationary semantics for disjunctive programs in <ref> [26] </ref> involved also the disjunctive inference rule, DIR, introduced in order to cover the perfect semantics for stratified disjunctive programs. The resulting `extended' stationary semantics has many interesting features that we are intending to discuss elsewhere.
Reference: [27] <author> T.C. </author> <title> Przymusinski (1995) Static semantics for normal and disjunctive logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 14 </volume> <pages> 323-357. </pages>
Reference-contexts: In other words, this reduction calculus provides a fairly general way of transforming our purely declarative description into a computation procedure. The above semantics is also closely connected with Przymusinski's static semantics of general logic programs <ref> [27] </ref> (see [15]). The latter is defined in the framework of the Autoepistemic Logic of minimal Beliefs (AEB) which is formulated in the classical language augmented with a modal belief operator B. <p> As can be easily seen, the above rule is stronger than _-coherence, but is weaker than f_; :g-coherence (see below). A couple of examples, taken from <ref> [27] </ref>, will help to clarify the correspondence between the static semantics and our construction. <p> The following example, also from <ref> [27] </ref>, is especially interesting in compar ing our approaches. <p> Moreover, confluence no longer holds in this case, and applications of DIR cannot be restricted to the stage after performing circumscription. 3.2 f_; :g-Completion and `Full' Stationary Semantics. In a later paper, <ref> [27] </ref>, Przymusinski gives another description of what he sees as an intended notion of a stationary semantics. It is obtained from the static semantics by way of adding an axiom of distributivity of the belief operator with respect to disjunctions.
Reference: [28] <author> T.C. </author> <title> Przymusinski (1995) Semantics of normal and disjunctive logic programs: A unifying framework. </title> <editor> In J. Dix, L. Pereira, and T. Przy-musinski, eds., </editor> <booktitle> Proc. Workshop on Non-Monotonic Extensions of Logic Programming, </booktitle> <address> Santa Margherita Ligure, Italy, </address> <month> June </month> <year> 1994, </year> <pages> pages 43-67, </pages> <publisher> Springer Verlag (Lect. Notes in AI). </publisher>
Reference: [29] <author> J. S. </author> <title> Schlipf (1992). Formalizing a logic for logic programming. </title> <journal> Annals of Mathematics and Artificial Intelligence 5 </journal> <pages> 279-302. 24 </pages>
Reference-contexts: In fact, some alternative semantics for logic programs, not described in this paper, can be obtained by imposing certain logical rules on the source biconsequence relation, e.g., Schlipf's stable-by-case semantics <ref> [29] </ref> (see [8] for details).
Reference: [30] <author> J.-H. You and L. Y. </author> <title> Yuan (1994) A three-valued semantics for deductive databases and logic programs. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 49: </volume> <pages> 334-361. </pages>
Reference-contexts: Another major issue is that the nonmonotonic semantics can be strengthened in many cases by considering only some `preferred' bimodels of a non-monotonic completion. This approach has been intensively studied, mainly in the context of normal programs, but see, e.g., <ref> [30] </ref>, where it is applied to disjunctive programs. As we already mentioned in discussing the stable class semantics, many such constructions can be accounted for in our framework by applying some general maximization principles to the nonmonotonic completion.
Reference: [31] <author> A. Van Gelder, K.A. Ross and J.S. </author> <title> Schlipf (1991) The well-founded semantics for general logic programs. </title> <journal> J. ACM, </journal> <volume> 38: </volume> <pages> 620-650. </pages>

References-found: 31

