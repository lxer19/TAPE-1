URL: ftp://ftp.cs.ucsd.edu/pub/carter/icca97.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/ferrante/papers.html
Root-URL: http://www.cs.ucsd.edu
Title: A Compiler Perspective on Architectural Evolutions  
Author: Nicholas Mitchell, Larry Carter, Jeanne Ferrante 
Keyword: cache, compiler, optimization, PlayDoh, prefetch, tiling, TLB  
Abstract: Certain architectural features either constrain or inhibit compiler optimizations. We suggest three hardware changes aimed to improve the situation, from a compiler's perspective. These changes involve redesigns of translation lookaside buffers, communication in memory hierarchies, and page mapping hardware for caches. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Nicholas Mitchell, Larry Carter, Jeanne Ferrante, and Karin Hogstedt, </author> <title> "Quantifying the multi-level nature of tiling interactions," </title> <type> Tech. Rep. </type> <institution> CS97-531, UCSD, Computer Science and Engineering Department, </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: With a wide range of control, a compiler or programmer can choreograph data motion as in Figure 3. We have some indication that, due to inter-level interactions between optimizations <ref> [1] </ref>, such extensions of control to either the programmer or compiler may be necessary to approach peak performance. product, an application which reads and writes sequentially.
Reference: [2] <author> Vinod Kathail, Michael Schlansker, and B. Ramakrinsha Rau, </author> <title> "HPL PlayDoh architecture specification: Version 1.0," </title> <type> Tech. Rep. </type> <institution> HPL-93-80, Hewlett-Packard Company, Computer Systems Laboratory, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: The Intel Pentium Pro extends the hardware's control to registers by using dynamic dataflow analysis. Processors such as the MIPS R10000 give compilers control over cache with cache prefetching instructions, though not with fine enough granularity to distinguish between first- and second-level cache. Hewlett-Packard's Play-Doh <ref> [2] </ref> research architecture includes cache bypassing and extends prefetching to L1 and L2 caches and main memory. This architecture gives fine enough granularity and a large domain of control to the compiler. While it exists only in simulation, PlayDoh offers intriguing possibilities for future compilers. Fig. 5.
Reference: [3] <author> Monica S. Lam, Edward E. Rothberg, and Michael E. Wolf, </author> <title> "The cache performance and optimizations of blocked algorithms," </title> <booktitle> in ASPLOS-IV, </booktitle> <address> Palo Alto, CA, </address> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: Fig. 5. Typically, the low-order bits of the page number concatenated with the low-order bits of the index provide the set number for an address. IV. Randomized Page Mapping With a virtually-indexed cache, an optimizing compiler (or industrious programmer) can predict the effects of associativity on performance <ref> [3] </ref>. With predictable performance, the compiler can effectively avoid associativity problems. For instance, tiling restructures a set of nested loop to reuse the values stored in one rectangular submatrix of a matrix before proceeding to the values in the next submatrix.
Reference: [4] <author> Edouard Bugnion, Jennifer M. Anderson, Todd C. Mowry, Mendel Rosenblum, and Monica Lam, </author> <title> "Compiler-directed page coloring for multiprocessors," </title> <booktitle> in ASPLOS-VII, </booktitle> <address> Cambridge, MA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Several software and hardware changes attempt to solve the predictability problem without modifying source code. Virtually-indexed caches would solve our problem, but physical indexing may be necessary to simplify the design of consistent shared memory. An operating system can use page coloring with dynamic remapping on conflicts <ref> [4] </ref>; this strategy performs best with hardware assistance [5]. Yet another possibility involves using compile-time array layout and access information to direct the operating system's page mapping at runtime (and on a per-application basis) [4]. The dynamic page coloring scheme encounters hot spots by not utilizing program-specific information. <p> An operating system can use page coloring with dynamic remapping on conflicts <ref> [4] </ref>; this strategy performs best with hardware assistance [5]. Yet another possibility involves using compile-time array layout and access information to direct the operating system's page mapping at runtime (and on a per-application basis) [4]. The dynamic page coloring scheme encounters hot spots by not utilizing program-specific information. The compiler-OS solution induces a run-time overhead and runs into problems when applications are fully utilizing available memory [4] We suggest a hardware modification, termed randomized page mapping, to remedy the physical addressing problem. <p> layout and access information to direct the operating system's page mapping at runtime (and on a per-application basis) <ref> [4] </ref>. The dynamic page coloring scheme encounters hot spots by not utilizing program-specific information. The compiler-OS solution induces a run-time overhead and runs into problems when applications are fully utilizing available memory [4] We suggest a hardware modification, termed randomized page mapping, to remedy the physical addressing problem. Work on skewed associativity classes [6] uses a similar approach.
Reference: [5] <author> Theodore H. Romer, Dennis Lee, Brian Bershad, and J. Bradley Chen, </author> <title> "Dynamic page mapping policies for cache conflict resolution on standard hardware," </title> <booktitle> in First Symposium on Operating Systems Design and Implementation, </booktitle> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Virtually-indexed caches would solve our problem, but physical indexing may be necessary to simplify the design of consistent shared memory. An operating system can use page coloring with dynamic remapping on conflicts [4]; this strategy performs best with hardware assistance <ref> [5] </ref>. Yet another possibility involves using compile-time array layout and access information to direct the operating system's page mapping at runtime (and on a per-application basis) [4]. The dynamic page coloring scheme encounters hot spots by not utilizing program-specific information.
Reference: [6] <author> A Seznec, </author> <title> "A case for two-way skewed associative caches," </title> <booktitle> in Proceedings of the 20th International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: The compiler-OS solution induces a run-time overhead and runs into problems when applications are fully utilizing available memory [4] We suggest a hardware modification, termed randomized page mapping, to remedy the physical addressing problem. Work on skewed associativity classes <ref> [6] </ref> uses a similar approach. Instead of directly mapping the low-order bits of the page number to a set, first pass the entire page number through a universal hash function. This operation effectively randomizes the mapping of addresses to sets. Figure 6 visualizes the solution.
References-found: 6

