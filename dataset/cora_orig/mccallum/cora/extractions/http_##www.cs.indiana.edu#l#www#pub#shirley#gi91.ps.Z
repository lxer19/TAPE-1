URL: http://www.cs.indiana.edu/l/www/pub/shirley/gi91.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/pub/shirley/
Root-URL: http://www.cs.indiana.edu
Title: A Ray Tracing Framework for Global Illumination Systems  
Author: Peter Shirley Kelvin Sung William Brown 
Keyword: CR Categories and Subject Descriptors: I.3.0 [Computer Graphics]: General; I.3.6 [Computer Graphics]: Methodology and Techniques. Additional Key Words and Phrases: Ray tracing, radiosity, object-oriented design, zonal method, visual realism.  
Affiliation: Department of Computer Science Indiana University  Department of Computer Science University of Illinois at Urbana-Champaign  Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John M. Airey and Ming Ouh-young. </author> <title> Two adaptive techniques let progressive radiosity outperform the traditional radiosity algorithm. </title> <type> Technical Report TR89-20, </type> <institution> University of North Carolina at Chapel Hill, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination.
Reference: [2] <author> John M. Airey, John H. Rohlf, , and Frederick P. Brooks. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <journal> Computer Graphics, </journal> <volume> 24(1) </volume> <pages> 41-50, </pages> <year> 1990. </year> <booktitle> ACM Workshop on Interactive Graphics Proceedings. </booktitle>
Reference-contexts: reflection protocol should also accept a canonical (u; v) pair (Section 2.2), to be used as a basis for any probabilistic reflection that might occur. 3 Zonal Calculations Several recent zonal (radiosity: global lighting information is stored at a finite set of `zones') systems are based on progressive refinement techniques <ref> [10, 2] </ref>. The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions [7, 40, 18, 39, 36].
Reference: [3] <author> Kansei Iwata Akira Fujimoto, Takayu Tanaka. </author> <title> Arts: Accelerated ray-tracing system. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 16-26, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Notice that a bounding slab is also a primitive in the sense that it must respond to the Hit protocol message by returning the primitives (including children slabs) bounded by the current slab. Spatial Subdivision <ref> [16, 3] </ref>. The Builder module inquires the extent from a primitive and determines which spatial cell should be associated with the primitive. The actual implementation of spatial cell and the association between the primitive is performed by the Structurer module.
Reference: [4] <author> John Amanatides and Don P. Mitchell. </author> <title> Antialiasing of interlaced video animation. </title> <journal> Computer Graphics, </journal> <volume> 24(3) </volume> <pages> 77-86, </pages> <month> August </month> <year> 1990. </year> <booktitle> ACM Siggraph '90 Conference Proceedings. </booktitle>
Reference-contexts: To avoid complications that arise when imprecision causes the hit to be represented as a slightly positive number, we look for the first hit where t &gt; *, where * is a small positive number that bounds the possible roundoff error. Amanitides and Mitchell <ref> [4] </ref> showed that problems can arise when there are real surfaces closer than t = * and provided strategies to use in these cases. We can eliminate the * test by using the surface normal information. Each surface can be viewed as an interface between two materials 5 .
Reference: [5] <author> John Amanatides and Andrew Woo. </author> <title> A fast voxel traversal algorithm for ray tracing. </title> <booktitle> In Eurographics '87, </booktitle> <year> 1987. </year>
Reference-contexts: Because it takes extra time for tree walking to ascend from the deep octants, Glassner's algorithm may be faster in these cases. Mail box. The mail box concept was proposed independently in <ref> [6, 5] </ref>. The idea is to avoid multiple ray-object intersection calculation between the same object and the same ray in different spatial cell units.
Reference: [6] <author> Bruno Arnaldi, Thierry Priol, and Kadi Bouatouch. </author> <title> A new space subdivision method for ray tracing csg mod-elled scenes. </title> <journal> Visual Computer, </journal> <volume> 3 </volume> <pages> 98-107, </pages> <year> 1987. </year>
Reference-contexts: Because it takes extra time for tree walking to ascend from the deep octants, Glassner's algorithm may be faster in these cases. Mail box. The mail box concept was proposed independently in <ref> [6, 5] </ref>. The idea is to avoid multiple ray-object intersection calculation between the same object and the same ray in different spatial cell units.
Reference: [7] <author> James Arvo. </author> <title> Backward ray tracing. </title> <booktitle> Developments in Ray Tracing, </booktitle> <pages> pages 259-263, </pages> <year> 1985. </year> <note> ACM Siggraph '85 Course Notes. </note>
Reference-contexts: The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions <ref> [7, 40, 18, 39, 36] </ref>. These solutions are easy to construct if we view the zone as a black box which collects power carrying rays, and later emits a group of power carrying rays that represent reflected power accumulated since the previous emission step.
Reference: [8] <author> James Arvo and David Kirk. </author> <title> A survey of ray tracing acceleration techniques. </title> <editor> In Andrew S. Glassner, editor, </editor> <title> An Introduction to Ray Tracing. </title> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1989. </year>
Reference-contexts: With this simple definition, this component can be implemented as a black box framework [25]. Our goal here is to present the design of a framework to facilitate the independent development of different algorithms for this component. We use the Faster Ray Intersection Techniques as described by <ref> [8] </ref> as a base to discuss our design and show that our design unifies the approaches. <p> It is a primitive's responsibility to calculate for possible intersections. Under this design, the ray-object intersection component becomes the coordinator that assists and thus speeds up the process of searching for potential intersecting primitives. The acceleration techniques for faster intersection calculations as described in <ref> [8] </ref> are unified under this design: Bounding Slabs [27]. The Builder module inquires the bounding slab distances from the primitive. In this case, the bounding slab is the "geometry characteristic". The Struc-turer module associates the primitive with the corresponding slab and slab distances.
Reference: [9] <author> Norman F. Barnes. </author> <title> Color characteristics of artists' pigments. </title> <journal> Journal of the Optical Society of America, </journal> <month> May </month> <year> 1939. </year>
Reference-contexts: Unfortunately this data can be hard to come by, and directly specifying spectral curves is not intuitive. In these cases we generate curves by `mixing' standard artist's pigments, the curves for which can be found in <ref> [9] </ref>. When we have existing rgb data, we use Glassner's conversion method [17].
Reference: [10] <author> Michael F. Cohen, Shenchang Eric Chen, John R. Wal-lace, and Donald P. Greenberg. </author> <title> A progressive refinement approach to fast radiosity image generation. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 75-84, </pages> <month> August </month> <year> 1988. </year> <booktitle> ACM Sig-graph '88 Conference Proceedings. </booktitle>
Reference-contexts: reflection protocol should also accept a canonical (u; v) pair (Section 2.2), to be used as a basis for any probabilistic reflection that might occur. 3 Zonal Calculations Several recent zonal (radiosity: global lighting information is stored at a finite set of `zones') systems are based on progressive refinement techniques <ref> [10, 2] </ref>. The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions [7, 40, 18, 39, 36].
Reference: [11] <author> Michael F. Cohen and Donald P. Greenberg. </author> <title> The hemi-cube: a radiosity solution for complex environments. </title> <journal> Computer Graphics, </journal> <volume> 19(3) </volume> <pages> 31-40, </pages> <month> July </month> <year> 1985. </year> <booktitle> ACM Sig-graph '85 Conference Proceedings. </booktitle>
Reference-contexts: For example, it is possible to define and ray trace a large cylinder primitive. In a zonal renderer, all primitives must be turned into patches. In order to generate high quality final image, it is often necessary to generate relatively small patches <ref> [11] </ref>; thus all large primitives need to be break down into small patches. The probability of these small size patches stretching across spatial units are smaller.
Reference: [12] <author> Robert L. Cook. </author> <title> Stochastic sampling in computer graphics. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(1) </volume> <pages> 51-72, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. <p> Many spaces we need to sample (e.g lens area, reflection ray direction) are not square. One way to generate sample points on a non-square region is a special purpose algorithm, such as the one used by Cook for reflected rays <ref> [12] </ref>. The other is to generate points on the square and then apply a warping function so that their distribution is changed. An example of this method is the transformation used by Ward et al. to generate a cosine distribution of sample points on a hemisphere [46]. <p> We could simply apply weights to each sample point based on its (u; v) coordinate. If we sample each pixel independently it is better to apply importance sampling by placing the sample points in a way that is distributed according to the weighting function <ref> [12] </ref>. In this section, we describe a module that takes a set of n uniformly distributed points, and somehow warps them in a way that they are distributed according to the desired weighting function.
Reference: [13] <author> Robert L. Cook, Thomas Porter, and Loren Carpenter. </author> <title> Distributed ray tracing. </title> <journal> Computer Graphics, </journal> <volume> 18(4) </volume> <pages> 165-174, </pages> <month> July </month> <year> 1984. </year> <booktitle> ACM Siggraph '84 Conference Proceedings. </booktitle>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. <p> Cook calls his specific version of this method uncorrelated jittering. There has been much discussion on how to get a `good' set of sample points on a square two-dimensional region <ref> [13, 31] </ref>. Many spaces we need to sample (e.g lens area, reflection ray direction) are not square. One way to generate sample points on a non-square region is a special purpose algorithm, such as the one used by Cook for reflected rays [12].
Reference: [14] <author> James D. Foley, Andries van Dam, Steven K. Feiner, and John F. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: These test results, and some analysis on why this might be true can be found in [38, 41]. 2.2.2 Sample Distribution Transformations Suppose we want to apply weighted area averaging to a pixel rather than simple area averaging <ref> [14] </ref>. We could simply apply weights to each sample point based on its (u; v) coordinate. If we sample each pixel independently it is better to apply importance sampling by placing the sample points in a way that is distributed according to the weighting function [12].
Reference: [15] <author> Andrew Glassner. </author> <title> Implementation notes for ray tracers. Advanced Topics in Ray Tracing, </title> <note> 1990. ACM Siggraph '90 Course 24 Notes. </note>
Reference-contexts: As a result, we are able to isolate and observe the effect of different algorithms. Some interesting observations we thus get are described here: Octree Traversal. It is believed that the original octree traversal algorithm [16] can be improved by realizing tree location coherence <ref> [15] </ref>. In his original octree paper [16], Glassner proposed to always begin the search for next oc-tant from the root of an octree. <p> It is believed that the original octree traversal algorithm [16] can be improved by realizing tree location coherence [15]. In his original octree paper [16], Glassner proposed to always begin the search for next oc-tant from the root of an octree. It has been pointed out by various researchers <ref> [24, 15] </ref> that theoretically, starting the next octant search from the parent of current octant should be faster (this approach has been called tree walking [15]). However, Sung observed that in a zonal renderer, tree walking may be slower than that of the Glassner's original algorithm [43]. <p> It has been pointed out by various researchers [24, 15] that theoretically, starting the next octant search from the parent of current octant should be faster (this approach has been called tree walking <ref> [15] </ref>). However, Sung observed that in a zonal renderer, tree walking may be slower than that of the Glassner's original algorithm [43].
Reference: [16] <author> Andrew S. Glassner. </author> <title> Space subdivision for fast ray tracing. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4(10) </volume> <pages> 15-22, </pages> <year> 1984. </year>
Reference-contexts: Notice that a bounding slab is also a primitive in the sense that it must respond to the Hit protocol message by returning the primitives (including children slabs) bounded by the current slab. Spatial Subdivision <ref> [16, 3] </ref>. The Builder module inquires the extent from a primitive and determines which spatial cell should be associated with the primitive. The actual implementation of spatial cell and the association between the primitive is performed by the Structurer module. <p> The traverser module knows how to traverse an octree, but does not need to know the detail implementation of the octree structure. Some of the examples of octree traversers are: linear octree walking 3 , Glassner's algorithm <ref> [16] </ref>, and DDA octree traverser [43]. 2.3.3 Implementation Notes Following the design approach described in this section, it is possible to replace a module in this component with the rest of the system remaining unchanged. As a result, we are able to isolate and observe the effect of different algorithms. <p> As a result, we are able to isolate and observe the effect of different algorithms. Some interesting observations we thus get are described here: Octree Traversal. It is believed that the original octree traversal algorithm <ref> [16] </ref> can be improved by realizing tree location coherence [15]. In his original octree paper [16], Glassner proposed to always begin the search for next oc-tant from the root of an octree. <p> Some interesting observations we thus get are described here: Octree Traversal. It is believed that the original octree traversal algorithm <ref> [16] </ref> can be improved by realizing tree location coherence [15]. In his original octree paper [16], Glassner proposed to always begin the search for next oc-tant from the root of an octree.
Reference: [17] <author> Andrew S. Glassner. </author> <title> How to derive a spectrum from an rgb triplet. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 9(7) </volume> <pages> 95-99, </pages> <year> 1989. </year>
Reference-contexts: Unfortunately this data can be hard to come by, and directly specifying spectral curves is not intuitive. In these cases we generate curves by `mixing' standard artist's pigments, the curves for which can be found in [9]. When we have existing rgb data, we use Glassner's conversion method <ref> [17] </ref>. It has been our experience that using smooth curves for this conversion is highly preferable to using impulses. 2.2 Sample Point Generation A basic module in any ray tracing code selects sample points on the pixel (in some systems the samples are chosen more glabally on the screen).
Reference: [18] <author> David Edward Hall. </author> <title> An analysis and modification of shao's radiosity method for computer graphics image synthesis. </title> <type> Master's thesis, </type> <institution> Department of Mechanical Engineering, Georgia Institute of Technology, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions <ref> [7, 40, 18, 39, 36] </ref>. These solutions are easy to construct if we view the zone as a black box which collects power carrying rays, and later emits a group of power carrying rays that represent reflected power accumulated since the previous emission step. <p> The radiance of the zone will just be =(A), where A is the area of the zone. For a zone with directionally dependent reflection behavior, such as brushed steel, we must maintain the total and unsent power as some kind of directional table <ref> [18, 39, 36] </ref>. A simple way to do this is a simple spherical coordinate array of bins, with the total power going through each bin. The unsent and total power of the diffuse case must be generaized to a new black box, the angular distribution function (adf).
Reference: [19] <author> Roy Hall. </author> <title> Illumination and Color in Computer Generated Imagery. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: We treat light-material interaction as a component, where the reflection behavior is determined strictly from a set of material parameters. Traditionally this might be accomplished with one shading model with parameters including ks, kt, and kd <ref> [19] </ref>. One problem with such an approach is that physically implausible parameter combinations can be chosen by the user (e.g. kd = ks = 0, kt = 1).
Reference: [20] <author> Roy Hall and Donald P. Greenberg. </author> <title> A testbed for realistic image synthesis. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 3(8) </volume> <pages> 10-20, </pages> <year> 1983. </year>
Reference-contexts: The first is a material id which stores the material the ray is in (e.g. `this ray is now traveling through glass'). The second characteristic is the attenuation of the ray. This makes the bookkeeping associated with adaptive ray tree pruning <ref> [20] </ref> straightforward. A utility class that has been surprisingly useful is an or-thonormal basis of three vectors. Though any two of these vectors uniquely defines the basis, all three are explicitly stored, trading space for execution time.
Reference: [21] <author> Pat Hanrahan and Jim Lawson. </author> <title> A language for shading and lighting calculations. </title> <journal> Computer Graphics, </journal> <volume> 24(3) </volume> <pages> 289-298, </pages> <month> August </month> <year> 1990. </year> <booktitle> ACM Siggraph '90 Conference Proceedings. </booktitle>
Reference-contexts: Kirk and Arvo also described a shader component, which encapsulates the local illumination model as a basic compo 1 nent. A similar shader concept has been advanced by various researchers <ref> [44, 21] </ref>. In this section, we describe the basic components of our ray tracing framework. In Section 2.1 we present several simple classes that are useful in graphics programs. The components which manage sample distributions on the pixel are discussed in Section 2.2. <p> In summary, the benifits of the mailbox technique may be highly dependent on the general geometric character of the geometric primatives used. 2.4 Ray-Material Interaction Several researchers have noted that reflection behavior should be encapsulated as one unit of a rendering system <ref> [28, 44, 21] </ref>. We treat light-material interaction as a component, where the reflection behavior is determined strictly from a set of material parameters. Traditionally this might be accomplished with one shading model with parameters including ks, kt, and kd [19]. <p> If the `material' were to handle all shading in this situation, it would need access to steel, marble, and dust reflectance behavior, as well as the procedural texture describing the dust. This could be accomplished in a manner similar to a Renderman shader <ref> [44, 21] </ref>, where the shading routine has access to the internals of reflection models and textures. Unfortunately, such a shader does not hide much information, and can become quite unwieldy.
Reference: [22] <author> Paul S. Heckbert. </author> <title> Writing a ray tracer. </title> <editor> In Andrew S. Glassner, editor, </editor> <title> An Introduction to Ray Tracing. </title> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem [47, 13, 12, 26, 46, 45, 1, 40, 23]. Other authors have applied object-oriented design to ray tracing programs <ref> [28, 22] </ref>. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. There are several existing systems that enable programmers to construct user interfaces from basic components (e.g menus, scrollbars, windows). <p> example global illumination system assembled from these components is described in Section 4. 2 Ray Tracing Components Heckbert observed that geometrical objects should be viewed as basic components with common interface protocols, so that a ray tracing system can be designed independently from the geometrical primitive types (e.g. spheres, polygons) <ref> [22] </ref>. Kirk and Arvo have generalized this idea, by observing that ray-object intersection search structures, such as octrees, have the same interface protocols as geometrical primitives. This generalization allows the ray tracing system to be designed independently of both geometrical primative types, and ray-object intersection optimization strategy [28].
Reference: [23] <author> Paul S. Heckbert. </author> <title> Adaptive radiosity textures for bidirectional ray tracing. </title> <journal> Computer Graphics, </journal> <volume> 24(3) </volume> <pages> 145-154, </pages> <month> August </month> <year> 1990. </year> <booktitle> ACM Siggraph '90 Conference Proceedings. </booktitle>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination.
Reference: [24] <author> Frederik W. Jansen. </author> <title> Data structures for ray tracing. </title> <editor> In L. R. A. Kessener, F. J. Peters, and M. L. P. van Lierop, editors, </editor> <booktitle> Data Sturctures for Raster Graphics, </booktitle> <pages> pages 57-373. </pages> <publisher> Springer-Verlag, </publisher> <address> Netherlands, </address> <year> 1986. </year>
Reference-contexts: It is believed that the original octree traversal algorithm [16] can be improved by realizing tree location coherence [15]. In his original octree paper [16], Glassner proposed to always begin the search for next oc-tant from the root of an octree. It has been pointed out by various researchers <ref> [24, 15] </ref> that theoretically, starting the next octant search from the parent of current octant should be faster (this approach has been called tree walking [15]). However, Sung observed that in a zonal renderer, tree walking may be slower than that of the Glassner's original algorithm [43].
Reference: [25] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> pages 22-35, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Email: ksung@cs.uiuc.edu z Dept. of Computer Science, University of Illinois, Urbana, Illinois 61801. Email: brown@cs.uiuc.edu 1 Components are defined by their behavior and their interface protocols. This is the same as the black box framework described by Johnson and Foote <ref> [25] </ref>. specified only by their interface protocols, so different implementations of the same component can be invisibly exchanged in a particular system, which allows isolated testing of particular component implementations. This, of course, is simply an instance of abstract data typing. The design strategy outlined above is not novel. <p> With this simple definition, this component can be implemented as a black box framework <ref> [25] </ref>. Our goal here is to present the design of a framework to facilitate the independent development of different algorithms for this component. We use the Faster Ray Intersection Techniques as described by [8] as a base to discuss our design and show that our design unifies the approaches.
Reference: [26] <author> James T. Kajiya. </author> <title> The rendering equation. </title> <journal> Computer Graphics, </journal> <volume> 20(4) </volume> <pages> 143-150, </pages> <month> August </month> <year> 1986. </year> <booktitle> ACM Siggraph '86 Conference Proceedings. </booktitle>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. <p> The geometry model should be processed into some internal representation (e.g. collection structures like octree) for efficient candidate primitive look up during intersection testings. Since current ray tracers and zonal renderers only model geometrical optics <ref> [26] </ref>, the processed internal representation could be viewed as an efficient primitive/geometry-characteristic association list storage and look up mechanism. From the design level, the ray-object intersection component consists of three functional modules: Builder, Struc-turer, and Traverser.
Reference: [27] <author> Timothy L. Kay and James T. Kajiya. </author> <title> Ray tracing complex scenes. </title> <journal> Computer Graphics, </journal> <volume> 20(4) </volume> <pages> 269-278, </pages> <month> August </month> <year> 1986. </year> <booktitle> ACM Siggraph '86 Conference Proceedings. </booktitle>
Reference-contexts: Under this design, the ray-object intersection component becomes the coordinator that assists and thus speeds up the process of searching for potential intersecting primitives. The acceleration techniques for faster intersection calculations as described in [8] are unified under this design: Bounding Slabs <ref> [27] </ref>. The Builder module inquires the bounding slab distances from the primitive. In this case, the bounding slab is the "geometry characteristic". The Struc-turer module associates the primitive with the corresponding slab and slab distances. The construction of the bounding slab hierarchy is also the responsibility of the structurer module.
Reference: [28] <author> David Kirk and James Arvo. </author> <title> The ray tracing kernal. </title> <booktitle> In Proceedins of Ausgraph, </booktitle> <pages> pages 75-82, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem [47, 13, 12, 26, 46, 45, 1, 40, 23]. Other authors have applied object-oriented design to ray tracing programs <ref> [28, 22] </ref>. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. There are several existing systems that enable programmers to construct user interfaces from basic components (e.g menus, scrollbars, windows). <p> Finally, the paper summaries by providing an example of a full global illumination system assembled from the basic components. The fundamental components of a distributed ray tracing system are described in Section 2. This extends the basic framework presented by Kirk and Arvo <ref> [28] </ref>. In Section 3 we describe the new components that are needed for zonal calculations, and discuss how the ray tracing components can be reused. <p> Kirk and Arvo have generalized this idea, by observing that ray-object intersection search structures, such as octrees, have the same interface protocols as geometrical primitives. This generalization allows the ray tracing system to be designed independently of both geometrical primative types, and ray-object intersection optimization strategy <ref> [28] </ref>. Kirk and Arvo also described a shader component, which encapsulates the local illumination model as a basic compo 1 nent. A similar shader concept has been advanced by various researchers [44, 21]. In this section, we describe the basic components of our ray tracing framework. <p> We use the Faster Ray Intersection Techniques as described by [8] as a base to discuss our design and show that our design unifies the approaches. This section concludes with some interesting implementation observations. 2.3.1 Class Hierarchy Like Kirk and Arvo <ref> [28] </ref>, we implemented geometrical primitives (e.g. sphere, polygon) and collection structures (e.g. octree, bounding volume) as subclasses of the same geom-object abstract class. In this way, they can have the same interface protocols and behaviors. <p> In summary, the benifits of the mailbox technique may be highly dependent on the general geometric character of the geometric primatives used. 2.4 Ray-Material Interaction Several researchers have noted that reflection behavior should be encapsulated as one unit of a rendering system <ref> [28, 44, 21] </ref>. We treat light-material interaction as a component, where the reflection behavior is determined strictly from a set of material parameters. Traditionally this might be accomplished with one shading model with parameters including ks, kt, and kd [19].
Reference: [29] <author> Donald Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Volume 3. </volume> <publisher> Addison-Wesley, </publisher> <address> New York, N.Y., </address> <year> 1981. </year>
Reference-contexts: For example, suppose we have the width 2 weighting function: w (x; y) = (1 jxj) (1 jyj) (1) If we just wanted to generate independent random points with density w, we can apply standard techniques to transform canonical 2 random numbers into these points <ref> [29] </ref>. Since this particular w is separable, we can generate x according to w (x) = (1 jxj), and y the same way.
Reference: [30] <author> Gary W. Meyer, Holly E. Rushmeyer, Michael F. Co-hen, Donald P. Greenberg, and Kenneth E. Torrance. </author> <title> An experimental evaluation of computer graphics imagery. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(1) </volume> <pages> 30-50, </pages> <month> Jan-uary </month> <year> 1986. </year>
Reference-contexts: Next, we switched to twenty evenly spaced nodes were used to represent color spectra. Because this had a high storage cost (especially for images using zonal calculations), the four unevenly spaced node locations suggested by Meyer was used <ref> [30] </ref>. There was no qualitative loss in image quality observed going from the twenty to four samples, but this may say more about the arbitrary nature of most of the input spectral curves than about the quality of the spectral approximation.
Reference: [31] <author> Don P. Mitchell. </author> <title> Generating antialiased images at low sampling densities. </title> <journal> Computer Graphics, </journal> <volume> 21(4) </volume> <pages> 65-72, </pages> <month> July </month> <year> 1987. </year> <booktitle> ACM Siggraph '87 Conference Proceedings. </booktitle>
Reference-contexts: Cook calls his specific version of this method uncorrelated jittering. There has been much discussion on how to get a `good' set of sample points on a square two-dimensional region <ref> [13, 31] </ref>. Many spaces we need to sample (e.g lens area, reflection ray direction) are not square. One way to generate sample points on a non-square region is a special purpose algorithm, such as the one used by Cook for reflected rays [12]. <p> Poisson disk has nondeterministic running time, and choosing the disk radius is not straightforward. Mitchell addressed the first problem with an approximation to poisson disk sampling based on error diffusion <ref> [31] </ref>. We have implemented these strategies and one new strategy, n-rooks sampling. N-rooks is a variation of Cook's uncorrelated jittering. We generate the u coordinates of the n points by jittering in one dimension, and then generate n v coordinates in the same way.
Reference: [32] <author> Masataka Ohta and Mamoru Maekawa. </author> <title> Ray coherence theorom and constant time ray tracing algorithm. </title> <editor> In Toshiyasu Kunii, editor, </editor> <booktitle> Computer Graphics 1987, </booktitle> <pages> pages 303-314. </pages> <publisher> Springer-Verlag, </publisher> <address> Tokyo, Japan, </address> <year> 1987. </year>
Reference-contexts: New algorithms could be formulated by identifying the geometry characteristic that the approach is taking advantage of. For example, the ray coherence theorem <ref> [32] </ref> uses a direction and an acute angle as the geometry characteristic. In this case, the builder module finds out the list of candidate primitives that are visible from a direction/angle pair of a primitive.
Reference: [33] <author> Edward D. Palik. </author> <title> Handbook of Optical Constants of Solids. </title> <publisher> Academic Press, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: Example: light bulb. These basic materials can be extended, but they have proven to be fairly good approximations to common real world materials. Conductors are sometimes a little difficult because the parameters n and k are` not intuitively controllable. We have found most data for conductors in <ref> [33] </ref>. The behavior of both conductors and dielectrics is determined using the Fres-nel Equations, the full form of which can be found in [42, 38]. The polished surface is an approximation to a diffuse substrate with a thin dielectric covering.
Reference: [34] <author> Ken Perlin. </author> <title> An image synthesizer. </title> <journal> Computer Graphics, </journal> <volume> 19(3) </volume> <pages> 287-296, </pages> <month> July </month> <year> 1985. </year> <booktitle> ACM Siggraph '85 Conference Proceedings. </booktitle>
Reference-contexts: Another utility class is the (u; v) pair. This class is useful for pixel sampling and texture mapping. The texture class itself adds another useful utility. In this implementation, the texture abstract class takes both a point in 3D, and a (u; v) pair. Surface textures and solid textures <ref> [34] </ref> are both subclasses of the texture class. A solid texture will use the point for texture generation, and the surface texture will use the (u; v) coordinate for color lookup.
Reference: [35] <author> Ken Perlin and Eric M. Hoffert. </author> <title> Hypertexture. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 253-262, </pages> <month> July </month> <year> 1989. </year> <booktitle> ACM Sig-graph '89 Conference Proceedings. </booktitle>
Reference-contexts: This `send all information, needed or not' strategy can be inefficient, but it is a simple way to guarantee that the needed information is passed to a texture module. A very useful utility class is a solid noise generator. We have implemented the generator given in Perlin's 1989 paper <ref> [35] </ref>, and found it to be quite mechanical to implement.
Reference: [36] <author> Bertrand Le Saec and Christophe Schlick. </author> <title> A progressive ray-tracing-based radiosity with general reflectance functions. </title> <booktitle> In Proceedings of the Eurographics Workshop on Photosimulation, Realism and Physics in Computer Graphics, </booktitle> <pages> pages 103-116, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions <ref> [7, 40, 18, 39, 36] </ref>. These solutions are easy to construct if we view the zone as a black box which collects power carrying rays, and later emits a group of power carrying rays that represent reflected power accumulated since the previous emission step. <p> The radiance of the zone will just be =(A), where A is the area of the zone. For a zone with directionally dependent reflection behavior, such as brushed steel, we must maintain the total and unsent power as some kind of directional table <ref> [18, 39, 36] </ref>. A simple way to do this is a simple spherical coordinate array of bins, with the total power going through each bin. The unsent and total power of the diffuse case must be generaized to a new black box, the angular distribution function (adf).
Reference: [37] <author> Y. A. Screider. </author> <title> The Monte Carlo Method. </title> <publisher> Pergamon Press, </publisher> <address> New York, N.Y., </address> <year> 1966. </year>
Reference-contexts: Note that the non-uniform weighting function reduces aliasing. The uniform sampling transformation can also apply to non separable density functions, and to functions defined on non-Cartesian manifolds. This requires dealing with the joint distribution function and non-constant metrics, but otherwise the same techniques apply. Details can be found in <ref> [37, 38] </ref>. We have found several other transformations to be useful. For example, to choose points uniformly from a disk of radius R, apply the transformation = 2u, r = R p v.
Reference: [38] <author> Peter Shirley. </author> <title> Physically Based Lighting Calculations for Computer Graphics. </title> <type> PhD thesis, </type> <institution> University of Illi-nois at Urbana-Champaign, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: In our experience, two-dimensional jittering usually is more accurate than poisson disk sampling, regardless of the disk radius. These test results, and some analysis on why this might be true can be found in <ref> [38, 41] </ref>. 2.2.2 Sample Distribution Transformations Suppose we want to apply weighted area averaging to a pixel rather than simple area averaging [14]. We could simply apply weights to each sample point based on its (u; v) coordinate. <p> Note that the non-uniform weighting function reduces aliasing. The uniform sampling transformation can also apply to non separable density functions, and to functions defined on non-Cartesian manifolds. This requires dealing with the joint distribution function and non-constant metrics, but otherwise the same techniques apply. Details can be found in <ref> [37, 38] </ref>. We have found several other transformations to be useful. For example, to choose points uniformly from a disk of radius R, apply the transformation = 2u, r = R p v. <p> Conductors are sometimes a little difficult because the parameters n and k are` not intuitively controllable. We have found most data for conductors in [33]. The behavior of both conductors and dielectrics is determined using the Fres-nel Equations, the full form of which can be found in <ref> [42, 38] </ref>. The polished surface is an approximation to a diffuse substrate with a thin dielectric covering.
Reference: [39] <author> Peter Shirley. </author> <title> Physically based lighting calculations for computer graphics: A modern perspective. </title> <booktitle> In Proceedings of the Eurographics Workshop on Photosimulation, Realism and Physics in Computer Graphics, </booktitle> <pages> pages 67-81, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions <ref> [7, 40, 18, 39, 36] </ref>. These solutions are easy to construct if we view the zone as a black box which collects power carrying rays, and later emits a group of power carrying rays that represent reflected power accumulated since the previous emission step. <p> The radiance of the zone will just be =(A), where A is the area of the zone. For a zone with directionally dependent reflection behavior, such as brushed steel, we must maintain the total and unsent power as some kind of directional table <ref> [18, 39, 36] </ref>. A simple way to do this is a simple spherical coordinate array of bins, with the total power going through each bin. The unsent and total power of the diffuse case must be generaized to a new black box, the angular distribution function (adf).
Reference: [40] <author> Peter Shirley. </author> <title> A ray tracing algorithm for global illumination. </title> <booktitle> Graphics Interface '90, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. <p> The theoretical basis for such systems is straightforward to extract. If the progressive refinement is viewed as power transport simulation, which implies fairly direct non-diffuse zonal solutions <ref> [7, 40, 18, 39, 36] </ref>. These solutions are easy to construct if we view the zone as a black box which collects power carrying rays, and later emits a group of power carrying rays that represent reflected power accumulated since the previous emission step.
Reference: [41] <author> Peter Shirley. </author> <title> Discrepancy: A goodness measure for sampling distributions. </title> <note> In Submitted to Eurographics '91, </note> <year> 1991. </year>
Reference-contexts: In our experience, two-dimensional jittering usually is more accurate than poisson disk sampling, regardless of the disk radius. These test results, and some analysis on why this might be true can be found in <ref> [38, 41] </ref>. 2.2.2 Sample Distribution Transformations Suppose we want to apply weighted area averaging to a pixel rather than simple area averaging [14]. We could simply apply weights to each sample point based on its (u; v) coordinate.
Reference: [42] <author> Robert Siegel and John R. Howell. </author> <title> Thermal Radiation Heat Transfer. </title> <publisher> McGraw-Hill, </publisher> <address> New York, N.Y., </address> <year> 1981. </year>
Reference-contexts: Conductors are sometimes a little difficult because the parameters n and k are` not intuitively controllable. We have found most data for conductors in [33]. The behavior of both conductors and dielectrics is determined using the Fres-nel Equations, the full form of which can be found in <ref> [42, 38] </ref>. The polished surface is an approximation to a diffuse substrate with a thin dielectric covering.
Reference: [43] <author> Kelvin Sung. </author> <note> Dda traversal of octree structures. In Submitted to Eurographics '91, </note> <year> 1991. </year>
Reference-contexts: The traverser module knows how to traverse an octree, but does not need to know the detail implementation of the octree structure. Some of the examples of octree traversers are: linear octree walking 3 , Glassner's algorithm [16], and DDA octree traverser <ref> [43] </ref>. 2.3.3 Implementation Notes Following the design approach described in this section, it is possible to replace a module in this component with the rest of the system remaining unchanged. As a result, we are able to isolate and observe the effect of different algorithms. <p> However, Sung observed that in a zonal renderer, tree walking may be slower than that of the Glassner's original algorithm <ref> [43] </ref>. We note that the only difference between the two algorithms is in the process of getting the next octant: tree walking reconizes the tree location coherence and start searching from the parent of the current octant, while the Glassner's algorithm always start searching from the root of the octree. <p> Also, since there are a larger amount of primitives (e.g. a cylinder primitive is turned into many small primitive patches), the overhead involved in performing the pre-intersection checking and post-intersection information recording for every primitive becomes greater. Sung observed <ref> [43] </ref> that implementing mailbox in a zonal renderer does not achieve significant speed up (less than 5%). This analysis may not apply if the decomposition into zones is simply done in the objects parametric space with no geometric changes being made.
Reference: [44] <author> Steve Upstill. </author> <title> The Renderman Companion. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Kirk and Arvo also described a shader component, which encapsulates the local illumination model as a basic compo 1 nent. A similar shader concept has been advanced by various researchers <ref> [44, 21] </ref>. In this section, we describe the basic components of our ray tracing framework. In Section 2.1 we present several simple classes that are useful in graphics programs. The components which manage sample distributions on the pixel are discussed in Section 2.2. <p> In summary, the benifits of the mailbox technique may be highly dependent on the general geometric character of the geometric primatives used. 2.4 Ray-Material Interaction Several researchers have noted that reflection behavior should be encapsulated as one unit of a rendering system <ref> [28, 44, 21] </ref>. We treat light-material interaction as a component, where the reflection behavior is determined strictly from a set of material parameters. Traditionally this might be accomplished with one shading model with parameters including ks, kt, and kd [19]. <p> If the `material' were to handle all shading in this situation, it would need access to steel, marble, and dust reflectance behavior, as well as the procedural texture describing the dust. This could be accomplished in a manner similar to a Renderman shader <ref> [44, 21] </ref>, where the shading routine has access to the internals of reflection models and textures. Unfortunately, such a shader does not hide much information, and can become quite unwieldy.
Reference: [45] <author> John R. Wallace, Kells A. Elmquist, and Eric A. Haines. </author> <title> A ray tracing algorithm for progressive radiosity. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 335-344, </pages> <month> July </month> <year> 1989. </year> <booktitle> ACM Sig-graph '89 Conference Proceedings. </booktitle>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination.
Reference: [46] <author> Gregory J. Ward, Francis M. Rubinstein, and Robert D. </author> <title> Clear. A ray tracing solution for diffuse interreflection. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 85-92, </pages> <month> August </month> <year> 1988. </year> <booktitle> ACM Siggraph '88 Conference Proceedings. </booktitle>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination. <p> The other is to generate points on the square and then apply a warping function so that their distribution is changed. An example of this method is the transformation used by Ward et al. to generate a cosine distribution of sample points on a hemisphere <ref> [46] </ref>. The first abstraction is to make the sampling distribution come from an abstract class. This lets the user flexibly choose and add sampling methods and filter functions in a natural way. In this section we discuss two basic modules useful for sample point generation.
Reference: [47] <author> Turner Whitted. </author> <title> An improved illumination model for shaded display. </title> <journal> Communications of the ACM, </journal> <volume> 23(6) </volume> <pages> 343-349, </pages> <month> June </month> <year> 1980. </year> <month> 12 </month>
Reference-contexts: 1 Introduction In recent years many researchers have investigated ray tracing solutions to the global illumination problem <ref> [47, 13, 12, 26, 46, 45, 1, 40, 23] </ref>. Other authors have applied object-oriented design to ray tracing programs [28, 22]. In this paper, we discuss the major components 1 of an object oriented ray tracing system for global illumination.
References-found: 47

