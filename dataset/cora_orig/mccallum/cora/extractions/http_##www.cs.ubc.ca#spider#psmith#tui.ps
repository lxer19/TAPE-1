URL: http://www.cs.ubc.ca/spider/psmith/tui.ps
Refering-URL: http://www.cs.umd.edu/~keleher/818.html
Root-URL: 
Email: email: fpsmith,normg@cs.ubc.ca  
Title: Heterogeneous Process Migration The Tui System  
Author: Peter Smith and Norman C. Hutchinson, 
Date: February 28, 1996  
Address: Vancouver, B.C., V6T 1Z4, Canada  
Affiliation: Department of Computer Science University of British Columbia  
Abstract: Heterogeneous Process Migration is a technique whereby an active process is moved from one machine to another. It must then continue normal execution and communication. The source and destination processors can have a different architecture, that is, different instruction sets and data formats. Because of this heterogeneity, the entire process memory image must be translated during the migration. Tui is a prototype migration system that is able to translate the memory image of a program (written in ANSI-C) between four common architectures (m68000, SPARC, i486 and PowerPC). This requires detailed knowledge of all data types and variables used with the program. This is not always possible in non type-safe (but popular) languages such as C, Pascal and Fortran. The important features of the Tui algorithm are discussed in great detail. This includes the method by which a program's entire set of data values can be located, and eventually reconstructed on the target processor. Initial performance figures demonstrating the viability of using Tui for real migration applications are given.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> DWARF Debugging Information Format. </editor> <title> Industry Review Draft, </title> <booktitle> UNIX International, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Recently, work has progressed in the field of debugging optimized code [11] [19]. Whereas traditional debuggers have only been able to correctly debug unopti-mized programs, it has been recognized that many errors do not become obvious in this situation. The DWARF debugging format <ref> [1] </ref> is a newly developed format that is capable of expressing the structure of an optimized program. * Binary Translation Binary Translation is a technique that is used to convert machine code from one architecture to another.
Reference: [2] <institution> Information Technology Abstract Syntax Notation One (ASN.1) Specification of Basic Notation. International Organization for Standardization, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Several general packages are available to automate the data translation process. Given some form of data description, these systems will generate suitable functions for translating between a machine's native data format and some intermediate format. Two of the most common systems are Sun's XDR [24] and ISO's ASN.1 <ref> [2] </ref>. Tui does not take advantage of any standard system, since the packaging the whole data structure is handled as part of migrout, and the translation of single data values is trivial in the four machines support by Tui.
Reference: [3] <author> Bruno Achauer. </author> <title> The DOWL Distributed Object Oriented Language. </title> <journal> Communications of the ACM, </journal> <volume> 36(9):48, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: However, it has become more relevant to migrate on a per-object basis (or in groups of objects), rather than moving a whole program. Migration in this form is more commonly known as Mobility, that is, the object is mobile. Examples of such systems are: Emerald [5] [21] [28], DOWL <ref> [3] </ref>, DCE++ [29], and COOL [22]. As previously mentioned, Emerald is the only system that permits heterogeneous mobility of active code. * Debugging Source level debugging is one of the most closely related topics to heterogeneous process migration.
Reference: [4] <author> Yeshayahu Artsy and Ralph Finkel. </author> <title> Designing a Process Migration Facility: </title> <booktitle> The Charlotte Experience. COMPUTER, </booktitle> <month> September </month> <year> 1989. </year>
Reference-contexts: If this sharing relationship is not preserved, the subelement will be encoded twice, and there would be no way for the destination machine to restore the data structure to its original state. For example: - char buffer [10]; char *p = &buffer <ref> [4] </ref>; - In Tui, pointers are encoded as a pair of numbers (Object ID, offset), where the offset states how many indivisible subelements must be skipped in order to locate the correct value. <p> This section gives a list of such areas, showing their relationship to heterogeneous migration. * Traditional Migration Systems Process migration is not a new topic, and has been studied extensively since the late 1970s. Examples of process migration systems are V [9][37], Charlotte <ref> [4] </ref>, DEMOS/MP [27], Sprite [12], Condor [8] and Accent [40]. A good summary of these and other systems is given in [25]. 25 Much of the previous research has involved finding new and improved methods of transferring the state of the process from one machine to another.
Reference: [5] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transaction on Software Engineering, </journal> <month> January </month> <year> 1987. </year>
Reference-contexts: Each machine has its own method of storing a program's values. Differences are obvious in the layout of each stack frame, the usage of registers and the structure of the executable code. 3.2 Emerald The Emerald system <ref> [5] </ref> [21] [28] is an object oriented programming language and run-time system that supports movement of processes (active objects) between machines of different architectures (the category of active objects with native code). Emerald provides each object with a uniform view of the outside world, regardless of where is it located. <p> That is, if the base address of the newly discovered data item falls within the range of addresses already covered by an existing item. For example, - int *b = &a <ref> [5] </ref>; Since a is entered into the table first, *b will be consumed by a. * If the new data item consumes the successive data item, then the new item is entered into the table, and the old entry will be discarded. <p> However, it has become more relevant to migrate on a per-object basis (or in groups of objects), rather than moving a whole program. Migration in this form is more commonly known as Mobility, that is, the object is mobile. Examples of such systems are: Emerald <ref> [5] </ref> [21] [28], DOWL [3], DCE++ [29], and COOL [22]. As previously mentioned, Emerald is the only system that permits heterogeneous mobility of active code. * Debugging Source level debugging is one of the most closely related topics to heterogeneous process migration.
Reference: [6] <author> Hans J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly Parallel Garbage Collection. </title> <journal> ACM SIGPLAN Notices, </journal> <month> June </month> <year> 1991. </year>
Reference-contexts: A good overview of traditional garbage collection techniques is given in [10], and some of the more recent issues are discussed in [17]. See <ref> [6] </ref> and [38] for some further examples. Most existing garbage collection algorithms are not accurate enough to correctly migrate a program. In many cases, it is assumed that all data items are distinct (as in object oriented programming), and that marking the data is somehow possible.
Reference: [7] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage Collection in an Uncooperative Environment. </title> <journal> Software Practice and Experience, </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: Also, it is necessary for pointers to be clearly identified in some manner (such as tagging), so they are not confused with other data values. One system <ref> [7] </ref> allows garbage collection to function within C programs, but without proper type information, an educated guess must be made to identify pointers. Any pointer sized data value in a register or on the stack is considered to potentially be a pointer.
Reference: [8] <author> Allan Bricker, Michael Litzkow, and Miron Livny. </author> <title> Condor Technical Summary. </title> <type> Technical report, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: This section gives a list of such areas, showing their relationship to heterogeneous migration. * Traditional Migration Systems Process migration is not a new topic, and has been studied extensively since the late 1970s. Examples of process migration systems are V [9][37], Charlotte [4], DEMOS/MP [27], Sprite [12], Condor <ref> [8] </ref> and Accent [40]. A good summary of these and other systems is given in [25]. 25 Much of the previous research has involved finding new and improved methods of transferring the state of the process from one machine to another. <p> This implies that heterogeneity is not an issue. However, if we wish to restart it on a different machine, with a different architecture, then the problem is identical to that of heterogeneous process migration. Several checkpointing systems have been created for Unix systems <ref> [8] </ref> [26], but they only function in a homogeneous environment. 8 Summary The Tui Heterogeneous Process Migration system is able to move a process between machines of different architecture. It uses type information that is generated when the migratible program is compiled.
Reference: [9] <author> David R. Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 31(3), </volume> <year> 1988. </year>
Reference: [10] <author> Jacques Cohen. </author> <title> Garbage Collection of Linked Data Structures. </title> <journal> ACM Computer Surveys, </journal> <month> September </month> <year> 1981. </year>
Reference-contexts: If this sharing relationship is not preserved, the subelement will be encoded twice, and there would be no way for the destination machine to restore the data structure to its original state. For example: - char buffer <ref> [10] </ref>; char *p = &buffer [4]; - In Tui, pointers are encoded as a pair of numbers (Object ID, offset), where the offset states how many indivisible subelements must be skipped in order to locate the correct value. <p> In the above example, the Object ID would be whichever unique number was associated with the buffer array, and offset would be 4. We must also consider the case of composite data items, that contain other composite data. For example, - struct - int a; - c <ref> [10] </ref>; - In this case, the offset for p would be 5, since the structure contains two subele-ments, and p refers to the second element of the third instance of that struct within the array c. 15 4.4 Migrin : Reconstructing the Process To restart a process on the destination machine, <p> A good overview of traditional garbage collection techniques is given in <ref> [10] </ref>, and some of the more recent issues are discussed in [17]. See [6] and [38] for some further examples. Most existing garbage collection algorithms are not accurate enough to correctly migrate a program.
Reference: [11] <author> Max Copperman. </author> <title> Debugging optimized code without being misled. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> page 387, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Also, if generic pointers (such as void * in C) are used, the debugger will not be able to dereference the pointer unless the user performs explicit type casting. Recently, work has progressed in the field of debugging optimized code <ref> [11] </ref> [19]. Whereas traditional debuggers have only been able to correctly debug unopti-mized programs, it has been recognized that many errors do not become obvious in this situation.
Reference: [12] <author> Fred Douglis. </author> <title> Transparent Process Migration : Design Alternatives and the Sprite Implementation. </title> <journal> Software Practice and Experience, </journal> <month> August </month> <year> 1991. </year> <month> 29 </month>
Reference-contexts: This section gives a list of such areas, showing their relationship to heterogeneous migration. * Traditional Migration Systems Process migration is not a new topic, and has been studied extensively since the late 1970s. Examples of process migration systems are V [9][37], Charlotte [4], DEMOS/MP [27], Sprite <ref> [12] </ref>, Condor [8] and Accent [40]. A good summary of these and other systems is given in [25]. 25 Much of the previous research has involved finding new and improved methods of transferring the state of the process from one machine to another.
Reference: [13] <author> Fred Douglis and Brian Marsh. </author> <title> The Workstation as a Waystation : Integrating Mobility into Computing Environments. </title> <booktitle> The Third Workshop on Workstation Operating Systems (IEEE), </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: To make full use of these systems, the user needs to be able to communicate with larger machines without being physically connected to them, normally done via wireless LANs or cellular telephones. 3 It has been proposed <ref> [13] </ref> that process migration is important in this area. For exam-ple, a user may activate a program on their laptop, but in order to save battery power or to speed up processing, may later choose to transfer the running process onto a larger compute server.
Reference: [14] <author> D.L. Eager, E.D. Lazowska, and J. Zahorjan. </author> <title> The limited performance benefits of migrating active processes for load sharing. </title> <booktitle> Proceedings of the 1988 ACM SIGMETRICS Conference on Measurement and Modelling of Computer Systems, </booktitle> <pages> pages 63-72, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Migration allows a process to take advantage of un-derutilized resources in the system, by moving it to a suitable machine. It has been shown that load sharing is not always beneficial <ref> [14] </ref>. Since most processes only require a small amount of CPU time, with respect to the cost of migrating the process, there is no advantage to using migration over simply executing a job locally or carefully choosing its initial machine.
Reference: [15] <author> Chris Fraser and David Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1995. </year>
Reference-contexts: Three different compilers were considered. The gcc compiler [33] was the obvious choice as it can generate code for most common architectures. However, modifying the compiler and its related tools was considered too difficult due to the complexity of the source code. The lcc compiler <ref> [15] </ref> was considered, due to its wide range of target architectures and its ease of modification. However, it became obvious that important changes had to be made to the assembler and linker, which were not supplied as part of the package.
Reference: [16] <author> Benjamin Goldberg. </author> <title> Tag Free Garbage Collection for Strongly Typed Programming Languages. </title> <journal> ACM SIGPLAN Notices, </journal> <month> June </month> <year> 1991. </year>
Reference-contexts: The limitation of this system is that we can never be totally sure of whether a data item is a pointer, or simply an integer. Although an incorrect guess is not fatal for a garbage collection system, it will not suffice for a migrator. In a second system <ref> [16] </ref>, the compiler is extended so that an extra garbage collector function is automatically generated for each standard function in the program. When garbage collection takes place, the entire stack is traversed on a frame by frame basis, with the appropriate function being called for each.
Reference: [17] <author> Xiaomei Han. </author> <title> Memory Reclamation in Emerald An Object Oriented Programming Language. </title> <type> Master's thesis, </type> <institution> University of British Columbia, </institution> <year> 1994. </year>
Reference-contexts: A good overview of traditional garbage collection techniques is given in [10], and some of the more recent issues are discussed in <ref> [17] </ref>. See [6] and [38] for some further examples. Most existing garbage collection algorithms are not accurate enough to correctly migrate a program. In many cases, it is assumed that all data items are distinct (as in object oriented programming), and that marking the data is somehow possible.
Reference: [18] <author> H. Herlihy and B. Liskov. </author> <title> A Value Transmission Method for Abstract Data Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> October </month> <year> 1982. </year>
Reference-contexts: Tui does not take advantage of any standard system, since the packaging the whole data structure is handled as part of migrout, and the translation of single data values is trivial in the four machines support by Tui. One solution <ref> [18] </ref> has addressed the issue of transmitting cyclic data structures within the CLU programming environment (XDR and ASN.1 cannot correctly deal with cycles).
Reference: [19] <author> Urs Holzle, Craig Chambers, and David Ungar. </author> <title> Debugging Optimized Code with Dynamic Deoptimization. </title> <booktitle> ACM SIGPLAN 1993 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Also, if generic pointers (such as void * in C) are used, the debugger will not be able to dereference the pointer unless the user performs explicit type casting. Recently, work has progressed in the field of debugging optimized code [11] <ref> [19] </ref>. Whereas traditional debuggers have only been able to correctly debug unopti-mized programs, it has been recognized that many errors do not become obvious in this situation.
Reference: [20] <author> Wilso C. Hsieh, Paul Wang, and William E. Weihl. </author> <title> Computation Migration: Enhancing Locality for Distributed Memory Parallel Systems. </title> <journal> SIGPLAN Notices, </journal> <pages> page 239, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: If a program makes frequent use of remote data, its performance will suffer. Process migration can help alleviate this problem by moving the program closer to the data, rather than moving the data to the program <ref> [20] </ref>. Typically, a program would start executing on the user's local machine. If it later makes frequent accesses to remote data, the migration system will reduce the delay by moving the process to a machine that is physically closer to the data.
Reference: [21] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> February </month> <year> 1988. </year>
Reference-contexts: Section 5 shows the results of some performance tests. Finally, section 6 lists some proposed improvements to the current prototype implementation, and section 7 discusses some related work. 2 Motivations The traditional reasons for using process migration have been identified <ref> [21] </ref> as : * Load Sharing among a pool of processors For a process to obtain as much CPU time as possible, it must be executed on the processor that will provide the most instructions and I/O operations in the smallest amount of time. <p> Each machine has its own method of storing a program's values. Differences are obvious in the layout of each stack frame, the usage of registers and the structure of the executable code. 3.2 Emerald The Emerald system [5] <ref> [21] </ref> [28] is an object oriented programming language and run-time system that supports movement of processes (active objects) between machines of different architectures (the category of active objects with native code). Emerald provides each object with a uniform view of the outside world, regardless of where is it located. <p> However, it has become more relevant to migrate on a per-object basis (or in groups of objects), rather than moving a whole program. Migration in this form is more commonly known as Mobility, that is, the object is mobile. Examples of such systems are: Emerald [5] <ref> [21] </ref> [28], DOWL [3], DCE++ [29], and COOL [22]. As previously mentioned, Emerald is the only system that permits heterogeneous mobility of active code. * Debugging Source level debugging is one of the most closely related topics to heterogeneous process migration.
Reference: [22] <author> Rodger Lea, Christian Jacquemot, and Eric Pillevesse. </author> <title> COOL : System Support for Distributed Programming. </title> <journal> Communications of the ACM, </journal> <volume> 36(9):37, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: Migration in this form is more commonly known as Mobility, that is, the object is mobile. Examples of such systems are: Emerald [5] [21] [28], DOWL [3], DCE++ [29], and COOL <ref> [22] </ref>. As previously mentioned, Emerald is the only system that permits heterogeneous mobility of active code. * Debugging Source level debugging is one of the most closely related topics to heterogeneous process migration.
Reference: [23] <author> Julia Menapace, Jim Kingdon, and David MacKenzie. </author> <title> The stabs debug format. </title> <type> Technical report, </type> <institution> Cygnus support. </institution>
Reference-contexts: The majority of optimizations are performed on intermediate code, with the backends being primarily responsible for performing target instruction selection, as well as a small amount of peephole optimization. The optimization problems of code motion [34] are not relevant here. ACK front ends generate stabs format <ref> [23] </ref> debugging information. These describe the type and location of all data values, using a compact ASCII encoding. Also, the mapping between source code line numbers and target machine addresses is recorded.
Reference: [24] <author> Sun Microsystems. </author> <title> Open Network Computer : RPC Programming. The official documentation for Sun RPC and XDR. </title>
Reference-contexts: Several general packages are available to automate the data translation process. Given some form of data description, these systems will generate suitable functions for translating between a machine's native data format and some intermediate format. Two of the most common systems are Sun's XDR <ref> [24] </ref> and ISO's ASN.1 [2]. Tui does not take advantage of any standard system, since the packaging the whole data structure is handled as part of migrout, and the translation of single data values is trivial in the four machines support by Tui.
Reference: [25] <author> Mark Nuttall. </author> <title> A brief survey of systems providing process of object migration facilities. </title> <booktitle> Operating Systems Review, </booktitle> <pages> page 64, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Examples of process migration systems are V [9][37], Charlotte [4], DEMOS/MP [27], Sprite [12], Condor [8] and Accent [40]. A good summary of these and other systems is given in <ref> [25] </ref>. 25 Much of the previous research has involved finding new and improved methods of transferring the state of the process from one machine to another. In all of these systems, the process can only be migrated between homogeneous machines.
Reference: [26] <author> James S. Plank, Micah Beck, and Gerry Kingsley. Libckpt: </author> <title> Transparent Check-pointing under Unix. </title> <booktitle> In USENIX Technical Conference, </booktitle> <year> 1995. </year> <month> 30 </month>
Reference-contexts: This implies that heterogeneity is not an issue. However, if we wish to restart it on a different machine, with a different architecture, then the problem is identical to that of heterogeneous process migration. Several checkpointing systems have been created for Unix systems [8] <ref> [26] </ref>, but they only function in a homogeneous environment. 8 Summary The Tui Heterogeneous Process Migration system is able to move a process between machines of different architecture. It uses type information that is generated when the migratible program is compiled.
Reference: [27] <author> Michael L. Powell and Barton P. Miller. </author> <title> Process Migration in DEMOS/MP. </title> <booktitle> Pro--ceedings of the 9th Symposium on Operating System Principle, </booktitle> <month> October </month> <year> 1983. </year>
Reference-contexts: This section gives a list of such areas, showing their relationship to heterogeneous migration. * Traditional Migration Systems Process migration is not a new topic, and has been studied extensively since the late 1970s. Examples of process migration systems are V [9][37], Charlotte [4], DEMOS/MP <ref> [27] </ref>, Sprite [12], Condor [8] and Accent [40]. A good summary of these and other systems is given in [25]. 25 Much of the previous research has involved finding new and improved methods of transferring the state of the process from one machine to another.
Reference: [28] <author> Rajendra K. Raj, Ewan Tempero, Henry M. Levy, Andrew P. Black, Norman C. Hutchinson, and Eric Jul. </author> <title> Emerald : A general-purpose programming language. </title> <journal> Software Practice and Experience, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Each machine has its own method of storing a program's values. Differences are obvious in the layout of each stack frame, the usage of registers and the structure of the executable code. 3.2 Emerald The Emerald system [5] [21] <ref> [28] </ref> is an object oriented programming language and run-time system that supports movement of processes (active objects) between machines of different architectures (the category of active objects with native code). Emerald provides each object with a uniform view of the outside world, regardless of where is it located. <p> However, it has become more relevant to migrate on a per-object basis (or in groups of objects), rather than moving a whole program. Migration in this form is more commonly known as Mobility, that is, the object is mobile. Examples of such systems are: Emerald [5] [21] <ref> [28] </ref>, DOWL [3], DCE++ [29], and COOL [22]. As previously mentioned, Emerald is the only system that permits heterogeneous mobility of active code. * Debugging Source level debugging is one of the most closely related topics to heterogeneous process migration.
Reference: [29] <author> Alexander B. Schill and Markus U. Mock. </author> <title> DCE++ : Distributed Object-Oriented System Support on top of OSF DCE. </title> <type> Technical report, </type> <institution> Institute of Telematics. University of Karlsruhe, Germany. </institution>
Reference-contexts: Migration in this form is more commonly known as Mobility, that is, the object is mobile. Examples of such systems are: Emerald [5] [21] [28], DOWL [3], DCE++ <ref> [29] </ref>, and COOL [22]. As previously mentioned, Emerald is the only system that permits heterogeneous mobility of active code. * Debugging Source level debugging is one of the most closely related topics to heterogeneous process migration.
Reference: [30] <author> Gabriel M. Silberman and Kemal Ebcioglu. </author> <title> An Architectural Framework for Supporting Heterogeneous Instuction-Set Architectures. </title> <booktitle> IEEE Computer, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: For example, one of its main uses was in the introduction of DEC's Alpha processor [31]. There was a desire to convert existing VAX software to the Alpha platform, without using the original source code. Another system <ref> [30] </ref> talks about emulating complex instruction set machines by using binary translation within a RISC environment. In the context of heterogeneous process migration, binary translation could be used to migrate the executable program code to a different architecture.
Reference: [31] <author> Richard L. Sites, Anton Chernoff, Matthew B. Kirk, Maurice P. Marks, and Scott G. Robinson. </author> <title> Binary Translation. </title> <journal> Communications of the ACM, </journal> <month> February </month> <year> 1993. </year>
Reference-contexts: For example, one of its main uses was in the introduction of DEC's Alpha processor <ref> [31] </ref>. There was a desire to convert existing VAX software to the Alpha platform, without using the original source code. Another system [30] talks about emulating complex instruction set machines by using binary translation within a RISC environment.
Reference: [32] <author> Daniel Dominic Sleator and Robert Endre Tarjan. </author> <title> Self-Adusting Binary Search Trees. </title> <journal> Journal of the ACM, </journal> <volume> 32(3), </volume> <month> July </month> <year> 1985. </year>
Reference-contexts: Insertions and lookups can be random, since pointers may refer to any memory location. Also, we often wish to locate the adjacent entries, as well as to make an inorder traversal of the entire table. A splay tree <ref> [32] </ref> has been used for this purpose. When a new data value is discovered, it is important to consider any data that already exists at the same memory address, and any data that precedes or follows this new value. The following list of cases has been noted.
Reference: [33] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. </title> <year> 1995. </year>
Reference-contexts: Secondly, the entire source code for the compiler, assembler and linker had to be available (for all architectures), so that modifications to their output could be made. Three different compilers were considered. The gcc compiler <ref> [33] </ref> was the obvious choice as it can generate code for most common architectures. However, modifying the compiler and its related tools was considered too difficult due to the complexity of the source code.
Reference: [34] <author> Bjarne Steensgaard and Eric Jul. </author> <title> Object and Native Code Process Mobility Among Heterogeneous Computers. </title> <booktitle> In Symposium on Operating System Principles, </booktitle> <year> 1995. </year>
Reference-contexts: The majority of optimizations are performed on intermediate code, with the backends being primarily responsible for performing target instruction selection, as well as a small amount of peephole optimization. The optimization problems of code motion <ref> [34] </ref> are not relevant here. ACK front ends generate stabs format [23] debugging information. These describe the type and location of all data values, using a compact ASCII encoding. Also, the mapping between source code line numbers and target machine addresses is recorded.
Reference: [35] <author> Andrew S. Tanenbaum, Hans van Staveren, Ed G. Keizer, and Johan W. Steven-son. </author> <title> Description of a Machine Architecture for use with Block Structure Languages. </title> <type> Technical report, </type> <institution> Vrije Universiteit Amsterdam, </institution> <year> 1983. </year>
Reference-contexts: The storage location and size of these entities may differ widely between machines, for example, local variables may be stored on the stack, or in registers. Since ACK frontends generate intermediate code <ref> [35] </ref>, the differences between the various executable files is minimal. The majority of optimizations are performed on intermediate code, with the backends being primarily responsible for performing target instruction selection, as well as a small amount of peephole optimization. The optimization problems of code motion [34] are not relevant here.
Reference: [36] <author> A.S. Tanenbaum, H. van Staveren, E.G. Keizer, and J.W. Stevenson. </author> <title> A UNIX Toolkit for Making Portable Compilers. </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1983. </year>
Reference-contexts: A program (written in ANSI-C) is compiled, once for each architecture. A modified version of the Amsterdam Compiler Kit (ACK) <ref> [36] </ref> is able to produce bi naries for each of the four machine types supported by Tui. 2. The program is executed on the source machine, in the standard way (such as from the command line). 3.
Reference: [37] <author> Marvin M. Theimer, Keith A. Lantz, and David R. Cheriton. </author> <title> Preemptable Remote Execution Facilities for the V-System. </title> <booktitle> In Proceedings of the Tenth Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1985. </year>
Reference: [38] <author> Ian Toyn and Alan J. Dix. </author> <title> Efficient Binary Transfer of Pointer Structures. </title> <journal> Software Practice and Experience, </journal> <month> November </month> <year> 1994. </year>
Reference-contexts: A good overview of traditional garbage collection techniques is given in [10], and some of the more recent issues are discussed in [17]. See [6] and <ref> [38] </ref> for some further examples. Most existing garbage collection algorithms are not accurate enough to correctly migrate a program. In many cases, it is assumed that all data items are distinct (as in object oriented programming), and that marking the data is somehow possible.
Reference: [39] <author> D. B. Wortman, S. Zhou, and S. Fink. </author> <title> Automating Data Conversion for Heterogeneous Distributed Shared Memory. </title> <journal> Software Practice and Experience, </journal> <pages> page 111, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: These functions perform collection by following any pointers that are present in that frame. As with the Emerald migration system, this algorithm will only function correctly in a strongly typed environment. 27 * Heterogeneous Distributed Shared Memory The Mermaid system <ref> [39] </ref> [41] allows distributed shared memory (DSM) to function between heterogeneous machines. That is, a group of processes residing on different machines are able to share a consistent view of a segment of memory.
Reference: [40] <author> Edward R. Zayas. </author> <title> Attacking the Process Migration Bottleneck. </title> <booktitle> In Symposium on Operating System Principles, </booktitle> <pages> pages 13-22, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year> <month> 31 </month>
Reference-contexts: Examples of process migration systems are V [9][37], Charlotte [4], DEMOS/MP [27], Sprite [12], Condor [8] and Accent <ref> [40] </ref>. A good summary of these and other systems is given in [25]. 25 Much of the previous research has involved finding new and improved methods of transferring the state of the process from one machine to another.
Reference: [41] <author> Songnian Zhou, Michael Stumm, Kai Li, and David Wortman. </author> <title> Heterogeneous Distributed Shared Memory. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <pages> page 540, </pages> <month> September </month> <year> 1992. </year> <month> 32 </month>
Reference-contexts: These functions perform collection by following any pointers that are present in that frame. As with the Emerald migration system, this algorithm will only function correctly in a strongly typed environment. 27 * Heterogeneous Distributed Shared Memory The Mermaid system [39] <ref> [41] </ref> allows distributed shared memory (DSM) to function between heterogeneous machines. That is, a group of processes residing on different machines are able to share a consistent view of a segment of memory.
References-found: 41

