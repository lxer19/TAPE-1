URL: http://www.cs.man.ac.uk/~banach/some.pubs/Pi.CCS.ext.abs.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~banach/Recent.publications.html
Root-URL: http://www.cs.man.ac.uk
Email: banach@cs.man.ac.uk  franck@cs.mcgill.ca  
Title: Mobility and Modularity: expressing -calculus in CCS (extended abstract)  
Author: Richard Banach Franck van Breugel 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  3480 University Street, Montreal, Canada H3A 2A7  
Affiliation: University of Manchester, Department of Computer Science  McGill University, School of Computer Science  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [ACS96] <author> R.M. Amadio, I. Castellani, and D. Sangiorgi. </author> <title> On Bisimulation for the Asynchronous -Calculus. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> Proceedings of CONCUR'96, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-162, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Q a Q a We have omitted the symmetric versions of the rules 6, 7, 8, and 9. The only differences from the axioms and rules given in [San92] are that rule 1 is a little more general (like in, e.g., <ref> [ACS96] </ref>), the rules 4, 5, and 9 have been changed to deal with sets of names, and rule 10 has been added to handle countably infinite compositions The rule for replication is P j !P ! P 0 a 3 Since we will focus on reduction bisimilarity (see Definition 1.4), the
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus, its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Let us briefly discuss the basic ideas of our encoding. It is based on Milner's encoding of value passing CCS into pure CCS [Mil89]. To overcome some complications caused by -calculus' alpha-conversion, we focus on clash-free -processes. Clash-freeness is a minor variation on Barendregt's variable convention for the -calculus <ref> [Bar84] </ref>. In the encoding, we exploit the fact that all restrictions in a clash-free -process can be pulled out|the phenomenon is also known as scope extrusion|preserving reduction bisimilarity. <p> Clash-freeness is a minor variation on Barendregt's variable convention for the -calculus <ref> [Bar84, page 26] </ref> and coincides with the non-homonymy condition of [FMQ96, page 57]. This notion will turn out to be essential in Proposition 3.3 and Lemma 4.2.
Reference: [BDP96] <author> C. Bodei, P. Degano, and C. Priami. </author> <title> Handling Locally Names of Mobile Agents. </title> <type> Draft, </type> <institution> University of Pisa, Pisa, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: of names X satisfying n (P ) " X = ; there exists a -process Q such that P + Q and bn (Q) X by induction on the proof of P + Q. 2 An alternative approach to distinguish free and bound names in the -calculus is presented in <ref> [BDP96] </ref>. Because we can construct for every -process a clash-free alpha-variant in a compositional way (proof of Lemma 2.2) and alpha-convertibility is a reduction bisimulation (Proposition 1.5), we will restrict our attention in the sequel to clash-free -processes.
Reference: [Bor96] <author> M. Boreale. </author> <title> On the Expressiveness of Internal Mobility in Name-Passing Calculi. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> Proceedings of CONCUR'96, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 163-178, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: (P 0 ) n N 2 ccs E (Q 0 ) n N 2 [Lemma 3.5] () E 0 (P ) ccs E 0 (Q): [Lemma 5.2] 2 Conclusion Ever since its introduction, the expressiveness of the -calculus and related calculi has attracted a considerable amount of attention (see, e.g., <ref> [Bou92, Bor96, HT91, NP96, San93] </ref>). Here, we have shown that the -calculus can be encoded in CCS is a compositional way. From this result we should not conclude that we 10 can therefore focus on CCS. In contrast to CCS, the -calculus is a calculus with mobility.
Reference: [Bou92] <author> G. Boudol. </author> <title> Asynchrony and the -Calculus (note). </title> <type> Report RR-1702, </type> <institution> INRIA, Sophia Antipolis, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: (P 0 ) n N 2 ccs E (Q 0 ) n N 2 [Lemma 3.5] () E 0 (P ) ccs E 0 (Q): [Lemma 5.2] 2 Conclusion Ever since its introduction, the expressiveness of the -calculus and related calculi has attracted a considerable amount of attention (see, e.g., <ref> [Bou92, Bor96, HT91, NP96, San93] </ref>). Here, we have shown that the -calculus can be encoded in CCS is a compositional way. From this result we should not conclude that we 10 can therefore focus on CCS. In contrast to CCS, the -calculus is a calculus with mobility.
Reference: [BS96] <author> M. Boreale and D. Sangiorgi. </author> <title> Some Congruence Properties for -Calculus Bisimilarities. </title> <type> Report RR-2870, </type> <institution> INRIA, Sophia Antipolis, </institution> <year> 1996. </year>
Reference-contexts: Bisimilarity [Mil80, Par81] is the most commonly used semantic equivalence on CCS-processes. For -processes, a large variety of different notions of bisimilarity have been introduced (see, e.g., <ref> [BS96] </ref>). Reduction bisimilarity focuses on the key feature of concurrency: interaction. Although this semantic equivalence is rather weak|in general, reduction bisimilarity is not preserved by composition|it allows us to give a compositional encoding.
Reference: [CSW97] <author> G.L. Cattani, I. Stark, and G. Winskel. </author> <title> Presheaf Models for the Pi-Calculus. </title> <booktitle> In Proceedings of the 7th International Conference on Category Theory and Computer Science, volume 1290 of Lecture Notes in Computer Science, </booktitle> <pages> pages 106-126, </pages> <address> Santa Margherita Ligure, </address> <month> September </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: The smaller the scope of a channel, the less pressure it puts on the registers. Note that the construction of normal forms does exactly the opposite. Whether our encoding of the -calculus into CCS has any impact on the existing denotational models for the -calculus, like e.g. <ref> [FMS96, Sta96, CSW97] </ref>, needs further study. These models are much more complex than the ones for CCS and the encoding might give us some insight how the models for the -calculus can be simplified.
Reference: [FMQ96] <author> G. Ferrari, U. Montanari, and P. Quaglia. </author> <title> A -Calculus with Explicit Substitutions. </title> <journal> Theoretical Computer Science, </journal> <volume> 168(1) </volume> <pages> 53-103, </pages> <month> November </month> <year> 1996. </year>
Reference-contexts: It shows that if we drop the `uniformity' and `reasonableness' conditions, then we can give a compositional encoding. Second, the study of clash-freeness. Several papers are rather vague on this point. As far as we are aware, the only other paper which considers this notions is <ref> [FMQ96] </ref>. Finally, the investigation of countably infinite restrictions and compositions in the -calculus. As far as we know, these infinite constructs have not been considered. Several algebraic laws for these constructs are exploited, extending laws of, e.g., [PS95] to our infinite setting. <p> Clash-freeness is a minor variation on Barendregt's variable convention for the -calculus [Bar84, page 26] and coincides with the non-homonymy condition of <ref> [FMQ96, page 57] </ref>. This notion will turn out to be essential in Proposition 3.3 and Lemma 4.2. A -process is clash-free if each binder in the process is named distinctly from any other binder in the process, and each binder also differs from any free name in the process. <p> This operation is exploited in the encoding of the input prefix as follows: E (x (y):P ) = z2N The use of [f z =yg] in our encoding is reminiscent to the explicit substitutions in the -calculus <ref> [FMQ96] </ref>. <p> Our study has shown that we can exploit this mobility without having to give up modularity. The work of Palamidessi [Pal97], which is closely related to ours, has already been discussed in detail. Another paper that addresses a related problem is <ref> [FMQ96] </ref>. Ferrari, Montanari and Quaglia present an alternative formulation of the -calculus in which substitution is handled explicitly via the introduction of a suitable operator.
Reference: [FMS96] <author> M. Fiore, E. Moggi, and D. Sangiorgi. </author> <title> A Fully Abstract Model for the -Calculus. </title> <booktitle> In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 43-54, </pages> <address> New Brunswick, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 11 </pages>
Reference-contexts: The smaller the scope of a channel, the less pressure it puts on the registers. Note that the construction of normal forms does exactly the opposite. Whether our encoding of the -calculus into CCS has any impact on the existing denotational models for the -calculus, like e.g. <ref> [FMS96, Sta96, CSW97] </ref>, needs further study. These models are much more complex than the ones for CCS and the encoding might give us some insight how the models for the -calculus can be simplified.
Reference: [HT91] <author> K. Honda and M. Tokoro. </author> <title> An Object Calculus for Asynchronous Communication. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 133-147, </pages> <address> Geneva, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: (P 0 ) n N 2 ccs E (Q 0 ) n N 2 [Lemma 3.5] () E 0 (P ) ccs E 0 (Q): [Lemma 5.2] 2 Conclusion Ever since its introduction, the expressiveness of the -calculus and related calculi has attracted a considerable amount of attention (see, e.g., <ref> [Bou92, Bor96, HT91, NP96, San93] </ref>). Here, we have shown that the -calculus can be encoded in CCS is a compositional way. From this result we should not conclude that we 10 can therefore focus on CCS. In contrast to CCS, the -calculus is a calculus with mobility.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: Bisimilarity <ref> [Mil80, Par81] </ref> is the most commonly used semantic equivalence on CCS-processes. For -processes, a large variety of different notions of bisimilarity have been introduced (see, e.g., [BS96]). Reduction bisimilarity focuses on the key feature of concurrency: interaction.
Reference: [Mil83] <author> R. Milner. </author> <title> Calculi for Synchrony and Asynchrony. </title> <journal> Theoretical Computer Science, </journal> <volume> 25(3) </volume> <pages> 267-310, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: What is more to the point is the extent to which semantic equivalences are preserved by an encoding and the encoding is compositional. According to Milner <ref> [Mil83, page 291] </ref>, the passing of communication links as values, which is one of the key features of the -calculus, cannot obviously be expressed in a general form in CCS. Sangiorgi [San96, page 235] even claimed that this phenomenon gives the -calculus a much greater expressiveness than CCS.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall International, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: We investigate whether the -calculus can be expressed in CCS. In a trivial sense, the -calculus and CCS have the same expressiveness, since they are Turing-equivalent (cf. <ref> [Mil89, Section 6.1] </ref>). However, Turing-equivalence fails to capture the relative power of concurrency mechanisms and is therefore of little interest in comparing the expressiveness of concurrent calculi. What is more to the point is the extent to which semantic equivalences are preserved by an encoding and the encoding is compositional. <p> To smooth the encoding of replication, we extend the -calculus with two infinite constructs: countably infinite restrictions and compositions. Let us briefly discuss the basic ideas of our encoding. It is based on Milner's encoding of value passing CCS into pure CCS <ref> [Mil89] </ref>. To overcome some complications caused by -calculus' alpha-conversion, we focus on clash-free -processes. Clash-freeness is a minor variation on Barendregt's variable convention for the -calculus [Bar84]. <p> In the rest of this paper we do the following. Section 1 describes the -calculus and reduction bisimilarity. For more details on the -calculus we refer the reader to Milner's tutorial [Mil91]. A good introduction to CCS is Milner's book <ref> [Mil89] </ref>. Section 2 introduces the clash-free fragment of the -calculus. Section 3 gives the encoding of the restriction-free part of the -calculus. Section 4 focuses on scope extrusion. Section 5 considers the incorporation of restriction in the encoding. <p> The -calculus has inaction, summation and composition and so does CCS, so it's clear how we might want to deal with those. To handle the output and input prefixes of the -calculus, we emulate the trick used for encoding value passing CCS into pure CCS <ref> [Mil89, Section 2.8] </ref>. We design the set of CCS channels as pairs hx; yi, with the first entry of the pair holding the -calculus name along which is communicated, and the second entry containing the -calculus name being transmitted. <p> Because different choices for the constants A [oe];1 , A [oe];2 , : : : are allowed, the above introduced encoding is not a function but a relation. Definition 3.2 CCS-processes are chi-variants if they only differ in the choice of constants. According to <ref> [Mil89, Proposition 4.12] </ref>, chi-variants are bisimilar. Different choices for the constants in the final clause of the encoding give rise to chi-variants, and hence to bisimilar CCS-processes. The encoding maps alpha-variants to chi-variants. <p> Proof Transition induction exploiting Proposition 3.3 and <ref> [Mil89, Proposition 4.10, 4.11, and 4.12] </ref>. 2 Reduction bisimilarity on restriction-free -processes and bisimilarity on their encodings are linked as follows. <p> Lemma 3.5 For all restriction-free -processes P and Q, P Q if and only if E (P ) n N 2 ccs E (Q) n N 2 : Proof From Proposition 3.4 and <ref> [Mil89, Proposition 4.10] </ref> we can deduce that f hE (P ) n N 2 ; E (Q) n N 2 i j P Q g is a bisimulation and that f hP; Qi j E (P ) n N 2 ccs E (Q) n N 2 g is a reduction bisimulation
Reference: [Mil91] <author> R. Milner. </author> <title> The Polyadic -Calculus: a tutorial. </title> <type> Report ECS-LFCS-91-180, </type> <institution> University of Edinburgh, Edinburgh, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Several algebraic laws for these constructs are exploited, extending laws of, e.g., [PS95] to our infinite setting. In the rest of this paper we do the following. Section 1 describes the -calculus and reduction bisimilarity. For more details on the -calculus we refer the reader to Milner's tutorial <ref> [Mil91] </ref>. A good introduction to CCS is Milner's book [Mil89]. Section 2 introduces the clash-free fragment of the -calculus. Section 3 gives the encoding of the restriction-free part of the -calculus. Section 4 focuses on scope extrusion. Section 5 considers the incorporation of restriction in the encoding.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A Calculus of Mobile Processes, I and II. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40 and 41-77, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: For example, CML and Facile are both built on top of Standard ML [MTHM97] and Pict is compiled into C. In this paper, we address the question whether this translation can be done in a modular (or compositional) way. For that purpose, we consider the calculus <ref> [MPW92] </ref>, a basic calculus with mobility as its key feature, and CCS, the -calculus' predecessor without mobility. We investigate whether the -calculus can be expressed in CCS. In a trivial sense, the -calculus and CCS have the same expressiveness, since they are Turing-equivalent (cf. [Mil89, Section 6.1]). <p> Furthermore, we can show that P is early congruent to nf (P ), again by structural induction on P , generalising various laws of [PS95] and <ref> [MPW92, Theorem 13] </ref>. The definition of early congruence is given in, e.g., [PS95, Definition 2.5]. The observation that early congruence is a reduction bisimulation concludes the proof. 2 Observe that we cannot pull a restriction out of a replication, i.e. !(X)P (X)!P does not hold in general. <p> Proof From rule 4 of Definition 1.3 we can conclude that restriction preserves o -transitions. We can also show that restriction reflects o -transitions up to alpha-conversion exploiting straightforward modifications of <ref> [MPW92, Lemma 1 and 3] </ref>.
Reference: [MPW93] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> Modal Logics for Mobile Processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 114(1) </volume> <pages> 149-171, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: and rule 10 has been added to handle countably infinite compositions The rule for replication is P j !P ! P 0 a 3 Since we will focus on reduction bisimilarity (see Definition 1.4), the early and late instantiation schemes give rise to the same o -transitions (straightforward modification of <ref> [MPW93, Lemma 2.5] </ref>), and some results are easier to prove for the early scheme, we have chosen the former. 4 Obviously, one can view !P as syntactic sugar for Q n2IN P . Note that a -process without countably infinite restrictions and compositions, possibly containing replications, is coinfinite.
Reference: [MS92] <author> R. Milner and D. Sangiorgi. </author> <title> Barbed Bisimulation. </title> <editor> In W. Kuich, editor, </editor> <booktitle> Proceedings of the 19th International Colloquium on Automata, Languages and Programming, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 685-695, </pages> <address> Vienna, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [MTHM97] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML Revised. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, </address> <year> 1997. </year>
Reference-contexts: This phenomenon will be discussed in more detail in the next paragraph. Most implementations of concurrent programming languages with mobility contain a phase in which a language with mobility is translated into a language without mobility. For example, CML and Facile are both built on top of Standard ML <ref> [MTHM97] </ref> and Pict is compiled into C. In this paper, we address the question whether this translation can be done in a modular (or compositional) way. For that purpose, we consider the calculus [MPW92], a basic calculus with mobility as its key feature, and CCS, the -calculus' predecessor without mobility.
Reference: [Nes97] <author> U. Nestmann. </author> <title> What is a `Good' Encoding of Guarded Choice? In C. </title> <editor> Palamidessi and J. Parrow, editors, </editor> <booktitle> Proceedings of EXPRESS'97, volume 7 of Electronic Notes in Theoretical Computer Science, </booktitle> <address> Santa Margherita Ligure, </address> <month> September </month> <year> 1997. </year> <pages> Elsevier. </pages>
Reference-contexts: Nestmann <ref> [Nes97] </ref> showed that either the `uniformity' of the encoding or the `reasonableness' of the semantics is necessary for Palamidessi's other 1 negative result. In this paper, we present a compositional, yet not `uniform', encoding of the -calculus into CCS. <p> Observe that our encoding preserves the amount of concurrency. The encoding E 0 can be expressed in terms of the encoding E as follows (cf. the two-level encoding in <ref> [Nes97, Section 4.1] </ref>). Lemma 5.2 If nf (P ) = (X)P 0 then E 0 (P ) = E (P 0 ) n N 2 .
Reference: [NP96] <author> U. Nestmann and B.C. Pierce. </author> <title> Decoding Choice Encodings. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> Proceedings of CONCUR'96, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 179-194, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: (P 0 ) n N 2 ccs E (Q 0 ) n N 2 [Lemma 3.5] () E 0 (P ) ccs E 0 (Q): [Lemma 5.2] 2 Conclusion Ever since its introduction, the expressiveness of the -calculus and related calculi has attracted a considerable amount of attention (see, e.g., <ref> [Bou92, Bor96, HT91, NP96, San93] </ref>). Here, we have shown that the -calculus can be encoded in CCS is a compositional way. From this result we should not conclude that we 10 can therefore focus on CCS. In contrast to CCS, the -calculus is a calculus with mobility.
Reference: [Pal97] <author> C. Palamidessi. </author> <title> Comparing the Expressive Power of the Synchronous and the Asynchronous -Calculus. </title> <booktitle> In Proceedings of the 24th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 256-265, </pages> <address> Paris, </address> <month> January </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: Sangiorgi [San96, page 235] even claimed that this phenomenon gives the -calculus a much greater expressiveness than CCS. This claim was supported by a proof of Palamidessi <ref> [Pal97] </ref> that there does not exist a compositional and `uniform' encoding of the -calculus into CCS preserving a `reasonable' fl Supported by the British Council, the Consiglio Nazionale delle Ricerche, and the Staff Exchange Scheme of the European Commission's ERASMUS programme. y Supported by the European Commission's HCM programme and NSERC <p> From this result we should not conclude that we 10 can therefore focus on CCS. In contrast to CCS, the -calculus is a calculus with mobility. Our study has shown that we can exploit this mobility without having to give up modularity. The work of Palamidessi <ref> [Pal97] </ref>, which is closely related to ours, has already been discussed in detail. Another paper that addresses a related problem is [FMQ96]. Ferrari, Montanari and Quaglia present an alternative formulation of the -calculus in which substitution is handled explicitly via the introduction of a suitable operator.
Reference: [Par81] <author> D. Park. </author> <title> Concurrency and Automata on Infinite Sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> Proceedings of 5th GI-Conference on Theoretical Compute Science, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-183, </pages> <address> Karlsruhe, March 1981. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Bisimilarity <ref> [Mil80, Par81] </ref> is the most commonly used semantic equivalence on CCS-processes. For -processes, a large variety of different notions of bisimilarity have been introduced (see, e.g., [BS96]). Reduction bisimilarity focuses on the key feature of concurrency: interaction.
Reference: [PS95] <author> J. Parrow and D. Sangiorgi. </author> <title> Algebraic Theories for Name-Passing Calculi. </title> <journal> Information and Computation, </journal> <volume> 120(2) </volume> <pages> 174-197, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Finally, the investigation of countably infinite restrictions and compositions in the -calculus. As far as we know, these infinite constructs have not been considered. Several algebraic laws for these constructs are exploited, extending laws of, e.g., <ref> [PS95] </ref> to our infinite setting. In the rest of this paper we do the following. Section 1 describes the -calculus and reduction bisimilarity. For more details on the -calculus we refer the reader to Milner's tutorial [Mil91]. A good introduction to CCS is Milner's book [Mil89]. <p> Furthermore, we can show that P is early congruent to nf (P ), again by structural induction on P , generalising various laws of <ref> [PS95] </ref> and [MPW92, Theorem 13]. The definition of early congruence is given in, e.g., [PS95, Definition 2.5]. The observation that early congruence is a reduction bisimulation concludes the proof. 2 Observe that we cannot pull a restriction out of a replication, i.e. !(X)P (X)!P does not hold in general. <p> Furthermore, we can show that P is early congruent to nf (P ), again by structural induction on P , generalising various laws of [PS95] and [MPW92, Theorem 13]. The definition of early congruence is given in, e.g., <ref> [PS95, Definition 2.5] </ref>. The observation that early congruence is a reduction bisimulation concludes the proof. 2 Observe that we cannot pull a restriction out of a replication, i.e. !(X)P (X)!P does not hold in general. This is the reason why we added countably infinite restrictions and compositions to the calculus.
Reference: [PT97] <author> B.C. Pierce and D.N. Turner. </author> <title> Pict: A Programming Language Based on the Pi-Calculus. </title> <type> Report CSCI 476, </type> <institution> Indiana University, Bloomington, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Introduction In concurrent programming languages like CML [Rep97], Facile [TLK96] and Pict <ref> [PT97] </ref>, which contain a scoping mechanism for channels and allow the communication of channels names, one can write programs with mobility: sending (the name of) a local channel out of its scope and, as a result, enlarging its scope with the receiver.
Reference: [Rep92] <author> J.H. Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, Ithaca, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Every client has its own reply channel to ensure that the server returns each reply to the right client (for more details we refer the reader to <ref> [Rep92, Chapter 4] </ref>). val request_channel = channel () fun client request = let val reply_channel = channel () in send (request_channel, (request, reply_channel)); accept reply_channel end fun reply_to request = ... fun server () = let val (request, reply_channel) = accept request_channel in spawn (fn () =&gt; send (reply_channel, reply_to request));
Reference: [Rep97] <author> J.H. Reppy. </author> <title> Concurrent Programming in ML. </title> <address> Cambridge University Pres, Cambridge, </address> <year> 1997. </year>
Reference-contexts: Introduction In concurrent programming languages like CML <ref> [Rep97] </ref>, Facile [TLK96] and Pict [PT97], which contain a scoping mechanism for channels and allow the communication of channels names, one can write programs with mobility: sending (the name of) a local channel out of its scope and, as a result, enlarging its scope with the receiver.
Reference: [San92] <author> D. Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: first-order and higher-order paradigms. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: In this paper, we present a compositional, yet not `uniform', encoding of the -calculus into CCS. We follow the scheme proposed by Sangiorgi in his thesis <ref> [San92, page 8 and 9] </ref>: we treat the formal definition of the semantics of the two calculi, the definition of the compositional encoding of the one calculus into the other, and a proof of the correctness of the encoding with respect to the semantics given. <p> The final section concludes and discusses related and future work. 1 -Calculus We present the coinfinite fragment of the monadic 2 -calculus extended with countable restrictions and countably infinite compositions. Furthermore, we introduce reduction bisimilarity. Our presentation is based on Sangiorgi's thesis <ref> [San92, Subsection 2.2.2 and Section 3.2] </ref>. Definition 1.1 Let N = fx; y; z; : : :g be a (countably infinite) set of names. <p> Q a Q a We have omitted the symmetric versions of the rules 6, 7, 8, and 9. The only differences from the axioms and rules given in <ref> [San92] </ref> are that rule 1 is a little more general (like in, e.g., [ACS96]), the rules 4, 5, and 9 have been changed to deal with sets of names, and rule 10 has been added to handle countably infinite compositions The rule for replication is P j !P ! P 0
Reference: [San93] <author> D. Sangiorgi. </author> <title> From -Calculus to Higher-Order -Calculus|and back. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of the 5th International Conference on Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-166, </pages> <address> Orsay, April 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: (P 0 ) n N 2 ccs E (Q 0 ) n N 2 [Lemma 3.5] () E 0 (P ) ccs E 0 (Q): [Lemma 5.2] 2 Conclusion Ever since its introduction, the expressiveness of the -calculus and related calculi has attracted a considerable amount of attention (see, e.g., <ref> [Bou92, Bor96, HT91, NP96, San93] </ref>). Here, we have shown that the -calculus can be encoded in CCS is a compositional way. From this result we should not conclude that we 10 can therefore focus on CCS. In contrast to CCS, the -calculus is a calculus with mobility.
Reference: [San96] <author> D. Sangiorgi. </author> <title> -Calculus, Internal Mobility, and Agent-Passing Calculi. </title> <journal> Theoretical Computer Science, </journal> 167(1/2):235-274, October 1996. 
Reference-contexts: According to Milner [Mil83, page 291], the passing of communication links as values, which is one of the key features of the -calculus, cannot obviously be expressed in a general form in CCS. Sangiorgi <ref> [San96, page 235] </ref> even claimed that this phenomenon gives the -calculus a much greater expressiveness than CCS.
Reference: [Sta96] <author> I. Stark. </author> <title> A Fully Abstract Domain Model for the -Calculus. </title> <booktitle> In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 36-42, </pages> <address> New Brunswick, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The smaller the scope of a channel, the less pressure it puts on the registers. Note that the construction of normal forms does exactly the opposite. Whether our encoding of the -calculus into CCS has any impact on the existing denotational models for the -calculus, like e.g. <ref> [FMS96, Sta96, CSW97] </ref>, needs further study. These models are much more complex than the ones for CCS and the encoding might give us some insight how the models for the -calculus can be simplified.
Reference: [TLK96] <author> B. Thomsen, L. Leth, and T.-M. Kuo. </author> <title> A Facile Tutorial. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> Proceedings of CONCUR'96, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 278-298, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Introduction In concurrent programming languages like CML [Rep97], Facile <ref> [TLK96] </ref> and Pict [PT97], which contain a scoping mechanism for channels and allow the communication of channels names, one can write programs with mobility: sending (the name of) a local channel out of its scope and, as a result, enlarging its scope with the receiver.
Reference: [Tur95] <author> D.N. Turner. </author> <title> The Polymorphic Pi-Calculus: Theory and Implementation. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Edinburgh, </institution> <year> 1995. </year> <month> 12 </month>
Reference-contexts: Reduction bisimilarity focuses on the key feature of concurrency: interaction. Although this semantic equivalence is rather weak|in general, reduction bisimilarity is not preserved by composition|it allows us to give a compositional encoding. Reduction (bisimilarity) is often used in more practical applications (cf. the abstract machine implementation of the -calculus <ref> [Tur95, Chapter 7] </ref>). In the conclusion, we will sketch how we expect to change our encoding to deal with early bisimilarity. This semantic equivalence is the one that corresponds to barbed bisimilarity [MS92]|a canonical semantic equivalence for calculi like CCS and the -calculus.
References-found: 32

