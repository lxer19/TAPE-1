URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-richardson.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: email: julianr@dai.ed.ac.uk  
Title: Proof Planning with Schema Frameworks  
Author: Julian Richardson ?? 
Address: Edinburgh EH1 1HN, Scotland  
Affiliation: 1 Department of Artificial Intelligence, Edinburgh University, 80 South Bridge,  
Abstract: Recently, schema-based program transformation and synthesis techniques have received a lot of attention, especially at LOPSTR. It seems that schema-based techniques often fall into one of two categories: either they are pragmatic, designed for carrying out real program transformation or synthesis operations, but lacking the logical basis that they need to ensure that they really do synthesise/transform programs correctly, or they are rigorous, with strong theoretical foundations, but their use generates proof obligations which are difficult to satisfy. In this paper, we propose that proof planning offers a paradigm which combines logical rigour with usability, and, in addition, allows the employment (or indeed development) of schemas to be integrated in a very natural way with the automatic satisfaction of any proof obligations which arise. 
Abstract-found: 1
Intro-found: 1
Reference: [ASG97] <author> Alessandro Armando, Alan Smaill, and Ian Green. </author> <title> Automatic synthesis of recursive programs: The proof-planning paradigm. </title> <booktitle> In 12th IEEE International Automated Software Engineering Conference, </booktitle> <pages> pages 2-9, </pages> <address> Lake Tahoe, Nevada, USA, </address> <year> 1997. </year>
Reference: [Bun91a] <author> Alan Bundy. </author> <title> A science of reasoning. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <pages> pages 178-198. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year> <note> Also available from Edinburgh as DAI Research Paper 445. </note>
Reference-contexts: In [FLO98] a rigorous formulation of program synthesis schemas called frameworks is proposed. Application of such a schema involves choosing instantiations for its open symbols and proving that the required framework axioms are satisfied. In this paper, we propose that proof planning <ref> [Bun91a] </ref> provides a way of both encoding heuristics for choosing instantiations of the framework's open symbols and for satisfying the resulting proof obligations.
Reference: [Bun91b] <author> Alan Bundy. </author> <title> The use of proof plans for normalization. </title> <editor> In R. S. Boyer, editor, </editor> <booktitle> Essays in Honor of Woody Bledsoe, </booktitle> <pages> pages 149-166. </pages> <publisher> Kluwer, </publisher> <year> 1991. </year> <note> Also available from Edinburgh as DAI Research Paper No. 513. </note>
Reference-contexts: If desired, a numerical score can be calculated by the method and used to determine the order in which method combinations are searched, so-called best-first planning [MIB93]. 9 Granularity Another benefit can be expected from combining schemas with other proof planning methods. In <ref> [Bun91b] </ref>, decision procedures were encoded using proof planning methods, and it was found that other proof planning methods could be interleaved with the decision procedure and in so doing extended the range of formulae it could decide.
Reference: [FLO97] <author> P. Flener, K.-K. Lau, and M. Ornaghi. </author> <title> Correct-schema-guided synthesis of steadfast programs. </title> <editor> In M. Lowry and Y. Ledru, editors, </editor> <booktitle> Proceedings of ASE '97. </booktitle> <publisher> IEEE CS Press, </publisher> <month> November </month> <year> 1997. </year>
Reference: [FLO98] <author> P. Flener, K.-K. Lau, and M. Ornaghi. </author> <title> On correct program schemas. </title> <editor> In N. E. Fuchs, editor, </editor> <booktitle> LOPSTR '97: Proceedings of the Seventh International Workshop on Logic Program Synthesis and Transformation, </booktitle> <address> Leuven, Belgium, </address> <month> July 10-12 </month> <year> 1997. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, forthcoming, </publisher> <year> 1998. </year>
Reference-contexts: In <ref> [FLO98] </ref> a rigorous formulation of program synthesis schemas called frameworks is proposed. Application of such a schema involves choosing instantiations for its open symbols and proving that the required framework axioms are satisfied. <p> Any practical transformation (or synthesis) system should provide a way of managing these correctness conditions while ensuring that they do not swamp the application process and so render it unusable. In this paper we will concentrate on the formulation of program schemas as open frameworks <ref> [FLO98] </ref>. An open framework can be seen as an abstract data type which contains certain undefined predicate symbols. In the framework-based view, schemas are applied by supplying an implementation of the abstract data type.
Reference: [IB96] <author> A. Ireland and A. Bundy. </author> <title> Productive use of failure in inductive proof. </title> <journal> Journal of Automated Reasoning, </journal> <note> 16(1-2):79-111, 1996. Also available as DAI Research Paper No 716, </note> <institution> Dept. of Artificial Intelligence, Edinburgh. </institution>
Reference-contexts: Rippling. Rippling is a technique for automating proofs by induction, which arise naturally during program synthesis and verification proofs. 2. Explanation. In [Low97], it is shown how explanations can be generated in natural language based on the success or failure of method preconditions. 3. Critics. Proof critics <ref> [IB96] </ref> are generally triggered by the failure of critical method preconditions, and they then suggest a proof patch, for example by speculating a lemma and proving it or by correcting a faulty conjecture [MBI94]. 4. Higher-order reasoning. Reasoning about programs and specifications is naturally a higher-order task.
Reference: [Kra94] <author> I. Kraan. </author> <title> Proof Planning for Logic Program Synthesis. </title> <type> PhD thesis, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1994. </year>
Reference: [Low97] <author> H. Lowe. </author> <title> The use of theorem provers in the teaching and practice of formal methods. </title> <booktitle> In Proceedings of the Irish Workshop on Formal Methods, </booktitle> <address> Dublin, </address> <month> July </month> <year> 1997, 1997. </year> <note> Published in the Springer-Verlag Electronic Workshop Series in Computer Science. </note>
Reference-contexts: Rippling. Rippling is a technique for automating proofs by induction, which arise naturally during program synthesis and verification proofs. 2. Explanation. In <ref> [Low97] </ref>, it is shown how explanations can be generated in natural language based on the success or failure of method preconditions. 3. Critics.
Reference: [MBI94] <author> R. Monroy, A. Bundy, and A. Ireland. </author> <title> Proof Plans for the Correction of False Conjectures. </title> <editor> In F. Pfenning, editor, </editor> <booktitle> 5th International Conference on Logic Programming and Automated Reasoning, LPAR'94, Lecture Notes in Artificial Intelligence, v. </booktitle> <volume> 822, </volume> <pages> pages 54-68, </pages> <address> Kiev, Ukraine, </address> <year> 1994. </year> <note> Springer-Verlag. Also available from Edinburgh as DAI Research Paper 681. </note>
Reference-contexts: Critics. Proof critics [IB96] are generally triggered by the failure of critical method preconditions, and they then suggest a proof patch, for example by speculating a lemma and proving it or by correcting a faulty conjecture <ref> [MBI94] </ref>. 4. Higher-order reasoning. Reasoning about programs and specifications is naturally a higher-order task. Work is currently in progress on adapting existing proof planning techniques to a higher-order setting [RSG98]. 8 Schema Selection When a number of schemas can be applied, we are faced with a search problem.
Reference: [MIB93] <author> A. Manning, A. Ireland, and A. Bundy. </author> <title> Increasing the versatility of heuristic based theorem provers. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> International Conference on Logic Programming and Automated Reasoning - LPAR 93, St. Petersburg, number 698 in Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages pp 194-204. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: If desired, a numerical score can be calculated by the method and used to determine the order in which method combinations are searched, so-called best-first planning <ref> [MIB93] </ref>. 9 Granularity Another benefit can be expected from combining schemas with other proof planning methods.
Reference: [RF97] <author> J. D. C. Richardson and N. E. Fuchs. </author> <title> Development of correct transformation schemata for Prolog programs. </title> <editor> In Norbert E Fuchs, editor, </editor> <booktitle> LOPSTR '97: Proceedings of the Seventh International Workshop on Logic Program Synthesis and Transformation. </booktitle> <institution> Katholieke Universiteit Leuven, </institution> <month> July </month> <year> 1997. </year> <note> Report CW 253, Full proceedings to be published by Springer in the LNCS series. </note>
Reference-contexts: In <ref> [RF97] </ref>, it was proposed that Prolog program transformation schemas should be constructed stepwise by composing schemas which represent low-level program transformation techniques, in particular fold/unfold. Transformations were considered to be correct if application of a schema produced a program which was equivalent to the original under the pure Prolog semantics.
Reference: [RSG98] <author> J.D.C. Richardson, A. Smaill, and I. M. Green. </author> <title> System description: Proof planning in higher-order logic with Clam. </title> <booktitle> In Proceedings of CADE-15, </booktitle> <publisher> forthcoming, </publisher> <year> 1998. </year>
Reference-contexts: Higher-order reasoning. Reasoning about programs and specifications is naturally a higher-order task. Work is currently in progress on adapting existing proof planning techniques to a higher-order setting <ref> [RSG98] </ref>. 8 Schema Selection When a number of schemas can be applied, we are faced with a search problem. In [VF96], transformation schemas are assigned a numerical preference and are tried in order of that preference.
Reference: [Smi85] <author> D. R. Smith. </author> <title> The top-down synthesis of divide and conquer algorithms. </title> <journal> AI, </journal> <volume> 27(1), </volume> <year> 1985. </year>
Reference-contexts: The implementation of schemas as proof planning methods will have a significant benefit in that use of the schemas and satisfaction of the resulting proof obligations can be uniformly carried out in the same proof planning framework. The algorithm design strategies of <ref> [Smi85] </ref> may each be separately implemented as methods. 7 Useful Techniques from Proof Planning A number of techniques which have been developed in the context proof planning should be useful in conjunction with schemas: 1. Rippling.
Reference: [VF96] <author> W. W. Vasconcelos and N.E. Fuchs. </author> <title> An opportunistic approach for logic program analysis and optimisation using enhanced schema-based transformations. </title> <booktitle> In Proceedings of LoPSTr'95, Fifth International Workshop on Logic Program Synthesis and Transformation, </booktitle> <address> Utrecht, Netherlands, </address> <booktitle> volume 1048 of Lecture Notes in Computer Science, </booktitle> <pages> pages 175-188. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: scores could be used to help choose between alternative paths in the search space of possible schema developments (x8), and that some attention should be paid to the granularity at which schemas are encoded as methods (x9). 2 Correctness Conditions in Program Schemas Many formulations of program schemas (for example <ref> [VF96] </ref>) are primarily syntactic. In [RF97], it was proposed that Prolog program transformation schemas should be constructed stepwise by composing schemas which represent low-level program transformation techniques, in particular fold/unfold. <p> Higher-order reasoning. Reasoning about programs and specifications is naturally a higher-order task. Work is currently in progress on adapting existing proof planning techniques to a higher-order setting [RSG98]. 8 Schema Selection When a number of schemas can be applied, we are faced with a search problem. In <ref> [VF96] </ref>, transformation schemas are assigned a numerical preference and are tried in order of that preference. If we view schemas as tactics, then the meta-level of the method pre- and postconditions can be used to determine more precisely when it is appropriate to apply a schema.
Reference: [Wig92] <author> G. A. Wiggins. </author> <title> Synthesis and transformation of logic programs in the Whelk proof development system. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Proceedings of JICSLP-92, </booktitle> <pages> pages 351-368. </pages> <editor> M. </editor> <title> I.T. </title> <publisher> Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
References-found: 15

