URL: http://www.cs.cmu.edu/afs/cs/project/jair/pub/volume4/marchiori96a.ps
Refering-URL: http://www.cs.washington.edu/research/jair/abstracts/marchiori96a.html
Root-URL: 
Email: elena@cwi.nl  
Title: Practical Methods for Proving Termination of General Logic Programs  
Author: Elena Marchiori 
Address: P.O. Box 94079, 1090 GB Amsterdam, The Netherlands  
Affiliation: Centrum voor Wiskunde en Informatica (CWI)  
Note: Journal of Artificial Intelligence Research 4 (1996) 179-208 Submitted 11/95; published 4/96  
Abstract: Termination of logic programs with negated body atoms (here called general logic programs) is an important topic. One reason is that many computational mechanisms used to process negated atoms, like Clark's negation as failure and Chan's constructive negation, are based on termination conditions. This paper introduces a methodology for proving termination of general logic programs w.r.t. the Prolog selection rule. The idea is to distinguish parts of the program depending on whether or not their termination depends on the selection rule. To this end, the notions of low-, weakly up-, and up-acceptable program are introduced. We use these notions to develop a methodology for proving termination of general logic programs, and show how interesting problems in non-monotonic reasoning can be formalized and implemented by means of terminating general logic programs.
Abstract-found: 1
Intro-found: 1
Reference: <author> Apt, K., & Bezem, M. </author> <year> (1991). </year> <title> Acyclic programs. </title> <journal> New Generation Computing, </journal> <volume> 9, </volume> <pages> 335-363. </pages>
Reference-contexts: Note that this query would flounder when negation as finite failure is used. 4. Acceptable Programs In the previous section, we have seen how termination of glp's w.r.t. an arbitrary selection rule can be proven by means of the notion of acyclicity. The notion of acceptability <ref> (Apt & Pedreschi, 1991) </ref> is used for proving termination of glp's w.r.t. the Prolog selection rule. In this section, we recall this notion, together with some useful results from (Marchiori, 1996).
Reference: <author> Apt, K., & Bol, R. </author> <year> (1994). </year> <title> Logic programming and negation: a survey. </title> <journal> The Journal of Logic Programming, </journal> <pages> 19-20, 9-71. </pages>
Reference-contexts: Floundering is an abnormal form of termination which arises as soon as a non-ground negated atom is selected, as explained e.g., in <ref> (Apt & Bol, 1994) </ref>. To treat also non-ground negated atoms, Chan (1988) introduced a procedure known as Chan's constructive negation.
Reference: <author> Apt, K., & Pedreschi, D. </author> <year> (1991). </year> <title> Proving termination of general prolog programs. </title> <booktitle> In Proceedings of the Int. Conf. on Theoretical Aspects of Computer Software, </booktitle> <volume> Vol. LNCS 526, </volume> <pages> pp. 265-289. </pages> <publisher> Springer Verlag. </publisher>
Reference-contexts: Note that this query would flounder when negation as finite failure is used. 4. Acceptable Programs In the previous section, we have seen how termination of glp's w.r.t. an arbitrary selection rule can be proven by means of the notion of acyclicity. The notion of acceptability <ref> (Apt & Pedreschi, 1991) </ref> is used for proving termination of glp's w.r.t. the Prolog selection rule. In this section, we recall this notion, together with some useful results from (Marchiori, 1996).
Reference: <author> Baral, C., & Gelfond, M. </author> <year> (1994). </year> <title> Logic programming and knowledge representation. </title> <journal> The Journal of Logic Programming, </journal> <pages> 19-20, 73-148. </pages>
Reference: <author> Bratko, I. </author> <year> (1986). </year> <title> PROLOG Programming for Artificial Intelligence. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Next, we define the notion of low-acceptability and prove some results. Finally, we apply this notion to the program of our example. 7.1 An Example: Graph Specialization Graph structures are used in AI for many applications, such as the representation of relations, situations or problems <ref> (see e.g., Bratko, 1986) </ref>. Two typical operations on graphs are find a path between two given nodes, and find a subgraph with some specified properties. The program specialize below uses both these operations to solve the following problem.
Reference: <author> Chan, D. </author> <year> (1988). </year> <title> Constructive negation based on the completed database. </title> <booktitle> In Proceedings of the 5th Int. Conf. and Symp. on Logic Programming, </booktitle> <pages> pp. 111-125. </pages>
Reference-contexts: For example, Prolog's negation as finite failure operator can be used to implement the temporal persistence problem in Artificial Intelligence as a logic program (Kowalski & Sergot, 1986; Evans, 1990; Apt & Bezem, 1991). The implementation of operators like Clark's negation as failure (Clark, 1978) and Chan's constructive negation <ref> (Chan, 1988) </ref>, is based on termination conditions. Therefore the study of termination of glp's (e.g., De Schreye & Decorte, 1994) is an important topic. Two classes of glp's that behave well w.r.t. termination are the so-called acyclic and acceptable programs (Apt & Bezem, 1991; Apt & Pedreschi, 1991).
Reference: <author> Clark, K. </author> <year> (1978). </year> <title> Logic and Databases, chap. Negation as Failure, </title> <journal> pp. </journal> <pages> 293-322. </pages> <publisher> Plenum Press, </publisher> <address> NY. </address>
Reference-contexts: For example, Prolog's negation as finite failure operator can be used to implement the temporal persistence problem in Artificial Intelligence as a logic program (Kowalski & Sergot, 1986; Evans, 1990; Apt & Bezem, 1991). The implementation of operators like Clark's negation as failure <ref> (Clark, 1978) </ref> and Chan's constructive negation (Chan, 1988), is based on termination conditions. Therefore the study of termination of glp's (e.g., De Schreye & Decorte, 1994) is an important topic. <p> For instance, consider the program p (a) . The answer to the query :p (X) is X 6= a ^ X 6= b. We call sldcnf-resolution, sld-resolution augmented with Chan's procedure. To show the correctness of sldcnf-resolution, we choose as program semantics the Clark's completion <ref> (Clark, 1978) </ref>. This semantics is a natural interpretation of a glp as a set of definitions. Intuitively, the Clark's completion of a program P , denoted by comp (P ), is the first-order theory obtained by replacing the implication of each clause of P with an equivalence.
Reference: <author> De Schreye, D., & Decorte, S. </author> <year> (1994). </year> <title> Termination of logic programs: The never-ending story. </title> <journal> The Journal of Logic Programming, </journal> <pages> 19-20, 199-260. </pages>
Reference-contexts: The implementation of operators like Clark's negation as failure (Clark, 1978) and Chan's constructive negation (Chan, 1988), is based on termination conditions. Therefore the study of termination of glp's <ref> (e.g., De Schreye & Decorte, 1994) </ref> is an important topic. Two classes of glp's that behave well w.r.t. termination are the so-called acyclic and acceptable programs (Apt & Bezem, 1991; Apt & Pedreschi, 1991). <p> For instance, the program: p (X) : q (Y). q (0) . is terminating (floundering) but it is not acyclic. Finding a level mapping for proving acyclicity is a creative process. We refer the reader to <ref> (De Schreye & Decorte, 1994) </ref> for a thorough presentation of various techniques for constructing level mappings.
Reference: <author> Dershowitz, N. </author> <year> (1987). </year> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3, </volume> <pages> 69-116. </pages>
Reference: <author> Evans, C. </author> <year> (1990). </year> <title> Negation as failure as an approach to the hanks and mcdermott problem. </title> <booktitle> In Proceedings of the 2nd International Symposium om AI, </booktitle> <pages> pp. 23-27. </pages>
Reference: <author> Kowalski, R., & Sergot, M. </author> <year> (1986). </year> <title> A logic based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4, </volume> <pages> 67-95. </pages>
Reference: <author> Marchiori, E. </author> <year> (1995). </year> <title> A methodology for proving termination of general logic programs. </title> <booktitle> In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI'95), </booktitle> <pages> pp. 356-367. </pages>
Reference-contexts: Sections 5, 6, and 7, contain our alternative definitions of acceptability. In Section 8 these definitions are integrated in a methodology for proving termination. Finally, in Section 9 some conclusions are given. This paper is an extended and revised version of <ref> (Marchiori, 1995) </ref>. 2. Preliminaries The following notation will be used. We follow Prolog syntax and assume that a string starting with a capital letter represents a variable, while other strings represent constants, terms and relations. Relation symbols are often denoted by p; q; r.
Reference: <author> Marchiori, E. </author> <year> (1996). </year> <title> On termination of general logic programs w.r.t. constructive negation. </title> <journal> The Journal of Logic Programming, </journal> <volume> 26(1), </volume> <pages> 69-89. </pages>
Reference-contexts: Acyclic Programs Our method will be based on the notions of acyclicity and acceptability, which are used to characterize a class of terminating programs w.r.t. an arbitrary and the Prolog selection rule, respectively. In this section we recall the definition of acyclicity, and some useful results from <ref> (Marchiori, 1996) </ref>, while acceptability will be discussed in Section 4. Apt and Bezem (1991) study termination of glp's w.r.t. an arbitrary selection rule. They introduce the following elegant syntactic notion. <p> Apt and Bezem prove that for an acyclic program, every bounded query Q has only finite derivations w.r.t. negation as finite failure. The converse of this result does not hold, due to the possibility of floundering. Instead, using Chan's constructive negation, we obtain a complete characterization <ref> (Marchiori, 1996) </ref>. First, we formalize the concept of termination w.r.t. an arbitrary selection rule. Definition 3.3 (Terminating Query and Program) A query is terminating (w.r.t. P ) if all its sldcnf-derivations (in P ) are finite. A program P is terminating if all ground queries are terminating w.r.t. <p> The notion of acceptability (Apt & Pedreschi, 1991) is used for proving termination of glp's w.r.t. the Prolog selection rule. In this section, we recall this notion, together with some useful results from <ref> (Marchiori, 1996) </ref>. Acyclicity and acceptability will be combined in the following sections to provide more practical tools for proving termination of glp's w.r.t. the Prolog selection rule. <p> The converse of this result holds when Chan's constructive negation is used <ref> (Marchiori, 1996) </ref>. First, we formalize the concept of termination w.r.t. the Prolog selection rule. Definition 4.4 (Left-Terminating Query and Program) A query is left-terminating (w.r.t. P ) if all its ldcnf-derivations are finite. A program P is left-terminating if every ground query is left-terminating w.r.t.
Reference: <author> McCarthy, J., & Hayes, P. </author> <year> (1969). </year> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <journal> Machine Intelligence, </journal> <volume> 4, </volume> <pages> 463-502. </pages>
Reference-contexts: An example of an initial situation is given in Kowalski (1979) gives a clausal representation of this problem by means of pre- and post-conditions. Here we formulate the problem using McCarthy and Hayes' situation calculus 183 Marchiori <ref> (McCarthy & Hayes, 1969) </ref>, in terms of facts, events and situations.
Reference: <author> Nilsson, N. </author> <year> (1982). </year> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The following section illustrates how an interesting problem in nonmonotonic reasoning can be formalized and implemented as an acyclic program. 3.1 An Example: Blocks World The blocks world is a formulation of a problem in AI, where a robot performs a number of primitive actions in a simple world <ref> (see for instance Nilsson, 1982) </ref>. Here we consider a simpler version of this problem by Sacerdoti (1977). There are three blocks a, b, c, and three different positions p, q, r on a table.
Reference: <author> Sterling, L., & Shapiro, E. </author> <year> (1994). </year> <title> The Art of Prolog. </title> <publisher> MIT Press. </publisher> <pages> 208 </pages>
Reference-contexts: This problem can be solved using a nondeterministic algorithm <ref> (Sterling & Shapiro, 1994) </ref>: while the desired configuration has not yet been reached, find a legal action, update the current configuration, and check that it was not already obtained.
References-found: 16

