URL: http://siesta.cs.wustl.edu/~engel/doc/FACE_ESEC.ps.gz
Refering-URL: http://siesta.cs.wustl.edu/~engel/
Root-URL: http://www.cs.wustl.edu
Title: Making Design Patterns Explicit in FACE A Framework Adaptive Composition Environment  
Author: Theo Dirk Meijler, Serge Demeyer, Robert Engel 
Keyword: Frameworks, Design Patterns, Software composition, Visual Composition, Reflection  
Address: (RE) 3  
Affiliation: Baan Labs (TDM) 1 Software Composition Group, University of Berne (SD) 2 Washington University, Computer Science Department  
Abstract: Tools incorporating design patterns combine the advantage of having a high-abstraction level of describing a system and the possibility of coupling these abstractions to some underlying implementation. Still, all current tools are based on generating source code in which the design patterns become implicit. After that, further extension and adaptation of the software is needed but this can no longer be supported at the same level of abstraction. This paper presents FACE, an environment based on an explicit representation of design patterns, sustaining an incremental development style without abandoning the higher-level design pattern abstraction. A visual composition tool for FACE has been developed in the Self programming language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Don Batory and Sean OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems With Reusable Components, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference: [2] <author> Don Batory, Vivek Singhal, Jeff Thomas, Sankar Dasari, Bart Geraci and Marty Sirkin, </author> <title> The GenVoca Model of Software-System Generators, </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1994, </year> <pages> pp. 89-94. </pages>
Reference: [3] <author> Serge Demeyer, Stphane Ducasse, Robb Nebbe, Oscar Nierstrasz and Tamar Richner, </author> <title> Using Restructuring Transformations to Reengineer Object-Oriented Systems, </title> <note> Submitted to WCRE97. Available from the SCG-website (http://iamwww.unibe.ch/~famoos/). </note>
Reference: [4] <author> Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides, </author> <title> Design Patterns, </title> <publisher> Addi-son Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction Design patterns <ref> [4] </ref> are gaining more and more attention as a technique for supporting the development and maintenance of object-oriented applications and frameworks. <p> Thus, the realization presented here cannot be simply copied to fit any framework. This is true for primal schema modeling primitives as well as semantics. The patterns have been chosen from the Design patterns book design pattern catalogue <ref> [4] </ref>, each having a non-trivial class structure and belonging to a different pattern category, namely the AbstractFactory and the State pattern. <p> In section 10 we discuss related work, in section 11 we give a conclusion and discuss future work. 2 Short Description of the Abstract Factory Design Pattern The first example in this paper will be the Abstract Factory design pattern. We refer to <ref> [4] </ref> for details. The Abstract Factory design pattern is used when client objects want to create certain objects (e.g., window objects, scrollbar objects) but the instantiation of these objects should not commit the client to choosing a specific implementation for these objects (e.g., either Presentation Manager Window or Motif Window). <p> We refer to <ref> [4] </ref> for details. The state design pattern is used when an object has to exhibit state dependent behavior, that is, dependent on its state the object reacts differently to the same requests for operation execution. <p> It changes state by exchanging that object. The TCP network protocol implementation that is an example of the use of the state pattern is taken from [5]. The solution is somewhat different from the standard solution <ref> [4] </ref> in that, instead of the context object (here called a protocol object) directly reacting to messages, and delegating these to its state object, there will be a request object 1 that represents the operation to be executed. <p> This diagram is again close to a class-diagram, as in the example for the Abstract-Factory pattern (figure 2), it contains much more pattern specific information, so that it 1. In [5] this is called a messenger object. We follow however the general terminology in <ref> [4] </ref>. TCPClosed PassiveOpen ActiveOpen Send Close TCPListen PassiveOpen ActiveOpen Send Close TCPEstablished PassiveOpen ActiveOpen Send Close TCPActiveOpen PassiveOpen ActiveOpen Send Close TCPEstablished [ ]theInstance TCPClose [ ]theInstance 4.TCPClose::instance 3.close (cm,p) aTCPEstablished ts 1.accept (cm) 2.apply (ts,p) et.al.[5].
Reference: [5] <author> Hermann Hueni, Ralph E. Johnson and Robert Engel, </author> <title> A Framework for Network Protocol Software, </title> <journal> Proceedings OOPSLA95, ACM SIGPLAN Notices, </journal> <note> to appear. </note>
Reference-contexts: The object delegates requests that have to be handled state dependently to another object (the state object). It changes state by exchanging that object. The TCP network protocol implementation that is an example of the use of the state pattern is taken from <ref> [5] </ref>. The solution is somewhat different from the standard solution [4] in that, instead of the context object (here called a protocol object) directly reacting to messages, and delegating these to its state object, there will be a request object 1 that represents the operation to be executed. <p> This diagram is again close to a class-diagram, as in the example for the Abstract-Factory pattern (figure 2), it contains much more pattern specific information, so that it 1. In <ref> [5] </ref> this is called a messenger object. We follow however the general terminology in [4]. TCPClosed PassiveOpen ActiveOpen Send Close TCPListen PassiveOpen ActiveOpen Send Close TCPEstablished PassiveOpen ActiveOpen Send Close TCPActiveOpen PassiveOpen ActiveOpen Send Close TCPEstablished [ ]theInstance TCPClose [ ]theInstance 4.TCPClose::instance 3.close (cm,p) aTCPEstablished ts 1.accept (cm) 2.apply (ts,p) et.al.[5]. <p> A fully implemented protocol needs more states. Only subclasses are shown for states needed to establish a connection and for the closed state. Note that we shall call messengers as used in <ref> [5] </ref> requests in the text. TCPState PassiveOpen ActiveOpen Send Close aCloseMessenger cm state [ ] aProtocol p ops state 1:1 TCPOperation:MetaAbstrOper TCPStatePattern context state operation Send Close ACK Close Close Send ActiveOpen ops opsops pattern. In this case a realization of the TCP Protocol modeled in state pattern specific terms.
Reference: [6] <author> Gregor Kiczales, Jim des Rivires and Daniel G. Bobrow, </author> <title> The Art of the Metaobject Protocol, </title> <publisher> MIT Press (Ed.), </publisher> <year> 1991. </year>
Reference-contexts: All these approaches offer a fixed meaning to links between classes. In contrast, in FACE arbitrary kinds of relationships may be introduced. This is a result of the meta-level that is provided. In this respect, our work has roots in the area of open programming languages such as CLOS <ref> [6] </ref>, and in Open Implementations [16]. Open programming languages such as CLOS reify their software components (classes), but the reification is not black-box the reification is quite complex, and it is difficult to create drastically different components because of the intricate cooperation between all parts of the reified class.
Reference: [7] <author> Wolfgang Klas, E.J. Neuhold and Michael Schrefl, </author> <title> Metaclasses in VODAK and their Application in Database Integration, </title> <journal> Arbeitpapiere der GMD, </journal> <volume> no. 462, </volume> <year> 1990. </year>
Reference-contexts: The way in which we use reification and reflection is close to the model of Klas and Neuhold <ref> [7] </ref>. Their model also allows one to introduce new kinds of relationships. They focus on adaptive data models for databases systems, less on frameworks and application development. We feel that our model is simpler and therefore easier to understand and use.
Reference: [8] <author> Christina V. Lopes, Karl J. Lieberherr, </author> <title> AP/S++: Case-Study of a MOP for Purposes of Software Evolution, Proceedings Reflection 96, </title> <note> to appear. </note>
Reference: [9] <author> Karl J. Lieberherr, Ignacio Silva-Lepe, Cun Xiao, </author> <title> Adaptive object-oriented programming using graph-based customization, </title> <journal> Commun of the ACM, </journal> <volume> Vol 37, no. 5, </volume> <month> May </month> <year> 1993, </year> <pages> pp 94-101. </pages>
Reference: [10] <author> Jeff Magee, Naranker Dulay and Jeffrey Kramer, </author> <title> Structuring Parallel and Distributed Programs, </title> <booktitle> Proceedings of the International Workshop on Configurable Distributed Systems, </booktitle> <address> London, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: The Standard Template Library STL [13] shows the power of applying this idea. Also the work of Batory et. al. [1][2] is based on parameterizing class-level components with class-level components. The work of McGee and Kramer on Darwin <ref> [10] </ref> represents another form of class-level composition: Links between components basically describe communication possibilities between the instances. All these approaches offer a fixed meaning to links between classes. In contrast, in FACE arbitrary kinds of relationships may be introduced. This is a result of the meta-level that is provided.
Reference: [11] <author> Vicki de Mey, </author> <title> Visual Composition of Software Applications, </title> <booktitle> in [14], </booktitle> <pages> pp. 275-303. </pages>
Reference-contexts: By requesting evaluation of addTmp (push the Evaluate button) the composition will be made if it is a correct link, as is the case here. Vista <ref> [11] </ref> is a visual tool that supports composition, and that can be adapted to the composition rules. In contrast to FACE, Vista does not support a precise distinction between class components and instances.
Reference: [12] <author> Microtool homepage: </author> <note> http://www.microtool.de/ </note>
Reference-contexts: If this check returns true, the attempt succeeds. In this example, PMWindow is an instance of ConcreteProd, so the attempt succeeds. 10 Related work The idea of actively supporting design patterns is finding its way into CASE tools. A first commercial product supporting patterns is Objectif <ref> [12] </ref>. A more experimental approach is described by Pagel & Winter [15]. These kinds of tools focus on helping the framework designer: patterns are mainly used to support the design of the framework architecture. Code can be generated, but this is not the main goal of these tools.
Reference: [13] <author> David R. Musser and Atul Saini, </author> <title> STL Tutorial and Reference Guide, </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Composition at the level of classes (although not visually supported) is encountered in particular in generic constructs, where classes can be parameterized with other classes, such as in the template classes in C++. The Standard Template Library STL <ref> [13] </ref> shows the power of applying this idea. Also the work of Batory et. al. [1][2] is based on parameterizing class-level components with class-level components. The work of McGee and Kramer on Darwin [10] represents another form of class-level composition: Links between components basically describe communication possibilities between the instances.
Reference: [14] <editor> Oscar Nierstrasz and Dennis Tsichritzis (Ed.), </editor> <booktitle> Object-Oriented Software Composition, </booktitle> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference: [15] <author> Bernd-Uwe Pagel, Mario Winter, </author> <title> Towards Pattern-Based Tools, </title> <booktitle> EuroPLoP Preliminary Conference Proceedings, </booktitle> <month> July </month> <year> 1996 </year>
Reference-contexts: In this example, PMWindow is an instance of ConcreteProd, so the attempt succeeds. 10 Related work The idea of actively supporting design patterns is finding its way into CASE tools. A first commercial product supporting patterns is Objectif [12]. A more experimental approach is described by Pagel & Winter <ref> [15] </ref>. These kinds of tools focus on helping the framework designer: patterns are mainly used to support the design of the framework architecture. Code can be generated, but this is not the main goal of these tools.
Reference: [16] <author> Ramana Rao, </author> <title> Implementational Reflection in Silica, </title> <booktitle> Proceedings ECOOP 91, </booktitle> <editor> P. America (Ed.), </editor> <publisher> LNCS 512, Springer-Verlag, </publisher> <address> Geneva, Switzerland, </address> <month> July 15-19, </month> <year> 1991, </year> <pages> pp. 251-267. </pages>
Reference-contexts: In contrast, in FACE arbitrary kinds of relationships may be introduced. This is a result of the meta-level that is provided. In this respect, our work has roots in the area of open programming languages such as CLOS [6], and in Open Implementations <ref> [16] </ref>. Open programming languages such as CLOS reify their software components (classes), but the reification is not black-box the reification is quite complex, and it is difficult to create drastically different components because of the intricate cooperation between all parts of the reified class.
Reference: [17] <author> Albert Schappert, Peter Sommerlad and Wolfgang Pree, </author> <title> Automated Support for Software Development with Frameworks, </title> <booktitle> Proceedings SSR95 ACM SIGSOFT Symposium on Software Reusability, </booktitle> <year> 1995. </year>
Reference-contexts: Code can be generated, but this is not the main goal of these tools. Closer to our work is work is work described by Soukop [19] and Sommerlad, et.al. <ref> [17] </ref>, which supports application developers. Basically these tools provide quite extensive code generation.
Reference: [18] <author> Randall B. Smith and David Ungar, </author> <title> Programming as an Experience: The Inspiration for Self, </title> <booktitle> Proceedings ECOOP95, </booktitle> <editor> W. Olthoff (Ed.), </editor> <publisher> LNCS 952, Springer-Verlag, </publisher> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995, </year> <pages> pp. 303-330. </pages>
Reference: [19] <author> Jiri Soukop, </author> <title> Implementing Patterns, Pattern Languages of Program Design, </title> <note> Addison Wesley 1995, Chapter 20. </note>
Reference-contexts: Visual support should further help the developer in creating the right kinds of components, and creating the right kinds of relationships between them. Currently, FACE uses the Kansas-Self <ref> [19] </ref> visual presentation to support visual modeling see figure 8. This means that (as mentioned in section 8) all components in a schema are represented as objects, and relationships as links between objects in Kansas. Kansas provides direct presentation and editing of these objects. <p> These kinds of tools focus on helping the framework designer: patterns are mainly used to support the design of the framework architecture. Code can be generated, but this is not the main goal of these tools. Closer to our work is work is work described by Soukop <ref> [19] </ref> and Sommerlad, et.al. [17], which supports application developers. Basically these tools provide quite extensive code generation. <p> This still needs to be proven. Future work will be in two directions: Using FACE for re-engineering purposes <ref> [19] </ref>: discovering patterns, anti-patterns, the relationships between classes etc. and representing this in FACE sche-mas; afterwards, improve system design by applying restructuring transforma tions based on design patterns. Applying FACE to real world frameworks. Interesting questions will be, how complex meta-schemas will become. <p> Applying FACE to real world frameworks. Interesting questions will be, how complex meta-schemas will become. We want to investigate whether we can uncouple patterns (similar as described by Soukop <ref> [19] </ref>) so that the reuse and merging of patterns will be easy. Acknowledgements We thank Dirk Riehle for his first reviews; Tamar Richner, Robb Nebbe, Oscar Nierstrasz and many others for their helpful comments and corrections.
Reference: [20] <author> Patrick Steyaert, K. De Hondt, S. Demeyer, N. Boyen and M. de Molder, </author> <title> Reflective User Interface Builders, </title> <booktitle> Proceedings Meta95, </booktitle> <editor> C. Zimmerman (Ed.), </editor> <year> 1995. </year>
Reference-contexts: Their model also allows one to introduce new kinds of relationships. They focus on adaptive data models for databases systems, less on frameworks and application development. We feel that our model is simpler and therefore easier to understand and use. Steyaert et. al. <ref> [20] </ref> have described how the use of a meta-level interface could be applied to provide powerful configuration capabilities for user interface builders. Also, using reflection, new kinds of components could be described using the composition environment itself.
References-found: 20

