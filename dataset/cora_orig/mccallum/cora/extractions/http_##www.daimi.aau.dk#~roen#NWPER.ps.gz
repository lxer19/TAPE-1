URL: http://www.daimi.aau.dk/~roen/NWPER.ps.gz
Refering-URL: http://www.daimi.aau.dk/~roen/
Root-URL: http://www.daimi.aau.dk
Email: hr@systematic.dk  schade@post7.tele.dk  
Title: Midgard A Dynamic Programming Environment Supporting Exploratory Programming Based on Extensibility  
Author: Henrik Ron and Rene Schade 
Address: Denmark,  Denmark,  
Affiliation: Abyhoj,  
Note: 1 Systematic Software Engineering A/S, Soren Frichs Vej 38K, DK-8230  2 Tele Danmark Internet A/S, Oluf Palmes Alle 36, DK-8200 Aarhus N,  
Abstract: Midgard is a design and prototype of an incremental program development environment, where part of the development of a program is carried out in the context of an execution of the program itself. Midgard is based on dynamic extensibility supported by a dynamic compiler and an incremental linker. The goal of Midgard is to provide better support for exploratory programming by enabling the developer to experiment with different designs and solutions while maintaining a low turn-around time during most of the development. A prototype implementation for the block structured statically checked object-oriented programming language BETA is presented and the underlying techniques for compilation and linking are described. The prototype has the traditional benefits of static checking and gains some of the flexibility associated with exploratory programming environments. Furthermore the techniques used for dynamic compilation and incremental linking are relatively simple compared to other systems supporting exploratory programming for statically checked object-oriented languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Adams, W. Tichy, and A. Weinert. </author> <title> The cost of selective recompilation and environment processing. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <year> 1994. </year>
Reference-contexts: By choosing simpler techniques we sacrifice full generality for an easily implementable and maintainable environment. Our desire for simplicity also swayed us away from using state-of-the-art techniques for, e.g., incremental execution [12] or fine-grained recompilation <ref> [1, 4] </ref>. We present Midgard 5 , a design for an EP based environment. EP in Midgard is based on a mixture of a traditional and an incremental programming environment, where part of the development is done during run-time by extending the source code of executing program.
Reference: [2] <author> O. Agesen and D. Ungar. </author> <title> Sifting out the gold delivering compact applications from an exploratory object-oriented programming environment. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'94), </booktitle> <pages> pages 355-370. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Self has all the characteristics of an environment suited for exploratory programming, but has two major disadvantages (a) it is dynamically checked and (b) it is a monolithic environment, where it is non-trivial to extract applications <ref> [2] </ref>. The monolithic environment also prevents extensibility of stand-alone programs. Midgard doesn't have these disadvantages, but it lacks the uniformity, direct manipulation, and object outliner that Self has. This could be a future research direction for Midgard.
Reference: [3] <author> P. J. Brown. </author> <title> Dynamic program building. </title> <journal> Software Practice and Experience, </journal> <volume> 11(8) </volume> <pages> 831-843, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: We have named the parts, whose specification is deferred until run-time, extension points. Extension points are analogous to "loose ends" as described in <ref> [3] </ref>. Our idea for the working cycle in Midgard is that the developer programs enough of the program in a traditional environment for him/her to have a context for the dynamic development and inserts extension points for later development.
Reference: [4] <author> C. Chambers, J. Dean, and D. Grove. </author> <title> A framework for selective recompilation in the presence of complex intermodule dependencies. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 221-230, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: By choosing simpler techniques we sacrifice full generality for an easily implementable and maintainable environment. Our desire for simplicity also swayed us away from using state-of-the-art techniques for, e.g., incremental execution [12] or fine-grained recompilation <ref> [1, 4] </ref>. We present Midgard 5 , a design for an EP based environment. EP in Midgard is based on a mixture of a traditional and an incremental programming environment, where part of the development is done during run-time by extending the source code of executing program.
Reference: [5] <author> O.-J. Dahl, B. Myhrhaug, and K. Nygaard. </author> <title> Simula 67 common base language. </title> <type> Technical report, </type> <institution> Norwegian Computing Center, </institution> <year> 1968. </year>
Reference-contexts: 1 Introduction Traditionally one can divide program development environments into two schools. One school is the statically checked 1 school, e.g., environments for Simula <ref> [5] </ref>, BETA [19], C ++ [33], and Eiffel [23]. The work cycle is "edit, compile, link, execute", as depicted in Fig. 1 (a), and has a high turn-around time because of the compilation (static analysis and checking) and linking phases, which are time consuming, especially the latter.
Reference: [6] <author> P. Fritzon. </author> <title> Prelimenary experiences from the DICE system a distributed incremental environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <year> 1984. </year>
Reference-contexts: There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer [34], environments <ref> [6, 7, 26] </ref> for Pascal [37] and Integral C [28] for C [15]. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21]. <p> The code for &lt;3&gt; would be the bottom element in stack, because it was the first extension point reached during execution, the next would be &lt;5&gt; and so on. 5 Related Work DICE In <ref> [6, 7] </ref> the DICE environment is described, which is an incremental environment for Pascal which has many of the same goals as Midgard.
Reference: [7] <author> P. Fritzon. </author> <title> Systems and tools for exploratory programming overview and examples. </title> <type> Technical Report LITH-IDA-R-86-36, </type> <institution> Department of Computer and Information Science, Linkoping University, </institution> <year> 1986. </year>
Reference-contexts: There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer [34], environments <ref> [6, 7, 26] </ref> for Pascal [37] and Integral C [28] for C [15]. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21]. <p> The code for &lt;3&gt; would be the bottom element in stack, because it was the first extension point reached during execution, the next would be &lt;5&gt; and so on. 5 Related Work DICE In <ref> [6, 7] </ref> the DICE environment is described, which is an incremental environment for Pascal which has many of the same goals as Midgard.
Reference: [8] <author> A. Goldberg. </author> <title> Smalltalk-80 The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <year> 1984. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued [17] to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self [32, 36], Smalltalk <ref> [8, 9] </ref>, and Lisp [29, 35]. <p> It is possible to browse the object graph of the executing program from several starting points and alter the state of the object graph using dynamic compilation, much like the "do-it" functionality of Smalltalk's workspace, inspector or debugger <ref> [8] </ref> or the evaluator in the object outliner in the Self programming environment [31].
Reference: [9] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued [17] to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self [32, 36], Smalltalk <ref> [8, 9] </ref>, and Lisp [29, 35].
Reference: [10] <author> S. Graham. </author> <title> Language and interactive software development. </title> <booktitle> In Programming Languages and System Architectures, volume 782 of LNCS, </booktitle> <pages> pages 21-34, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Another reason is that the effort and expense of constructing interactive systems is great thus deterring developers <ref> [10] </ref>, even more so for statically checked OO languages because of the increased complexity as mentioned above.
Reference: [11] <author> G. Hedin. </author> <title> Incremental Semantic Analysis. </title> <type> PhD thesis, </type> <institution> Lund University, </institution> <year> 1992. </year>
Reference-contexts: for procedural languages because of 3 We use the term developer covering analyst, designer, and programmer. 4 In our terminology "incremental" means that the amount of work needed after a change is proportional to the size of the effect of the change. the combination of subclassing and block-structure visibility rules <ref> [11] </ref>. Another reason is that the effort and expense of constructing interactive systems is great thus deterring developers [10], even more so for statically checked OO languages because of the increased complexity as mentioned above. <p> Another reason is that the effort and expense of constructing interactive systems is great thus deterring developers [10], even more so for statically checked OO languages because of the increased complexity as mentioned above. An example of this problem is Orm, as the techniques <ref> [11, 12] </ref> used to provide incrementality, are complex and require a large amount of resources to implement compared to what we call traditional (non-incremental) environments, e.g., Microsoft's Visual C ++ or Emacs with the GNU C ++ compiler. <p> The early detection of errors was the reason why the designers of Orm re-garded it as essential to provide support for statically checked languages. Another goal was support of the EP style, i.e., the provision of low turn-around time by using incremental compilation techniques <ref> [11] </ref> and the possibility to execute incomplete programs. Orm supports a more general form of incrementality than the one we have implemented. The arguments against Orm is the very complex techniques one has to employ in order to get such an environment.
Reference: [12] <author> G. Hedin and B. Magnusson. </author> <title> Supporting Exploratory Programming, chapter 27. </title> <editor> In Knudsen et al. </editor> <volume> [16], </volume> <year> 1993. </year>
Reference-contexts: Another reason is that the effort and expense of constructing interactive systems is great thus deterring developers [10], even more so for statically checked OO languages because of the increased complexity as mentioned above. An example of this problem is Orm, as the techniques <ref> [11, 12] </ref> used to provide incrementality, are complex and require a large amount of resources to implement compared to what we call traditional (non-incremental) environments, e.g., Microsoft's Visual C ++ or Emacs with the GNU C ++ compiler. <p> By choosing simpler techniques we sacrifice full generality for an easily implementable and maintainable environment. Our desire for simplicity also swayed us away from using state-of-the-art techniques for, e.g., incremental execution <ref> [12] </ref> or fine-grained recompilation [1, 4]. We present Midgard 5 , a design for an EP based environment.
Reference: [13] <author> U. Holzle and D. Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the Conference on Programming Language Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: The drawbacks of such environments is the late detection of type errors and the inefficiency of the generated code. Self is a notable exception as it is almost as efficient as the statically checked languages <ref> [13, 14] </ref>. Edit Execute Link Compile (a) Statically checked Edit Execute (b) Dynamically checked The dynamic environments are often associated with a programming methodology called exploratory programming (EP) [30]. The idea is that it is easy for the developer 3 to experiment by implementing his/her design thus getting feedback quickly. <p> Midgard doesn't have these disadvantages, but it lacks the uniformity, direct manipulation, and object outliner that Self has. This could be a future research direction for Midgard. Efficiency isn't an issue as Self almost has reached the level of statically checked languages <ref> [13, 14] </ref>, but the techniques necessary to reach this efficiency require large resources to implement; resource on a scale comparable to Orm. Extensibility in Tailorable Applications In [22] Malhotra presents several applications of an interpreter for BETA used to extend the functionality of a running program.
Reference: [14] <author> U. Holzle and D. Ungar. </author> <title> Reconciling responsiveness with performance in pure object-oriented languages. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'94), </booktitle> <pages> pages 229-243. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: The drawbacks of such environments is the late detection of type errors and the inefficiency of the generated code. Self is a notable exception as it is almost as efficient as the statically checked languages <ref> [13, 14] </ref>. Edit Execute Link Compile (a) Statically checked Edit Execute (b) Dynamically checked The dynamic environments are often associated with a programming methodology called exploratory programming (EP) [30]. The idea is that it is easy for the developer 3 to experiment by implementing his/her design thus getting feedback quickly. <p> Midgard doesn't have these disadvantages, but it lacks the uniformity, direct manipulation, and object outliner that Self has. This could be a future research direction for Midgard. Efficiency isn't an issue as Self almost has reached the level of statically checked languages <ref> [13, 14] </ref>, but the techniques necessary to reach this efficiency require large resources to implement; resource on a scale comparable to Orm. Extensibility in Tailorable Applications In [22] Malhotra presents several applications of an interpreter for BETA used to extend the functionality of a running program.
Reference: [15] <author> B. Kernighan and D. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> 2. edition, </address> <year> 1988. </year>
Reference-contexts: There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer [34], environments [6, 7, 26] for Pascal [37] and Integral C [28] for C <ref> [15] </ref>. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21].
Reference: [16] <author> J. L. Knudsen, M. Lofgren, O. L. Madsen, and B. Magnusson. </author> <title> Object-Oriented Environments: The Mjolner Approach. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: The MPS, and thereby most of the tools in the MBS, is description-driven, i.e., instantiated for a particular language by specifying a metagrammar for the language. In the MBS ASTs are currently stored on disk in files. The reader is referred to <ref> [16] </ref> for further details on the MBS. Most of Midgards user interface is based on Sif the hybrid text/structure editor, which we expanded with functionality for manipulation of extension points and inlining of code. As mentioned above the extension code has to be an object descriptor.
Reference: [17] <author> O. L. Madsen. </author> <title> Open issues in object-oriented programming | A Scandinavian perspective. </title> <journal> Software Proactice and Experience, </journal> <volume> 25:S4/3-S4/43, </volume> <month> December </month> <year> 1995. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued <ref> [17] </ref> to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self [32, 36], Smalltalk [8, 9], and Lisp [29, 35].
Reference: [18] <author> O. L. Madsen. Minidyn. </author> <title> A prototype for a simple dynamic BETA environment. Personal conversation and demonstration, </title> <year> 1996. </year>
Reference-contexts: As mentioned above the extension code has to be an object descriptor. One of the reasons that we chose a structure editor was that it makes it easier to enforce such a restriction. We based our work on a prototype of the dynamic compiler, MiniDyn <ref> [18] </ref>, which had limited support for dynamic compilation and linking. We generalised the compilation techniques, so that any object could serve as context, but our extended compiler can still be used for traditional compilation. Furthermore we ensured that garbage collection would not corrupt the linking process.
Reference: [19] <author> O. L. Madsen, B. Moller-Pedersen, and K. Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Traditionally one can divide program development environments into two schools. One school is the statically checked 1 school, e.g., environments for Simula [5], BETA <ref> [19] </ref>, C ++ [33], and Eiffel [23]. The work cycle is "edit, compile, link, execute", as depicted in Fig. 1 (a), and has a high turn-around time because of the compilation (static analysis and checking) and linking phases, which are time consuming, especially the latter.
Reference: [20] <author> O. L. Madsen and C. Norgaard. </author> <title> An object-oriented metaprogramming system, chapter 19. </title> <editor> In Knudsen et al. </editor> <volume> [16], </volume> <year> 1993. </year>
Reference-contexts: Most of our environment is based on tools already part of the MBS. The tools in the MBS utilise one single representation of the program in the form of ASTs. All manipulation of the ASTs is done through the metaprogramming system (MPS) <ref> [20] </ref>. The MPS, and thereby most of the tools in the MBS, is description-driven, i.e., instantiated for a particular language by specifying a metagrammar for the language. In the MBS ASTs are currently stored on disk in files. The reader is referred to [16] for further details on the MBS.
Reference: [21] <author> B. Magnusson. </author> <title> The Mjolner Orm System, chapter 1. </title> <editor> In Knudsen et al. </editor> <volume> [16], </volume> <year> 1993. </year>
Reference-contexts: Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm <ref> [21] </ref>. <p> The main difference are (a) we based our environment on extensibility, while DICE supports full incremental compilation, (b) our compiler can be used as an embedded compiler thus providing extensibility in stand-alone applications. Orm The Mjolner Orm <ref> [21] </ref> system is designed to be used as both a language and program development environment, with focus on object-oriented languages. Apart from being a regular programming environment Orm has a meta-environment for specifying the grammar for the language in use.
Reference: [22] <author> J. Malhotra. </author> <title> Tailorable Systems: Design, Support, Techniques, and Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: EP in Midgard is based on a mixture of a traditional and an incremental programming environment, where part of the development is done during run-time by extending the source code of executing program. Extending, but not modifying, the source code of a program during execution is called dynamic extensibility <ref> [22] </ref>. We furthermore describe a prototype implementation of Midgard for the statically checked object-oriented language BETA. The work presented is the result of our Master's Thesis done at the Devise Research Group, which is part of the Department of Computer Science at the University of Aarhus. <p> Type conflicts are avoided because the compiler type checks the dynamic code, thus guaranteeing that there are no type errors. The reader is referred to <ref> [22] </ref> for a detailed coverage of technique for extensibility in BETA. 3.2 Using the Midgard Prototype An Example In our example, which is inspired by [29], a program for management of appointments is being developed. <p> Furthermore our dynamic compiler and linker provide extensibility in any stand-alone application. It thus becomes possible to use BETA as a general scripting language using the techniques for structuring and extending programs described in <ref> [22] </ref>. Self Self is a dynamically checked prototype based object-oriented programming language with a visual object-oriented programming environment. In Self, language and environment are designed to support each other optimally, thus obtaining a uniform programming experience [32]. <p> Efficiency isn't an issue as Self almost has reached the level of statically checked languages [13, 14], but the techniques necessary to reach this efficiency require large resources to implement; resource on a scale comparable to Orm. Extensibility in Tailorable Applications In <ref> [22] </ref> Malhotra presents several applications of an interpreter for BETA used to extend the functionality of a running program.
Reference: [23] <author> B. Meyer. </author> <title> Eiffel, The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Traditionally one can divide program development environments into two schools. One school is the statically checked 1 school, e.g., environments for Simula [5], BETA [19], C ++ [33], and Eiffel <ref> [23] </ref>. The work cycle is "edit, compile, link, execute", as depicted in Fig. 1 (a), and has a high turn-around time because of the compilation (static analysis and checking) and linking phases, which are time consuming, especially the latter.
Reference: [24] <institution> Mjolner Informatics Report. Frigg User Interface Builder, </institution> <year> 1996. </year> <month> MIA 96-33. </month>
Reference-contexts: Furthermore we ensured that garbage collection would not corrupt the linking process. We have experimented with different interfaces and the work in Midgard was the foundation for a framework for dynamic compilation and incremental linking used in Midgard, MiniDyn and an experimental dynamically extensible version of Frigg <ref> [24] </ref>, the interfacebuilder in the MBS. At startup the incremental linker scans the executable for entry points and stores these in a hash-table.
Reference: [25] <editor> Mjolner Informatics Report. Sif - Mjolner BETA Source Browser and Editor, </editor> <year> 1996. </year> <month> MIA 90-11. </month>
Reference-contexts: The tools in Midgard are illustrated in Fig. 4, which is a snapshot of Midgard in the dynamic programming phase. Three dots (: : :) signify code that has been abstracted using the outline capabilities of Sif <ref> [25] </ref>, the hybrid structure/text editor in the Mjolner BETA system (MBS). Due to the current implementation of Midgard the developer writes his/her program as a specialisation of a virtual class (the pattern 6 userProgram).
Reference: [26] <author> B. Nordstrom and . Wikstrom. </author> <title> The design of an interactive program development system for Pascal. </title> <journal> Software Practice and Experience, </journal> <volume> 14(2) </volume> <pages> 177-190, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: The idea is that it is easy for the developer 3 to experiment by implementing his/her design thus getting feedback quickly. But critics of EP name this strong feature as a reason for EP leading to unstructured programs. The need for structure is also recognised by advocates of EP <ref> [26, 29, 30] </ref>. An ideal programming environment would have both the advantages of static checking and type declarations, i.e., efficiency, safety, improved readability and better structure, while harnessing the power of environments suited for EP. <p> There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer [34], environments <ref> [6, 7, 26] </ref> for Pascal [37] and Integral C [28] for C [15]. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21].
Reference: [27] <author> H. Ron and R. </author> <month> Schade. </month> <institution> Midgard En dynamisk programmeringsomgivelse baseret pa ekstensibilitet. </institution> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <year> 1997. </year> <note> (In Danish). </note>
Reference-contexts: It is our goal that the principles in Midgard should be applicable for a wide variety of languages, not only object-oriented ones. For a more detailed description of the general design of Midgard the reader is referred to <ref> [27] </ref>. 2.1 Program Development in Midgard The main principle behind Midgard is that part of the development of a program is done in the context of an execution of the program itself, i.e., Midgard is partly a dynamic programming environment. <p> When the developer feels that the extension code has reached a maturity where it can be considered final, he/she can inline the code, thus replacing the extension point with the extension code. In our prototype we have three different ways of inlining the code. The reader is referred to <ref> [27] </ref> for details as this is very BETA specific.
Reference: [28] <author> G. Ross. </author> <title> Integral C A practical environment for C programming. </title> <booktitle> In Proceedings of the Symposium on Practical Software Development Environments, </booktitle> <pages> pages 42-48. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer [34], environments [6, 7, 26] for Pascal [37] and Integral C <ref> [28] </ref> for C [15]. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21].
Reference: [29] <author> E. Sandewall. </author> <title> Programming in an interactive environment. </title> <journal> ACM Computing Surveys, </journal> <volume> 10(2) </volume> <pages> 35-71, </pages> <year> 1978. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued [17] to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self [32, 36], Smalltalk [8, 9], and Lisp <ref> [29, 35] </ref>. <p> The idea is that it is easy for the developer 3 to experiment by implementing his/her design thus getting feedback quickly. But critics of EP name this strong feature as a reason for EP leading to unstructured programs. The need for structure is also recognised by advocates of EP <ref> [26, 29, 30] </ref>. An ideal programming environment would have both the advantages of static checking and type declarations, i.e., efficiency, safety, improved readability and better structure, while harnessing the power of environments suited for EP. <p> The reader is referred to [22] for a detailed coverage of technique for extensibility in BETA. 3.2 Using the Midgard Prototype An Example In our example, which is inspired by <ref> [29] </ref>, a program for management of appointments is being developed. The tools in Midgard are illustrated in Fig. 4, which is a snapshot of Midgard in the dynamic programming phase.
Reference: [30] <author> B. Sheil. </author> <title> Power tools for programmers. </title> <journal> Datamation, </journal> <volume> 29(2) </volume> <pages> 131-144, </pages> <month> February </month> <year> 1983. </year>
Reference-contexts: Self is a notable exception as it is almost as efficient as the statically checked languages [13, 14]. Edit Execute Link Compile (a) Statically checked Edit Execute (b) Dynamically checked The dynamic environments are often associated with a programming methodology called exploratory programming (EP) <ref> [30] </ref>. The idea is that it is easy for the developer 3 to experiment by implementing his/her design thus getting feedback quickly. But critics of EP name this strong feature as a reason for EP leading to unstructured programs. <p> The idea is that it is easy for the developer 3 to experiment by implementing his/her design thus getting feedback quickly. But critics of EP name this strong feature as a reason for EP leading to unstructured programs. The need for structure is also recognised by advocates of EP <ref> [26, 29, 30] </ref>. An ideal programming environment would have both the advantages of static checking and type declarations, i.e., efficiency, safety, improved readability and better structure, while harnessing the power of environments suited for EP.
Reference: [31] <author> R. B. Smith, J. Maloney, and D. Ungar. </author> <title> The Self-4.0 user interface: Manifesting a system-wide vision of concreteness, uniformity and flexibility. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'95), </booktitle> <pages> pages 47-60. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1995. </year>
Reference-contexts: is possible to browse the object graph of the executing program from several starting points and alter the state of the object graph using dynamic compilation, much like the "do-it" functionality of Smalltalk's workspace, inspector or debugger [8] or the evaluator in the object outliner in the Self programming environment <ref> [31] </ref>.
Reference: [32] <author> R. B. Smith and D. Ungar. </author> <title> Programming as an experience: The inspiration for Self. </title> <booktitle> In Proceedings of the 9th European Conference on Object-Oriented Programming (ECOOP'95), volume 952 of Lecture Notes in Computer Science, </booktitle> <pages> pages 303-330. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued [17] to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self <ref> [32, 36] </ref>, Smalltalk [8, 9], and Lisp [29, 35]. <p> Self Self is a dynamically checked prototype based object-oriented programming language with a visual object-oriented programming environment. In Self, language and environment are designed to support each other optimally, thus obtaining a uniform programming experience <ref> [32] </ref>. The leitmotif of the Self programming environment is to create a feeling of directly working with concrete physical objects.
Reference: [33] <author> B. Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> 2. edition, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Traditionally one can divide program development environments into two schools. One school is the statically checked 1 school, e.g., environments for Simula [5], BETA [19], C ++ <ref> [33] </ref>, and Eiffel [23]. The work cycle is "edit, compile, link, execute", as depicted in Fig. 1 (a), and has a high turn-around time because of the compilation (static analysis and checking) and linking phases, which are time consuming, especially the latter.
Reference: [34] <author> T. Teitelbaum and T. W. Reps. </author> <title> The Cornell program synthesizer: A syntax-directed programming environment. </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 563-573, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer <ref> [34] </ref>, environments [6, 7, 26] for Pascal [37] and Integral C [28] for C [15]. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21].
Reference: [35] <author> W. Teitelman and L. Masinter. </author> <title> The Interlisp programming environment. </title> <journal> IEEE Computer, </journal> <volume> 14(4) </volume> <pages> 25-33, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued [17] to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self [32, 36], Smalltalk [8, 9], and Lisp <ref> [29, 35] </ref>.
Reference: [36] <author> D. Ungar and R. B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'87), </booktitle> <pages> pages 227-242. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1987. </year>
Reference-contexts: The advantages of the static checking are early error detection and efficient code. Furthermore programs with types are often argued [17] to be better structured and more readable. The other school is the dynamically checked 2 environments for, e.g., Self <ref> [32, 36] </ref>, Smalltalk [8, 9], and Lisp [29, 35].
Reference: [37] <author> N. Wirth. </author> <title> The programming language Pascal. </title> <journal> Acta Informatica, </journal> <pages> pages 35-63, </pages> <year> 1971. </year>
Reference-contexts: There have been many research project aimed at providing such environments for statically checked languages, e.g. the Cornell Program Synthesizer [34], environments [6, 7, 26] for Pascal <ref> [37] </ref> and Integral C [28] for C [15]. Despite the multitude of environments for statically checked languages there, to our knowledge, only exists one incremental 4 environment for a statically checked object-oriented language (Simula), namely Orm [21].
References-found: 37

