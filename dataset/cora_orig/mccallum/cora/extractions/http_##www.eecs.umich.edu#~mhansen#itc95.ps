URL: http://www.eecs.umich.edu/~mhansen/itc95.ps
Refering-URL: http://www.eecs.umich.edu/~mhansen/
Root-URL: http://www.cs.umich.edu
Title: High-Level Test Generation Using Symbolic Scheduling  Design Automation Operations Integrated Circuit Design Center  
Author: Mark C. Hansen Delco J. P. Hayes John P. Hayes* 
Web: MIP-9200526.  
Address: Kokomo, Indiana 46904  Ann Arbor, MI 48109  
Affiliation: Electronics Corporation  Advanced Computer Architecture Laboratory Dept. of Electrical Engineering and Computer Science The University of Michigan  
Date: September 1, 1995 1  
Note: ITC 95 Paper, Hansen Hayes,  was supported by the National Science Foundation under Grant No.  
Abstract: A high-level test generation algorithm SWIFT is proposed which incorporates a symbolic scheduling procedure, derived from high-level synthesis applications, to resolve decision conicts during test generation. SWIFT uses the induced fault model to generate functional tests that guarantee detection of low-level structural faults. When applied to functional models of representative 74X-series, ISCAS-85 and ISCAS-89 circuits, SWIFT produces test sequences that cover all gate-level stuck-at faults. Surprisingly, although they are derived from a high-level functional description of the circuit under test, most of these test sequences are of provably minimal or near-minimal size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abramovici, M. A. Breuer and A. D. Friedman, </author> <title> Digital Systems Testing and Testable Design, </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction The goal of high-level test generation is to abstract low-level information about a circuit into a functional or high-level form, thus reducing the effort needed to generate tests. Classical ATPG testing methods model circuits at the gate level <ref> [1] </ref>, but due to the ever-increasing size of integrated circuits (ICs), these low-level methods are increasingly impractical. By modeling circuits at a higher level, the number of primitive elements is reduced, which allows larger circuits to be tested. <p> In this paper, we discuss and propose solutions for the following three issues. Accurate fault modeling: The ultimate goal of a fault model is to effectively represent realistic physical faults in the circuit under test. The classical gate-level fault model is the single-stuck-line (SSL) or stuck-at fault model <ref> [1] </ref>, and it provides good coverage of the many IC fault types. Functional test generation methods [2,3,4] usually employ their own, unique functional fault models. In general though, coverage of these functional faults does not guarantee complete coverage of the underlying SSL faults. <p> If a logical conict occurs when propagating an error on an n-bit wide bus, is the proper solution to try one of the 2 n 1 other values on the bus, or to choose an alternative propagation path? Classical ATPG algorithms use branch-and-bound search with chronological backtracking <ref> [1] </ref>, and easily get bogged down with this problem. A promising alternative is dependency-directed backtracking [6,7,8]. We present an entirely new and more efficient approach using scheduling algorithms developed for logic synthesis [9] to resolve value and operation conicts during test generation. <p> Module selection: Gate-level ATPG is characterized by combinational primitive elements which are simple logic gates (ANDs, ORs, NOTs, etc.) and two-state storage elements (latches and ip-ops). Sequential behavior is handled by considering single time steps (clock cycles) using, for instance, the iterative logic array model <ref> [1] </ref>. The higher level of interest here is characterized by functional (register-level) primitives such as adders, multiplexers, counters, controllers, etc. As at the gate level, these higher-level primitives must be fully characterized for their fault types, and their fault transmission properties. <p> Using this modular approach, exible libraries of modules with their individual SIF lists and tests can easily be created. Fault propagation: At the gate level, controlling and non-controlling values <ref> [1] </ref> are defined for each primitive module except XOR/XNOR. In general, to propagate a fault through a gate-level primitive, all other inputs must be set to their non-controlling values (XORs/XNORs and multiple fault propagation are again exceptions). <p> A prototype implementation has given excellent results on the benchmark circuits discussed here and in the next section. Most high-level methods developed to date use branch-and-bound algorithms to backtrack when decision con-icts occur. Algorithms of this type are widely used (e.g. by PODEM <ref> [1] </ref>) and are well suited for low-level testing, but they do not take full advantage of the functional information available at the high level. <p> It uses well-known intermediate operations; and (b) module tests. Comparatortest = RSLSP 14 Countertest = RSLSP-RSLSIP 2 -RSILSP 8 -SRILSP Latchtest = RSLSP 2 (b) RSLSP = Reset-Scan-Load-Scan-Propagate RSLSIP = Reset-Scan-Load-Scan-Increment-Propagate RSILSP = Reset-Scan-Increment-Load-Scan-Propagate SRILSP = Scan-Reset-Increment-Load-Scan-Propagate (a) procedures of the justify-and-propagate type <ref> [1] </ref>, and its new features are symbolic values, multiple-time-step functional operators, and an explicit scheduling routine. Most high-level sequential ATPG algorithms are direct extensions of combinational algorithms applied to an iterative logic array model of the circuit under test.
Reference: [2] <author> S. M. Thatte and J. A. Abraham, </author> <title> Test generation for microprocessors, </title> <journal> IEEE TC, </journal> <volume> Vol. C-29, </volume> <month> June </month> <year> 1980, </year> <pages> pp. 429-441. </pages>
Reference: [3] <author> Y. H. Levendel and P. R. Menon, </author> <title> Test generation algorithms for computer hardware description languages, </title> <journal> IEEE TC, </journal> <volume> Vol. C-31, </volume> <month> July </month> <year> 1982, </year> <pages> pp. 577-588. </pages>
Reference: [4] <author> T. Lin and S. Y. H. Su, </author> <title> The S-Algorithm: A promising solution for systematic functional test generation, </title> <journal> IEEE TCAD, </journal> <volume> Vol. CAD-4, </volume> <month> July </month> <year> 1985, </year> <pages> pp. 250-263. </pages>
Reference: [5] <author> M. C. Hansen and J. P. Hayes, </author> <title> High-level test generation using physically-induced faults, </title> <booktitle> Proc. VLSI Test Symp., </booktitle> <year> 1995, </year> <pages> pp 20-28. </pages>
Reference-contexts: Functional test generation methods [2,3,4] usually employ their own, unique functional fault models. In general though, coverage of these functional faults does not guarantee complete coverage of the underlying SSL faults. In our prior work <ref> [5] </ref>, we addressed this problem by develop ing a functional fault model, the physically-induced fault model, that ensures coverage of low-level faults of interest. <p> At the high level, this classification scheme does not restrict the connections inside the primitive elements, so a module can be combinational or sequential. Fault representation: As described in <ref> [5] </ref>, functional faults can be classified into three main categories: the general, pin, and induced fault models. Induced faults (IFs) are the category of interest in this paper. <p> The ITC 95 Paper, Hansen & Hayes, September 1, 1995 9 74X-series and ISCAS-85 circuits were first functionally modeled for testing purposes in <ref> [5] </ref>. We have also reverse-engineered six ISCAS-89 circuits [12] and present some of their functional models and test results here. Two representative ISCAS circuits, c880 and s349 are examined in greater depth. The c880 circuit is an 8-bit ALU with the high-level structure shown in Figure 15 [5]. <p> testing purposes in <ref> [5] </ref>. We have also reverse-engineered six ISCAS-89 circuits [12] and present some of their functional models and test results here. Two representative ISCAS circuits, c880 and s349 are examined in greater depth. The c880 circuit is an 8-bit ALU with the high-level structure shown in Figure 15 [5]. Since this circuit is combinational, each test requires only one time step to apply. An additional feature of SWIFT is that test set compaction is inherently a part of the test generation process, not a post-process refinement. <p> Likewise, the known tests for M6 are used to propagate the errors. With this implicit compaction process, SWIFT finds a test set of size 17, which is the best known, and provably minimal <ref> [5] </ref>. Since c880 is a combinational module, the scheduling procedure (step m5 in Figure 9) is not used. Using SWIFTs modular approach, the efficiency of finding tests at the functional level is much greater than at the gate-level. <p> For the combinational circuits, the sizes of the SIF tests are compared to those produced by COMPACTEST, a well-known and fast gate-level test generator [10], and to the previous smallest-known test set sizes [11]. We also include sizes of the best-known independent functional fault sets from <ref> [5] </ref> that were also derived in this work. For the sequential circuits, our results are compared to the shortest known test sequences without scan [13] and those using full scan [11]. <p> SIF sequential test set size (clock cycles) using SWIFT Number of test patterns Number of clock cycles s208.1 27 251 207 s344 15 255 45 best known to date Circuit Size of test set from COMPAC-TEST [10] Previous smallest test set size [11] Lower bound from independent functional fault set <ref> [5] </ref> SIF test set size using SWIFT 74182 12 10 10 7485 23 23 23 c432 47 29 27 32 c880 30 21 17 17 c6288 16 14 11 12 best known to date; minimum possible testing results giving 100% SSL fault coverage.
Reference: [6] <author> J. Lee and J. H. Patel, </author> <title> A signal-driven discrete relaxation technique for architectural level test generation, </title> <booktitle> Proc. </booktitle> <address> ICCAD, </address> <year> 1991, </year> <pages> pp. 458-461. </pages>
Reference-contexts: Search-space management: A second problem is the extremely large search space confronting the test generator. Although it is usually easier to justify and propagate signals at the high, functional level <ref> [6] </ref>, how to proceed when value conicts occur is not clear. Consider for example, conict resolution during test generation for a datap-ath circuit. <p> Another technique with the potential to substantially reduce test generation effort is the use of symbolic signal values and operations. Test generation using symbolic values has been considered for low-level [14], hierarchical [15,16] and high-level <ref> [6] </ref> circuits, but so far has not been used with true high-level ATPG algorithms. Typical is the functional solution language introduced by Breuer and Friedman [17] which employs primitive operations like count, shift, clock and hold, and symbolically manipulates them to generate tests.
Reference: [7] <author> R. P. Kunda, P. Harain, J. A. Abraham and B. D. Rathi, </author> <title> Speed up of test generation using high-level primitives, </title> <booktitle> Proc. DAC, </booktitle> <year> 1990, </year> <pages> pp. 594-599. </pages>
Reference: [8] <author> J. P. M. Silva and K. A. Sakallah, </author> <title> Dynamic search-space pruning techniques in path sensitization, </title> <booktitle> Proc. DAC, </booktitle> <year> 1994, </year> <pages> pp. 705-711. </pages>
Reference: [9] <author> D. Gajski, N. Dutt, A. Wu and S. Lin, </author> <title> High-Level Synthesis, Introduction to Chip and System Design, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: A promising alternative is dependency-directed backtracking [6,7,8]. We present an entirely new and more efficient approach using scheduling algorithms developed for logic synthesis <ref> [9] </ref> to resolve value and operation conicts during test generation. Test set compaction: A gate-level ATPG method like COMPACTEST [10] is able to find complete and near-minimal test sets for large combinational circuits. <p> Often a revised ordering of operations on the same propagation path in a circuit resolves a conict, as opposed to just trying the next propagation path in the decision tree. Our approach adapts the scheduling algorithms used for high-level-synthesis <ref> [9] </ref> to resolve the decision steps during test generation. We know of no other attempts to apply such scheduling algorithms to the test generation problem. <p> Then, using constraint information about each operation, a scheduling algorithm is called to determine if a valid solution can be reached, and to analyze any conicts that occur otherwise. The algorithms we use come from the area of high-level synthesis <ref> [9] </ref>. The scheduling procedure is called with a structured list of operations that are to be performed on the circuit. The list can be depicted by what we call a sequence graph S; see Figure 12a. <p> Likewise, the Modifies constraint graph shows which operations modify the counter, the source of the previous conict. Two well-known scheduling methods are the ASAP (as soon as possible) and ALAP (as late as possible) algorithms <ref> [9] </ref>. ASAP and ALAP assign a label E i to each node v i giving the earliest and latest time steps that an operation o i can be scheduled. If these algorithms are applied to the nodes of the S graph of Figure 12a, Figure 12b results.
Reference: [10] <author> I. Pomeranz, L. N. Reddy and S. M. Reddy, COMPACT-EST: </author> <title> A method to generate compact test sets for combinational circuits, </title> <booktitle> Proc. </booktitle> <address> ITC, </address> <year> 1991, </year> <pages> pp. 194-203. </pages>
Reference-contexts: A promising alternative is dependency-directed backtracking [6,7,8]. We present an entirely new and more efficient approach using scheduling algorithms developed for logic synthesis [9] to resolve value and operation conicts during test generation. Test set compaction: A gate-level ATPG method like COMPACTEST <ref> [10] </ref> is able to find complete and near-minimal test sets for large combinational circuits. Sequential circuits are handled by COMPACTEST (and many other combinational methods) by adding a full scan chain [11]. <p> Additional test results obtained by SWIFT are summarized in Figure 17. In every case, complete gate-level SSL fault detection of detectable faults is achieved. For the combinational circuits, the sizes of the SIF tests are compared to those produced by COMPACTEST, a well-known and fast gate-level test generator <ref> [10] </ref>, and to the previous smallest-known test set sizes [11]. We also include sizes of the best-known independent functional fault sets from [5] that were also derived in this work. <p> set size using no scan [13] Previous smallest test set size using scan [11] SIF sequential test set size (clock cycles) using SWIFT Number of test patterns Number of clock cycles s208.1 27 251 207 s344 15 255 45 best known to date Circuit Size of test set from COMPAC-TEST <ref> [10] </ref> Previous smallest test set size [11] Lower bound from independent functional fault set [5] SIF test set size using SWIFT 74182 12 10 10 7485 23 23 23 c432 47 29 27 32 c880 30 21 17 17 c6288 16 14 11 12 best known to date; minimum possible testing
Reference: [11] <author> S. Kajihara, I. Pomeranz, K. Kinoshita and S. M. Reddy, </author> <title> On compacting test sets by addition and removal of test vectors, </title> <booktitle> Proc. VLSI Test Symp., </booktitle> <year> 1994, </year> <pages> pp. 202-207. </pages>
Reference-contexts: Test set compaction: A gate-level ATPG method like COMPACTEST [10] is able to find complete and near-minimal test sets for large combinational circuits. Sequential circuits are handled by COMPACTEST (and many other combinational methods) by adding a full scan chain <ref> [11] </ref>. Although the number of tests found is near-minimal for the combinational logic, the cost of scanning vectors into and out of the sequential circuit can be very high and is often ignored. For example, using the method of Kaji-hara et al. [11], the ISCAS-89 benchmark circuit s349 [12] requires 14 <p> combinational methods) by adding a full scan chain <ref> [11] </ref>. Although the number of tests found is near-minimal for the combinational logic, the cost of scanning vectors into and out of the sequential circuit can be very high and is often ignored. For example, using the method of Kaji-hara et al. [11], the ISCAS-89 benchmark circuit s349 [12] requires 14 tests, but scanning the tests through the circuits 15 ip-ops requires as many as 239 clock cycles. <p> In every case, complete gate-level SSL fault detection of detectable faults is achieved. For the combinational circuits, the sizes of the SIF tests are compared to those produced by COMPACTEST, a well-known and fast gate-level test generator [10], and to the previous smallest-known test set sizes <ref> [11] </ref>. We also include sizes of the best-known independent functional fault sets from [5] that were also derived in this work. For the sequential circuits, our results are compared to the shortest known test sequences without scan [13] and those using full scan [11]. <p> to the previous smallest-known test set sizes <ref> [11] </ref>. We also include sizes of the best-known independent functional fault sets from [5] that were also derived in this work. For the sequential circuits, our results are compared to the shortest known test sequences without scan [13] and those using full scan [11]. The number of clock cycles required to apply the tests in [11] to the full-scan sequential versions is also shown. For s298, s344 and s349, no scan logic was added for SWIFT testing. <p> For the sequential circuits, our results are compared to the shortest known test sequences without scan [13] and those using full scan <ref> [11] </ref>. The number of clock cycles required to apply the tests in [11] to the full-scan sequential versions is also shown. For s298, s344 and s349, no scan logic was added for SWIFT testing. For s208.1, scan logic was added to an 8-bit counter. s208.1 was still tested functionally, for which shifting in the counter became an additional functional operation. <p> Unlike prior work on high-level testing, our approach has been validated using functional models of well-known 74X-series, ISCAS-85 and ISCAS-89 benchmark circuits. Circuit Previous smallest test set size using no scan [13] Previous smallest test set size using scan <ref> [11] </ref> SIF sequential test set size (clock cycles) using SWIFT Number of test patterns Number of clock cycles s208.1 27 251 207 s344 15 255 45 best known to date Circuit Size of test set from COMPAC-TEST [10] Previous smallest test set size [11] Lower bound from independent functional fault set <p> Previous smallest test set size using scan <ref> [11] </ref> SIF sequential test set size (clock cycles) using SWIFT Number of test patterns Number of clock cycles s208.1 27 251 207 s344 15 255 45 best known to date Circuit Size of test set from COMPAC-TEST [10] Previous smallest test set size [11] Lower bound from independent functional fault set [5] SIF test set size using SWIFT 74182 12 10 10 7485 23 23 23 c432 47 29 27 32 c880 30 21 17 17 c6288 16 14 11 12 best known to date; minimum possible testing results giving 100% SSL fault coverage.
Reference: [12] <author> F. Brglez, D. Bryan and K. Kozminski, </author> <title> Combinational profiles of sequential benchmark circuits, </title> <booktitle> Proc. </booktitle> <address> ISCAS, </address> <year> 1989, </year> <pages> pp. 1929-1934. </pages>
Reference-contexts: Although the number of tests found is near-minimal for the combinational logic, the cost of scanning vectors into and out of the sequential circuit can be very high and is often ignored. For example, using the method of Kaji-hara et al. [11], the ISCAS-89 benchmark circuit s349 <ref> [12] </ref> requires 14 tests, but scanning the tests through the circuits 15 ip-ops requires as many as 239 clock cycles. Previously, the smallest known test size for this circuit requires 84 clock cycles using a method that works directly on the low-level sequential circuit without a scan chain [13]. <p> We break new ground with this work by bridging the experimental gap between high-level and gate-level methods. The circuits we functionally test are from the well-known 74X [18], ISCAS-85 [19] and ISCAS-89 <ref> [12] </ref> series. To accomplish this, we first construct functional models of these circuits, complete details of which are found in [20]. As we report in Section 4, most of our test results improve upon the best-known gate-level test set sizes and their lower bounds. <p> The ITC 95 Paper, Hansen & Hayes, September 1, 1995 9 74X-series and ISCAS-85 circuits were first functionally modeled for testing purposes in [5]. We have also reverse-engineered six ISCAS-89 circuits <ref> [12] </ref> and present some of their functional models and test results here. Two representative ISCAS circuits, c880 and s349 are examined in greater depth. The c880 circuit is an 8-bit ALU with the high-level structure shown in Figure 15 [5].
Reference: [13] <author> T. P. Kelsey, K. K. Saluja and S. Y. Lee, </author> <title> An efficient algorithm for sequential circuit test generation, </title> <journal> IEEE TC, </journal> <volume> Vol. 42, </volume> <month> November </month> <year> 1993, </year> <pages> pp. 1361-1371. </pages>
Reference-contexts: Previously, the smallest known test size for this circuit requires 84 clock cycles using a method that works directly on the low-level sequential circuit without a scan chain <ref> [13] </ref>. Using our functional method and no scan chain, a complete test set for s349 requiring 45 clock ITC 95 Paper, Hansen & Hayes, September 1, 1995 2 cycles is found, which is the best result to date. <p> By testing on the unmodified circuit, these redundancies can be agged for potential deletion. For s349, SWIFT finds a complete gate-level SSL test sequence of length 45. The shortest test sequence previously known for this circuit was of length 84 <ref> [13] </ref>. Using a full scan chain, the test size is known to be 14, but this is misleading applying these 14 tests through the 15 ip-ops of s349 requires up to 239 clock cycles. Therefore, our method has found the shortest test sequence known to date. <p> We also include sizes of the best-known independent functional fault sets from [5] that were also derived in this work. For the sequential circuits, our results are compared to the shortest known test sequences without scan <ref> [13] </ref> and those using full scan [11]. The number of clock cycles required to apply the tests in [11] to the full-scan sequential versions is also shown. For s298, s344 and s349, no scan logic was added for SWIFT testing. <p> Unlike prior work on high-level testing, our approach has been validated using functional models of well-known 74X-series, ISCAS-85 and ISCAS-89 benchmark circuits. Circuit Previous smallest test set size using no scan <ref> [13] </ref> Previous smallest test set size using scan [11] SIF sequential test set size (clock cycles) using SWIFT Number of test patterns Number of clock cycles s208.1 27 251 207 s344 15 255 45 best known to date Circuit Size of test set from COMPAC-TEST [10] Previous smallest test set size
Reference: [14] <author> K. Cho and R. E. Bryant, </author> <title> Test pattern generation for sequential MOS circuits by symbolic fault simulation, </title> <booktitle> Proc. DAC, </booktitle> <year> 1989, </year> <pages> pp. 418-423. </pages>
Reference-contexts: Thus our approach reduces test time and can avoid the area overhead of scan logic. Another technique with the potential to substantially reduce test generation effort is the use of symbolic signal values and operations. Test generation using symbolic values has been considered for low-level <ref> [14] </ref>, hierarchical [15,16] and high-level [6] circuits, but so far has not been used with true high-level ATPG algorithms. Typical is the functional solution language introduced by Breuer and Friedman [17] which employs primitive operations like count, shift, clock and hold, and symbolically manipulates them to generate tests.
Reference: [15] <author> P. N. Anirudhan and P. R. Menon, </author> <title> Symbolic test generation for hierarchically modeled digital systems, </title> <booktitle> Proc. </booktitle> <address> ITC, </address> <year> 1989, </year> <pages> pp 461-469. </pages>
Reference: [16] <author> B. T. Murray and J. P. Hayes, </author> <title> Hierarchical test generation using precomputed tests for modules, </title> <journal> IEEE TCAD, </journal> <volume> Vol. 9, </volume> <month> June </month> <year> 1990, </year> <pages> pp. 594-603. </pages>
Reference-contexts: Therefore, generalized non-controlling values must be known for each high-level primitive. Determining propagation modes is usually not too difficult. Some modules, e.g., multiplexers, have transparent modes <ref> [16] </ref> that allow fault effects to propagate through the primitive unaltered. Other modules, e.g., adders, pass all fault information, but may alter the fault effect values. We use a general library of primitive modules, with their precomputed SIF tests and propagation properties.
Reference: [17] <author> M. A. Breuer and A. D. Friedman, </author> <title> Functional level primitives in test generation, </title> <journal> IEEE TC, </journal> <volume> Vol. C-29, </volume> <month> March </month> <year> 1980, </year> <pages> pp. 223-235. </pages>
Reference-contexts: Test generation using symbolic values has been considered for low-level [14], hierarchical [15,16] and high-level [6] circuits, but so far has not been used with true high-level ATPG algorithms. Typical is the functional solution language introduced by Breuer and Friedman <ref> [17] </ref> which employs primitive operations like count, shift, clock and hold, and symbolically manipulates them to generate tests. <p> In the combinational case, all operations are primitive. When considering tests for sequential circuits, it is very useful to define higher-level operations that require multiple time steps by combining several primitive operations, as proposed by Breuer and Friedman <ref> [17] </ref>. These operations can then be hierarchically modeled as even higher-level operations. Breuer and Friedman define an ad hoc functional solution language (FSL) to describe circuit operations and they apply it to gate-level test generation. We describe tests functionally in a manner similar to FSL, but unlike [17], test generation is <p> Breuer and Friedman <ref> [17] </ref>. These operations can then be hierarchically modeled as even higher-level operations. Breuer and Friedman define an ad hoc functional solution language (FSL) to describe circuit operations and they apply it to gate-level test generation. We describe tests functionally in a manner similar to FSL, but unlike [17], test generation is carried out by SWIFT at the functional level. In our first example, a sequential decoder circuit presented below called h325, there are four primitive operations, namely Reset, Count, Pulse, and Shift. <p> Also in this way, the detailed, low-level processing is deferred until a high-level road map is made. This dramatically differs from the symbolic approach of Breuer and Friedman <ref> [17] </ref>, who effectively induced faults. m1 main ( ) m2 for every T op in T from each module m3 Justify ( T_T op , T_S I ) m4 Propagate ( T_S F ) m5 Schedule ( S ) m6 if successful then select time steps from S & apply data <p> From the SIF test requirements of each module (e.g., those of Figure 5), SWIFT creates four composite operations that with appropriate test data achieve 100% gate-level SSL fault coverage. Figure 14 compares these results to a gate-level approach and the approach proposed in <ref> [17] </ref>. It gives the actual number of module evaluations for SWIFT and a best-case number of evaluations for the other two approaches. <p> Since there are of the order of n faults, kn 2 is a conservative lower bound on the number of gate evaluations. Breuer and Friedman <ref> [17] </ref> focus on the modeling of functional primitives, and do not discuss the fault model assumed. Since they use a test generator of the D 1 evaluations needed to test h325. Gate-level test generator evaluations Breuer-Friedman test generator [17] evaluations SWIFT evaluations 5,070,000 62,400 156 algorithm-type and create bit-level propagation algorithms <p> Breuer and Friedman <ref> [17] </ref> focus on the modeling of functional primitives, and do not discuss the fault model assumed. Since they use a test generator of the D 1 evaluations needed to test h325. Gate-level test generator evaluations Breuer-Friedman test generator [17] evaluations SWIFT evaluations 5,070,000 62,400 156 algorithm-type and create bit-level propagation algorithms aimed at SSL faults, the SSL fault model is also assumed by us. For each fault, there are roughly 4k module evaluations, so all faults require 4kn module evaluations. Our symbolic tests require 48 time steps.
Reference: [18] <institution> Texas Instruments Inc., </institution> <note> The TTL Logic Data Book, Second Edition, </note> <institution> Dallas TX, </institution> <year> 1988. </year>
Reference-contexts: We break new ground with this work by bridging the experimental gap between high-level and gate-level methods. The circuits we functionally test are from the well-known 74X <ref> [18] </ref>, ISCAS-85 [19] and ISCAS-89 [12] series. To accomplish this, we first construct functional models of these circuits, complete details of which are found in [20]. As we report in Section 4, most of our test results improve upon the best-known gate-level test set sizes and their lower bounds.
Reference: [19] <author> F. Brglez and H. Fujiwara, </author> <title> A neutral netlist of 10 combinational benchmark designs and a special translator in fortran, </title> <booktitle> Proc. </booktitle> <address> ISCAS, </address> <year> 1985, </year> <pages> pp. 695-698. </pages>
Reference-contexts: We break new ground with this work by bridging the experimental gap between high-level and gate-level methods. The circuits we functionally test are from the well-known 74X [18], ISCAS-85 <ref> [19] </ref> and ISCAS-89 [12] series. To accomplish this, we first construct functional models of these circuits, complete details of which are found in [20]. As we report in Section 4, most of our test results improve upon the best-known gate-level test set sizes and their lower bounds.
Reference: [20] <author> M. C. Hansen and J. P. Hayes, </author> <title> Functional modeling and testing of 74X-series, ISCAS-85 and ISCAS-89 circuits, </title> <type> Tech. Report, </type> <institution> Dept. of EECS, University of Michigan, </institution> <note> in preparation. </note>
Reference-contexts: The circuits we functionally test are from the well-known 74X [18], ISCAS-85 [19] and ISCAS-89 [12] series. To accomplish this, we first construct functional models of these circuits, complete details of which are found in <ref> [20] </ref>. As we report in Section 4, most of our test results improve upon the best-known gate-level test set sizes and their lower bounds. The contents of the paper are as follows. We discuss our functional modeling of circuits and their faults in Section 2.
References-found: 20

