URL: http://polaris.cs.uiuc.edu/reports/1260.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Email: (kwang|harrison)@csrd.uiuc.edu  
Title: Automatic Generation and Management of Interprocedural Program Analyses  
Author: Kwangkeun Yi and Williams Ludwell Harrison III 
Address: 465 CSRL, 1308 West Main St., Urbana, IL 61801-2307  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: We have designed and implemented an interprocedural program analyzer generator, called system Z. Our goal is to automate the generation and management of semantics-based interprocedural program analysis for a wide range of target languages. System Z is based on the abstract interpretation framework. The input to system Z is a high-level specification of an abstract interpreter. The output is a C code for the specified interprocedural program analyzer. The system provides a high-level command set (called projection expressions) in which the user can tune the analysis in accuracy and cost. The user writes projection expressions for selected domains; system Z takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. We demonstrate the system's capabilities by experiments with a set of generated analyzers which can analyze C, FORTRAN, and SCHEME programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Samson Abramsky and Chris Hankin, editors. </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: Later, he write projections for selected domains. The system takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. 1.2 Why Abstract Interpretation? The abstract interpretation framework <ref> [6, 7, 1] </ref> proposes that designing a program analysis is equivalent to defining an interpreter for the target language. The virtues of system Z comes from the power of the abstract interpretation framework. * The abstract interpretation framework solves problems that compiler designers currently face.
Reference: [2] <author> Jeffrey M. Barth. </author> <title> An interprocedural data flow analysis algorithm. </title> <booktitle> In Conference Record of the Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 119-131, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: An approximate, compile-time interpretation rule for procedure call expression is all that is needed for interprocedural analysis. As defined in this rule, the analysis will bind the parameters and interpret the body. This approach is different from conventional ones <ref> [5, 15, 23, 2] </ref> in two aspects. First, aliases (due to reference parameters) and recursive calls, which were considered two principal problems of interprocedural analysis, are treated by simulating directly the language construct that causes them (in this case, call expression).
Reference: [3] <author> Geoffrey L. Burn. </author> <title> Abstract Interpretation and the Parallel Evaluation of Functional Languages. </title> <type> PhD thesis, </type> <institution> Department of Computing, Imperial College, University of London, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: One question is: how do we write a correct abstract interpreter? This question reduces to: what does each abstract value mean? The denotational semantics formalism provides us with an answer to this question <ref> [4, 3] </ref>. In denotational semantics [20], domains are used to give mathematical meaning to types.
Reference: [4] <author> Geoffrey L. Burn. </author> <title> Lazy Functional Languages: Abstract Interpretation and Compilation. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: One question is: how do we write a correct abstract interpreter? This question reduces to: what does each abstract value mean? The denotational semantics formalism provides us with an answer to this question <ref> [4, 3] </ref>. In denotational semantics [20], domains are used to give mathematical meaning to types.
Reference: [5] <author> David Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: An approximate, compile-time interpretation rule for procedure call expression is all that is needed for interprocedural analysis. As defined in this rule, the analysis will bind the parameters and interpret the body. This approach is different from conventional ones <ref> [5, 15, 23, 2] </ref> in two aspects. First, aliases (due to reference parameters) and recursive calls, which were considered two principal problems of interprocedural analysis, are treated by simulating directly the language construct that causes them (in this case, call expression). <p> Second, the program's call graph is not assumed as given prior to the analysis. As we discussed above, this is important when the target language allows procedures as first-class objects. Accuracy improvement by clever representations of the call graph <ref> [5, 15] </ref> may still be applicable in abstract interpretation, if the improvement is applied as a post-analysis process, when the call graph has been constructed. * The abstract interpretation framework makes it feasible to generate compile-time analyses from high-level specifications automatically.
Reference: [6] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the 4th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: Our goal is to automate the generation of such global program analyses and shorten the cycle time of designing, experimenting, and redesigning. We have designed and implemented the system Z which automates the generation and management of interprocedural program analyses. The system is based on the abstract interpretation framework <ref> [6, 7] </ref>. The user specifies an abstract interpreter in a specification language. The system compiles the specification into a C code, which becomes an executable interprocedural program analyzer when linked with a target language parser. <p> Later, he write projections for selected domains. The system takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. 1.2 Why Abstract Interpretation? The abstract interpretation framework <ref> [6, 7, 1] </ref> proposes that designing a program analysis is equivalent to defining an interpreter for the target language. The virtues of system Z comes from the power of the abstract interpretation framework. * The abstract interpretation framework solves problems that compiler designers currently face.
Reference: [7] <author> Patrick Cousot and Radhia Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Conference Record of the Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: Our goal is to automate the generation of such global program analyses and shorten the cycle time of designing, experimenting, and redesigning. We have designed and implemented the system Z which automates the generation and management of interprocedural program analyses. The system is based on the abstract interpretation framework <ref> [6, 7] </ref>. The user specifies an abstract interpreter in a specification language. The system compiles the specification into a C code, which becomes an executable interprocedural program analyzer when linked with a target language parser. <p> Later, he write projections for selected domains. The system takes care of the remaining things so that the generated analyzer conducts an analysis over the projected domains, which will vary in cost and accuracy according to the projections. 1.2 Why Abstract Interpretation? The abstract interpretation framework <ref> [6, 7, 1] </ref> proposes that designing a program analysis is equivalent to defining an interpreter for the target language. The virtues of system Z comes from the power of the abstract interpretation framework. * The abstract interpretation framework solves problems that compiler designers currently face.
Reference: [8] <author> Harald Ganzinger and Robert Giegerich. </author> <title> A truly generative semantics-directed compiler generator. </title> <booktitle> In Proceedingsof SIG-PLAN '82 Symposium on Compiler Construction, volume 17 of SIGPLAN Notices, </booktitle> <pages> pages 172-184, </pages> <year> 1982. </year>
Reference-contexts: Department of Energy under Grant No. DE-FG02-85ER25001 with additional support from NSF under Grant No. NSF CCR 90-24554. To appear in The Twentieth Annual ACM Symposium on Principles of Programming Languages, January, 1993. analysis succinctly. Similar tools <ref> [18, 14, 8, 24] </ref> have been reported in the literature, but they have several shortcomings relative to system Z.

Reference: [10] <author> Williams Ludwell Harrison III. </author> <title> Semantic Analysis of Symbolic Programs for Automatic Parallelization. </title> <note> Book in preparation, </note> <year> 1992. </year>
Reference-contexts: Inside Z, the user declares it, before its use, as (isPlus (from syntree) (to number)). Inside user.h, syntree and number are defined as, for example, typedef struct node* syntree and typedef int number. Currently, we have implemented ANSI C, FORTRAN, and SCHEME front-ends for an intermediate language MIL (MIPRAC <ref> [11, 10, 9] </ref> Intermediate Language), along with a set of routines to access MIL programs, so that Z may be used to analyze programs in these source languages. 4 Experiments In this section, we present examples to demonstrate system Z's capabilities, focusing on the projection facility. <p> We present one such case below. We have designed two analyses in Z: constant propagation analysis and alias analysis. The target language is MIL <ref> [11, 10] </ref>. Since we have parsers from ANSI C and FORTRAN into MIL, we can use C and FORTRAN programs as test suites. The two analyses are embodied in a single abstract interpreter definition.
Reference: [11] <author> Williams Ludwell Harrison III and Zahira Ammarguellat. </author> <title> A program's eye view of miprac. </title> <editor> In D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <title> Languages and Compilers for Parallel Computing (Also as a UIUC CSRD Report 1227). </title> <publisher> MIT Press, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: Inside Z, the user declares it, before its use, as (isPlus (from syntree) (to number)). Inside user.h, syntree and number are defined as, for example, typedef struct node* syntree and typedef int number. Currently, we have implemented ANSI C, FORTRAN, and SCHEME front-ends for an intermediate language MIL (MIPRAC <ref> [11, 10, 9] </ref> Intermediate Language), along with a set of routines to access MIL programs, so that Z may be used to analyze programs in these source languages. 4 Experiments In this section, we present examples to demonstrate system Z's capabilities, focusing on the projection facility. <p> We present one such case below. We have designed two analyses in Z: constant propagation analysis and alias analysis. The target language is MIL <ref> [11, 10] </ref>. Since we have parsers from ANSI C and FORTRAN into MIL, we can use C and FORTRAN programs as test suites. The two analyses are embodied in a single abstract interpreter definition.
Reference: [12] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Comptuer Programs. </title> <publisher> Elsevier North-Holland, Inc., </publisher> <year> 1977. </year>
Reference-contexts: The virtues of system Z comes from the power of the abstract interpretation framework. * The abstract interpretation framework solves problems that compiler designers currently face. Conventional data flow analysis methods (as summarized in <ref> [17, 12] </ref>) have several limitations. First, they are restricted to languages like FORTRAN where a program's flow graph can be (largely) determined from its text. Second, only with difficulty can they be adapted to constructs that require detailed semantic consideration.
Reference: [13] <author> Paul Hudak and Jonathan Young. </author> <title> Collecting interpretations of expressions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 269-290, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: We call this a collecting analysis <ref> [13] </ref>. How can an interpreter definition be a specification of a collecting analysis? An interpreter is a function that defines, for each language construct, its evaluation rule. Each evaluation rule is a state transformer: a function from a pre-state to a post-state.
Reference: [14] <author> Kai Koskimies, Otto Nurmi, Jukka Paakki, and Seppo Sippu. </author> <title> The design of a language processor generator. </title> <journal> Software Practice and Experience, </journal> <volume> 18(2) </volume> <pages> 107-135, </pages> <year> 1988. </year>
Reference-contexts: Department of Energy under Grant No. DE-FG02-85ER25001 with additional support from NSF under Grant No. NSF CCR 90-24554. To appear in The Twentieth Annual ACM Symposium on Principles of Programming Languages, January, 1993. analysis succinctly. Similar tools <ref> [18, 14, 8, 24] </ref> have been reported in the literature, but they have several shortcomings relative to system Z.
Reference: [15] <author> Eugene W. Myers. </author> <title> A precise inter-procedural data flow algo rithm. </title> <booktitle> In Conference Record of the Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <year> 1981. </year>
Reference-contexts: An approximate, compile-time interpretation rule for procedure call expression is all that is needed for interprocedural analysis. As defined in this rule, the analysis will bind the parameters and interpret the body. This approach is different from conventional ones <ref> [5, 15, 23, 2] </ref> in two aspects. First, aliases (due to reference parameters) and recursive calls, which were considered two principal problems of interprocedural analysis, are treated by simulating directly the language construct that causes them (in this case, call expression). <p> Second, the program's call graph is not assumed as given prior to the analysis. As we discussed above, this is important when the target language allows procedures as first-class objects. Accuracy improvement by clever representations of the call graph <ref> [5, 15] </ref> may still be applicable in abstract interpretation, if the improvement is applied as a post-analysis process, when the call graph has been constructed. * The abstract interpretation framework makes it feasible to generate compile-time analyses from high-level specifications automatically.
Reference: [16] <author> D.E. Rutherford. </author> <title> Introduction to Lattice Theory. </title> <publisher> Hafner Pub lishing Company, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: Property 2 For each domain in Z, every maximal chain between any two elements is of the same length. Proof. This property (Jordan-Holder theorem <ref> [16] </ref>) follows when all the constructed lattices are modular and finite. We know that all of our lattices are of finite cardinality.
Reference: [17] <author> Barbara G. Ryder and Marvin C. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(3):277 316, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: The virtues of system Z comes from the power of the abstract interpretation framework. * The abstract interpretation framework solves problems that compiler designers currently face. Conventional data flow analysis methods (as summarized in <ref> [17, 12] </ref>) have several limitations. First, they are restricted to languages like FORTRAN where a program's flow graph can be (largely) determined from its text. Second, only with difficulty can they be adapted to constructs that require detailed semantic consideration.
Reference: [18] <author> Masataka Sassa. Rie and jun: </author> <title> Towards the generation of all compiler phases. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 477, </volume> <pages> pages 56-70. </pages> <year> 1990. </year>
Reference-contexts: Department of Energy under Grant No. DE-FG02-85ER25001 with additional support from NSF under Grant No. NSF CCR 90-24554. To appear in The Twentieth Annual ACM Symposium on Principles of Programming Languages, January, 1993. analysis succinctly. Similar tools <ref> [18, 14, 8, 24] </ref> have been reported in the literature, but they have several shortcomings relative to system Z.
Reference: [19] <author> Bernahard Steffen. </author> <title> Data flow analysis as model checking. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 526, </volume> <pages> pages 346-364. </pages> <year> 1991. </year>
Reference-contexts: Young [26] reported a library that he used to implement several semantic analyses. Steffen <ref> [19] </ref> reported a specification framework that uses modal logic formulae to specify data flow analysis algorithms. The work most similar to ours is by Venkatesh [22]. His specification language allows denotational semantics to be augmented with a collecting mechanism for program analysis.
Reference: [20] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: the Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: Designing a program analysis is equivalent to designing an abstract interpreter. Thus an appropriate formalism for interpreter specification provides a comfortable ground for automatic generation of a global program analysis. In deno-tational semantics <ref> [20] </ref>, abstract interpreters are defined by domain equations together with semantics equations over the domains. For a useful class of domains these specifications can automatically be made executable. <p> One question is: how do we write a correct abstract interpreter? This question reduces to: what does each abstract value mean? The denotational semantics formalism provides us with an answer to this question [4, 3]. In denotational semantics <ref> [20] </ref>, domains are used to give mathematical meaning to types.
Reference: [21] <author> Steven W. K. Tjiang and John L. Hennessy. </author> <title> Sharlit a tool for building optimizers. </title> <booktitle> In SIGPLAN Conference on Program ming Language Design and Implementation, </booktitle> <pages> pages 82-93, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: All the value structures and semantic actions at each attribute grammar node must be provided in the implementation language by the user. Recently, Tjiang and Hennessy <ref> [21] </ref> reported a similar tool to generate an analyzer for a low-level intermediate language, with C++ as its specification language. An interesting feature of this tool is that its fixpoint computation procedure can be simplified by means of flow graph reduction rules specified by the user. <p> Depending on target languages, however, we can improve its performance. For example, for a language which enables us to determine, before the analysis starts, the control flow graph of an input program, the fixpoint computation method can be tailored for the control flow graph. As in <ref> [21] </ref>, system Z can provide a facility by which the user can specify such optimizations when possible. * Optimization of the generated analysis. There are ways in which we can further improve the performance of the gen erated C code.
Reference: [22] <author> G. A. Venkatesh. </author> <title> A framework for construction and evaluation of high-level specifications for program analysis techniques. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1989. </year>
Reference-contexts: Young [26] reported a library that he used to implement several semantic analyses. Steffen [19] reported a specification framework that uses modal logic formulae to specify data flow analysis algorithms. The work most similar to ours is by Venkatesh <ref> [22] </ref>. His specification language allows denotational semantics to be augmented with a collecting mechanism for program analysis. None of these tools provides a high-level facility to tune the analysis in accuracy and cost. 1.1 System Overview The overall configuration of system Z is shown in Figure 1.
Reference: [23] <author> William E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In Conference Record of the Annual ACM Symposium on Prin ciples of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <year> 1980. </year>
Reference-contexts: An approximate, compile-time interpretation rule for procedure call expression is all that is needed for interprocedural analysis. As defined in this rule, the analysis will bind the parameters and interpret the body. This approach is different from conventional ones <ref> [5, 15, 23, 2] </ref> in two aspects. First, aliases (due to reference parameters) and recursive calls, which were considered two principal problems of interprocedural analysis, are treated by simulating directly the language construct that causes them (in this case, call expression).
Reference: [24] <author> Reinhard Wilhelm. </author> <title> Global flow analysis and optimization in the mug2 compiler generating system. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: Theory and Applications, chapter 5. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Department of Energy under Grant No. DE-FG02-85ER25001 with additional support from NSF under Grant No. NSF CCR 90-24554. To appear in The Twentieth Annual ACM Symposium on Principles of Programming Languages, January, 1993. analysis succinctly. Similar tools <ref> [18, 14, 8, 24] </ref> have been reported in the literature, but they have several shortcomings relative to system Z.
Reference: [25] <author> Kwangkeun Yi and Williams Ludwell Harrison III. </author> <title> Z: In terprocedural data flow analysis specification language (in preparation). </title> <type> Technical report, </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana Champaign, </institution> <year> 1992. </year>
Reference-contexts: For each basic type, Z provides a set of constants and primitive operations over its values. Certainly, the expression constructs shown in Figure 3 are not defined for all types of values. The reader may want to see <ref> [25] </ref> for their formal semantics and type rules. (In Appendix B we include a brief description of them.) 3.4 Defining the Abstract Syntax of a Target Language As might be noted, Z does not provide any construct to specify the abstract syntax of a target language. <p> The definition has 667 lines. Due to space limitation we show only parts of the definition in Appendix A.1. (The reader may want to see <ref> [25] </ref> for the complete definition.) The generated C code for the analysis has 12K lines. Its executable binary size is 463K bytes. 4.1 Cost Variations Depending on Projections Tables in Figure 4 show the cost variations depending on the projections. <p> This example is a case in which a projection expression reduces the analysis cost without a loss of accuracy. Due to space limitation we show only parts of the definition in Appendix A.2. (The reader may want to see <ref> [25] </ref> for the complete definition.) The definition has 696 lines.
Reference: [26] <author> Jonathan H. Young. </author> <title> The Theory and Practice of Semantic Program Analysis for Higher-Order Functional Programming Languages. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: It is unclear, however, how this feature can be used for the case where the flow graph of a program cannot be determined before the analysis, which is the case for languages in which a function call expression need not specify (syntactically) which function it calls. Young <ref> [26] </ref> reported a library that he used to implement several semantic analyses. Steffen [19] reported a specification framework that uses modal logic formulae to specify data flow analysis algorithms. The work most similar to ours is by Venkatesh [22].
References-found: 25

