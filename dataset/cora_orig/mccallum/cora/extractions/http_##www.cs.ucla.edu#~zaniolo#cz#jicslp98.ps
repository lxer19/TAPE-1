URL: http://www.cs.ucla.edu/~zaniolo/cz/jicslp98.ps
Refering-URL: http://www.cs.ucla.edu/~zaniolo/cz/ZanioloPapers.html
Root-URL: http://www.cs.ucla.edu
Email: greco@si.deis.unical.it  zaniolo@cs.ucla.edu  
Title: Greedy Algorithms in Datalog with Choice and Negation  
Author: Sergio Greco Carlo Zaniolo 
Address: 87030 Rende, Italy  Los Angeles Los Angeles, CA 90024  
Affiliation: Dip. Elettr. Informatica Sist. Universita della Calabria  Computer Science Dept. Univ. of California at  
Abstract: In the design of algorithms, the greedy paradigm provides a powerful tool for solving efficiently classical computational problems, within the framework of procedural languages. However, expressing these algorithms within the declarative framework of logic-based languages has proven a difficult research challenge. In this paper, we extend the framework of Datalog-like languages to obtain simple declarative formulations for such problems, and propose effective implementation techniques to ensure computational complexities comparable to those of procedural formulations. These advances are achieved through the use of the choice construct, extended with preference annotations to effect the selection of alternative stable-models and nondeterministic fixpoints. We show that, with suitable storage structures, the differential fixpoint computation of our programs matches the complexity of procedural algorithms in classical search and optimization problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul S., R. Hull, V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley. </publisher> <year> 1994. </year>
Reference: [2] <author> Abiteboul S. and V. Vianu. </author> <title> Datalog Extensions for Databases Queries and Updates. </title> <journal> In Journal of Computer and System Science, </journal> <volume> 43, </volume> <pages> pages 62-124, </pages> <year> 1991. </year>
Reference-contexts: In fact, the expressive power of the choice construct has been studied in [9, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator <ref> [2] </ref>, and the original version of choice proposed in [13], which is called static-choice, to distinguish from the dynamic choice used here [8]). <p> For instance, it has been shown in [8], that the task of ordering a domain or computing whether it contains an even number of elements (parity query) cannot performed by positive programs with static choice or the witness operator <ref> [2] </ref>. In the rest of the paper, we will concentrate on nondeterministic queries. In particular, our previous advisor example, can be modified using more sophisticated criteria are used to match students with candidate advisors.
Reference: [3] <author> Aho A.V., J.E. Hopcropt J.E., and J.D. Ullman, </author> <title> The Design and analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference: [4] <author> Apt K.R., H.A. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In (Minker ed.) </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [5] <author> S. W. Dietrich. </author> <title> Shortest Path by Approximation in Logic Programs. </title> <journal> ACM Letters on Programming Lang. and Sys. </journal> <volume> Vol 1, No, 2, </volume> <pages> pages 119-137, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: A significant amount of excellent previous work has investigated the issue of how to express in logic and compute efficiently greedy algorithms, and, more in general, classical algorithms that require non-monotonic constructs. An incomplete list include work by <ref> [19, 5, 18, 21, 6] </ref>.
Reference: [6] <author> Ganguly S., S. Greco, and C. Zaniolo. </author> <title> Extrema Predicates in Deductive Databases. </title> <journal> Journal of Computer and System Science, </journal> <year> 1995. </year>
Reference-contexts: A significant amount of excellent previous work has investigated the issue of how to express in logic and compute efficiently greedy algorithms, and, more in general, classical algorithms that require non-monotonic constructs. An incomplete list include work by <ref> [19, 5, 18, 21, 6] </ref>.
Reference: [7] <author> Gelfond M. and V. Lifschitz. </author> <title> The stable model semantics of logic programming. </title> <booktitle> In Proc. Fifth Intern. Conf. on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: Unfortunately, the computational problems remain largely unsolved: various approaches have been proposed to more effective computations of well-founded models and stable models <ref> [20, 7] </ref>, but these fall well short of matching the efficiency of classical procedural solu tions, such as, say, algorithms that find shortest paths in graphs. In general, it is known that determining whether a program has a stable model is NP-complete [14].
Reference: [8] <author> Giannotti F., D. Pedreschi, D. Sacca, and C. Zaniolo. </author> <title> Nondeterminism in deductive databases. </title> <booktitle> In Proc. 2nd DOOD Conference, </booktitle> <year> 1991. </year>
Reference-contexts: (P; Majr); chosen (S; P): chosen (S; P) student (S; Majr; Yr); professor (P; Majr); :diffChoice (S; P): diffChoice (S; P) chosen (S; P 0 ); P 6= P 0 : In general, the program f oe (P ) generated by the transformation dis cussed above has the following properties <ref> [8] </ref>: * f oe (P ) has one or more total stable models. * The chosen atoms in each stable model of f oe (P ) obey the FDs defined by the choice goals. The stable models of f oe (P ) are called choice models for P . <p> those without choice. 3 Computing with Choice The introduction of choice in Datalog has a significant impact on the expressive power of the language, since it allows us to express nondeterministic queries that cannot be expressed in Datalog with stratified negation, and deterministic queries that could not be expressed otherwise <ref> [10, 8] </ref>. <p> power of the choice construct has been studied in [9, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [13], which is called static-choice, to distinguish from the dynamic choice used here <ref> [8] </ref>). For instance, it has been shown in [8], that the task of ordering a domain or computing whether it contains an even number of elements (parity query) cannot performed by positive programs with static choice or the witness operator [2]. <p> in [9, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [13], which is called static-choice, to distinguish from the dynamic choice used here <ref> [8] </ref>). For instance, it has been shown in [8], that the task of ordering a domain or computing whether it contains an even number of elements (parity query) cannot performed by positive programs with static choice or the witness operator [2]. In the rest of the paper, we will concentrate on nondeterministic queries. <p> For logic programs with infinite Her-brand universe, an additional assumption of fairness is needed to ensure completeness [9]. As customary for database queries, computational complexity is evaluated with respect to the size of the database. Theorem 2. <ref> [8] </ref> Let P be a choice Datalog program. <p> In particular, we want to explore specializations of this concept that trade nondeterministic completeness (which is only of abstract interest to a programmer) in return for very concrete benefits, such as expressive power and performance. For instance, in the specialization called Eager Choice <ref> [8] </ref>, a maximal I is used in Equation 2. This results in a significant increase in expressive power, as demonstrated by the fact that negation can be emulated by eager choice [8, 9]. <p> For instance, in the specialization called Eager Choice [8], a maximal I is used in Equation 2. This results in a significant increase in expressive power, as demonstrated by the fact that negation can be emulated by eager choice <ref> [8, 9] </ref>.
Reference: [9] <author> Giannotti F., D. Pedreschi, C. Zaniolo, </author> <title> Semantics and Expressive Power of Non-Deterministic Constructs in Deductive, </title> <note> Tecnical Report C96-04, Cnuce-CNR, Pisa, 1996, (submitted for publication). </note>
Reference-contexts: In fact, the expressive power of the choice construct has been studied in <ref> [9, 10] </ref>, where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [13], which is called static-choice, to distinguish from the dynamic choice used here [8]). <p> Therefore, we have that, for any interpretation I of f oe (P ): T foe (P ) (I) = T P D (I) [ T P C (I): Following <ref> [9] </ref> we can now introduce a general operator for computing the nondeterministic fixpoints of a choice program P . The stable models of f oe (P ) are called choice models for P , and the choice goals define the functional dependencies F D P : Definition 2. <p> For logic programs with infinite Her-brand universe, an additional assumption of fairness is needed to ensure completeness <ref> [9] </ref>. As customary for database queries, computational complexity is evaluated with respect to the size of the database. Theorem 2. [8] Let P be a choice Datalog program. <p> For instance, in the specialization called Eager Choice [8], a maximal I is used in Equation 2. This results in a significant increase in expressive power, as demonstrated by the fact that negation can be emulated by eager choice <ref> [8, 9] </ref>.
Reference: [10] <author> Greco S., D. Sacca, and C. Zaniolo, </author> <title> DATALOG Queries with Stratified Negation and Choice: from P to D P In Proc. </title> <booktitle> Fifth ICDT Conference, </booktitle> <pages> 81-96, </pages> <year> 1995. </year>
Reference-contexts: those without choice. 3 Computing with Choice The introduction of choice in Datalog has a significant impact on the expressive power of the language, since it allows us to express nondeterministic queries that cannot be expressed in Datalog with stratified negation, and deterministic queries that could not be expressed otherwise <ref> [10, 8] </ref>. <p> In fact, the expressive power of the choice construct has been studied in <ref> [9, 10] </ref>, where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [13], which is called static-choice, to distinguish from the dynamic choice used here [8]).
Reference: [11] <author> Greco S., C. Zaniolo, and S. Ganguly. </author> <title> Greedy by Choice. </title> <booktitle> In Proc. of the 11th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: An incomplete list include work by [19, 5, 18, 21, 6]. In this paper we introduce a treatment for greedy algorithms that is significant simpler and more robust than previous approaches (including that of Greco, Zaniolo and Ganguly <ref> [11] </ref>); it also treats all aspects of these algorithms, beginning from their intuitive formulation, and ending with their optimized expression and execution. <p> In this paper, we introduce a new kind of specialization called greedy choice; this is motivated by the observation that it is frequently desirable to select a value that is the least (or the most) among the possible values and still satisfy the FDs defined by the choice atoms <ref> [11] </ref>. Therefore, with X denoting one or more variables of r, and C denoting one single variable ranging over an ordered domain, a goal choice-least ((X),(C)) in a rule r can be used to denote that the FD choice ((X),(C)) is to be satisfied using least values of C.
Reference: [12] <author> Greco S., and C. Zaniolo, </author> <title> Greedy Fixpoint Algorithms for Logic Programs with Negation and Extrema. </title> <type> Technical Report, </type> <year> 1997. </year>
Reference-contexts: For space limitation the proofs of our results are omitted and they can be found in the full version of the paper <ref> [12] </ref>. 2 Nondeterministic Reasoning Say that, with relation student (Name; Major; Year), our university database contains the relation professor (Name; Major).
Reference: [13] <author> Krishnamurthy R. and S. Naqvi. </author> <title> Non-deterministic choice in Datalog. </title> <booktitle> In Proc. of the 3rd International Conf. on Data and Knowledge Bases, </booktitle> <year> 1988. </year>
Reference-contexts: In fact, the expressive power of the choice construct has been studied in [9, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in <ref> [13] </ref>, which is called static-choice, to distinguish from the dynamic choice used here [8]).
Reference: [14] <author> Marek W., M. Truszczynski. </author> <title> Autoepistemic Logic. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 588-619, </pages> <year> 1991. </year>
Reference-contexts: In general, it is known that determining whether a program has a stable model is NP-complete <ref> [14] </ref>. Therefore, in this paper we propose a different approach: while, at the semantic level, we strictly adhere to the formal declarative semantics of logic programs with negation, we also allow the use of extended non-monotonic constructs with first order semantics to facilitate the task of programmers and compilers alike. <p> This contrast with the general untractability of finding stable models for general programs: in fact, we know that checking if a Datalog program with negation has a stable model is NP-complete <ref> [14] </ref>. Therefore the choice construct allows us to capture a special subclass of programs that have a stable model semantics but are amenable to efficient implementation and are appealing to intuition.
Reference: [15] <author> Moret B.M.E., and H.D. Shapiro. </author> <title> Algorithms from P to NP. </title> <publisher> Benjamin Cum-mings, </publisher> <year> 1993. </year>
Reference-contexts: This entails simple declarative formulations and nearly optimal executions for large classes of problems, that are normally solved using greedy algorithms. Greedy algorithms <ref> [15] </ref> are those that solve a class of optimization problems, using a control structure of a single loop, where, at each iteration some element judged the `best' at that stage is chosen and it is added to the solution.
Reference: [16] <author> Papadimitriou C., K. Steiglitz, </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <address> Englewood Cliff, N.J., </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Dijkstra's algorithm. dj (a; 0): C = C 1 + C 2 ; choice-least ((Y); (C)): 2 Greedy algorithms often provide efficient approximate solutions to NP-complete problems; the following algorithm yields heuristically effective approximations of optimal solutions for the traveling salesperson problem <ref> [16] </ref>. Example 10. Greedy TSP. Given a complete undirected graph 2 , the exit rule simply selects an arbitrary node X, from which to start the search. Then, the recursive rule the greedily chooses an arc of least cost having X as its end node.
Reference: [17] <author> Przymusinski T., </author> <title> On the declarative and procedural semantics of stratified deductive databases. </title> <editor> In Minker, ed., </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <address> Morgan-Kaufman, </address> <year> 1988. </year>
Reference: [18] <author> K.A. Ross, and Y. Sagiv. </author> <title> Monotonic Aggregation in Deductive Databases. </title> <booktitle> In Proc. 11th ACM Symp. on Princ. of Database Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: A significant amount of excellent previous work has investigated the issue of how to express in logic and compute efficiently greedy algorithms, and, more in general, classical algorithms that require non-monotonic constructs. An incomplete list include work by <ref> [19, 5, 18, 21, 6] </ref>.
Reference: [19] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proc. of the 17th Conference on Very Large Data Bases, </booktitle> <year> 1991. </year>
Reference-contexts: A significant amount of excellent previous work has investigated the issue of how to express in logic and compute efficiently greedy algorithms, and, more in general, classical algorithms that require non-monotonic constructs. An incomplete list include work by <ref> [19, 5, 18, 21, 6] </ref>.
Reference: [20] <author> Van Gelder A., K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Unfortunately, the computational problems remain largely unsolved: various approaches have been proposed to more effective computations of well-founded models and stable models <ref> [20, 7] </ref>, but these fall well short of matching the efficiency of classical procedural solu tions, such as, say, algorithms that find shortest paths in graphs. In general, it is known that determining whether a program has a stable model is NP-complete [14].
Reference: [21] <author> Van Gelder A., </author> <booktitle> Foundations of Aggregations in Deductive Databases In Proc. of the Int. Conf. On Deductive and Object-Oriented databases, </booktitle> <year> 1993. </year>
Reference-contexts: A significant amount of excellent previous work has investigated the issue of how to express in logic and compute efficiently greedy algorithms, and, more in general, classical algorithms that require non-monotonic constructs. An incomplete list include work by <ref> [19, 5, 18, 21, 6] </ref>.
Reference: [22] <author> Zaniolo C., S. Ceri, C. Faloutsos, V.S. Subrahmanian and R. Zicari, </author> <title> Advanced Database Systems, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1997. </year>
Reference-contexts: In general computation computation consists of two phases: (i) compilation (ii) the execution phase. All compilation algorithms discussed here execute with time complexity that is polynomial in the size of the programs. Moreover, we will assume, as it is customarily done <ref> [22] </ref>, that the size of the database dominates that of the program. Thus, execution costs dominate the compilation costs, which will then be disregarded in the derivation of the worst case complexities. <p> Thus, execution costs dominate the compilation costs, which will then be disregarded in the derivation of the worst case complexities. We will use compilation techniques, such as the differential fixpoint computation, that are of common usage in deductive database systems <ref> [22] </ref>. Also we will employ suitable storage structures, such as hash tables to support search on keys, and priority queues to support choice-least and choice-most goals. 6.1 Implementation of Programs with Choice Let us begin with the implementation of choice goals.
References-found: 22

