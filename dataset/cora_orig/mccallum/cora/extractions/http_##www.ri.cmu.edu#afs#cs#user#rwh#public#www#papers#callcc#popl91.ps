URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers/callcc/popl91.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Title: Typing First-Class Continuations in ML  
Author: Bruce F. Duba Robert Harper David MacQueen 
Affiliation: Rice University  Carnegie Mellon University  AT&T Bell Laboratories  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: as the meaning of its cps transform, M , defined as follows: x = : x M N = :M (m:N (n:mn)) letcc x in M = :[=x]M throw M N = :M (m:N (n:mn)) (In fact, the Standard ML of New Jersey compiler is based on a similar transformation <ref> [1] </ref>.) To relate the type of a term M to the type of its cps transform, we associate to each type t of the illustrative language, a simple type t fl given by b fl = b (t cont ) fl = t fl !ff where ff is a fixed, but
Reference: [2] <author> Andrew W. Appel and David MacQueen. </author> <title> Standard ML of New Jersey Reference Manual. </title> <note> (in preparation), </note> <year> 1990. </year>
Reference-contexts: It is here that the two constructs differ in an ML-like setting. Another way of typing continuations, and the one currently adopted in Standard ML of New Jersey <ref> [2] </ref>, is to abandon the view that continuations are functions in the ordinary sense and to consider t cont as a primitive type with an operation throw for invoking a continuation.
Reference: [3] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, Laurent Hascoet, and Gilles Kahn. </author> <title> Natural semantics on the computer. </title> <type> Technical Report RR 416, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: The main results are a Milner-style soundness theorem ("well-typed programs cannot go wrong") and an observational soundness theorem ("convergent programs of type int yield integers"). Finally, in Section 4 we give an operational semantics for the language in the "natural semantics" style of Plotkin and Kahn <ref> [25, 3] </ref>. The operational presentation illustrates the extent to which the definition of Standard ML [22] would have to be changed to accomodate the proposed extension.
Reference: [4] <author> William Clinger, Daniel P. Friedman, and Mitchell Wand. </author> <title> A scheme for higher-level semantic algebra. </title> <editor> In Maurice Nivat and John C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 237-250. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: In a typical implementation the final result is passed to the interactive top-level, which prints the result, and continues by evaluating the next expression. In 1982 Will Clinger and Dan Friedman <ref> [4] </ref> noticed that the act of capturing the current continuation did not require a special variable binding form, but could be performed by a primitive operation, called call-with-current-continuation, or call/cc for short, whose argument was a function that would be applied to the captured continuation, so that (catch x body) becomes
Reference: [5] <author> Eric C. Cooper. </author> <title> An overview of the FOX project. </title> <institution> Talk at Bell Laboratories, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: k : state cont =&gt; produce (n,S k)) fun prun () = consume (pinit (0)) Closely related to coroutines are lightweight processes or threads, and continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [27, 5, 26, 36] </ref>. Another use of continuations is to provide a clean, typed interface for asynchronous signal handling [28].
Reference: [6] <author> R. Kent Dybvig and Bob Hieb. </author> <title> Engines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 14(2) </volume> <pages> 109-124, </pages> <year> 1989. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [15], exceptions [41], and engines <ref> [6] </ref>, for writing interpreters and compilers [30, 34], and for organizing run-time support for multiple threads of control [40, 27]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38].
Reference: [7] <author> Arthur Evans. </author> <title> PAL a language designed for teaching programming linguistics. </title> <booktitle> In Proc. ACM 23rd National Conference, </booktitle> <pages> pages 395-403, </pages> <address> Prince-ton, 1968. </address> <publisher> ACM, Brandin Systems Press. </publisher>
Reference-contexts: Stephen Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, and Olin Shivers for their comments and suggestions. 2 Adding Continuations to Standard ML A first-class continuation is an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [19], Reynold's escape [30], label variables in Gedanken [29] and PAL <ref> [7] </ref>, and from the semantic analyses of general control structures, including jumps [35]. Scheme [37] originally introduced a binding construct (catch x body) that captured its own expression continuation and bound it to the variable x, with the expression body as the scope of the binding.
Reference: [8] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> Reasoning with continuations. </title> <booktitle> In First Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [8, 9, 38] </ref>. Recent studies have focused on questions of typing for first-class continuations [12, 11, 14] and their impact on "full abstraction" results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [9] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [8, 9, 38] </ref>. Recent studies have focused on questions of typing for first-class continuations [12, 11, 14] and their impact on "full abstraction" results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [10] <author> Matthias Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming languages, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1988, </year> <pages> pages 180-190. </pages>
Reference: [11] <author> Andrzej Filinski. </author> <title> Declarative continuations: An investigation of duality in programming language semantics. </title> <booktitle> In Summer Conference on Category Theory and Computer Science, volume 389 of Lecture Notes in Computer Science, </booktitle> <address> Manchester, UK, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. Recent studies have focused on questions of typing for first-class continuations <ref> [12, 11, 14] </ref> and their impact on "full abstraction" results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [12] <author> Andrzej Filinski. </author> <title> Declarative continuations and categorical duality. </title> <type> Master's thesis, </type> <institution> University of Copenhagen, Copenhagen, Denmark, </institution> <month> August </month> <year> 1989. </year> <type> (DIKU Report 89/11). </type>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. Recent studies have focused on questions of typing for first-class continuations <ref> [12, 11, 14] </ref> and their impact on "full abstraction" results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme. <p> There are two main points. First, continuations arise in a program only by capturing the evaluation context of some expression: there are no expression forms denoting continuations (in contrast to the language considered by Filinski <ref> [12] </ref>.) Therefore continuations expect values of the type of the expression whose evaluation context the continuation represents. Second, the invocation of a captured continuation discards the current evaluation context, passing a value to the captured, instead of the current, continuation.
Reference: [13] <author> Daniel P. Friedman, Christopher T. Haynes, and Eugene Kohlbecker. </author> <title> Programming with continuations. Program Transformations and Programming Environments, edited by P. Pepper. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985, </year> <pages> 263-274. </pages>
Reference: [14] <author> Timothy Griffin. </author> <title> A formulas-as-types notion of control. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990, </year> <pages> pages 47-58. </pages>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. Recent studies have focused on questions of typing for first-class continuations <ref> [12, 11, 14] </ref> and their impact on "full abstraction" results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme. <p> of application of a continuation is now void, we must introduce, in compensation, a map ignore witnessing the inclusion of void into every type t : ` M : void ` ignore M : t (give-up) (These two rules have the form of Pierce's Law and false elimination, respectively; see <ref> [14] </ref> for further discussion.) The expression throw M N is now defined as ignore (M N ). For the polymorphic variant, the typing rule for letcc appears in the introduction. The denotational semantics must be changed to reflect the representation of continuations as functions.
Reference: [15] <author> Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. </author> <title> Obtaining coroutines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 11 </volume> <pages> 143-153, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction First-class continuations are a simple and natural way to provide access to the flow of evaluation in functional languages. The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines <ref> [15] </ref>, exceptions [41], and engines [6], for writing interpreters and compilers [30, 34], and for organizing run-time support for multiple threads of control [40, 27]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38].
Reference: [16] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 582-598, </pages> <year> 1987. </year>
Reference: [17] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Abstracting timed preemption with engines. </title> <journal> Journal of Computer Languages, </journal> <volume> 12 </volume> <pages> 109-121, </pages> <year> 1987. </year>
Reference: [18] <author> J. Roger Hindley. </author> <title> The completeness theorem for typing terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22 </volume> <pages> 127-134, </pages> <year> 1983. </year>
Reference: [19] <author> Peter J. Landin. </author> <title> A correspondence between ALGOL-60 and Church's lambda notation. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 89-101, </pages> <year> 1965. </year>
Reference-contexts: We are grateful to Stephen Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, and Olin Shivers for their comments and suggestions. 2 Adding Continuations to Standard ML A first-class continuation is an abstraction that evolved from various nonstandard control structures such as Landin's J-operator <ref> [19] </ref>, Reynold's escape [30], label variables in Gedanken [29] and PAL [7], and from the semantic analyses of general control structures, including jumps [35].
Reference: [20] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: By exploiting the type structure of the language, the complexity of reflexive domains can be avoided (while still admitting extensions such as fix). The fundamental idea is to adapt the methods of Meyer and Wand <ref> [20] </ref>, and make use of standard results of the typed -calculus to obtain the desired result.
Reference: [21] <author> Robin Milner and Mads Tofte. </author> <title> Co-induction in relational semantics. </title> <type> Technical Report ECS-LFCS-88-65, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, Edinburgh, </institution> <month> Octo-ber </month> <year> 1988. </year>
Reference-contexts: In contrast to the domain-theoretic semantics, the proof of the soundness theorem is significantly complicated by the introduction of fixed-point operators for defining recursive functions; see <ref> [21] </ref> for a careful discussion of a closely-related problem in the setting of natural semantics.
Reference: [22] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Finally, in Section 4 we give an operational semantics for the language in the "natural semantics" style of Plotkin and Kahn [25, 3]. The operational presentation illustrates the extent to which the definition of Standard ML <ref> [22] </ref> would have to be changed to accomodate the proposed extension. <p> all monotypes, and note that the above argument shows that if :: t , then v: 0 :(v) : t !t 0 for any type t 0 (not just void). 4 Extending the Definition of Standard ML An operational semantics for our language presented in the relational semantics style of <ref> [22] </ref> may be obtained from the denotational semantics by a process of "de-functionalization" [30] whereby closures and continuations are represented by finitary objects that are then "interpreted" on an argument, rather than simply applied to it.
Reference: [23] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <type> Technical Report STAN-CS-89-1277, </type> <institution> Stanford University, </institution> <year> 1989. </year>
Reference-contexts: We say that an environment matches a typing context iff (x) 2 A (x) for each x 2 dom (). It is a standard result that if ` ! M : t and matches , then A [[M ]] 2 A t <ref> [23] </ref>. Hence if we define [[M ]] to be A [[M]], then [[M ]] is in the set A (t fl !ff)!ff whenever matches fl .
Reference: [24] <author> Gordon Plotkin. </author> <title> Lambda-definability in the full type hierarchy. </title> <editor> In J. P. Seldin and J. R. Hind-ley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combi-natory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 363-373. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [25] <author> Gordon Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: The main results are a Milner-style soundness theorem ("well-typed programs cannot go wrong") and an observational soundness theorem ("convergent programs of type int yield integers"). Finally, in Section 4 we give an operational semantics for the language in the "natural semantics" style of Plotkin and Kahn <ref> [25, 3] </ref>. The operational presentation illustrates the extent to which the definition of Standard ML [22] would have to be changed to accomodate the proposed extension.
Reference: [26] <author> Norman Ramsey. </author> <title> Concurrent programming in ML. </title> <type> Technical Report CS-TR-262-90, </type> <institution> Computer Science Department, Princeton University, </institution> <year> 1990. </year>
Reference-contexts: k : state cont =&gt; produce (n,S k)) fun prun () = consume (pinit (0)) Closely related to coroutines are lightweight processes or threads, and continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [27, 5, 26, 36] </ref>. Another use of continuations is to provide a clean, typed interface for asynchronous signal handling [28].
Reference: [27] <author> John Reppy. </author> <title> First-class synchronous operations in Standard ML. </title> <type> Technical Report TR 89-1068, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, NY, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [15], exceptions [41], and engines [6], for writing interpreters and compilers [30, 34], and for organizing run-time support for multiple threads of control <ref> [40, 27] </ref>. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. Recent studies have focused on questions of typing for first-class continuations [12, 11, 14] and their impact on "full abstraction" results [32]. <p> k : state cont =&gt; produce (n,S k)) fun prun () = consume (pinit (0)) Closely related to coroutines are lightweight processes or threads, and continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [27, 5, 26, 36] </ref>. Another use of continuations is to provide a clean, typed interface for asynchronous signal handling [28].
Reference: [28] <author> John Reppy. </author> <title> Asynchronous signals in Standard ML. </title> <type> Technical Report TR 90-1144, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, NY, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Another use of continuations is to provide a clean, typed interface for asynchronous signal handling <ref> [28] </ref>. In Standard ML of New Jersey the type of a signal handler is (int * unit cont) -&gt; unit cont, where the argument is a pair consisting of a count of pending signals of the kind being handled, and the continuation representing the interrupted process.
Reference: [29] <author> John C. Reynolds. </author> <title> GEDANKEN | a simple type-less language based on the principle of completeness and the reference concept. </title> <journal> Communications of the ACM, </journal> <volume> 13(5) </volume> <pages> 308-319, </pages> <month> May </month> <year> 1970. </year>
Reference-contexts: are grateful to Stephen Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, and Olin Shivers for their comments and suggestions. 2 Adding Continuations to Standard ML A first-class continuation is an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [19], Reynold's escape [30], label variables in Gedanken <ref> [29] </ref> and PAL [7], and from the semantic analyses of general control structures, including jumps [35]. Scheme [37] originally introduced a binding construct (catch x body) that captured its own expression continuation and bound it to the variable x, with the expression body as the scope of the binding.
Reference: [30] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Conference Record of the 25th National ACM Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <note> ACM. </note>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [15], exceptions [41], and engines [6], for writing interpreters and compilers <ref> [30, 34] </ref>, and for organizing run-time support for multiple threads of control [40, 27]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. <p> We are grateful to Stephen Brookes, Matthias Felleisen, Andrzej Filinski, Timothy Griffin, and Olin Shivers for their comments and suggestions. 2 Adding Continuations to Standard ML A first-class continuation is an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [19], Reynold's escape <ref> [30] </ref>, label variables in Gedanken [29] and PAL [7], and from the semantic analyses of general control structures, including jumps [35]. <p> [[M N ]] = [[M ]] (m: [[N ]] (n: let clsr (f )=m in f n ow wrong)) [[letcc x in M ]] = [[M ]] [x:= clsr (v: 0 :(v))] [[ignore M ]] = [[M ]] A continuation is represented by a closure that ignores its continuation argument <ref> [30] </ref>. The definition of the relation v : t remains essentially the same, ignoring the clause for continuation types. Since void is a base type, a value v is of type void iff v =?: there are no terminating values of type void. <p> , then v: 0 :(v) : t !t 0 for any type t 0 (not just void). 4 Extending the Definition of Standard ML An operational semantics for our language presented in the relational semantics style of [22] may be obtained from the denotational semantics by a process of "de-functionalization" <ref> [30] </ref> whereby closures and continuations are represented by finitary objects that are then "interpreted" on an argument, rather than simply applied to it.
Reference: [31] <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <booktitle> In Proc. ICALP '74, volume 14 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: This entails extending the "non-escaping" property to arbitrary values, and to do so appears to require an inclusive predicate argument similar to that considered by Reynolds <ref> [31] </ref>. Given that such a predicate exists, we may choose the initial continuation as discussed above, and conclude, by the non-escaping property, that well-typed closed terms of base type evaluate to values of that type.
Reference: [32] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 Conference on LISP and Functional Programming, </booktitle> <pages> pages 161-175, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. Recent studies have focused on questions of typing for first-class continuations [12, 11, 14] and their impact on "full abstraction" results <ref> [32] </ref>. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [33] <author> Richard Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> <volume> 65 </volume> <pages> 85-97, </pages> <year> 1985. </year>
Reference: [34] <author> Guy L. Steele Jr. RABBIT: </author> <title> A compiler for SCHEME. </title> <type> Technical Report Memo 474, </type> <institution> MIT AI Laboratory, </institution> <year> 1978. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [15], exceptions [41], and engines [6], for writing interpreters and compilers <ref> [30, 34] </ref>, and for organizing run-time support for multiple threads of control [40, 27]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38].
Reference: [35] <author> Christopher Strachey and Christopher Wadsworth. </author> <title> A mathematical semantics for handling full jumps. </title> <type> Technical Report Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1974. </year>
Reference-contexts: their comments and suggestions. 2 Adding Continuations to Standard ML A first-class continuation is an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [19], Reynold's escape [30], label variables in Gedanken [29] and PAL [7], and from the semantic analyses of general control structures, including jumps <ref> [35] </ref>. Scheme [37] originally introduced a binding construct (catch x body) that captured its own expression continuation and bound it to the variable x, with the expression body as the scope of the binding.
Reference: [36] <author> Bernard Sufrin. </author> <title> CSP-style processes in ML. </title> <type> (Private communication), </type> <year> 1989. </year>
Reference-contexts: k : state cont =&gt; produce (n,S k)) fun prun () = consume (pinit (0)) Closely related to coroutines are lightweight processes or threads, and continuations have been used as the basis for several implementations of process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [27, 5, 26, 36] </ref>. Another use of continuations is to provide a clean, typed interface for asynchronous signal handling [28].
Reference: [37] <author> Gerald Jay Sussman and Guy Lewis Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Technical Report Memo No. 349, </type> <institution> MIT AI Laboratory, </institution> <month> December </month> <year> 1975. </year>
Reference-contexts: Scheme <ref> [37] </ref> originally introduced a binding construct (catch x body) that captured its own expression continuation and bound it to the variable x, with the expression body as the scope of the binding.
Reference: [38] <author> Carolyn Talcott. Rum: </author> <title> An intensional theory of function and control abstractions. </title> <booktitle> In Proc. 1987 Workshop of Foundations of Logic and Functional Programming, volume 306 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [8, 9, 38] </ref>. Recent studies have focused on questions of typing for first-class continuations [12, 11, 14] and their impact on "full abstraction" results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [39] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1988. </year> <note> Available as Edinburgh University Laboratory for Foundations of Computer Science Technical Report ECS-LFCS-88-54. </note>
Reference-contexts: For instance, if the identity function is stored into a cell, then a single instance of its polymorphic type must be chosen for all subsequent retrievals: it's polymorphic character is lost. (See Tofte's thesis <ref> [39] </ref> for further discussion of this point.) Thus if continuations were represented as functions of polymorphic result type, then the result type would have to be fixed at the time that the continuation is stored, rather than invoked, significantly limiting their utility.
Reference: [40] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <year> 1980. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [15], exceptions [41], and engines [6], for writing interpreters and compilers [30, 34], and for organizing run-time support for multiple threads of control <ref> [40, 27] </ref>. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38]. Recent studies have focused on questions of typing for first-class continuations [12, 11, 14] and their impact on "full abstraction" results [32].
Reference: [41] <author> Andrew Wright and Matthias Felleisen. </author> <title> The nature of exceptions in polymorphic languages. </title> <type> Unpublished manuscript, </type> <institution> Rice University, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction First-class continuations are a simple and natural way to provide access to the flow of evaluation in functional languages. The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [15], exceptions <ref> [41] </ref>, and engines [6], for writing interpreters and compilers [30, 34], and for organizing run-time support for multiple threads of control [40, 27]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [8, 9, 38].
References-found: 41

