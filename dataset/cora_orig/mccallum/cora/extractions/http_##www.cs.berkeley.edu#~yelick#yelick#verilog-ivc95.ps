URL: http://www.cs.berkeley.edu/~yelick/yelick/verilog-ivc95.ps
Refering-URL: http://www.cs.berkeley.edu/~yelick/papers.html
Root-URL: 
Title: Compiling Verilog into Timed Finite State Machines  
Author: Szu-Tsung Cheng Robert K. Brayton Gary York Katherine Yelick Alexander Saldanha 
Date: January 1, 1995  
Abstract: The lack of formal semantics for HDLs has made it hard to make a formal bridge between simulation tools based on HDLs and synthesis/verification tools based on finite state machines. In this paper we address the problem of finding a larger subset of Verilog HDL (which includes timing constructs) and a systematic way of extracting FSMs from programs built using the subset. Using timed FSMs as the target language for HDL compilation gives us two potential advantages. First, FSMs can be used to model systems that do not have hardware implementation. Second, FSMs can be used to model systems that are implementable but not automatically synthesizable. 
Abstract-found: 1
Intro-found: 1
Reference: [ABB + 94] <author> Adnan Aziz, Felice Balarin, Robert K. Brayton, Szu-Tsung Cheng, Ramin Ho-jati, Sriram C. Krishnan, Rajeev K. Ran-jan, Alberto L. Sangiovanni-Vincentelli, Thomas R. Shiple, Timothy Kam Vigyan Singhal, Serdar Tasiran, and Huey-Yih Wang. HSIS: </author> <title> A BDD-based environment for formal verification. </title> <booktitle> In DAC94, </booktitle> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year> <title> 2 Implicit/explicit clocking should be distinguished implicit/explicit FSMs used by Cadence for their hardware compiler for Verilog. </title>
Reference-contexts: Many advanced automatic synthesis/verification systems, for example <ref> [ABB + 94] </ref>, make use of formal transition models such as automata as their underlying model of the real world.
Reference: [BBC + ] <author> Felice Balarin, Robert K. Brayton, Szu-Tsung Cheng, Desmond A. Kirkpatrick, Alberto L. Sangiovanni-Vincentelli, and Ephrem Wu. </author> <title> A methodology for formal verification of real-time systems. </title> <note> To be submitted to DAC'96. </note>
Reference-contexts: The translated finite state machines are represented either using blif-mvt <ref> [BBC + ] </ref> (a timed extension of blif-mv [BCH + 91], which is a multi-valued extension of blif) or smv+ [McM94]. However, since the latter does not support notation for timing, at present smv+ can only represent Verilog without timing constructs. <p> It is possible that, with the advant of more advanced synthesis algorithms, such timed FSMs can be synthesized and an optimized implementation can be found. In addition, formal verifiers for real-time systems <ref> [BBC + ] </ref> can be applied to extracted timed FSMs so that systems with timing constraints (not necessarily implementable) can be verified. Note that the compilation process presented in this paper differs from high-level synthesis. <p> Several techniques used to minimize compiled FSMs are given in Apppendix B. 2 Background and Terminology 2.1 Timed Finite State Machines The timed finite state machines used as the target language of the compilation process are basically Timed Automata with Linear Equations (TALE, <ref> [BBC + ] </ref>). These finite state machines are traditional FSMs plus some timer variables. Each transition is labelled with input/output alphabets as well as linear inequalities among timer variables and/or actions (generally resetting) on timer variables.
Reference: [BCH + 91] <author> R. K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R. P. Kurshan, S. Malik, A. Sangiovanni-Vincentelli, E. M. Sentovich, T. Shiple, K. J. Singh, and H.-Y. Wang. BLIF-MV: </author> <title> An interchange format for design verification and synthesis. </title> <institution> Memorandum UCB/ERL M91/97, University of California at Berkeley, </institution> <year> 1991. </year>
Reference-contexts: The translated finite state machines are represented either using blif-mvt [BBC + ] (a timed extension of blif-mv <ref> [BCH + 91] </ref>, which is a multi-valued extension of blif) or smv+ [McM94]. However, since the latter does not support notation for timing, at present smv+ can only represent Verilog without timing constructs.
Reference: [BY93] <author> Felice Balarin and Gary York. </author> <title> Verilog HDL modeling styles for formal verification. In CHDL. </title> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: In the presence of non-blocking assignments, the next state of x will be chosen nondeterminis-tically from active non-blocking assignments, as suggested by <ref> [BY93] </ref>. This is used to model nondeterminism on state variables.
Reference: [CB94] <author> Szu-Tsung Cheng and Robert K. Brayton. </author> <title> Compiling verilog into automata. </title> <institution> Memorandum UCB/ERL M94/37, University of California at Berkeley, </institution> <year> 1994. </year>
Reference-contexts: This could be relieved by a preprocess over the CFG to eliminate all insignificant conditional blocks, which can be done in O (jV j) <ref> [CB94] </ref>. Consider the following always statement. always stmt1; #3 stmt2; A Verilog simulator first executes stmt1, then waits for 3 time units and executes stmt2 and stmt1, and so on.
Reference: [McM94] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: The translated finite state machines are represented either using blif-mvt [BBC + ] (a timed extension of blif-mv [BCH + 91], which is a multi-valued extension of blif) or smv+ <ref> [McM94] </ref>. However, since the latter does not support notation for timing, at present smv+ can only represent Verilog without timing constructs.
Reference: [TM91] <author> Donald E. Thomas and Philip R. Moorby. </author> <title> The Verilog Hardware Description Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Now-ell, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Abstraction, which can be used to reduce system complexity, is an important aspect of hierarchical synthesis/verification of large systems. Using HDLs, designers can design pretty much the way they write software programs. Recently, many existing designs have been written in HDLs like Verilog <ref> [TM91] </ref>, VHDL [vhd88], etc. However, most of these HDLs are designed for simulation and their semantics are either defined in terms of simulation results or left undefined.
Reference: [vhd88] <institution> IEEE Standard VHDL Language Reference Manual. Institute of Electrical and Electronics Engineers, </institution> <year> 1988. </year> <month> 12 </month>
Reference-contexts: Abstraction, which can be used to reduce system complexity, is an important aspect of hierarchical synthesis/verification of large systems. Using HDLs, designers can design pretty much the way they write software programs. Recently, many existing designs have been written in HDLs like Verilog [TM91], VHDL <ref> [vhd88] </ref>, etc. However, most of these HDLs are designed for simulation and their semantics are either defined in terms of simulation results or left undefined.
References-found: 8

