URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-97-06.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: nr@cs.virginia.edu  
Phone: Phone: +1 804 982 2227 Fax: +1 804 982 2214  
Title: Eliminating Spurious Error Messages Using Exceptions, Polymorphism, and Higher-Order Functions (Short Title: Eliminating Spurious Messages)  
Author: Norman Ramsey 
Date: April 3, 1997  
Address: Charlottesville, Virginia 22903 USA  
Affiliation: Dept of Computer Science, University of Virginia  
Abstract: Many language processors make assumptions after detecting an error. If the assumptions are invalid, processors may issue a cascade of error messages in which only the first represents a true error in the input; later messages are side effects of the original error. Eliminating such spurious error messages requires keeping track of values within the compiler that are not available because of a previously detected error. Examples include symbol-table entries, types, and intermediate code. This paper presents a discipline for tracking unavailable values and avoiding cascading error messages. The discipline itself is unsurprising, but it is both formalized and implemented in terms of a type constructor and combinators expressed in Standard ML, and the ML type rules enforce the discipline. The type constructor distinguishes intermediate results that are unavailable because of a previously detected error. The combinators transform ordinary functions, which assume all intermediate results are available, into functions that silently propagate the unavailability of intermediate results. ML's type system guides the application of the combinators; if the compiler writer does not account for a potentially unavailable value, the source code of the compiler does not type-check. The techniques presented exploit several features of Standard ML, including exceptions, higher-order functions, polymorphism, and static type checking. Using these features enables the ML type system to ensure that the error-tracking discipline is applied consistently, relieving the programmer of that burden. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James J. Horning. </author> <title> What the compiler should tell the user. </title> <editor> In F. L. Bauer and J. Eickel, editors, </editor> <title> Compiler Construction: An Advanced Course, </title> <booktitle> chapter 5.D, </booktitle> <pages> pages 525-548. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1976. </year> <note> Originally published as LNCS Vol. 21. </note>
Reference-contexts: The technique itself is a simple programming discipline: keep track of intermediate results that are unavailable because of a previously detected error. The idea behind this discipline is old; for example, Horning <ref> [1] </ref> recommends that spurious error messages related to an identifier be suppressed by entering the identifier into the symbol table with a special "error entry" flag.
Reference: [2] <author> C. W. Johnson and C. Runciman. </author> <title> Semantic errors diagnosis and repair. </title> <booktitle> In Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 88-97. </pages> <publisher> ACM, ACM, </publisher> <year> 1982. </year>
Reference-contexts: The idea behind this discipline is old; for example, Horning [1] recommends that spurious error messages related to an identifier be suppressed by entering the identifier into the symbol table with a special "error entry" flag. Johnson and Runciman <ref> [2] </ref> extend the idea beyond symbol-table entries; when their compiler detects a semantic error, "offending parts of the internal program representation are replaced by substitutes that cannot arise from an error-free program." The contribution of this paper is to show how to exploit features of a modern functional programming language to <p> Using the error type constructor gives the compiler writer superior control, since it can be applied selectively not only to types, but to components of structured types, or to different values of the same type. Johnson and Runciman <ref> [2] </ref> do not use attribute grammars. Their York Ada Workbench compiler uses an internal representation based on trees, and when it detects a semantic error, it issues a message and replaces the offending tree node with a "plastic" node.
Reference: [3] <author> Robin Milner, Mads Tofte, and Robert W. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The features used are exceptions, higher-order functions, polymorphism, and static type checking, and the functional language is Standard ML <ref> [3] </ref>. By exploiting this combination, we not only reduce the effort required to implement the discipline, but we get the ML compiler, not the programmer, to check that the discipline is applied correctly.
Reference: [4] <author> Jeffrey D. Ullman. </author> <title> Elements of ML Programming. </title> <publisher> Prentice Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: By exploiting this combination, we not only reduce the effort required to implement the discipline, but we get the ML compiler, not the programmer, to check that the discipline is applied correctly. Ullman <ref> [4] </ref> presents ML at a level suitable for understanding this paper. 2 Representing faulty intermediate results The essence of the technique is to write most functions under the assumption that their arguments are always valid, then to apply combinators to handle cases 2 in which the arguments may have been invalidated
Reference: [5] <author> Norman Ramsey and Mary F. Fernandez. </author> <title> Specifying representations of machine instructions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1997. To appear. </note>
Reference-contexts: I have used the combinators in this paper to help build a new compiler for the SLED specification language for encoding and decoding of machine instructions <ref> [5] </ref>. In SLED, one defines assembly-language and binary representations for such elements as opcodes, addressing modes, and instructions. SLED therefore has declarations and expressions, but no statements. I use the error combi-nators mostly in the symbol table, in the elaboration of expressions, and in the elaboration of higher-level specifications.
Reference: [6] <author> Mike Beaven and Ryan Stansifer. </author> <title> Explaining type errors in polymorphic languages. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):17-30, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: The reported location of the error may be far away from the code that causes the error, and the error message itself may confuse those who don't understand the underlying unification algorithm. Elaborate methods have been proposed to help users understand errors in type inference <ref> [6, 7, 8] </ref>.
Reference: [7] <author> Karen L. Bernstein and Eugene W. Stark. </author> <title> Debugging type errors. </title> <type> Technical report, </type> <institution> State University of New York at Stony Brook, Computer Science Department, </institution> <month> October </month> <year> 1995. </year> <month> 14 </month>
Reference-contexts: The reported location of the error may be far away from the code that causes the error, and the error message itself may confuse those who don't understand the underlying unification algorithm. Elaborate methods have been proposed to help users understand errors in type inference <ref> [6, 7, 8] </ref>.
Reference: [8] <author> Dominic Duggan and Frederick Bent. </author> <title> Explaining type inference. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 7(1), </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: The reported location of the error may be far away from the code that causes the error, and the error message itself may confuse those who don't understand the underlying unification algorithm. Elaborate methods have been proposed to help users understand errors in type inference <ref> [6, 7, 8] </ref>.
Reference: [9] <author> Michael G. Burke and Gerald A. Fisher. </author> <title> A practical method for LR and LL syntactic error diagnosis and recovery. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(2) </volume> <pages> 164-167, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: support this reporting strategy, but the mutation of the symbol table would be awkward, since it is not in the style of ML programming to mutate the symbol table after building it. 6 Related work There are many published papers about recovery from syntactic errors, so that parsing can continue <ref> [9, 10] </ref>. Chapter 17 of Fischer and LeBlanc [11] surveys the field. By contrast, semantic errors and their processing are rarely discussed| perhaps, as David Gries suggested twenty years ago, because they haven't been formalized [12]. A handful of researchers have used attribute grammars to formalize semantic errors.
Reference: [10] <author> Bruce J. McKenzie, Corey Yeatman, and Lorraine De Vere. </author> <title> Error repair in shift-reduce parsers. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 672-689, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: support this reporting strategy, but the mutation of the symbol table would be awkward, since it is not in the style of ML programming to mutate the symbol table after building it. 6 Related work There are many published papers about recovery from syntactic errors, so that parsing can continue <ref> [9, 10] </ref>. Chapter 17 of Fischer and LeBlanc [11] surveys the field. By contrast, semantic errors and their processing are rarely discussed| perhaps, as David Gries suggested twenty years ago, because they haven't been formalized [12]. A handful of researchers have used attribute grammars to formalize semantic errors.
Reference: [11] <author> Charles N. Fischer and Richard J. LeBlanc, Jr. </author> <title> Crafting a Compiler. </title> <address> Ben-jamin/Cummings, Menlo Park, CA, </address> <year> 1988. </year>
Reference-contexts: Chapter 17 of Fischer and LeBlanc <ref> [11] </ref> surveys the field. By contrast, semantic errors and their processing are rarely discussed| perhaps, as David Gries suggested twenty years ago, because they haven't been formalized [12]. A handful of researchers have used attribute grammars to formalize semantic errors.
Reference: [12] <author> David Gries. </author> <title> Error recovery and correction | an introduction to the literature. </title> <editor> In F. L. Bauer and J. Eickel, editors, </editor> <title> Compiler Construction: An Advanced Course, </title> <booktitle> chapter 6.C, </booktitle> <pages> pages 627-638. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1976. </year> <note> Originally published as LNCS Vol. 21. </note>
Reference-contexts: Chapter 17 of Fischer and LeBlanc [11] surveys the field. By contrast, semantic errors and their processing are rarely discussed| perhaps, as David Gries suggested twenty years ago, because they haven't been formalized <ref> [12] </ref>. A handful of researchers have used attribute grammars to formalize semantic errors. Adorni, Boccalatte, and Di Manzo [13, 14] extend LL (1) techniques for syntactic error recovery.
Reference: [13] <author> A. Boccalatte, M. Di Manzo, and D. Sciarra. </author> <title> Error recovery with attribute grammars. </title> <journal> The Computer Journal, </journal> <volume> 25(3) </volume> <pages> 331-337, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: By contrast, semantic errors and their processing are rarely discussed| perhaps, as David Gries suggested twenty years ago, because they haven't been formalized [12]. A handful of researchers have used attribute grammars to formalize semantic errors. Adorni, Boccalatte, and Di Manzo <ref> [13, 14] </ref> extend LL (1) techniques for syntactic error recovery. Their algorithm, which combines parsing and attribute evaluation, can detect a semantic error at the first incorrect symbol; that is, the symbols parsed are a prefix of some program that is both syntactically and semantically correct.
Reference: [14] <author> G. Adorni, A. Boccalatte, and M. Di Manzo. </author> <title> Top-down semantic analysis. </title> <journal> The Computer Journal, </journal> <volume> 27(3) </volume> <pages> 233-237, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: By contrast, semantic errors and their processing are rarely discussed| perhaps, as David Gries suggested twenty years ago, because they haven't been formalized [12]. A handful of researchers have used attribute grammars to formalize semantic errors. Adorni, Boccalatte, and Di Manzo <ref> [13, 14] </ref> extend LL (1) techniques for syntactic error recovery. Their algorithm, which combines parsing and attribute evaluation, can detect a semantic error at the first incorrect symbol; that is, the symbols parsed are a prefix of some program that is both syntactically and semantically correct.
Reference: [15] <author> Kai Koskimies. </author> <title> A specification language for one-pass semantic analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, volume 19(6) of ACM SIGPLAN Notices, </booktitle> <pages> pages 179-189, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: By contrast, the techniques in this paper do not attempt to recover from errors; instead, they help us create compilers that can digest incorrect constructs without causing 11 further errors later on. Koskimies <ref> [15] </ref> describes Lisa, a specification language based on attribute grammars, in which "check clauses" give conditions on attributes that must hold if the program is correct.
Reference: [16] <author> Norman Ramsey. </author> <title> Literate programming simplified. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 97-105, </pages> <month> September </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: The views expressed are those of the author and should not be taken to be those of the DoD. Appendix This paper was prepared with the noweb tool for literate programming <ref> [16] </ref>. The examples, together with supporting code, have been extracted from the paper and compiled with Standard ML of New Jersey, version 109.17. This exercise ensures that the code in the examples type-checks, and that the types match those given in declarations and in Table 1.
References-found: 16

