URL: ftp://st.cs.uiuc.edu/pub/papers/refactoring/opdyke-thesis.ps.Z
Refering-URL: http://st-www.cs.uiuc.edu/users/brant/Refactory/RefactoringBrowser.html
Root-URL: http://www.cs.uiuc.edu
Title: REFACTORING OBJECT-ORIENTED FRAMEWORKS  
Author: BY WILLIAM F. OPDYKE 
Degree: THESIS Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science in the Graduate College of the  
Date: 1982  
Address: 1979  1979 M.S., University of Wisconsin Madison,  1992 Urbana, Illinois  
Affiliation: B.S., Drexel University,  B.S., Drexel University,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: This assumption, while safe, prevents many optimizations. One can expect to do better if the effects of a call are more carefully analyzed. The analysis of the effects of a call is generally termed interprocedural data flow analysis. <ref> [1, 44, 106] </ref> 7.3.1 Interprocedural Data Flow Analysis A procedure or subprogram can be represented as a data flow graph of basic blocks, where directed edges connecting the basic blocks represent the flow of control within the procedure.
Reference: [2] <author> E. Allman and M. Stonebraker. </author> <title> Observations on the evolution of a software system. </title> <journal> Computer, </journal> <volume> 15(6) </volume> <pages> 27-32, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Since programmers' perceptions differ from each other, and a programmer's perception can change over time, the notion of software structure is dynamic. Many factors can contribute to poor software structure. These factors include an inadequate design methodology [14], absence of development and maintenance standards <ref> [2] </ref>, buggy optimizations [113] and expedient but poorly conceived changes made to the software system to reflect changes in the environment in which it operates [25]. 7 Weinberg in [123] suggests that very small changes to a software system are much more prone to error than larger changes, because people tend
Reference: [3] <author> Robert S. Arnold. </author> <title> An introduction to software restructuring. Tutorial on Software Restructuring (Robert S. </title> <editor> Arnold, ed.), </editor> <year> 1986. </year>
Reference-contexts: Some restructurings modify a component to make it more reusable; such components can be easier to compose together for an application. The following section discusses software restructuring. 2.2 Background: Software Restructuring Software sometimes needs to be restructured before it is reused. Arnold <ref> [3] </ref> defines software restructuring as "the modification of software to make the software (1) easier to understand and to change or (2) less susceptible to error when future changes are made." A major goal of software restructuring is to preserve or increase the value of a piece of software. <p> However, it can also be applied in the earlier design and development phases. Software structure can be broadly defined as a collection of software attributes that make sense to the perceiver <ref> [3] </ref>. Since programmers' perceptions differ from each other, and a programmer's perception can change over time, the notion of software structure is dynamic. Many factors can contribute to poor software structure.
Reference: [4] <author> E. Ashcroft and Z. Manna. </author> <title> The translation of "goto" programs in "while" programs. </title> <booktitle> In Proceedings of the 1971 IFIP Congress, </booktitle> <pages> pages 250-260. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. Several techniques have been developed based on structured programming guidelines; these include goto elimination <ref> [4, 20, 128] </ref>, case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability.
Reference: [5] <author> AT&T. </author> <title> UNIX System V User Reference Manual. </title> <journal> AT&T, </journal> <year> 1984. </year>
Reference-contexts: Thus, instances of the Inode class represented inodes for BSD UNIX file systems. A series of changes, shown in Figure 3.1, were made to generalize the Inode class in order to support both BSD UNIX and UNIX System V <ref> [5] </ref> file formats: 1. the Inode class was renamed to BSDInode, 2. the SystemVInode class was added as a subclass of MemoryObject; variables and functions were copied from the BSDInode class, and modified, 3. the Inode class was added as a subclass of MemoryObject and as an abstract superclass of BSDInode
Reference: [6] <author> Maurice J. Bach. </author> <title> The Design of the UNIX Operating System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: Many parts of the file system are MemoryObjects, such as files and disks. An Inode 4 contains a description of the disk layout of a file and other information such as the file owner, access permissions and access times <ref> [6] </ref>.
Reference: [7] <author> B. S. Baker. </author> <title> An algorithm for structured programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 98-120, </pages> <year> 1977. </year>
Reference-contexts: Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches [56, 118] repeatedly traverse the flow graphs until there are no more changes. Structured solutions (e.g., <ref> [7, 67, 107] </ref>) are more complex, but have much better worse case performance. 7.4 Checking Whether a Predicate is a Class Invariant In general, the problem of determining whether an arbitrary predicate is a class invariant is undecidable.
Reference: [8] <author> Robert Balzer. </author> <title> A fifteen-year perspective on automatic programming. </title> <booktitle> In Software Reusability Volume II: Applications and Experience, </booktitle> <pages> pages 289-311, </pages> <year> 1989. </year>
Reference-contexts: Research into more ambitious forms of program transformations and automatic programming has been underway for over 15 years. Early work in this area was done by Burstall and Darlington [27]; extensive work has been done by Balzer and others at USC/ISI <ref> [8] </ref>, including recent work into building an evolution transformation library [61]. This work has focused on the process of converting a formal specification into an efficient implementation. Examples of behavior preserving transformations are: * folding and unfolding. <p> On the other hand, it is difficult to correctly define the input to these systems. As Balzer notes in <ref> [8] </ref>, one of the chief failures in program transformation systems has been the unreadability of their specification languages. It has taken a high level of user sophistication, both in the application domain and in the domain of specification languages and transformations, to apply many automatic programming approaches.
Reference: [9] <author> Jay Banerjee and Won Kim. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <year> 1987. </year>
Reference-contexts: A refactoring tool can help a designer by providing the right set of refactorings, and by ensuring that each refactoring is applied correctly, but it cannot decide which refactorings to apply. Thus, refactoring cannot be completely automated. To understand how people refactor programs, related research <ref> [9, 30, 59, 71, 98] </ref> was surveyed, and an analysis was done of the structural changes made to the Choices file system framework [77] over a two year period. The Choices file system framework was developed using 3 the C++ programming language [114]. <p> Distinct Class Names. After refactoring, each class must have a unique name. In this research, classes are not nested; that is, the scope of each class is the entire program. 1 They are similar to the properties analyzed in <ref> [9, 31] </ref>. Those efforts focused on restructurings involving program data, while this research considers structural changes to both functions and data. <p> from the constraints defined on specific classes. 10 He distinguishes these from preconditions and postconditions defined on routines. 11 His invariant rule also requires that, when these procedures are applied, the arguments and state satisfy the preconditions for the procedures. 12 Casais [31] compares the GemStone R fl [92], Orion <ref> [9] </ref>, O 2 and OTGen object-oriented database systems with respect to class invariants. <p> Schemas evolve over time; many of the changes made to schemas in OODBs are similar to refactorings. Schema evolution has been studied for several OODB systems, most notably ORION <ref> [9, 66] </ref>. 2 Just as with refactoring, the methodology for handling schema changes has included: * developing a taxonomy of changes * defining a set of properties that must remain invariant across schema changes * defining the changes in the taxonomy in a way that preserves these properties. .
Reference: [10] <editor> D. R. Barstow, H. E. Shrobe, and E. Sandewall. </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: Lyons [75] and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions. Other tools to support software restructuring include pretty printers and code formatters, integrated programming environments <ref> [10, 122] </ref> and rule-based program transformation systems [91]. Software restructuring continues to be an important area of software engineering research. 2.3 Object-Oriented Programming, Reuse and Restructuring Object-oriented programming is often touted as promoting software reuse [45]. However, it is not a panacea.
Reference: [11] <author> V. Basili. </author> <title> Tutorial on Models and Metrics for Software Management and Engineering. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1980. </year>
Reference-contexts: Many other software restructuring approaches involve code changes. A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics <ref> [11] </ref>, maintainability measures [26] or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [12] <author> Carol Sue Beckman-Davies. </author> <title> Finding Program Differences Based on Syntactic Tree Structure. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: Before the function body can be migrated to the superclass, differences need to be separated from the common code. The approaches for detecting program differences involve string comparison, tree comparison or a combination of these techniques <ref> [12] </ref>. Program differences have been studied in regard to spelling correction [54, 109], parsing error correction [119], version storage [99] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. <p> The user specifies the cost of insertion, replacements and deletion of particular elements. Dynamic programming is used to build a cost table; then, the table is analyzed to find the minimum cost sequence. Several refinements have been proposed <ref> [12] </ref>. String comparison algorithms have their limitations. In comparing two programs, one limitation is that often there is no way to relate changes with each other. <p> This shortcoming can be overcome by expanding the difference region until it corresponds to a syntactically meaningful program part. Beckman-Davies <ref> [12] </ref> analyzed string and tree comparison approaches (and hybrid approaches) for finding program differences. That analysis showed that no approach is optimal in all cases.
Reference: [13] <author> Boris Beizer. </author> <title> Software Testing Techniques. </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1983. </year>
Reference-contexts: Creating a Program Entity: (a) creating an empty class (b) creating a member variable (c) creating a member function. 7 In the software testing literature, black box denotes functional testing and white box denotes structural testing. The two types of testing are compared in <ref> [13] </ref>. 22 2. Deleting a Program Entity: (a) deleting an unreferenced class (b) deleting an unreferenced variable (c) deleting a set of member functions. 3.
Reference: [14] <author> G. D. Bergland. </author> <title> A guided tour of program design methodologies. </title> <journal> Computer, </journal> <volume> 14(10) </volume> <pages> 18-37, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: Since programmers' perceptions differ from each other, and a programmer's perception can change over time, the notion of software structure is dynamic. Many factors can contribute to poor software structure. These factors include an inadequate design methodology <ref> [14] </ref>, absence of development and maintenance standards [2], buggy optimizations [113] and expedient but poorly conceived changes made to the software system to reflect changes in the environment in which it operates [25]. 7 Weinberg in [123] suggests that very small changes to a software system are much more prone to
Reference: [15] <author> Paul L. Bergstein. </author> <title> Object-preserving class transformations. </title> <booktitle> In Proceedings of OOPSLA `91, </booktitle> <year> 1991. </year>
Reference-contexts: Johnson and Foote [59] propose design rules to support reusable classes. The authors argue that restructuring an object-oriented program in line with these guidelines will improve its reusability and maintainability. Very recent research has investigated some of the issues involved in restructuring object oriented programs <ref> [15, 31] </ref>. Those efforts have tended to focus on inheritance, to achieve such goals as eliminating duplicate definitions of a variable in a program. Refactoring is much more complex that this, however. <p> It can be generalized to work with any number of classes. Casais [30] and Bergstein <ref> [15] </ref> note that a useful behavior preserving program transformation is to move a function or variable to a common superclass from subclasses where it is identically defined. However, as this chapter describes defining an abstract superclass involves more than just moving up identically defined members. <p> There are tools for converting between textual and graphical representations of class dictionaries, for uncovering subgraphs of related objects called propagation patterns, and for generated C++ source code from their representations. Bergstein <ref> [15] </ref> defined a set of object preserving class transformations that can be applied to class dictionary graphs.
Reference: [16] <author> Ted Biggerstaff and Charles Richter. </author> <title> Reusability framework, assessment, and directions. Tutorial: Software Reuse Emerging Technology (Will Tracz, </title> <editor> ed.), </editor> <year> 1988. </year>
Reference-contexts: Biggerstaff and Richter note that the fundamental problem preventing successful design level reuse is finding the right representation of design. Such a representation should <ref> [16] </ref>: * represent knowledge about implementation structures in a factored form * permit partial specifications that can be incrementally extended * allow flexible couplings between a design and its various interpretations * support degrees of abstraction and precision. An important object-oriented technique for facilitate design-level reuse is an application framework.
Reference: [17] <author> Ted J. Biggerstaff. </author> <title> Design recovery for maintenance and reuse. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 36-49, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Improving a programmer's perception of the structure of a software system doesn't necessarily require modifying the code. Design recovery is a software reengineering approach that recreates design abstractions from a collection of code, existing documentation, general knowledge of the domain and heuristic reasoning <ref> [17, 34] </ref>. Design recovery has been proposed using program structures (cliches) and graph parsing [97], a heuristic-based concept-recognition mechanism with multiple views of program knowledge [55], and an approach using an intermediate modular interconnection language to generate design descriptions [35]. None of these approaches involve code changes.
Reference: [18] <author> Ted J. Biggerstaff and Alan J. Perlis (eds). </author> <title> Software Reusability Volume I: Concepts and Models. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1989. </year>
Reference-contexts: Reuse does not happen by accident; one needs to plan to reuse software and look for software to reuse. Reuse requires the right attitude, tools and techniques [59, 117]. Tools and techniques to support software reuse include compositional and generational approaches <ref> [18] </ref>. The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. The components might be code skeletons [32, 68], subroutines [32, 68, 96] or functions.
Reference: [19] <author> Ted J. Biggerstaff and Charles Richter. </author> <title> Reusability framework, assessment, and directions. </title> <booktitle> In Software Reusability Volume I: Concepts and Models, </booktitle> <pages> pages 1-19, </pages> <year> 1989. </year>
Reference-contexts: Closely related to software reuse is software maintenance, where knowledge about a software system is used to develop a version that refines or extends it. 1 Approaches that support reuse address one or more of the following four important aspects <ref> [19] </ref>: 1. finding a reusable component. This is usually is not as simple as finding an exact match, but rather involves finding the most similar component. 2. understanding the component.
Reference: [20] <author> C. Bohm and G. Jacopini. </author> <title> Flow diagrams, turing machines, and languages with only two formation rules. </title> <journal> Communications of the ACM, </journal> <volume> 9(5) </volume> <pages> 366-371, </pages> <month> May </month> <year> 1966. </year>
Reference-contexts: Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. Several techniques have been developed based on structured programming guidelines; these include goto elimination <ref> [4, 20, 128] </ref>, case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability.
Reference: [21] <author> Grady Booch. </author> <title> Object-Oriented Design. </title> <address> Benjamin/Cummings, </address> <year> 1990. </year>
Reference-contexts: The clarity of a design can be compromised if refactorings are applied "blindly" to optimize conformance to other design criteria, such as minimizing program size or minimizing access to variables. 1 Other approaches to object-oriented analysis and design include <ref> [21] </ref> and [36]. 118 10.2 Designing Reusable Classes This refactoring research directly builds on research done at the University of Illinois by John-son and Foote to support reusable classes [59].
Reference: [22] <author> P. Borras and D. Clement. </author> <title> Centaur: the system. </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 14-24, </pages> <year> 1988. </year>
Reference-contexts: The most well-known of these systems for generating program development environments are the (Cornell) Synthesizer Generator [95], GANDALF [84] and CENTAUR <ref> [22] </ref>. Ideally, these systems could be used to generate the software refactory. They have built in facilities for generating parsers that convert source into abstract syntax trees and pretty printers that convert abstract syntax trees into source, and provide other support such as language directed editing and version management.
Reference: [23] <author> James M. Boyle. </author> <title> Abstract programming and program transformation an approach to reusing programs. </title> <booktitle> In Software Reusability Volume I: Concepts and Models, </booktitle> <pages> pages 361-414, </pages> <year> 1989. </year>
Reference-contexts: The components might be code skeletons [32, 68], subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems <ref> [23, 33, 43, 83] </ref> are examples of generation-based systems. Software restructuring relates to each of the four important aspects of reuse listed above. Restructuring a program can make it easier to understand the design of a program and can assist in finding reusable components.
Reference: [24] <author> Frederick P. Brooks. </author> <title> No silver bullet essence and accidents of software engineering. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: The final three chapters provide extended examples, survey closely related work, briefly discuss an implementation of the approach and present conclusions. 5 Chapter 2 Motivation A software project "is capable of becoming a monster of missed schedules, blown budgets and flawed products" <ref> [24] </ref>. One approach to achieving meaningful reductions in software costs is to acquire an existing software system rather than developing a new one. Often, however, the available software systems do not provide an exact fit for the problem at hand. <p> This is usually is not as simple as finding an exact match, but rather involves finding the most similar component. 2. understanding the component. Understanding what a component does is important in order to use it, but developing that mental model is difficult <ref> [24, 88] </ref>. 1 Most (60%) of the activities analyzed in Osborne's software maintenance study [80], were found neither to be corrective (that is, diagnosing and fixing errors) nor adaptive (changing software to work with new hardware and peripherals) but rather were perfective activities, where pressure was brought to bear on developers <p> The important point here is that these issues do not disappear when object-oriented technology is introduced. One of the essential difficulties in developing software is that the software must conform to human institutions and systems that interface with it, and that those forces are constantly changing <ref> [24] </ref>. Nonetheless, the motivation to restructure object-oriented programs is somewhat different from the motivation for many software restructuring approaches in the past. Many of the software restructuring techniques described earlier were motivated by the need to understand and evolve unstructured or poorly structured programs.
Reference: [25] <author> P. J. Brown. </author> <title> Why does software die? Infotech State of the Art Report, </title> <booktitle> 8(7) </booktitle> <pages> 32-45, </pages> <year> 1980. </year>
Reference-contexts: Many factors can contribute to poor software structure. These factors include an inadequate design methodology [14], absence of development and maintenance standards [2], buggy optimizations [113] and expedient but poorly conceived changes made to the software system to reflect changes in the environment in which it operates <ref> [25] </ref>. 7 Weinberg in [123] suggests that very small changes to a software system are much more prone to error than larger changes, because people tend to take very small changes less seriously and are therefore less likely to test them adequately.
Reference: [26] <author> K. Burns. </author> <title> Using automated techniques to improve the maintainability of existing software. </title> <booktitle> In DSSD User's Conference/6 Maintenance, </booktitle> <pages> pages 33-39, </pages> <year> 1981. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures <ref> [26] </ref> or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [27] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: Return statements are converted to branch/goto statements (at the end of the statement list). 2. replaces the function call with the equivalent statement list. 8 Issues involved in inlining functions calls are detailed in the program transformation literature <ref> [27] </ref>. 49 The only problem with inlining a called function is that the function may reference private or protected members that the calling function can't reference. By precondition one, all references are visible to the caller. Thus, the statement list is semantically equivalent to the function call it replaces. <p> Research into more ambitious forms of program transformations and automatic programming has been underway for over 15 years. Early work in this area was done by Burstall and Darlington <ref> [27] </ref>; extensive work has been done by Balzer and others at USC/ISI [8], including recent work into building an evolution transformation library [61]. This work has focused on the process of converting a formal specification into an efficient implementation. Examples of behavior preserving transformations are: * folding and unfolding.
Reference: [28] <author> M. H. Burstein. </author> <title> Concept formation by incremental analogical reasoning and debugging. Machine Learning: An Artificial Intelligence Approach (R.S. </title> <editor> Michalski, J. G. Carbonell and T. M. Mitchell, eds), </editor> <volume> 2 </volume> <pages> 351-370, </pages> <year> 1986. </year>
Reference-contexts: These heuristics detect similarities based on a small set of structural attributes. More powerful similarity detection is possible, as discussed in the artificial intelligence machine learning literature on analogy-based systems <ref> [28, 39, 51, 64] </ref>. Analogy-based systems have very limited power unless their analysis is based on a well-defined domain model.
Reference: [29] <author> R. Canning. </author> <title> Rejuvenate your old systems. </title> <journal> EDP Analyzer, </journal> <volume> 22(3) </volume> <pages> 1-16, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. <p> Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., <ref> [29] </ref>). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability. Lyons [75] and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions.
Reference: [30] <author> Eduardo Casais. </author> <title> Reorganizing an Object System, </title> <type> pages 161-189. </type> <institution> Centre Universitair d'Informatique, Universite de Geneve, </institution> <year> 1989. </year>
Reference-contexts: A refactoring tool can help a designer by providing the right set of refactorings, and by ensuring that each refactoring is applied correctly, but it cannot decide which refactorings to apply. Thus, refactoring cannot be completely automated. To understand how people refactor programs, related research <ref> [9, 30, 59, 71, 98] </ref> was surveyed, and an analysis was done of the structural changes made to the Choices file system framework [77] over a two year period. The Choices file system framework was developed using 3 the C++ programming language [114]. <p> It can be generalized to work with any number of classes. Casais <ref> [30] </ref> and Bergstein [15] note that a useful behavior preserving program transformation is to move a function or variable to a common superclass from subclasses where it is identically defined. However, as this chapter describes defining an abstract superclass involves more than just moving up identically defined members. <p> Recall from section 6.1 that the classes that shared a common abstraction were passed as arguments to the refactoring that created the superclass. Casais <ref> [30] </ref> describes a global reorganization scheme that is based on recognizing classes with common attributes. Classes are automatically brought together that share common attributes, and higher level classes are introduced to contain the common members.
Reference: [31] <author> Eduardo Casais. </author> <title> Managing Evolution in Object Oriented Environments: An Algorithmic Approach. </title> <type> PhD thesis, </type> <institution> University of Geneva, </institution> <year> 1991. </year>
Reference-contexts: Often, however, object-oriented software cannot be reused without first being restructuring. There are several reasons for this <ref> [31, 59] </ref>: 1. When developing a software application, it is difficult to determine a priori what classes embody the important concepts for that application and how they interrelate. Experience has shown that a useful taxonomy of classes is discovered through an iterative process of exploration. <p> Johnson and Foote [59] propose design rules to support reusable classes. The authors argue that restructuring an object-oriented program in line with these guidelines will improve its reusability and maintainability. Very recent research has investigated some of the issues involved in restructuring object oriented programs <ref> [15, 31] </ref>. Those efforts have tended to focus on inheritance, to achieve such goals as eliminating duplicate definitions of a variable in a program. Refactoring is much more complex that this, however. <p> Distinct Class Names. After refactoring, each class must have a unique name. In this research, classes are not nested; that is, the scope of each class is the entire program. 1 They are similar to the properties analyzed in <ref> [9, 31] </ref>. Those efforts focused on restructurings involving program data, while this research considers structural changes to both functions and data. <p> To handle this, the code that differed between the two implementations was placed into new functions getDirect and setDirect which were added to the subclasses. Then, in both definitions of the mapUnit 1 Casais <ref> [31] </ref> similarly observes that renamings and other attribute refinements are sometimes needed before functions and variables are migrated to an abstract superclass. 56 AFTER: Inode Protected: virtual int getDirect () virtual void setDirect (..) int mapUnit (...) - * index = getDirect () * setDirect (index) * - BSDInode (and SystemVInode) <p> The chapter closes with a discussion of how interaction with the designer might be reduced, and other issues. Casais <ref> [31] </ref> deals with several of the issues discussed in this chapter: renamings, refining function signatures and variable attributes, and moving members. One important step defined here that is not addressed by Casais [31] is how to separate out the differences between corresponding functions defined in both subclasses, making them match, before <p> Casais <ref> [31] </ref> deals with several of the issues discussed in this chapter: renamings, refining function signatures and variable attributes, and moving members. One important step defined here that is not addressed by Casais [31] is how to separate out the differences between corresponding functions defined in both subclasses, making them match, before migrating common code to the superclass. That step closely relates with the other steps defined in this chapter. There are other ways in which this work is different from [31]: it provides <p> by Casais <ref> [31] </ref> is how to separate out the differences between corresponding functions defined in both subclasses, making them match, before migrating common code to the superclass. That step closely relates with the other steps defined in this chapter. There are other ways in which this work is different from [31]: it provides some heuristics for detecting structural similarities, includes access control mode as an attribute that can be refined, and discusses some of the tradeoffs involving user/tool interaction. Before a function signature or variable can be added to the superclass, it must first be defined compatibly in the subclasses. <p> By contrast, refactoring uses a class invariant to simplify the internals of the class; for these purposes the invariant must also remain true as viewed from inside the class. Another use of the term class invariant is made by Casais in <ref> [31] </ref>. <p> the language being used, but they are distinct from the constraints defined on specific classes. 10 He distinguishes these from preconditions and postconditions defined on routines. 11 His invariant rule also requires that, when these procedures are applied, the arguments and state satisfy the preconditions for the procedures. 12 Casais <ref> [31] </ref> compares the GemStone R fl [92], Orion [9], O 2 and OTGen object-oriented database systems with respect to class invariants. <p> As with Bergstein's approach described above, Casais' focus was upon inheritance related changes. He defines four means for supporting evolution <ref> [31] </ref>: * tailoring, where the existing class definitions are not directly modified, but adaptations are applied to inherited properties when deriving new subclasses. For example, when introducing a new subclass a function inherited from its superclass may be overridden. <p> Casais' research makes important contributions including the characterization of changes into the four categories listed above, his local and global reorganization strategies, and his 121 object model. However, as he notes in <ref> [31] </ref>, his reorganization algorithms deal exclusively with inheritance. There is no facility for splitting methods, restructuring their code, or changing the client/server relationship between classes. These areas are addressed in the refactoring research, as Casais cites in [31]. Splitting and restructuring functions is covered in chapter six. <p> However, as he notes in <ref> [31] </ref>, his reorganization algorithms deal exclusively with inheritance. There is no facility for splitting methods, restructuring their code, or changing the client/server relationship between classes. These areas are addressed in the refactoring research, as Casais cites in [31]. Splitting and restructuring functions is covered in chapter six. <p> Some research into OODBs has considered versioning issues and multiple inheritance, outside the scope of this refactoring research. Conversely, OODB research has not focused on 2 Other systems include Gemstone [92], O 2 and OTGen. Casais <ref> [31] </ref> compares features of these object-oriented database systems with regard to schema evolution. 122 several topics important in refactoring, such as simplifying conditional expressions using invari-ants, and converting an association modeled using inheritance into an aggregation. 10.7 Program Transformations Refactorings support change by performing a type of program transformation. <p> The set of refactorings may need to be extended to handle programming styles that, while unusual or non-standard, are nonetheless used in the organization. A refactoring tool must integrate well with other tools that support change management and other software development tasks in an organization <ref> [31, 85] </ref>. Large software organizations are often resistant to change; changing the names, behavior, interrelationships and responsibilities of objects can have political as well as technical implications.
Reference: [32] <author> Michael J. Cavaliere. </author> <title> Reusable code at the Hartford Insurance Group. </title> <booktitle> In Software Reusability Volume II: Applications and Experience, </booktitle> <pages> pages 131-142, </pages> <year> 1989. </year>
Reference-contexts: Tools and techniques to support software reuse include compositional and generational approaches [18]. The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. The components might be code skeletons <ref> [32, 68] </ref>, subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems [23, 33, 43, 83] are examples of generation-based systems. <p> The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. The components might be code skeletons [32, 68], subroutines <ref> [32, 68, 96] </ref> or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems [23, 33, 43, 83] are examples of generation-based systems.
Reference: [33] <author> Thomas E. Cheatham. </author> <title> Reusability through program transformations. </title> <booktitle> In Software Reusability Volume I: Concepts and Models, </booktitle> <pages> pages 321-336, </pages> <year> 1989. </year> <month> 135 </month>
Reference-contexts: The components might be code skeletons [32, 68], subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems <ref> [23, 33, 43, 83] </ref> are examples of generation-based systems. Software restructuring relates to each of the four important aspects of reuse listed above. Restructuring a program can make it easier to understand the design of a program and can assist in finding reusable components.
Reference: [34] <author> Elliot J. Chikofsky. </author> <title> Reverse engineering and design recovery: A taxonomy. </title> <journal> IEEE Software, </journal> <pages> pages 13-17, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Improving a programmer's perception of the structure of a software system doesn't necessarily require modifying the code. Design recovery is a software reengineering approach that recreates design abstractions from a collection of code, existing documentation, general knowledge of the domain and heuristic reasoning <ref> [17, 34] </ref>. Design recovery has been proposed using program structures (cliches) and graph parsing [97], a heuristic-based concept-recognition mechanism with multiple views of program knowledge [55], and an approach using an intermediate modular interconnection language to generate design descriptions [35]. None of these approaches involve code changes.
Reference: [35] <author> Song C. Choi and Walt Scacchi. </author> <title> Extracting and restructuring the design of large systems. </title> <journal> IEEE Software, </journal> <pages> pages 66-71, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Design recovery has been proposed using program structures (cliches) and graph parsing [97], a heuristic-based concept-recognition mechanism with multiple views of program knowledge [55], and an approach using an intermediate modular interconnection language to generate design descriptions <ref> [35] </ref>. None of these approaches involve code changes. Also, they do not directly address how to change the implementation once the existing structure is understood; although clearly the knowledge gathered during software reengineering should help a developer determine where changes need to be made.
Reference: [36] <author> Peter Coad and Ed Yourdon. </author> <title> OOA - Object-Oriented Analysis. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: The clarity of a design can be compromised if refactorings are applied "blindly" to optimize conformance to other design criteria, such as minimizing program size or minimizing access to variables. 1 Other approaches to object-oriented analysis and design include [21] and <ref> [36] </ref>. 118 10.2 Designing Reusable Classes This refactoring research directly builds on research done at the University of Illinois by John-son and Foote to support reusable classes [59]. To improving the design of an object oriented system, they define rules of thumbs for finding standard protocols, abstract classes and frameworks.
Reference: [37] <institution> Department of Electrical Engineering Computer Science Division and Computer Science. UNIX Programmer's Manual, 4.2 Berkeley Software Distribution, </institution> <type> Virtual VAX-11 Version. </type> <institution> University of California at Berkeley, </institution> <month> August </month> <year> 1983. </year>
Reference-contexts: UNIX is a registered trademark of UNIX Systems Laboratories, Inc. 13 BEFORE: MemoryObject Inode (BSD) DURING: BSDInode SystemVInode MemoryObject Steps 1 & 2: AFTER: MemoryObject BSDInode SystemVInode Inode Steps 3 & 4: An early version of the Choices file system framework only supported the BSD UNIX <ref> [37] </ref> operating system functions and formats. Thus, instances of the Inode class represented inodes for BSD UNIX file systems.
Reference: [38] <author> Curtis, Krasner, and Iscoe. </author> <title> A field study of the software design process for large systems. </title> <journal> Communications of the ACM 31:11, </journal> <pages> pages 1268-1287, </pages> <year> 1988. </year>
Reference-contexts: Refactorings do not force upon a designer a rigid, top down design style. Experience has shown that the development of a large software program does not proceed in a purely top down manner <ref> [38, 89] </ref>. Software design is in many ways an informal process [63]. Refactorings support iterative conceptual shifts. For example, the refactoring that defines an abstract superclass generates a common design abstraction from low-level implementation; this design abstraction can then be used for further low level implementation.
Reference: [39] <author> N. Dershowitz. </author> <title> Programming by analogy. Machine Learning: An Artificial Intelligence Approach (R.S. </title> <editor> Michalski, J. G. Carbonell and T. M. Mitchell, eds), </editor> <volume> 2 </volume> <pages> 395-424, </pages> <year> 1986. </year>
Reference-contexts: These heuristics detect similarities based on a small set of structural attributes. More powerful similarity detection is possible, as discussed in the artificial intelligence machine learning literature on analogy-based systems <ref> [28, 39, 51, 64] </ref>. Analogy-based systems have very limited power unless their analysis is based on a well-defined domain model.
Reference: [40] <author> L. Peter Deutsch. </author> <title> Design reuse and frameworks in the Smalltalk-80 system. </title> <booktitle> In Software Reusability Volume II: Applications and Experience, </booktitle> <pages> pages 57-72, </pages> <year> 1989. </year>
Reference-contexts: Frameworks capture the designs of interfaces and the way functionality is divided among components, which Deutsch argues are the key intellectual content of software <ref> [40] </ref>. Frameworks define an external interface that is constant across all uses of a framework, and an internal interface that is a set of constraints on subclass code or a component object's protocol. A framework is a mixture of abstract and concrete classes. <p> These refactorings change type, access control mode, and convert an instance variable to a variable that points to an instance. 24 3.7 Summary: Importance & Complexity of Refactoring Refactoring is important. As noted earlier, in the view of Deutsch <ref> [40] </ref> and others, the key intellectual content of software is captured in the factoring of functions and in the design of interfaces. Refactoring helps in making this intellectual content more explicit and, hence, helps in designing reusable software.
Reference: [41] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: All functions are (using C++ terminology) virtual, and can be overridden in subclasses. Signatures of virtual functions in C++ are compatible only if their (return and argument) types match exactly <ref> [41] </ref>. 3 This allows a function defined in a superclass to be overridden in a subclass, as long as the signatures are compatible. The ability to override inherited functions is important in refactoring. <p> To handle this, the data flow equations are changed to: 2 The Killed sets are null 3 In C++, the variable this referenced in a member function points to the object for which the function is called <ref> [41] </ref>.
Reference: [42] <author> M. Fagan. </author> <title> Design and code inspection to reduce errors in program development. </title> <journal> IBM Systems Journal, </journal> <volume> 15(3) </volume> <pages> 182-212, </pages> <year> 1976. </year>
Reference-contexts: Many other software restructuring approaches involve code changes. A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs <ref> [42, 47] </ref>, adherence to software metrics [11], maintainability measures [26] or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [43] <author> Martin S. Feather. </author> <title> Reuse in the context of a transformation-based methodology. </title> <booktitle> In Software Reusability Volume I: Concepts and Models, </booktitle> <pages> pages 337-360, </pages> <year> 1989. </year>
Reference-contexts: The components might be code skeletons [32, 68], subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems <ref> [23, 33, 43, 83] </ref> are examples of generation-based systems. Software restructuring relates to each of the four important aspects of reuse listed above. Restructuring a program can make it easier to understand the design of a program and can assist in finding reusable components.
Reference: [44] <author> Charles N. Fischer and Jr. Richard J. LeBlanc. </author> <title> Crafting a Compiler. </title> <publisher> Benjamin Cummings, </publisher> <year> 1988. </year>
Reference-contexts: This assumption, while safe, prevents many optimizations. One can expect to do better if the effects of a call are more carefully analyzed. The analysis of the effects of a call is generally termed interprocedural data flow analysis. <ref> [1, 44, 106] </ref> 7.3.1 Interprocedural Data Flow Analysis A procedure or subprogram can be represented as a data flow graph of basic blocks, where directed edges connecting the basic blocks represent the flow of control within the procedure. <p> After the Gen and Killed sets have been determined for each basic block, the In and Out sets can be determined using flow graphs and generic data flow equations such as described in <ref> [44] </ref>. Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches [56, 118] repeatedly traverse the flow graphs until there are no more changes. <p> After the Gen and Killed sets have been determined for each basic block, the In and Out sets can be determined using flow graphs and generic data flow equations such as described in <ref> [44] </ref>. Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches [56, 118] repeatedly traverse the flow graphs until there are no more changes. <p> The first step is a special case of theorem proving and, in general, is undecidable. However, since class invariants are of the form: &lt;memberVariable&gt; == &lt;value&gt; where the value is an integer or the value of an enumerated type, constant propagation and copy propagation <ref> [44] </ref> can be used to reduce some conditions to true or false. Constant propagation and copy propagation are applied in compilers to detect and remove extraneous variables, and improve execution speed by replacing variable references with their values. <p> There are many algorithms for simplifying expressions by performing constant propagation and copy propagation <ref> [44] </ref>. These techniques can be applied for simplifying conditional statements. For a variable referenced in a condition, an any path, forward flow analysis can be used to compute the set of reaching definitions, that is, the set of definitions to the variable that might reach the reference.
Reference: [45] <author> Gerhard Fischer. </author> <title> Cognitive view of reuse and redesign. </title> <journal> IEEE Software, </journal> <volume> 4(4) </volume> <pages> 60-72, </pages> <year> 1987. </year>
Reference-contexts: Software that solves a similar problem might be available, but such software may need to be changed in some way before it can be reused. These changes may involve restructuring the software. Object-oriented programming is often touted as promoting software reuse <ref> [45] </ref>. Sometimes however the benefits of the object-oriented approach are overstated, and claims are made that features can be added to an object-oriented system without disturbing the existing implementation. <p> Software restructuring continues to be an important area of software engineering research. 2.3 Object-Oriented Programming, Reuse and Restructuring Object-oriented programming is often touted as promoting software reuse <ref> [45] </ref>. However, it is not a panacea. This section discusses some of the strengths of object-oriented programming regarding reuse, and some of its limitations. 2.3.1 Features of Object-Oriented Systems That Support Reuse Most object-oriented languages combine several features that support reuse: data abstraction, class inheritance and polymorphism.
Reference: [46] <author> Brian Foote. </author> <title> An Object-Oriented Framework for Reflective Meta-Level Architectures. </title> <type> Ph.D. </type> <note> thesis in preparation, </note> <institution> University of Illinois at Urbana-Champaign. </institution>
Reference: [47] <author> D. Freedman and G. Weinberg. </author> <note> Handbook of Walkthroughs, Inspections and Technical Reviews (3rd Edition). </note> <author> Little Brown, </author> <year> 1982. </year>
Reference-contexts: Many other software restructuring approaches involve code changes. A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs <ref> [42, 47] </ref>, adherence to software metrics [11], maintainability measures [26] or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [48] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: Frameworks are an emerging technique; there is still much to be learned concerning the design, configuration, and architecture-level description of frameworks. Among the earliest examples of object-oriented application frameworks were the Lisa Toolkit [57] and Smalltalk Model/View/Controller <ref> [48] </ref>. More recently, several projects have been undertaken at the University of Illinois at Urbana-Champaign to design frameworks; these include the Typed Smalltalk (TS) optimizing compiler framework for code generation and optimization [60], the FOIBLE framework for visual programming [58] and the Choices object-oriented operating system.
Reference: [49] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: Two kinds of design information are needed for some of the high-level refactorings: 1 The refactorings are described using C++ terms such as member variable and member function, which correspond to the Smalltalk-80 TM <ref> [49] </ref> terms instance variable and method. Smalltalk-80 is a trademark of ParcPlace Systems. 4 1. a class invariant, which is a predicate, defined on the values of member variables, that is true for the lifetime of an instance of the class.
Reference: [50] <author> J. E. Grass and Y. F. Chen. </author> <title> The C++ Information Abstractor. </title> <booktitle> In Usenix C++ Conference Proceedings, </booktitle> <pages> pages 265-278, </pages> <address> San Francisco, CA, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: columnNumber) = 0; -; class TwoDimensionalArray : public MatrixRepresentation - protected: int elements [400]; public: TwoDimensionalArray (int numberOfRows, int numberOfColumns) - ... -; int get (int rowNumber, int columnNumber) - ... -; void put (int newValue, rowNumber, int columnNumber) - ... -; class SparseMatrixRepresentation : MatrixRepresentation - protected: sparseArrayElement elements <ref> [50] </ref>; /* maximum 50 elements for this sparse representation; type sparseArrayElement defined elsewhere */ int get (int rowNumber, int columnNumber) - ... -; void put (int newValue, rowNumber, int columnNumber) - ... -; As a result of these refactorings: * the mathematical abstraction is separated from the underlying representation * the <p> Precomputing the cross reference information has the advantage of making cross reference lookup (queries) easy, but making updates to this cross reference information can be hard. Several tools have been developed to create these tables from C++ source code <ref> [50, 81] </ref>; tools have also been developed for other object oriented languages. However, refactorings change program structure, and almost every refactoring requires the cross reference database to be updated. These database changes can be costly and complex.
Reference: [51] <author> R. Greiner. </author> <title> Learning by understanding analogies. </title> <journal> Artificial Intelligence, </journal> <volume> 35 </volume> <pages> 81-125, </pages> <year> 1988. </year> <month> 136 </month>
Reference-contexts: These heuristics detect similarities based on a small set of structural attributes. More powerful similarity detection is possible, as discussed in the artificial intelligence machine learning literature on analogy-based systems <ref> [28, 39, 51, 64] </ref>. Analogy-based systems have very limited power unless their analysis is based on a well-defined domain model.
Reference: [52] <author> William G. Griswold. </author> <title> Program Restructuring as an Aid in Software Maintenance. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1991. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. <p> A similar insight has been gained from the refactoring research. 10.7.1 Transforming Block Structured Languages Griswold <ref> [52] </ref> investigated meaning preserving transformations to restructure programs written in a block-structured programming language, to make maintaining such programs easier. The language analyzed in this research was Scheme. From the program source, a program dependency graph is created. <p> Like the refactoring research, his research investigated source to source program restructuring to aid software maintenance. However, his work <ref> [52] </ref> focused on transforming the syntactic constructs of a block-structured language; his focus was not on transformations involving inheritance or a type hierarchy. In [52] he cites our refactoring research and discusses how his approach might be applied for object-oriented systems. <p> Like the refactoring research, his research investigated source to source program restructuring to aid software maintenance. However, his work <ref> [52] </ref> focused on transforming the syntactic constructs of a block-structured language; his focus was not on transformations involving inheritance or a type hierarchy. In [52] he cites our refactoring research and discusses how his approach might be applied for object-oriented systems. He notes several complexities that inheritance causes in program analysis and transformation; these complexities are dealt with more fully in the prior chapters of this (refactoring) thesis. <p> Clearly, for large programs the representation (s) used will influence how expensive it is to refactor the program. One way to achieve some efficiencies in maintaining consistency between multiple program representations is described by Griswold <ref> [52] </ref>. His restructuring of Scheme programs used an abstract syntax tree (AST) representation, and a program dependency graph (PDG) which recorded data flow and control flow dependencies. PDG updates were expensive. The AST announced three events as the program was restructured: insert, delete and change.
Reference: [53] <author> Daniel C. Halbert and Patrick D. O'Brien. </author> <title> Using types and inheritance in object-oriented programs. </title> <journal> IEEE Software, </journal> <pages> pages 71-79, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: In order to appreciate the need for this refactoring, it is important to understand the role of subtyping for specialization. A type characterizes the behavior of its instances by describing the operations that can manipulate those objects <ref> [53] </ref>. A program with a well-designed type structure will minimize and localize the dependencies among types, enhancing maintainability and extensibility. A type hierarchy is composed of subtypes and supertypes. <p> Subtyping is most frequently used to model conceptual hierarchies. When used in this way, a subtype describes a type that is more specific than a supertype; the subtype is a specialization of the supertype <ref> [53, 74] </ref>. 5 MS-DOS is a trademark of Microsoft Corporation. 15 Inheritance can be used in several ways; some clarify the design of a framework while others can make a framework more difficult to understand.
Reference: [54] <author> Patrick A. V. Hall and Geoff R. Dowling. </author> <title> Approximate string matching. </title> <journal> Computing Surveys, </journal> <volume> 12(4) </volume> <pages> 381-402, </pages> <month> December </month> <year> 1980. </year>
Reference-contexts: Before the function body can be migrated to the superclass, differences need to be separated from the common code. The approaches for detecting program differences involve string comparison, tree comparison or a combination of these techniques [12]. Program differences have been studied in regard to spelling correction <ref> [54, 109] </ref>, parsing error correction [119], version storage [99] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. The standard algorithm for string comparison is described by Wagner and Fisher [120].
Reference: [55] <author> Mehdi T. Harandi and Jim Q. Ning. </author> <title> Knowledge-based program analysis. </title> <journal> IEEE Software, </journal> <pages> pages 74-81, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Design recovery has been proposed using program structures (cliches) and graph parsing [97], a heuristic-based concept-recognition mechanism with multiple views of program knowledge <ref> [55] </ref>, and an approach using an intermediate modular interconnection language to generate design descriptions [35]. None of these approaches involve code changes.
Reference: [56] <author> M. S. Hecht and J. D. Ullman. </author> <title> Flow graph reducability. </title> <journal> SIAM J. Computing, </journal> <volume> 1 </volume> <pages> 188-202, </pages> <year> 1972. </year>
Reference-contexts: Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches <ref> [56, 118] </ref> repeatedly traverse the flow graphs until there are no more changes.
Reference: [57] <institution> Apple Computer Inc. Lisa Toolkit 3.0. Apple Computer, </institution> <year> 1984. </year>
Reference-contexts: Frameworks are an emerging technique; there is still much to be learned concerning the design, configuration, and architecture-level description of frameworks. Among the earliest examples of object-oriented application frameworks were the Lisa Toolkit <ref> [57] </ref> and Smalltalk Model/View/Controller [48]. More recently, several projects have been undertaken at the University of Illinois at Urbana-Champaign to design frameworks; these include the Typed Smalltalk (TS) optimizing compiler framework for code generation and optimization [60], the FOIBLE framework for visual programming [58] and the Choices object-oriented operating system.
Reference: [58] <author> William A. Jindrich. Foible: </author> <title> A framework for visual programming languages. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: More recently, several projects have been undertaken at the University of Illinois at Urbana-Champaign to design frameworks; these include the Typed Smalltalk (TS) optimizing compiler framework for code generation and optimization [60], the FOIBLE framework for visual programming <ref> [58] </ref> and the Choices object-oriented operating system. Choices, written in C++, is more than just an operating system; it is really an operating system framework consisting of interlocking frameworks for file systems [77], virtual memory [103], communication [129], and process scheduling [102].
Reference: [59] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: Tracking down the dependencies by hand and consistently updating the program can be time consuming, difficult and error prone. The reusability benefits of object-oriented programming can be difficult to realize without some form of automated support for making these structural changes <ref> [59, 98] </ref>. 1.2 A Proposed Solution This dissertation describes an approach for providing automated support for the restructuring of object-oriented programs. <p> Refactoring is especially important in object-oriented programming. Some in the object-oriented programming culture have placed high value in designing and redesigning software to make it more reusable <ref> [59, 98] </ref>. In some cases, the best way to improve the design of a program is to re-write it. <p> A refactoring tool can help a designer by providing the right set of refactorings, and by ensuring that each refactoring is applied correctly, but it cannot decide which refactorings to apply. Thus, refactoring cannot be completely automated. To understand how people refactor programs, related research <ref> [9, 30, 59, 71, 98] </ref> was surveyed, and an analysis was done of the structural changes made to the Choices file system framework [77] over a two year period. The Choices file system framework was developed using 3 the C++ programming language [114]. <p> However, a major problem with design-level reuse is that there is no well-defined representation system for design. Reuse does not happen by accident; one needs to plan to reuse software and look for software to reuse. Reuse requires the right attitude, tools and techniques <ref> [59, 117] </ref>. Tools and techniques to support software reuse include compositional and generational approaches [18]. The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. <p> Often, however, object-oriented software cannot be reused without first being restructuring. There are several reasons for this <ref> [31, 59] </ref>: 1. When developing a software application, it is difficult to determine a priori what classes embody the important concepts for that application and how they interrelate. Experience has shown that a useful taxonomy of classes is discovered through an iterative process of exploration. <p> Rochat [98] discusses the importance of good programming style in Smalltalk and proposes several semantic and syntactic guidelines. Lieberherr and others in the Demeter project [71] have proposed an approach for hiding the structure of a class in order to increase maintainability. Johnson and Foote <ref> [59] </ref> propose design rules to support reusable classes. The authors argue that restructuring an object-oriented program in line with these guidelines will improve its reusability and maintainability. Very recent research has investigated some of the issues involved in restructuring object oriented programs [15, 31]. <p> Refactoring not only involves manipulating inheritance hierarchies but also involves such tasks as renaming a class, splitting up classes and functions, and removing conditional statements. Also, some refactorings involve not only inheritance hierarchies but also instance hierarchies, where an instance of one class is a component of another class <ref> [59] </ref>. <p> Good frameworks are usually the result of many design iterations and a lot of hard work involving structural changes <ref> [59, 85] </ref>. These changes may involve a single refactoring, or a series of related refactorings. The following sections describe examples of several common refactorings. They are mostly based on the analysis of changes made during the iterative design of the Choices file system framework. <p> Instance hierarchies emerge, where an instance of one class is a component of another class <ref> [59] </ref>. Often, as instance hierarchies are defined the inheritance hierarchies also change and become easier to understand. <p> Creating reusable abstract classes often involves examining an existing implementation to find an abstraction hidden in a concrete class (or classes), and reorganizing the class hierarchy to make that abstraction explicit <ref> [59] </ref>. Consider the example, shown in Figure 3.1, of an abstract class created for the Choices file system framework [76]. One of the central classes in that framework 3 is MemoryObject [104]. A MemoryObject is a sequence of identically sized blocks. <p> Black box interfaces provide better encapsulation and abstraction than do white box or grey box interfaces <ref> [59] </ref>. Thus, while inheritance plays an important role in an application framework, so too can aggregations and components. There are some complexities in converting a subclass/superclass relationship to an aggregation. Checks are needed to ensure that type requirements on variable assignments and function calls are still satisfied. <p> design criteria, such as minimizing program size or minimizing access to variables. 1 Other approaches to object-oriented analysis and design include [21] and [36]. 118 10.2 Designing Reusable Classes This refactoring research directly builds on research done at the University of Illinois by John-son and Foote to support reusable classes <ref> [59] </ref>. To improving the design of an object oriented system, they define rules of thumbs for finding standard protocols, abstract classes and frameworks. Related to protocols, they recommend consistent naming of related functions, replacing case analysis with subclassing, and minimizing the size of methods and number of function arguments. <p> This thesis defines several ways to split up large classes: by separating abstractions into abstract classes, by specializing classes using subclassing, and by defining components and moving members into the components. This research differs from and extends <ref> [59] </ref> in other ways. Their paper includes a set of thirteen heuristics; this research defines a layered taxonomy of several dozen refactorings. The refactoring taxonomy made clear that their thirteen rules of thumb were not distinct but interrelate. <p> Chapter seven describes an approach that exploits subclass-ing for specialization in splitting large classes. This research also uncovered design information that was needed to automate refactorings, and considered implementation issues. Johnson and Foote recognized the need for this research in <ref> [59] </ref> and motivated its importance. 10.3 Achieving Good Style in Smalltalk Programs Rochat [98] proposes several guidelines for achieving good programming style in Smalltalk. Among the guidelines: Carefully name classes and class members. Each class and method should have a single purpose; multi-purpose classes and methods should be split.
Reference: [60] <author> Ralph E. Johnson, Justin O. Graver, and Lawrence W. Zurawski. </author> <title> TS: An optimizing compiler for Smalltalk. </title> <booktitle> In Proceedings of OOPSLA `88, </booktitle> <pages> pages 18-26, </pages> <month> November </month> <year> 1988. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 23(11). </volume>
Reference-contexts: Among the earliest examples of object-oriented application frameworks were the Lisa Toolkit [57] and Smalltalk Model/View/Controller [48]. More recently, several projects have been undertaken at the University of Illinois at Urbana-Champaign to design frameworks; these include the Typed Smalltalk (TS) optimizing compiler framework for code generation and optimization <ref> [60] </ref>, the FOIBLE framework for visual programming [58] and the Choices object-oriented operating system. Choices, written in C++, is more than just an operating system; it is really an operating system framework consisting of interlocking frameworks for file systems [77], virtual memory [103], communication [129], and process scheduling [102]. <p> In each newly defined subclass, the functions can be simplified by replacing the conditional statements with just the code segment for the condition corresponding to (implied by) the subclass. There are several examples of this type of restructuring that occurred in the Typed Smalltalk <ref> [60] </ref> project and the Choices operating system project; it was also useful in converting a program written in the C programming language to C++. The Typed Smalltalk (TS) project is developing an optimizing compiler for a typed version of Smalltalk.
Reference: [61] <author> W. Lewis Johnson and Martin Feather. </author> <title> Building an evolution transformation library. </title> <booktitle> In Proceedings of the 12th International Conference on Software Engineering, </booktitle> <pages> pages 238-247, </pages> <year> 1990. </year>
Reference-contexts: Early work in this area was done by Burstall and Darlington [27]; extensive work has been done by Balzer and others at USC/ISI [8], including recent work into building an evolution transformation library <ref> [61] </ref>. This work has focused on the process of converting a formal specification into an efficient implementation. Examples of behavior preserving transformations are: * folding and unfolding. Folding replaces a code segment with a function call; unfolding inline expands a function call.
Reference: [62] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language (2rd Edition). </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference-contexts: Finally, a pretty printer is called to print the refactored code. The approach that we used to build the prototype was to write a simple parser from C++ into Lisp forms using a YACC-compatible specification of C++ developed by Roskind [100]. A Common Lisp <ref> [62] </ref> program, making extensive use of the Common Lisp Object System (CLOS) facilities, used the output of the parser to build a complex structure representing the program.
Reference: [63] <author> Simon M. Kaplan. Coed: </author> <booktitle> Conversation-oriented software environments. In Proceedings of IFIP Conference on Human Facors in Information Systems, </booktitle> <address> Scharding, Austia., </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Refactorings do not force upon a designer a rigid, top down design style. Experience has shown that the development of a large software program does not proceed in a purely top down manner [38, 89]. Software design is in many ways an informal process <ref> [63] </ref>. Refactorings support iterative conceptual shifts. For example, the refactoring that defines an abstract superclass generates a common design abstraction from low-level implementation; this design abstraction can then be used for further low level implementation.
Reference: [64] <author> S. T. Kedar-Cabelli. </author> <title> Purpose-directed analogy. </title> <booktitle> In Proceedings Seventh Annual Conference of the Cognitive Science Society, </booktitle> <address> Irvine, CA, </address> <month> August </month> <year> 1985. </year>
Reference-contexts: These heuristics detect similarities based on a small set of structural attributes. More powerful similarity detection is possible, as discussed in the artificial intelligence machine learning literature on analogy-based systems <ref> [28, 39, 51, 64] </ref>. Analogy-based systems have very limited power unless their analysis is based on a well-defined domain model.
Reference: [65] <author> B. W. Kernighan and P. J. Plauger. </author> <title> Elements of Programming Style. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [66] <author> Won Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The issues and approaches for schema evolution in object-oriented databases are discussed in <ref> [66] </ref> and the references therein. Several efforts have been underway to understand good style for object-oriented programs, to support their evolution and reuse. Rochat [98] discusses the importance of good programming style in Smalltalk and proposes several semantic and syntactic guidelines. <p> A mechanism is needed for representing this whole/part relationship. The whole-part relationship is a special association between objects, often called an aggregation. There are many examples <ref> [66, 126] </ref> of aggregations: * a car and its automotive parts * a company and its departments * a drawing and its drawing elements * a program and its program fragments * a desk lamp and the parts used in its manufacture. <p> program contains a single instance of the aggregate class; 2. it extends the initial algorithm to better handle cases where component objects are created by classes other than the aggregate class; 1 This definition is consistent with the meaning of exclusive composite references in object-oriented databases, as defined by Kim <ref> [66] </ref>. 87 3. it further extends the algorithm to handle the case where a program contains multiple instances of the aggregate class; 4. finally, it discusses additional extensions that could make the algorithm more powerful. <p> By construction, the two functions perform the same operations and, from the prior step, all variable references are semantically equivalent. Thus, each step is behavior preserving and, hence, the refactoring is behavior preserving. 8.10 Discussion 8.10.1 Related Work in OODB Schema Evolution Kim <ref> [66] </ref> describes composite objects in the ORION object-oriented database system, which are similar to aggregate objects. Orion supported composite references, which are similar to components. ORION supported several types of composite references, one important distinction being shared and exclusive references. <p> Schemas evolve over time; many of the changes made to schemas in OODBs are similar to refactorings. Schema evolution has been studied for several OODB systems, most notably ORION <ref> [9, 66] </ref>. 2 Just as with refactoring, the methodology for handling schema changes has included: * developing a taxonomy of changes * defining a set of properties that must remain invariant across schema changes * defining the changes in the taxonomy in a way that preserves these properties. .
Reference: [67] <author> S. R. Kosaraju. </author> <title> Analysis of structured programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 9(3) </volume> <pages> 232-255, </pages> <year> 1974. </year>
Reference-contexts: Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches [56, 118] repeatedly traverse the flow graphs until there are no more changes. Structured solutions (e.g., <ref> [7, 67, 107] </ref>) are more complex, but have much better worse case performance. 7.4 Checking Whether a Predicate is a Class Invariant In general, the problem of determining whether an arbitrary predicate is a class invariant is undecidable.
Reference: [68] <author> Robert G. Lanergan and Charles A. Grasso. </author> <title> Software engineering with reusable designs and code. </title> <booktitle> In Software Reusability Volume II: Applications and Experience, </booktitle> <pages> pages 187-196, </pages> <year> 1989. </year>
Reference-contexts: Tools and techniques to support software reuse include compositional and generational approaches [18]. The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. The components might be code skeletons <ref> [32, 68] </ref>, subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems [23, 33, 43, 83] are examples of generation-based systems. <p> The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. The components might be code skeletons [32, 68], subroutines <ref> [32, 68, 96] </ref> or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems [23, 33, 43, 83] are examples of generation-based systems. <p> A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [69] <author> Karl Lieberherr. </author> <title> Concepts of Object-Oriented Data Modeling and Programming. </title> <journal> ACM, </journal> <note> 1991. Presented as Tutorial No. 16 at OOPSLA '91. </note>
Reference-contexts: These guidelines are reflected both in the supporting refactorings and most clearly in the discussion of subclassing in chapter seven of this thesis. 10.4 Demeter Project Lieberherr and others in the Demeter project at Northeastern University have studied how to improve the productivity of object-oriented designers and programmers <ref> [71, 69] </ref>. They have proposed rules for bringing discipline to the object oriented design process (the "Law of Demeter") 119 and have developed a set of structures and tools, which they package as the Demeter system.
Reference: [70] <author> Karl Lieberherr, Walter J. Hursch, and Cun Xiao. </author> <title> Object-extending class transformations (draft). </title> <type> Technical report, </type> <institution> College of Computer Science, Northeastern University, </institution> <address> 360 Huntington Ave., Boston MA 02115, </address> <year> 1991. </year>
Reference-contexts: This permits changes such as moving members between component and aggregate classes, which are not covered in Bergstein's approach. Extensions to Bergstein's approach are being investigated by the Demeter researchers <ref> [70] </ref>. 120 10.5 Reorganizing Generic Applications: Ithaca As part of the ITHACA (Esprit II) project, research by Casais at the University of Geneva investigated approaches to support the evolution of a generic application, which is similar to an application framework.
Reference: [71] <author> Karl J. Lieberherr and Ian M. Holland. </author> <title> Assuring good style for object-oriented programs. </title> <journal> IEEE Software, </journal> <pages> pages 38-48, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: A refactoring tool can help a designer by providing the right set of refactorings, and by ensuring that each refactoring is applied correctly, but it cannot decide which refactorings to apply. Thus, refactoring cannot be completely automated. To understand how people refactor programs, related research <ref> [9, 30, 59, 71, 98] </ref> was surveyed, and an analysis was done of the structural changes made to the Choices file system framework [77] over a two year period. The Choices file system framework was developed using 3 the C++ programming language [114]. <p> Several efforts have been underway to understand good style for object-oriented programs, to support their evolution and reuse. Rochat [98] discusses the importance of good programming style in Smalltalk and proposes several semantic and syntactic guidelines. Lieberherr and others in the Demeter project <ref> [71] </ref> have proposed an approach for hiding the structure of a class in order to increase maintainability. Johnson and Foote [59] propose design rules to support reusable classes. The authors argue that restructuring an object-oriented program in line with these guidelines will improve its reusability and maintainability. <p> These guidelines are reflected both in the supporting refactorings and most clearly in the discussion of subclassing in chapter seven of this thesis. 10.4 Demeter Project Lieberherr and others in the Demeter project at Northeastern University have studied how to improve the productivity of object-oriented designers and programmers <ref> [71, 69] </ref>. They have proposed rules for bringing discipline to the object oriented design process (the "Law of Demeter") 119 and have developed a set of structures and tools, which they package as the Demeter system.
Reference: [72] <author> Karl J. Lieberherr, Ian M. Holland, and A. Riel. </author> <title> Object-oriented programming: An objective sense of style. </title> <booktitle> In Proceedings of OOPSLA `88, </booktitle> <pages> pages 323-334, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Their style is claimed to increase information hiding, minimize coupling between classes, and improve maintainability and comprehensibility. They have developed tools to check if programs conform to the law. There are some shortcomings to the Demeter approach. The Demeter researchers <ref> [72] </ref> note that restructuring a program to make it conform with their "law" can require increasing the number of methods and method arguments, and result in slower execution speed and poorer readability of code.
Reference: [73] <author> R. C. Linger, H. D. Mills, and R. J. </author> <title> Witt. Structured Programming: Theory and Practice. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement <ref> [73] </ref> and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability. Lyons [75] and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions.
Reference: [74] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <booktitle> In Addendum to the Proceedings of OOPSLA `87, </booktitle> <year> 1987. </year>
Reference-contexts: Subtyping is most frequently used to model conceptual hierarchies. When used in this way, a subtype describes a type that is more specific than a supertype; the subtype is a specialization of the supertype <ref> [53, 74] </ref>. 5 MS-DOS is a trademark of Microsoft Corporation. 15 Inheritance can be used in several ways; some clarify the design of a framework while others can make a framework more difficult to understand. <p> In this case, the subclass may not be a specialization of the superclass the resulting class hierarchy may not model any meaningful concept (other than expedient code copying) and can be difficult to understand. Liskov <ref> [74] </ref> argues that using inheritance to model the type hierarchy supports data abstraction, which can simplify program maintenance. <p> Before the refactoring, the services were inherited by the InodeSystem class; later, they were provided by its components. From a software engineering viewpoint, there are advantages in using aggregations and components, as opposed to inheritance, to accomplish reuse. Data abstraction supports reuse <ref> [74] </ref>. An aggregate object only sees the public interface of its components, whereas a subclass sees the internals (i.e. a less abstract view) of its superclass.
Reference: [75] <author> M. J. Lyons. </author> <title> Salvaging your software asset (tools based maintanance). </title> <booktitle> In Proceedings of the National Computer Conference 1981, </booktitle> <pages> pages 337-341. </pages> <publisher> AFIPS Press, </publisher> <year> 1981. </year>
Reference-contexts: Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs <ref> [75, 82, 121] </ref>. Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability. <p> Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability. Lyons <ref> [75] </ref> and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions. Other tools to support software restructuring include pretty printers and code formatters, integrated programming environments [10, 122] and rule-based program transformation systems [91].
Reference: [76] <author> Peter W. Madany. </author> <title> An Object-Oriented Framework for File System. </title> <type> Ph.D. </type> <note> thesis in preparation, </note> <institution> University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: Consider the example, shown in Figure 3.1, of an abstract class created for the Choices file system framework <ref> [76] </ref>. One of the central classes in that framework 3 is MemoryObject [104]. A MemoryObject is a sequence of identically sized blocks. It also is responsible for maintaining the number of blocks it contains. The key operations provided by MemoryObjects are read, write, and size. <p> In the Choices file system framework, Inode was represented as a subclass of MemoryObject. 2 The specification of an object also includes class invariants and the relationships with other objects. 3 The file system has a layered structure that is much more comprehensive than what is presented here; see <ref> [76] </ref>. 4 Inode is standard UNIX R fl operating system terminology; it is a contraction of the term index node.
Reference: [77] <author> Peter W. Madany, Roy H. Campbell, Vincent F. Russo, and Douglas E. Leyens. </author> <title> A Class Hierarchy for Building Stream-Oriented File Systems. </title> <booktitle> In Proceedings of the 1989 European Conference on Object-Oriented Programming, </booktitle> <address> Nottingham, UK, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: It is an important object-oriented technique to facilitate design-level reuse [127]. Good frameworks are usually the result of many design iterations and a lot of hard work, involving structural changes. For example, the application framework for managing files in an operating system <ref> [77] </ref> began as an implementation of only one file format. Then, it was to be extended to handle additional file formats. Unfortunately, in the initial implementation the more general, common abstractions were intertwined with features specific to the file format supported. <p> Thus, refactoring cannot be completely automated. To understand how people refactor programs, related research [9, 30, 59, 71, 98] was surveyed, and an analysis was done of the structural changes made to the Choices file system framework <ref> [77] </ref> over a two year period. The Choices file system framework was developed using 3 the C++ programming language [114]. <p> Choices, written in C++, is more than just an operating system; it is really an operating system framework consisting of interlocking frameworks for file systems <ref> [77] </ref>, virtual memory [103], communication [129], and process scheduling [102]. Good frameworks are usually the result of many design iterations and a lot of hard work involving structural changes [59, 85]. These changes may involve a single refactoring, or a series of related refactorings.
Reference: [78] <author> J. Martin and C. McClure. </author> <title> Software Maintenance: The Problem and Its Solution. </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [79] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Making software easier to change makes subsequent design iterations easier, and makes the software more reusable. Although there have been no scientific studies that validate the claim, it is nonetheless a strongly held conclusion among many practitioners that object-oriented software is easier to change than conventional software <ref> [79] </ref>. Some changes to object-oriented software can be made simply by adding new subclasses or by adding new operations on existing classes, while leaving most of the original software unchanged. However, object-oriented software is harder to change than it might at first appear to be. <p> This allows for several important changes that don't affect equivalence: 3 Signature compatibility has different meanings in other object oriented languages such as Eiffel R fl <ref> [79] </ref>. Eiffel is a registered trademark of Interactive Software Engineering, Inc. 28 * expressions can be simplified and dead code removed. Conditional statements can be simplified based on invariant conditions known when the conditional is encountered (eg. class invariant). <p> In refactoring, the term class invariant is used in a manner similar to Meyer's <ref> [79] </ref> use of the term. <p> GemStone is a registered trademark of Servio Logic. 84 In summary, in refactoring the term class invariant is used in a manner similar to Meyer's <ref> [79] </ref> use of the term, although in refactoring the invariant applies not only where the class calls other classes, but also for states internal to the class. 85 Chapter 8 Refactoring To Capture Aggregations & Components 8.1 Motivation Inheritance is a powerful technique, but in modeling the relationships among classes it
Reference: [80] <author> Ware Meyers. </author> <title> Interview with Wilma Osborne. </title> <journal> IEEE Software, </journal> <volume> 5(3) </volume> <pages> 104-105, </pages> <year> 1988. </year>
Reference-contexts: Understanding what a component does is important in order to use it, but developing that mental model is difficult [24, 88]. 1 Most (60%) of the activities analyzed in Osborne's software maintenance study <ref> [80] </ref>, were found neither to be corrective (that is, diagnosing and fixing errors) nor adaptive (changing software to work with new hardware and peripherals) but rather were perfective activities, where pressure was brought to bear on developers to extend and enhance the functionality of a system.
Reference: [81] <author> Scott Meyers Moises Lejter and Steven P. Reiss. </author> <title> Support for Maintaining Object-Oriented Programs. </title> <booktitle> In Proceedings of the 1991 Conference on Software Maintenance, </booktitle> <pages> pages 171-178, </pages> <address> Sorrento, Italy, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Precomputing the cross reference information has the advantage of making cross reference lookup (queries) easy, but making updates to this cross reference information can be hard. Several tools have been developed to create these tables from C++ source code <ref> [50, 81] </ref>; tools have also been developed for other object oriented languages. However, refactorings change program structure, and almost every refactoring requires the cross reference database to be updated. These database changes can be costly and complex.
Reference: [82] <author> H. W. Morgan. </author> <title> Evolution of a software maintenance tool. </title> <booktitle> In Proceedings of the 2nd National Conference on EDP Software Maintenance, </booktitle> <pages> pages 268-278. </pages> <institution> US Professional Development Institute, </institution> <year> 1984. </year>
Reference-contexts: Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs <ref> [75, 82, 121] </ref>. Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability. <p> Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability. Lyons [75] and Morgan <ref> [82] </ref> describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions. Other tools to support software restructuring include pretty printers and code formatters, integrated programming environments [10, 122] and rule-based program transformation systems [91].
Reference: [83] <author> James M. Neighbors. </author> <title> Draco: A method for engineering reusable software systems. </title> <booktitle> In Software Reusability Volume I: Concepts and Models, </booktitle> <pages> pages 275-294, </pages> <year> 1989. </year>
Reference-contexts: The components might be code skeletons [32, 68], subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators <ref> [83] </ref> and some program transformation systems [23, 33, 43, 83] are examples of generation-based systems. Software restructuring relates to each of the four important aspects of reuse listed above. Restructuring a program can make it easier to understand the design of a program and can assist in finding reusable components. <p> The components might be code skeletons [32, 68], subroutines [32, 68, 96] or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems <ref> [23, 33, 43, 83] </ref> are examples of generation-based systems. Software restructuring relates to each of the four important aspects of reuse listed above. Restructuring a program can make it easier to understand the design of a program and can assist in finding reusable components.
Reference: [84] <author> David et al. Notkin. </author> <title> The Journal of Systems and Software Special Issue: The GANDALF Project. </title> <publisher> Elsevier Science Publishing Co., </publisher> <month> May </month> <year> 1985. </year>
Reference-contexts: The most well-known of these systems for generating program development environments are the (Cornell) Synthesizer Generator [95], GANDALF <ref> [84] </ref> and CENTAUR [22]. Ideally, these systems could be used to generate the software refactory.
Reference: [85] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Refactoring: An aid in designing application frameworks and evolving object-oriented systems. </title> <booktitle> In Proceedings of Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <month> September </month> <year> 1990. </year> <month> 138 </month>
Reference-contexts: For example, a new feature might be added to a program by first refactoring part of a complex class into a component class, and then using the component class in defining the new feature. There are several cases where refactorings might be applied <ref> [85] </ref>: 1. Extracting a reusable component. For example, an industrial process control system had served user needs well for several years. Customers require a new product to support new process approaches, but with a user interface that is compatible with the older system. <p> The Choices file system framework was developed using 3 the C++ programming language [114]. Based on that analysis, the following set of eight basic refactorings was compiled <ref> [85] </ref>: 1 1. defining an abstract superclass of one or more existing classes 2. specializing a class by defining subclasses, and using subclassing to eliminate conditional tests 3. changing how the whole/part association between classes is modeled, from using inheri tance to using an instance hierarchy of aggregates and their components <p> It defines in detail three of the most complex refactorings. 4. It defines design constraints needed in refactoring, specifically class invariants and exclu sive components. The research described here could serve as the basis for a software refactory <ref> [85] </ref>. Whereas past research into a software factory (for example, [110]) has focused on generating a software program from specifications, this research has focused on how to restructure an existing program to make it easier to understand, change and reuse. <p> Good frameworks are usually the result of many design iterations and a lot of hard work involving structural changes <ref> [59, 85] </ref>. These changes may involve a single refactoring, or a series of related refactorings. The following sections describe examples of several common refactorings. They are mostly based on the analysis of changes made during the iterative design of the Choices file system framework. <p> These low-level refactorings are described in chapter five. This list, combined with the three high-level refactorings, is an elaboration of the original list of eight refactorings described in section 1.2.1 (and in <ref> [85] </ref>). <p> The set of refactorings may need to be extended to handle programming styles that, while unusual or non-standard, are nonetheless used in the organization. A refactoring tool must integrate well with other tools that support change management and other software development tasks in an organization <ref> [31, 85] </ref>. Large software organizations are often resistant to change; changing the names, behavior, interrelationships and responsibilities of objects can have political as well as technical implications.
Reference: [86] <author> Tim O'Shea, Kent Beck, Dan Halbert, and Kurt J. Schmucker. </author> <title> Panel on: The learnability of object-oriented programming systems. </title> <booktitle> In Proceedings of OOPSLA `86, </booktitle> <pages> pages 502-504, </pages> <month> November </month> <year> 1986. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 21(11). </volume>
Reference-contexts: Creating an abstract class is important but not easy. Beck observed that, among Smalltalk researchers, useful abstractions are usually created by programmers who are willing to redo their code several times to produce easy-to-understand and easy-to-specialize classes <ref> [86] </ref>. Creating reusable abstract classes often involves examining an existing implementation to find an abstraction hidden in a concrete class (or classes), and reorganizing the class hierarchy to make that abstraction explicit [59].
Reference: [87] <author> D. L. Parnas. </author> <title> Designing software for ease of extension and contraction. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. <p> Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., [29]). Parnas <ref> [87] </ref> gives principles for partitioning a system into modules to increase its maintainability. Lyons [75] and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions.
Reference: [88] <author> D. L. Parnas. </author> <title> Designing software for ease of extension and contraction. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(2) </volume> <pages> 128-138, </pages> <month> March </month> <year> 1979. </year>
Reference-contexts: This is usually is not as simple as finding an exact match, but rather involves finding the most similar component. 2. understanding the component. Understanding what a component does is important in order to use it, but developing that mental model is difficult <ref> [24, 88] </ref>. 1 Most (60%) of the activities analyzed in Osborne's software maintenance study [80], were found neither to be corrective (that is, diagnosing and fixing errors) nor adaptive (changing software to work with new hardware and peripherals) but rather were perfective activities, where pressure was brought to bear on developers <p> A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [89] <author> David L. Parnas and P. C. Clements. </author> <title> A rational design process: How and why to fake it. </title> <booktitle> In Proceedings of International Joint Conference on Theory and Practice on Software Development (TAPSOFT), </booktitle> <year> 1985. </year> <note> Reprinted in IEEE Transactions on Software Engineering SE-12:2, </note> <month> February, </month> <year> 1986. </year>
Reference-contexts: Refactorings do not force upon a designer a rigid, top down design style. Experience has shown that the development of a large software program does not proceed in a purely top down manner <ref> [38, 89] </ref>. Software design is in many ways an informal process [63]. Refactorings support iterative conceptual shifts. For example, the refactoring that defines an abstract superclass generates a common design abstraction from low-level implementation; this design abstraction can then be used for further low level implementation.
Reference: [90] <author> D. L. Parnass, </author> <title> P.C. Clements, and D.M. Weiss. The modular structure of complex systems. </title> <booktitle> In Proceedings of the 7th International Conference on Software Engineering, </booktitle> <pages> pages 408-417, </pages> <year> 1984. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [91] <author> H. Partsch and R. Steinbruggen. </author> <title> Program transformation systems. </title> <journal> Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 199-236, </pages> <month> September </month> <year> 1983. </year>
Reference-contexts: Lyons [75] and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions. Other tools to support software restructuring include pretty printers and code formatters, integrated programming environments [10, 122] and rule-based program transformation systems <ref> [91] </ref>. Software restructuring continues to be an important area of software engineering research. 2.3 Object-Oriented Programming, Reuse and Restructuring Object-oriented programming is often touted as promoting software reuse [45]. However, it is not a panacea.
Reference: [92] <author> D. Jason Penney and Jacob Stein. </author> <title> Class modification in the GemStone object-oriented dbms. </title> <booktitle> In Proceedings of OOPSLA `87, </booktitle> <year> 1987. </year>
Reference-contexts: are distinct from the constraints defined on specific classes. 10 He distinguishes these from preconditions and postconditions defined on routines. 11 His invariant rule also requires that, when these procedures are applied, the arguments and state satisfy the preconditions for the procedures. 12 Casais [31] compares the GemStone R fl <ref> [92] </ref>, Orion [9], O 2 and OTGen object-oriented database systems with respect to class invariants. <p> Some research into OODBs has considered versioning issues and multiple inheritance, outside the scope of this refactoring research. Conversely, OODB research has not focused on 2 Other systems include Gemstone <ref> [92] </ref>, O 2 and OTGen.
Reference: [93] <author> Edward J. </author> <title> Rak. Two redesign tools for Smalltalk. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: In order for the new functions to represent meaningful abstractions, this "common" code might really belong together with the differing segments in those new functions. Fully automated techniques won't pick this up. Rak <ref> [93] </ref> describes an approach that combines automated analysis with user interaction, for abstracting a function (Smalltalk method) into a superclass from its subclass implementations. <p> Performance issues will be better understood as practical refactoring systems are implemented and used. Clarity in the user interface is important because, as discussed earlier, many refactoring tasks (especially the more complex refactorings) require some user interaction for the results to be useful. Rak <ref> [93] </ref> describes an interface for refactoring Smalltalk methods and migrating code to a common superclass; his approach is described and extended in chapter six. User interface issues regarding refactoring process is an area for future research. Several approaches can be applied to "undo" the effects of a refactoring.
Reference: [94] <author> Thomas W. Reps. </author> <title> Incremental evaluation for attribute grammars with unrestricted movement between tree modification. </title> <journal> Acta Informatica, </journal> <volume> 25(2) </volume> <pages> 155-178, </pages> <year> 1988. </year>
Reference-contexts: Tree comparison is computationally expensive, and extensive research has gone into reducing the cost by first limiting the analysis to a subset of "interesting trees", and then further reducing the search by detecting and eliminating matching subtrees. Tree comparison algorithms are described in <ref> [94, 111, 115, 116, 124] </ref>. These techniques can be used in refactoring as follows: Suppose the function abstractable-Function is defined in classes Class1 and Class2.
Reference: [95] <author> Thomas W. Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The most well-known of these systems for generating program development environments are the (Cornell) Synthesizer Generator <ref> [95] </ref>, GANDALF [84] and CENTAUR [22]. Ideally, these systems could be used to generate the software refactory.
Reference: [96] <author> John R. Rice and Herbert D. Schwetman. </author> <title> Interface issues in a software parts technology. </title> <booktitle> In Software Reusability Volume I: Concepts and Models, </booktitle> <pages> pages 125-140, </pages> <year> 1989. </year>
Reference-contexts: The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems. The components might be code skeletons [32, 68], subroutines <ref> [32, 68, 96] </ref> or functions. The generation-based approach, on the other hand, is aimed at reusing patterns that drive the creation of specific or customized versions of themselves. Application generators [83] and some program transformation systems [23, 33, 43, 83] are examples of generation-based systems.
Reference: [97] <author> Charles Rich and Linda M. Wills. </author> <title> Recognizing a program's design: A graph-parsing approach. </title> <journal> IEEE Software, </journal> <pages> pages 82-89, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Design recovery is a software reengineering approach that recreates design abstractions from a collection of code, existing documentation, general knowledge of the domain and heuristic reasoning [17, 34]. Design recovery has been proposed using program structures (cliches) and graph parsing <ref> [97] </ref>, a heuristic-based concept-recognition mechanism with multiple views of program knowledge [55], and an approach using an intermediate modular interconnection language to generate design descriptions [35]. None of these approaches involve code changes.
Reference: [98] <author> Roxanna Rochat. </author> <title> In search of good Smalltalk programming style. </title> <type> Technical Report CR-86-19, </type> <institution> Tektronix, </institution> <year> 1986. </year>
Reference-contexts: Tracking down the dependencies by hand and consistently updating the program can be time consuming, difficult and error prone. The reusability benefits of object-oriented programming can be difficult to realize without some form of automated support for making these structural changes <ref> [59, 98] </ref>. 1.2 A Proposed Solution This dissertation describes an approach for providing automated support for the restructuring of object-oriented programs. <p> Refactoring is especially important in object-oriented programming. Some in the object-oriented programming culture have placed high value in designing and redesigning software to make it more reusable <ref> [59, 98] </ref>. In some cases, the best way to improve the design of a program is to re-write it. <p> A refactoring tool can help a designer by providing the right set of refactorings, and by ensuring that each refactoring is applied correctly, but it cannot decide which refactorings to apply. Thus, refactoring cannot be completely automated. To understand how people refactor programs, related research <ref> [9, 30, 59, 71, 98] </ref> was surveyed, and an analysis was done of the structural changes made to the Choices file system framework [77] over a two year period. The Choices file system framework was developed using 3 the C++ programming language [114]. <p> The issues and approaches for schema evolution in object-oriented databases are discussed in [66] and the references therein. Several efforts have been underway to understand good style for object-oriented programs, to support their evolution and reuse. Rochat <ref> [98] </ref> discusses the importance of good programming style in Smalltalk and proposes several semantic and syntactic guidelines. Lieberherr and others in the Demeter project [71] have proposed an approach for hiding the structure of a class in order to increase maintainability. <p> This research also uncovered design information that was needed to automate refactorings, and considered implementation issues. Johnson and Foote recognized the need for this research in [59] and motivated its importance. 10.3 Achieving Good Style in Smalltalk Programs Rochat <ref> [98] </ref> proposes several guidelines for achieving good programming style in Smalltalk. Among the guidelines: Carefully name classes and class members. Each class and method should have a single purpose; multi-purpose classes and methods should be split. Subclasses should be refinements (in protocol or implementation) of their superclasses. <p> Among the guidelines: Carefully name classes and class members. Each class and method should have a single purpose; multi-purpose classes and methods should be split. Subclasses should be refinements (in protocol or implementation) of their superclasses. Nested conditionals should be replaced with multiple classes to achieve polymorphism. Rochat concludes <ref> [98] </ref> that organizational tools are needed to support these guidelines.
Reference: [99] <author> Marc J. Rochkind. </author> <title> The source code control system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(4):364-370, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: The approaches for detecting program differences involve string comparison, tree comparison or a combination of these techniques [12]. Program differences have been studied in regard to spelling correction [54, 109], parsing error correction [119], version storage <ref> [99] </ref> and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. The standard algorithm for string comparison is described by Wagner and Fisher [120]. The user specifies the cost of insertion, replacements and deletion of particular elements.
Reference: [100] <author> James A. Roskind. </author> <title> YACC compatible C++ grammar (and Related Tools). </title> <address> 516 Latania Palm Drive; Indialantic FL 32903 USA. </address> <note> Author can be reached by email at jar@ileaf.com or uunet!leafusa!jar. Software available via ftp from several sites. </note>
Reference-contexts: Finally, a pretty printer is called to print the refactored code. The approach that we used to build the prototype was to write a simple parser from C++ into Lisp forms using a YACC-compatible specification of C++ developed by Roskind <ref> [100] </ref>. A Common Lisp [62] program, making extensive use of the Common Lisp Object System (CLOS) facilities, used the output of the parser to build a complex structure representing the program.
Reference: [101] <author> James et al Rumbaugh. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year> <month> 139 </month>
Reference-contexts: Several tests may indicate whether an association between objects is an aggregation <ref> [101] </ref>: * Is one object part of the other? * Are some operations on the "whole" applied to its "parts"? * Are some attribute values propagated from the whole to its parts? * Is there an intrinsic asymmetry to the association, where one object class is subordinate to the other? The <p> The decision to model an association as an aggregation is a matter of judgement. As is typical in modeling, there are few hard and fast rules <ref> [101] </ref>. While it is common to represent the components of an aggregate object as member variables, not all member variables necessarily represent components. For example, member variables in an Automobile class might represent its color, age or the number of passengers it would accommodate.
Reference: [102] <author> Vince Russo, Gary Johnston, and Roy H. Campbell. </author> <title> Process Management in Multipro--cessor Operating Systems using Class Hierarchical Design. </title> <booktitle> In Proceedings of OOPSLA '88, </booktitle> <address> San Diego, Ca., </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Choices, written in C++, is more than just an operating system; it is really an operating system framework consisting of interlocking frameworks for file systems [77], virtual memory [103], communication [129], and process scheduling <ref> [102] </ref>. Good frameworks are usually the result of many design iterations and a lot of hard work involving structural changes [59, 85]. These changes may involve a single refactoring, or a series of related refactorings. The following sections describe examples of several common refactorings.
Reference: [103] <author> Vincent Russo and Roy H. Campbell. </author> <title> Virtual Memory and Backing Storage Management in Multiprocessor Operating Systems using Class Hierarchical Design. </title> <note> In Submitted to OOPSLA '89, 1989. Also available as University of Illinois Technical Report. </note>
Reference-contexts: Choices, written in C++, is more than just an operating system; it is really an operating system framework consisting of interlocking frameworks for file systems [77], virtual memory <ref> [103] </ref>, communication [129], and process scheduling [102]. Good frameworks are usually the result of many design iterations and a lot of hard work involving structural changes [59, 85]. These changes may involve a single refactoring, or a series of related refactorings. The following sections describe examples of several common refactorings.
Reference: [104] <author> Vincent F. Russo. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1991. </year>
Reference-contexts: Consider the example, shown in Figure 3.1, of an abstract class created for the Choices file system framework [76]. One of the central classes in that framework 3 is MemoryObject <ref> [104] </ref>. A MemoryObject is a sequence of identically sized blocks. It also is responsible for maintaining the number of blocks it contains. The key operations provided by MemoryObjects are read, write, and size. Many parts of the file system are MemoryObjects, such as files and disks. <p> One common case that is trivial to check is when the variable is only directly assigned the result of an object creation expression (i.e. by a call to the C++ new function) and its value is not reassigned to another variable. For example, the Choices Virtual Memory system <ref> [104] </ref> has two kinds of objects, Memory-Objects and MemoryObjectCaches. A MemoryObjectCache is a component of a MemoryObject. A MemoryObject does not always have a MemoryObjectCache, but once it gets one it never changes.
Reference: [105] <author> Vincent F. Russo and Simon M. Kaplan. </author> <title> A C++ interpreter for scheme. </title> <booktitle> In Proceedings of the USENIX C++ Workshop, </booktitle> <pages> pages 95-108, </pages> <year> 1988. </year> <note> Also Technical Report No. </note> <institution> UIUCDCS-R-88-1461, Department of Computer Science, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: These changes made the design of the Choices File System easier to understand. Another benefit that is sometimes realized by replacing conditional tests with subclassing is that the run time performance may improve, as reported by Russo and Kaplan <ref> [105] </ref>. They ported a Scheme interpreter from the C-language to C++. In a traditional C implementation, the cornerstones are a discrimination union and a procedure body that is essentially a giant switch statement.
Reference: [106] <author> Barbara Ryder. </author> <title> Paper on incremental data flow ananysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: This assumption, while safe, prevents many optimizations. One can expect to do better if the effects of a call are more carefully analyzed. The analysis of the effects of a call is generally termed interprocedural data flow analysis. <ref> [1, 44, 106] </ref> 7.3.1 Interprocedural Data Flow Analysis A procedure or subprogram can be represented as a data flow graph of basic blocks, where directed edges connecting the basic blocks represent the flow of control within the procedure.
Reference: [107] <author> Barbara G. Ryder and Marvin C. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(3) </volume> <pages> 231-276, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches [56, 118] repeatedly traverse the flow graphs until there are no more changes. Structured solutions (e.g., <ref> [7, 67, 107] </ref>) are more complex, but have much better worse case performance. 7.4 Checking Whether a Predicate is a Class Invariant In general, the problem of determining whether an arbitrary predicate is a class invariant is undecidable.
Reference: [108] <author> Markku Sakkinen. </author> <title> Comments in the law of Demeter and C++. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 38-44, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Wirfs-Brock and Wilkerson [125] argue that the law overconstrains the connections between objects, and more importantly shifts the focus away from the responsibility-driven aspects of design (where it belongs) toward the data-driven aspects. Sakkinen <ref> [108] </ref> discusses other problems in applying the Law of Demeter. Nonetheless, the Demeter work is an important contribution to object-oriented design style. Abstraction is important in improving the maintainability of object-oriented systems.
Reference: [109] <author> David Sankoff and Joseph B. Kruskal. </author> <title> Macromolecular sequences. In Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison (D. </title> <editor> Sankoff and J. Kruskal, </editor> <booktitle> eds), </booktitle> <pages> pages 45-53, </pages> <year> 1983. </year>
Reference-contexts: Before the function body can be migrated to the superclass, differences need to be separated from the common code. The approaches for detecting program differences involve string comparison, tree comparison or a combination of these techniques [12]. Program differences have been studied in regard to spelling correction <ref> [54, 109] </ref>, parsing error correction [119], version storage [99] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. The standard algorithm for string comparison is described by Wagner and Fisher [120].
Reference: [110] <author> Walt Scacchi. </author> <title> The USC system factory project. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 14(1) </volume> <pages> 61-82, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: It defines in detail three of the most complex refactorings. 4. It defines design constraints needed in refactoring, specifically class invariants and exclu sive components. The research described here could serve as the basis for a software refactory [85]. Whereas past research into a software factory (for example, <ref> [110] </ref>) has focused on generating a software program from specifications, this research has focused on how to restructure an existing program to make it easier to understand, change and reuse.
Reference: [111] <author> Stanley M. Selkow. </author> <title> The tree-to-tree editing problem. </title> <journal> Information Processing Letters, </journal> <volume> 6(6) </volume> <pages> 184-186, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: Tree comparison is computationally expensive, and extensive research has gone into reducing the cost by first limiting the analysis to a subset of "interesting trees", and then further reducing the search by detecting and eliminating matching subtrees. Tree comparison algorithms are described in <ref> [94, 111, 115, 116, 124] </ref>. These techniques can be used in refactoring as follows: Suppose the function abstractable-Function is defined in classes Class1 and Class2.
Reference: [112] <author> B. Shneiderman and G. Thomas. </author> <title> An architecture for utomatic relational database system conversion. </title> <journal> In ACM Transactions on Database Systems, </journal> <pages> pages 235-257, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: A major purpose of these changes is to infuse the code with structure, making the flow of control in a program more explicit. Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria <ref> [29, 52, 65, 68, 78, 87, 88, 90, 112] </ref>. Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121].
Reference: [113] <author> M. J. </author> <title> Spier. </title> <journal> Software malpractice a distasteful experience. Software Practice and Experience, </journal> <volume> 6 </volume> <pages> 293-299, </pages> <year> 1976. </year>
Reference-contexts: Since programmers' perceptions differ from each other, and a programmer's perception can change over time, the notion of software structure is dynamic. Many factors can contribute to poor software structure. These factors include an inadequate design methodology [14], absence of development and maintenance standards [2], buggy optimizations <ref> [113] </ref> and expedient but poorly conceived changes made to the software system to reflect changes in the environment in which it operates [25]. 7 Weinberg in [123] suggests that very small changes to a software system are much more prone to error than larger changes, because people tend to take very
Reference: [114] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: The Choices file system framework was developed using 3 the C++ programming language <ref> [114] </ref>. <p> A class sometimes embodies a general abstraction and several different concrete cases which are candidates for specialization. Often the behavior that distinguishes the concrete examples is encoded on the state of an object as flags, tags and conditions. As Stroustup notes in <ref> [114] </ref>, representing the behavior in this way may work fine for small programs written by a single person, but has a fundamental weakness: it depends on the programmer manipulating the specializations (types) in a way that cannot be checked by the compiler.
Reference: [115] <author> Kuo-Chung Tai. </author> <title> The tree-to-tree correction problem. </title> <journal> Journal of the ACM, </journal> <volume> 26(3) </volume> <pages> 422-433, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: Tree comparison is computationally expensive, and extensive research has gone into reducing the cost by first limiting the analysis to a subset of "interesting trees", and then further reducing the search by detecting and eliminating matching subtrees. Tree comparison algorithms are described in <ref> [94, 111, 115, 116, 124] </ref>. These techniques can be used in refactoring as follows: Suppose the function abstractable-Function is defined in classes Class1 and Class2.
Reference: [116] <author> Walter F. Tichy. </author> <title> Tools for software configuration management. </title> <booktitle> In Proceedings of the International Workshop on Software Version and Configuration Control (J. </booktitle> <editor> F. H. Winkler, </editor> <publisher> ed), </publisher> <pages> pages 1-20, </pages> <year> 1988. </year> <month> 140 </month>
Reference-contexts: Tree comparison is computationally expensive, and extensive research has gone into reducing the cost by first limiting the analysis to a subset of "interesting trees", and then further reducing the search by detecting and eliminating matching subtrees. Tree comparison algorithms are described in <ref> [94, 111, 115, 116, 124] </ref>. These techniques can be used in refactoring as follows: Suppose the function abstractable-Function is defined in classes Class1 and Class2.
Reference: [117] <author> Will Tracz. </author> <title> Tutorial: Software Reuse Emerging Technology. </title> <publisher> IEEE Computer Society, </publisher> <year> 1988. </year>
Reference-contexts: However, a major problem with design-level reuse is that there is no well-defined representation system for design. Reuse does not happen by accident; one needs to plan to reuse software and look for software to reuse. Reuse requires the right attitude, tools and techniques <ref> [59, 117] </ref>. Tools and techniques to support software reuse include compositional and generational approaches [18]. The composition-based model of reuse is based on the notion of plugging components together, with little or no modification of those components, in order to create target software systems.
Reference: [118] <author> V. Vyssotsky and P. Wegner. </author> <title> A graph theoretical fortran source language analyzer. </title> <type> Manuscript, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1963. </year>
Reference-contexts: Two common approaches for solving data flow problems are iterative and structured approaches [44]. Iterative approaches <ref> [56, 118] </ref> repeatedly traverse the flow graphs until there are no more changes.
Reference: [119] <author> Robert A. Wagner. </author> <title> Order-n correction for regular languages. </title> <journal> Communications of the ACM, </journal> <volume> 17(5) </volume> <pages> 265-268, </pages> <year> 1974. </year>
Reference-contexts: The approaches for detecting program differences involve string comparison, tree comparison or a combination of these techniques [12]. Program differences have been studied in regard to spelling correction [54, 109], parsing error correction <ref> [119] </ref>, version storage [99] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. The standard algorithm for string comparison is described by Wagner and Fisher [120]. The user specifies the cost of insertion, replacements and deletion of particular elements.
Reference: [120] <author> Robert A. Wagner and Michael J. Fisher. </author> <title> The string-to-string correction problem. </title> <journal> Journal of the ACM, </journal> <volume> 21(1) </volume> <pages> 168-173, </pages> <month> January </month> <year> 1974. </year>
Reference-contexts: String comparison finds the minimum cost sequence of edit operations to convert one string into another. The standard algorithm for string comparison is described by Wagner and Fisher <ref> [120] </ref>. The user specifies the cost of insertion, replacements and deletion of particular elements. Dynamic programming is used to build a cost table; then, the table is analyzed to find the minimum cost sequence. Several refinements have been proposed [12]. String comparison algorithms have their limitations.
Reference: [121] <author> S. Warren. </author> <title> Map: A tool for understanding software. </title> <booktitle> In Proceedings of the 6th International Conference on Software Engineering, </booktitle> <pages> pages 28-37. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1982. </year>
Reference-contexts: Approaches have been proposed based on code inspections and walk throughs [42, 47], adherence to software metrics [11], maintainability measures [26] or other criteria [29, 52, 65, 68, 78, 87, 88, 90, 112]. Many of the earliest commercial products in this area were developed for restructuring COBOL programs <ref> [75, 82, 121] </ref>. Several techniques have been developed based on structured programming guidelines; these include goto elimination [4, 20, 128], case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability.
Reference: [122] <author> A. I. Wasserman. </author> <title> Tutorial: Software Development Environments. </title> <publisher> IEEE Computer Society, </publisher> <year> 1981. </year>
Reference-contexts: Lyons [75] and Morgan [82] describe tools that reduce gotos, remove dead (unreachable) code, convert notes to comments, physically group I/O, and highlight looping conditions. Other tools to support software restructuring include pretty printers and code formatters, integrated programming environments <ref> [10, 122] </ref> and rule-based program transformation systems [91]. Software restructuring continues to be an important area of software engineering research. 2.3 Object-Oriented Programming, Reuse and Restructuring Object-oriented programming is often touted as promoting software reuse [45]. However, it is not a panacea.
Reference: [123] <author> G. M. Weinberg. </author> <title> Kill that code! Infosystems, </title> <address> pages 48-49, </address> <month> August </month> <year> 1983. </year>
Reference-contexts: These factors include an inadequate design methodology [14], absence of development and maintenance standards [2], buggy optimizations [113] and expedient but poorly conceived changes made to the software system to reflect changes in the environment in which it operates [25]. 7 Weinberg in <ref> [123] </ref> suggests that very small changes to a software system are much more prone to error than larger changes, because people tend to take very small changes less seriously and are therefore less likely to test them adequately.
Reference: [124] <author> Reinhard Wilhelm. </author> <title> A modified tree-to-tree correction problem. </title> <journal> Information Processing Letters, </journal> <volume> 12(3) </volume> <pages> 127-132, </pages> <month> June 13 </month> <year> 1981. </year>
Reference-contexts: Tree comparison is computationally expensive, and extensive research has gone into reducing the cost by first limiting the analysis to a subset of "interesting trees", and then further reducing the search by detecting and eliminating matching subtrees. Tree comparison algorithms are described in <ref> [94, 111, 115, 116, 124] </ref>. These techniques can be used in refactoring as follows: Suppose the function abstractable-Function is defined in classes Class1 and Class2.
Reference: [125] <author> Rebecca Wirfs-Brock and Brian Wilkerson. </author> <title> Object-oriented design: A responsibility-driven approach. </title> <booktitle> In Proceedings of OOPSLA `89, </booktitle> <pages> pages 71-75, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: There are some shortcomings to the Demeter approach. The Demeter researchers [72] note that restructuring a program to make it conform with their "law" can require increasing the number of methods and method arguments, and result in slower execution speed and poorer readability of code. Wirfs-Brock and Wilkerson <ref> [125] </ref> argue that the law overconstrains the connections between objects, and more importantly shifts the focus away from the responsibility-driven aspects of design (where it belongs) toward the data-driven aspects. Sakkinen [108] discusses other problems in applying the Law of Demeter.
Reference: [126] <author> Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: Refactorings can help make aggregations more explicit, and make component classes more reusable. The following sections describe modeling whole-part relationships, moving members between aggregate and component classes, and converting a relationship modeled using inheritance into an aggregation. 18 3.4.1 Background: Modeling Whole-Part Relationships As Wirfs-Brock, Wilkerson and Wiener note <ref> [126] </ref>, inheritance is a natural way to represent some but not all interclass relationships. <p> A mechanism is needed for representing this whole/part relationship. The whole-part relationship is a special association between objects, often called an aggregation. There are many examples <ref> [66, 126] </ref> of aggregations: * a car and its automotive parts * a company and its departments * a drawing and its drawing elements * a program and its program fragments * a desk lamp and the parts used in its manufacture. <p> This chapter discusses several approaches for supporting good object-oriented design style and for managing evolution of object-oriented systems. Also described is some recent work on restructuring applied to areas other than object-oriented systems. 10.1 CRC Approach to Designing Object-Oriented Systems Wirfs-Brock, Wilkerson and Wiener <ref> [126] </ref> describe an approach to Object-Oriented Design focusing on classes, class responsibilities and the collaborations among classes. 1 In an initial exploratory phase, classes, responsibilities and collaborations are defined.
Reference: [127] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <title> A survey of current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1990. </year>
Reference-contexts: Supporting the iterative design of an Object-Oriented Application Framework. An object-oriented application framework is an abstract design of an application, consisting of an abstract class for each major component. It is an important object-oriented technique to facilitate design-level reuse <ref> [127] </ref>. Good frameworks are usually the result of many design iterations and a lot of hard work, involving structural changes. For example, the application framework for managing files in an operating system [77] began as an implementation of only one file format.
Reference: [128] <author> E. Yourdon. </author> <title> Techniques of Program Structure and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1975. </year>
Reference-contexts: Many of the earliest commercial products in this area were developed for restructuring COBOL programs [75, 82, 121]. Several techniques have been developed based on structured programming guidelines; these include goto elimination <ref> [4, 20, 128] </ref>, case statement refinement [73] and other techniques (e.g., [29]). Parnas [87] gives principles for partitioning a system into modules to increase its maintainability.
Reference: [129] <author> Jonathan Zweig and Ralph Johnson. Conduits: </author> <title> A communication abstraction in C++. </title> <booktitle> In Proceedings of the USENIX C++ Workshop, </booktitle> <pages> pages 191-203, </pages> <year> 1990. </year> <month> 141 </month>
Reference-contexts: Choices, written in C++, is more than just an operating system; it is really an operating system framework consisting of interlocking frameworks for file systems [77], virtual memory [103], communication <ref> [129] </ref>, and process scheduling [102]. Good frameworks are usually the result of many design iterations and a lot of hard work involving structural changes [59, 85]. These changes may involve a single refactoring, or a series of related refactorings. The following sections describe examples of several common refactorings.
References-found: 129

