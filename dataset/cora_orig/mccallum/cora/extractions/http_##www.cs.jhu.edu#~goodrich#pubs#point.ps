URL: http://www.cs.jhu.edu/~goodrich/pubs/point.ps
Refering-URL: http://www.cs.jhu.edu/~goodrich/pubs/index.html
Root-URL: http://www.cs.jhu.edu
Email: goodrich@cs.jhu.edu  rt@cs.brown.edu  
Title: Dynamic Trees and Dynamic Point Location  
Author: Michael T. Goodrich Roberto Tamassia 
Keyword: Computational geometry, point location, centroid decomposition, dynamic data structures, on-line algorithms  
Web: 68U05, 68Q25, 68P05, 68P10.  
Note: AMS (MOS) Subject Classifications:  This research was supported in part by the National Science Foundation under Grants CCR-8810568, CCR-9003299, and CCR-9625289, and by U.S. Army Research Office under grant DAAH04-96-1-0013.  
Address: Baltimore, MD 21218  Providence, RI 02912-1910  
Affiliation: Dept. of Computer Science The Johns Hopkins University  Dept. of Computer Science Brown University  
Abstract: This paper describes new methods for maintaining a point-location data structure for a dynamically-changing monotone subdivision S. The main approach is based on the maintenance of two interlaced spanning trees, one for S and one for the graph-theoretic planar dual of S. Queries are answered by using a centroid decomposition of the dual tree to drive searches in the primal tree. These trees are maintained via the link-cut trees structure of Sleator and Tarjan, leading to a scheme that achieves vertex insertion/deletion in O(log n) time, insertion/deletion of k-edge monotone chains in O(log n + k) time, and answers queries in O(log 2 n) time, with O(n) space, where n is the current size of subdivision S. The techniques described also allow for the dual operations expand and contract to be implemented in O(log n) time, leading to an improved method for spatial point-location in a 3-dimensional convex subdivision. In addition, the interlaced-tree approach is applied to on-line point-location (where one builds S incrementally), improving the query bound to O(log n log log n) time and the update bounds to O(1) amortized time in this case. This appears to be the first on-line method to achieve a polylogarithmic query time and constant update time. fl A preliminary version of this paper was presented at the 23rd Annual ACM Symposium on the Theory of Computing. z This research supported in part by the National Science Foundation under grants CCR-9007851 and CCR-9423847, by the U.S. Army Research Office under grants DAAL03-91-G-0035 and DAAH04-96-1-0013, and by the Office of Naval Research and the Advanced Research Projects Agency under contract N00014-91-J-4052, ARPA order 8225. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. J. Atallah, </author> <title> Parallel techniques for computational geometry, </title> <booktitle> Proc. IEEE, 80 (1992), </booktitle> <pages> pp. 1435-1448. </pages>
Reference-contexts: A problem with tremendous potential for dynamization is planar point location, a classic problem in computational geometry (e.g., see <ref> [1, 17, 28, 33, 37] </ref>). Given a subdivision S of the plane into "cells", described by a total of n line segments, the problem is to preprocess S to allow for efficiently naming the cell containing a query point p.
Reference: [2] <author> M. J. Atallah, M. T. Goodrich, and K. Ramaiyer, </author> <title> Biased finger trees and three-dimensional layers of maxima, </title> <booktitle> in Proc. 10th Annu. ACM Sympos. </booktitle> <institution> Comput. Geom., </institution> <year> 1994, </year> <pages> pp. 150-159. </pages>
Reference-contexts: (log n) Connected [12] O (log n) O (log 3 n) O (log 3 n) Monotone [14] O (log n) O (log 2 n) O (log 2 n) Convex [39] O (log n + log N ) O (log n log N ) O (log n log N ) Staircase <ref> [2] </ref> O (log n) O (log n) O (log n) Table 1: Previous results for dynamic point location. N denotes the number of possible y-coordinates for edge endpoints in the subdivision. <p> They show how to achieve queries in O (log n) time, while requiring O (log 2 n) time for updates. The space requirement for their method is O (n log n). Finally, Atallah, Goodrich, and Ramaiyer <ref> [2] </ref> show how to apply a new data structure, which the call biased finger trees to achieve an O (log n) query time and O (log n) amortized update time for a fairly restricted class of subdivisions known as staircase subdivisions, where each face is bounded above and below by "staircase" <p> As mentioned in the introduction, Atallah et al. <ref> [2] </ref> achieve this result for the fairly restrictive class of staircase subdivisions. Acknowledgements We would like to thank Bernard Chazelle for suggesting the pursuit of an on-line point-location method with O (1) amortized update time. We would also like to thank Siu-Wing Cheng, Ravi Janardan, and S.
Reference: [3] <author> H. Baumgarten, H. Jung, and K. Mehlhorn, </author> <title> Dynamic point location in general subdivi-sions, </title> <journal> J. Algorithms, </journal> <volume> 17 (1994), </volume> <pages> pp. 342-380. </pages>
Reference-contexts: Preparata and Tamassia [38] have given techniques for maintaining monotone subdivisions that is also based on this chain-method, but improves the bounds of Fries et al. by representing the chains topologically rather than geometrically. In their scheme, in 1 Type Queries Insert Delete General <ref> [3] </ref> O (log n log log n) O (log n log log n) O (log 2 n) Connected [11] O (log 2 n) O (log n) O (log n) Connected [12] O (log n) O (log 3 n) O (log 3 n) Monotone [14] O (log n) O (log 2 n) <p> Their methods do not seem to extend to the dual update operations, however, nor does it seem possible to improve their bounds for the on-line case. The dynamic data struture by Baumgarten, Jung and Mehlhorn <ref> [3] </ref> combines interval trees, segment trees, fractional cascading and the data structure of [11]. It achieves O (n) space, O (log n log log n) query and insertion time and O (log 2 n) deletion time, where the time bounds for updates are amortized.
Reference: [4] <author> J. L. Bentley and D. Wood, </author> <title> An optimal worst case algorithm for reporting intersections of rectangles, </title> <journal> IEEE Trans. Comput., </journal> <month> C-29 </month> <year> (1980), </year> <pages> pp. 571-577. </pages>
Reference-contexts: Early work on dynamic point location includes a method by Overmars [35], which is based on a segment-tree <ref> [4] </ref> approach to planar-point location, and achieves an O (log 2 n) query and update time with O (n log n) space.
Reference: [5] <author> J. A. Bondy and U. S. R. Murty, </author> <title> Graph Theory with Applications, </title> <publisher> North-Holland, </publisher> <address> New York, NY, </address> <year> 1976. </year>
Reference-contexts: Construct a monotone spanning tree T for S, and represent T as an edge-ordered tree rooted at the sink vertex t, where the ordering of the edges incident on a vertex is given by the planar embedding. 2. Construct the graph-theoretic planar dual <ref> [5] </ref> of S, but exclude any edges dual to edges in T . This defines a spanning tree D on the dual graph [19], called the dual spanning tree of T (see Fig. 2).
Reference: [6] <author> B. Chazelle, </author> <title> A theorem on polygon cutting with applications, </title> <booktitle> in Proc. 23rd Annu. IEEE Sympos. </booktitle> <institution> Found. Comput. Sci., </institution> <year> 1982, </year> <pages> pp. </pages> <month> 339-349. </month> <title> [7] , Triangulating a simple polygon in linear time, </title> <journal> Discrete Comput. Geom., </journal> <volume> 6 (1991), </volume> <pages> pp. 485-524. </pages>
Reference-contexts: A centroid edge of T is an edge e whose removal partitions T into two trees of size at most 1 + 2n=3 each. It is well-known that if n &gt; 1, such an edge exists and can be found in time O (n) (e.g., see <ref> [6, 31] </ref>). A centroid decomposition tree for T is a rooted binary tree B recursively defined as follows: If T has a single vertex v, then B consists of a single leaf node that stores vertex v. <p> We represent D as an edge-ordered tree rooted at the external region, where the ordering of the edges incident on a node (region) is given by the planar embedding. 7 t (a) 8 3. Form a centroid decomposition of D <ref> [6, 10, 24] </ref>.
Reference: [8] <author> B. Chazelle and L. J. Guibas, Fractional cascading: I. </author> <title> A data structuring technique, </title> <journal> Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> pp. </pages> <month> 133-162. </month> <title> [9] , Fractional cascading: II. </title> <journal> Applications, Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> pp. </pages> <month> 163-191. </month> <title> [10] , Visibility and intersection problems in plane geometry, </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 (1989), </volume> <pages> pp. 551-581. </pages>
Reference-contexts: Given such a subdivision, Kirkpatrick [26] shows that one can construct an O (n)-space structure in O (n) time that allows O (log n)-time point-location queries. Edelsbrunner, Guibas, and Stolfi [18] show that one can achieve these same bounds by applying the fractional cascading paradigm of Chazelle and Guibas <ref> [8, 9] </ref> to the chain-method of Lee and Preparata [27]. <p> In this case we show how to maintain the centroid decomposition of the dual tree explicitly (in a BB (ff) tree [32]), and apply a simple version of the fractional cascading paradigm of Chazelle and Guibas <ref> [8, 9] </ref> to improve the query time to O (log n log log n) while also improving the complexity of updates to O (1) amortized time. <p> Incidentally, one can improve the query time to O (log n), while increasing the preprocessing time and space by at most a constant factor, via the fractional cascading technique of Chazelle and Guibas <ref> [8, 9] </ref>. Thus, one can modify the above approach to match the query bounds of previous point location methods [18, 26, 41]. <p> Thus, each leaf in B corresponds to a node of D, which in turn corresponds to a region in R. For each node in B we explicitly store the chains L () and R (). In addition, in the spirit of fractional cascading y <ref> [8, 9] </ref>, for each node , we maintain auxiliary lists AL () and AR (), which are defined recursively as follows: AL () = L () is a leaf L () [ AL () [ AL (-) otherwise AR () = R () is a leaf R () [ AR ()
Reference: [11] <author> S. W. Cheng and R. Janardan, </author> <title> New results on dynamic planar point location, </title> <journal> SIAM J. Comput., </journal> <volume> 21 (1992), </volume> <pages> pp. 972-999. </pages>
Reference-contexts: In their scheme, in 1 Type Queries Insert Delete General [3] O (log n log log n) O (log n log log n) O (log 2 n) Connected <ref> [11] </ref> O (log 2 n) O (log n) O (log n) Connected [12] O (log n) O (log 3 n) O (log 3 n) Monotone [14] O (log n) O (log 2 n) O (log 2 n) Convex [39] O (log n + log N ) O (log n log N <p> Cheng and Janardan <ref> [11] </ref> present two methods for dynamic planar point-location that improve the time of edge updates. <p> Their methods do not seem to extend to the dual update operations, however, nor does it seem possible to improve their bounds for the on-line case. The dynamic data struture by Baumgarten, Jung and Mehlhorn [3] combines interval trees, segment trees, fractional cascading and the data structure of <ref> [11] </ref>. It achieves O (n) space, O (log n log log n) query and insertion time and O (log 2 n) deletion time, where the time bounds for updates are amortized.
Reference: [12] <author> Y.-J. Chiang, F. P. Preparata, and R. Tamassia, </author> <title> A unified approach to dynamic point location, ray shooting, and shortest paths in planar maps, </title> <booktitle> in Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <year> 1993, </year> <pages> pp. 44-53. </pages>
Reference-contexts: In their scheme, in 1 Type Queries Insert Delete General [3] O (log n log log n) O (log n log log n) O (log 2 n) Connected [11] O (log 2 n) O (log n) O (log n) Connected <ref> [12] </ref> O (log n) O (log 3 n) O (log 3 n) Monotone [14] O (log n) O (log 2 n) O (log 2 n) Convex [39] O (log n + log N ) O (log n log N ) O (log n log N ) Staircase [2] O (log n) <p> In related work, Chiang, Preparata, and Tamassia <ref> [12] </ref> have shown that one can achieve an O (log n) query time in a dynamic environment that allows for ray-shooting queries and subdivision updates in O (log 3 n) time, and Goodrich and Tamassia [23] show how to maintain a similar environment so as to achieve O (log 2 n)
Reference: [13] <author> Y.-J. Chiang and R. Tamassia, </author> <title> Dynamic algorithms in computational geometry, </title> <booktitle> Proc. IEEE, 80 (1992), </booktitle> <pages> pp. </pages> <month> 1412-1434. </month> <title> [14] , Dynamization of the trapezoid method for planar point location in monotone subdivisions, </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 2 (1992), </volume> <pages> pp. 311-333. </pages>
Reference-contexts: 1 Introduction An exciting direction in algorithmic research has been to show how one can efficiently maintain various properties of a combinatoric or geometric structure while updating that structure in a dynamic fashion (e.g., see <ref> [13] </ref>). A problem with tremendous potential for dynamization is planar point location, a classic problem in computational geometry (e.g., see [1, 17, 28, 33, 37]).
Reference: [15] <author> R. Cole, </author> <title> Searching and storing similar lists, </title> <journal> J. Algorithms, </journal> <volume> 7 (1986), </volume> <pages> pp. 202-220. </pages>
Reference-contexts: Edelsbrunner, Guibas, and Stolfi [18] show that one can achieve these same bounds by applying the fractional cascading paradigm of Chazelle and Guibas [8, 9] to the chain-method of Lee and Preparata [27]. Cole <ref> [15] </ref> and Sarnak and Tarjan [41] independently show that One can also achieve these bounds after O (n log n) preprocessing by applying a persistence technique (e.g., see Driscoll et al. [16]) to a simple plane-sweeping procedure (as an example of a static!dynamic!static conversion). (See [17, 28, 37] for other references
Reference: [16] <author> J. R. Driscoll, N. Sarnak, D. D. Sleator, and R. E. Tarjan, </author> <title> Making data structures persistent, </title> <institution> J. Comput. Syst. Sci., </institution> <month> 38 </month> <year> (1989), </year> <pages> pp. 86-124. </pages>
Reference-contexts: Cole [15] and Sarnak and Tarjan [41] independently show that One can also achieve these bounds after O (n log n) preprocessing by applying a persistence technique (e.g., see Driscoll et al. <ref> [16] </ref>) to a simple plane-sweeping procedure (as an example of a static!dynamic!static conversion). (See [17, 28, 37] for other references on this important problem.) We are interested in maintaining a monotone subdivision dynamically, subject to edge insertion and deletion, vertex insertion and deletion, as well as the insertion or deletion of <p> These operations are useful in applying a dynamic point-location to spatial point location in 3-dimensional subdivisions [40] via persistence <ref> [16] </ref>. 1.1 Previous Work Before we describe our main results, let us briefly review previous work on dynamic point location, which we summarize in Table 1.1. <p> Moreover, as shown in [40], their scheme can be extended to the dual update operations, which leads, via persistence <ref> [16] </ref>, to a data structure for spatial point location that uses O (N log 2 N ) space, requires O (N log 2 N ) processing time, and allows for queries to be answered in O (log 2 N ) time, where N is the size of the 3-dimensional subdivision. <p> Our methods improve the previous bounds for dynamically maintaining monotone subdivisions. We also show how to extend our approach to implement the dual operations of expand and contract, which, in turn, leads to an improved data structure for spatial point location via the persistence paradigm of Driscoll et al. <ref> [16] </ref>, where one dynamizes the problem to a 3-dimensional space sweep that uses our data structure to maintain the current "slice". <p> Note that both n and the number of edges of C are O (N ). Following the same general approach of Preparata and Tamassia [40], we obtain a spatial point location data structure by combining the persistence-addition technique of Driscoll et al. <ref> [16] </ref> and our dynamic structure for planar point location. A conventional dynamic data structure is called ephemeral since its instantiation preceding an update is not recoverable after the execution of the update. <p> A fully persistent structure supports both accesses and updates to any of its past versions; a partially persistent structure supports accesses to any of its past versions, but updates only to its most current version. The general technique of Driscoll et al. <ref> [16] </ref> can be used to add persistence to an ephemeral linked data structure whose records are pointed to by a bounded number of pointers. <p> Thus, our data structure for spatial point location consists of a partially persistent version of the dynamic planar point location data structure of Theorem 4.5. By Lemma 5.1, such structure satisfies the hypothesis for applying the persistence-addition technique of <ref> [16] </ref>. It is important to observe that, although our query algorithm modifies the ephemeral data structure (see section 4.2), such changes are only temporary and need not be remembered by the persistent data structure.
Reference: [17] <author> H. Edelsbrunner, </author> <title> Algorithms in Combinatorial Geometry, </title> <booktitle> vol. 10 of EATCS Monographs on Theoretical Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1987. </year>
Reference-contexts: A problem with tremendous potential for dynamization is planar point location, a classic problem in computational geometry (e.g., see <ref> [1, 17, 28, 33, 37] </ref>). Given a subdivision S of the plane into "cells", described by a total of n line segments, the problem is to preprocess S to allow for efficiently naming the cell containing a query point p. <p> Cole [15] and Sarnak and Tarjan [41] independently show that One can also achieve these bounds after O (n log n) preprocessing by applying a persistence technique (e.g., see Driscoll et al. [16]) to a simple plane-sweeping procedure (as an example of a static!dynamic!static conversion). (See <ref> [17, 28, 37] </ref> for other references on this important problem.) We are interested in maintaining a monotone subdivision dynamically, subject to edge insertion and deletion, vertex insertion and deletion, as well as the insertion or deletion of a monotone chain of k edges.
Reference: [18] <author> H. Edelsbrunner, L. J. Guibas, and J. Stolfi, </author> <title> Optimal point location in a monotone subdivision, </title> <journal> SIAM J. Comput., </journal> <volume> 15 (1986), </volume> <pages> pp. 317-340. </pages>
Reference-contexts: Given such a subdivision, Kirkpatrick [26] shows that one can construct an O (n)-space structure in O (n) time that allows O (log n)-time point-location queries. Edelsbrunner, Guibas, and Stolfi <ref> [18] </ref> show that one can achieve these same bounds by applying the fractional cascading paradigm of Chazelle and Guibas [8, 9] to the chain-method of Lee and Preparata [27]. <p> Thus, one can modify the above approach to match the query bounds of previous point location methods <ref> [18, 26, 41] </ref>. Our motivation for designing this new method was not to simply match the performance of previous methods, however, but to design a scheme that leads to an efficient dynamic point location method.
Reference: [19] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, and M. Yung, </author> <title> Maintenance of a minimum spanning forest in a dynamic planar graph, </title> <journal> J. Algorithms, </journal> <volume> 13 (1992), </volume> <pages> pp. 33-54. </pages>
Reference-contexts: Queries are performed by using a centroid decomposition of the dual tree to drive searches in the primal tree. We dynamize this approach using the edge-ordered dynamic tree data structure of Eppstein et al. <ref> [19] </ref>, which is an extension of the link-cut trees data structure of Sleator and Tarjan [19, 42]. We use the "built-in" operations of link, cut, split, and merge to implement both our updates and queries. Our methods improve the previous bounds for dynamically maintaining monotone subdivisions. <p> Queries are performed by using a centroid decomposition of the dual tree to drive searches in the primal tree. We dynamize this approach using the edge-ordered dynamic tree data structure of Eppstein et al. [19], which is an extension of the link-cut trees data structure of Sleator and Tarjan <ref> [19, 42] </ref>. We use the "built-in" operations of link, cut, split, and merge to implement both our updates and queries. Our methods improve the previous bounds for dynamically maintaining monotone subdivisions. <p> We shall use an extension of dynamic trees, called edge-ordered dynamic trees <ref> [19] </ref>. An edge-ordered tree is a rooted tree in which a cyclic order is imposed on the edges incident on each node (including the edge to the parent). The circular sequence of edges 4 incident to node is called the edge-ring of . <p> For example, in our application the trees are drawn in the plane and we use the counterclockwise ordering of the edges around each vertex given by the embedding. Edge-ordered dynamic trees support the following repertory of update operations <ref> [19] </ref>: link ( 0 ; 00 ; e 0 ; e 00 ): this operation assumes that 0 is the root of a tree T 0 , 00 is a node of another tree T 00 , and e 00 is an edge incident on 00 . <p> Let T be a dynamic tree, subject to the above operations. Sleator and Tarjan [42] present two schemes for efficiently performing the link and cut operations on T , and these schemes carry over naturally to edge-ordered dynamic trees <ref> [19] </ref>. In this paper we assume the scheme that uses partitioning by size. <p> For more details on partitioning by size, and how it can be exploited to efficiently perform dynamic tree updates and queries, see <ref> [19, 42] </ref>. While link-cut trees support a variety of query operations, such as finding the least-common ancestor of two nodes, we shall use only the following operation that is part of the standard repertory of dynamic trees [19, 42]: expose (): create a solid path from node to the root by <p> it can be exploited to efficiently perform dynamic tree updates and queries, see <ref> [19, 42] </ref>. While link-cut trees support a variety of query operations, such as finding the least-common ancestor of two nodes, we shall use only the following operation that is part of the standard repertory of dynamic trees [19, 42]: expose (): create a solid path from node to the root by converting to solid all the dashed edges of , and converting to dashed all the the solid edges that enter a node of but are not on . (See Fig. 1.b.) This operation may violate the definition <p> Edge-ordered dynamic trees use linear space and support each of the above operations in O (log n) time, where n is the size of the tree (s) involved in the operation <ref> [19, 42] </ref>. 5 v (a) of operation expose (v) on the tree of part (a). 6 3 Our Approach In this section we address the problem of performing point location in a triangulation S with n vertices. Without loss of generality, we assume that S does not have horizontal edges. <p> Construct the graph-theoretic planar dual [5] of S, but exclude any edges dual to edges in T . This defines a spanning tree D on the dual graph <ref> [19] </ref>, called the dual spanning tree of T (see Fig. 2). <p> comb) is the only outgoing edge of its end vertex and hence is in T . 2 Our dynamic data structure for point location in S simply consists of the leftist spanning tree T of R, and of its dual spanning tree D, each represented as an edge-ordered dynamic tree <ref> [19, 42] </ref>. Tree T is rooted at the node associated with the (bottom-most) sink vertex t, and tree D is rooted at the node associated with the external region. In both trees, the ordering of the edges incident on each node is given by the planar embedding. <p> More significantly, like our triangulation, our representations must be virtual, since an update operation may cause substantial restructurings in the centroid tree and edge-lists. Our approach for overcoming this difficulty consists of representing T as an edge-ordered dynamic tree <ref> [19] </ref> (see also [42]). As we show in the following lemma, this is sufficient for us to be able to quickly perform a point-cycle query in T . Lemma 4.2: Let T be a monotone spanning tree of S, with root t. <p> By representing T as an edge-ordered link-cut tree, one can determine in time O (log n) whether a query point p is on, inside, or outside the fundamental cycle F (e) induced by a non-tree edge e of S. Proof: In a link-cut tree <ref> [19, 42] </ref> representing T the operation expose (v) returns a balanced binary tree P that represents the path of T between the root t and vertex v (i.e., the external and internal nodes of P store the vertices and edges of , respectively, such that the in-order visit of P yields <p> Then a centroid edge in D can be located in O (log n) time. Proof: As mentioned above, one of the main ideas of the link-cut tree data structure is to partition the tree D into "solid" paths and "dashed" edges <ref> [19, 42] </ref>, and represent each solid path with a binary search tree. Let be the solid path containing the root of D. <p> Let w i be the size of S i , called the weight of node i . We have that P k i=1 w i = n, where n is the number of nodes of D. From the definition of dashed edges <ref> [19, 42] </ref>, we have that w i &lt; n=2 for i = 2; ; k. We distinguish two cases. If w 1 1 + 2n=3, then there exists some j such that n=3 1 i=1 w i 1 + 2n=3. <p> If we perform these link operations in series, then we will require O (k log n) time, where k is the length of the chain. So, instead, we first build a link-cut tree representation of the chain and its corresponding comb, which takes O (k) time <ref> [19, 42] </ref>, and then perform the O (1) link operations required to link these chains into T . <p> Moreover, we maintain D as a degree-3 tree, which implies that the underlying link-cut tree representation satisfies the bounded number of pointers condition (see <ref> [19, 42] </ref> for details). The tree 22 T need not have bounded degree, however. <p> The tree 22 T need not have bounded degree, however. Nevertheless, by using the implementation of edge-ordered dynamic trees trees given by Eppstein et al. <ref> [19] </ref>, we represent T so as to satisfy the bounded-degree condition (see [19] for details). 2 Thus, we can create a persistent version of our point location data structure. But being able to search in the "past" must also be meaningful. We find this meaning in the following lemma. <p> The tree 22 T need not have bounded degree, however. Nevertheless, by using the implementation of edge-ordered dynamic trees trees given by Eppstein et al. <ref> [19] </ref>, we represent T so as to satisfy the bounded-degree condition (see [19] for details). 2 Thus, we can create a persistent version of our point location data structure. But being able to search in the "past" must also be meaningful. We find this meaning in the following lemma.
Reference: [20] <author> O. Fries, </author> <title> Zerlegung einer planaren Unterteilung der Ebene und ihre Anwendungen, m.S. </title> <type> thesis, </type> <institution> Inst. Angew. Math. Inform., Univ. Saarlandes, Saarbrucken, West Germany, </institution> <year> 1985. </year> <month> 29 </month>
Reference-contexts: Early work on dynamic point location includes a method by Overmars [35], which is based on a segment-tree [4] approach to planar-point location, and achieves an O (log 2 n) query and update time with O (n log n) space. Fries, Mehlhorn, and Naeher <ref> [20, 21] </ref> present a data structure with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time (for edge insertion/deletion only), using an approach based on the static chain-method of Lee and Preparata [27]. <p> The space for this data structure is O (n log n). One can improve the space of the above method to O (n) at the expense of making the query time an amortized bound, using the methods of Fries et al. <ref> [20, 21] </ref>. As we mentioned earlier, however, our interest is in performing updates in O (1) amortized time (O (k) time for chain insertion). In the next section we show how to modify our approach to achieve this goal.
Reference: [21] <author> O. Fries, K. Mehlhorn, and S. N aher, </author> <title> Dynamization of geometric data structures, </title> <booktitle> in Proc. 1st Annu. ACM Sympos. </booktitle> <institution> Comput. Geom., </institution> <year> 1985, </year> <pages> pp. 168-176. </pages>
Reference-contexts: Early work on dynamic point location includes a method by Overmars [35], which is based on a segment-tree [4] approach to planar-point location, and achieves an O (log 2 n) query and update time with O (n log n) space. Fries, Mehlhorn, and Naeher <ref> [20, 21] </ref> present a data structure with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time (for edge insertion/deletion only), using an approach based on the static chain-method of Lee and Preparata [27]. <p> The space for this data structure is O (n log n). One can improve the space of the above method to O (n) at the expense of making the query time an amortized bound, using the methods of Fries et al. <ref> [20, 21] </ref>. As we mentioned earlier, however, our interest is in performing updates in O (1) amortized time (O (k) time for chain insertion). In the next section we show how to modify our approach to achieve this goal.
Reference: [22] <author> M. R. Garey, D. S. Johnson, F. P. Preparata, and R. E. Tarjan, </author> <title> Triangulating a simple polygon, </title> <journal> Inform. Process. Lett., </journal> <volume> 7 (1978), </volume> <pages> pp. 175-179. </pages>
Reference-contexts: Without loss of generality, we assume that S does not have horizontal edges. General subdivisions can be handled via a preliminary triangulation step, which takes O (n) time if the subdivision is connected [7], and O (n log n) time otherwise <ref> [22] </ref>. We describe here a static method that uses O (n log n) space and preprocessing time, and supports point-location queries in O (log 2 n) time.
Reference: [23] <author> M. T. Goodrich and R. Tamassia, </author> <title> Dynamic ray shooting and shortest paths via balanced geodesic triangulations, </title> <booktitle> in Proc. 9th Annu. ACM Sympos. </booktitle> <institution> Comput. Geom., </institution> <year> 1993, </year> <pages> pp. 318-327. </pages>
Reference-contexts: In related work, Chiang, Preparata, and Tamassia [12] have shown that one can achieve an O (log n) query time in a dynamic environment that allows for ray-shooting queries and subdivision updates in O (log 3 n) time, and Goodrich and Tamassia <ref> [23] </ref> show how to maintain a similar environment so as to achieve O (log 2 n) time for all updates and queries (using a method built upon the scheme of the present paper). 1.2 Our Results In this paper we show how to dynamically maintain a monotone subdivision so as to
Reference: [24] <author> L. J. Guibas, J. Hershberger, D. Leven, M. Sharir, and R. E. Tarjan, </author> <title> Linear-time algorithms for visibility and shortest path problems inside triangulated simple polygons, </title> <journal> Algorithmica, </journal> <volume> 2 (1987), </volume> <pages> pp. 209-233. </pages>
Reference-contexts: The root of B stores edge e, and the left and right subtrees of B are centroid trees for T 0 and T 00 , respectively. The centroid decomposition tree B has O (log n) height, and can be constructed in O (n) time (e.g., see <ref> [10, 24] </ref>). 2.3 Dynamic trees Dynamic trees [42] are a versatile dynamic data structure for maintaining a forest of rooted trees. We shall use an extension of dynamic trees, called edge-ordered dynamic trees [19]. <p> We represent D as an edge-ordered tree rooted at the external region, where the ordering of the edges incident on a node (region) is given by the planar embedding. 7 t (a) 8 3. Form a centroid decomposition of D <ref> [6, 10, 24] </ref>. <p> Proof: Steps 1 and 2 can be easily implemented in O (n) time. Step 3 takes O (n) time using the method of <ref> [10, 24] </ref>.
Reference: [25] <author> L. J. Guibas and J. Stolfi, </author> <title> Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams, </title> <journal> ACM Trans. Graph., </journal> <volume> 4 (1985), </volume> <pages> pp. 74-123. </pages>
Reference-contexts: In addition, we are also interested in operations that are duals to edge insertion and deletion, as in the framework of Guibas and Stolfi <ref> [25] </ref>, where we allow for vertex expansion and contraction: an expansion splits a vertex v into two new vertices connected by an edge, and a contraction merges two adjacent vertices into a new vertex.
Reference: [26] <author> D. G. Kirkpatrick, </author> <title> Optimal search in planar subdivisions, </title> <journal> SIAM J. Comput., </journal> <volume> 12 (1983), </volume> <pages> pp. 28-35. </pages>
Reference-contexts: An important special case of the point-location problem occurs when each face in the planar subdivision is a monotone polygon with respect to the y-axis, that is, the boundary of each face is intersected at most twice by any horizontal line. Given such a subdivision, Kirkpatrick <ref> [26] </ref> shows that one can construct an O (n)-space structure in O (n) time that allows O (log n)-time point-location queries. <p> Thus, one can modify the above approach to match the query bounds of previous point location methods <ref> [18, 26, 41] </ref>. Our motivation for designing this new method was not to simply match the performance of previous methods, however, but to design a scheme that leads to an efficient dynamic point location method.
Reference: [27] <author> D. T. Lee and F. P. Preparata, </author> <title> Location of a point in a planar subdivision and its applications, </title> <journal> SIAM J. Comput., </journal> <volume> 6 (1977), </volume> <pages> pp. </pages> <month> 594-606. </month> <title> [28] , Computational geometry: a survey, </title> <journal> IEEE Trans. Comput., </journal> <volume> C-33 (1984), </volume> <pages> pp. 1072-1101. </pages>
Reference-contexts: Edelsbrunner, Guibas, and Stolfi [18] show that one can achieve these same bounds by applying the fractional cascading paradigm of Chazelle and Guibas [8, 9] to the chain-method of Lee and Preparata <ref> [27] </ref>. <p> Fries, Mehlhorn, and Naeher [20, 21] present a data structure with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time (for edge insertion/deletion only), using an approach based on the static chain-method of Lee and Preparata <ref> [27] </ref>. Neither of these methods seem to extend to the dual update operations of expand and contract, however.
Reference: [29] <author> C. Levcopoulos and M. H. Overmars, </author> <title> A balanced search tree with O(1) worst-case update time, </title> <journal> Acta Informatica, </journal> <volume> 26 (1988), </volume> <pages> pp. 269-277. </pages>
Reference-contexts: store the elements of L () that fall between e and f in a data structure that allows O (1) insertion time, given an element's position, and O (log n e ) query time, where n e = O (N ) is the number of elements between e and f <ref> [29] </ref>. The elements of L () between e and f can intuitively be viewed as belonging to a "bucket" for the pair (e; f ). We modify our definition of the AL and AR lists to take advantage of the sublists L 0 and R 0 .
Reference: [30] <author> E. M. McCreight, </author> <title> Priority search trees, </title> <journal> SIAM J. Comput., </journal> <volume> 14 (1985), </volume> <pages> pp. 257-276. </pages>
Reference-contexts: Both of their methods are based on a search strategy derived from the priority search tree data structure of McCreight <ref> [30] </ref>.
Reference: [31] <author> N. Megiddo, </author> <title> Linear-time algorithms for linear programming in R 3 and related problems, </title> <journal> SIAM J. Comput., </journal> <volume> 12 (1983), </volume> <pages> pp. 759-776. </pages>
Reference-contexts: A centroid edge of T is an edge e whose removal partitions T into two trees of size at most 1 + 2n=3 each. It is well-known that if n &gt; 1, such an edge exists and can be found in time O (n) (e.g., see <ref> [6, 31] </ref>). A centroid decomposition tree for T is a rooted binary tree B recursively defined as follows: If T has a single vertex v, then B consists of a single leaf node that stores vertex v.
Reference: [32] <author> K. Mehlhorn, </author> <title> Sorting and Searching, vol. 1 of Data Structures and Algorithms, </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1984. </year>
Reference-contexts: Both of their methods are based on a search strategy derived from the priority search tree data structure of McCreight [30]. They dynamize this approach with the BB (ff) tree data structure (e.g., see <ref> [32] </ref>), using the approach of Willard and Lueker [43] to spread local updates over future operations, and the method of Overmars [34] to perform global rebuilding (at the same time) before the "current" data structure becomes too unbalanced. <p> Finally, we show how to apply our approach to on-line planar point location, where one builds a monotone subdivision incrementally. In this case we show how to maintain the centroid decomposition of the dual tree explicitly (in a BB (ff) tree <ref> [32] </ref>), and apply a simple version of the fractional cascading paradigm of Chazelle and Guibas [8, 9] to improve the query time to O (log n log log n) while also improving the complexity of updates to O (1) amortized time. <p> This is because the size of AL () and AR () is bounded by the number of vertices in P (), the subpolygon associated with , which is O (n ). We can, therefore, take advantage of the following lemma: Lemma 6.1 <ref> [32] </ref>: Let ff 2 (1=4; 1 p 2=2) and let f be a non-decreasing function such that the cost of performing a rotation in a BB (ff) tree at a node is f (n ).
Reference: [33] <author> J. O'Rourke, </author> <title> Computational geometry, </title> <type> Annu. Rev. </type> <institution> Comput. Sci., </institution> <month> 3 </month> <year> (1988), </year> <pages> pp. 389-411. </pages>
Reference-contexts: A problem with tremendous potential for dynamization is planar point location, a classic problem in computational geometry (e.g., see <ref> [1, 17, 28, 33, 37] </ref>). Given a subdivision S of the plane into "cells", described by a total of n line segments, the problem is to preprocess S to allow for efficiently naming the cell containing a query point p.
Reference: [34] <author> M. H. Overmars, </author> <title> The design of dynamic data structures, </title> <booktitle> vol. 156 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983. </year> <title> [35] , Range searching in a set of line segments, </title> <booktitle> in Proc. 1st Annu. ACM Sympos. </booktitle> <institution> Comput. Geom., </institution> <year> 1985, </year> <pages> pp. 177-185. </pages>
Reference-contexts: They dynamize this approach with the BB (ff) tree data structure (e.g., see [32]), using the approach of Willard and Lueker [43] to spread local updates over future operations, and the method of Overmars <ref> [34] </ref> to perform global rebuilding (at the same time) before the "current" data structure becomes too unbalanced. Their methods do not seem to extend to the dual update operations, however, nor does it seem possible to improve their bounds for the on-line case. <p> This can also be viewed as an instance of dynamic point location when only insertions are allowed. In this section we show how to implement our centroid-decomposition approach to planar point location on-line using BB (ff) trees and some dynamic data structuring techniques of Overmars <ref> [34] </ref> to achieve O (1) amortized time per update and O (log n log log n) time (worst-case) for answering queries. <p> Our modification reduces the space to O (n) and increases the query time by only a log log n factor. 26 6.2 Improving the Implementation The main idea of our improvement is to apply a "bucketing" technique <ref> [34] </ref> at two different places in our structure. The first application is for the L and R lists at the nodes of B. For simplicity of expression, let us concentrate our attention on the L lists; the modifications for the R lists are similar.
Reference: [36] <author> F. P. Preparata, </author> <title> A new approach to planar point location, </title> <journal> SIAM J. Comput., </journal> <volume> 10 (1981), </volume> <pages> pp. 473-482. </pages>
Reference-contexts: Chiang and Tamassia [14] present a dynamic data structure for monotone subdivisions, which is based on the static trapezoid method of Preparata <ref> [36] </ref> and extends previous work by Preparata and Tamassia [39] on dynamic point location in convex subdivisions with vertices on a fixed set of lines. The operations supported are insertion and deletion of 2 vertices and edges, and horizontal translation of vertices.
Reference: [37] <author> F. P. Preparata and M. I. Shamos, </author> <title> Computational Geometry: An Introduction, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: A problem with tremendous potential for dynamization is planar point location, a classic problem in computational geometry (e.g., see <ref> [1, 17, 28, 33, 37] </ref>). Given a subdivision S of the plane into "cells", described by a total of n line segments, the problem is to preprocess S to allow for efficiently naming the cell containing a query point p. <p> Cole [15] and Sarnak and Tarjan [41] independently show that One can also achieve these bounds after O (n log n) preprocessing by applying a persistence technique (e.g., see Driscoll et al. [16]) to a simple plane-sweeping procedure (as an example of a static!dynamic!static conversion). (See <ref> [17, 28, 37] </ref> for other references on this important problem.) We are interested in maintaining a monotone subdivision dynamically, subject to edge insertion and deletion, vertex insertion and deletion, as well as the insertion or deletion of a monotone chain of k edges. <p> We assume that S has one unbounded region, called the external region. A subdivision S is generated by a planar graph embedded in the plane such that the edges are straight-line segments. We assume a standard representation for the subdivision S, such as doubly-connected edge lists <ref> [37] </ref>. A monotone chain is a polygonal chain such that each horizontal line intersects it in at most one point. A polygon is monotone if its boundary is partitionable into two monotone chains. A monotone subdivision is such that all its regions are monotone polygons (even the external region).
Reference: [38] <author> F. P. Preparata and R. Tamassia, </author> <title> Fully dynamic point location in a monotone subdivision, </title> <journal> SIAM J. Comput., </journal> <volume> 18 (1989), </volume> <pages> pp. </pages> <month> 811-830. </month> <title> [39] , Dynamic planar point location with optimal query time, </title> <type> Theoret. </type> <institution> Comput. Sci., </institution> <month> 74 </month> <year> (1990), </year> <pages> pp. </pages> <month> 95-114. </month> <title> [40] , Efficient point location in a convex spatial cell-complex, </title> <journal> SIAM J. Comput., </journal> <volume> 21 (1992), </volume> <pages> pp. 267-280. </pages>
Reference-contexts: Neither of these methods seem to extend to the dual update operations of expand and contract, however. Preparata and Tamassia <ref> [38] </ref> have given techniques for maintaining monotone subdivisions that is also based on this chain-method, but improves the bounds of Fries et al. by representing the chains topologically rather than geometrically.
Reference: [41] <author> N. Sarnak and R. E. Tarjan, </author> <title> Planar point location using persistent search trees, </title> <journal> Commun. ACM, </journal> <volume> 29 (1986), </volume> <pages> pp. 669-679. </pages>
Reference-contexts: Edelsbrunner, Guibas, and Stolfi [18] show that one can achieve these same bounds by applying the fractional cascading paradigm of Chazelle and Guibas [8, 9] to the chain-method of Lee and Preparata [27]. Cole [15] and Sarnak and Tarjan <ref> [41] </ref> independently show that One can also achieve these bounds after O (n log n) preprocessing by applying a persistence technique (e.g., see Driscoll et al. [16]) to a simple plane-sweeping procedure (as an example of a static!dynamic!static conversion). (See [17, 28, 37] for other references on this important problem.) We <p> Thus, one can modify the above approach to match the query bounds of previous point location methods <ref> [18, 26, 41] </ref>. Our motivation for designing this new method was not to simply match the performance of previous methods, however, but to design a scheme that leads to an efficient dynamic point location method.
Reference: [42] <author> D. D. Sleator and R. E. Tarjan, </author> <title> A data structure for dynamic trees, </title> <institution> J. Comput. Syst. Sci., </institution> <month> 26 </month> <year> (1983), </year> <pages> pp. 362-381. </pages>
Reference-contexts: Queries are performed by using a centroid decomposition of the dual tree to drive searches in the primal tree. We dynamize this approach using the edge-ordered dynamic tree data structure of Eppstein et al. [19], which is an extension of the link-cut trees data structure of Sleator and Tarjan <ref> [19, 42] </ref>. We use the "built-in" operations of link, cut, split, and merge to implement both our updates and queries. Our methods improve the previous bounds for dynamically maintaining monotone subdivisions. <p> The centroid decomposition tree B has O (log n) height, and can be constructed in O (n) time (e.g., see [10, 24]). 2.3 Dynamic trees Dynamic trees <ref> [42] </ref> are a versatile dynamic data structure for maintaining a forest of rooted trees. We shall use an extension of dynamic trees, called edge-ordered dynamic trees [19]. <p> If ffe is the edge-ring of of 0 and fie is the edge-ring of 00 , then fffi is the edge-ring of . Let T be a dynamic tree, subject to the above operations. Sleator and Tarjan <ref> [42] </ref> present two schemes for efficiently performing the link and cut operations on T , and these schemes carry over naturally to edge-ordered dynamic trees [19]. In this paper we assume the scheme that uses partitioning by size. <p> For more details on partitioning by size, and how it can be exploited to efficiently perform dynamic tree updates and queries, see <ref> [19, 42] </ref>. While link-cut trees support a variety of query operations, such as finding the least-common ancestor of two nodes, we shall use only the following operation that is part of the standard repertory of dynamic trees [19, 42]: expose (): create a solid path from node to the root by <p> it can be exploited to efficiently perform dynamic tree updates and queries, see <ref> [19, 42] </ref>. While link-cut trees support a variety of query operations, such as finding the least-common ancestor of two nodes, we shall use only the following operation that is part of the standard repertory of dynamic trees [19, 42]: expose (): create a solid path from node to the root by converting to solid all the dashed edges of , and converting to dashed all the the solid edges that enter a node of but are not on . (See Fig. 1.b.) This operation may violate the definition <p> Edge-ordered dynamic trees use linear space and support each of the above operations in O (log n) time, where n is the size of the tree (s) involved in the operation <ref> [19, 42] </ref>. 5 v (a) of operation expose (v) on the tree of part (a). 6 3 Our Approach In this section we address the problem of performing point location in a triangulation S with n vertices. Without loss of generality, we assume that S does not have horizontal edges. <p> comb) is the only outgoing edge of its end vertex and hence is in T . 2 Our dynamic data structure for point location in S simply consists of the leftist spanning tree T of R, and of its dual spanning tree D, each represented as an edge-ordered dynamic tree <ref> [19, 42] </ref>. Tree T is rooted at the node associated with the (bottom-most) sink vertex t, and tree D is rooted at the node associated with the external region. In both trees, the ordering of the edges incident on each node is given by the planar embedding. <p> More significantly, like our triangulation, our representations must be virtual, since an update operation may cause substantial restructurings in the centroid tree and edge-lists. Our approach for overcoming this difficulty consists of representing T as an edge-ordered dynamic tree [19] (see also <ref> [42] </ref>). As we show in the following lemma, this is sufficient for us to be able to quickly perform a point-cycle query in T . Lemma 4.2: Let T be a monotone spanning tree of S, with root t. <p> By representing T as an edge-ordered link-cut tree, one can determine in time O (log n) whether a query point p is on, inside, or outside the fundamental cycle F (e) induced by a non-tree edge e of S. Proof: In a link-cut tree <ref> [19, 42] </ref> representing T the operation expose (v) returns a balanced binary tree P that represents the path of T between the root t and vertex v (i.e., the external and internal nodes of P store the vertices and edges of , respectively, such that the in-order visit of P yields <p> Then a centroid edge in D can be located in O (log n) time. Proof: As mentioned above, one of the main ideas of the link-cut tree data structure is to partition the tree D into "solid" paths and "dashed" edges <ref> [19, 42] </ref>, and represent each solid path with a binary search tree. Let be the solid path containing the root of D. <p> Let w i be the size of S i , called the weight of node i . We have that P k i=1 w i = n, where n is the number of nodes of D. From the definition of dashed edges <ref> [19, 42] </ref>, we have that w i &lt; n=2 for i = 2; ; k. We distinguish two cases. If w 1 1 + 2n=3, then there exists some j such that n=3 1 i=1 w i 1 + 2n=3. <p> If we perform these link operations in series, then we will require O (k log n) time, where k is the length of the chain. So, instead, we first build a link-cut tree representation of the chain and its corresponding comb, which takes O (k) time <ref> [19, 42] </ref>, and then perform the O (1) link operations required to link these chains into T . <p> Moreover, we maintain D as a degree-3 tree, which implies that the underlying link-cut tree representation satisfies the bounded number of pointers condition (see <ref> [19, 42] </ref> for details). The tree 22 T need not have bounded degree, however.
Reference: [43] <author> D. E. Willard and G. S. Lueker, </author> <title> Adding range restriction capability to dynamic data structures, </title> <journal> J. ACM, </journal> <volume> 32 (1985), </volume> <pages> pp. 597-617. 31 </pages>
Reference-contexts: Both of their methods are based on a search strategy derived from the priority search tree data structure of McCreight [30]. They dynamize this approach with the BB (ff) tree data structure (e.g., see [32]), using the approach of Willard and Lueker <ref> [43] </ref> to spread local updates over future operations, and the method of Overmars [34] to perform global rebuilding (at the same time) before the "current" data structure becomes too unbalanced.
References-found: 35

