URL: ftp://ftp.cs.berkeley.edu/ucb/sprite/papers/lfsSOSP91.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/mds/research/1995/meterprop.html
Root-URL: 
Email: mendel@sprite.berkeley.edu, ouster@sprite.berkeley.edu  
Title: The Design and Implementation of a Log-Structured File System  
Author: Mendel Rosenblum and John K. Ousterhout 
Address: Berkeley, CA 94720  
Affiliation: Electrical Engineering and Computer Sciences, Computer Science Division University of California  
Abstract: This paper presents a new technique for disk storage management called a log-structured file system. A log-structured file system writes all modifications to disk sequentially in a log-like structure, thereby speeding up both file writing and crash recovery. The log is the only structure on disk; it contains indexing information so that files can be read back from the log efficiently. In order to maintain large free areas on disk for fast writing, we divide the log into segments and use a segment cleaner to compress the live information from heavily fragmented segments. We present a series of simulations that demonstrate the efficiency of a simple cleaning policy based on cost and benefit. We have implemented a prototype log-structured file system called Sprite LFS; it outperforms current Unix file systems by an order of magnitude for small-file writes while matching or exceeding Unix performance for reads and large writes. Even when the overhead for cleaning is included, Sprite LFS can use 70% of the disk bandwidth for writing, whereas Unix file systems typically can use only 5-10%. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> John K. Ousterhout, Herve Da Costa, David Harrison, John A. Kunze, Mike Kupfer, </author> <title> and James July 24, 1991 - 14 - G. Thompson, ``A TraceDriven Analysis of the Unix 4.2 BSD File System,'' </title> <booktitle> Proceedings of the 10th Symposium on Operating Systems Principles, </booktitle> <pages> pp. 15-24 ACM, </pages> <year> (1985). </year>
Reference-contexts: Log-structured file systems are based on the assumption that files are cached in main memory and that increasing memory sizes will make the caches more and more effective at satisfying read requests <ref> [1] </ref>. As a result, disk traffic will become dominated by writes. A log-structured file system writes all new information to disk in a sequential structure called the log. This approach increases write performance dramatically by eliminating almost all seeks. <p> Modern file systems cache recently-used file data in main memory, and larger main memories make larger file caches possible. This has two effects on file system behavior. First, larger file caches alter the workload presented to the disk by absorbing a greater fraction of the read requests <ref> [1, 6] </ref>. Most write requests must eventually be reflected on disk for safety, so disk traffic (and disk performance) will become more and more dominated by writes. <p> One of the most difficult work-loads for file system designs to handle efficiently is found in office and engineering environments. Office and engineering applications tend to be dominated by accesses to small files; several studies have measured mean file sizes of only a few kilobytes <ref> [1, 6-8] </ref>. Small files usually result in small random disk I/Os, and the creation and deletion times for such files are often dominated by updates to file system ``metadata'' (the data structures used to locate the attributes and blocks of the file).
Reference: 2. <author> Michael L. Kazar, Bruce W. Leverett, Owen T. Anderson, Vasilis Apostolides, Beth A. Bottos, Sailesh Chutani, Craig F. Everhart, W. Anthony Mason, Shu-Tsui Tu, and Edward R. Zayas, </author> <title> ``DEcorum File System Architectural Overview,'' </title> <booktitle> Proceedings of the USENIX 1990 Summer Conference, </booktitle> <pages> pp. </pages> <month> 151-164 (Jun </month> <year> 1990). </year>
Reference-contexts: The notion of logging is not new, and a number of recent file systems have incorporated a log as an auxiliary structure to speed up writes and crash recovery <ref> [2, 3] </ref>. However, these other systems use the log only for temporary storage; the permanent home for information is in a traditional random-access storage structure on disk. In contrast, a log-structured file system stores data permanently in the log: there is no other structure on disk. <p> Thus it should be possible to recover very quickly after crashes. This benefit of logs is well known and has been used to advantage both in database systems [13] and in other file systems <ref> [2, 3, 14] </ref>. Like many other logging systems, Sprite LFS uses a two-pronged approach to recovery: checkpoints, which define consistent states of the file system, and roll-forward, which is used to recover information written since the last checkpoint. 4.1. <p> Logging file systems like Episode <ref> [2] </ref> or Cedar [3] are likely to be somewhat more complicated than either Unix FFS or Sprite LFS, since they include both logging and layout code. In everyday use Sprite LFS does not feel much different to the users than the Unix FFS-like file system in Sprite.
Reference: 3. <author> Robert B. Hagmann, </author> <title> ``Reimplementing the Cedar File System Using Logging and Group Commit,'' </title> <booktitle> Proceedings of the 11th Symposium on Operating Systems Principles, </booktitle> <pages> pp. </pages> <month> 155-162 (Nov </month> <year> 1987). </year>
Reference-contexts: The notion of logging is not new, and a number of recent file systems have incorporated a log as an auxiliary structure to speed up writes and crash recovery <ref> [2, 3] </ref>. However, these other systems use the log only for temporary storage; the permanent home for information is in a traditional random-access storage structure on disk. In contrast, a log-structured file system stores data permanently in the log: there is no other structure on disk. <p> Thus it should be possible to recover very quickly after crashes. This benefit of logs is well known and has been used to advantage both in database systems [13] and in other file systems <ref> [2, 3, 14] </ref>. Like many other logging systems, Sprite LFS uses a two-pronged approach to recovery: checkpoints, which define consistent states of the file system, and roll-forward, which is used to recover information written since the last checkpoint. 4.1. <p> Logging file systems like Episode [2] or Cedar <ref> [3] </ref> are likely to be somewhat more complicated than either Unix FFS or Sprite LFS, since they include both logging and layout code. In everyday use Sprite LFS does not feel much different to the users than the Unix FFS-like file system in Sprite.
Reference: 4. <author> John K. Ousterhout, Andrew R. Cherenson, Freder-ick Douglis, Michael N. Nelson, and Brent B. Welch, </author> <title> ``The Sprite Network Operating System,'' </title> <journal> IEEE Computer 21(2) pp. </journal> <month> 23-36 </month> <year> (1988). </year>
Reference-contexts: We have constructed a prototype log-structured file system called Sprite LFS, which is now in production use as part of the Sprite network operating system <ref> [4] </ref>. Benchmark programs demonstrate that the raw writing speed of Sprite LFS is more than an order of magnitude greater than that of Unix for small files.
Reference: 5. <author> David A. Patterson, Garth Gibson, and Randy H. Katz, </author> <title> ``A Case for Redundant Arrays of Inexpensive Disks (RAID),'' </title> <booktitle> ACM SIGMOD 88, </booktitle> <pages> pp. </pages> <month> 109-116 (Jun </month> <year> 1988). </year>
Reference-contexts: There are two components of disk performance: transfer bandwidth and access time. Although both of these factors are improving, the rate of improvement is much slower than for CPU speed. Disk transfer bandwidth can be improved substantially with the use of disk arrays and parallel-head disks <ref> [5] </ref> but no major improvements seem likely for access time (it is determined by mechanical motions that are hard to improve).
Reference: 6. <author> Mary G. Baker, John H. Hartman, Michael D. Kupfer, Ken W. Shirriff, and John K. Ousterhout, </author> <title> ``Measurements of a Distributed File System,'' </title> <booktitle> Proceedings of the 13th Symposium on Operating Systems Principles, ACM, </booktitle> <month> (Oct </month> <year> 1991). </year>
Reference-contexts: Modern file systems cache recently-used file data in main memory, and larger main memories make larger file caches possible. This has two effects on file system behavior. First, larger file caches alter the workload presented to the disk by absorbing a greater fraction of the read requests <ref> [1, 6] </ref>. Most write requests must eventually be reflected on disk for safety, so disk traffic (and disk performance) will become more and more dominated by writes.
Reference: 7. <author> M. Satyanarayanan, </author> <title> ``A Study of File Sizes and Functional Lifetimes,'' </title> <booktitle> Proceedings of the 8th Symposium on Operating Systems Principles, </booktitle> <pages> pp. 96-108 ACM, </pages> <year> (1981). </year>
Reference: 8. <author> Edward D. Lazowska, John Zahorjan, David R Cher-iton, and Willy Zwaenepoel, </author> <title> ``File Access Performance of Diskless Workstations,'' </title> <journal> Transactions on Computer Systems 4(3) pp. </journal> <month> 238-268 (Aug </month> <year> 1986). </year>
Reference: 9. <author> Marshall K. McKusick, </author> <title> ``A Fast File System for Unix,'' </title> <journal> Transactions on Computer Systems 2(3) pp. 181-197 ACM, </journal> <year> (1984). </year>
Reference-contexts: When we began the project we were concerned that a log-structured file system might be substantially more complicated to implement than a traditional file system. In reality, however, Sprite LFS turns out to be no more complicated than Unix FFS <ref> [9] </ref>: Sprite LFS has additional complexity for the segment cleaner, but this is compensated by the elimination of the bitmap and layout policies required by Unix FFS; in addition, the checkpointing and roll-forward code in Sprite LFS is no more complicated than the fsck code [15] that scans Unix FFS disks
Reference: 10. <author> R. Sandberg, </author> <title> ``Design and Implementation of the Sun Network Filesystem,'' </title> <booktitle> Proceedings of the USENIX 1985 Summer Conference, </booktitle> <pages> pp. </pages> <month> 119-130 (Jun </month> <year> 1985). </year>
Reference-contexts: Synchronous writes couple the application's performance to that of the disk and make it hard for the application to benefit from faster CPUs. They also defeat the potential use of the file cache as a write buffer. Unfortunately, network file systems like NFS <ref> [10] </ref> have introduced additional synchronous behavior where it didn't used to exist. This has simplified crash recovery, but it has reduced write performance.
Reference: 11. <author> John K. Ousterhout, </author> <title> ``Why Aren't Operating Systems Getting Faster As Fast as Hardware?,'' </title> <booktitle> Proceedings of the USENIX 1990 Summer Conference, </booktitle> <pages> pp. </pages> <month> 247-256 (Jun </month> <year> 1990). </year>
Reference-contexts: If a segment to be cleaned has no live blocks (u = 0) then it need not be read at all and the write cost is 1.0. reference, Unix FFS on small-file workloads utilizes at most 5-10% of the disk bandwidth, for a write cost of 10-20 (see <ref> [11] </ref> and Figure 8 in Section 5.1 for specific measurements). With logging, delayed writes, and disk request sorting this can probably be improved to about 25% of the bandwidth [12] or a write cost of 4. <p> In everyday use Sprite LFS does not feel much different to the users than the Unix FFS-like file system in Sprite. The reason is that the machines being used are not fast enough to be disk-bound with the current workloads. For example on the modified Andrew benchmark <ref> [11] </ref>, July 24, 1991 - 10 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (b) (a) Files/sec (predicted)Files/sec (measured) 10000 1K file create 10000 1K file access Sun4 2*Sun4 4*Sun4 75 225 375 525 675 Create Read Delete 0 40 80 120 160 Sprite LFS SunOSKey: SunOS.
Reference: 12. <author> Margo I. Seltzer, Peter M. Chen, and John K. Ousterhout, </author> <title> ``Disk Scheduling Revisited,'' </title> <booktitle> Proceedings of the Winter 1990 USENIX Technical Conference, </booktitle> <month> (January </month> <year> 1990). </year>
Reference-contexts: With logging, delayed writes, and disk request sorting this can probably be improved to about 25% of the bandwidth <ref> [12] </ref> or a write cost of 4. Figure 3 suggests that the segments cleaned must have a utilization of less than .8 in order for a log-structured file system to outperform the current Unix FFS; the utilization must be less than .5 to outperform an improved Unix FFS.
Reference: 13. <author> Jim Gray, </author> <title> ``Notes on Data Base Operating Systems,'' in Operating Systems, An Advanced Course, </title> <publisher> Springer-Verlag (1979). </publisher>
Reference-contexts: Thus it should be possible to recover very quickly after crashes. This benefit of logs is well known and has been used to advantage both in database systems <ref> [13] </ref> and in other file systems [2, 3, 14]. Like many other logging systems, Sprite LFS uses a two-pronged approach to recovery: checkpoints, which define consistent states of the file system, and roll-forward, which is used to recover information written since the last checkpoint. 4.1. <p> The logging scheme used in Sprite LFS is similar to schemes pioneered in database systems. Almost all database systems use write-ahead logging for crash recovery and high performance <ref> [13] </ref>, but differ from Sprite LFS in how they use the log.
Reference: 14. <author> A. Chang, M. F. Mergen, R. K. Rader, J. A. Roberts, and S. L. Porter, </author> <title> ``Evolution of storage facilities in AIX Version 3 for RISC System/6000 processors,'' </title> <journal> IBM Journal of Research and Development 34(1) pp. </journal> <month> 105-109 (Jan </month> <year> 1990). </year>
Reference-contexts: Thus it should be possible to recover very quickly after crashes. This benefit of logs is well known and has been used to advantage both in database systems [13] and in other file systems <ref> [2, 3, 14] </ref>. Like many other logging systems, Sprite LFS uses a two-pronged approach to recovery: checkpoints, which define consistent states of the file system, and roll-forward, which is used to recover information written since the last checkpoint. 4.1.
Reference: 15. <author> Marshall Kirk McKusick, Willian N. Joy, Samuel J. Leffler, and Robert S. Fabry, </author> <title> ``Fsck The UNIX File System Check Program,'' Unix System Manager's Manual - 4.3 BSD Virtual VAX-11 Version, </title> <booktitle> USENIX, </booktitle> <month> (Apr </month> <year> 1986). </year>
Reference-contexts: more complicated than Unix FFS [9]: Sprite LFS has additional complexity for the segment cleaner, but this is compensated by the elimination of the bitmap and layout policies required by Unix FFS; in addition, the checkpointing and roll-forward code in Sprite LFS is no more complicated than the fsck code <ref> [15] </ref> that scans Unix FFS disks to restore consistency. Logging file systems like Episode [2] or Cedar [3] are likely to be somewhat more complicated than either Unix FFS or Sprite LFS, since they include both logging and layout code.
Reference: 16. <author> Larry McVoy and Steve Kleiman, </author> <title> ``Extent-like Performance from a UNIX File System,'' </title> <booktitle> Proceedings of the USENIX 1991 Winter Conference, </booktitle> <month> (Jan </month> <year> 1991). </year>
Reference-contexts: Sprite LFS has a higher write bandwidth and the same read bandwidth as SunOS with the exception of sequential reading of a file that was written randomly. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh July 24, 1991 - 11 - individual disk operations for each block (a newer version of SunOS groups writes <ref> [16] </ref> and should therefore have performance equivalent to Sprite LFS).
Reference: 17. <author> D. Reed and Liba Svobodova, ``SWALLOW: </author> <title> A Distributed Data Storage System for a Local Network,'' </title> <booktitle> Local Networks for Computer Communications, </booktitle> <pages> pp. 355-373 North-Holland, </pages> <year> (1981). </year>
Reference-contexts: Related work The log-structured file system concept and the Sprite LFS design borrow ideas from many different storage management systems. File systems with log-like structures have appeared in several proposals for building file systems on write-once media <ref> [17, 18] </ref>. Besides writing all changes in an append-only fashion, these systems maintain indexing information much like the Sprite LFS inode map and inodes for quickly locating and reading files.
Reference: 18. <author> Ross S. Finlayson and David R. Cheriton, </author> <title> ``Log Files: An Extended File Service Exploiting Write-Once Storage,'' </title> <booktitle> Proceedings of the 11th Symposium on Operating Systems Principles, </booktitle> <pages> pp. 129-148 ACM, </pages> <month> (Nov </month> <year> 1987). </year>
Reference-contexts: Related work The log-structured file system concept and the Sprite LFS design borrow ideas from many different storage management systems. File systems with log-like structures have appeared in several proposals for building file systems on write-once media <ref> [17, 18] </ref>. Besides writing all changes in an append-only fashion, these systems maintain indexing information much like the Sprite LFS inode map and inodes for quickly locating and reading files.
Reference: 19. <author> H. G. Baker, </author> <title> ``List Processing in Real Time on a Serial Computer,'' A.I. </title> <type> Working Paper 139, </type> <institution> MIT-AI Lab, </institution> <address> Boston, MA (April 1977). </address>
Reference-contexts: They differ from Sprite LFS in that the write-once nature of the media made it unnecessary for the file systems to reclaim log space. The segment cleaning approach used in Sprite LFS acts much like scavenging garbage collectors developed for programming languages <ref> [19] </ref>. The cost-benefit segment selection and the age sorting of blocks during segment cleaned in Sprite LFS separates files into generations much like generational garbage collection schemes [20].
Reference: 20. <author> Henry Lieberman and Carl Hewitt, </author> <title> ``A Real-Time Garbage Collector Based on the Lifetimes of Objects,'' </title> <journal> Communications of the ACM 26(6) pp. </journal> <month> 419-429 </month> <year> (1983). </year>
Reference-contexts: The segment cleaning approach used in Sprite LFS acts much like scavenging garbage collectors developed for programming languages [19]. The cost-benefit segment selection and the age sorting of blocks during segment cleaned in Sprite LFS separates files into generations much like generational garbage collection schemes <ref> [20] </ref>. A significant difference between these garbage collection schemes and Sprite LFS is that efficient random access is possible in the generational garbage collectors, whereas sequential accesses are necessary to achieve high performance in a file system.
Reference: 21. <author> Brian M. Oki, Barbara H. Liskov, and Robert W. Scheifler, </author> <title> ``Reliable Object Storage to Support Atomic Actions,'' </title> <booktitle> Proceedings of the 10th Symposium on Operating Systems Principles, </booktitle> <pages> pp. 147-159 ACM, </pages> <year> (1985). </year>
Reference-contexts: Typically only the changed bytes are written to database logs rather than entire blocks as in Sprite LFS. The Sprite LFS crash recovery mechanism of checkpoints and roll forward using a ``redo log'' is similar to techniques used in database systems and object repositories <ref> [21] </ref>. The implementation in Sprite LFS is simplified because the log is the final home of the data. Rather than redoing the operation to the separate data copy, Sprite LFS recovery insures that the indexes point at the newest copy of the data in the log.
Reference: 22. <author> David J. DeWitt, Randy H. Katz, Frank Olken, L. D. Shapiro, Mike R. Stonebraker, and David Wood, </author> <title> ``Implementation Techniques for Main Memory Database Systems,'' </title> <booktitle> Proceedings of SIGMOD 1984, </booktitle> <pages> pp. </pages> <month> 1-8 (Jun </month> <year> 1984). </year>
Reference-contexts: Collecting data in the file cache and writing it to disk in large writes is similar to the concept of group commit in database systems <ref> [22] </ref> and to techniques used in main-memory database systems [23, 24]. 7.
Reference: 23. <author> Kenneth Salem and Hector Garcia-Molina, </author> <title> ``Crash Recovery Mechanisms for Main Storage Database Systems,'' </title> <institution> CS-TR-034-86, Princeton University, Princeton, </institution> <address> NJ (1986). </address>
Reference-contexts: Collecting data in the file cache and writing it to disk in large writes is similar to the concept of group commit in database systems [22] and to techniques used in main-memory database systems <ref> [23, 24] </ref>. 7. Conclusion The basic principle behind a log-structured file system is a simple one: collect large amounts of new data in a file cache in main memory, then write the data to disk in a single large I/O that can use all of the disk's bandwidth.
Reference: 24. <author> Robert B. Hagmann, </author> <title> ``A Crash Recovery Scheme for a Memory-Resident Database System,'' </title> <journal> IEEE Transactions on Computers C-35(9)(Sep 1986). </journal> <month> July 24, </month> <year> 1991 </year> <month> - 15 </month> - 
Reference-contexts: Collecting data in the file cache and writing it to disk in large writes is similar to the concept of group commit in database systems [22] and to techniques used in main-memory database systems <ref> [23, 24] </ref>. 7. Conclusion The basic principle behind a log-structured file system is a simple one: collect large amounts of new data in a file cache in main memory, then write the data to disk in a single large I/O that can use all of the disk's bandwidth.
References-found: 24

