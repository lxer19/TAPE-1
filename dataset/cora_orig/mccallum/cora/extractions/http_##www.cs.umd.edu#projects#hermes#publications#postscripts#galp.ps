URL: http://www.cs.umd.edu/projects/hermes/publications/postscripts/galp.ps
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/galp.html
Root-URL: 
Email: E-Mail: kifer@cs.sunysb.edu  E-Mail: vs@cs.umd.edu  
Title: Theory of Generalized Annotated Logic Programming and its Applications  
Author: Michael Kifer V.S. Subrahmanian 
Address: NY 11794.  College Park, Maryland 20742.  
Affiliation: Department of Computer Science SUNY at Stony Brook Stony Brook,  Department of Computer Science University of Maryland  
Abstract: Annotated logics were introduced in [43] and later studied in [5, 7, 31, 32]. In [31], annotations were extended to allow variables and functions, and it was argued that such logics can be used to provide a formal semantics for rule-based expert systems with uncertainty. In this paper we continue to investigate the power of this approach. First, we introduce a new semantics for such programs based on ideals of lattices. Subsequently, some proposals for multivalued logic programming [5, 7, 32, 47, 40, 18] as well as some formalisms for temporal reasoning [1, 3, 42] are shown to fit into this framework. As an interesting by-product of this investigation, we obtain a new result concerning multivalued logic programming: a model theory for Fitting's bilattice-based logic programming, which until now has not been characterized model-theoretically. This is accompanied by a corresponding proof theory.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and Z. Manna. </author> <title> (1987) Temporal Logic Programming, </title> <booktitle> Proc. 4th IEEE Symp. on Logic Programming, </booktitle> <pages> pp 4-16, </pages> <publisher> Computer Society Press. </publisher>
Reference-contexts: Intuitively, what this definition says is that members of F may occur in the annotation of the head of a clause, but that elements of F may not occur in the body of a clause. For instance, if we take T to be the interval <ref> [0; 1] </ref> of real numbers, then p (s (X)) : 0:5 fi p (X) : is a clause that says: If the truth value assigned to p (X) is , then p (s (X)) is assigned 0:5 fi . <p> The set of all ideals of T is denoted by I (T ), and the set of principal ideals of T will be denoted by PI (T ). 2 Example 1 Ideals are not necessarily closed under infinite least upper bounds. For example, consider the complete lattice <ref> [0; 1] </ref> (the unit interval of reals) ordered by the familiar "" relation. <p> Consider the following example: Example 2 Suppose P is the following program over the unit interval <ref> [0; 1] </ref> of truth values: p : x q : 0:3 It is easy to see that this program is model-theoretically equivalent (using either general or restricted models) to: p : 1 q : 0:3 (recall that when T = [0; 1] then &gt; = 1). 2 Thus, we can assume <p> Suppose P is the following program over the unit interval <ref> [0; 1] </ref> of truth values: p : x q : 0:3 It is easy to see that this program is model-theoretically equivalent (using either general or restricted models) to: p : 1 q : 0:3 (recall that when T = [0; 1] then &gt; = 1). 2 Thus, we can assume without loss of generality that, in every clause, variables occurring in the annotation of the clause head also appear as annotations of the body literals. We will make this assumption throughout this paper. <p> Therefore must belong to one of the T P " n (A)'s. 2 Unlike T P , R P may not be continuous, as illustrated in the following example: Example 3 Suppose T is the interval of real numbers <ref> [0; 1] </ref> with the usual ordering, and consider the following program: p : 0 2 p : x 9 where x is an annotation variable. It is easy to see that the interpretation T P " i, 0 i !, always assigns the empty ideal fg to q. <p> A n-reductant of a program P is a reductant involving no more than n clauses of P . Many popular semilattices have finite width. Clearly, all finite semilattices are of this kind. Among the infinite ones, the semilattice of the form <ref> [0; 1] </ref> n has width n (here (a 1 ; :::; a n ) t (b 1 ; :::; b n ) = (a 1 t b 1 ; :::; a n t b n )). In particular, [0; 1] and [0; 1] 2 are frequently used in expert systems. <p> Among the infinite ones, the semilattice of the form <ref> [0; 1] </ref> n has width n (here (a 1 ; :::; a n ) t (b 1 ; :::; b n ) = (a 1 t b 1 ; :::; a n t b n )). In particular, [0; 1] and [0; 1] 2 are frequently used in expert systems. To show that, e.g., [0; 1] 2 is 2-wide, let ff 1 = [a 1 ; b 1 ], ..., ff k = [a k ; b k ] be a finite set of pairs of real numbers in <p> Among the infinite ones, the semilattice of the form <ref> [0; 1] </ref> n has width n (here (a 1 ; :::; a n ) t (b 1 ; :::; b n ) = (a 1 t b 1 ; :::; a n t b n )). In particular, [0; 1] and [0; 1] 2 are frequently used in expert systems. To show that, e.g., [0; 1] 2 is 2-wide, let ff 1 = [a 1 ; b 1 ], ..., ff k = [a k ; b k ] be a finite set of pairs of real numbers in the interval [0; <p> In particular, <ref> [0; 1] </ref> and [0; 1] 2 are frequently used in expert systems. To show that, e.g., [0; 1] 2 is 2-wide, let ff 1 = [a 1 ; b 1 ], ..., ff k = [a k ; b k ] be a finite set of pairs of real numbers in the interval [0; 1]. <p> <ref> [0; 1] </ref> 2 are frequently used in expert systems. To show that, e.g., [0; 1] 2 is 2-wide, let ff 1 = [a 1 ; b 1 ], ..., ff k = [a k ; b k ] be a finite set of pairs of real numbers in the interval [0; 1]. Let a i (resp., b j ) be the maximal element among the a 1 , ..., a k (resp., b 1 , ..., b k ). Then, ff i t ff j = tfff 1 ; :::; ff k g, which proves that [0; 1] 2 is 2-wide. <p> numbers in the interval <ref> [0; 1] </ref>. Let a i (resp., b j ) be the maximal element among the a 1 , ..., a k (resp., b 1 , ..., b k ). Then, ff i t ff j = tfff 1 ; :::; ff k g, which proves that [0; 1] 2 is 2-wide. As we shall see, if T is n-wide, then in building refutations it suffices to consider n-reductants only. This limits the choice of clauses to resolve with to a finite set of n-reductants. <p> A quantitative rule set (QRS) is a collection of finitely many rules. Interpretations map ground atoms into the unit interval <ref> [0; 1] </ref>. Interpretations of QRSs, as defined in [47], are the same as r-interpretations of GAPs over the lattice T = [0; 1] (with the standard ordering on [0; 1]). <p> A quantitative rule set (QRS) is a collection of finitely many rules. Interpretations map ground atoms into the unit interval <ref> [0; 1] </ref>. Interpretations of QRSs, as defined in [47], are the same as r-interpretations of GAPs over the lattice T = [0; 1] (with the standard ordering on [0; 1]). <p> A quantitative rule set (QRS) is a collection of finitely many rules. Interpretations map ground atoms into the unit interval <ref> [0; 1] </ref>. Interpretations of QRSs, as defined in [47], are the same as r-interpretations of GAPs over the lattice T = [0; 1] (with the standard ordering on [0; 1]). <p> A more expressive temporal logic was proposed by Abadi and Manna in <ref> [1] </ref>. There, besides the "next" operator, fl, other modalities, such as "eventuality", 3, and "always true", 2, are allowed. The full temporal logic of [1] is, according to the authors, computationally expensive, and a fragment amenable to an efficient implementation by means of SLD resolution was proposed. <p> A more expressive temporal logic was proposed by Abadi and Manna in <ref> [1] </ref>. There, besides the "next" operator, fl, other modalities, such as "eventuality", 3, and "always true", 2, are allowed. The full temporal logic of [1] is, according to the authors, computationally expensive, and a fragment amenable to an efficient implementation by means of SLD resolution was proposed. This fragment consists of clauses of the following form. <p> We have already shown how the next-atoms are represented using annotations. The necessity operator, 2, corresponds to the topmost element &gt; 2 T (which represents the whole set Y). For instance, 2A is represented as A : &gt;. Finally, our annotated rules correspond to the permanent rules of <ref> [1] </ref>. We show below some simple examples of information that can be represented using the GAP formalism. Suppose in the sequel that Y is the set of all integers. <p> general, since we allow arbitrary computable functions (subject to the restrictions of Section 4) in rule heads while both Baudinet and Abadi and Manna restrict the rule heads to be next-atoms (i.e. c-annotated literals, in our setting), GAPs can express several fancy temporal problems that are beyond the scope of <ref> [1, 3] </ref>. Also, we do not restrict bodies of temporal programs to be 2-free, since atoms of the form A : &gt; are perfectly acceptable. There are, however, situations where GAPs are weaker than [1]. For instance, GAPs cannot express a clause with the following body: 3 (p ^ 3q). <p> Also, we do not restrict bodies of temporal programs to be 2-free, since atoms of the form A : &gt; are perfectly acceptable. There are, however, situations where GAPs are weaker than <ref> [1] </ref>. For instance, GAPs cannot express a clause with the following body: 3 (p ^ 3q). Likewise, we cannot represent directly the initial clauses of Abadi and Manna, since GAP rules are permanently true. This difficulty could be overcome by using metaprogramming techniques (e.g. [45]). <p> For instance, if &lt; B A &gt; is an encoding of a clause B A, then we could write clause (&lt; B A &gt;) : f0g, stating that the respective clause is true at time 0, which corresponds to the initial clause B A of <ref> [1] </ref>. We will not discuss this issue any further in this paper. <p> T = (Y ! T 0 ): For instance, we can take T 0 to be the four-valued Belnap's lattice [4] shown in Figure 1, or we can take T 0 to be the set <ref> [0; 1] </ref> fi [0; 1] often used for modeling uncertainty in expert systems [7, 31, 18]. An interpretation is a map from B L to T . <p> T = (Y ! T 0 ): For instance, we can take T 0 to be the four-valued Belnap's lattice [4] shown in Figure 1, or we can take T 0 to be the set <ref> [0; 1] </ref> fi [0; 1] often used for modeling uncertainty in expert systems [7, 31, 18]. An interpretation is a map from B L to T . The underlying intuition is that an interpretation I assigns to any ground atom A, a function f A from Y to T 0 .
Reference: [2] <author> K. R. Apt, H. A. Blair and A. Walker. </author> <title> (1988) Towards a Theory of Declarative Knowledge, in: Foundations of Deductive Databases and Logic Programming, </title> <editor> (ed. Jack Minker), </editor> <publisher> Morgan-Kauffman. </publisher>
Reference: [3] <author> M. Baudinet. </author> <title> (1989) Temporal Logic Programming is Complete and Expressive, </title> <booktitle> Proc. of the ACM Conference on Principles of Programming Languages, </booktitle> <address> Austin, Texas. </address>
Reference-contexts: We show that GAPs are sufficiently expressive to be able to cope with a large body of temporal problems and, in particular, subsume some of the earlier proposals for temporal logic programming <ref> [3] </ref>. Although our approach cannot directly represent certain constructs used in temporal specifications, we note that the implication problem in most full-fledged temporal logics is 1 1 -complete and therefore such logics cannot be adequately implemented on a computer, anyway. <p> To say that p is true at all even times, we write p : f0g p : succ (succ (ff)) p : ff: Baudinet <ref> [3] </ref> has developed a semantic framework for temporal logic programming, with Y taken to be the set of non-negative integers. <p> To compare GAPs with <ref> [3] </ref>, let Y be the set of all non-negative integers f0; 1; . . .g, and T = P (Y) be the lattice of all sets of non-negative integers ordered by inclusion, which we call the temporal lattice. <p> general, since we allow arbitrary computable functions (subject to the restrictions of Section 4) in rule heads while both Baudinet and Abadi and Manna restrict the rule heads to be next-atoms (i.e. c-annotated literals, in our setting), GAPs can express several fancy temporal problems that are beyond the scope of <ref> [1, 3] </ref>. Also, we do not restrict bodies of temporal programs to be 2-free, since atoms of the form A : &gt; are perfectly acceptable. There are, however, situations where GAPs are weaker than [1]. For instance, GAPs cannot express a clause with the following body: 3 (p ^ 3q).
Reference: [4] <author> N.D. Belnap. </author> <title> (1977) A Useful Four-Valued Logic, </title> <editor> in G. Epstein and J.M. Dunn, eds. </editor> <title> Modern Uses of Many-valued Logic, </title> <editor> (eds. G. Epstein and J.M. Dunn), D. </editor> <publisher> Reidel, </publisher> <pages> pp. 8-37. </pages>
Reference-contexts: More generally, assume that now our domain of truth values is the set of functions from Y to some complete lattice T 0 , i.e. T = (Y ! T 0 ): For instance, we can take T 0 to be the four-valued Belnap's lattice <ref> [4] </ref> shown in Figure 1, or we can take T 0 to be the set [0; 1] fi [0; 1] often used for modeling uncertainty in expert systems [7, 31, 18]. An interpretation is a map from B L to T .
Reference: [5] <author> H. A. Blair and V.S. Subrahmanian. </author> <title> (1989) Paraconsistent Logic Programming, </title> <journal> Theoretical Computer Science, </journal> <volume> 68, </volume> <pages> pp 135-154. </pages>
Reference-contexts: As a step towards the solution of this problem, annotated logic programs were introduced by Subrahmanian in [43] and were subsequently studied in <ref> [5, 7] </ref> by Blair and Subrahmanian. In [32, 33], Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. <p> The utility of annotated logics for reasoning with fl A preliminary report on this research has appeared in [34] y Work supported in part by the NSF grant IRI-8903507. 1 inconsistency and for programming expert systems was well argued in <ref> [5, 7, 31, 32, 33] </ref>. In this paper we continue to investigate the power of this formalism. <p> We believe that this paper unifies, and in some cases, generalizes various results and treatments of multivalued logic programming. Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in <ref> [5, 7, 32, 33] </ref>; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets [47, 39, 29, 36, 41, 28, 40]. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. <p> On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. For annotated logics it was first introduced in <ref> [43, 5, 7] </ref>; it was dubbed epistemic negation in [32]. One of the advantages of epistemic negation is that, given a c-annotated literal :A : , there is a c-annotation = :() such that :A : is logically equivalent to A : . <p> In the remainder of this section we give a simple characterization of when R P attains a fixed-point at !. Blair and Subrahmanian <ref> [5, 7] </ref> have shown that lf p (R P ) = R P " ! whenever P is c-annotated, and T is a lattice. It follows immediately from that proof that the same result holds when no annotation variables appear in rule bodies. <p> This implies that R P exhibits undesirable behaviour only when c- and v-annotations are intermixed in rule bodies. Apart from the two important cases considered in <ref> [5, 7, 31] </ref>, there is a large class of programs for which R P is not necessarily continuous, but still R P " ! = lf p (R P ) holds. Let us call the latter equation the fixpoint reachability requirement.
Reference: [6] <author> H. A. Blair and V. S. Subrahmanian. </author> <title> (1988) Strong Completeness Results for Paraconsistent Logic Programming, </title> <note> submitted. </note>
Reference-contexts: Furthermore, it should be clear that each clause in P is a reductant of itself. Example 5 Suppose T is the lattice F OU R shown in Figure 1. This lattice has been used extensively in reasoning about knowledge bases which may contain inconsistent information (cf. <ref> [6, 46] </ref>). Intuitively, ? represents the Kleene's truth value "unknown", while &gt; represents the truth value "inconsistent".
Reference: [7] <author> H. A. Blair and V. S. Subrahmanian. </author> <title> (1988) Paraconsistent Foundations for Logic Programming, </title> <journal> Journal of Non-Classical Logic, </journal> <volume> 5, 2, </volume> <pages> pp 45-73. </pages>
Reference-contexts: As a step towards the solution of this problem, annotated logic programs were introduced by Subrahmanian in [43] and were subsequently studied in <ref> [5, 7] </ref> by Blair and Subrahmanian. In [32, 33], Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. <p> The utility of annotated logics for reasoning with fl A preliminary report on this research has appeared in [34] y Work supported in part by the NSF grant IRI-8903507. 1 inconsistency and for programming expert systems was well argued in <ref> [5, 7, 31, 32, 33] </ref>. In this paper we continue to investigate the power of this formalism. <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of <ref> [7, 31, 32, 33] </ref> to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in [7, 32, 33], the notion of annotation variable was not present). <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of [7, 31, 32, 33] to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in <ref> [7, 32, 33] </ref>, the notion of annotation variable was not present). Then we present the model-theoretic, fixed-point, and operational semantics of GAPs. In Section 5.1 we show that van Emden's quantitative logic programming [47] is a special case of GAPs. <p> We believe that this paper unifies, and in some cases, generalizes various results and treatments of multivalued logic programming. Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in <ref> [5, 7, 32, 33] </ref>; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets [47, 39, 29, 36, 41, 28, 40]. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. <p> The GAP framework introduced here uses the "classical" definition of implication in the same way as in <ref> [43, 7, 32] </ref>. However, by appropriately generalizing the concept of an annotation, we are able to capture the propagation of truth values "across" implications (cf. Theorems 7 and 8), at least to the extent this propagation is treated in [17]. <p> It is often convenient to assume the existence of a greatest element in T , denoted &gt;, and some of our results will depend on this assumption. The greatest lower bound operator, when it exists, is denoted by u. Elements of T can be thought of as confidence factors <ref> [7, 31] </ref>, or degrees of belief [7, 32, 33], or, as we shall see later, as truth values similar to those used in multivalued logics. In addition, sometimes it will be assumed that T has a unique least element, denoted ?; in these cases this assumption will be made explicitly. <p> The greatest lower bound operator, when it exists, is denoted by u. Elements of T can be thought of as confidence factors [7, 31], or degrees of belief <ref> [7, 32, 33] </ref>, or, as we shall see later, as truth values similar to those used in multivalued logics. In addition, sometimes it will be assumed that T has a unique least element, denoted ?; in these cases this assumption will be made explicitly. <p> On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. For annotated logics it was first introduced in <ref> [43, 5, 7] </ref>; it was dubbed epistemic negation in [32]. One of the advantages of epistemic negation is that, given a c-annotated literal :A : , there is a c-annotation = :() such that :A : is logically equivalent to A : . <p> In the remainder of this section we give a simple characterization of when R P attains a fixed-point at !. Blair and Subrahmanian <ref> [5, 7] </ref> have shown that lf p (R P ) = R P " ! whenever P is c-annotated, and T is a lattice. It follows immediately from that proof that the same result holds when no annotation variables appear in rule bodies. <p> This implies that R P exhibits undesirable behaviour only when c- and v-annotations are intermixed in rule bodies. Apart from the two important cases considered in <ref> [5, 7, 31] </ref>, there is a large class of programs for which R P is not necessarily continuous, but still R P " ! = lf p (R P ) holds. Let us call the latter equation the fixpoint reachability requirement. <p> T = (Y ! T 0 ): For instance, we can take T 0 to be the four-valued Belnap's lattice [4] shown in Figure 1, or we can take T 0 to be the set [0; 1] fi [0; 1] often used for modeling uncertainty in expert systems <ref> [7, 31, 18] </ref>. An interpretation is a map from B L to T . The underlying intuition is that an interpretation I assigns to any ground atom A, a function f A from Y to T 0 .
Reference: [8] <author> L. Farinas del Cerro. </author> <year> (1986) </year> <month> Molog: </month> <title> A System That Extends Prolog with Modal Logic, New Generation Computing. </title>
Reference: [9] <author> N.C.A. da Costa. </author> <title> (1974) On the Theory of Inconsistent Formal Systems, </title> <journal> Notre Dame J. of Formal Logic, </journal> <volume> 15, </volume> <pages> pp. 497-510. </pages>
Reference: [10] <author> N.C.A. da Costa and E.H. Alves. </author> <title> (1977) A Semantical Analysis of the Calculi C n , Notre Dame J. </title> <journal> of Formal Logic, </journal> <volume> 18, </volume> <pages> pp. 621-630. </pages>
Reference: [11] <author> N.C.A. da Costa and E.H. Alves. </author> <title> (1981) Relations between Paraconsistent Logic and Many-valued Logic, </title> <journal> Bulletin of the Section of Logic, </journal> <volume> 10, </volume> <pages> pp. 185-191. </pages>
Reference: [12] <author> N.C.A. da Costa, L. J. Henschen, J. J. Lu and V.S. Subrahmanian. </author> <title> (1989) Automatic Theorem Proving in Paraconsistent Logics: Theory and Implementation, </title> <booktitle> in: Proc. 10th International Conference on Automated Deduction, Lecture Notes in Computer Science Vol. </booktitle> <volume> 449, </volume> <pages> pp. 72-86, </pages> <month> July </month> <year> 1990. </year> <month> 31 </month>
Reference-contexts: In [32, 33], Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. More efficient proof procedures have been recently obtained, and implementations of these theorem provers have been designed (cf. <ref> [12, 26] </ref>). Kifer and Li [31] extended annotated programs in a different direction by allowing variables and evaluable function terms to appear as annotations. We will call such programs generalized annotated programs (GAPs, for short).
Reference: [13] <author> N.C.A. da Costa, V.S. Subrahmanian and C. Vago. </author> <title> (1989) The Paraconsistent Logics PT , to appear in: </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> Vol. 37, </volume> <year> 1991. </year>
Reference-contexts: However, " " is not expressible via _, ^, and the epistemic negation :. Therefore, since the ontological negation is not used in this paper, we had to define the implication " " separately. Properties of ontological negation are discussed in detail in <ref> [32, 33, 13] </ref>. The above definition tells us what the models of a GAP are.
Reference: [14] <author> S. Feferman. </author> <title> (1984) Toward Useful Type-Free Theories, </title> <journal> Journal of Symbolic Logic, </journal> <volume> 49, </volume> <pages> pp. 75-111. </pages>
Reference-contexts: We will not discuss this issue any further in this paper. More information about encodings and logics for meta-reasoning can be found in <ref> [14, 37, 38, 27, 45] </ref>. 6.2 Multivalued Temporal Reasoning One advantage of the GAP formalism as opposed to Baudinet's and Abadi and Manna's is that it also allows one to deal with "epistemically inconsistent worlds", i.e. interpretations in which at certain times t the information about certain ground atoms is inconsistent.
Reference: [15] <author> M. C. </author> <title> Fitting. (1987) Bilattices and the Theory of Truth, </title> <note> to appear in: Journal of Philosophical Logic. </note>
Reference: [16] <author> M. C. </author> <title> Fitting. (1987) Enumeration Operators and Modular Logic Programming, </title> <journal> Journal of Logic Programming, </journal> <volume> 4, </volume> <pages> pp. 11-21. </pages>
Reference: [17] <author> M. C. </author> <title> Fitting. (1988) Logic Programming on a Topological Bilattice, </title> <journal> Fundamenta Informat-icae, </journal> <volume> 11, </volume> <pages> pp. 209-218. </pages>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics <ref> [23, 17] </ref>; and 3. Quantitative rule sets [47, 39, 29, 36, 41, 28, 40]. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. <p> However, by appropriately generalizing the concept of an annotation, we are able to capture the propagation of truth values "across" implications (cf. Theorems 7 and 8), at least to the extent this propagation is treated in <ref> [17] </ref>. This is one of the key insights provided by this paper. Additionally, this paper demonstrates that the GAP framework can be used to implement a semi-decidable fragment of temporal logics, which is a new application for GAPs. <p> In addition, meets and joins with respect to k are monotone with respect to t and vice versa. Fitting <ref> [17, 18] </ref> has developed a theory of fixpoints for logic programs whose associated set of truth values forms a bilattice.
Reference: [18] <author> M. C. </author> <title> Fitting. (1991) Bilattices and the Semantics of Logic Programming, </title> <journal> Journal of Logic Programming, </journal> <note> 1991. to appear. </note>
Reference-contexts: Then, in Section 5.2, we show how Fitting's bilattice-based logic programming approach fits into the framework of GAPs. The consequence of this "fit" is that we can now characterize Fitting's approach model-theoretically (no model-theoretic semantics was previously proposed for this approach). By translating [47] and <ref> [18] </ref> into GAPs, we obtain a sound and complete proof procedure for these theories, thus strengthening van Emden's soundness and completeness theorems (which were obtained under some restrictions) and complementing Fitting's results. <p> our use of epistemic negation in this paper is not computational, but the fact that the negation in Fitting's theory of logic programming over 1 If t is an annotation ground term, it can be identified with a constant in T , since all annotation functions are evaluable. 6 bilattices <ref> [18] </ref> directly translates into the epistemic negation of GAPs (see Section 5.2). Also, it is easy to see that the implication, A B, can be expressed via ontological negation as follows: A_ ~ B. However, " " is not expressible via _, ^, and the epistemic negation :. <p> Later we will establish a much more general result regarding the relationship between T P and R P that will be subsequently used in Section 5 to establish the relationship between GAPs and van Emden's [47] and Fitting's <ref> [18] </ref> works. 7 One intuition behind the ideal-theoretic definition is the following: Consider an interpretation I and a ground atom A. <p> procedures for programs whose clauses are c-annotated were obtained in Subrahmanian [44] and Kifer and Lozinskii [32, 33]. 5 Multivalued Logics and GAPs The principal aim of this section is to show that quantitative logic programming as proposed by van Emden [47] and also the bilattice-based logic programs of Fitting <ref> [18] </ref>, all fit into the framework of GAPs. 5.1 van Emden's Quantitative Deduction A quantitative rule [47] is of the form: r : A B 1 & . . . & B k ; where r 2 (0; 1]. <p> truth values, and the results are applicable to any multi-valued logic based on a complete lattice that possesses Henkin's existential property. 22 5.2 Bilattice-valued Logics For the purpose of this section, we assume that the reader is familiar with the basics of Fitting's theory of bilattice-based logic programming developed in <ref> [18] </ref>. Bilattices, due to Ginsberg [23], provide an elegant epistemological framework for studying multivalued logics. <p> In addition, meets and joins with respect to k are monotone with respect to t and vice versa. Fitting <ref> [17, 18] </ref> has developed a theory of fixpoints for logic programs whose associated set of truth values forms a bilattice. <p> In general, this equality does not guarantee the existence of a complete proof theory for bilattice-based logic programs. However, for distributive bilattices such a proof procedure does exist. A distributive bilattice <ref> [18] </ref> is a bilattice satisfying all twelve distributive laws for various combinations of the operators t k , t t , u k , and u t . <p> T = (Y ! T 0 ): For instance, we can take T 0 to be the four-valued Belnap's lattice [4] shown in Figure 1, or we can take T 0 to be the set [0; 1] fi [0; 1] often used for modeling uncertainty in expert systems <ref> [7, 31, 18] </ref>. An interpretation is a map from B L to T . The underlying intuition is that an interpretation I assigns to any ground atom A, a function f A from Y to T 0 . <p> This is important because, we believe, logics with non-recursively enumerable implication problem cannot be effectively 30 implemented on a computer. Third, it gives a proof theory to formalisms based on multivalued logics, such as <ref> [47, 18] </ref>, which can be naturally translated into GAPs. Finally, when all else fails, one may prefer to program in terms of GAPs directly rather than using different formalisms (subsumed by GAPs) for different purposes. Acknowledgements.
Reference: [19] <author> M. C. </author> <title> Fitting. (1989) Negation as Refutation, </title> <booktitle> Proc. 4th Symp. on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <pages> pp. 63-70. </pages>
Reference-contexts: We can use the operational semantics of GAPs developed in the previous section to process queries to bilattice-based programs. In <ref> [19] </ref>, Fitting described a tableau-based proof procedure for his logic programs. This procedure is restricted to the case of the four-valued bilattice depicted in Figure 1. Since this bilattice is distributive, our results about the proof theory subsume the corresponding results in [19]. <p> In <ref> [19] </ref>, Fitting described a tableau-based proof procedure for his logic programs. This procedure is restricted to the case of the four-valued bilattice depicted in Figure 1. Since this bilattice is distributive, our results about the proof theory subsume the corresponding results in [19]. Now, the models of Fitting's logic programs can be defined as follows: Definition 19 We say that I is a model of a ground clause A Body in a bilattice-based program if and only if I (A) k I (Body).
Reference: [20] <author> D. M. Gabbay. </author> <title> (1987) Modal and Temporal Logic Programming, in: Temporal Logic in Computer Science, </title> <editor> (ed. A. Galton), </editor> <publisher> Academic Press. </publisher>
Reference: [21] <author> A. Galton. </author> <booktitle> (1987) Temporal Logic in Computer Science, </booktitle> <publisher> Academic Press. </publisher>
Reference: [22] <author> D.D. Ganguly and S. Ranka. </author> <title> (1990) A Space Efficient Coding Algorithm for Lattice Computations, </title> <type> draft manuscript. </type>
Reference-contexts: But for ground constraints satisfaction is obviously decidable since they are conjunctions of ground atoms involving decidable predicates only. 2 Of course, the algorithm of Lemma 3 is impractical and we just used it as a decidability argument; efficient algorithms for constraint solving over T are presented in <ref> [22] </ref>. Definition 16 A deduction of a constrained query Q 0 from a GAP P is a sequence: Q 0 ; hC 0 ; 0 i; Q 1 ; . . . ; Q n ; hC n ; n i; Q n+1 such that: 1. <p> The implementation of the above refutation procedure hinges upon two things: * The ability to solve lattice constraints; and * The ability to restrict the choice of reductants. Studying the ways of solving constraints is beyond the scope of this paper; <ref> [22] </ref> deals with efficient serial and parallel algorithms for this task. The need to use reductants of P rather then just the clauses of P is another major obstacle.
Reference: [23] <author> M. Ginsberg. </author> <title> (1988) Multivalued Logics: A Uniform Approach to Reasoning in Artificial Intelligence, </title> <journal> Computational Intelligence, </journal> <volume> vol. 4, </volume> <year> 1988, </year> <pages> pp. 265-316. </pages>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics <ref> [23, 17] </ref>; and 3. Quantitative rule sets [47, 39, 29, 36, 41, 28, 40]. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. <p> The implication itself was then interpreted in a "classical logic" fashion. The two approaches had their own advantages and disadvantages: although associating truth values with implications, as in <ref> [23] </ref>, has intuitive appeal, annotated logics provide a simpler formalism that is much closer to classical logic. Besides, in [33] it is shown that for many problems in nonmonotonic reasoning, it is easier to arrive at the intended semantics via nonmonotonic annotated logics, compared to the bilattice-based formalism of [23]. 2 <p> in <ref> [23] </ref>, has intuitive appeal, annotated logics provide a simpler formalism that is much closer to classical logic. Besides, in [33] it is shown that for many problems in nonmonotonic reasoning, it is easier to arrive at the intended semantics via nonmonotonic annotated logics, compared to the bilattice-based formalism of [23]. 2 However, one of the principal results of this paper is to show that this dichotomy can be done away with. The GAP framework introduced here uses the "classical" definition of implication in the same way as in [43, 7, 32]. <p> Bilattices, due to Ginsberg <ref> [23] </ref>, provide an elegant epistemological framework for studying multivalued logics.
Reference: [24] <author> M. Ginsberg. </author> <title> (1990) Bilattices and Modal Operators, </title> <booktitle> in: Proc. 1990 Intl. Conf. on Theoretical Aspects of Reasoning About Knowledge, </booktitle> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: This is one of the key insights provided by this paper. Additionally, this paper demonstrates that the GAP framework can be used to implement a semi-decidable fragment of temporal logics, which is a new application for GAPs. Ginsberg <ref> [24] </ref> has recently observed that there are various connections between bilattices and modal logics, temporal logics in particular.
Reference: [25] <author> J.Y. Halpern, Z. Manna and B. Moszkowski. </author> <title> (1983) A High-Level Semantics Based on Interval Logic, </title> <booktitle> Proc. ICALP 1983, </booktitle> <pages> pp 278-291, </pages> <publisher> Springer. </publisher>
Reference-contexts: The above translation precisely captures the intended meaning of the modal operators of Shoham [42] but, in general, we cannot simulate full-fledged interval-based temporal logics. This, of course, does not come as a surprise, since even the propositional temporal logic ITL has an undecidable validity problem <ref> [25] </ref>. 7 Conclusions There are many alternative formalisms for multivalued and temporal logic programming. However, the relationship between these different formalisms is not well understood. In this paper, we have made a first contribution towards the understanding of different methodologies for logic programming based on non-standard logics.
Reference: [26] <author> L.J. Henschen, J. J. Lu and V.S. Subrahmanian. </author> <title> (1989) An Improved Resolution Procedure for Paraconsistent Logics , submitted. </title>
Reference-contexts: In [32, 33], Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. More efficient proof procedures have been recently obtained, and implementations of these theorem provers have been designed (cf. <ref> [12, 26] </ref>). Kifer and Li [31] extended annotated programs in a different direction by allowing variables and evaluable function terms to appear as annotations. We will call such programs generalized annotated programs (GAPs, for short).
Reference: [27] <author> P.M. Hill and J.W. Lloyd. </author> <title> (1988) Analysis of Meta-Programs, </title> <type> Tech. Report CS-88-08, </type> <institution> University of Bristol, UK. </institution>
Reference-contexts: We will not discuss this issue any further in this paper. More information about encodings and logics for meta-reasoning can be found in <ref> [14, 37, 38, 27, 45] </ref>. 6.2 Multivalued Temporal Reasoning One advantage of the GAP formalism as opposed to Baudinet's and Abadi and Manna's is that it also allows one to deal with "epistemically inconsistent worlds", i.e. interpretations in which at certain times t the information about certain ground atoms is inconsistent.
Reference: [28] <author> M. Ishizuka. </author> <title> (1983) Inference Methods Based on Extended Dempster and Shafer's Theory with Uncertainty/Fuzziness, </title> <journal> New Generation Computing, </journal> <volume> 1, 2, </volume> <pages> pps 159-168. </pages>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration.
Reference: [29] <author> M. Ishizuka and N. Kanai. </author> <title> (1985) PROLOG-ELF Incorporating Fuzzy Logic, </title> <journal> New generation Computing, </journal> <volume> 3, </volume> <pages> pps 479-486. </pages>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration.
Reference: [30] <author> J. Jaffar and J-L Lassez. </author> <title> (1987) Constraint Logic Programming, </title> <address> POPL-87, Munich, </address> <publisher> W. </publisher> <address> Germany. </address> <month> 32 </month>
Reference-contexts: We see that there is a close relationship between annotated logic programming and constraint logic programming <ref> [30] </ref>. As will be shown later, there is also a close connection between annotated programs and certain fragments of temporal logics. Thus, there is hope that in the future a single unifying framework for multivalued, temporal, and constraint logic programming will emerge.
Reference: [31] <author> M. Kifer and A. Li. </author> <title> (1988) On the Semantics of Rule-Based Expert Systems with Uncer--tainty, </title> <booktitle> 2-nd Intl. Conf. on Database Theory, </booktitle> <publisher> Springer Verlag LNCS 326, </publisher> <editor> (eds. M. Gyssens, J. Paredaens, D. Van Gucht), Bruges, </editor> <address> Belgium, </address> <pages> pp. 102-117. </pages>
Reference-contexts: In [32, 33], Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. More efficient proof procedures have been recently obtained, and implementations of these theorem provers have been designed (cf. [12, 26]). Kifer and Li <ref> [31] </ref> extended annotated programs in a different direction by allowing variables and evaluable function terms to appear as annotations. We will call such programs generalized annotated programs (GAPs, for short). <p> The utility of annotated logics for reasoning with fl A preliminary report on this research has appeared in [34] y Work supported in part by the NSF grant IRI-8903507. 1 inconsistency and for programming expert systems was well argued in <ref> [5, 7, 31, 32, 33] </ref>. In this paper we continue to investigate the power of this formalism. <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of <ref> [7, 31, 32, 33] </ref> to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in [7, 32, 33], the notion of annotation variable was not present). <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of [7, 31, 32, 33] to allow annotation variables over arbitrary semilattices of truth values (in <ref> [31] </ref> only a special lattice the Cartesian product of two unit intervals was considered and in [7, 32, 33], the notion of annotation variable was not present). Then we present the model-theoretic, fixed-point, and operational semantics of GAPs. <p> It is often convenient to assume the existence of a greatest element in T , denoted &gt;, and some of our results will depend on this assumption. The greatest lower bound operator, when it exists, is denoted by u. Elements of T can be thought of as confidence factors <ref> [7, 31] </ref>, or degrees of belief [7, 32, 33], or, as we shall see later, as truth values similar to those used in multivalued logics. In addition, sometimes it will be assumed that T has a unique least element, denoted ?; in these cases this assumption will be made explicitly. <p> Similarly, if P is a GAP, then we denote the set of all strictly ground instances of clauses in P by SGI (P ). 3 The General and Restricted Semantics In this section, we propose two alternative model-theoretic semantics for GAPs. The first corresponds closely to that in <ref> [31, 34] </ref>, while the second is ideal-theoretic in nature, first proposed in [33]. <p> It follows immediately from that proof that the same result holds when no annotation variables appear in rule bodies. In parallel, Kifer and Li <ref> [31] </ref> showed that lf p (R P ) = R P " ! holds at the other end of the spectrum: when P contains only v-annotations in rule bodies (in which case R P is even continuous). <p> This implies that R P exhibits undesirable behaviour only when c- and v-annotations are intermixed in rule bodies. Apart from the two important cases considered in <ref> [5, 7, 31] </ref>, there is a large class of programs for which R P is not necessarily continuous, but still R P " ! = lf p (R P ) holds. Let us call the latter equation the fixpoint reachability requirement. <p> T = (Y ! T 0 ): For instance, we can take T 0 to be the four-valued Belnap's lattice [4] shown in Figure 1, or we can take T 0 to be the set [0; 1] fi [0; 1] often used for modeling uncertainty in expert systems <ref> [7, 31, 18] </ref>. An interpretation is a map from B L to T . The underlying intuition is that an interpretation I assigns to any ground atom A, a function f A from Y to T 0 .
Reference: [32] <author> M. Kifer and E.L. Lozinskii. </author> <title> (1989) RI: A Logic for Reasoning with Inconsistency, </title> <booktitle> 4-th Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <pages> pp. 253-262. </pages>
Reference-contexts: As a step towards the solution of this problem, annotated logic programs were introduced by Subrahmanian in [43] and were subsequently studied in [5, 7] by Blair and Subrahmanian. In <ref> [32, 33] </ref>, Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. More efficient proof procedures have been recently obtained, and implementations of these theorem provers have been designed (cf. [12, 26]). <p> The utility of annotated logics for reasoning with fl A preliminary report on this research has appeared in [34] y Work supported in part by the NSF grant IRI-8903507. 1 inconsistency and for programming expert systems was well argued in <ref> [5, 7, 31, 32, 33] </ref>. In this paper we continue to investigate the power of this formalism. <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of <ref> [7, 31, 32, 33] </ref> to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in [7, 32, 33], the notion of annotation variable was not present). <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of [7, 31, 32, 33] to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in <ref> [7, 32, 33] </ref>, the notion of annotation variable was not present). Then we present the model-theoretic, fixed-point, and operational semantics of GAPs. In Section 5.1 we show that van Emden's quantitative logic programming [47] is a special case of GAPs. <p> We believe that this paper unifies, and in some cases, generalizes various results and treatments of multivalued logic programming. Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in <ref> [5, 7, 32, 33] </ref>; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets [47, 39, 29, 36, 41, 28, 40]. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. <p> The GAP framework introduced here uses the "classical" definition of implication in the same way as in <ref> [43, 7, 32] </ref>. However, by appropriately generalizing the concept of an annotation, we are able to capture the propagation of truth values "across" implications (cf. Theorems 7 and 8), at least to the extent this propagation is treated in [17]. <p> The greatest lower bound operator, when it exists, is denoted by u. Elements of T can be thought of as confidence factors [7, 31], or degrees of belief <ref> [7, 32, 33] </ref>, or, as we shall see later, as truth values similar to those used in multivalued logics. In addition, sometimes it will be assumed that T has a unique least element, denoted ?; in these cases this assumption will be made explicitly. <p> In the sequel, we will be freely switching between the two views of r-interpretations, i.e. we will think of them either as mappings B L 7! T or B L 7! PI (T ), depending on which of the views is more convenient at the moment. Following <ref> [32, 33] </ref>, we could also define interpretations with arbitrary domains, but since in this paper we are mainly concerned with logic programming, we will restrict our attention to Herbrand interpretations only. We assume that there is a unary operator : : T ! T , conceptually interpreted as negation. <p> In annotated logics, there are at least two different (but related) notions of negation <ref> [32, 33] </ref>. The ontological negation is close to the standard negation in predicate calculus; for annotated logics it was first studied in [32]. On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. <p> In annotated logics, there are at least two different (but related) notions of negation [32, 33]. The ontological negation is close to the standard negation in predicate calculus; for annotated logics it was first studied in <ref> [32] </ref>. On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. For annotated logics it was first introduced in [43, 5, 7]; it was dubbed epistemic negation in [32]. <p> in predicate calculus; for annotated logics it was first studied in <ref> [32] </ref>. On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. For annotated logics it was first introduced in [43, 5, 7]; it was dubbed epistemic negation in [32]. One of the advantages of epistemic negation is that, given a c-annotated literal :A : , there is a c-annotation = :() such that :A : is logically equivalent to A : . This type of negation is monotonic and, therefore, is more tractable. The other negation, ontological [32], defines <p> in <ref> [32] </ref>. One of the advantages of epistemic negation is that, given a c-annotated literal :A : , there is a c-annotation = :() such that :A : is logically equivalent to A : . This type of negation is monotonic and, therefore, is more tractable. The other negation, ontological [32], defines satisfaction of negated atoms as follows: I j=~ A : if and only if I 6j= A : . In this case, there is usually no such that A : and ~ A : are logically equivalent. As a result, ontological negation is computationally more expensive. <p> However, " " is not expressible via _, ^, and the epistemic negation :. Therefore, since the ontological negation is not used in this paper, we had to define the implication " " separately. Properties of ontological negation are discussed in detail in <ref> [32, 33, 13] </ref>. The above definition tells us what the models of a GAP are. <p> Then the clause [ A 1 : B 1 1 & . . . & B 1 m 1 & . . . &B n 1 & . . . & B n m n ] is called a reductant of P <ref> [32] </ref>. Here, the expression tf 1 ; :::; n g is evaluated only if all the i 's are c-annotations; otherwise the complex term-annotation tf 1 ; :::; n g becomes the annotation in the head of the reductant. <p> Hence our completeness result applies to Example 7, whereas Morishita's completeness result is inapplicable to that example. Results on query processing procedures for programs whose clauses are c-annotated were obtained in Subrahmanian [44] and Kifer and Lozinskii <ref> [32, 33] </ref>. 5 Multivalued Logics and GAPs The principal aim of this section is to show that quantitative logic programming as proposed by van Emden [47] and also the bilattice-based logic programs of Fitting [18], all fit into the framework of GAPs. 5.1 van Emden's Quantitative Deduction A quantitative rule [47]
Reference: [33] <author> M. Kifer and E.L. Lozinskii. </author> <title> (1991) A Logic for Reasoning with Inconsistency, Journal of Automated Reasoning, </title> <publisher> Kluwer Academic Publ., </publisher> <year> 1991, </year> <note> to appear. </note>
Reference-contexts: As a step towards the solution of this problem, annotated logic programs were introduced by Subrahmanian in [43] and were subsequently studied in [5, 7] by Blair and Subrahmanian. In <ref> [32, 33] </ref>, Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. More efficient proof procedures have been recently obtained, and implementations of these theorem provers have been designed (cf. [12, 26]). <p> The utility of annotated logics for reasoning with fl A preliminary report on this research has appeared in [34] y Work supported in part by the NSF grant IRI-8903507. 1 inconsistency and for programming expert systems was well argued in <ref> [5, 7, 31, 32, 33] </ref>. In this paper we continue to investigate the power of this formalism. <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of <ref> [7, 31, 32, 33] </ref> to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in [7, 32, 33], the notion of annotation variable was not present). <p> In this paper we continue to investigate the power of this formalism. First we extend the semantics of [7, 31, 32, 33] to allow annotation variables over arbitrary semilattices of truth values (in [31] only a special lattice the Cartesian product of two unit intervals was considered and in <ref> [7, 32, 33] </ref>, the notion of annotation variable was not present). Then we present the model-theoretic, fixed-point, and operational semantics of GAPs. In Section 5.1 we show that van Emden's quantitative logic programming [47] is a special case of GAPs. <p> We believe that this paper unifies, and in some cases, generalizes various results and treatments of multivalued logic programming. Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in <ref> [5, 7, 32, 33] </ref>; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets [47, 39, 29, 36, 41, 28, 40]. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. <p> The implication itself was then interpreted in a "classical logic" fashion. The two approaches had their own advantages and disadvantages: although associating truth values with implications, as in [23], has intuitive appeal, annotated logics provide a simpler formalism that is much closer to classical logic. Besides, in <ref> [33] </ref> it is shown that for many problems in nonmonotonic reasoning, it is easier to arrive at the intended semantics via nonmonotonic annotated logics, compared to the bilattice-based formalism of [23]. 2 However, one of the principal results of this paper is to show that this dichotomy can be done away <p> The greatest lower bound operator, when it exists, is denoted by u. Elements of T can be thought of as confidence factors [7, 31], or degrees of belief <ref> [7, 32, 33] </ref>, or, as we shall see later, as truth values similar to those used in multivalued logics. In addition, sometimes it will be assumed that T has a unique least element, denoted ?; in these cases this assumption will be made explicitly. <p> The first corresponds closely to that in [31, 34], while the second is ideal-theoretic in nature, first proposed in <ref> [33] </ref>. <p> In the sequel, we will be freely switching between the two views of r-interpretations, i.e. we will think of them either as mappings B L 7! T or B L 7! PI (T ), depending on which of the views is more convenient at the moment. Following <ref> [32, 33] </ref>, we could also define interpretations with arbitrary domains, but since in this paper we are mainly concerned with logic programming, we will restrict our attention to Herbrand interpretations only. We assume that there is a unary operator : : T ! T , conceptually interpreted as negation. <p> In annotated logics, there are at least two different (but related) notions of negation <ref> [32, 33] </ref>. The ontological negation is close to the standard negation in predicate calculus; for annotated logics it was first studied in [32]. On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. <p> However, " " is not expressible via _, ^, and the epistemic negation :. Therefore, since the ontological negation is not used in this paper, we had to define the implication " " separately. Properties of ontological negation are discussed in detail in <ref> [32, 33, 13] </ref>. The above definition tells us what the models of a GAP are. <p> Hence our completeness result applies to Example 7, whereas Morishita's completeness result is inapplicable to that example. Results on query processing procedures for programs whose clauses are c-annotated were obtained in Subrahmanian [44] and Kifer and Lozinskii <ref> [32, 33] </ref>. 5 Multivalued Logics and GAPs The principal aim of this section is to show that quantitative logic programming as proposed by van Emden [47] and also the bilattice-based logic programs of Fitting [18], all fit into the framework of GAPs. 5.1 van Emden's Quantitative Deduction A quantitative rule [47]
Reference: [34] <author> M. Kifer and V.S. Subrahmanian. </author> <title> (1989) On the Expressive Power of Annotated Logic Programs, </title> <booktitle> Proc. 1989 North American Conference on Logic Programming, </booktitle> <address> Cleveland, </address> <publisher> Ohio, </publisher> <pages> pp. 1069-1089, </pages> <publisher> MIT Press. </publisher>
Reference-contexts: We will call such programs generalized annotated programs (GAPs, for short). The utility of annotated logics for reasoning with fl A preliminary report on this research has appeared in <ref> [34] </ref> y Work supported in part by the NSF grant IRI-8903507. 1 inconsistency and for programming expert systems was well argued in [5, 7, 31, 32, 33]. In this paper we continue to investigate the power of this formalism. <p> Similarly, if P is a GAP, then we denote the set of all strictly ground instances of clauses in P by SGI (P ). 3 The General and Restricted Semantics In this section, we propose two alternative model-theoretic semantics for GAPs. The first corresponds closely to that in <ref> [31, 34] </ref>, while the second is ideal-theoretic in nature, first proposed in [33].
Reference: [35] <author> J.W. Lloyd. </author> <booktitle> (1987) Foundations of Logic Programming, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Proof: A simple modification of the standard proof, e.g., from <ref> [35] </ref>, with the use of the mono-tonicity property of annotated functions in F . 2 In what follows, we will often use a special "least" interpretation, , which assigns the empty ideal f g to every atom. <p> Then there is a refutation &lt; 0 of Q such that 2 SOL (&lt; 0 ). Proof: Similar to the proof of the mgu lemma in classical logic programming (Lloyd, <ref> [35] </ref>). 2 Lemma 5 (Lifting Lemma) Suppose P is a GAP and Q is a normal query. Suppose is an assignment of c-annotations to some (not necessarily all) annotation variables in Q and let be a substitution for object variables. <p> If there is a refutation &lt; of Q from P , then there is a refutation &lt; 0 of Q from P . Proof: Similar to the proof of the classical lifting lemma (cf. Lloyd <ref> [35] </ref>). 2 19 Theorem 6 (Completeness Theorem) Suppose that T is a lattice, P is a GAP and Q is a normal query. Suppose P j= (9)Q. Then there is a refutation of Q from P .
Reference: [36] <author> S. Morishita. </author> <title> (1989) A Unified Approach to Semantics of Multi-Valued Logic Programs, </title> <type> Tech. Report RT 5006, </type> <institution> IBM Tokyo, </institution> <address> April 9th, </address> <year> 1990. </year>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration. <p> As will be shown later, there is also a close connection between annotated programs and certain fragments of temporal logics. Thus, there is hope that in the future a single unifying framework for multivalued, temporal, and constraint logic programming will emerge. In related works, Morishita <ref> [36] </ref> and Subrahmanian [44] have also studied multivalued logic programming where annotations were associated with clauses, rather than with individual atoms. <p> Soundness of the proof procedure is established for queries that have a finite AND/OR tree associated with them (cf. <ref> [36, Theorem 4.11] </ref>). This restriction is not needed in our work. It must also be pointed out that our ideal-theoretic semantics differs from Morishita's semantics. Hence our completeness result applies to Example 7, whereas Morishita's completeness result is inapplicable to that example.
Reference: [37] <author> D. Perlis. </author> <title> (1985) Languages with Self-Reference I: </title> <journal> Foundations , Artificial Intelligence, </journal> <volume> 25, </volume> <pages> pp. 301-322. </pages>
Reference-contexts: We will not discuss this issue any further in this paper. More information about encodings and logics for meta-reasoning can be found in <ref> [14, 37, 38, 27, 45] </ref>. 6.2 Multivalued Temporal Reasoning One advantage of the GAP formalism as opposed to Baudinet's and Abadi and Manna's is that it also allows one to deal with "epistemically inconsistent worlds", i.e. interpretations in which at certain times t the information about certain ground atoms is inconsistent.
Reference: [38] <author> D. Perlis. </author> <title> (1988) Languages with Self-Reference II: Knowledge,Belief, and Modality, </title> <journal> Artificial Intelligence, </journal> <volume> 34, </volume> <pages> pp. 179-212. </pages>
Reference-contexts: We will not discuss this issue any further in this paper. More information about encodings and logics for meta-reasoning can be found in <ref> [14, 37, 38, 27, 45] </ref>. 6.2 Multivalued Temporal Reasoning One advantage of the GAP formalism as opposed to Baudinet's and Abadi and Manna's is that it also allows one to deal with "epistemically inconsistent worlds", i.e. interpretations in which at certain times t the information about certain ground atoms is inconsistent.
Reference: [39] <author> D. C. Rine. </author> <title> (1986) Some Relationships Between Logic Programming and Multiple-Valued Logic, </title> <booktitle> Proc. IEEE Intl. Symp. on Multiple-Valued Logic, </booktitle> <address> pps 160-163. </address>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration.
Reference: [40] <author> E. Shapiro. </author> <title> (1983) Logic Programs with Uncertainties: A Tool for Implementing Expert Systems, </title> <booktitle> Proc. IJCAI '83, </booktitle> <pages> pp. 529-532, </pages> <publisher> William Kauffman. </publisher>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration.
Reference: [41] <author> E. Shortliffe. </author> <title> (1976) Computer-Based Medical Consultation: MYCIN, </title> <publisher> Elsevier Science. </publisher>
Reference-contexts: Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration.
Reference: [42] <author> Y. Shoham. </author> <title> (1988) Reasoning About Change, </title> <publisher> MIT Press. </publisher>
Reference-contexts: To see that GAPs can represent some forms of interval temporal reasoning, we show that the logic of Shoham <ref> [42, pp. 61-62] </ref> can be expressed within the GAP framework. <p> Also note that satisfiability of constraints in the above clauses is decidable since this is a very simple case of linear programming, and thus the proof theory for GAPs applies. The above translation precisely captures the intended meaning of the modal operators of Shoham <ref> [42] </ref> but, in general, we cannot simulate full-fledged interval-based temporal logics. This, of course, does not come as a surprise, since even the propositional temporal logic ITL has an undecidable validity problem [25]. 7 Conclusions There are many alternative formalisms for multivalued and temporal logic programming.
Reference: [43] <editor> V.S. Subrahmanian. </editor> <booktitle> (1987) On the Semantics of Quantitative Logic Programs, Proc. 4th IEEE Symposium on Logic Programming, </booktitle> <publisher> Computer Society Press, </publisher> <address> Washington DC, </address> <pages> pp. 173-182. </pages>
Reference-contexts: As a step towards the solution of this problem, annotated logic programs were introduced by Subrahmanian in <ref> [43] </ref> and were subsequently studied in [5, 7] by Blair and Subrahmanian. In [32, 33], Kifer and Lozinskii extended the theory to a full-fledged logic, and it was shown that a sound and complete proof procedure exists. <p> The GAP framework introduced here uses the "classical" definition of implication in the same way as in <ref> [43, 7, 32] </ref>. However, by appropriately generalizing the concept of an annotation, we are able to capture the propagation of truth values "across" implications (cf. Theorems 7 and 8), at least to the extent this propagation is treated in [17]. <p> On the other hand, the negation defined in (2) of Definition 7 is close to the negation used in multivalued logics. For annotated logics it was first introduced in <ref> [43, 5, 7] </ref>; it was dubbed epistemic negation in [32]. One of the advantages of epistemic negation is that, given a c-annotated literal :A : , there is a c-annotation = :() such that :A : is logically equivalent to A : .
Reference: [44] <author> V. S. Subrahmanian. </author> <title> (1990) Mechanical Proof Procedures for Many Valued Lattice Based Logic Programming, </title> <note> to appear in: Journal of Non-Classical Logic, </note> <year> 1990. </year>
Reference-contexts: The other inclusion is proved similarly to the earlier proof that R P (R P " k)(A) t (T P " !)(A), in Claim (1). 2 4 Constrained Queries and GAPs Following <ref> [44] </ref>, we are now going to develop an SLD-style proof theory for GAPs based on the general semantics. <p> As will be shown later, there is also a close connection between annotated programs and certain fragments of temporal logics. Thus, there is hope that in the future a single unifying framework for multivalued, temporal, and constraint logic programming will emerge. In related works, Morishita [36] and Subrahmanian <ref> [44] </ref> have also studied multivalued logic programming where annotations were associated with clauses, rather than with individual atoms. <p> It must also be pointed out that our ideal-theoretic semantics differs from Morishita's semantics. Hence our completeness result applies to Example 7, whereas Morishita's completeness result is inapplicable to that example. Results on query processing procedures for programs whose clauses are c-annotated were obtained in Subrahmanian <ref> [44] </ref> and Kifer and Lozinskii [32, 33]. 5 Multivalued Logics and GAPs The principal aim of this section is to show that quantitative logic programming as proposed by van Emden [47] and also the bilattice-based logic programs of Fitting [18], all fit into the framework of GAPs. 5.1 van Emden's Quantitative
Reference: [45] <author> V. S. Subrahmanian. </author> <booktitle> (1988) Foundations of Metalogic Programming, in: Proc. of the Workshop on Meta-Programming in Logic Programming, </booktitle> <editor> (ed. J. Lloyd), </editor> <address> Bristol, UK. </address>
Reference-contexts: For instance, GAPs cannot express a clause with the following body: 3 (p ^ 3q). Likewise, we cannot represent directly the initial clauses of Abadi and Manna, since GAP rules are permanently true. This difficulty could be overcome by using metaprogramming techniques (e.g. <ref> [45] </ref>). In these formalisms, formulae can be encoded by terms, and thus can be reasoned about. <p> We will not discuss this issue any further in this paper. More information about encodings and logics for meta-reasoning can be found in <ref> [14, 37, 38, 27, 45] </ref>. 6.2 Multivalued Temporal Reasoning One advantage of the GAP formalism as opposed to Baudinet's and Abadi and Manna's is that it also allows one to deal with "epistemically inconsistent worlds", i.e. interpretations in which at certain times t the information about certain ground atoms is inconsistent.
Reference: [46] <author> V.S. Subrahmanian. </author> <title> (1989) Paraconsistent Disjunctive Deductive Databases, </title> <note> to appear in: Theoretical Computer Science, early 1992. </note>
Reference-contexts: Furthermore, it should be clear that each clause in P is a reductant of itself. Example 5 Suppose T is the lattice F OU R shown in Figure 1. This lattice has been used extensively in reasoning about knowledge bases which may contain inconsistent information (cf. <ref> [6, 46] </ref>). Intuitively, ? represents the Kleene's truth value "unknown", while &gt; represents the truth value "inconsistent".
Reference: [47] <author> M.H. van Emden. </author> <title> (1986) Quantitative Deduction and its Fixpoint Theory, </title> <journal> Journal of Logic Programming, </journal> <volume> 4, 1, </volume> <pages> pp. 37-53. 33 </pages>
Reference-contexts: Then we present the model-theoretic, fixed-point, and operational semantics of GAPs. In Section 5.1 we show that van Emden's quantitative logic programming <ref> [47] </ref> is a special case of GAPs. Then, in Section 5.2, we show how Fitting's bilattice-based logic programming approach fits into the framework of GAPs. The consequence of this "fit" is that we can now characterize Fitting's approach model-theoretically (no model-theoretic semantics was previously proposed for this approach). By translating [47] <p> <ref> [47] </ref> is a special case of GAPs. Then, in Section 5.2, we show how Fitting's bilattice-based logic programming approach fits into the framework of GAPs. The consequence of this "fit" is that we can now characterize Fitting's approach model-theoretically (no model-theoretic semantics was previously proposed for this approach). By translating [47] and [18] into GAPs, we obtain a sound and complete proof procedure for these theories, thus strengthening van Emden's soundness and completeness theorems (which were obtained under some restrictions) and complementing Fitting's results. <p> Furthermore, it presents new applications of this formal setting. So far, research in multivalued logic programming has proceeded along three different directions: 1. Annotated logics as described in [5, 7, 32, 33]; 2. Bilattice-based logics [23, 17]; and 3. Quantitative rule sets <ref> [47, 39, 29, 36, 41, 28, 40] </ref>. Earlier studies of these three approaches quickly identified various distinctions between these frameworks. For example, one of the key insights behind bilattices was the interplay between the truth values assigned to sentences and the notion of implication in the language under consideration. <p> In general, using this intuition, a quantitative rule r : A B 1 & . . . & B k of van Emden <ref> [47] </ref> may be translated into the annotated clause: A : r fi minf 1 ; . . . ; k g B 1 : 1 & . . . & B k : k : This issue will be further discussed in Section 5.1. <p> Later we will establish a much more general result regarding the relationship between T P and R P that will be subsequently used in Section 5 to establish the relationship between GAPs and van Emden's <ref> [47] </ref> and Fitting's [18] works. 7 One intuition behind the ideal-theoretic definition is the following: Consider an interpretation I and a ground atom A. <p> Results on query processing procedures for programs whose clauses are c-annotated were obtained in Subrahmanian [44] and Kifer and Lozinskii [32, 33]. 5 Multivalued Logics and GAPs The principal aim of this section is to show that quantitative logic programming as proposed by van Emden <ref> [47] </ref> and also the bilattice-based logic programs of Fitting [18], all fit into the framework of GAPs. 5.1 van Emden's Quantitative Deduction A quantitative rule [47] is of the form: r : A B 1 & . . . & B k ; where r 2 (0; 1]. <p> [32, 33]. 5 Multivalued Logics and GAPs The principal aim of this section is to show that quantitative logic programming as proposed by van Emden <ref> [47] </ref> and also the bilattice-based logic programs of Fitting [18], all fit into the framework of GAPs. 5.1 van Emden's Quantitative Deduction A quantitative rule [47] is of the form: r : A B 1 & . . . & B k ; where r 2 (0; 1]. A quantitative rule set (QRS) is a collection of finitely many rules. Interpretations map ground atoms into the unit interval [0; 1]. <p> A quantitative rule set (QRS) is a collection of finitely many rules. Interpretations map ground atoms into the unit interval [0; 1]. Interpretations of QRSs, as defined in <ref> [47] </ref>, are the same as r-interpretations of GAPs over the lattice T = [0; 1] (with the standard ordering on [0; 1]). <p> This improves upon van Emden's "weak soundness and completeness" results in two ways: 1. van Emden's evaluation procedure <ref> [47] </ref> works under the conditions that the AND/OR tree associated with a program P and a query Q is finite. No such restriction is needed here. 2. van Emden's proof procedure applies to ground queries. The procedure for GAPs described in this paper applies to non-ground existential queries as well. <p> Furthermore, as with QRS, we can observe that constraints arising in bl (P ) are normal and therefore the proof procedure developed for GAPs applies. As a consequence, once again, just as in the case of van Emden's QRSs <ref> [47] </ref>, we can study the semantics of bilattice logic programming by studying the semantics of the corresponding GAPs, and we can use the corresponding proof procedure to answer queries. There are several advantages in doing so: 1. Fitting did not define the notion of a model for his logic programs. <p> This is important because, we believe, logics with non-recursively enumerable implication problem cannot be effectively 30 implemented on a computer. Third, it gives a proof theory to formalisms based on multivalued logics, such as <ref> [47, 18] </ref>, which can be naturally translated into GAPs. Finally, when all else fails, one may prefer to program in terms of GAPs directly rather than using different formalisms (subsumed by GAPs) for different purposes. Acknowledgements.
References-found: 47

