URL: http://www.cs.cornell.edu/jyh/papers/otypes.ps
Refering-URL: http://www.cs.cornell.edu/jyh/cornell-papers.html
Root-URL: http://www.cs.brown.edu/
Title: Predicative Type Theoretic Objects with Self Application  
Author: Jason J. Hickey 
Affiliation: Department of Computer Science Cornell University  
Abstract: Predicative type theories are powerful tools for giving foundational interpretations of programming languages. Due to their explicit inductive construction, predicative type theories have multiple mathematical models that provide precise definitions of programming language features. However, not all features have predicative interpretations, and current interpretations of objects rely on impredicative type theories, such as Girard's System F, because of the difficulty in specifying a type for objects in the presence of self-application. In this paper we show that objects have a predicative interpretation. We show that predica-tivity is associated with method monotonicity, and that binary methods prevent the inductive type construction. Our interpretation differs from impredicative accounts by replacing the use of recursive types for objects with conditions for method polymorphism over the self type. We further give a propositional meaning to objects in the type theory, providing a calculus for formal verification. Our interpretation has been verified in the Nuprl predicative type theory. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer, </publisher> <year> 1996. </year> <note> 12 Jason J. Hickey </note>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1; 29; 6; 12] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [11]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory. <p> A formal proof of soundness is available online. In our interpretation, object types have propositional meaning. We further extend the calculus with dependent method types to provide a basis for formal program analysis. We develop our account on the object calculus of Cardelli et al. <ref> [1; 2] </ref>, which gives a precise characterization of self application and method override. We show that the type system can be developed without the use of recursive types or weak sums, and without sacrificing subtyping properties. <p> While these object calculi are simple and precise, they allow representations of class-based and object-based concepts, as shown by Abadi and Cardelli in the "Theory of Objects" <ref> [1] </ref>. One of the significant features of these calculi is that they are all based on self-application: methods receive the object as an argument when they are invoked. Our task is to provide an encoding of the three primitives and their types in the type theory.
Reference: [2] <author> Martn Abadi, Luca Cardelli, and Ramesh Viswanathan. </author> <title> An Interpretation of Objects and Object Types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: A formal proof of soundness is available online. In our interpretation, object types have propositional meaning. We further extend the calculus with dependent method types to provide a basis for formal program analysis. We develop our account on the object calculus of Cardelli et al. <ref> [1; 2] </ref>, which gives a precise characterization of self application and method override. We show that the type system can be developed without the use of recursive types or weak sums, and without sacrificing subtyping properties. <p> After covering the interpretations, we discuss related work. 2. REVIEW The formalism we use for objects in this paper is a functional object calculus similar to the calculus of Abadi, Cardelli, and Viswanathan <ref> [2] </ref>, in which the only primitives are objects, method invocation, and method update. While these object calculi are simple and precise, they allow representations of class-based and object-based concepts, as shown by Abadi and Cardelli in the "Theory of Objects" [1]. <p> Predicative Type Theoretic Objects with Self Application 5 3.1 Constrained polymorphism In order to address the subtyping problem, we must specify which methods are updatable. We adopt the method of variance annotations <ref> [2] </ref>, where method labels are annotated with the symbols ( + , , ffi ), which are intended to provide the extra information.
Reference: [3] <author> Stuart F. Allen. </author> <title> The Semantics of Type Theoretic Languages. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: This is a stronger result because predicative theories make fewer assumptions and have more models. In particular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [21], PER models <ref> [3; 26] </ref>, denotational models [31], and others. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [25; 4], so the Contact information: Jason J. Hickey, Department of Computer Science, Upson Hall, Cornell University, Ithaca, NY 14853 USA.
Reference: [4] <author> Stuart F. Allen. </author> <title> A non-type-theoretic definition of martin-lof's types. </title> <booktitle> In Proceedings of the Second Conference on Logic in Computer Science, </booktitle> <pages> pages 215-224, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In particular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [21], PER models [3; 26], denotational models [31], and others. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction <ref> [25; 4] </ref>, so the Contact information: Jason J. Hickey, Department of Computer Science, Upson Hall, Cornell University, Ithaca, NY 14853 USA. Tel: 607-255-1372, email: jyh@cs.cornell.edu.
Reference: [5] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, the Hopkins Objects Group, Gary Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <note> 1997. To appear. </note>
Reference-contexts: Rules for nondependent calculus monotonicity is required to show that the use of polymorphism is sound. Bruce et al. <ref> [5] </ref> discuss other issues that make binary methods problematic. 4. DEPENDENT CALCULUS The type theoretic interpretation gives a mathematical basis that allows programs to be formally analyzed. We can extend the calculus to provide formal specifications about program behavior by adding dependent method types.
Reference: [6] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing, and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1; 29; 6; 12] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [11]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory.
Reference: [7] <author> Adriana B. Compagnoni and Benjamin C. Pierce. </author> <title> Intersection types and multiple inheritance. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Their interpretation uses an existential encoding of objects [29; 20] in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems <ref> [7; 19] </ref>. Another existential system was developed by Jackson [22] to formalize a significant portion of constructive algebra in Nuprl. While Jackson's framework includes many of the properties of objects, the subtyping requirements prohibit the use of self-application and constrain the shape of objects.
Reference: [8] <author> Karl Crary. </author> <title> Recursive computation in foundational type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, Forthcoming. </institution>
Reference-contexts: However, with the introduction of recursive methods, a formal account of totality would require a specification of all the intermediate computations. Our account of partial objects is based on the partial types of Smith [33], which have been simplified by Crary <ref> [8] </ref>. A partial type, denoted T , contains a term x if the evaluation of x diverges, or if x is an element of T . The induction principle for partial types relies on an admissiblity condition, which holds for the types in our calculus.
Reference: [9] <author> N. G. de Bruijn. </author> <title> Telescopic mappings in typed lambda calculus. </title> <journal> Information and Computation, </journal> <volume> 91(2) </volume> <pages> 189-204, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In contrast to object calculi, formal calculi for modules have a long history. An important early system is DeBruijn's automath <ref> [9; 28] </ref>, which presented formal bodies of math as books, relying on first-class contexts. More recently Sannella et al. [24; 23] have extended the ML module system with formal specifications of program behavior.
Reference: [10] <author> R.L. Constable et.al. </author> <title> Implementing Mathematics in the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Method type dependencies are expressed using dependent records based on the very-dependent function type [15], and method polymorphism over subtypes is expressed using intersection types. We have verified this interpretation on the Nuprl <ref> [10] </ref> type theory, extended with rules for method monotonicity. A summary of the proof is available online. In the next section we review the object calculus, and cover preliminaries.
Reference: [11] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'a rithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects [1; 29; 6; 12] have been encoded in impredicative type theory (mainly variants of Girard's System F <ref> [11] </ref>), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory. This is a stronger result because predicative theories make fewer assumptions and have more models.
Reference: [12] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1; 29; 6; 12] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [11]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory.
Reference: [13] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: More recently Sannella et al. [24; 23] have extended the ML module system with formal specifications of program behavior. In [17], we address the issue of extended modules using the translucent sum calculus of Harper and Lillibridge <ref> [13] </ref>. Each of these systems augments the module theory to include module specifications. 6. CONCLUSION We have given a interpretation of objects that differs from more standard accounts by replacing the use of recursive types for objects with polymorphic restrictions on methods.
Reference: [14] <author> Jason J. Hickey. </author> <note> http://www.cs.cornell.edu/home/jyh. </note>
Reference-contexts: The rules for non-dependent objects are sound with respect to the type theoretic model. Several more results follow directly from the interpretation. Progress, preservation, and substitution properties arise from a semantics of functionality for the type theory. Formal proofs and summaries are available at the author's home page <ref> [14] </ref>. 3.4 Summary of nondependent interpretation Our account of nondependent object types differs from other accounts primarily in the lack of a recursive type in the definition. Instead, the recursion is embedded in the method polymorphism.
Reference: [15] <author> Jason J. Hickey. </author> <title> Formal objects in type theory using very dependent types. </title> <booktitle> In Foundations of Object Oriented Languages 3, </booktitle> <year> 1996. </year> <note> Available electronically through the FOOL 3 home page at Williams College. </note>
Reference-contexts: We show that the type system can be developed without the use of recursive types or weak sums, and without sacrificing subtyping properties. Method type dependencies are expressed using dependent records based on the very-dependent function type <ref> [15] </ref>, and method polymorphism over subtypes is expressed using intersection types. We have verified this interpretation on the Nuprl [10] type theory, extended with rules for method monotonicity. A summary of the proof is available online. In the next section we review the object calculus, and cover preliminaries. <p> This specification uses an even more constrained subtyping relation dep that we discuss shortly, and the quantification is over all the methods and constraints that are to be updated. 4.1 Encoding We encode dependent object types as dependent records, which in turn are encoded as very-dependent function types <ref> [15] </ref>. Very-dependent function types allow function values to be used to specify their range, in a well-ordered manner. We use the notation ff j x: A ! B [f; x]g to specify the functions f with domain type A, and range type B [f; a] on argument a 2 A. <p> While Jackson's framework includes many of the properties of objects, the subtyping requirements prohibit the use of self-application and constrain the shape of objects. Our work has borrowed from Jackson' interpretation; in an earlier paper <ref> [15] </ref>, we presented another existential interpretation of objects in a predicative type theory, using the "very-dependent" function type to express the type dependencies. In contrast to object calculi, formal calculi for modules have a long history.
Reference: [16] <author> Jason J. Hickey. Nuprl-Light: </author> <title> An implementation framework for higher-order logics. </title> <booktitle> In 14th International Conference on Automated Deduction. </booktitle> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: It may be possible to address this issue by giving a syntactic account of polymorphism that allows the use of recursive types to define objects. We are using the interpretation in the Nuprl-Light system <ref> [16] </ref> to implement a formal module layer on top of the Objective Caml module system [30].
Reference: [17] <author> Jason J. Hickey. </author> <title> Modules with proofs. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, Forthcoming. </institution>
Reference-contexts: An important early system is DeBruijn's automath [9; 28], which presented formal bodies of math as books, relying on first-class contexts. More recently Sannella et al. [24; 23] have extended the ML module system with formal specifications of program behavior. In <ref> [17] </ref>, we address the issue of extended modules using the translucent sum calculus of Harper and Lillibridge [13]. Each of these systems augments the module theory to include module specifications. 6.
Reference: [18] <author> M. Hofmann, W. Naraschewski, M. Steffen, and T. Stroup. </author> <title> Inheritance of proofs. In TAPOS. </title> <publisher> Wiley, forthcoming. </publisher>
Reference-contexts: Predicative Type Theoretic Objects with Self Application 11 These rules are essentially the same as for the nondependent-rules, except to account for the additional bindings in the method types. 5. RELATED WORK Another framework for expressive object calculi is developed by Hofmann et el. <ref> [18] </ref>, who have implemented a verification calculus based on the existential interpretation of objects. In their system, objects have three parts: an object state, the object methods, and the proofs of method correctness. As in our interpretation, specifications are encoded in objects using dependent method types.
Reference: [19] <author> Martin Hofmann and Benjamin Pierce. </author> <title> Positive subtyping. </title> <booktitle> In Proceedings of Twenty-Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 186-197. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1995. </year>
Reference-contexts: Their interpretation uses an existential encoding of objects [29; 20] in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems <ref> [7; 19] </ref>. Another existential system was developed by Jackson [22] to formalize a significant portion of constructive algebra in Nuprl. While Jackson's framework includes many of the properties of objects, the subtyping requirements prohibit the use of self-application and constrain the shape of objects.
Reference: [20] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 593-635, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: In their system, objects have three parts: an object state, the object methods, and the proofs of method correctness. As in our interpretation, specifications are encoded in objects using dependent method types. Their interpretation uses an existential encoding of objects <ref> [29; 20] </ref> in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems [7; 19].
Reference: [21] <author> Douglas J. Howe. </author> <title> Semantic foundations for embedding HOL in Nuprl. </title> <booktitle> In AMAST '96, </booktitle> <year> 1996. </year>
Reference-contexts: This is a stronger result because predicative theories make fewer assumptions and have more models. In particular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic <ref> [21] </ref>, PER models [3; 26], denotational models [31], and others. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [25; 4], so the Contact information: Jason J.
Reference: [22] <author> Paul Bernard Jackson. </author> <title> Enhancing the NuPRL Proof Development System and Applying it to Computational Abstract Algebra. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems [7; 19]. Another existential system was developed by Jackson <ref> [22] </ref> to formalize a significant portion of constructive algebra in Nuprl. While Jackson's framework includes many of the properties of objects, the subtyping requirements prohibit the use of self-application and constrain the shape of objects.
Reference: [23] <author> S. Kahrs, D. Sannella, and A. Tarlecki. </author> <title> The definition of Extended ML. </title> <type> Technical Report ECS-LFCS-94-300, </type> <institution> Laboratory for Foundations of Computer Science, University of Ed-inburgh, </institution> <year> 1994. </year>
Reference-contexts: In contrast to object calculi, formal calculi for modules have a long history. An important early system is DeBruijn's automath [9; 28], which presented formal bodies of math as books, relying on first-class contexts. More recently Sannella et al. <ref> [24; 23] </ref> have extended the ML module system with formal specifications of program behavior. In [17], we address the issue of extended modules using the translucent sum calculus of Harper and Lillibridge [13]. Each of these systems augments the module theory to include module specifications. 6.
Reference: [24] <author> S. Kahrs, D. Sannella, and A. Tarlecki. </author> <title> The definition of Extended ML: a gentle introduction. </title> <journal> Theoretical Computer Science, </journal> <volume> 173 </volume> <pages> 445-484, </pages> <year> 1997. </year>
Reference-contexts: In contrast to object calculi, formal calculi for modules have a long history. An important early system is DeBruijn's automath [9; 28], which presented formal bodies of math as books, relying on first-class contexts. More recently Sannella et al. <ref> [24; 23] </ref> have extended the ML module system with formal specifications of program behavior. In [17], we address the issue of extended modules using the translucent sum calculus of Harper and Lillibridge [13]. Each of these systems augments the module theory to include module specifications. 6.
Reference: [25] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: Predicative part. </title> <booktitle> In Logic Colloquium '73, </booktitle> <pages> pages 73-118. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference-contexts: In particular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [21], PER models [3; 26], denotational models [31], and others. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction <ref> [25; 4] </ref>, so the Contact information: Jason J. Hickey, Department of Computer Science, Upson Hall, Cornell University, Ithaca, NY 14853 USA. Tel: 607-255-1372, email: jyh@cs.cornell.edu.
Reference: [26] <author> Paul Francis Mendler. </author> <title> Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> September </month> <year> 1987. </year> <month> 87-870. </month> <title> Predicative Type Theoretic Objects with Self Application 13 </title>
Reference-contexts: This is a stronger result because predicative theories make fewer assumptions and have more models. In particular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [21], PER models <ref> [3; 26] </ref>, denotational models [31], and others. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [25; 4], so the Contact information: Jason J. Hickey, Department of Computer Science, Upson Hall, Cornell University, Ithaca, NY 14853 USA.
Reference: [27] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1993. </year>
Reference: [28] <editor> R.P. Nederpelt, J.H. Geuvers, and editors R.C. ~ de Vrijer. </editor> <booktitle> Selected Papers on Automath, </booktitle> <volume> volume 133. </volume> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: In contrast to object calculi, formal calculi for modules have a long history. An important early system is DeBruijn's automath <ref> [9; 28] </ref>, which presented formal bodies of math as books, relying on first-class contexts. More recently Sannella et al. [24; 23] have extended the ML module system with formal specifications of program behavior.
Reference: [29] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Self application occurs during method selection when the entire object is passed to the method as an implicit "self" argument. Recent type-theoretic accounts of objects <ref> [1; 29; 6; 12] </ref> have been encoded in impredicative type theory (mainly variants of Girard's System F [11]), which allow self-application through an impredicative interpretation of the self parameter. In this paper, we show that the construction of objects has an interpretation in predicative type theory. <p> In their system, objects have three parts: an object state, the object methods, and the proofs of method correctness. As in our interpretation, specifications are encoded in objects using dependent method types. Their interpretation uses an existential encoding of objects <ref> [29; 20] </ref> in an impredicative type theory. Although the existential encoding restricts method update, the interpretation of objects does not require the use of recursive types, allowing the development of expressive type systems [7; 19].
Reference: [30] <author> Didier Remy and Jerome Vouillon. </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 40-53, </pages> <year> 1997. </year>
Reference-contexts: It may be possible to address this issue by giving a syntactic account of polymorphism that allows the use of recursive types to define objects. We are using the interpretation in the Nuprl-Light system [16] to implement a formal module layer on top of the Objective Caml module system <ref> [30] </ref>.
Reference: [31] <author> Adrian Rezus. </author> <title> Semantics of constructive type theory. </title> <type> Technical Report 70, </type> <institution> Nijmegen University, </institution> <address> The Netherlands, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: This is a stronger result because predicative theories make fewer assumptions and have more models. In particular, the Nuprl type theory that we use in this paper has multiple mathematical models, notably set theoretic [21], PER models [3; 26], denotational models <ref> [31] </ref>, and others. The object interpretation is more delicate but we get more information. For example, predicative theories have a strictly inductive construction [25; 4], so the Contact information: Jason J. Hickey, Department of Computer Science, Upson Hall, Cornell University, Ithaca, NY 14853 USA. Tel: 607-255-1372, email: jyh@cs.cornell.edu.
Reference: [32] <author> Robinson and Tennent. </author> <title> Bounded quantification and record-update problems. Message to types email list, </title> <year> 1988. </year>
Reference-contexts: Unfortunately, this typing also fails to produce the expected behavior because it contains only the identity functions <ref> [32] </ref>. Essentially, we don't want polymorphism over subtypes of fx: fg ! Zg, but over record extensions of fx: fg ! Z g. We address this issue in the next section as we develop the initial calculus. 3.

References-found: 32

