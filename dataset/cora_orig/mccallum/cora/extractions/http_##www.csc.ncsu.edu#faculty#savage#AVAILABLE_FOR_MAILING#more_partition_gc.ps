URL: http://www.csc.ncsu.edu/faculty/savage/AVAILABLE_FOR_MAILING/more_partition_gc.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/savage/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: Gray Code Enumeration of Families of Integer Partitions  
Author: David Rasmussen Carla D. Savage Douglas B. West 
Note: Research supported by the National Security Agency Grant No. MDA904-92-H-4001. Research supported by National Science Foundation Grant No. CCR9103431 and National Security Agency Grant No. MDA904-92-H-4001. Research supported National Security Agency Grant No. MDA904-90-H-4011.  
Address: Box 8206 Raleigh, NC 27612-8206  IL 61801  
Affiliation: Department of Computer Science North Carolina State University,  Department of Mathematics University of Illinois Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. R. Bitner, G. Ehrlich, and E. M. Reingold, </author> <title> "Efficient generation of the binary reflected Gray code and its applications," </title> <journal> Communications of the ACM 19 No. </journal> <volume> 9 (1976), </volume> <pages> 517-521. </pages>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element <ref> [1, 8, 12] </ref>, (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17].
Reference: [2] <author> J. H. Conway, N. J. A. Sloane, and A. R. Wilks, </author> <title> "Gray codes for reflection groups," </title> <booktitle> (1989) Graphs and Combinatorics 5 (1989), </booktitle> <pages> 315-325. </pages>
Reference-contexts: Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection <ref> [2] </ref>, and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17]. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above.
Reference: [3] <author> E. N. Gilbert, </author> <title> "Gray codes and paths on the n-cube," </title> <journal> Bell Systems Technical Journal (1958), </journal> <pages> 815-826. </pages>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit <ref> [4, 3] </ref>, (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17].
Reference: [4] <author> F. Gray, </author> <title> "Pulse code communication," </title> <editor> U. S. </editor> <booktitle> Patent 2632058 (1953). </booktitle>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit <ref> [4, 3] </ref>, (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17].
Reference: [5] <author> S. M. Johnson, </author> <title> "Generation of permutations by adjacent transpositions," </title> <journal> Math. Comp. </journal> <volume> 17 (1963), </volume> <pages> 282-285. </pages>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions <ref> [5, 16] </ref> (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15,
Reference: [6] <author> L. Lovasz, </author> <title> Problem 11 in Combinatorial Structures and their Applications, </title> <publisher> Gorden and Breach, </publisher> <address> London 1970. </address>
Reference-contexts: Under this view, many Gray code problems are special cases of open problems in graph theory. In cases such as 1, 2, 3, and 5 above, the associated graph is vertex transitive; it is an open question of Lovasz whether every connected vertex transitive graph has a Hamiltonian path <ref> [6] </ref>. The question remains open even if the vertex transitive graph is the Cayley graph of a finite group, as for (1) and (5) above. Herb Wilf suggested the problem of constructing Gray codes for integer partitions.
Reference: [7] <author> J. M. Lucas, D. Roelants van Baronaigien, and F. Ruskey, </author> <title> "On rotations and the generation of binary trees," </title> <journal> Journal of Algorithms 15, </journal> <volume> No. </volume> <month> 3 </month> <year> (1993) </year> <month> 343-366. 34 </month>
Reference-contexts: Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations <ref> [7] </ref>, (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17]. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above.
Reference: [8] <author> A. Nijenhuis and H. S. Wilf, </author> <title> Combinatorial Algorithms for Computers and Calculators, </title> <publisher> Academic Press, Inc., </publisher> <address> NY, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element <ref> [1, 8, 12] </ref>, (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17].
Reference: [9] <author> G. Pruesse and F. Ruskey, </author> <title> "Generating the linear extensions of certain posets by transpositions", </title> <note> SIAM Journal on Discrete Mathematics 4 (1991), 413-422. </note>
Reference-contexts: by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions <ref> [9, 10, 13, 15, 17] </ref>. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above. These schemes may permit "efficient" generation of combinatorial families of exponential size.
Reference: [10] <author> G. Pruesse and F. Ruskey, </author> <title> "Generating linear extensions fast", </title> <note> SIAM Journal on Computing (to appear). </note>
Reference-contexts: by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions <ref> [9, 10, 13, 15, 17] </ref>. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above. These schemes may permit "efficient" generation of combinatorial families of exponential size.
Reference: [11] <author> J. B. Remmel, </author> <title> "Bijective proofs of some classical partition identities," </title> <journal> Journal of Combinatorial Theory (A) 33 (1982), </journal> <pages> 273-286. </pages>
Reference-contexts: This generalizes the case of unrestricted partitions, where ffi = 1. By generalizing the construction of [14], we prove in Section 3 that for arbitrary ffi, Gray codes always exist. Partitions in which parts are restricted to lie in certain congruence classes modulo ffi are discussed, for example in <ref> [11] </ref>. In Section 4, we consider partitions into distinct parts, with adjacencies as above for ffi = 1. Due to the sparseness of this class in the set of all partitions, the previous construction fails.
Reference: [12] <author> F. Ruskey, </author> <title> "Adjacent interchange generation of combinations," </title> <booktitle> Journal of Algorithms 9 (1988), </booktitle> <pages> 162-180. </pages>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element <ref> [1, 8, 12] </ref>, (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15, 17].
Reference: [13] <author> F. Ruskey, </author> <title> "Generating linear extensions of posets by transpositions," </title> <journal> Journal of Combinatorial Theory (B) 54 (1992), </journal> <pages> 77-101. </pages>
Reference-contexts: by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions <ref> [9, 10, 13, 15, 17] </ref>. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above. These schemes may permit "efficient" generation of combinatorial families of exponential size.
Reference: [14] <author> C. Savage, </author> <title> "Gray code sequences of partitions," </title> <journal> Journal of Algorithms 10, </journal> <volume> No. </volume> <month> 4 </month> <year> (1989). </year>
Reference-contexts: the list is reordered in the following way, no violations occur: 6; 5 1; 4 2; 4 1 1; 3 2 1; 2 2 2; 2 2 1 1; 3 1 1 1; 2 1 1 1 1; 1 1 1 1 1 1: By a doubly recursive construction, Savage <ref> [14] </ref> proved that such a listing always exists. In fact, for any n and k satisfying n k 1, the set of partitions of n into parts of size at most k has such a listing. <p> This generalizes the case of unrestricted partitions, where ffi = 1. By generalizing the construction of <ref> [14] </ref>, we prove in Section 3 that for arbitrary ffi, Gray codes always exist. Partitions in which parts are restricted to lie in certain congruence classes modulo ffi are discussed, for example in [11].
Reference: [15] <author> G. Stachowiak, </author> <title> "Hamilton paths in graphs of linear extensions for unions of posets," </title> <journal> SIAM J. Discrete Math. </journal> <volume> 5 (1992), </volume> <pages> 199-206. </pages>
Reference-contexts: by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions <ref> [9, 10, 13, 15, 17] </ref>. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above. These schemes may permit "efficient" generation of combinatorial families of exponential size.
Reference: [16] <author> H. F. Trotter, </author> <title> "PERM (Algorithm 115)", </title> <journal> Communications of the ACM 5, </journal> <volume> No. </volume> <month> 8 </month> <year> (1962) </year> <month> 434-435. </month>
Reference-contexts: 1 Introduction Recent work in combinatorial enumeration has considered listing special sets so successive elements differ by a small, pre-specified change. Examples include (1) generating permutations by adjacent transpositions <ref> [5, 16] </ref> (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions [9, 10, 13, 15,
Reference: [17] <author> D. B. West, </author> <title> "Generating linear extensions by adjacent transpositions," </title> <journal> Journal of Combinatorial Theory (B), </journal> <volume> 57(1993). </volume> <pages> 35 </pages>
Reference-contexts: by adjacent transpositions [5, 16] (2) generating bit strings by changing one bit [4, 3], (3) generating subsets by changing one element [1, 8, 12], (4) generating binary trees by rotations [7], (5) generating Coxeter group elements by reflection [2], and (6) generating linear extensions of certain posets by transpositions <ref> [9, 10, 13, 15, 17] </ref>. Such enumeration schemes are called minimal change algorithms or combinatorial Gray codes, in honor of the reflected binary code of Gray for solving problem (2) above. These schemes may permit "efficient" generation of combinatorial families of exponential size.
References-found: 17

