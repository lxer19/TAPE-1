URL: ftp://ftp.cs.arizona.edu/xkernel/Papers/usc.ps
Refering-URL: http://www.cs.arizona.edu/scout/overview.html
Root-URL: http://www.cs.arizona.edu
Title: USC: A Universal Stub Compiler  
Author: Sean O'Malley, Todd Proebsting, and Allen Brady Montz 
Affiliation: University of Arizona  
Abstract: USC is a new stub compiler that generates stubs that perform many data conversion operations. USC is flexible and can be used in situations where previously only manual code generation was possible. USC generated code is up to 20 times faster than code generated by traditional argument marshaling schemes such as ASN.1 and Sun XDR. This paper presents the design of USC and a comprehensive set of experiments that compares USC performance with the best manually generated code and traditional stub compilers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: Finally, we believe that the poor performance of traditional stub compilers when marshaling base types and structures has masked potential improvements in support for marshaling pointer types. 5 Discussion 5.1 USC Implementation USC generates efficient code by minimizing loads and stores and doing algebraic transformations <ref> [1] </ref> to optimize representation changing operations (eg., masks and shifts). The optimizer's first priority is to minimize memory accesses. The test data we've seen supports the assertion that memory access is the primary hindrance to efficient stubs.
Reference: [2] <author> D. D. Clark, V. Jacobson, J. Romkey, and H. Sal--wen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Most importantly, we decided that performance matters. USC generates nearly optimal C code. Optimized code is vital for three reasons. First, modern Internet protocol implementations are very efficient; some TCP implementations require only tens of instructions to process an incoming packet <ref> [2] </ref>. A stub compiler which required hundreds of instructions to marshal the TCP header would dominate the cost of the protocol implementation. Second, USC can be used to generate very small stubs to access particular fields in structures.
Reference: [3] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proceedings of the SIGCOMM '90 Symposium, </booktitle> <pages> pages 200-208, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The correctness, performance, and portability of the marshaling code is critical. Argument marshaling is becoming recognized as one of the last remaining performance bottlenecks in network software <ref> [3] </ref>. There are two common solutions to the marshaling problem: manual code generation, and automatic code generation with a stub compiler. Most Internet protocols use manual methods for header marshaling and to our knowledge all device marshaling is done manually. <p> In a USC-enhanced C the programmer would only have to correctly annotate any network data | the compiler would handle any conversions needed. Existing presentation layers are recognized as the most serious remaining bottleneck in the network data path <ref> [3] </ref>. USC could provide the basis for a simpler and much faster presentation layer stub compiler.
Reference: [4] <author> P. Hoschka and C. Huitema. </author> <title> Automatic gener-atio of optimized code for marshalling routines. </title> <booktitle> In Proceedings of the IFIP Conference on Upper Layer Protocols, Architectures and Applications ULPAA '94, </booktitle> <address> Barcelona, Spain, </address> <year> 1994. </year>
Reference-contexts: Dynamic encodings of base types are expensive to process. Even with a highly optimizing stub compiler such as the one described in <ref> [4] </ref>, encoding an ASN.1/BER integer requires at least 11 instructions.
Reference: [5] <author> C. Huitema. Mavros: </author> <title> Highlights on an asn.1 compiler. </title> <type> Technical Report Internal Working Paper, </type> <institution> INRIA Project RODEO, </institution> <year> 1991. </year>
Reference-contexts: The standard XDR library incurs at least one procedure call per base type and another procedure call for each word of the encoded format. The poor performance of XDR stubs has been noted by others [11] [7]. Next the performance of the MAVROS <ref> [5] </ref> ASN.1 complier was tested. MAVROS was selected for this experiment because MAVROS generated stubs have been shown to be at least as fast as stubs generated by SNACC and much faster than stubs generated by ISODE.
Reference: [6] <author> C. Huitema and G. Chave. </author> <title> Measuring the performance of an asn.1 compiler. </title> <type> Technical Report Internal Working Paper, </type> <institution> INRIA Project RODEO. </institution>
Reference-contexts: The last row in Table 5 gives the results of using MAVROS to generate stubs using the experimental ASN.1 encoding format. These stubs perform much better than the ASN.1/BER stubs. The poor ASN.1 performance is clearly caused by the dynamic format defined in BER. Note that in <ref> [6] </ref> the reported results on this new encoding format were discouraging. There are several possible explanations for the discrepancy between their results and ours. The first explanation is that the test cases used in the paper were large and complex data structures that require the use of dynamically allocated storage.
Reference: [7] <author> C. Huitema and A. Doghri. </author> <title> A high speed approach for the osi presentation protocol. In Protocols for High-Speed Networks. </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1989. </year>
Reference-contexts: Closer examination of the XDR library helps explain this problem. The standard XDR library incurs at least one procedure call per base type and another procedure call for each word of the encoded format. The poor performance of XDR stubs has been noted by others [11] <ref> [7] </ref>. Next the performance of the MAVROS [5] ASN.1 complier was tested. MAVROS was selected for this experiment because MAVROS generated stubs have been shown to be at least as fast as stubs generated by SNACC and much faster than stubs generated by ISODE.
Reference: [8] <author> ISO. </author> <title> Specification of abstract syntax notation one. </title> <type> Technical Report International Standard ISO 8824, </type> <institution> International Standards Organization. </institution>
Reference: [9] <author> ISO. </author> <title> Specification of basic encoding rules for abstract syntax notation one. </title> <type> Technical Report International Standard ISO 8835, </type> <institution> International Standards Organization. </institution>
Reference: [10] <author> H. Lin. </author> <title> Estimation of the optimal performance of asn.1/ber transfer syntax. </title> <journal> Computer Comunica-tions Review, </journal> <year> 1993. </year>
Reference-contexts: We are still unsure as to its ability to define memory mapped device interfaces. While it can certainly cover a great majority of such interfaces, we are still discovering novel 1 The 54 instruction minimum presented in <ref> [10] </ref> appears to be somewhat pessimistic. formats which may require extensions to USC. USC generates C stubs. C was chosen for maximum portability. This can create problems when the target C compiler has a poor optimizer.
Reference: [11] <author> R. G. Minnich. Mether-nfs: </author> <title> A modified nsf which supports virtual shared memory. </title> <booktitle> In Proceedings of the Distributed and Multiprocessor Systems (SEDMSIV) Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Closer examination of the XDR library helps explain this problem. The standard XDR library incurs at least one procedure call per base type and another procedure call for each word of the encoded format. The poor performance of XDR stubs has been noted by others <ref> [11] </ref> [7]. Next the performance of the MAVROS [5] ASN.1 complier was tested. MAVROS was selected for this experiment because MAVROS generated stubs have been shown to be at least as fast as stubs generated by SNACC and much faster than stubs generated by ISODE.
Reference: [12] <author> J. Purtilo. </author> <title> Polylith: An environment to support management of tool interfaces. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Language Issues in Programming Environments, </booktitle> <pages> pages 12-18, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: We believe that complex pointer based types are rarely sent if only because they are so expensive. It is much more efficient to structure a distributed system such that large complex types don't move and use simple IPC's to update them in place as is recommended in <ref> [12] </ref>.
Reference: [13] <author> Sun Microsystems, Inc. XDR: </author> <title> External Data Representation, </title> <year> 1987. </year>
Reference-contexts: Unfortunately, the manual generation of marshaling code is time consuming, error prone, and rarely results in portable code. Most argument marshaling is now done using stub compilers such as Sun's rpcgen. In addition, certain protocols use a stub compiler to marshal their headers. For example, Sun RPC uses XDR <ref> [13] </ref>. Stub compilers eliminate most portability problems. Unfortunately, the performance of the stubs generated by many existing stub compilers leaves much to be desired. Furthermore, all existing stub compilers are inflexible and can only be used to marshal data to and from a stub compiler defined intermediate form.
Reference: [14] <author> C. A. Thekkath and H. M. Levy. </author> <title> Limits to low-latency communication on high-speed networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2), </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: ratio of the total time required to marshal a big header four times to the round trip time recorded for three different protocol implementations on the DECstation 5000/200: Ultrix user-to-user UDP/IP (1200 microsecond round trip), Mach kernel-to-kernel UDP/IP (800 microsecond round trip), and the RPC over ATM protocol presented in <ref> [14] </ref> (170 microsecond round trip). These results show that for standard protocol implementations the performance advantage of USC over ntoh stubs would probably be undetectable.
References-found: 14

