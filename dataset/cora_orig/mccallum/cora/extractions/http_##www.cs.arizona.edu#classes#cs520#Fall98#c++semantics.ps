URL: http://www.cs.arizona.edu/classes/cs520/Fall98/c++semantics.ps
Refering-URL: http://www.cs.arizona.edu/classes/cs520/
Root-URL: http://www.cs.arizona.edu
Title: A literate, executable, denotational semantics of simple C++ declarations  
Author: Joseph Reynolds 
Keyword: denotational semantics, C++, literate programming, declarations, executable semantics, Standard ML 1992 CR Categories: D.1.m [Programming Techniques] Miscellaneous Literate programming; D.3.1 [Programming Languages] Formal Definitions and Theory Semantics, syntax; D.3.3 [Programming Languages] Language Constructs and Features Data types and structures; F.3.2 [Logics and Meaning of Programs] Semantics of Programming Languages Denotational semantics.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: TR #93-15  
Abstract-found: 0
Intro-found: 1
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: The operation is_same_array_value checks if two arrays are the same array. This is used, for instance, to determine if pointer comparison is meaningful. 9 (Comparing two pointers is meaningful only if the pointers are either both point-ing to the same location or both pointing into the same array <ref> [ES90, Section 5.9] </ref>.) harray signature declaration 10i signature Array_Sig = sig type Array_Value type Memory type Location val alloc: Data_Type * Nat * Memory -&gt; Array_Value * Memory val index: Array_Value * Nat -&gt; Location val is_same_array_value: Array_Value * Array_Value -&gt; bool end; This code is used on page 6. 3.7 <p> We return 0 if the pointers refer to the same cell. If the pointers point into the same array, we perform subtraction. Otherwise, the ptrdiff_undefined exception is raised. In all cases the result is the C++ type ptrdiff_t, represented by an ML integer. <ref> [ES90, Section 5.7] </ref>. hdifference function declaration 26i fun difference (cell_ptr (_,loc1), cell_ptr (_,loc2)) = if is_same_location (loc1,loc2) then 0 else raise ptrdiff_undefined | difference (arr_ptr (_,arrval1,index1), arr_ptr (_,arrval2,index2)) = if Array_Struct.is_same_array_value (arrval1, arrval2) then index1 - index2 else raise ptrdiff_undefined | difference (_, _) = raise ptrdiff_undefined This code is used <p> The state we keep is the cumulative size of the fields seen so far. The update function has only to add that to the size of the current field. One small wrinkle is that an object with no members has a size greater than zero <ref> [ES90, Section 5.3.2, Section 9] </ref>; here we arbitrarily choose 4 as the size of such an object. hobject size guts 33i let val size = field_iter (0, fn (size_so_far, (field_name, field_type)) =&gt; size_so_far + Data_Type_Struct.sizeof (field_type, env)) in if size = 0 then 4 else size end This code is used
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1979. </year> <note> The second author is listed on the cover as Arthur J. Milner, which is clearly a mistake. </note>
Reference-contexts: It is the particular mapping that defines the language and provides the semantics. 1.4 Using SML to implement semantics The semantics in this paper are implemented in Standard ML (SML) [Pau91]. (ML was originally the name of a meta language for a theorem prover system <ref> [GMW79] </ref>.) This language is secure from type subversion and corruption of the run-time environment [Pau91, Section 1.5]. These features should be considered essential in any implementation of a formal system. SML signatures are used to describe the semantic domains.
Reference: [LP87] <author> Peter Lee and Uwe Pleban. </author> <title> A realistic compiler generator based on high-level semantics: Another progress report. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, Munich, </booktitle> <pages> pages 284-295. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: Compared to these, the techniques used in this paper offers a greater explanation of the denotational semantics technique and a better partitioning of the semantic values into domains. There is work in separating the concerns of the compile-time system from the run-time system <ref> [LP87] </ref>. This makes compilers derived from a semantic specification much more efficient.
Reference: [Mas91] <author> Dave Mason. </author> <title> Denotational semantics and an ML interpreter for a functional programming language. obtained from the author: </title> <address> dma-son@plg.uwaterloo.ca. </address> <year> 1991. </year>
Reference-contexts: There is a paper on denotational semantics implemented in SML <ref> [Mas91] </ref>. Compared to these, the techniques used in this paper offers a greater explanation of the denotational semantics technique and a better partitioning of the semantic values into domains. There is work in separating the concerns of the compile-time system from the run-time system [LP87].
Reference: [Pau91] <author> Laurence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> NY, </address> <year> 1991. </year> <month> 39 </month>
Reference-contexts: In practice this means a pre-digested tree is mapped onto well-understood environment and memory operations. It is the particular mapping that defines the language and provides the semantics. 1.4 Using SML to implement semantics The semantics in this paper are implemented in Standard ML (SML) <ref> [Pau91] </ref>. (ML was originally the name of a meta language for a theorem prover system [GMW79].) This language is secure from type subversion and corruption of the run-time environment [Pau91, Section 1.5]. These features should be considered essential in any implementation of a formal system. <p> and provides the semantics. 1.4 Using SML to implement semantics The semantics in this paper are implemented in Standard ML (SML) [Pau91]. (ML was originally the name of a meta language for a theorem prover system [GMW79].) This language is secure from type subversion and corruption of the run-time environment <ref> [Pau91, Section 1.5] </ref>. These features should be considered essential in any implementation of a formal system. SML signatures are used to describe the semantic domains. They provide a natural way to modularize the code and separate the system's functionality from implementation details.
Reference: [Ram92] <author> Norman Ramsey. </author> <title> Literate-programming tools need not be complex. </title> <type> Technical report, </type> <institution> Princeton, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: This technique combines documentation and source code into one coherent document. In this way, you are assured that the documentation is up to date. The literate programming tool used here is noweb <ref> [Ram92] </ref>. With this tool, a text file contains the literate program which looks very much like the L a T E X input that created this paper. The file can be processed by noweave to produce this file. And it can be processed by notangle to produce the source code.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: 1 Introduction Computer languages are difficult to learn and understand. Part of the problem is that there is (usually) no formal statement of what various language constructs mean. Denotational semantics <ref> [Sch86] </ref> provides a formal framework for developing this meaning. Yet there is no denotational semantics for C++. This paper provides a denotational semantics for some simple C++ declarations. 1.1 Audience This paper is intended for a general computer science audience interested in denotational semantics and C++ declarations. <p> Another restriction is that variables and classes must have unique names. E.g., you cannot say class foo -- foo; because then foo would denote both a variable and a class. 1.3 Denotational Semantics In denotational semantics, programs are mapped directly to their meanings as in <ref> [Sch86] </ref>. In practice this means a pre-digested tree is mapped onto well-understood environment and memory operations. <p> There are two. The first allows creation of types. The second allows the C++ programmer to declare variables. hsyntactic domain declarations 4i hData-Type type declaration 5i hDeclaration datatype declaration 4i hData-Type signature declaration 5i This code is used on page 4. C++ declarations are given using an abstract syntax <ref> [Sch86, Section 1.1] </ref>. For example, the C++ declaration int i; is represented by the SML expression var_decl ("i", IntType). A list of such declarations is represented by an ordinary SML list. 2.1 Declaration Syntax The declarations considered here are either simple variable declarations or simple class definitions. <p> The mundane domains of truth values, identifiers, and numbers are modeled with the built-in capabilities of SML. The environment and denotable values provide the usual sort of environment capabilities <ref> [Sch86] </ref>. Finally, memory and storable values provide the rich set of capabilities in C++ data structures. These last set of capabilities are most interesting. 5 This section presents the capabilities only|the interfaces for users of the system. The implementations are given later. <p> mappings to the environment: the name "Coord" to a SML Class which represents the equivalent C++ 6 class, and the name "loc" to a SML Variable which represents the equivalent C++ variable. struct Coord - int x, y; -; Coord loc; Functions new, add, and lookup provide the usual capabilities <ref> [Sch86, Chapter 7] </ref>. lookup raises the exception symbol_not_found if the symbol it is looking for is not there. <p> is used on page 16. hsizeof function signature 8i Storable_Value -&gt; int This code is used on page 16. hcopy function signature 8i Storable_Value * Location * Memory -&gt; Memory This code is used on page 16. 3.4 Memory Memory provides the usual sort of mapping from Location to Storable_Value <ref> [Sch86, Chapter 5] </ref>. The value initial and functions alloc and read should be self-explanatory. Function is_same_location provides an equality test for locations. <p> Memory is implemented in the usual way <ref> [Sch86, Section 5.1] </ref>. Locations are represented by integers. Memory is represented by a function from Location to Storable_Value. <p> The function is written in a continuation passing style (CPS) <ref> [Sch86, Section 9.1] </ref>. Its signature is given here. hEvalDeclList signature 28i Declaration list -&gt; DeclCont -&gt; DeclCont This code is used on page 29. 28 Our continuations are functions that take an (Environment * Memory) and produce a new (Environment * Memory).
Reference: [Set80] <author> Ravi Sethi. </author> <title> A case study in specifying the semantics of a programming langauge. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Las Vegas, Nevada, </address> <pages> pages 117-130. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1980. </year> <month> 40 </month>
Reference-contexts: env, mem) = let val thing = lookup (env, id) in (print (id^" is "); show_id2 (thing, env, mem)) end handle symbol_not_found =&gt; (print ("Unknown identifier: "^id^""n "); ()) This code is used on page 35. 8 Related Work Sethi published an article on the denotational semantics of C programs <ref> [Set80] </ref>. There is a paper on denotational semantics implemented in SML [Mas91]. Compared to these, the techniques used in this paper offers a greater explanation of the denotational semantics technique and a better partitioning of the semantic values into domains.
References-found: 8

