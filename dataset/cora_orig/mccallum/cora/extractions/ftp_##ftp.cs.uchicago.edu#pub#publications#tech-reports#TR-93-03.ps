URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-93-03.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: On PP-Low Classes  
Author: Lide Li 
Address: 1100 E. 58th St., Chicago, IL 60637  
Affiliation: University of Chicago Department of Computer Science  
Abstract: Recently Toda proved that the class WPP is low for PP. We show that there is a more general complexity class which is low for PP and contains all known low classes for PP. We show the exact low class of PP is not comparable with PP and C = P relative to some oracles. We prove that every sparse coC = P set is low for PP which improves a result of Kobler, Schoning, Toda and Toran that every sparse NP set is low for PP. We also give a new characterization of PP. We show that if class C is closed under join, complementation, and polynomial time conjunctive reducibility, then #P C = # C and 2GapP C = Gap C. This generalizes many results such as #P PH = # PH [Toda and Watanabe], P P = P [Papadimetriou and Zachos]
Abstract-found: 1
Intro-found: 1
Reference: [Bei92] <author> R. Beigel. </author> <title> Perceptrons, PP and the polynomial hierarchy. </title> <booktitle> In Proceedings of the 7th Structure in Complexity Theory Conference, </booktitle> <pages> pages 14-19, </pages> <year> 1992. </year>
Reference-contexts: One approach is to show its containment with other complexity classes. For example, NP; coNP PP [Gil77], C = P; coC = P PP [Sim75][Wag86], MA PP [Ver92]. One interesting open question is whether a language Turing reducible to PP, or even NP, is contained in PP. Beigel <ref> [Bei92] </ref> proved a negative result, that is, P NP is not contained in PP relative to an oracle. However, some positive approaches also have been achieved in the sense of restricted reducibilities. <p> Unfortunately, like P v. NP question, the current known technique is not capable to solve this problem. In fact, we have Theorem 3.4 There is an oracle A and an oracle B such that PP PP A PP B . Proof: Beigel <ref> [Bei92] </ref> proved that there is an oracle A such that P NP A 6 PP A . Since P NP A PP PP A , we have the first conclusion. <p> This implies that PP PH PP BPP C [Q;GapP] PP C [Q;GapP] PP if C [Q; GapP] Low PP. Since C = P = C [f0g; GapP], the previous statement implies that if PP C = P = PP, then PP PH = PP. But from Beigel <ref> [Bei92] </ref>, there exists an oracle A such that P NP A 6 PP A . This implies that PP PH A 6 PP A , contradicting that PP PH PP. Conversely, suppose any relativized class in Low PP is also contained in C = P. Then BPP C = P.
Reference: [BG92] <author> R. Beigel and J. Gill. </author> <title> Counting classes: thresholds, parity, </title> <journal> mods, and fewness. Theoretical Computer Science, </journal> <volume> 103 </volume> <pages> 3-23, </pages> <year> 1992. </year>
Reference: [BH77] <author> L. Berman and J. Hartmanis. </author> <title> On isomorphism and density of NP and other complete sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 1 </volume> <pages> 305-322, </pages> <year> 1977. </year>
Reference-contexts: Furthermore, we give a new characterization for PP. A language is sparse if there is a polynomial p such that the number of strings of length at most n in the language is bounded by p (n). It was conjectured by Hartmanis and Berman <ref> [BH77] </ref>, and finally proved by Mahaney [Mah82] that no sparse set could be NP-complete unless P = NP. Lately, Kobler, Schoning, Toda and Toran show that every sparse NP set is PP-low. In Section 5, we extend this result.
Reference: [BRS91] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> PP is closed under intersection. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1991. </year>
Reference-contexts: Beigel [Bei92] proved a negative result, that is, P NP is not contained in PP relative to an oracle. However, some positive approaches also have been achieved in the sense of restricted reducibilities. Beigel, Reingold and Spielman <ref> [BRS91] </ref> proved that PP is closed under several restricted reductions such as polynomial time conjunctive reducibility, and P PP [log] = PP. Fortnow and Reingold [FR91] further proved that PP is closed under truth table reducibility. The second approach is to show certain complexity classes are Turing reducible to PP. <p> " fl #1) [ (B#0 " fl #0) 2 Low PP It is easy to see that A [ B 2 BPP LowPP = Low PP 2 The condition that Low PP is not closed under union would imply that Low PP 6= PP, since PP is closed under union <ref> [BRS91] </ref>. Moreover, we have Proposition 3.7 If Low PP is not closed under union, then there are two Turing incomparable sets in Low PP. Proof: Let A; B 2 Low PP. If A and B are Turing comparable, then A 2 P B or B 2 P A . <p> Define a function pos as follows: pos (y) = 1 if y &gt; 0 0 otherwise Define polynomials similar to those in <ref> [BRS91] </ref>. <p> Then G (x) 2 GapP and x 2 L =) G (x) (3=2)f 0 (x) f 0 (x) &gt; 0 This proves that L 2 PP. 2 Corollary 5.18 (Beigel, Reingold and Spielman <ref> [BRS91] </ref>) PP is closed under intersection. Proof: Same as the proof for Proposition 5.2. 2 From Theorem 5.17, we see that APP is different from PP on just one restriction: the target functions depend on n only.
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference: [FFK91] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <booktitle> In Proceedings of the 6th Structure in Complexity Theory Conference, </booktitle> <pages> pages 30-42, </pages> <year> 1991. </year> <month> 16 </month>
Reference-contexts: Roughly speaking, these classes cannot help to increase PP's computational power. We call them PP-low classes. BPP is a well known example. In [KSTT92] it was proved that FEW is PP-low. Then Fenner et al <ref> [FFK91] </ref> proved a more general result: SPP is PP-low. Lately Toda [Tod91b] fl Research Partially Supported by NSF Grant CCR-9253582. E-mail: lilide@cs.uchicago.edu 1 proved that the class WPP is PP-low. The question whether there exists a more general PP-low complexity class became an interesting open problem. <p> In Section 5, we extend this result. We show that every sparse coC = P set is contained in APP, therefore is PP-low. The counting functions are closely related to PP. Valiant [Val79] studied classes #P and #NP (#P NP ). Fenner, Kurtz and Fortnow <ref> [FFK91] </ref> showed that the exact low class for GapP is SPP. In Section 3, we show that the exact low class for #P is UP " coUP. A corollary of this is that #P 6= #NP unless UP = NP = coNP [KST89]. <p> As usual, L denotes the characteristic function for L, and for any class C, coC = fA j A 2 Cg. Definition 2.1 [Val79] #P = facc M j M is a CMg UP = fL j L 2 #Pg Definition 2.2 <ref> [FFK91] </ref> GapP = facc M rej M j M is a CMg 2 SPP = fL j L 2 GapPg The use of GapP gives us the alternative and simpler definitions for many counting classes . We now list some commonly discussed ones. <p> Define Low C = fA j C A = Cg For example, it was proved in <ref> [FFK91] </ref> that Low GapP = SPP. It is also clear that Low FP = P. To consider Low #P, suppose A 2 Low #P. We note that A 2 #P A , and then A 2 #P since A is #P-low. This implies that A 2 UP. <p> Then we conclude that #P C # C For the other direction, we construct a oracle counting machine M with oracle B. on input x, M simply guesses a string y, then ask query for (x; y). Clearly, M witnesses a function f 2 #P C . 2)In <ref> [FFK91] </ref>, it is proved that for any GapP function g, there is a normal CM M such that 2g = gap M . This result is relativized. Suppose g 2 GapP C . Then there is a oracle CM M s.t. 2g = gap M .
Reference: [FFKL93] <author> S. Fenner, L. Fortnow, S. Kurtz, and L. Li. </author> <title> An oracle builder's toolkit. In Proceedings of the 8th Structure in Complexity Theory Conference, </title> <note> page to appear, </note> <year> 1993. </year>
Reference-contexts: We may view them as determined by two type of functions, main functions and target functions. In fact, this type of structure has been used in a different approach. The following class was introduced in <ref> [FFKL93] </ref>. <p> In FFKL <ref> [FFKL93] </ref>, it was proved that with a sp-generic oracle G, P G = AWPP G . Thus, as a direct consequences, we have P G = UP G = FewP G = SPP G = BPP G = WPP G = AWPP G for an sp-generic G.
Reference: [FFL93] <author> S. Fenner, L. Fortnow, and L. Li. </author> <title> Gap-definability as closure property. </title> <booktitle> In Proceedings of the 10th Symposium on Theoretical Aspects of Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Proof: (=)) Suppose Low PP is closed under union, it is also closed under complementation. By De Morgan's Law, Low PP is closed under intersection. Since SPP Low PP, and ;; fl 2 Low PP, according to Corollary3.3 of <ref> [FFL93] </ref>, Low PP is gap-definable. ((=) Suppose that Low PP is gap-definable, let A; B 2 Low PP. Then A#1; B#0 2 Low PP. Clearly fl #1; fl #0 2 SPP and they are disjoint. Then from Theorem 3.2 of [FFL93], A#1 [ B#0 = (A#1 " fl #1) [ (B#0 <p> and ;; fl 2 Low PP, according to Corollary3.3 of <ref> [FFL93] </ref>, Low PP is gap-definable. ((=) Suppose that Low PP is gap-definable, let A; B 2 Low PP. Then A#1; B#0 2 Low PP. Clearly fl #1; fl #0 2 SPP and they are disjoint. Then from Theorem 3.2 of [FFL93], A#1 [ B#0 = (A#1 " fl #1) [ (B#0 " fl #0) 2 Low PP It is easy to see that A [ B 2 BPP LowPP = Low PP 2 The condition that Low PP is not closed under union would imply that Low PP 6= PP, since
Reference: [For93] <author> L. </author> <title> Fortnow. </title> <type> Private communication. </type> <year> 1993. </year>
Reference-contexts: Finally, we generalize the class APP by extending the function f (1 n ) to be a function which depends on n and x . Interestingly, the new class we obtained is exactly PP. Thus we have a new characterization for PP. Theorem 5.17 (Fortnow <ref> [For93] </ref>) L 2 PP if and only if for any polynomial r, there are f; g 2 GapP such that f (x) &gt; 0 for all x, and for all n; x with n jxj, x 2 L =) (1 2 r (n) )f (x; 1 n ) g (x; 1
Reference: [FR91] <author> L. Fortnow and N. Reingold. </author> <title> PP is closed under truth-table reductions. </title> <booktitle> In Proceedings of the 6th Structure in Complexity Theory Conference, </booktitle> <pages> pages 13-15, </pages> <year> 1991. </year>
Reference-contexts: However, some positive approaches also have been achieved in the sense of restricted reducibilities. Beigel, Reingold and Spielman [BRS91] proved that PP is closed under several restricted reductions such as polynomial time conjunctive reducibility, and P PP [log] = PP. Fortnow and Reingold <ref> [FR91] </ref> further proved that PP is closed under truth table reducibility. The second approach is to show certain complexity classes are Turing reducible to PP. Toda [Tod91a] proved a remarkable result that the Polynomial Time Hierarchy is Turing reducible to PP.
Reference: [Gil77] <author> J. Gill. </author> <title> Computational complexity of probabilistic complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <pages> 675-695, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction The class PP (Probabilistic Polynomial time) was introduced by Gill <ref> [Gil77] </ref> and Simon [Sim75]. PP is the class of all languages accepted by a polynomial time nondeterministic Turing machine (PP machine) which accepts an input if and only if at least half of its paths are accepting. <p> Quite a few papers, from different approaches, have investigated its computational power, and it received much attention in recent years. One approach is to show its containment with other complexity classes. For example, NP; coNP PP <ref> [Gil77] </ref>, C = P; coC = P PP [Sim75][Wag86], MA PP [Ver92]. One interesting open question is whether a language Turing reducible to PP, or even NP, is contained in PP. Beigel [Bei92] proved a negative result, that is, P NP is not contained in PP relative to an oracle.
Reference: [Gre93] <author> F. Green. </author> <title> On the power of deterministic reductions to C=P. </title> <journal> Mathematical Systems Theory, </journal> <volume> 26 </volume> <pages> 215-233, </pages> <year> 1993. </year>
Reference-contexts: This implies that PP PH A 6 PP A , contradicting that PP PH PP. Conversely, suppose any relativized class in Low PP is also contained in C = P. Then BPP C = P. It was proved by Green <ref> [Gre93] </ref> that there exists an oracle B such that BPP B 6 P C = P B .
Reference: [Her90] <author> U. Hertrampf. </author> <title> Relations among mod-classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 74 </volume> <pages> 325-328, </pages> <year> 1990. </year>
Reference: [KST89] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year>
Reference-contexts: Fenner, Kurtz and Fortnow [FFK91] showed that the exact low class for GapP is SPP. In Section 3, we show that the exact low class for #P is UP " coUP. A corollary of this is that #P 6= #NP unless UP = NP = coNP <ref> [KST89] </ref>. In Section 4, we show that if a class C is closed under join, complementation and polynomial time conjunctive reducibility, then #P C = # C and 2GapP C = Gap C. <p> All other paths of N are rejecting. Therefore, acc N = acc M A . From the discussion above, we have Proposition 3.2 * Low FP = P * Low GapP = SPP * Low #P = UP " coUP Corollary 3.3 <ref> [KST89] </ref> #P 6= #P NP unless UP = NP = coNP. Now we investigate the class Low PP. That is, the class of all language A such that PP A = PP. <p> It is interesting to study function classes with higher complexity oracles. Recently, it is known that #P PH is 1-Turing reducible to #P [TW92]. #P 6= #P NP unless NP = coNP <ref> [KST89] </ref>. We consider the counting functions with general oracle classes. We show that with oracles from quite wide range of complexity classes, these functions indeed have much simpler structures. Definition 4.1 Let C be a complexity class.
Reference: [KSTT92] <author> J. Kobler, U. Schoning, S. Toda, and J. Toran. </author> <title> Turing machines with few accepting computations and low sets for PP. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44(2) </volume> <pages> 272-286, </pages> <year> 1992. </year>
Reference-contexts: That is, with additional access to a set (oracle) in such classes, a PP machine still accepts a language in PP. Roughly speaking, these classes cannot help to increase PP's computational power. We call them PP-low classes. BPP is a well known example. In <ref> [KSTT92] </ref> it was proved that FEW is PP-low. Then Fenner et al [FFK91] proved a more general result: SPP is PP-low. Lately Toda [Tod91b] fl Research Partially Supported by NSF Grant CCR-9253582. E-mail: lilide@cs.uchicago.edu 1 proved that the class WPP is PP-low. <p> Clearly G; F 2 GapP . Then L 2 APP follows. 2 As an immediate consequence of this theorem and Lemma4.4, Lemma5.7, we have Theorem 5.10 APP is PP-low. Corollary 5.11 (Toda [Tod91b]) WPP is PP-low. Kobler et al <ref> [KSTT92] </ref> proved that every sparse NP set is PP-low. We shall further prove that every sparse coC = P set is PP-low. Theorem 5.12 coC = P " SPARSE APP. Proof: Let L 2 coC = P " SPARSE. <p> Corollary 5.15 (Kobler, Schoning, Toda and Toran <ref> [KSTT92] </ref>) NP " SPARSE is PP-low. Since APP is closed under complementation, we also have Corollary 5.16 C = P " coSPARSE is PP-low. Finally, we generalize the class APP by extending the function f (1 n ) to be a function which depends on n and x .
Reference: [Mah82] <author> S. Mahaney. </author> <title> Sparse complete sets for np: solution of a conjecture of berman and hartmanis. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 130-143, </pages> <year> 1982. </year>
Reference-contexts: A language is sparse if there is a polynomial p such that the number of strings of length at most n in the language is bounded by p (n). It was conjectured by Hartmanis and Berman [BH77], and finally proved by Mahaney <ref> [Mah82] </ref> that no sparse set could be NP-complete unless P = NP. Lately, Kobler, Schoning, Toda and Toran show that every sparse NP set is PP-low. In Section 5, we extend this result. We show that every sparse coC = P set is contained in APP, therefore is PP-low.
Reference: [PZ83] <author> C. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proceedings of the 6th GI Conference on Theoretical Computer Science, volume 145 of Lecture Notes in Computer Science, </booktitle> <pages> pages 269-276. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: The direct consequences of this result include that #P PH = # PH [TW92] and that P P = P <ref> [PZ83] </ref>. 2 The Counting Functions and Counting Classes We assume that the readers are familiar with complexity classes such as NP, BPP, PH. The function classes #P and GapP are two of the most interesting counting function classes. <p> Corollary 4.5 * NP SPP = 9 SPP * PP PH = C PH * NP NP"coNP = 9 (NP " coNP) NP; therefore NP NP"coNP = NP * NP BPP = 9 BPP * P P = P = P (Papadimitriou and Zachos <ref> [PZ83] </ref>) Proof of Theorem4.2: 1) Suppose function f 2 #P C is witnessed by an oracle counting machine M with oracle C 2 C.
Reference: [Sim75] <author> J. Simon. </author> <title> On Some Central Problems in Computational Complexity. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1975. </year> <type> TR 75-224. </type>
Reference-contexts: 1 Introduction The class PP (Probabilistic Polynomial time) was introduced by Gill [Gil77] and Simon <ref> [Sim75] </ref>. PP is the class of all languages accepted by a polynomial time nondeterministic Turing machine (PP machine) which accepts an input if and only if at least half of its paths are accepting. <p> We now list some commonly discussed ones. Definition 2.3 * ([Gil77], <ref> [Sim75] </ref>) PP = fL j 9g 2 GapP; s.t. x 2 L iff g (x) 0g * ([Wag86]) C = P = fL j 9g 2 GapP; s.t. x 2 L iff g (x) = 0g * ([CH90][Her90][BG92]) Mod k P = fL j 9g 2 GapP; s.t. x 2 L
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: The following theorem is in this sense. 5 Theorem 3.8 C = P and Low PP are incomparable relative to some oracles. Proof: From <ref> [TO92] </ref>, we have C [Q; GapP (PH)] BPP C [Q;GapP] where C [Q; F ] is the class of all language L such that 9f 2 F , and x 2 L iff f (x) 2 Q.
Reference: [Tod91a] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: Fortnow and Reingold [FR91] further proved that PP is closed under truth table reducibility. The second approach is to show certain complexity classes are Turing reducible to PP. Toda <ref> [Tod91a] </ref> proved a remarkable result that the Polynomial Time Hierarchy is Turing reducible to PP. Before his proof, such computational power of PP was not expected. The third approach is to show that certain complexity classes are low for PP.
Reference: [Tod91b] <author> S. </author> <title> Toda. </title> <type> Private communication. </type> <year> 1991. </year>
Reference-contexts: Roughly speaking, these classes cannot help to increase PP's computational power. We call them PP-low classes. BPP is a well known example. In [KSTT92] it was proved that FEW is PP-low. Then Fenner et al [FFK91] proved a more general result: SPP is PP-low. Lately Toda <ref> [Tod91b] </ref> fl Research Partially Supported by NSF Grant CCR-9253582. E-mail: lilide@cs.uchicago.edu 1 proved that the class WPP is PP-low. The question whether there exists a more general PP-low complexity class became an interesting open problem. <p> Now we investigate the class Low PP. That is, the class of all language A such that PP A = PP. Since PP WPP = PP <ref> [Tod91b] </ref>, PP BPP = PP, we have WPP Low PP; BPP Low PP, and Low PP PP LowPP = PP. Thus WPP Low PP PP Since PP P LowPP PP LowPP PP we also have P LowPP Low PP. That is, Low PP is closed under Turing-reducibility. <p> Clearly G; F 2 GapP . Then L 2 APP follows. 2 As an immediate consequence of this theorem and Lemma4.4, Lemma5.7, we have Theorem 5.10 APP is PP-low. Corollary 5.11 (Toda <ref> [Tod91b] </ref>) WPP is PP-low. Kobler et al [KSTT92] proved that every sparse NP set is PP-low. We shall further prove that every sparse coC = P set is PP-low. Theorem 5.12 coC = P " SPARSE APP. Proof: Let L 2 coC = P " SPARSE.
Reference: [TW92] <author> S. Toda and O. Watanabe. </author> <title> Polynomial time 1-turing reducibility from #ph to #p. </title> <journal> Theoretical Computer Science, </journal> <volume> 100, </volume> <year> 1992. </year>
Reference-contexts: In Section 4, we show that if a class C is closed under join, complementation and polynomial time conjunctive reducibility, then #P C = # C and 2GapP C = Gap C. The direct consequences of this result include that #P PH = # PH <ref> [TW92] </ref> and that P P = P [PZ83]. 2 The Counting Functions and Counting Classes We assume that the readers are familiar with complexity classes such as NP, BPP, PH. The function classes #P and GapP are two of the most interesting counting function classes. <p> It is interesting to study function classes with higher complexity oracles. Recently, it is known that #P PH is 1-Turing reducible to #P <ref> [TW92] </ref>. #P 6= #P NP unless NP = coNP [KST89]. We consider the counting functions with general oracle classes. We show that with oracles from quite wide range of complexity classes, these functions indeed have much simpler structures. Definition 4.1 Let C be a complexity class. <p> So it covers quite wide range of classes. Note that the coefficient 2 in part 3 is necessary, since all functions in Gap C take only even values, while those in GapP C need not to. As an example of direct application, we have Corollary 4.3 (Toda and Watanabe <ref> [TW92] </ref>) #P PH = # PH. 6 We may also apply the theorem to reduce counting classes with oracles.
Reference: [Val79] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: Lately, Kobler, Schoning, Toda and Toran show that every sparse NP set is PP-low. In Section 5, we extend this result. We show that every sparse coC = P set is contained in APP, therefore is PP-low. The counting functions are closely related to PP. Valiant <ref> [Val79] </ref> studied classes #P and #NP (#P NP ). Fenner, Kurtz and Fortnow [FFK91] showed that the exact low class for GapP is SPP. In Section 3, we show that the exact low class for #P is UP " coUP. <p> The meaning for rej M (x) and total M (x) are then clear. As usual, L denotes the characteristic function for L, and for any class C, coC = fA j A 2 Cg. Definition 2.1 <ref> [Val79] </ref> #P = facc M j M is a CMg UP = fL j L 2 #Pg Definition 2.2 [FFK91] GapP = facc M rej M j M is a CMg 2 SPP = fL j L 2 GapPg The use of GapP gives us the alternative and simpler definitions for
Reference: [Ver92] <author> N. Vereshchagin. </author> <title> On the power of pp. </title> <booktitle> In Proceedings of the 7th Structure in Complexity Theory Conference, </booktitle> <pages> pages 138-143, </pages> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Quite a few papers, from different approaches, have investigated its computational power, and it received much attention in recent years. One approach is to show its containment with other complexity classes. For example, NP; coNP PP [Gil77], C = P; coC = P PP [Sim75][Wag86], MA PP <ref> [Ver92] </ref>. One interesting open question is whether a language Turing reducible to PP, or even NP, is contained in PP. Beigel [Bei92] proved a negative result, that is, P NP is not contained in PP relative to an oracle.
Reference: [Wag86] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representa-tion. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year> <month> 18 </month>
References-found: 25

