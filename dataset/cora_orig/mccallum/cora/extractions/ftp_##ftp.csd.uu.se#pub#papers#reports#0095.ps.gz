URL: ftp://ftp.csd.uu.se/pub/papers/reports/0095.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Extending Horn Clause Theories by Reflection Principles  
Author: Stefania Costantini Pierangelo Dell'Acqua and Gaetano A. Lanzarone 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Uppsala University Computing Science Department  Dipartimento di Scienze dell'Informazione, Universita degli Studi di Milano  
Date: January, 1995  
Note: 20  
Abstract: UPMAIL Technical Report No. 95 Abstract In this paper, we introduce logical reflection as a principled way to empower the representation and reasoning capabilities of logic programming systems. In particular, reflection principles take the role of axiom schemata of a particular form that, once added to a given logic program (the basic theory, or the initial axioms), enlarge the set of consequences sanctioned by those initial axioms. The main advantage of this approach is that it is much easier to write a basic theory and then to augment it with condensed axiom schemata, than it is to write a corresponding large (or even infinite) set of axioms in the first place. Moreover, the well-established semantic properties of Horn clauses, carry over to Horn clauses with reflection. In fact, the semantics of Reflective SLD Resolution and the semantics of the Reflective Least Herbrand Model are obtained by making slight variations to, respectively, the procedural and the declarative semantics classically defined for Horn clauses. We present a complete formalization of this concept of reflection, that should constitute a simple way of understanding reflective programs; and a description of how reflection allows one to treat uniformly different application areas. To support this claim, the following three case studies will be discussed: metalevel reasoning; reasoning with multiple communicating theories (agents); and analogical reasoning. For each of these areas, the choice of a suitable reflection principle is shown, which tries to capture the specificity of the problem domain. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> H. D. Abramson, M. H. Rogers (eds). </editor> <booktitle> Meta-Programming in Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Thus, this use of reflection is different in essence from previous use of reflection rules in logic programming. Following [3], metaprogramming in logic programming <ref> [1, 4] </ref> has often been based on so-called metainterpreters. These are meta-level clauses which explicitly represent the derivability relation of the object level language, and are added to the clauses representing the problem domain.
Reference: [2] <author> J. Barklund, S. Costantini, P. Dell'Acqua, and G. A. Lanzarone. </author> <title> Reflection through Constraint Satisfaction. </title> <note> Submitted paper. </note>
Reference-contexts: The requirement that the result of transposition be applied to ground atoms only (i.e., in point (ii) of Definition 7 A i is required to be ground) can be avoided if unification is replaced by a more general constraint-satisfaction device. The problem is extensively discussed in <ref> [2] </ref> where a suitable solution is proposed, so as reflection can be applied with no restrictions. <p> To this aim, it is necessary to summarize the naming mechanism of RP , which is based on a naming relation NR. Please notice that the following is a very simplified version of a much more rich, complex and precise name theory. For detail, the reader may refer to <ref> [2] </ref>. In the language of an RP program P there are object variables, that we indicate with the usual syntax (e.g. X) and metavariables, that here we conventionally indicate by a single quote (e.g. Y 0 ), though this is not the concrete syntax used in RP .
Reference: [3] <author> K. A. Bowen, R. A. Kowalski. </author> <title> Amalgamating Language and Metalan-guage. </title> <editor> in: K. L. Clark and S. ATarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Thus, this use of reflection is different in essence from previous use of reflection rules in logic programming. Following <ref> [3] </ref>, metaprogramming in logic programming [1, 4] has often been based on so-called metainterpreters. These are meta-level clauses which explicitly represent the derivability relation of the object level language, and are added to the clauses representing the problem domain.
Reference: [4] <author> M. Bruynooghe (ed.). </author> <booktitle> Proceedings of the 2nd Workshop on Metapro-gramming in Logic. </booktitle> <address> Leuven (Belgium), </address> <month> April 4-6 </month> <year> 1990. </year>
Reference-contexts: Thus, this use of reflection is different in essence from previous use of reflection rules in logic programming. Following [3], metaprogramming in logic programming <ref> [1, 4] </ref> has often been based on so-called metainterpreters. These are meta-level clauses which explicitly represent the derivability relation of the object level language, and are added to the clauses representing the problem domain.
Reference: [5] <author> S. Costantini, G. A. Lanzarone. </author> <title> A Metalogic Programming Approach: Language, Semantics and Applications. </title> <journal> Journal of Experimental and Theoretical Artificial Intelligence 1(1993). </journal> <note> Extended Abstract in: </note> <editor> G. Levi and A. Martelli (eds.) </editor> <booktitle> Logic Programming, Proceedings of the Sixth International Conference, </booktitle> <publisher> The Mit Press, </publisher> <year> 1989. </year>
Reference-contexts: The applications of reflection that we have previously studied (and reported in detail in previous papers <ref> [5, 6, 7, 8] </ref>) become instances of the new formalization (modulo a suitable reformulation). Thus we are able to present them as case studies, that show how reflective logic programming can constitute a uniform framework for several problem domains. <p> In the following sections we show how different forms of knowledge representation and reasoning can be accomodated in the proposed framework, by defining suitable reflection principles. 3 Meta-level Reasoning A relevant application of the formalization presented in the previous Section is the language Reflective Prolog (RP) <ref> [5, 6] </ref>, a metalogic programming and knowledge representation language which allows the definition and use of both knowledge and metaknowledge in a uniform way in the same program. RP has three basic features. <p> Procedurally, clauses with conclusion solve ("A) may be used to resolve a goal A, and vice versa clauses with conclusion A to resolve solve ("A). 7 Many examples of use of the reflective RT P and resolution of RP are given in <ref> [5] </ref>, and we will give here only a brief illustration of the application of the reflection rules in RP . To this aim, it is necessary to summarize the naming mechanism of RP , which is based on a naming relation NR. <p> Below we show how an arbitrary reflection principle can be represented by means of RP reflection rules (introduced in section 3). Let theory clause be the declarative equivalent of the Prolog predefined predicate clause <ref> [5] </ref>.
Reference: [6] <author> S. Costantini, G. A. Lanzarone. </author> <title> Metalevel Negation in Non-Monotonic Reasoning. To appear on the Journal of Methods of Logic in Computer Science. Extended Abstract in: </title> <booktitle> Proceedings of the Workshop on Logic Programming and Non-Monotonic Reasoning, </booktitle> <address> Austin, TX, </address> <month> November 1-2, </month> <year> 1990. </year>
Reference-contexts: The applications of reflection that we have previously studied (and reported in detail in previous papers <ref> [5, 6, 7, 8] </ref>) become instances of the new formalization (modulo a suitable reformulation). Thus we are able to present them as case studies, that show how reflective logic programming can constitute a uniform framework for several problem domains. <p> In the following sections we show how different forms of knowledge representation and reasoning can be accomodated in the proposed framework, by defining suitable reflection principles. 3 Meta-level Reasoning A relevant application of the formalization presented in the previous Section is the language Reflective Prolog (RP) <ref> [5, 6] </ref>, a metalogic programming and knowledge representation language which allows the definition and use of both knowledge and metaknowledge in a uniform way in the same program. RP has three basic features. <p> In general, the reflection principle R is automatically applied on failure of goals by SLD-Resolution. We sketch now an informal proof of soundness of the implementation w.r.t. the given semantics. RP's Resolution has been proved correct and complete w.r.t. the Least Reflective Herbrand model of an RP program <ref> [6] </ref>. Let us assume that the clause above is a sound representation of a reflection principle (the main point is that the procedures correctly implement the transposition). <p> As mentioned in the introduction, we are since long experimenting with the usability of this approach. In addition to the three case studies presented in this paper, we have also coped with paradigms such as non-monotonic reasoning <ref> [6] </ref>, explanation-based generalization, and object-oriented knowledge representation (forthcoming papers). 14
Reference: [7] <author> S. Costantini, G. A. Lanzarone, and L. Sbarbaro. </author> <title> A Formal Definition and a Sound Implementation of Analogical Reasoning in Logic Programming. </title> <note> To appear on the Annals of Mathematics and Artificial Intelligence. </note>
Reference-contexts: The applications of reflection that we have previously studied (and reported in detail in previous papers <ref> [5, 6, 7, 8] </ref>) become instances of the new formalization (modulo a suitable reformulation). Thus we are able to present them as case studies, that show how reflective logic programming can constitute a uniform framework for several problem domains. <p> In fact, most forms of plausible reasoning reinterpret available premises to draw plausible conclusions. As a significant example, a knowledge representation principle which has been shown <ref> [7] </ref> to be easily formalizable in terms of reflection is replacement based analogy [13]. Analogy is based on the assumption that if two situations are similar in some respect, then they may be similar in other respects as well. <p> The analogous rules can be computed by means of partial identity between terms of the two domains, like in [10], or by means of predicate analogies and terms correspondence like in <ref> [7] </ref>, as exemplified below. Example 3 Consider the following programs P s and P t . <p> only one element of the target domain; on the contrary, two elements of the source domain, like the constants john and george in the example, may correspond to the same element of the target domain. 2 Reflective semantics of this kind of analogical reasoning is defined in full detail in <ref> [7] </ref>. We report here only the essential points, in order to show the connection to the formalization that we propose in this paper. Let a program P be divided into two subprograms, P s and P t , as mentioned above.
Reference: [8] <author> S. Costantini, P. Dell'Acqua, and G. A. Lanzarone. </author> <title> Reflective Agents in Metalogic Programming. </title> <editor> in: A. Pettorossi (ed.) </editor> <booktitle> Meta-Programming in Logic. Lecture Notes in Computer Science 649, </booktitle> <address> Springer-Verlag,1992. </address>
Reference-contexts: The applications of reflection that we have previously studied (and reported in detail in previous papers <ref> [5, 6, 7, 8] </ref>) become instances of the new formalization (modulo a suitable reformulation). Thus we are able to present them as case studies, that show how reflective logic programming can constitute a uniform framework for several problem domains. <p> In the context of communication-based reasoning, the 8 interaction among agents is based on communication acts. In particular, every agent can make questions to other agents in order to solve a given problem. Within the logic programming paradigm, an approach to communication-based reasoning has been proposed in <ref> [8] </ref>. The main idea of this approach is to represent agents and communication acts by means of theories and reflection principles, respectively. Thus, theories formalize knowledge of agents, while a reflection principle characterizes a possible interaction among agents.
Reference: [9] <author> S. Feferman. </author> <title> Transfinite Recursive Progressions of Axiomatic Theories. </title> <journal> Journal of Symbolic Logic vol. </journal> <volume> 27, </volume> <editor> n. </editor> <volume> 3, </volume> <year> 1962. </year>
Reference-contexts: In this paper, we introduce logical reflection as a principled way to further empower the representation and reasoning capabilities of logic programming systems. What we are referring to here are reflection principles inspired by those introduced in logic by Feferman <ref> [9] </ref>, where a reflection principle is understood as "a description of a procedure for adding to any set of axioms A certain new axioms whose validity follow from the validity of the axioms A and which formally express within the language of A evident consequences of the assumption that all the <p> The denomination "reflection principle" is borrowed from the work of Fe-ferman <ref> [9] </ref>, where (though in a quite different context) a reflection principle is defined to be "a description of a procedure for adding to any set of axioms A certain new axioms whose validity follow from the validity of the axioms A : : :". 4 In fact, in the definition 2.5,
Reference: [10] <author> M. Haraguchi, S. </author> <title> Arikawa. Reasoning by Analogy as a Partial Identity between Models. </title> <editor> in: K. P. Jantke (ed.), </editor> <title> Analogical and Inductive Inference. </title> <booktitle> Lecture Notes in Computer Science n. </booktitle> <volume> 265, </volume> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The analogous rules can be computed by means of partial identity between terms of the two domains, like in <ref> [10] </ref>, or by means of predicate analogies and terms correspondence like in [7], as exemplified below. Example 3 Consider the following programs P s and P t .
Reference: [11] <author> R. A. Kowalski. </author> <title> Problems and Promises of Computational Logic. </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic: Symposium Proceedings. </booktitle> <publisher> Springer-Verlag 1990. </publisher> <pages> 15 </pages>
Reference-contexts: These languages have well-behaved, convenient, computational properties, and well-developed, clean model and proof theories. Limitations of these kinds of formal systems have also been recognized, however, and several directions of research are active to overcome them <ref> [11] </ref>. In this paper, we introduce logical reflection as a principled way to further empower the representation and reasoning capabilities of logic programming systems.
Reference: [12] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming (Second, Extended Edition). </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: In fact, the semantics of Reflective SLD Resolution and the semantics of the Reflective Least Herbrand Model are obtained by making slight variations to, respectively, the procedural and the declarative semantics classically defined for Horn clauses <ref> [12] </ref>. Though this is a novel approach to reflective logic programming, it should not be seen as a tentative proposal. Rather, it is the outcome of the systematization and generalization of results accumulated in several years of study and experimentation on using reflection principles in the logic programming 1 framework. <p> In the following, let P be a definite program and B P its Herbrand base. Let also "terms" and "atoms" be terms and atoms in the language of P . It is useful to assume that the variables appearing in P are standardized apart <ref> [12] </ref>. Definition 1 A transformation schema AX is a mapping from Horn clauses to Horn clauses. We indicate the application of AX by ( AX . 2 The following general definitions can be given. Definition 2 Let I B P be an interpretation for P . <p> k )) and fD 1 ; : : : ; D k g I implies A 0 2 I, since I is a model of the reflection axioms defined by the reflection principle iff RT P (I) I. 2 Therefore we can apply the result by Van Emden and Kowalski <ref> [12, Th 6.5] </ref> thus providing a fixpoint characterization of the Least Reflective Herbrand Model LRM R P . Theorem 3 LRM R P = RT R S P " n (where RT R P " 0 = ;). <p> exists a computed answer for P [ fGg and a substitution fl such that = fl. 2 We do not report here the proofs of the above results because they are quite long and (similarly to the proof of Theorem 2) they are straightforward extensions of the corresponding proofs in <ref> [12] </ref>. Clearly, soundness and completeness of RSLD R -Resolution depend on appropriate properties of the procedural mechanism associated with R . <p> adding more cases to function RT and to resolution. 6 The semantics we have just presented is applicable for introducing re-flection not only in the plain Horn clause language, but possibly in all its variations and extensions which are mainly based on variations and extensions of the classical semantics of <ref> [12] </ref>.
Reference: [13] <author> P. Winston. </author> <title> Learning and Reasoning by Analogy. </title> <journal> Communication of the Association for Computing Machinery, </journal> <volume> 23 (12), </volume> <month> December </month> <year> 1980. </year> <month> 16 </month>
Reference-contexts: In fact, most forms of plausible reasoning reinterpret available premises to draw plausible conclusions. As a significant example, a knowledge representation principle which has been shown [7] to be easily formalizable in terms of reflection is replacement based analogy <ref> [13] </ref>. Analogy is based on the assumption that if two situations are similar in some respect, then they may be similar in other respects as well. Thus, an analogy is a mapping of knowledge from a known "source" domain into a novel "target" domain. <p> In particular, replacement-based analogy defines analogy as a replacement of the source object with the target object as stated in the following principle, due to Winston <ref> [13] </ref>. Assume that the premises fi 1 ; : : : ; fi n logically imply ff in the source domain. Assume also that analogous premises fl 1 ; : : : ; fl n hold in the target domain.
References-found: 13

