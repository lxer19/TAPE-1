URL: ftp://ftp.cs.washington.edu/tr/1994/06/UW-CSE-94-06-03.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Exploiting Shared Memory for Protected Services  
Author: Rene W. Schmidt 
Note: This work was supported in part by the National Science Foundation (Grants No. CDA-9123308, and CCR-9200832), the  
Date: 94-06-03  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  Washington Technology Center, Digital Equipment Cor poration, Boeing Computer Services, and Intel Corporation.  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: [Accetta et al. 86] <author> N. Accetta, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> MACH: A new kernel foundation for UNIX development. </title> <booktitle> In USENIX Summer Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: Porc is designed to support these needs on top of a standard RPC mechanism, i.e., it is built below the application but above the operating system's RPC facility. This approach contrasts with systems ranging from Hydra [Wulf 74], a capability-based system, to Mach <ref> [Accetta et al. 86] </ref>, a micro-kernel operating system, which have built object support into the operating system kernel. The toolkit simplifies the development of RPC clients and servers in the C ++ program 1 Protected objects refer to objects managed by a server. 3 ming language. <p> The interfaces to these classes are fixed, but the contents and implementation are transport dependent. For example, in the Mach based implementation a Channel caches the send-name of a Mach <ref> [Accetta et al. 86] </ref> port to the server. In an LRPC-based implementation [Bershad et al. 90], the Channel would hold the portal ID and a pointer to a memory region (A-stack) which is shared with the server.
Reference: [Allchin & McKendry 83] <author> J. Allchin and M. McKendry. </author> <title> Synchronization and recovery of actions. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 31-44, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Object-based RPC has been used in numerous operating systems and distributed programming systems. Systems such as Hydra [Wulf 74], Eden [Almes et al. 85], Clouds <ref> [Allchin & McKendry 83] </ref>, and Choices [Dave et al. 92] have all built object support into the operating system kernel. Objects are protected from each other with hardware protection boundaries. In Eden and Clouds, objects are represented as separate address spaces making them inappropriate for building applications with fine-grained sharing.
Reference: [Almes et al. 85] <author> G. T. Almes, A. P. Black, E. D. Lazowska, and J. D. Noe. </author> <title> The Eden system: A technical review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-59, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Object-based RPC has been used in numerous operating systems and distributed programming systems. Systems such as Hydra [Wulf 74], Eden <ref> [Almes et al. 85] </ref>, Clouds [Allchin & McKendry 83], and Choices [Dave et al. 92] have all built object support into the operating system kernel. Objects are protected from each other with hardware protection boundaries.
Reference: [Anderson et al. 86] <author> M. Anderson, R. D. Pose, and C. S. Wallace. </author> <title> The password-capability system. </title> <journal> The Computer Journal, </journal> <volume> 29(1) </volume> <pages> 1-8, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: A capability gives the owner the right to bind to the protected object and invoke its methods. Porc uses password capabilities <ref> [Anderson et al. 86, Chase et al. 92c] </ref> to uniquely name protected objects. A password capability is probabilistically rather than absolutely impossible to forge. Each capability has a (64-bit) password associated with it. The run-time system checks the password on each object invocation to authenticate the request.
Reference: [Bershad et al. 90] <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: The interfaces to these classes are fixed, but the contents and implementation are transport dependent. For example, in the Mach based implementation a Channel caches the send-name of a Mach [Accetta et al. 86] port to the server. In an LRPC-based implementation <ref> [Bershad et al. 90] </ref>, the Channel would hold the portal ID and a pointer to a memory region (A-stack) which is shared with the server. <p> Access to protected objects is inherently more expensive than access to a local object, due to the cost of the RPC call to the the server's protection domain. Even on highly optimized RPC protocols such as LRPC <ref> [Bershad et al. 90] </ref> it will be considerably more expensive. The extra overhead for an RPC call consists of marshaling the arguments and return values, two kernel invocations to transfer the marshaled arguments between the domains, and validation of the arguments in the guard.
Reference: [Birrell & Nelson 84] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Client applications thus access the data through a fixed procedural interface defined by the server. Calls to the server domain utilize a protected procedure call mechanism, typically Remote Procedure Calls <ref> [Birrell & Nelson 84] </ref>, to execute code within the server's domain. For example, an operating system's data structures are protected against unau thorized modification by the applications it is running. <p> The code for proxies and guards is ideally generated by a stub generator. Proxies and guards correspond to client stubs and server stubs, respectively, in a standard RPC system <ref> [Birrell & Nelson 84] </ref>. Primitive values such as integers and text strings are marshaled and unmarshaled in the same way as for RPC. However, in addition, the proxy model allows pointers to protected objects to be passed between clients and servers.
Reference: [Carter et al. 91] <author> J. B. Carter, J. K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference: [Chase et al. 92a] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. </author> <title> How to use a 64-bit virtual address space. </title> <type> Technical Report 92-03-02, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> March </month> <year> 1992. </year> <title> Shortened version published as Opal: A Single Address Space System for 64-Bit Architectures, </title> <booktitle> Third IEEE Workshop on Workstation Operating Systems (WWOS-III), </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Client/Server applications that employ these techniques need to coordinate their memory usage, to prevent the server's data area from overlapping with the clients. An implementation of Porc/C ++ has been built for the Opal system <ref> [Chase et al. 92a, Chase et al. 93] </ref>, a single virtual address space operating system. Read-only methods and shared proxies can be implemented very naturally in Opal's single address space, because there is no overloading of virtual addresses. <p> Several experimental operating systems, such as Monads [Rosenberg 92], Mungi [Heiser et al. 93] and Opal <ref> [Chase et al. 92a, Chase et al. 92c] </ref> provide a single shared address space for all applications. Protection and addressing are decoupled in these systems which makes it possible (among other things) for applications to easily coordinate sharing of data at run-time.
Reference: [Chase et al. 92b] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. Opal: </author> <title> A single address space system for 64-bit architectures. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <month> April </month> <year> 1992. </year> <month> 50 </month>
Reference-contexts: The original toolkit was written by Jeff Chase and Mike Feeley. It was conceived as a way to extend Emerald's [Jul et al. 88] uniform object model to a traditional system with protection domains. It was developed as a sideline to the Opal <ref> [Chase et al. 92b] </ref> project, whose primary goal is to make protection easy to use, and to allow protection configuration decisions to be deferred as long as possible, through the use of a single address space architecture. <p> Therefore, all the proxies for the directories can be mapped into the client's domain when the root-directory is initially accessed. Another example where shared proxies are useful is when a new domain is instantiated in Opal <ref> [Chase et al. 92b] </ref>. The Opal server can instantiate proxies for all its system services, simply by attaching a single segment containing all the shared proxies to the new domain. An additional benefit of shared proxies is that pointers to them are almost completely interchangeable with pointers to local objects.
Reference: [Chase et al. 92c] <author> J. S. Chase, H. M. Levy, E. D. Lazowska, and M. Baker-Harvey. </author> <title> Lightweight shared objects in a 64-bit operating system. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1992. </year> <institution> University of Washington CSE Technical Report 92-03-09. </institution>
Reference-contexts: Several experimental operating systems, such as Monads [Rosenberg 92], Mungi [Heiser et al. 93] and Opal <ref> [Chase et al. 92a, Chase et al. 92c] </ref> provide a single shared address space for all applications. Protection and addressing are decoupled in these systems which makes it possible (among other things) for applications to easily coordinate sharing of data at run-time. <p> A capability gives the owner the right to bind to the protected object and invoke its methods. Porc uses password capabilities <ref> [Anderson et al. 86, Chase et al. 92c] </ref> to uniquely name protected objects. A password capability is probabilistically rather than absolutely impossible to forge. Each capability has a (64-bit) password associated with it. The run-time system checks the password on each object invocation to authenticate the request.
Reference: [Chase et al. 93] <author> J. S. Chase, H. M. Levy, M. J. Feeley, and E. D. Lazowska. </author> <title> Sharing and protection in a single address space operating system. </title> <type> Technical Report 93-04-02, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> April </month> <year> 1993. </year> <note> To appear in ACM TOCS. </note>
Reference-contexts: Client/Server applications that employ these techniques need to coordinate their memory usage, to prevent the server's data area from overlapping with the clients. An implementation of Porc/C ++ has been built for the Opal system <ref> [Chase et al. 92a, Chase et al. 93] </ref>, a single virtual address space operating system. Read-only methods and shared proxies can be implemented very naturally in Opal's single address space, because there is no overloading of virtual addresses. <p> The read-only methods return pointers to shared proxies, so the client can modify (or delete) the object that a pointer refers to. Shared proxies are created eagerly. The experiments are run on a dedicated DECstation 5000 running Mach 3.0 and a prototype of the Opal <ref> [Chase et al. 93] </ref> server. The Opal server provides an environment in which all applications run in a single address space on top of the Mach kernel.
Reference: [Dave et al. 92] <author> A. Dave, M. Sefika, and R. H. Campbell. </author> <title> Proxies, application interfaces, </title> <booktitle> and distributed systems. In Proceedings of the Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Object-based RPC has been used in numerous operating systems and distributed programming systems. Systems such as Hydra [Wulf 74], Eden [Almes et al. 85], Clouds [Allchin & McKendry 83], and Choices <ref> [Dave et al. 92] </ref> have all built object support into the operating system kernel. Objects are protected from each other with hardware protection boundaries. In Eden and Clouds, objects are represented as separate address spaces making them inappropriate for building applications with fine-grained sharing.
Reference: [Feeley et al. 93] <author> M. J. Feeley, J. S. Chase, and E. D. Lazowska. </author> <title> User-level threads and interprocess communication. </title> <type> Technical Report 93-02-03, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: A semi-independent thread package <ref> [Feeley et al. 93] </ref> that comes along with the toolkit is modified to support this. In the thread package, a thread's stack is power of two aligned and of fixed size.
Reference: [Heiser et al. 93] <author> G. Heiser, K. Elphinstone, S. Russell, and J. Vochteloo. Mungi: </author> <title> A distributed single address-space operating system. </title> <type> Technical Report SC&E Report 9314, </type> <institution> School of Computer Science and Engineering, The University of New South Wales, </institution> <year> 1993. </year>
Reference-contexts: Choices has an interesting table-driven RPC mechanism, where the RPC stub code is chosen dynamically on each call, which could for example be used to automatically select the use of read-only methods at run-time. Several experimental operating systems, such as Monads [Rosenberg 92], Mungi <ref> [Heiser et al. 93] </ref> and Opal [Chase et al. 92a, Chase et al. 92c] provide a single shared address space for all applications. Protection and addressing are decoupled in these systems which makes it possible (among other things) for applications to easily coordinate sharing of data at run-time.
Reference: [Herlihy 91] <author> M. Herlihy. </author> <title> A methodology for implementing highly concurrent data objects. </title> <type> Technical Report CRL 91/10, </type> <institution> DEC Cambridge Research Laboratory, </institution> <year> 1991. </year>
Reference-contexts: Two ways of solving the synchronization problem are presented in this chapter: the obvious way of acquiring locks using RPC calls to the server and a scheme based on version numbers, a technique borrowed from lock-free synchronization <ref> [Herlihy 91] </ref>. 5.1 Using Locks For certain kinds of servers it might be profitable to arrange access to data in a check-in/check-out manner. A client makes an RPC call to the server (through a proxy) to check-out an object it wants to access.
Reference: [Hoare 78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference: [Jul et al. 88] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Objects are protected from each other with hardware protection boundaries. In Eden and Clouds, objects are represented as separate address spaces making them inappropriate for building applications with fine-grained sharing. Another approach is taken by systems such as Emerald <ref> [Jul et al. 88] </ref> and Pilot [Redell et al. 80]. They provide fine-grained sharing by ensuring protection through the use of a single safe language. Porc provides a combination of the two approaches by relying on hardware protection between applications and language protection within an application. <p> The original toolkit was written by Jeff Chase and Mike Feeley. It was conceived as a way to extend Emerald's <ref> [Jul et al. 88] </ref> uniform object model to a traditional system with protection domains.
Reference: [Levy 84] <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: The goal is to build a uniform object system that uses two referencing forms: virtual addresses and capabilities, each optimized for the particular style of object. Local ob 9 jects are named with virtual addresses, and protected objects are named with capabilities <ref> [Levy 84, Mullender & Tanenbaum 86] </ref>. A capability is an unforgeable reference that a client uses to name an object in another protection domain. Shapiro's proxy model is used to hide the non-uniformity, by encapsulating the capabilities in proxy objects, which in all respects act like the protected object.
Reference: [Mullender & Tanenbaum 86] <author> S. Mullender and A. Tanenbaum. </author> <title> The design of a capability-based operating system. </title> <journal> The Computer Journal, </journal> <volume> 29(4) </volume> <pages> 289-299, </pages> <year> 1986. </year>
Reference-contexts: The goal is to build a uniform object system that uses two referencing forms: virtual addresses and capabilities, each optimized for the particular style of object. Local ob 9 jects are named with virtual addresses, and protected objects are named with capabilities <ref> [Levy 84, Mullender & Tanenbaum 86] </ref>. A capability is an unforgeable reference that a client uses to name an object in another protection domain. Shapiro's proxy model is used to hide the non-uniformity, by encapsulating the capabilities in proxy objects, which in all respects act like the protected object.
Reference: [Redell et al. 80] <author> D. Redell, Y. Dalal, T. Horsley, H. Lauer, W. Lynch, P. McJones, H. Murray, and S. Purcell. </author> <title> Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year> <month> 51 </month>
Reference-contexts: Objects are protected from each other with hardware protection boundaries. In Eden and Clouds, objects are represented as separate address spaces making them inappropriate for building applications with fine-grained sharing. Another approach is taken by systems such as Emerald [Jul et al. 88] and Pilot <ref> [Redell et al. 80] </ref>. They provide fine-grained sharing by ensuring protection through the use of a single safe language. Porc provides a combination of the two approaches by relying on hardware protection between applications and language protection within an application.
Reference: [Rosenberg 92] <author> J. Rosenberg. </author> <title> Architectural and operating system support for orthogonal persistence. </title> <journal> Computing Systems, </journal> <volume> 5(3), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Choices has an interesting table-driven RPC mechanism, where the RPC stub code is chosen dynamically on each call, which could for example be used to automatically select the use of read-only methods at run-time. Several experimental operating systems, such as Monads <ref> [Rosenberg 92] </ref>, Mungi [Heiser et al. 93] and Opal [Chase et al. 92a, Chase et al. 92c] provide a single shared address space for all applications.
Reference: [Shapiro 86] <author> M. Shapiro. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: The toolkit simplifies the development of RPC clients and servers in the C ++ program 1 Protected objects refer to objects managed by a server. 3 ming language. Protected objects are represented by local proxy objects <ref> [Shapiro 86] </ref>, which make the RPC calls to the server. Proxies are heap-allocated and named by vir tual addresses. Similarly on the server side, the details of receiving incoming RPC calls and converting them into ordinary procedure calls to the protected objects are handled by guard objects. <p> None of the techniques described, however, depend on the single address space model, and can possibly be used on any operating system where applications can coordinate sharing of memory in some manner. 6 1.4 Related Work Proxies were defined by Shapiro <ref> [Shapiro 86] </ref> as a structuring mechanism for distributed systems. They are local server representatives that hide the communication boundary from clients. In addition to being a structuring mechanism, Shapiro describes several other benefits, such as access control and caching of server data.
Reference: [Stroustrup 91] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <note> second edition, </note> <year> 1991. </year>
Reference: [Wulf 74] <author> W. A. Wulf. Hydra: </author> <title> The kernel of a multiprocessor operating system. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-345, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: Porc is designed to support these needs on top of a standard RPC mechanism, i.e., it is built below the application but above the operating system's RPC facility. This approach contrasts with systems ranging from Hydra <ref> [Wulf 74] </ref>, a capability-based system, to Mach [Accetta et al. 86], a micro-kernel operating system, which have built object support into the operating system kernel. <p> Object-based RPC has been used in numerous operating systems and distributed programming systems. Systems such as Hydra <ref> [Wulf 74] </ref>, Eden [Almes et al. 85], Clouds [Allchin & McKendry 83], and Choices [Dave et al. 92] have all built object support into the operating system kernel. Objects are protected from each other with hardware protection boundaries.
References-found: 24

