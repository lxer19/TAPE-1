URL: http://www.cs.cornell.edu/Info/People/ulfar/mrst.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/ulfar/mrst.html
Root-URL: http://www.cs.brown.edu/
Title: Efficient Multiway Radix Search Trees  
Author: Ulfar Erlingsson a Mukkai Krishnamoorthy a T. V. Raman b 
Keyword: Key words: Algorithms, Compilers, Switch statements, Code generation, Code optimization.  
Address: Troy, NY 12180  Mountain View, CA 94039  
Affiliation: a Rensselaer Polytechnic Institute,  b Advanced Technology Group, Adobe Systems,  
Abstract: We present a new scheme for building static search trees, using multiway radix search. We apply this method to the problem of code generation for switch statements in imperative languages. For sparse case sets, the method has an advantage over existing methods, empirically requiring fewer than three branches for the average search. We give timing results that show that in practice our method runs faster than other methods on large sparse case sets. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: We use the number of branches as the metric for our time complexity measures. Skewed Binary Tree <ref> [1] </ref>, [10]. This method is essentially a linear search. Therefore it takes O (mn) time. Balanced Binary Tree [10], [11]. The run-time input is compared with one case at a time in such a way that the search tree is balanced. <p> Let the number of leaf nodes with hash tables be r. The worst-case running time occurs when r = m and is O (n log m), since log m is the search time for the tree. The expected case running time is O (n log r). Jump Table Method <ref> [1] </ref>, [10]. This is a direct hash table lookup and has a running time of O (n) in all cases. It requires space linear in the range of input cases and is therefore impractical for sparse sets of input cases.
Reference: [2] <author> L. Atkinson. </author> <title> Optimizing two-state case statements in Pascal. </title> <journal> Software| Practice and Experience, </journal> <volume> 12 </volume> <pages> 571-581, </pages> <year> 1982. </year>
Reference: [3] <author> R. Bernstein. </author> <title> Producing good code for the case statement. </title> <journal> Software|Practice and Experience, </journal> <volume> 15 </volume> <pages> 1021-1024, </pages> <year> 1985. </year>
Reference-contexts: Although the MRST method is appropriate for most searches where a static search tree can be generated, this paper discusses only its application to switch statements. There has been considerable work in the past ([2], <ref> [3] </ref>, [5], [6] and [10]) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in [4] and [11]. A scheme similar to MRST, but restricted to binary radix search trees, appears in [9]. <p> Assembly code generated by the MRST algorithm for the example. running time is O (n log m). Balanced Binary Tree to Hash Tables <ref> [3] </ref>, [4], [5], [6]. This is a balanced binary search to ranges where the case set is dense and then a direct indexing on those ranges. Let the number of leaf nodes with hash tables be r.
Reference: [4] <author> C. Fraser and D. Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1994. </year>
Reference-contexts: There has been considerable work in the past ([2], [3], [5], [6] and [10]) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in <ref> [4] </ref> and [11]. A scheme similar to MRST, but restricted to binary radix search trees, appears in [9]. Preprint submitted to Elsevier Preprint 18 September 1996 Applications for fast sparse switch statements are many and varied. <p> Assembly code generated by the MRST algorithm for the example. running time is O (n log m). Balanced Binary Tree to Hash Tables [3], <ref> [4] </ref>, [5], [6]. This is a balanced binary search to ranges where the case set is dense and then a direct indexing on those ranges. Let the number of leaf nodes with hash tables be r. <p> Our experimental results in the next section confirm this expectation. 4 Empirical Timing Results We integrated MRST into the lcc C compiler <ref> [4] </ref>. The lcc compiler has a built-in implementation of the balanced binary tree to hash table (BBTH) method for switch statements. We performed timing experiments on two representative platforms: the CISC architecture Intel 486 and the recent RISC architecture UltraSPARC.
Reference: [5] <author> J. Hennessy and N. Mendelsohn. </author> <title> Compilation of the Pascal case statement. </title> <journal> Software|Practice and Experience, </journal> <volume> 12 </volume> <pages> 879-882, </pages> <year> 1982. </year>
Reference-contexts: Although the MRST method is appropriate for most searches where a static search tree can be generated, this paper discusses only its application to switch statements. There has been considerable work in the past ([2], [3], <ref> [5] </ref>, [6] and [10]) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in [4] and [11]. A scheme similar to MRST, but restricted to binary radix search trees, appears in [9]. <p> Assembly code generated by the MRST algorithm for the example. running time is O (n log m). Balanced Binary Tree to Hash Tables [3], [4], <ref> [5] </ref>, [6]. This is a balanced binary search to ranges where the case set is dense and then a direct indexing on those ranges. Let the number of leaf nodes with hash tables be r.
Reference: [6] <author> S. Kannan and T. Proebsting. </author> <title> Correction to Producing good code for the case statement. </title> <journal> Software|Practice and Experience, </journal> <volume> 24:233, </volume> <year> 1994. </year>
Reference-contexts: Although the MRST method is appropriate for most searches where a static search tree can be generated, this paper discusses only its application to switch statements. There has been considerable work in the past ([2], [3], [5], <ref> [6] </ref> and [10]) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in [4] and [11]. A scheme similar to MRST, but restricted to binary radix search trees, appears in [9]. <p> Assembly code generated by the MRST algorithm for the example. running time is O (n log m). Balanced Binary Tree to Hash Tables [3], [4], [5], <ref> [6] </ref>. This is a balanced binary search to ranges where the case set is dense and then a direct indexing on those ranges. Let the number of leaf nodes with hash tables be r.
Reference: [7] <author> R. M. Karp and M. O. Rabin. </author> <title> Efficient randomized pattern-matching algorithms. </title> <type> Technical report 31-81, </type> <institution> Aiken Compu. Lab., Harvard University, </institution> <address> Cambridge, MA, </address> <year> 1981. </year>
Reference-contexts: Assume a hash value is calculated for each of the m substrings, using a special hash function. Now the search can be accomplished in a single scan of S by calculating hash values for each set of L adjacent letters in S, as is done in the Karp-Rabin algorithm <ref> [7] </ref>. After each hash value is calculated for L adjacent letters from S, it must be compared against the m pre-computed hash values. This is effectively a sparse switch statement.
Reference: [8] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 2, </volume> <booktitle> Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley, </publisher> <address> 2 edition, </address> <year> 1981. </year>
Reference-contexts: Given a window W of length L, the probability that there are r distinct values val (c i ; W ), where c i is in the set of m input cases and 0 &lt; r &lt; 2 L , is given by the following (see <ref> [8] </ref>, page 62): P (r; m; L) = (2 L r)! 2 mL m 6 Thus, if we sample m elements with replacement from a random source of values in the range [0; 2 L ), P (r; m; L) is the probability that the sample will contain r distinct different
Reference: [9] <author> D. R. Morrison. </author> <title> PATRICIA|Practical algorithm to retrieve information coded in alphanumeric. </title> <journal> Journal of the ACM, </journal> <volume> 15 </volume> <pages> 514-534, </pages> <year> 1968. </year>
Reference-contexts: There has been considerable work in the past ([2], [3], [5], [6] and [10]) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in [4] and [11]. A scheme similar to MRST, but restricted to binary radix search trees, appears in <ref> [9] </ref>. Preprint submitted to Elsevier Preprint 18 September 1996 Applications for fast sparse switch statements are many and varied. Two ex- amples are: Let L be a Common-Lisp-like language with dynamic type dispatch on function arguments.
Reference: [10] <author> A. Sale. </author> <title> The implementation of case statements in Pascal. </title> <journal> Software|Practice and Experience, </journal> <volume> 11, </volume> <year> 1981. </year>
Reference-contexts: Although the MRST method is appropriate for most searches where a static search tree can be generated, this paper discusses only its application to switch statements. There has been considerable work in the past ([2], [3], [5], [6] and <ref> [10] </ref>) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in [4] and [11]. A scheme similar to MRST, but restricted to binary radix search trees, appears in [9]. <p> We use the number of branches as the metric for our time complexity measures. Skewed Binary Tree [1], <ref> [10] </ref>. This method is essentially a linear search. Therefore it takes O (mn) time. Balanced Binary Tree [10], [11]. The run-time input is compared with one case at a time in such a way that the search tree is balanced. <p> We use the number of branches as the metric for our time complexity measures. Skewed Binary Tree [1], <ref> [10] </ref>. This method is essentially a linear search. Therefore it takes O (mn) time. Balanced Binary Tree [10], [11]. The run-time input is compared with one case at a time in such a way that the search tree is balanced. <p> The worst-case running time occurs when r = m and is O (n log m), since log m is the search time for the tree. The expected case running time is O (n log r). Jump Table Method [1], <ref> [10] </ref>. This is a direct hash table lookup and has a running time of O (n) in all cases. It requires space linear in the range of input cases and is therefore impractical for sparse sets of input cases.
Reference: [11] <author> R. M. Stallman. </author> <title> Using and porting GNU CC. </title> <type> Technical report, </type> <institution> Free Software Foundation, </institution> <year> 1992. </year> <month> 9 </month>
Reference-contexts: There has been considerable work in the past ([2], [3], [5], [6] and [10]) on the Pascal case statement and code generation. The generation of code for switch statements is discussed in [4] and <ref> [11] </ref>. A scheme similar to MRST, but restricted to binary radix search trees, appears in [9]. Preprint submitted to Elsevier Preprint 18 September 1996 Applications for fast sparse switch statements are many and varied. <p> We use the number of branches as the metric for our time complexity measures. Skewed Binary Tree [1], [10]. This method is essentially a linear search. Therefore it takes O (mn) time. Balanced Binary Tree [10], <ref> [11] </ref>. The run-time input is compared with one case at a time in such a way that the search tree is balanced.
References-found: 11

