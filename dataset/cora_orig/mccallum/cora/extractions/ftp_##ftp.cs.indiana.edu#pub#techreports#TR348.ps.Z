URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR348.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Phone: 2  
Title: Characterizing the Paralation Model using Dynamic Assignment  
Author: Eric T. Freeman ? and Daniel P. Friedman 
Address: New Haven, Connecticut 06520  Bloomington, Indiana 47405  
Affiliation: 1 Yale University, Department of Computer Science,  Indiana University, Computer Science Department,  
Abstract: Collection-oriented languages provide high-level constructs for describing computations over collections. These languages are becoming increasingly popular with the advent of massively parallel SIMD machines. Even on serial machines, collection-oriented languages are interesting because they allow the user to describe computation in a concise manner. In addition, these languages can easily be compiled on superpipelined, superscalar, and vector machines because they are so rich in simple loops. In this paper we implement Sabot's paralation model [7], a collection-oriented language extension for expressing elementwise computation and explicit communication. We extend the Scheme programming language, a dialect of Lisp with lexical scope and first-class procedures, basing our implementation on Sabot and Blelloch's original code written in Common Lisp. We have taken particular care to remove all unnecessary side-effects. This re-packaging has taken two forms. First, many of the side-effects can be treated as a kind of dynamic assignment. Some others can be removed by coding in a more functional style. The remaining category of side-effects are for site-specific operations. This re-packaging has led to a surprising result: the paralation model can be described with just a single language form and a single primitive.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Guy E. Blelloch: </author> <title> Vector Models for Data-Parallel Computing. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Other languages like Lisp provide this capability at a higher level through mapping. Mapping successively applies a procedure to each item in a collection. Collection-oriented languages provide even higher-level operations that manipulate collections as a whole <ref> [1, 2] </ref>. Typical operations might include adding a constant to an entire collection, reducing a collection to the sum of its elements, or removing all even elements of a collection. Collection-oriented languages are not new, APL provides many high-level operations for manipulating arrays and matrices.
Reference: 2. <author> Guy E. Blelloch and Gary W. Sabot: </author> <title> Compiling Collection-Oriented Languages Onto Massively Parallel Computers. </title> <journal> J. of Par. and Distr. Comp. </journal> <volume> 8, 2, </volume> <pages> 119-134. </pages>
Reference-contexts: Other languages like Lisp provide this capability at a higher level through mapping. Mapping successively applies a procedure to each item in a collection. Collection-oriented languages provide even higher-level operations that manipulate collections as a whole <ref> [1, 2] </ref>. Typical operations might include adding a constant to an entire collection, reducing a collection to the sum of its elements, or removing all even elements of a collection. Collection-oriented languages are not new, APL provides many high-level operations for manipulating arrays and matrices.
Reference: 3. <author> C. J. Date: </author> <title> An Introduction to Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1977. </year>
Reference-contexts: If we 3 This is our characterization of the paralation model. Sabot's model contained three prim itives: elwise, move, and match. let R be an arbitrary paralation then its index field contains the values 0; 1; :::; #R1. This acts much like a primary key in relational databases <ref> [3] </ref>. In the table, Inventory Number is the index field. Each field is a discrete data object, however all fields that belong to a paralation are bound together into a paralation by an association with the same index field.
Reference: 4. <author> R. Kent Dybvig: </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: These extensions are supported through a data type, the field , one special form, elwise, and a communication primitive, create-open-mapping 3 . In this paper we extend the Scheme programming language (see for example <ref> [4] </ref>), basing our implementation on Sabot and Blel-loch's original extensions to Common Lisp. We have chosen Scheme for this task because of its lexical scope, first-class procedures, and language extension facilities. This paper is descriptive in nature. <p> In the second example, quantity is treated elementwise in the computation whereas inventory-number is not. The result is a new field where at each site the field inventory-number has been cons'd onto the value of quantity. 3.1 Implementation The elwise special form is implemented through a syntactic extension facility <ref> [4] </ref>. This facility, extend-syntax, expands input expressions into output expressions based on pattern matching. In this section we first introduce extend-syntax through an implementation of the Scheme form let. We then implement a related form fluid-let that is subsequently modified to implement fluid-let-at-site. <p> Instead it establishes a new value for them. For example, the following expression demonstrates the difference between let and fluid-let. (let ((proc (lambda () (+ a 5)))) (list (fluid-let ((a 7)) (proc)) a (proc))))) ) (12 3 8) We now present the form fluid-let, which uses with <ref> [4] </ref>. (extend-syntax (fluid-let) ((fluid-let ((id val ) : : : ) e1 e2 : : : ) (with (((t : : : ) (map (lambda (x ) (gensym)) '(id : : : )))) (let ((body (lambda () e1 e2 : : : )) (swap (let ((t val ) : : :
Reference: 5. <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes: </author> <title> Essentials of Programming Languages. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: In the event that an error occurs in the evaluation of the second thunk, dynamic-wind guarantees that the third thunk will always be evaluated (in the presence of first-class continuations, dynamic-wind is actually more complicated <ref> [5] </ref>.). The evaluation of fluid-let occurs as follows: first, the temporary variables, t : : : , are assigned to the new values, val : : : Next, we enter the dynamic-wind and it evaluates swap to exchange the values of the temporaries and the ids. Then body is evaluated.
Reference: 6. <author> Daniel W. Hillis, and Guy L. Steele Jr.: </author> <title> Data Parallel Algorithms. </title> <journal> Communications of the ACM 29, </journal> <volume> 12, </volume> <pages> 1170-1183. </pages>
Reference-contexts: As a result a new programming paradigm (data-parallel algorithms) has shown that a large class of problems have inherently parallel solutions and programmers benefit from being able to think about ? Research done while author was at Indiana University. solving problems in a parallel manner <ref> [6] </ref>. It is this facet that interests us|the in-crease in expressibility that occurs when we add collection-oriented extensions to a language. Sabot's paralation model [7] is a high-level, abstract language extension for describing concurrent operations over collections of objects.
Reference: 7. <author> Gary W. Sabot: </author> <title> The Paralation Model: Architecture-Independent Parallel Programming. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: It is this facet that interests us|the in-crease in expressibility that occurs when we add collection-oriented extensions to a language. Sabot's paralation model <ref> [7] </ref> is a high-level, abstract language extension for describing concurrent operations over collections of objects. These extensions are supported through a data type, the field , one special form, elwise, and a communication primitive, create-open-mapping 3 .
Reference: 8. <author> Guy L. Steele Jr.: </author> <title> Common LISP: The Language Second Edition. </title> <publisher> Digital Press, </publisher> <year> 1990. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Our abstract type is implemented through a general record facility similar to defstruct of Common Lisp <ref> [8] </ref>. We represent a field as a record structure containing a vector and a pointer to an index field. (define-record field (vector index )) Here define-record defines a predicate, field?, and three procedures: make-field, field-&gt;vector, and field-&gt;index. <p> These pointers are created by finding the position of each element of source in target using elwise to apply the procedure field-position to every element of source. The procedure field-position is similar to the Common Lisp function position <ref> [8] </ref>. This procedure has two parameters, a value and a field, and returns the integer site of the first occurrence of the value in the field. If the value does not occur in the field, false is returned.
References-found: 8

