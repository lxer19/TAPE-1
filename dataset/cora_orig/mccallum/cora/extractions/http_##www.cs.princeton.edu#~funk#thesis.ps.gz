URL: http://www.cs.princeton.edu/~funk/thesis.ps.gz
Refering-URL: http://www.cs.princeton.edu/~funk/
Root-URL: http://www.cs.princeton.edu
Title: Database and Display Algorithms for Interactive Visualization of Architectural Models  
Author: by Thomas Allen Funkhouser 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Computer Science in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Carlo H. Sequin Chair Professor Lawrence Rowe Professor Jean Pierre Protzen  
Date: 1989  1993  
Address: 1983  Los Angeles)  
Affiliation: B.S. (Stanford University)  M.S. (University of California at  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Akeley, K. </author> <title> Reality Engine Graphics. </title> <note> To appear in Computer Graphics (Proc. SIG-GRAPH '93). </note>
Reference-contexts: In the near future, we hope to use a Silicon Graphics Reality Engine which can render polygons at similar rates, but also with texture mapping and antialiasing <ref> [1] </ref>. These computer systems currently cost between $50K and $100K. 1.3 Problem Statement Large, furnished building models are far too complex to be rendered with realistic-looking images at interactive frame rates on currently available hardware.
Reference: [2] <author> Airey, John M. </author> <title> Increasing Update Rates in the Building Walkthrough System with Automatic Model-Space Subdivision and Potentially Visible Set Calculations. </title> <type> Ph.D. thesis, </type> <institution> UNC Chapel Hill, </institution> <year> 1990. </year>
Reference-contexts: Research on increasing frame rates during interactive visualization of architectural models has been under way for over twenty years [34]. Pioneering work in spatial subdivision and visibility precomputation has been done at the University of North Carolina at Chapel Hill <ref> [2, 3, 11] </ref>. Airey developed algorithms for partitioning architectural models into cells, and precomputing a potentially visible set of polygons (PVS) for each cell.
Reference: [3] <author> Airey, John M., John H. Rohlf, and Frederick P. Brooks, Jr. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <booktitle> ACM SIGGRAPH Special Issue on 1990 Symposium on Interactive 3D Graphics, </booktitle> <volume> 24, 2 (1990), </volume> <pages> 41-50. </pages>
Reference-contexts: Research on increasing frame rates during interactive visualization of architectural models has been under way for over twenty years [34]. Pioneering work in spatial subdivision and visibility precomputation has been done at the University of North Carolina at Chapel Hill <ref> [2, 3, 11] </ref>. Airey developed algorithms for partitioning architectural models into cells, and precomputing a potentially visible set of polygons (PVS) for each cell.
Reference: [4] <author> Amenta, Nina. </author> <title> Finding a Line Traversal of Axial Objects in Three Dimensions. </title> <booktitle> Proc. 3 rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1992, </year> <pages> 66-71. </pages>
Reference-contexts: Hohmeyer and Teller have implemented a procedure to find sightlines through axial portal sequences, or determine that no such sightline exists, 28 in O (n log n) time, where n is the number of portals in the sequence [31]. Amenta has proposed an O (n) solution for this problem <ref> [4] </ref>, although it has not yet been implemented. We construct the cell-to-cell and cell-to-object visibility for the source cell during the depth-first search.
Reference: [5] <author> AutoCAD Reference Manual, </author> <title> Release 10, </title> <publisher> Autodesk Inc., </publisher> <year> 1990. </year>
Reference-contexts: In the case of Soda Hall, floorplans and elevations for the major structure elements of the building (i.e., walls, ceilings, and floors) were received from the architects in AutoCAD DXF format <ref> [5] </ref>. We converted these 2 1 2 D models into a consistent 3D representation in UC Berkeley UNIGRAFIX format. Unfortunately, the raw architectural models were not true three dimensional models they contained nonplanar polygons, coincident coplanar polygons, improper polygon intersections, and inconsistent polygon orientations.
Reference: [6] <author> Batory, D. </author> <title> GENESIS: A Project to Develop an Extensible Database Management System. </title> <booktitle> Proceedings of 1986 International Workshop on Object-Oriented Database Systems. Asilomar, </booktitle> <address> California, </address> <month> September, </month> <year> 1986. </year>
Reference-contexts: High-level database features and policies, such as crash recovery, security, and query execution are left to the application programmer so that no unnecessary overhead is incurred by the database system. In this regard, our database system is similar to Exodus [14] and Genesis <ref> [6] </ref> it is a modular, low-level storage system suitable for use directly by an application program, or by a complete object-oriented 85 database system. 5.1.1 Segments Our database system stores persistent application data in segments, which contain arbitrary groups of bytes that are manipulated by the database system as a unit.
Reference: [7] <author> Baum, Daniel, R., Stephen Mann, Kevin P. Smith, and James M. Winget. </author> <title> Making Radiosity Usable: Automatic Preprocessing and Meshing Techniques for the Generation of Accurate Radiosity. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '91), </booktitle> <volume> 25, </volume> <month> 4 (August </month> <year> 1991), </year> <pages> 51-60. </pages>
Reference-contexts: Conceptually, for every pair of polygons, A and B, a form factor is computed which measures the fraction of the energy leaving polygon A that arrives at polygon B. This approach yields a set of simultaneous equations which are solved to obtain the radiance for each polygon. See <ref> [7, 15, 28, 29, 30, 40] </ref> for more information. The advantage of radiosity methods for interactive visualization is that a global radios-ity solution can be precomputed, i.e. the solution does not depend on a particular observer viewpoint (see Figure 1.7).
Reference: [8] <author> Bechtel, Inc. WALKTHRU: </author> <title> 3D Animation and Visualization System. Promotional literature, </title> <booktitle> 1991. </booktitle> <pages> 147 </pages>
Reference-contexts: However, they do not support interactive visualization or design. Currently available commercial products that do allow interactive, real-time navigation generally support only small buildings models (e.g., less than one hundred thousand polygons), displayed with simple rendering algorithms (e.g., wire-frame or flat shading) <ref> [8, 56] </ref>. These commercial systems generally make little use of sophisticated precomputation, visibility determination, or detail elision, and require that the entire model be resident in memory. Research on increasing frame rates during interactive visualization of architectural models has been under way for over twenty years [34].
Reference: [9] <author> Bentley, J.L. </author> <title> Multidimensional Binary Search Trees Used for Associative Searching. </title> <journal> Communications of the ACM, </journal> <volume> 18 (1975), </volume> <pages> 509-517. </pages>
Reference-contexts: Viewpoint-independent calculations for ray-tracing and radiosity can also be done during the precomputation phase, but they have not yet been implemented. 3.2.1 Spatial Subdivision We partition the model into a spatial subdivision using a variant of the k-D tree data structure <ref> [9] </ref>. Splitting planes are introduced along the major opaque elements in the model (i.e., the walls, floors, and ceilings of the building).
Reference: [10] <author> Blake, Edwin H. </author> <title> A Metric for Computing Adaptive Detail in Animated Scenes using Object-Oriented Programming. Eurographics `87. </title> <editor> G. Marechal (Ed.), </editor> <publisher> Elsivier Science Publishers, B.V. (North-Holland), </publisher> <year> 1987. </year>
Reference-contexts: Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [10, 44, 45, 48, 59] </ref>, or the number of pixels covered by an average polygon [24]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [11] <author> Brooks, Jr., Frederick P. </author> <title> Walkthrough ADynamic Graphics System for Simulating Virtual Buildings. </title> <booktitle> Proceedings of the 1986 Workshop on Interactive 3D Graphics. </booktitle>
Reference-contexts: Research on increasing frame rates during interactive visualization of architectural models has been under way for over twenty years [34]. Pioneering work in spatial subdivision and visibility precomputation has been done at the University of North Carolina at Chapel Hill <ref> [2, 3, 11] </ref>. Airey developed algorithms for partitioning architectural models into cells, and precomputing a potentially visible set of polygons (PVS) for each cell.
Reference: [12] <author> Brown, Thurman A. </author> <title> Interactive Object Displacement in Building Walkthrough Models. </title> <type> Master's Thesis, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1992. </year>
Reference-contexts: Numerous parameters are available for the user to control the size, number, and placement of objects. Alternatively, we use interactive placement programs, such as AutoCAD, ugitools [36] (an interactive UNIGRAFIX tool), or wkedit <ref> [12] </ref> (an interactive walkthrough editor) to generate object instances.
Reference: [13] <author> Butterworth, Paul, Allen Otis, and Jacob Stein. </author> <title> The GemStone Object Management System. </title> <journal> Communications of the ACM, </journal> <volume> 34, </volume> <month> 10 (October, </month> <year> 1991), </year> <pages> 64-77. </pages>
Reference-contexts: This conversion is accomplished via the DFFixupSegmentData callback in which the application calls specified functions for each intra- and inter-segment reference contained in the segment's data. Like a data description language <ref> [19, 13] </ref> or tag table [37], this callback mechanism allows the database system to manipulate data and references in application-defined data types transparently. However, callbacks are more general than these previously described declarative methods because data manipulation is procedural.
Reference: [14] <author> Carey, Michael, J., David J. DeWitt, Joel E. Richardson, and Eugene J. Shekita. </author> <title> Object and File Management in the EXODUS Extensible Database System. </title> <booktitle> Proceedings of the Twelfth International Conference on Very Large Databases, </booktitle> <address> Kyoto, Japan, </address> <month> August, </month> <year> 1986, </year> <pages> 91-100. </pages>
Reference-contexts: High-level database features and policies, such as crash recovery, security, and query execution are left to the application programmer so that no unnecessary overhead is incurred by the database system. In this regard, our database system is similar to Exodus <ref> [14] </ref> and Genesis [6] it is a modular, low-level storage system suitable for use directly by an application program, or by a complete object-oriented 85 database system. 5.1.1 Segments Our database system stores persistent application data in segments, which contain arbitrary groups of bytes that are manipulated by the database system <p> DFReleaseSegment (DF DATABASE *database, DF SEGMENT *segment) Releases a segment's data from memory. The DFReadSegment, DFWriteSegment, and DFReleaseSegment operations control which segments are resident in memory at any given time. Unlike some object-oriented database systems, which at most allow an application to provide hints regarding buffer pool management <ref> [14] </ref>, our database system allows an application to control segment loading and replacement policies explicitly. For example, our building walkthrough application uses these operations to implement a rather complex pre-fetch memory management algorithm (see Section 5.2). <p> Reference counts and dirty bits are maintained by the database system in order to avoid redundant or unnecessary read/write operations. Note that our database system reads and writes data in segment-size blocks, rather than page-size blocks like many object-oriented database management systems <ref> [14, 37, 19] </ref>.
Reference: [15] <author> Cohen, Michael, F., and Donald P. Greenberg. </author> <title> The Hemi-cube: A Radiosity Solution for Complex Environments. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '85), </booktitle> <volume> 19, </volume> <month> 3 (July </month> <year> 1985), </year> <pages> 31-40. </pages>
Reference-contexts: Conceptually, for every pair of polygons, A and B, a form factor is computed which measures the fraction of the energy leaving polygon A that arrives at polygon B. This approach yields a set of simultaneous equations which are solved to obtain the radiance for each polygon. See <ref> [7, 15, 28, 29, 30, 40] </ref> for more information. The advantage of radiosity methods for interactive visualization is that a global radios-ity solution can be precomputed, i.e. the solution does not depend on a particular observer viewpoint (see Figure 1.7).
Reference: [16] <author> Chen, Peter, M., Edward K. Lee, Ann L. Drapeau, Ken Lutz, Ethan L. Miller, Srini-vasan Seshan, Ken Shirriff, David A. Patterson, and Randy H. Katz. </author> <title> Performance and Design Evaluation of the RAID-II Storage Server. </title> <booktitle> International Parallel Processing Symposium Workshop on I/O in Parallel Computer Systems, </booktitle> <month> April, </month> <year> 1993. </year>
Reference-contexts: For instance, our walkthrough system may eventually connect to a RAID storage system that supports very high throughput and long latency read operations for large chunks of data <ref> [16, 17, 35, 42] </ref>. For such storage devices, it may be advantageous to group read operations into large units. Unfortunately, there is no support for reading more than one object description in a single read operation in the current implementation of our system.
Reference: [17] <author> Chervenak, Ann, L., and Randy H. Katz. </author> <title> Perfomance of a Disk Array Prototype. </title> <booktitle> Proc. SIGMETRICS, </booktitle> <month> May, </month> <year> 1991. </year>
Reference-contexts: For instance, our walkthrough system may eventually connect to a RAID storage system that supports very high throughput and long latency read operations for large chunks of data <ref> [16, 17, 35, 42] </ref>. For such storage devices, it may be advantageous to group read operations into large units. Unfortunately, there is no support for reading more than one object description in a single read operation in the current implementation of our system.
Reference: [18] <author> Clark, James H. </author> <title> Hierarchical Geometric Models for Visible Surface Algorithms. </title> <journal> Communications of the ACM, </journal> <volume> 19, </volume> <month> 10 (October </month> <year> 1976), </year> <pages> 547-554. </pages>
Reference-contexts: These programs allow a user to add, delete, copy, or move object instances interactively with real-time visual feedback. 3.1.2 Model Representation The walkthrough display database represents the model as a set of objects, each of which can be described at multiple levels of detail (LODs) <ref> [18] </ref>. <p> Then, abstract representations for higher nodes in the tree can be rendered when the observer is far away and cannot see small details <ref> [18] </ref>. 24 3.2 Precomputation Phase During the precomputation phase, we perform a set of calculations on the building model that do not depend on a specific observer viewpoint, and thus can be done off-line, before a user begins an interactive building walkthrough. <p> This technique was first described by Clark <ref> [18] </ref>, and has been used by numerous commercial visualization systems [48]. If different representations for the same object have similar appearances and are blended smoothly, using transparency blending or three dimensional interpolation, transitions between levels of detail are barely noticeable during visualization.
Reference: [19] <editor> Deux, O., et al. </editor> <title> The O 2 System. </title> <journal> Communications of the ACM, </journal> <volume> 34, </volume> <month> 10 (October, </month> <year> 1991), </year> <pages> 34-48. 148 </pages>
Reference-contexts: This feature is important for several reasons. First, applications can access persistent data stored in the database very efficiently. No copy into an application buffer (e.g., [38]), or indirection via an object identifier (e.g., <ref> [19] </ref>) is required. Second, database queries can be executed directly by the application using functions defined in the native programming language, rather than by the database system using a query language. As a result, greater expressive power is available to the application. <p> This conversion is accomplished via the DFFixupSegmentData callback in which the application calls specified functions for each intra- and inter-segment reference contained in the segment's data. Like a data description language <ref> [19, 13] </ref> or tag table [37], this callback mechanism allows the database system to manipulate data and references in application-defined data types transparently. However, callbacks are more general than these previously described declarative methods because data manipulation is procedural. <p> Reference counts and dirty bits are maintained by the database system in order to avoid redundant or unnecessary read/write operations. Note that our database system reads and writes data in segment-size blocks, rather than page-size blocks like many object-oriented database management systems <ref> [14, 37, 19] </ref>.
Reference: [20] <author> Deyo, R. J., J. A. Briggs, and P. Doenges. </author> <title> Getting Graphics in Gear: Graphics and Dynamics in Driving Simulation. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '88), </booktitle> <volume> 24, </volume> <month> 4 (July </month> <year> 1988), </year> <pages> 317-326. </pages>
Reference-contexts: Numerous, sophisticated commercial vehicle simulators have been built over the last thirty years, including many which contain algorithms for visibility-based culling, detail elision, and real-time management of very large databases <ref> [20, 47, 48, 60] </ref>. However, since most are commercial systems, very little has been published on this vast quantity of work. Although there are many similarities between vehicle simulators and building walk-through systems, there are several important differences.
Reference: [21] <author> Dijksta, </author> <title> E.W. A Note on Two Problems in Connexion with Graphs. Numerische Math-ematik 1, </title> <booktitle> 1959, </booktitle> <pages> 269-271. </pages>
Reference-contexts: In each frame of an interactive walkthrough, we compute a set of range cells, R, that are likely to contain the observer eye position during the next N future frames by performing a shortest path search of the cell adjacency graph. The search, implemented using Dijkstra's method <ref> [21] </ref>, adds cells to the range set in order of minimum number of frames before the observer can enter the cell.
Reference: [22] <author> Foley, J.D., A. van Dam, S. Feiner, and J. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. 2nd ed., </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: A typical sequence of rendering operations is shown in Figure 1.9 <ref> [22] </ref> (assuming radiosity, Gouraud shading, and z-buffer hidden surface removal). This thesis addresses only the first two operations of this sequence: database traversal and trivial accept/reject. We assume that the other five operations are performed by the graphics subsystem, so they are not discussed in this thesis.
Reference: [23] <author> Funkhouser, Thomas A. </author> <title> An Interactive UNIGRAFIX Editor. </title> <type> Unpublished. </type> <month> May, </month> <year> 1991. </year>
Reference-contexts: We are currently working on automatic tools for object abstraction. Until now, we have constructed less detailed representations from highly detailed originals using an interactive UNIGRAFIX editor, called animator <ref> [23, 51] </ref>, which has editing features aimed specifically at reducing the complexity of 3D polyhedral models. A few of these features are: Deleting Polygons: The Delete Polygon command removes a polygon, leaving a hole (see Figure 3.8). Vertices attached to the polygon are not deleted.
Reference: [24] <author> Funkhouser, Thomas A., Carlo H. Sequin, and Seth J. Teller. </author> <title> Management of Large Amounts of Data in Interactive Building Walkthroughs. </title> <booktitle> ACM SIGGRAPH Special Issue on 1992 Symposium on Interactive 3D Graphics, </booktitle> <month> March, </month> <year> 1992, </year> <pages> 11-20. </pages>
Reference-contexts: described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer [10, 44, 45, 48, 59], or the number of pixels covered by an average polygon <ref> [24] </ref>. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [25] <author> Funkhouser, Thomas A., and Carlo H. Sequin. </author> <title> Adaptive Display Algorithm for Interactive Frame Rates During Visualization of Complex Virtual Environments. </title> <note> To appear in Computer Graphics (Proc. SIGGRAPH '93). </note>
Reference: [26] <author> Garey, Michael R. and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Darker shades of gray represent higher values for the Benefit heuristic. Unfortunately, this constrained optimization problem is NP-complete. It is the Continuous Multiple Choice Knapsack Problem <ref> [26, 32] </ref>, a version of the well-known Knapsack Problem in which elements are partitioned into candidate sets, and at most one element from each candidate set may be placed in the knapsack at once. <p> tuple with the 68 best available "bang for the buck." It is easy to show that a simple implementation of this greedy approach runs in O (n log n) time for n potentially visible objects, and produces a solution that is at least half as good as the optimal solution <ref> [26] </ref>.
Reference: [27] <author> Garlick, Benjamin, Daniel R. Baum, and James M. Winget. </author> <title> Interactive Viewing of Large Geometric Databases Using Multiprocessor Graphics Workstations. SIGGRAPH '90 Course Notes (Parallel Algorithms and Architectures for 3D Image Generation). </title>
Reference: [28] <author> Goral, Cindy M., Kenneth E. Torrance, Donald P. Greenberg, and Bennett Bat-taile. </author> <title> Modeling the Interaction of Light Between Diffuse Surfaces. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '84), </booktitle> <volume> 18, </volume> <month> 3 (July </month> <year> 1984), </year> <pages> 213-222. </pages>
Reference-contexts: Conceptually, for every pair of polygons, A and B, a form factor is computed which measures the fraction of the energy leaving polygon A that arrives at polygon B. This approach yields a set of simultaneous equations which are solved to obtain the radiance for each polygon. See <ref> [7, 15, 28, 29, 30, 40] </ref> for more information. The advantage of radiosity methods for interactive visualization is that a global radios-ity solution can be precomputed, i.e. the solution does not depend on a particular observer viewpoint (see Figure 1.7).
Reference: [29] <author> Hanrahan, Pat, and David Salzman. </author> <title> A Rapid Hierarchical Radiosity Algorithm. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '91), </booktitle> <volume> 25, </volume> <month> 4 (August </month> <year> 1991), </year> <pages> 197-206. </pages>
Reference-contexts: Conceptually, for every pair of polygons, A and B, a form factor is computed which measures the fraction of the energy leaving polygon A that arrives at polygon B. This approach yields a set of simultaneous equations which are solved to obtain the radiance for each polygon. See <ref> [7, 15, 28, 29, 30, 40] </ref> for more information. The advantage of radiosity methods for interactive visualization is that a global radios-ity solution can be precomputed, i.e. the solution does not depend on a particular observer viewpoint (see Figure 1.7).
Reference: [30] <author> Heckbert, Paul, S. </author> <title> Simulating Global Illumination Using Adaptive Meshing. </title> <type> Ph.D. thesis, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1991. </year> <note> Also available as Technical Report UCB/CSD 91/636. 149 </note>
Reference-contexts: Conceptually, for every pair of polygons, A and B, a form factor is computed which measures the fraction of the energy leaving polygon A that arrives at polygon B. This approach yields a set of simultaneous equations which are solved to obtain the radiance for each polygon. See <ref> [7, 15, 28, 29, 30, 40] </ref> for more information. The advantage of radiosity methods for interactive visualization is that a global radios-ity solution can be precomputed, i.e. the solution does not depend on a particular observer viewpoint (see Figure 1.7).
Reference: [31] <author> Hohmeyer, Michael E., and Seth J. Teller. </author> <title> Stabbing Isothetic Rectangles and Boxes in O(n lg n) Time. </title> <type> Technical Report UCB/CSD 91/634, </type> <institution> Computer Science Department, U.C. Berkeley, </institution> <year> 1991. </year>
Reference-contexts: Hohmeyer and Teller have implemented a procedure to find sightlines through axial portal sequences, or determine that no such sightline exists, 28 in O (n log n) time, where n is the number of portals in the sequence <ref> [31] </ref>. Amenta has proposed an O (n) solution for this problem [4], although it has not yet been implemented. We construct the cell-to-cell and cell-to-object visibility for the source cell during the depth-first search.
Reference: [32] <author> Ibaraki, T., T. Hasegawa, K. Teranaka, J. Iwase. </author> <title> The Multiple Choice Knapsack Problem. </title> <institution> J. Oper. Res. Soc. </institution> <address> Japan 21, </address> <year> 1978, </year> <pages> 59-94. </pages>
Reference-contexts: Darker shades of gray represent higher values for the Benefit heuristic. Unfortunately, this constrained optimization problem is NP-complete. It is the Continuous Multiple Choice Knapsack Problem <ref> [26, 32] </ref>, a version of the well-known Knapsack Problem in which elements are partitioned into candidate sets, and at most one element from each candidate set may be placed in the knapsack at once.
Reference: [33] <author> Ibarra, O. H. and C. E. Kim. </author> <title> Fast Approximate Algorithms for the Knapsack and Sum of Subset Problems. </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 22, </volume> <year> 1975, </year> <pages> 463-468. </pages>
Reference: [34] <author> Jones, C.B. </author> <title> A New Approach to the `Hidden Line' Problem. </title> <journal> The Computer Journal, </journal> <volume> 14, </volume> <month> 3 (August </month> <year> 1971), </year> <pages> 232-237. </pages>
Reference-contexts: These commercial systems generally make little use of sophisticated precomputation, visibility determination, or detail elision, and require that the entire model be resident in memory. Research on increasing frame rates during interactive visualization of architectural models has been under way for over twenty years <ref> [34] </ref>. Pioneering work in spatial subdivision and visibility precomputation has been done at the University of North Carolina at Chapel Hill [2, 3, 11]. Airey developed algorithms for partitioning architectural models into cells, and precomputing a potentially visible set of polygons (PVS) for each cell.
Reference: [35] <author> Katz, Randy, H., Peter M. Chen, Ann L. Drapeau, Edward K. Lee, Ken Lutz, Ethan L. Miller, Srinivasan Seshan, and David A. Patterson. </author> <title> RAID-II: Design and Implementation of a Large Scale Disk Array Controller. 1993 Symposium on Integrated Systems. </title> <note> Also available as UC Berkeley technical report UCB/CSD 92/705. </note>
Reference-contexts: For instance, our walkthrough system may eventually connect to a RAID storage system that supports very high throughput and long latency read operations for large chunks of data <ref> [16, 17, 35, 42] </ref>. For such storage devices, it may be advantageous to group read operations into large units. Unfortunately, there is no support for reading more than one object description in a single read operation in the current implementation of our system.
Reference: [36] <author> Khorramabadi, Delnaz. </author> <title> A Walk through the Planned CS Building. </title> <type> Master's Thesis, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1991. </year> <note> Also available as UC Berkeley technical report UCB/CSD 91/652. </note>
Reference-contexts: Unfortunately, the raw architectural models were not true three dimensional models they contained nonplanar polygons, coincident coplanar polygons, improper polygon intersections, and inconsistent polygon orientations. We used automated programs to detect and correct many of these anomalies <ref> [36] </ref> and then corrected any remaining modeling errors manually using interactive tools. Furniture, stairs, and other objects that a user would expect to find in a typical building have been modeled in a variety of ways. Stairs, window frames, and doors were created by Khorramabadi using AutoCAD. <p> Numerous parameters are available for the user to control the size, number, and placement of objects. Alternatively, we use interactive placement programs, such as AutoCAD, ugitools <ref> [36] </ref> (an interactive UNIGRAFIX tool), or wkedit [12] (an interactive walkthrough editor) to generate object instances.
Reference: [37] <author> Lamb, Charles, Gordon Landis, Jack Orenstein, and Dan Winreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34, </volume> <month> 10 (October, </month> <year> 1991), </year> <pages> 50-63. </pages>
Reference-contexts: This conversion is accomplished via the DFFixupSegmentData callback in which the application calls specified functions for each intra- and inter-segment reference contained in the segment's data. Like a data description language [19, 13] or tag table <ref> [37] </ref>, this callback mechanism allows the database system to manipulate data and references in application-defined data types transparently. However, callbacks are more general than these previously described declarative methods because data manipulation is procedural. Reference fixup can be conditional, iterative, or even recursive, and depend on values of application-specific data. <p> Reference counts and dirty bits are maintained by the database system in order to avoid redundant or unnecessary read/write operations. Note that our database system reads and writes data in segment-size blocks, rather than page-size blocks like many object-oriented database management systems <ref> [14, 37, 19] </ref>.
Reference: [38] <author> Lohman, Guy, M., Bruce Lindsay, Hamin Pirahesh, and K. Bernhard Schierfer. </author> <title> Ex-tentions to Starburst: Objects, Types, Functions, and Rules. </title> <journal> Communications of the ACM, </journal> <volume> 34, </volume> <month> 10 (October, </month> <year> 1991), </year> <pages> 94-109. </pages>
Reference-contexts: This feature is important for several reasons. First, applications can access persistent data stored in the database very efficiently. No copy into an application buffer (e.g., <ref> [38] </ref>), or indirection via an object identifier (e.g., [19]) is required. Second, database queries can be executed directly by the application using functions defined in the native programming language, rather than by the database system using a query language. As a result, greater expressive power is available to the application.
Reference: [39] <author> Molnar, Steven, Eyles, John, and Poulton, John. PixelFlow: </author> <title> High-Speed Rendering Using Image Composition. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '92), </booktitle> <volume> 26, </volume> <month> 2 (July </month> <year> 1992), </year> <pages> 231-240. </pages>
Reference-contexts: Two approaches for coordinating the efforts of more than one drawing process are: 1) division in object space, and 2) division in screen space. In the case of object space parallelism (e.g., <ref> [39] </ref>), each processor produces a full-screen image of a portion of the scene; in addition to the usual color and pixel coverage information calculated at each pixel, the depth of the closest object (or several objects if rendering of transparent objects is to be implemented) is computed and kept with the
Reference: [40] <author> Nishita, T., and E. Nakamae. </author> <title> Half-Tone Representation of 3D Objects Illuminated by Area Sources or Polyhedron Sources. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '85), </booktitle> <volume> 19, </volume> <month> 3 (July </month> <year> 1985), </year> <pages> 23-30. </pages>
Reference-contexts: Conceptually, for every pair of polygons, A and B, a form factor is computed which measures the fraction of the energy leaving polygon A that arrives at polygon B. This approach yields a set of simultaneous equations which are solved to obtain the radiance for each polygon. See <ref> [7, 15, 28, 29, 30, 40] </ref> for more information. The advantage of radiosity methods for interactive visualization is that a global radios-ity solution can be precomputed, i.e. the solution does not depend on a particular observer viewpoint (see Figure 1.7).
Reference: [41] <author> Oakland, Steven Anders. BUMP, </author> <title> A Motion Description and Animation Package. </title> <type> Technical Report UCB/CSD 87/370, </type> <institution> Computer Science Department, U.C. Berkeley, </institution> <year> 1987. </year> <month> 150 </month>
Reference-contexts: For chair instance #1, the lowest LOD is inherited from the object definition, whereas the medium and high LODs are specified explicitly. own geometries. Objects that move over time are represented by a simple extension to this hierarchy using a technique derived from ugbump <ref> [41] </ref>. The 4x4 transformation of any object instance can be represented by a sequence of strings representing translate, rotate and scale trans 18 formations that depend on a variable, t.
Reference: [42] <author> Patterson, David, A., Garth Gibson, and Randy H. Katz. </author> <title> A Case for Redundant Arrays of Inexpensive Disks (RAID). </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <month> June, </month> <year> 1988, </year> <pages> 109-116. </pages>
Reference-contexts: For instance, our walkthrough system may eventually connect to a RAID storage system that supports very high throughput and long latency read operations for large chunks of data <ref> [16, 17, 35, 42] </ref>. For such storage devices, it may be advantageous to group read operations into large units. Unfortunately, there is no support for reading more than one object description in a single read operation in the current implementation of our system.
Reference: [43] <author> Potmesil, Michael and Hoffert, Eric M. </author> <title> The Pixel Machine: A Parallel Image Computer. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '89), </booktitle> <volume> 23, </volume> <month> 3 (July </month> <year> 1989), </year> <pages> 69-78. </pages>
Reference-contexts: A separate processor, or more generally a hierarchy of processors, gathers pixel data from the scene processors and composites it by choosing the closest object at each pixel. In the case of image space parallelism (e.g., <ref> [43] </ref>), each processor is responsible for rendering only objects which map to a particular area of the screen. In either case, the scene is broken up into disjoint pieces, and separate processors work on separate pieces with little or no communication between them.
Reference: [44] <author> Rossignac, J. and P. Borrel. </author> <title> Multi-resolution 3D approximations for rendering complex scenes. </title> <booktitle> IFIP TC 5.WG 5.10 II Conference on Geometric Modeling in Computer Graphics, </booktitle> <address> Genova, Italy, </address> <year> 1993. </year> <note> Also available as IBM Research Report RC 17697, </note> <institution> Yorktown Heights, </institution> <address> NY 10598. </address>
Reference-contexts: Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [10, 44, 45, 48, 59] </ref>, or the number of pixels covered by an average polygon [24]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [45] <author> Rubin, S. M. </author> <title> The representation and display of scenes with a wide range of detail. </title> <booktitle> Computer Graphics and Image Processing. 19 (1982), </booktitle> <pages> 291-298. </pages>
Reference-contexts: Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [10, 44, 45, 48, 59] </ref>, or the number of pixels covered by an average polygon [24]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [46] <author> Sahni, S. </author> <title> Approximate Algorithms for the 0/1 Knapsack Problem. </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 22, </volume> <year> 1975, </year> <pages> 115-124. </pages>
Reference: [47] <author> Schachter, Bruce J. </author> <title> Computer Image Generation for Flight Simulation. </title> <journal> IEEE Computer Graphics and Applications. </journal> <volume> 1, 5 (1981), </volume> <pages> 29-68. </pages>
Reference-contexts: Numerous, sophisticated commercial vehicle simulators have been built over the last thirty years, including many which contain algorithms for visibility-based culling, detail elision, and real-time management of very large databases <ref> [20, 47, 48, 60] </ref>. However, since most are commercial systems, very little has been published on this vast quantity of work. Although there are many similarities between vehicle simulators and building walk-through systems, there are several important differences. <p> complexity in order to produce uniform, bounded frame rates. 4.2.2 Adaptive Detail Elision In an effort to maintain a specified target frame rate, some commercial flight simulators use an adaptive algorithm that adjusts the size threshold for LOD selection based on feedback regarding the time required to render previous frames <ref> [47] </ref>. If the previous frame took longer than the target frame time, the size threshold for LOD selection is increased so that future frames can be rendered more quickly.
Reference: [48] <author> Schachter, Bruce J. (Ed.). </author> <title> Computer Image Generation. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1983. </year>
Reference-contexts: Numerous, sophisticated commercial vehicle simulators have been built over the last thirty years, including many which contain algorithms for visibility-based culling, detail elision, and real-time management of very large databases <ref> [20, 47, 48, 60] </ref>. However, since most are commercial systems, very little has been published on this vast quantity of work. Although there are many similarities between vehicle simulators and building walk-through systems, there are several important differences. <p> This technique was first described by Clark [18], and has been used by numerous commercial visualization systems <ref> [48] </ref>. If different representations for the same object have similar appearances and are blended smoothly, using transparency blending or three dimensional interpolation, transitions between levels of detail are barely noticeable during visualization. <p> Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [10, 44, 45, 48, 59] </ref>, or the number of pixels covered by an average polygon [24]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [49] <author> Sequin, Carlo H. </author> <title> Introduction to the Berkeley UNIGRAFIX Tools (Version 3.0). </title> <type> Technical Report UCB/CSD 91/606, </type> <institution> Computer Science Department, U.C. Berkeley, </institution> <year> 1991. </year>
Reference-contexts: Currently, we load models into the display database from UC Berkeley UNIGRAFIX format files <ref> [49] </ref>. Models described in other formats (e.g., AutoCAD DXF) are first converted to UNIGRAFIX before being loaded into our display database, as shown in Figure 3.2.
Reference: [50] <author> Silicon Graphics, Inc. </author> <title> Graphics Library Programming Tools and Techniques, Document #007-1489-01, Silicon Graphics, </title> <publisher> Inc., </publisher> <address> Mountain View, CA, </address> <year> 1992. </year>
Reference-contexts: Our model, which is derived from the Graphics Library Programming Tools and Techniques document from Silicon Graphics, Inc. <ref> [50] </ref>, represents the rendering system as a pipeline with the two functional stages shown in 60 * Per Primitive: coordinate transformations, lighting calculations, clipping, etc. * Per Pixel: rasterization, z-buffering, alpha blending, texture mapping, etc.
Reference: [51] <author> Smith, Kevin, P. </author> <title> Interactive Modeling Tool. </title> <type> Unpublished. </type> <month> September, </month> <year> 1990. </year>
Reference-contexts: We are currently working on automatic tools for object abstraction. Until now, we have constructed less detailed representations from highly detailed originals using an interactive UNIGRAFIX editor, called animator <ref> [23, 51] </ref>, which has editing features aimed specifically at reducing the complexity of 3D polyhedral models. A few of these features are: Deleting Polygons: The Delete Polygon command removes a polygon, leaving a hole (see Figure 3.8). Vertices attached to the polygon are not deleted.
Reference: [52] <author> Stonebraker, Michael, and Greg Kemmitz. </author> <title> The POSTGRES Next Generation Database Management System. </title> <journal> Communications of the ACM, </journal> <volume> 34, </volume> <month> 10 (October, </month> <year> 1991), </year> <pages> 78-92. </pages>
Reference: [53] <author> Teller, Seth J., and Carlo H. Sequin. </author> <title> Visibility Preprocessing for Interactive Walk-throughs. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '91), </booktitle> <volume> 25, </volume> <month> 4 (August </month> <year> 1991), </year> <pages> 61-69. </pages>
Reference-contexts: The disadvantage of this approach is that computation is stocastic, and thus can under-estimate true cell visibility and requires a large amount of computation. Improved spatial subdivision and visibility precomputation techniques for building walkthroughs were developed by Teller <ref> [53, 55] </ref> at UC Berkeley. His visibility precom-putation algorithm is deterministic, never under-estimates true cell visibility, and runs efficiently. Teller also developed real-time visibility determination algorithms that compute a set of cells potentially visible from a particular observer viewpoint.
Reference: [54] <author> Teller, Seth J. </author> <title> Computing the Antiumbra Cast by an Area Light Source. </title> <booktitle> Computer Graphics (Proc. SIGGRAPH '92), </booktitle> <volume> 26, </volume> <month> 2 (August </month> <year> 1992), </year> <pages> 139-148. 151 </pages>
Reference-contexts: Teller has implemented such algorithms for models constructed from planar polygons with arbitrary alignment in three dimensions <ref> [54, 55] </ref>. The spatial subdivisions generated using these algorithms tend to require more storage than axial ones, and the visibility algorithms have higher computational complexity.
Reference: [55] <author> Teller, Seth J. </author> <title> Visibility Computations in Densely Occluded Polyhedral Environments. </title> <type> Ph.D. thesis, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1992. </year> <note> Also available as UC Berkeley technical report UCB/CSD-92-708. </note>
Reference-contexts: The disadvantage of this approach is that computation is stocastic, and thus can under-estimate true cell visibility and requires a large amount of computation. Improved spatial subdivision and visibility precomputation techniques for building walkthroughs were developed by Teller <ref> [53, 55] </ref> at UC Berkeley. His visibility precom-putation algorithm is deterministic, never under-estimates true cell visibility, and runs efficiently. Teller also developed real-time visibility determination algorithms that compute a set of cells potentially visible from a particular observer viewpoint. <p> Splitting planes are introduced along the major opaque elements in the model (i.e., the walls, floors, and ceilings of the building). See <ref> [55] </ref> for details. 25 After subdivision, cell portals (i.e., the transparent portions of shared boundaries) are identified and stored with each leaf cell, along with an identifier for the neighboring cell to which the portal leads. <p> Further experimentation is required to determine the time and space trade-offs between different approaches to updating precomputed object visibility information. See <ref> [55] </ref> for a discussion of updating precomputed visibility information as opaque objects contributing to cell boundaries move (i.e., thereby affecting the opacity of cell boundaries and precomputed cell-to-cell visibility information). 3.2.3 Results Mean and maximum precomputation statistics for cells in the spatial subdivision of Soda Hall are shown in Table 3.2. <p> Teller has implemented such algorithms for models constructed from planar polygons with arbitrary alignment in three dimensions <ref> [54, 55] </ref>. The spatial subdivisions generated using these algorithms tend to require more storage than axial ones, and the visibility algorithms have higher computational complexity. <p> determination for a finite, non-zero volume of 95 observer view positions (inside sphere) and view directions (inside range frustum) possible during the upcoming N frames. the user interface prevents traversal through solid walls. space (even an axial box) seems to be too compute intensive to be practical for interactive walkthroughs <ref> [55] </ref>. Fortunately, memory management does not typically require as exact a visibility solution as display management. During display management, the bandwidth of the graphics rendering system is generally the limiting resource. <p> For instance, computing the region of space visible from a 118 box requires execution of an O (n) algorithm for each portal encountered through a sequence of N portals <ref> [55] </ref> (compared to O (1) for each portal encountered during computation of visibility from a single point). Instead, we over-estimate the range-to-object visibility set using the precomputed cell-to-object visibility information of the cells containing some viewpoint in the observer range (i.e., the range cells).
Reference: [56] <author> Virtus Walkthrough. Promotional literature, </author> <year> 1991. </year>
Reference-contexts: However, they do not support interactive visualization or design. Currently available commercial products that do allow interactive, real-time navigation generally support only small buildings models (e.g., less than one hundred thousand polygons), displayed with simple rendering algorithms (e.g., wire-frame or flat shading) <ref> [8, 56] </ref>. These commercial systems generally make little use of sophisticated precomputation, visibility determination, or detail elision, and require that the entire model be resident in memory. Research on increasing frame rates during interactive visualization of architectural models has been under way for over twenty years [34].
Reference: [57] <author> Ward, Greg. Lawrence Berkeley Labatories. </author> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: Stairs, window frames, and doors were created by Khorramabadi using AutoCAD. Models for many types of furniture (e.g., chairs, desks, and coffee cups) were created with interactive modeling programs by Ward <ref> [57] </ref>. Other types of furniture (e.g., bookshelves, plants, door handles, and lights) were created by procedural object generators developed by students at UC Berkeley. Instances of these objects were placed into the building model using both automatic 16 and interactive placement programs.
Reference: [58] <author> Ware, Colin, and Steven Osborne. </author> <title> Exploration and Virtual Camera Control in Virtual Three Dimensional Environments. </title> <booktitle> ACM SIGGRAPH Special Issue on 1990 Symposium on Interactive 3D Graphics, </booktitle> <volume> 24, 2 (1990), </volume> <pages> 171-176. </pages>
Reference-contexts: Thus, realistic-looking images generated using physically-based lighting simulations are required for lighting design verification. Second, mechanical and medical CAD systems generally simulate an observer looking at the model "through a window" from the outside. The Environment in Hand metaphor <ref> [58] </ref> is used to support observer "navigation" by means of translation, scaling and rotation. In contrast, building walkthrough systems simulate an observer moving through the interior of the model. These different metaphors for observer navigation may imply different approaches to observer viewpoint prediction, visibility determination, and detail elision.
Reference: [59] <author> Zyda, Michael J. </author> <title> Course Notes, Book Number 10, </title> <institution> Graphics Video Laboratory, Department of Computer Science, Naval Postgraduate School, Monterey, California, Novem-ber, </institution> <year> 1991. </year>
Reference-contexts: Previously described techniques for choosing a level of detail at which to render each visible object use static heuristics, most often based on a threshold regarding the size or distance of an object to the observer <ref> [10, 44, 45, 48, 59] </ref>, or the number of pixels covered by an average polygon [24]. These simple heuristics can be very effective at improving frame rates in cases where most visible objects are far away from the observer and map to very few pixels on the workstation screen.
Reference: [60] <author> Zyda, Michael J., David R. Pratt, James G. Monahan, and Kalin P. Wilson. NPSNET: </author> <title> Constructing a 3D virtual world. </title> <booktitle> ACM SIGGRAPH Special Issue on 1992 Symposium on Interactive 3D Graphics, </booktitle> <month> March, </month> <year> 1992. </year>
Reference-contexts: Numerous, sophisticated commercial vehicle simulators have been built over the last thirty years, including many which contain algorithms for visibility-based culling, detail elision, and real-time management of very large databases <ref> [20, 47, 48, 60] </ref>. However, since most are commercial systems, very little has been published on this vast quantity of work. Although there are many similarities between vehicle simulators and building walk-through systems, there are several important differences.
References-found: 60

