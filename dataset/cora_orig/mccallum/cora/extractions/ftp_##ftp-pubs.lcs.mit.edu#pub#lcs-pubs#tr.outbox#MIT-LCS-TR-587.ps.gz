URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-587.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr500.html
Root-URL: 
Title: Liveness in Timed and Untimed Systems  
Author: Rainer Gawlick Roberto Segala Jtrgen Stgaard-Andersen Nancy Lynch 
Keyword: Automata, timed automata, I/O automata, liveness, environment-freedom, receptiveness, formal verification, simulation techniques, execution correspondence.  
Address: Denmark, DK-2800 Lyngby, Denmark.  
Affiliation: Department of Computer Science, Technical University of  
Abstract: When proving the correctness of algorithms in distributed systems, one generally considers safety conditions and liveness conditions. The Input/Output (I/O) automaton model and its timed version have been used successfully, but have focused on safety conditions and on a restricted form of liveness called fairness. In this paper we develop a new I/O automaton model, and a new timed I/O automaton model, that permit the verification of general liveness properties on the basis of existing verification techniques. Our models include a notion of environment-freedom which generalizes the idea of receptiveness of other existing formalisms, and enables the use of compositional verification techniques. The presentation includes an embedding of the untimed model into the timed model which preserves all the interesting attributes of the untimed model. Thus, our models constitute a coordinated framework for the description of concurrent and distributed systems satisfying general liveness properties. fl Supported by NSF grant CCR-89-15206, by DARPA contracts N00014-89-J-1988 and N00014-92-J-4033, and by ONR contract N00014-91-J-1046. Also supported in part at the Technical University of Denmark by the Danish Technical Research Council. Appears as Technical Report MIT/LCS/TR-587, Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, MA 02139 and as Technical Report ID-TR: 1993-128, Department of Computer Science, Technical University of Denmark, DK-2800 Lyngby, Denmark. y Laboratory for Computer Science, Massachusetts Institute of Technology, 545 Technology Square, Cam-bridge, MA 02139.
Abstract-found: 1
Intro-found: 1
Reference: [AL91a] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 2(82) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> A refinement mapping is a special case of a forward simulation where the relation is a function. Because of its practical importance (cf. <ref> [AL91a] </ref>) an explicit definition is given. Definition 6.2 (Refinement mapping) Let A and B be automata with the same external actions and with invariants I A and I B , respectively. <p> If b is a backward simulation from A to B with respect to some invariants I A and I B , write A B B (or A iB B when b is image-finite) via b. In [LV93a] abstract notions of history variables [OG76] and prophecy variables <ref> [AL91a] </ref> are given in terms of history relations and prophecy relations. Definition 6.4 (History relation) Let A and B be automata with the same external actions and with invariants I A and I B , respectively. <p> A key aspect of the models is the notion of environment-freedom, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref> is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93, LLS93].
Reference: [AL91b] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 1-27. </pages>
Reference-contexts: Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer <ref> [Fis85, AL91b] </ref> is another instance of a timed implementation for an untimed specification. <p> Environment-freedom also implies feasibility as defined in [LS89]. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in [VL92]. Finally, in contrast to <ref> [AL91b] </ref>, our timed model does not give either the system or the environment control over the passage of time. <p> The presentation of both the untimed and timed models starts with a general automaton model with liveness conditions in the style of <ref> [AL91b] </ref>; then the I/O distinction is introduced together with the environment-freedom property. <p> a direct consequence of Lemmas 4.11, 4.13, and 4.15, and the observation, analogous to the one of the untimed model, that parallel composition, hiding and renaming of timed execution sets preserve timed trace equivalence. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of <ref> [AL91b, MMT91, VL92] </ref>. The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. <p> The formalism that is used in <ref> [AL91b] </ref> is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. A specification S consists of the conjunction of three formulas Init ^ ^ L where Init represents the initial configurations of S, is a safety property, and L is a liveness property. <p> The subformula Init ^ corresponds to our safe timed I/O automata, while the subformula L corresponds to our timed liveness conditions. In <ref> [AL91b] </ref> L can also be satisfied by finite or Zeno executions or by executions that do not satisfy Init ^ . The formula L is a liveness condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in [AL91b]. <p> In <ref> [AL91b] </ref> L can also be satisfied by finite or Zeno executions or by executions that do not satisfy Init ^ . The formula L is a liveness condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in [AL91b]. There is a special formula NZ in [AL91b] that is used to express non-Zenoness, i.e., that time advances forever. Time blocking or Zeno behaviors are undesirable in [AL91b] as well as in our model; however, it is possible for the safety part of a specification to describe systems for which <p> The formula L is a liveness condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in <ref> [AL91b] </ref>. There is a special formula NZ in [AL91b] that is used to express non-Zenoness, i.e., that time advances forever. Time blocking or Zeno behaviors are undesirable in [AL91b] as well as in our model; however, it is possible for the safety part of a specification to describe systems for which time cannot advance past a given upper bound <p> condition for Init ^ based on our definition iff the pair (Init ^ ; L) is machine-closed based on the definition in <ref> [AL91b] </ref>. There is a special formula NZ in [AL91b] that is used to express non-Zenoness, i.e., that time advances forever. Time blocking or Zeno behaviors are undesirable in [AL91b] as well as in our model; however, it is possible for the safety part of a specification to describe systems for which time cannot advance past a given upper bound whenever a particular state is reached. Such a situation is eliminated in [AL91b] by requiring the pair (; NZ ) <p> blocking or Zeno behaviors are undesirable in <ref> [AL91b] </ref> as well as in our model; however, it is possible for the safety part of a specification to describe systems for which time cannot advance past a given upper bound whenever a particular state is reached. Such a situation is eliminated in [AL91b] by requiring the pair (; NZ ) to be machine-closed. <p> A major difference between our notion of environment-freedom and the notion of receptiveness of <ref> [AL91b] </ref> is in the role of time: in our model no one is allowed to have control over time; in [AL91b] either the system or its environment must have control over time. <p> A major difference between our notion of environment-freedom and the notion of receptiveness of <ref> [AL91b] </ref> is in the role of time: in our model no one is allowed to have control over time; in [AL91b] either the system or its environment must have control over time. We believe that it is more reasonable to assume that no one has control over time, and thus consider our model easier to understand. <p> For example, [LLS93] shows how an untimed specification (of the at-most-once message delivery problem) is implemented by a system that assumes upper time bounds on certain process steps and channel delays. Fischer's mutual exclusion algorithm <ref> [Fis85, AL91b] </ref> is another such example. Figure 1 depicts the stepwise development one would use for an implementation proof like the one in [LLS93]. <p> We recognize this objection and regard the generalization of the model as future work. In fact, our model is closer to the classical models of the process algebraic community than the models of <ref> [AL93, AL91b] </ref>, and thus may represent a natural starting point for possible generalizations. Some promising results come from [Seg93], which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing [DH84].
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year> <booktitle> A preliminary version appeared in Proceedings REX Workshop on Stepwise Refinement of Distributed Systems, </booktitle> <pages> pages 1-41, </pages> <address> Mook, The Netherlands, </address> <month> May </month> <year> 1989, </year> <note> LNCS 430, 1990, Springer-Verlag. </note>
Reference-contexts: This motivates a generalization of the I/O automaton model and its timed version to handle general liveness properties in such a way that the simulation based proof method still applies. 1 A simple and natural generalization is motivated by <ref> [AL93] </ref>, which models a machine as a pair (A; L) consisting of an automaton and A and a subset L of its behaviors satisfying the desired liveness property. The implementation notion can then be expressed by live trace inclusion just as fair trace inclusion expresses implementation for I/O automata. <p> The liveness properties of a system, i.e., what must eventually happen, can be expressed by a subset L of the executions of its safe part A, as proposed in <ref> [AL93] </ref>. Thus, informally, a live automaton is a pair (A; L) where A is an automaton and L is a subset of its executions. The executions of L, which satisfy both the safety and liveness requirements of (A; L), are the only ones that can occur in the described system. <p> Our restriction on the pair (A; L) implies that the pair (exec (A); L) is machine-closed as defined in <ref> [AL93] </ref>. <p> Some of the problems arising from the requirement that a live I/O automaton should behave properly independently of the inputs provided by its environment are addressed in <ref> [Dil88, AL93] </ref>. Their solutions lead to the notion of receptiveness . Intuitively a system is receptive if it behaves properly independently of the inputs provided by its environment, or equivalently, if it does not constrain its environment. <p> Then the pair (A 0 ; L 0 ) is environment-free. Function f chooses to perform action o whenever applied to an execution ending in s 0 or s 2 and chooses ? otherwise; function g always moves to the only possible next 12 state. In <ref> [AL93] </ref> the pair (A; L) is said to be realizable and is identified with its realizable part (A 0 ; L 0 ). Realizability can be defined in our model by considering only those outcomes O (g;f) (ff; I) where ff consists of a start state. However, the approach of [AL93] <p> <ref> [AL93] </ref> the pair (A; L) is said to be realizable and is identified with its realizable part (A 0 ; L 0 ). Realizability can be defined in our model by considering only those outcomes O (g;f) (ff; I) where ff consists of a start state. However, the approach of [AL93] implies that state s 4 should never be reached in (A; L), thus adding new safety requirements to A via L. <p> Example 3.29 shows that the simpler definition thus gives the system too much power for parallel composition to be closed. 3.5 Preorder Relations for Live I/O Automata In <ref> [LT87, Dil88, AL93] </ref> the notion of implementation is expressed through some form of trace inclusion. Similar notions of implementation can be defined on live I/O automata. <p> The conformation preorder of [Dil88], which expresses the notion of implementation for complete trace structures, coincides with the live preorder when dealing with failure free complete trace structures. Finally, the notion of implementation of <ref> [AL93] </ref>, which works in a state based model, coincides with the live preorder up to a different notion of traces arising from the state structure of the model. In [AL93], a system M 1 implements a system M 2 iff the set of "traces" of the realizable part of M 1 <p> Finally, the notion of implementation of <ref> [AL93] </ref>, which works in a state based model, coincides with the live preorder up to a different notion of traces arising from the state structure of the model. In [AL93], a system M 1 implements a system M 2 iff the set of "traces" of the realizable part of M 1 is a subset of the set of "traces" of the realizable part of M 2 . <p> Furthermore, if a system M is receptive, then M is equal to its realizable part. Thus, for receptive systems, the implementation notion of <ref> [AL93] </ref> is just the live trace preorder. The reader is referred to Section 3.6 for more details about realizability. It is interesting to note that the live preorder implies the safe preorder whenever the involved automata have finite internal nondeterminism. <p> This in turn causes the substitutivity of the parallel composition operator to fail. There are several ways in which the live preorder can be justified as an adequate notion of implementation for live I/O automata. Since the live preorder captures the implementation 26 notions of <ref> [LT87, Dil88, AL93] </ref> it can rest on the justifications provided for these implementa-tion notions. For example, the fair preorder of [LT87] is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. <p> If the involved systems have finite internal nondeterminism, then the live preorder implies the safe preorder. Thus the live preorder guarantees both safety and liveness properties. 3.6 Comparison with Other Models This section compares our model with the models of <ref> [Dil88, LT87, AL93] </ref> and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> Thus [LT87] can only express some special cases of our general liveness conditions. The model of <ref> [AL93] </ref> is based on unlabeled state transition systems and is suitable for the 27 modeling of shared memory systems. An action in [AL93] is identified with a set of transi-tions, and transitions are partitioned into environment transitions and system transitions. <p> Thus [LT87] can only express some special cases of our general liveness conditions. The model of <ref> [AL93] </ref> is based on unlabeled state transition systems and is suitable for the 27 modeling of shared memory systems. An action in [AL93] is identified with a set of transi-tions, and transitions are partitioned into environment transitions and system transitions. The environment moves by performing an arbitrary finite number of environment transitions and the system responds by performing zero or one system transitions. <p> The environment moves by performing an arbitrary finite number of environment transitions and the system responds by performing zero or one system transitions. Function g is not necessary in a strategy for a system of <ref> [AL93] </ref> since the environment chooses the next shared state in its move and does not modify the internal state. Function f chooses a new transition based on the past history of the system. A fundamental difference between [AL93] and our work is in that we define environment-freedom by requiring the existence <p> Function g is not necessary in a strategy for a system of <ref> [AL93] </ref> since the environment chooses the next shared state in its move and does not modify the internal state. Function f chooses a new transition based on the past history of the system. A fundamental difference between [AL93] and our work is in that we define environment-freedom by requiring the existence of a strategy that can "win the game" after any finite execution ff, whereas [AL93] considers a weaker property, called realizability, where the requirement is the existence of a strategy that can win starting from any start <p> Function f chooses a new transition based on the past history of the system. A fundamental difference between <ref> [AL93] </ref> and our work is in that we define environment-freedom by requiring the existence of a strategy that can "win the game" after any finite execution ff, whereas [AL93] considers a weaker property, called realizability, where the requirement is the existence of a strategy that can win starting from any start state (cf. Example 3.17). The realizable part of a system of [AL93] is the set of behaviors that can be the outcome of some strategy. <p> the existence of a strategy that can "win the game" after any finite execution ff, whereas <ref> [AL93] </ref> considers a weaker property, called realizability, where the requirement is the existence of a strategy that can win starting from any start state (cf. Example 3.17). The realizable part of a system of [AL93] is the set of behaviors that can be the outcome of some strategy. A system is then receptive if it coincides with its realizable part. The notion of receptiveness of [AL93] corresponds to our notion of environment-freedom, as can be derived easily from Proposition 9 of [AL93]. <p> Example 3.17). The realizable part of a system of <ref> [AL93] </ref> is the set of behaviors that can be the outcome of some strategy. A system is then receptive if it coincides with its realizable part. The notion of receptiveness of [AL93] corresponds to our notion of environment-freedom, as can be derived easily from Proposition 9 of [AL93]. Example 3.17 shows a live automaton (A; L), which is not environment-free. <p> a system of <ref> [AL93] </ref> is the set of behaviors that can be the outcome of some strategy. A system is then receptive if it coincides with its realizable part. The notion of receptiveness of [AL93] corresponds to our notion of environment-freedom, as can be derived easily from Proposition 9 of [AL93]. Example 3.17 shows a live automaton (A; L), which is not environment-free. However, (A; L) is realizable, and (A 0 ; L 0 ), which is defined in the same example, is the realizable part of (A; L). In [AL93] systems are compared based on their realizable parts. <p> environment-freedom, as can be derived easily from Proposition 9 of <ref> [AL93] </ref>. Example 3.17 shows a live automaton (A; L), which is not environment-free. However, (A; L) is realizable, and (A 0 ; L 0 ), which is defined in the same example, is the realizable part of (A; L). In [AL93] systems are compared based on their realizable parts. Thus, it is necessary to determine the realizable part of a system before its safety properties can be determined, and for this reason realizable systems are closed under parallel composition in [AL93]. <p> In <ref> [AL93] </ref> systems are compared based on their realizable parts. Thus, it is necessary to determine the realizable part of a system before its safety properties can be determined, and for this reason realizable systems are closed under parallel composition in [AL93]. In other words, L can add new safety properties to A. However, later in [AL93] a notion of machine-realizability is introduced which separates safety and liveness properties and requires receptiveness, or equivalently environment-freedom, just like our live I/O automata. <p> Thus, it is necessary to determine the realizable part of a system before its safety properties can be determined, and for this reason realizable systems are closed under parallel composition in <ref> [AL93] </ref>. In other words, L can add new safety properties to A. However, later in [AL93] a notion of machine-realizability is introduced which separates safety and liveness properties and requires receptiveness, or equivalently environment-freedom, just like our live I/O automata. <p> We recognize this objection and regard the generalization of the model as future work. In fact, our model is closer to the classical models of the process algebraic community than the models of <ref> [AL93, AL91b] </ref>, and thus may represent a natural starting point for possible generalizations. Some promising results come from [Seg93], which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing [DH84].
Reference: [AS85] <author> B. Alpern and F.B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Particularly important are formalisms that can model distributed and concurrent systems and those that can model real time systems, i.e., systems that rely on time constraints in order to guarantee correct behavior. Formalisms should be able to support verification of both safety and liveness properties <ref> [AS85] </ref>. Roughly speaking, a liveness property specifies that certain desirable events will eventually occur, while a safety property specifies that undesirable events will never occur. In this paper, we present a coordinated framework that permits modeling and verification of safety and liveness properties for both timed and untimed systems.
Reference: [Bel76] <author> D. Belsnes. </author> <title> Single message communication. </title> <journal> IEEE Transactions on Communications, </journal> <volume> Com-24(2), </volume> <month> February </month> <year> 1976. </year>
Reference-contexts: Another practical advantage of our proof methodology for the live preorder is that it proves the safe preorder as a side result. The work in [SLL93, LLS93] shows why this can be useful. In [SLL93, LLS93] the five-packet-handshake protocol of <ref> [Bel76] </ref> is shown to guarantee a safety property of "at-most-once message delivery", as well as liveness properties such as "in the absence of crashes, each message will eventually be delivered".
Reference: [BG91] <editor> J.C.M. Baeten and J.F. Groote, editors. </editor> <booktitle> Proceedings CONCUR 91, Amsterdam, volume 527 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Cle92] <editor> W.R. Cleaveland, editor. </editor> <booktitle> Proceedings CONCUR 92, </booktitle> <address> Stony Brook, NY, USA, </address> <booktitle> volume 630 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 97 </month>
Reference: [dBHRR91] <editor> J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Pro--ceedings of the REX Workshop "Real-Time: Theory in Practice", volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [DH84] <author> R. De Nicola and M. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: Some promising results come from [Seg93], which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing <ref> [DH84] </ref>. Another line of research consists of extending the current model to handle systems with probabilistic behaviors. The ultimate goal would be a model where probabilistic behaviors, timing constraints, safety properties, and liveness properties can be integrated together.
Reference: [Dil88] <author> D. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> ACM Distinguished Dissertations. MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The restrictions on L are given by a property called environment-freedom, which captures the intuitive idea that a live (timed) I/O automaton must not constrain its environment. The environment-freedom property is defined, using ideas from <ref> [Dil88] </ref>, by means of a two-person game between a live (timed) I/O automaton and its environment. Specifically, the environment provides arbitrary inputs while the system tries to react so that it behaves according to its liveness condition. <p> Our models generalize several existing models. The fairness condition of I/O automata satisfies the environment-freedom property; thus, live I/O automata are a proper generalization of I/O automata. Environment-freedom also implies feasibility as defined in [LS89]. The failure free complete trace structures of <ref> [Dil88] </ref> are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in [VL92]. Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. <p> Some of the problems arising from the requirement that a live I/O automaton should behave properly independently of the inputs provided by its environment are addressed in <ref> [Dil88, AL93] </ref>. Their solutions lead to the notion of receptiveness . Intuitively a system is receptive if it behaves properly independently of the inputs provided by its environment, or equivalently, if it does not constrain its environment. <p> Example 3.29 shows that the simpler definition thus gives the system too much power for parallel composition to be closed. 3.5 Preorder Relations for Live I/O Automata In <ref> [LT87, Dil88, AL93] </ref> the notion of implementation is expressed through some form of trace inclusion. Similar notions of implementation can be defined on live I/O automata. <p> In particular, the live preorder coincides with the fair preorder if, for each live I/O automaton (A; L), L is chosen to be the set of fair executions of A. The conformation preorder of <ref> [Dil88] </ref>, which expresses the notion of implementation for complete trace structures, coincides with the live preorder when dealing with failure free complete trace structures. <p> This in turn causes the substitutivity of the parallel composition operator to fail. There are several ways in which the live preorder can be justified as an adequate notion of implementation for live I/O automata. Since the live preorder captures the implementation 26 notions of <ref> [LT87, Dil88, AL93] </ref> it can rest on the justifications provided for these implementa-tion notions. For example, the fair preorder of [LT87] is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. <p> If the involved systems have finite internal nondeterminism, then the live preorder implies the safe preorder. Thus the live preorder guarantees both safety and liveness properties. 3.6 Comparison with Other Models This section compares our model with the models of <ref> [Dil88, LT87, AL93] </ref> and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> Thus the live preorder guarantees both safety and liveness properties. 3.6 Comparison with Other Models This section compares our model with the models of [Dil88, LT87, AL93] and the work of [RWZ92]. The model of complete trace structures of <ref> [Dil88] </ref> is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> The model of complete trace structures of <ref> [Dil88] </ref> is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> The model of complete trace structures of <ref> [Dil88] </ref> is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> By ignoring the state structure of a system, the model in <ref> [Dil88] </ref> may erroneously view as receptive a state machine that is not environment-free based on our model since its traces may be receptive. Thus, complete trace structures are not adequate whenever the state structure of a system is important. <p> A substantial verification project using the model appears in [SLL93, LLS93]. In addition to generalizing 96 the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of <ref> [Dil88] </ref> and the strong I/O feasibility notion of [VL92]. People familiar with process algebras might object to our model, arguing that environment-freedom is too restrictive since it rules out several systems that might be of interest at a high level of abstraction.
Reference: [Fis85] <author> M. Fischer. Re: </author> <title> Where are you? E-mail message to Leslie Lamport. Arpanet message number 8506252257.AA07636@YALE-BULLDOG.YALE/ARPA (47 lines), </title> <month> June 25 </month> <year> 1985. </year>
Reference-contexts: Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer <ref> [Fis85, AL91b] </ref> is another instance of a timed implementation for an untimed specification. <p> For example, [LLS93] shows how an untimed specification (of the at-most-once message delivery problem) is implemented by a system that assumes upper time bounds on certain process steps and channel delays. Fischer's mutual exclusion algorithm <ref> [Fis85, AL91b] </ref> is another such example. Figure 1 depicts the stepwise development one would use for an implementation proof like the one in [LLS93].
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: Thus, local (A) = int (A) [ out (A). The interaction between safe I/O automata is specified by the parallel composition operator. We use the synchronization style of <ref> [Hoa85, LT87] </ref>, where automata synchronize on their common actions and evolve independently on the others. We also retain the constraint of [LT87] that each action is under the control of at most one automaton by defining parallel composition only for compatible safe I/O automata.
Reference: [Jon91] <author> B. Jonsson. </author> <title> Simulations between specifications of distributed systems. </title> <booktitle> In Baeten and Groote [BG91], </booktitle> <pages> pages 346-360. </pages>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> A key aspect of the models is the notion of environment-freedom, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref> is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93, LLS93].
Reference: [Kon26] <author> D. Konig. </author> <title> Sur les correspondances multivoques des ensembles. </title> <journal> Fundamenta Math-ematicae, </journal> <volume> 8 </volume> <pages> 114-134, </pages> <year> 1926. </year>
Reference-contexts: G has finitely many roots. 2. Each node of G has finite outdegree. 3. Each node of G is reachable from some root of G. Then there is an infinite path in G starting from some root. Proof. The usual proof of Konig's Lemma <ref> [Kon26] </ref> extends to this case. 3 Untimed Systems The discussion of untimed systems is organized as follows. Section 3.1 defines automata. Section 3.2 introduces live automata without I/O distinction.
Reference: [Lam91] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) <ref> [Lam91] </ref> extended with a new variable now that models time. A specification S consists of the conjunction of three formulas Init ^ ^ L where Init represents the initial configurations of S, is a safety property, and L is a liveness property.
Reference: [LLS93] <author> Butler W. Lampson, Nancy A. Lynch, and Jtrgen .F Stgaard-Andersen. </author> <title> Correctness of at-most-once message delivery protocols. In Formal Description Techniques VI. </title> <publisher> North-Holland Elsevier, </publisher> <year> 1993. </year>
Reference-contexts: Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93, LLS93] </ref>. In particular, [SLL93, LLS93] provide examples where fairness is not adequate as a liveness condition. Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93, LLS93] </ref>. In particular, [SLL93, LLS93] provide examples where fairness is not adequate as a liveness condition. Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93, LLS93] </ref>. In particular, [SLL93, LLS93] provide examples where fairness is not adequate as a liveness condition. Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer [Fis85, AL91b] is another instance of a timed implementation for an untimed specification. <p> The paper shows how such a correspondence can be used to prove live trace inclusion. We believe that our coordinated untimed and timed models comprise a good general framework for verification of concurrent systems. The models have already been used in <ref> [SLL93, LLS93] </ref> which deal with a non-trivial system, a communication protocol used in the Internet, and require all the new expressiveness and simulation tools provided in this paper. After some preliminary definitions, given in Section 2, the paper is divided into four main sections. <p> Thus, one would like to work in the untimed model as much as possible and only switch to the timed model when it is needed. Sometimes, however, an algorithm that uses time implements a specification that does not use time. For example, <ref> [LLS93] </ref> shows how an untimed specification (of the at-most-once message delivery problem) is implemented by a system that assumes upper time bounds on certain process steps and channel delays. Fischer's mutual exclusion algorithm [Fis85, AL91b] is another such example. <p> Fischer's mutual exclusion algorithm [Fis85, AL91b] is another such example. Figure 1 depicts the stepwise development one would use for an implementation proof like the one in <ref> [LLS93] </ref>. <p> Another practical advantage of our proof methodology for the live preorder is that it proves the safe preorder as a side result. The work in <ref> [SLL93, LLS93] </ref> shows why this can be useful. In [SLL93, LLS93] the five-packet-handshake protocol of [Bel76] is shown to guarantee a safety property of "at-most-once message delivery", as well as liveness properties such as "in the absence of crashes, each message will eventually be delivered". <p> Another practical advantage of our proof methodology for the live preorder is that it proves the safe preorder as a side result. The work in <ref> [SLL93, LLS93] </ref> shows why this can be useful. In [SLL93, LLS93] the five-packet-handshake protocol of [Bel76] is shown to guarantee a safety property of "at-most-once message delivery", as well as liveness properties such as "in the absence of crashes, each message will eventually be delivered". <p> Moreover, the simulation method of [AL91a, LV91, LV93a, LV93b, Jon91] is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in <ref> [SLL93, LLS93] </ref>. In addition to generalizing 96 the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [LS89] <author> N.A. Lynch and E.W. Stark. </author> <title> A proof of the kahn principle for Input/Output automata. </title> <journal> Information and Computation, </journal> <volume> 82(1) </volume> <pages> 81-92, </pages> <year> 1989. </year>
Reference-contexts: Our models generalize several existing models. The fairness condition of I/O automata satisfies the environment-freedom property; thus, live I/O automata are a proper generalization of I/O automata. Environment-freedom also implies feasibility as defined in <ref> [LS89] </ref>. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in [VL92]. <p> The simpler definition, which is a natural generalization of the fairness condition of [LT87] and is also discussed in <ref> [LS89] </ref>, states that "a pair (A; L) is environment-free if for each finite execution ff of A and each (finite or infinite) sequence fi of input actions there is an execution fragment ff 0 of A such that ff 0 din (A) = fi and ff a ff 0 2 L."
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of [AL91a, LV91, LV93a, LV93b, Jon91], applied to the Input/Output automaton model of <ref> [LT87] </ref> and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. In order to extend the simulation based proof method to our model, we introduce an execution correspondence theorem which builds on a similar lemma of <ref> [LT87] </ref> by extending the result to some of the simulation relations studied in [LV93a, LV93b]. The execution correspondence theorem says that the existence of a simulation relation between two automata induces a strict 2 correspondence between their behaviors. <p> Section 3.5 defines two preorder relations, the safe preorder and the live preorder, and shows in what sense the live preorder can express a notion of implementation. Section 3.6 compares our model with existing work. 3.1 Automata The following definition of an automaton is given in the style of <ref> [LT87] </ref> and essentially describes a transition system. <p> In a physical system this is ensured by executing the two processes on separate processors or by using a fair scheduler in a multiprogramming environment. The notion of fairness of I/O automata <ref> [LT87] </ref> exactly captures this particular physical assumption. Second, a liveness condition can be used to specify additional properties that a system is required to satisfy. For example, in a mutual exclusion problem we may require a process to eventually exit the critical region whenever it enters it. <p> can express many specific intuitive ideas, for the purpose of this paper a liveness condition simply represents the set of executions that a system can exhibit whenever it is "working properly". 3.3 Safe I/O Automata Our notion of safe I/O automaton is the same as the "unfair" I/O automaton of <ref> [LT87] </ref>, i.e., the automaton obtained by removing the partition of the locally-controlled actions from an I/O automaton of [LT87]. 6 Definition 3.3 (Safe I/O automaton) A safe I/O automaton A is an automaton augmented with an external action signature, esig (A) = (in (A); out (A)), which partitions ext (A) into <p> set of executions that a system can exhibit whenever it is "working properly". 3.3 Safe I/O Automata Our notion of safe I/O automaton is the same as the "unfair" I/O automaton of <ref> [LT87] </ref>, i.e., the automaton obtained by removing the partition of the locally-controlled actions from an I/O automaton of [LT87]. 6 Definition 3.3 (Safe I/O automaton) A safe I/O automaton A is an automaton augmented with an external action signature, esig (A) = (in (A); out (A)), which partitions ext (A) into input and output actions. In each state, each input action must be enabled. <p> Thus, local (A) = int (A) [ out (A). The interaction between safe I/O automata is specified by the parallel composition operator. We use the synchronization style of <ref> [Hoa85, LT87] </ref>, where automata synchronize on their common actions and evolve independently on the others. We also retain the constraint of [LT87] that each action is under the control of at most one automaton by defining parallel composition only for compatible safe I/O automata. <p> Thus, local (A) = int (A) [ out (A). The interaction between safe I/O automata is specified by the parallel composition operator. We use the synchronization style of [Hoa85, LT87], where automata synchronize on their common actions and evolve independently on the others. We also retain the constraint of <ref> [LT87] </ref> that each action is under the control of at most one automaton by defining parallel composition only for compatible safe I/O automata. Compatibility requires that each action be an output action of at most one safe I/O automaton. <p> Then ff 2 exec (A) iff, for each i, ffdA i 2 exec (A i ) and s j1 dA i = s j dA i whenever a j =2 acts (A i ). Proof. The lemma is a direct consequence of Corollary 8 of <ref> [LT87] </ref>. The parallel composition operator could alternatively be defined as a commutative and associative (up to isomorphism) binary operator. Thus, the parallel composition of N I/O automata could be obtained by applying the binary composition operator N 1 times. <p> Parallel composition is typically used to build complex systems based on simpler components. However, some actions are meant to represent internal communications between the subcom-ponents of the complex system. The hiding operator of <ref> [LT87] </ref> changes some external actions into internal actions. Definition 3.6 (Action hiding) Let A be a safe I/O automaton and let fl be a set of actions such that fl local (A). <p> Then exec (A n fl) = exec (A). 8 Proof. The lemma is a direct consequence of Corollary 13 of <ref> [LT87] </ref>. Several processes might be identical except for their actions' names. The processes of a token ring communication network provide a classical example. <p> For each execution ff 2 exec (A), let (ff) be the sequence that results from replacing each occurrence of every action a in ff by (a). Then exec ((A)) = f (ff) j ff 2 exec (A)g. Proof. The lemma is a direct consequence of Lemma 15 of <ref> [LT87] </ref>. 3.4 Live I/O Automata In defining live I/O automata one could follow the approach of Definition 3.2 and define a live I/O automaton to be a pair (A; L) where A is a safe I/O automaton and L is a liveness condition for A. <p> The simpler definition, which is a natural generalization of the fairness condition of <ref> [LT87] </ref> and is also discussed in [LS89], states that "a pair (A; L) is environment-free if for each finite execution ff of A and each (finite or infinite) sequence fi of input actions there is an execution fragment ff 0 of A such that ff 0 din (A) = fi and <p> Example 3.29 shows that the simpler definition thus gives the system too much power for parallel composition to be closed. 3.5 Preorder Relations for Live I/O Automata In <ref> [LT87, Dil88, AL93] </ref> the notion of implementation is expressed through some form of trace inclusion. Similar notions of implementation can be defined on live I/O automata. <p> ; L 2 ) iff traces (A 1 ) traces (A 2 ) Live: (A 1 ; L 1 ) v L (A 2 ; L 2 ) iff traces (L 1 ) traces (L 2 ) The safe preorder is the same as the unfair preorder of I/O automata <ref> [LT87] </ref>, while the live preorder is a generalization of the fair preorder of [LT87]. In particular, the live preorder coincides with the fair preorder if, for each live I/O automaton (A; L), L is chosen to be the set of fair executions of A. <p> Live: (A 1 ; L 1 ) v L (A 2 ; L 2 ) iff traces (L 1 ) traces (L 2 ) The safe preorder is the same as the unfair preorder of I/O automata <ref> [LT87] </ref>, while the live preorder is a generalization of the fair preorder of [LT87]. In particular, the live preorder coincides with the fair preorder if, for each live I/O automaton (A; L), L is chosen to be the set of fair executions of A. <p> The substitutivity results for the safe trace preorder are already proven in <ref> [LT87] </ref>. The substitutivity results for the live trace preorder follow directly from the definitions of the parallel composition, hiding, and renaming operators after observing, as it is proved in Corollaries 8, 13 and Lemma 15 of [LT87], that parallel composition, hiding and renaming of execution sets preserve trace equivalence. <p> The substitutivity results for the safe trace preorder are already proven in <ref> [LT87] </ref>. The substitutivity results for the live trace preorder follow directly from the definitions of the parallel composition, hiding, and renaming operators after observing, as it is proved in Corollaries 8, 13 and Lemma 15 of [LT87], that parallel composition, hiding and renaming of execution sets preserve trace equivalence. The following example shows that the absence of environment-freedom can lead to situations where the substitutivity result of Theorem 3.33 breaks down. <p> This in turn causes the substitutivity of the parallel composition operator to fail. There are several ways in which the live preorder can be justified as an adequate notion of implementation for live I/O automata. Since the live preorder captures the implementation 26 notions of <ref> [LT87, Dil88, AL93] </ref> it can rest on the justifications provided for these implementa-tion notions. For example, the fair preorder of [LT87] is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. <p> Since the live preorder captures the implementation 26 notions of [LT87, Dil88, AL93] it can rest on the justifications provided for these implementa-tion notions. For example, the fair preorder of <ref> [LT87] </ref> is justified by two observations. First, the fact that I/O automata are input-enabled guarantees that a system must respond to any environment. In our model the same property is guaranteed by the concept of environment-freedom. <p> If the involved systems have finite internal nondeterminism, then the live preorder implies the safe preorder. Thus the live preorder guarantees both safety and liveness properties. 3.6 Comparison with Other Models This section compares our model with the models of <ref> [Dil88, LT87, AL93] </ref> and the work of [RWZ92]. The model of complete trace structures of [Dil88] is a special case of our model. <p> Thus, complete trace structures are not adequate whenever the state structure of a system is important. The I/O automaton model of <ref> [LT87] </ref> is also a special case of our model. An I/O automaton M of [LT87] can be represented in our model as the environment-free pair (A; L), where A is the I/O automaton M without the partition of its locally-controlled actions and L is the set of fair executions of M <p> Thus, complete trace structures are not adequate whenever the state structure of a system is important. The I/O automaton model of <ref> [LT87] </ref> is also a special case of our model. An I/O automaton M of [LT87] can be represented in our model as the environment-free pair (A; L), where A is the I/O automaton M without the partition of its locally-controlled actions and L is the set of fair executions of M . <p> Thus <ref> [LT87] </ref> can only express some special cases of our general liveness conditions. The model of [AL93] is based on unlabeled state transition systems and is suitable for the 27 modeling of shared memory systems. <p> Finally, it is easy to show, given our definition of environment-freedom, that the set of live traces of any live I/O automaton is union-game realizable according to [RWZ92], and thus describable by means of a standard I/O automaton of <ref> [LT87] </ref>. However, in general the I/O automaton description would involve a lot of encoding and would be extremely unnatural. 4 Timed Systems The notion of liveness discussed in the previous section is now extended to the timed model. <p> We believe that it is more reasonable to assume that no one has control over time, and thus consider our model easier to understand. The model of [MMT91] is an extension to the timed model of the I/O automaton model of <ref> [LT87] </ref>. The locally-controlled actions of an automaton are partitioned into classes, each one of which is associated with a lower bound (possibly 0 but not 1) and an upper bound (possibly 1 but not 0). <p> Ideas similar to those of the Execution Correspondence Theorem appear in the soundness proofs of the simulations for the safe preorder given in <ref> [LT87, LV93a] </ref>. The contribution of this section is to formally state and prove the Execution Correspondence Theorem for a large class of simulations and to show how it can be used as the basis for proving the live preorder. <p> Then, the only remaining proof obligation is to show that the sampling characterization of the high-level live timed I/O automaton is minimal. In [SLL93] there is an example of the use of Lemma 6.31 7 Concluding Remarks This paper extends I/O automata <ref> [LT87, MMT91] </ref> to handle general liveness properties in both the timed and untimed model, and creates a coordinate framework where timed and untimed systems can be analyzed. <p> Moreover, the simulation method of [AL91a, LV91, LV93a, LV93b, Jon91] is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93, LLS93]. In addition to generalizing 96 the I/O automaton model <ref> [LT87] </ref> and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [LV91] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 397-446. </pages>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Finite trace inclusion follows directly from part 1. Infinite trace inclusion follows from finite trace inclusion, closure under prefix of trace sets, and the fact that trace sets of automata with finite internal nondeterminism are closed under prefix ordering limit <ref> [LV91] </ref>. The proof of Proposition 3.32 supports the requirement of our definition of a liveness condition (Definition 3.2) that every safe execution be extendible to a live execution. <p> This turns out to be inadequate in the timed model as the following example illustrates. The example is a slight modification of an example in <ref> [LV91] </ref>. Example 4.2 Let Idle be a timed automaton that lets time pass except that it performs a visible action a at time 50. <p> This is a standard result that appears in <ref> [LV91] </ref>. 3. Let fl be a finite timed trace of A 1 . By definition of timed trace, there is a timed execution 1 of A 1 such that t-trace ( 1 ) = fl. <p> Then, the execution correspondence theorem for the timed model is proven, and finally the use of the timed simulation techniques to prove the timed safe and live preorders is discussed. 6.2.1 Timed Simulation Proof Techniques The timed simulations presented here are similar to the ones defined in <ref> [LV91] </ref> except for our use of invariants. Recall, that an invariant is any set of states of an automaton that is a superset of the reachable states (reachability coincides with t-reachability). <p> A key aspect of the models is the notion of environment-freedom, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref> is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93, LLS93].
Reference: [LV93a] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part I: </title> <journal> Untimed systems, </journal> <note> 1993. Submitted for publication. </note>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> In order to extend the simulation based proof method to our model, we introduce an execution correspondence theorem which builds on a similar lemma of [LT87] by extending the result to some of the simulation relations studied in <ref> [LV93a, LV93b] </ref>. The execution correspondence theorem says that the existence of a simulation relation between two automata induces a strict 2 correspondence between their behaviors. The paper shows how such a correspondence can be used to prove live trace inclusion. <p> This generalization also appears in <ref> [LV93a] </ref>. A root in a digraph is a node with no incoming edges. Lemma 2.1 (Generalization of Konig's Lemma) Let G be an infinite digraph that satisfies the following properties: 1. G has finitely many roots. 2. Each node of G has finite outdegree. 3. <p> Ideas similar to those of the Execution Correspondence Theorem appear in the soundness proofs of the simulations for the safe preorder given in <ref> [LT87, LV93a] </ref>. The contribution of this section is to formally state and prove the Execution Correspondence Theorem for a large class of simulations and to show how it can be used as the basis for proving the live preorder. <p> Fortunately, since the safety property is independent of the liveness of the channel, safety is still guaranteed, i.e., no message is delivered more than once. 6.1 Untimed Proof Techniques Section 6.1.1 defines a number of simulation relations taken from <ref> [LV93a] </ref>. Section 6.1.2 presents the Execution Correspondence Theorem. Finally, Sections 6.1.3 and 6.1.4 deal with proving the safe and live preorders, respectively. 6.1.1 Simulation Proof Techniques This section presents simulation relations taken from [LV93a]. For the purpose of generality, the definitions are stated in terms of automata. <p> more than once. 6.1 Untimed Proof Techniques Section 6.1.1 defines a number of simulation relations taken from <ref> [LV93a] </ref>. Section 6.1.2 presents the Execution Correspondence Theorem. Finally, Sections 6.1.3 and 6.1.4 deal with proving the safe and live preorders, respectively. 6.1.1 Simulation Proof Techniques This section presents simulation relations taken from [LV93a]. For the purpose of generality, the definitions are stated in terms of automata. All results are also valid for the special case of safe I/O automata. <p> How the sequence of abstract steps is selected depends on what type of simulation is considered. Below forward simulations, refinement mappings, backward simulations, history relations, and prophecy relations are defined. The definitions are similar to the definitions given in <ref> [LV93a] </ref> where combinations of forward and backward simulations are also considered. The 79 reader is referred to [LV93a] for details about, e.g., partial completeness of the simulation techniques. The simulation techniques use invariants (and are thus called weak in [LV93a]) of the implementation and specification automata to restrict the steps which <p> Below forward simulations, refinement mappings, backward simulations, history relations, and prophecy relations are defined. The definitions are similar to the definitions given in <ref> [LV93a] </ref> where combinations of forward and backward simulations are also considered. The 79 reader is referred to [LV93a] for details about, e.g., partial completeness of the simulation techniques. The simulation techniques use invariants (and are thus called weak in [LV93a]) of the implementation and specification automata to restrict the steps which need to be considered. <p> The definitions are similar to the definitions given in <ref> [LV93a] </ref> where combinations of forward and backward simulations are also considered. The 79 reader is referred to [LV93a] for details about, e.g., partial completeness of the simulation techniques. The simulation techniques use invariants (and are thus called weak in [LV93a]) of the implementation and specification automata to restrict the steps which need to be considered. Define an invariant of an automaton to be any set of states of the automaton that is a superset of the reachable states of the automaton. <p> Furthermore, if the backward simulation is image-finite, write A iB B. If b is a backward simulation from A to B with respect to some invariants I A and I B , write A B B (or A iB B when b is image-finite) via b. In <ref> [LV93a] </ref> abstract notions of history variables [OG76] and prophecy variables [AL91a] are given in terms of history relations and prophecy relations. Definition 6.4 (History relation) Let A and B be automata with the same external actions and with invariants I A and I B , respectively. <p> By Definition 6.5 S is an image-finite backward simulation from A to B, so the result follows from case 3 above. 6.1.3 Proving the Safe Preorder This subsection proves the soundness of the simulation proof techniques with respect to the safe preorder. This is a well-known result, see, e.g., <ref> [LV93a] </ref>, however, instead of proving the result directly as in [LV93a], the ECT is used. We start with some preliminary definitions and technical lemmas needed for the proof. <p> This is a well-known result, see, e.g., <ref> [LV93a] </ref>, however, instead of proving the result directly as in [LV93a], the ECT is used. We start with some preliminary definitions and technical lemmas needed for the proof. Define the ith step of ff, for all 0 &lt; i jffj, as step (ff; i) 4 = i1 jffj i = (s i1 ; a i ; s i ). <p> A key aspect of the models is the notion of environment-freedom, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref> is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93, LLS93].
Reference: [LV93b] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part II: </title> <journal> Timing-based systems, </journal> <note> 1993. Submitted for publication. 98 </note>
Reference-contexts: The framework is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref>, applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case [MMT91]. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> In order to extend the simulation based proof method to our model, we introduce an execution correspondence theorem which builds on a similar lemma of [LT87] by extending the result to some of the simulation relations studied in <ref> [LV93a, LV93b] </ref>. The execution correspondence theorem says that the existence of a simulation relation between two automata induces a strict 2 correspondence between their behaviors. The paper shows how such a correspondence can be used to prove live trace inclusion. <p> Since Examples 3.10, 3.17, 3.29, and 3.34 apply equally to the timed model, our discussion focuses on issues specific to the timed model. 28 4.1 Timed Automata The following definition of a timed automaton is the same as the corresponding definition in <ref> [LV93b] </ref> except for the fact that our definition allows multiple internal actions. Also, the notions of timed executions and timed traces are the same as the definitions of [LV93b]. The definitions are repeated here but the reader is referred to [LV93b] for further details. <p> the timed model. 28 4.1 Timed Automata The following definition of a timed automaton is the same as the corresponding definition in <ref> [LV93b] </ref> except for the fact that our definition allows multiple internal actions. Also, the notions of timed executions and timed traces are the same as the definitions of [LV93b]. The definitions are repeated here but the reader is referred to [LV93b] for further details. Times are specified using a dense time domain T. In this work, as in [LV93b], let T be R 0 , the set of non-negative reals. <p> timed automaton is the same as the corresponding definition in <ref> [LV93b] </ref> except for the fact that our definition allows multiple internal actions. Also, the notions of timed executions and timed traces are the same as the definitions of [LV93b]. The definitions are repeated here but the reader is referred to [LV93b] for further details. Times are specified using a dense time domain T. In this work, as in [LV93b], let T be R 0 , the set of non-negative reals. <p> Also, the notions of timed executions and timed traces are the same as the definitions of <ref> [LV93b] </ref>. The definitions are repeated here but the reader is referred to [LV93b] for further details. Times are specified using a dense time domain T. In this work, as in [LV93b], let T be R 0 , the set of non-negative reals. Definition 4.1 (Timed automaton) A timed automaton A is an automaton whose set of external actions contains a special time-passage action -. <p> Finally, Axiom S5 says that if time can pass from time t to time t 0 , then it is possible to associate states with all times in the interval [t; t 0 ] in a consistent way. In <ref> [LV93b] </ref> the last axiom is explained further and compared to the weaker axiom that says the following: if time can pass in one step, then it can pass in two steps with the time of the intermediate state being any time in the interval. <p> Relationships Between Timed and Untimed Execution Fragments There is a close relationship between timed execution fragments and ordinary execution fragments of a timed automaton. This leads to an alternative, but equivalent, definition of timed traces. All definitions and lemmas are taken from <ref> [LV93b] </ref>. Sampling Roughly speaking, an (ordinary) execution fragment can be regarded as "sampling" the state information in a timed execution fragment at a countable number of points in time. <p> A key aspect of the models is the notion of environment-freedom, which expresses the fact that a live (timed) I/O automaton does not constrain its environment. Moreover, the simulation method of <ref> [AL91a, LV91, LV93a, LV93b, Jon91] </ref> is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in [SLL93, LLS93].
Reference: [Lyn93] <author> N.A. Lynch. </author> <title> Simulation techniques for proving properties of real-time systems. </title> <booktitle> In Proceedings of the REX Workshop "A Decade of Concurrency", Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Thus, each of the conditions can be considered separately. 89 The reader is referred to <ref> [SLL93, Lyn93] </ref> for extensive applications of the proof techniques. 6.2 Timed Proof Techniques Since liveness conditions in the timed model are expressed in terms of timed executions, the obvious generalization of the approach taken in the untimed model would be to develop simulation techniques that give a correspondence between the timed
Reference: [MMP91] <author> O. Maler, Z. Manna, and A. Pnueli. </author> <title> From timed to hybrid systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 447-484. </pages>
Reference-contexts: Also, the intuition about the execution of a timed system is that visible actions occur at points in time, and that time passes "continuously" between these points. These observations lead to the definition of a timed execution. The definition is close to the notion of hybrid computation of <ref> [MMP91] </ref> where continuous changes and discrete events alternate during the execution of a system.
Reference: [MMT91] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <booktitle> In Baeten and Groote [BG91], </booktitle> <pages> pages 408-423. </pages>
Reference-contexts: A successful technique for the verification of safety properties and some special liveness properties is based on the simulation method of [AL91a, LV91, LV93a, LV93b, Jon91], applied to the Input/Output automaton model of [LT87] and to its generalization to the timed case <ref> [MMT91] </ref>. I/O automata are state machines with a labeled transition relation where the labels, also called actions , model communication. <p> Environment-freedom also implies feasibility as defined in [LS89]. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes <ref> [MMT91] </ref> and the notion of strong I/O feasibility introduced in [VL92]. Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. <p> a direct consequence of Lemmas 4.11, 4.13, and 4.15, and the observation, analogous to the one of the untimed model, that parallel composition, hiding and renaming of timed execution sets preserve timed trace equivalence. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of <ref> [AL91b, MMT91, VL92] </ref>. The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. <p> We believe that it is more reasonable to assume that no one has control over time, and thus consider our model easier to understand. The model of <ref> [MMT91] </ref> is an extension to the timed model of the I/O automaton model of [LT87]. The locally-controlled actions of an automaton are partitioned into classes, each one of which is associated with a lower bound (possibly 0 but not 1) and an upper bound (possibly 1 but not 0). <p> An automaton M of <ref> [MMT91] </ref> can be represented in our model as a pair (A; L) where A is a safe timed I/O automaton with a transition relation that satisfies all the timing constraints of M , and L is the set of all admissible executions of A. <p> It is easy to check that (A; L) is environment-free and that admissible timed trace inclusion in <ref> [MMT91] </ref> coincides with live 62 trace inclusion in our model. However, there are liveness conditions that can be represented in our model but cannot be represented naturally in the model of [MMT91]. <p> It is easy to check that (A; L) is environment-free and that admissible timed trace inclusion in <ref> [MMT91] </ref> coincides with live 62 trace inclusion in our model. However, there are liveness conditions that can be represented in our model but cannot be represented naturally in the model of [MMT91]. The work in [VL92] does not deal with general liveness properties, and argues that finite and admissible timed traces inclusion is generally sufficient to express a useful notion of implementation whenever time is involved. <p> Then, the only remaining proof obligation is to show that the sampling characterization of the high-level live timed I/O automaton is minimal. In [SLL93] there is an example of the use of Lemma 6.31 7 Concluding Remarks This paper extends I/O automata <ref> [LT87, MMT91] </ref> to handle general liveness properties in both the timed and untimed model, and creates a coordinate framework where timed and untimed systems can be analyzed. <p> A substantial verification project using the model appears in [SLL93, LLS93]. In addition to generalizing 96 the I/O automaton model [LT87] and its timed version <ref> [MMT91] </ref>, our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [NS92] <author> X. Nicollin and J. Sifakis. </author> <title> An overview and synthesis on timed process algebras. </title> <editor> In K.G. Larsen and A. Skou, editors, </editor> <booktitle> Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <address> Aalborg, Denmark, </address> <month> July </month> <year> 1991, </year> <booktitle> volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 376-398. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The close relation between the environment-freedom property in the untimed and the timed model allows the models to be tied together, thus permitting the verification of timed implementations of untimed specifications. Specifically, the paper presents a patient operator <ref> [NS92, VL92] </ref> that converts (untimed) live I/O automata into live timed I/O automata without timing constraints. The patient operator preserves the environment-freedom property and the live trace preorder relation of the untimed model. <p> Our approach to this issue is to convert the untimed systems in the stepwise development to timed systems by applying a patient operator that adds arbitrary time-passage steps. The patient operator we use is similar to the one of <ref> [NS92, VL92] </ref>. To complement the patient operator, this section proves the Embedding Theorem which states that a concrete level implements an abstract level in the untimed model if and only if the patient version of the concrete level implements the patient version of the abstract level in the timed model.
Reference: [OG76] <author> S. Owicki and D. Gries. </author> <title> An axiomatic technique for parallel programs i. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: If b is a backward simulation from A to B with respect to some invariants I A and I B , write A B B (or A iB B when b is image-finite) via b. In [LV93a] abstract notions of history variables <ref> [OG76] </ref> and prophecy variables [AL91a] are given in terms of history relations and prophecy relations. Definition 6.4 (History relation) Let A and B be automata with the same external actions and with invariants I A and I B , respectively.
Reference: [RWZ92] <author> N. Reingold, D.W. Wang, and L.D. Zuck. </author> <title> Games I/O automata play. </title> <booktitle> In Cleave-land [Cle92], </booktitle> <pages> pages 325-339. </pages>
Reference-contexts: If the involved systems have finite internal nondeterminism, then the live preorder implies the safe preorder. Thus the live preorder guarantees both safety and liveness properties. 3.6 Comparison with Other Models This section compares our model with the models of [Dil88, LT87, AL93] and the work of <ref> [RWZ92] </ref>. The model of complete trace structures of [Dil88] is a special case of our model. Specifically, the model of [Dil88] does not include a state structure, so that the safe part of a live automaton in [Dil88] is given by a set of traces. <p> Finally, it is easy to show, given our definition of environment-freedom, that the set of live traces of any live I/O automaton is union-game realizable according to <ref> [RWZ92] </ref>, and thus describable by means of a standard I/O automaton of [LT87]. However, in general the I/O automaton description would involve a lot of encoding and would be extremely unnatural. 4 Timed Systems The notion of liveness discussed in the previous section is now extended to the timed model.
Reference: [Seg93] <author> R. Segala. </author> <title> Quiescence, fairness, testing and the notion of implementation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In fact, our model is closer to the classical models of the process algebraic community than the models of [AL93, AL91b], and thus may represent a natural starting point for possible generalizations. Some promising results come from <ref> [Seg93] </ref>, which shows that there is a strong connection between the trace semantics of I/O automata and the must preorder of the theory of testing [DH84]. Another line of research consists of extending the current model to handle systems with probabilistic behaviors.
Reference: [SLL93] <author> J.F. Stgaard-Andersen, N.A. Lynch, and B.W. Lampson. </author> <title> Correctness of communication protocols. a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93, LLS93] </ref>. In particular, [SLL93, LLS93] provide examples where fairness is not adequate as a liveness condition. Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93, LLS93] </ref>. In particular, [SLL93, LLS93] provide examples where fairness is not adequate as a liveness condition. Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. <p> Compositionality is needed for modular design techniques. Despite its success, the I/O automaton model is not general enough to handle some recent verification work in <ref> [SLL93, LLS93] </ref>. In particular, [SLL93, LLS93] provide examples where fairness is not adequate as a liveness condition. Moreover, the work in [SLL93, LLS93] has shown the need for a connection between timed and untimed models to prove that an implementation that uses timing constraints correctly implements an untimed specification. The mutual exclusion algorithm of Fischer [Fis85, AL91b] is another instance of a timed implementation for an untimed specification. <p> The paper shows how such a correspondence can be used to prove live trace inclusion. We believe that our coordinated untimed and timed models comprise a good general framework for verification of concurrent systems. The models have already been used in <ref> [SLL93, LLS93] </ref> which deal with a non-trivial system, a communication protocol used in the Internet, and require all the new expressiveness and simulation tools provided in this paper. After some preliminary definitions, given in Section 2, the paper is divided into four main sections. <p> The work in [VL92] does not deal with general liveness properties, and argues that finite and admissible timed traces inclusion is generally sufficient to express a useful notion of implementation whenever time is involved. The work in <ref> [SLL93] </ref>, however, has shown that liveness is useful even in a timed model. In general, the automata of [VL92] are not receptive, however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. <p> Another practical advantage of our proof methodology for the live preorder is that it proves the safe preorder as a side result. The work in <ref> [SLL93, LLS93] </ref> shows why this can be useful. In [SLL93, LLS93] the five-packet-handshake protocol of [Bel76] is shown to guarantee a safety property of "at-most-once message delivery", as well as liveness properties such as "in the absence of crashes, each message will eventually be delivered". <p> Another practical advantage of our proof methodology for the live preorder is that it proves the safe preorder as a side result. The work in <ref> [SLL93, LLS93] </ref> shows why this can be useful. In [SLL93, LLS93] the five-packet-handshake protocol of [Bel76] is shown to guarantee a safety property of "at-most-once message delivery", as well as liveness properties such as "in the absence of crashes, each message will eventually be delivered". <p> Thus, each of the conditions can be considered separately. 89 The reader is referred to <ref> [SLL93, Lyn93] </ref> for extensive applications of the proof techniques. 6.2 Timed Proof Techniques Since liveness conditions in the timed model are expressed in terms of timed executions, the obvious generalization of the approach taken in the untimed model would be to develop simulation techniques that give a correspondence between the timed <p> In this case L 0 is, by definition, a sampling characterization of L. Then, the only remaining proof obligation is to show that the sampling characterization of the high-level live timed I/O automaton is minimal. In <ref> [SLL93] </ref> there is an example of the use of Lemma 6.31 7 Concluding Remarks This paper extends I/O automata [LT87, MMT91] to handle general liveness properties in both the timed and untimed model, and creates a coordinate framework where timed and untimed systems can be analyzed. <p> Moreover, the simulation method of [AL91a, LV91, LV93a, LV93b, Jon91] is extended to our model, making the results of this paper immediately applicable in practice. A substantial verification project using the model appears in <ref> [SLL93, LLS93] </ref>. In addition to generalizing 96 the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of [VL92].
Reference: [VL92] <author> F.W. Vaandrager and N.A. Lynch. </author> <title> Action transducers and timed automata. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 436-455. 99 </pages>
Reference-contexts: The close relation between the environment-freedom property in the untimed and the timed model allows the models to be tied together, thus permitting the verification of timed implementations of untimed specifications. Specifically, the paper presents a patient operator <ref> [NS92, VL92] </ref> that converts (untimed) live I/O automata into live timed I/O automata without timing constraints. The patient operator preserves the environment-freedom property and the live trace preorder relation of the untimed model. <p> Environment-freedom also implies feasibility as defined in [LS89]. The failure free complete trace structures of [Dil88] are also properly generalized by our model. In the timed case, our model generalizes [MMT91] and the notion of strong I/O feasibility introduced in <ref> [VL92] </ref>. Finally, in contrast to [AL91b], our timed model does not give either the system or the environment control over the passage of time. <p> iff (A 1 ; L 1 ) v fl St (A 2 ; L 2 ): Live: (A 1 ; L 1 ) v Lt (A 2 ; L 2 ) iff t-traces (L 1 ) t-traces (L 2 ): The safe-non-Zeno preorder is the relation that is used in <ref> [VL92] </ref>. This preorder is used in [VL92] instead of the more natural safe-admissible preorder since finite timed traces are need for substitutivity of a sequential composition operator. <p> ) v fl St (A 2 ; L 2 ): Live: (A 1 ; L 1 ) v Lt (A 2 ; L 2 ) iff t-traces (L 1 ) t-traces (L 2 ): The safe-non-Zeno preorder is the relation that is used in <ref> [VL92] </ref>. This preorder is used in [VL92] instead of the more natural safe-admissible preorder since finite timed traces are need for substitutivity of a sequential composition operator. It is interesting to note that the live preorder implies the safe preorder whenever the involved safe timed I/O automata have timed finite internal nondeterminism. <p> a direct consequence of Lemmas 4.11, 4.13, and 4.15, and the observation, analogous to the one of the untimed model, that parallel composition, hiding and renaming of timed execution sets preserve timed trace equivalence. 4.6 Comparison with Other Timed Models This section compares our timed model with the work of <ref> [AL91b, MMT91, VL92] </ref>. The formalism that is used in [AL91b] is the Temporal Logic of Actions (TLA) [Lam91] extended with a new variable now that models time. <p> However, there are liveness conditions that can be represented in our model but cannot be represented naturally in the model of [MMT91]. The work in <ref> [VL92] </ref> does not deal with general liveness properties, and argues that finite and admissible timed traces inclusion is generally sufficient to express a useful notion of implementation whenever time is involved. The work in [SLL93], however, has shown that liveness is useful even in a timed model. <p> The work in [SLL93], however, has shown that liveness is useful even in a timed model. In general, the automata of <ref> [VL92] </ref> are not receptive, however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of [VL92] and our notion <p> The work in [SLL93], however, has shown that liveness is useful even in a timed model. In general, the automata of <ref> [VL92] </ref> are not receptive, however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of [VL92] and our notion of environment-freedom. <p> the automata of <ref> [VL92] </ref> are not receptive, however, in order to avoid trivial implementations, [VL92] assumes some form of I/O distinction and some form of receptiveness at the lower level of implementation. There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of [VL92] and our notion of environment-freedom. It is possible to represent each timed I/O automaton A of [VL92] with the pair (A; L) where L is the set of admissible executions of A. The notion of I/O feasibility of [VL92], which requires each finite timed execution of A to be extendible <p> There is a very close connection between the technical definitions of I/O feasibility and strong I/O feasibility of <ref> [VL92] </ref> and our notion of environment-freedom. It is possible to represent each timed I/O automaton A of [VL92] with the pair (A; L) where L is the set of admissible executions of A. The notion of I/O feasibility of [VL92], which requires each finite timed execution of A to be extendible to an admissible timed execution of A using locally-controlled actions only, is stronger than requiring that L <p> the technical definitions of I/O feasibility and strong I/O feasibility of <ref> [VL92] </ref> and our notion of environment-freedom. It is possible to represent each timed I/O automaton A of [VL92] with the pair (A; L) where L is the set of admissible executions of A. The notion of I/O feasibility of [VL92], which requires each finite timed execution of A to be extendible to an admissible timed execution of A using locally-controlled actions only, is stronger than requiring that L is a liveness condition for A and weaker than requiring that (A; L) is a live timed I/O automaton. <p> In order to have closure under parallel composition, <ref> [VL92] </ref> introduces a stronger requirement on I/O automata called strong I/O feasibility. Strong I/O feasibility adds to I/O feasibility the requirement that the safe part of an I/O automaton A does not exhibit any system-Zeno execution. <p> Our approach to this issue is to convert the untimed systems in the stepwise development to timed systems by applying a patient operator that adds arbitrary time-passage steps. The patient operator we use is similar to the one of <ref> [NS92, VL92] </ref>. To complement the patient operator, this section proves the Embedding Theorem which states that a concrete level implements an abstract level in the untimed model if and only if the patient version of the concrete level implements the patient version of the abstract level in the timed model. <p> A substantial verification project using the model appears in [SLL93, LLS93]. In addition to generalizing 96 the I/O automaton model [LT87] and its timed version [MMT91], our model generalizes the failure free complete trace structures of [Dil88] and the strong I/O feasibility notion of <ref> [VL92] </ref>. People familiar with process algebras might object to our model, arguing that environment-freedom is too restrictive since it rules out several systems that might be of interest at a high level of abstraction. We recognize this objection and regard the generalization of the model as future work.
References-found: 30

