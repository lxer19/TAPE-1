URL: http://www.acm.org/jacm/papers/2095.ps
Refering-URL: http://www.acm.org/jacm/Upcoming.html
Root-URL: 
Title: OBJECT IDENTITY AS A QUERY LANGUAGE PRIMITIVE  
Author: Serge Abiteboul I.N.R.I.A.-Rocquencourt Paris C. Kanellakis 
Date: December 20, 1996  
Affiliation: Brown University  
Abstract: We demonstrate the power of object identities (oid's) as a database query language primitive. We develop an object-based data model, whose structural part generalizes most of the known complex-object data models: cyclicity is allowed in both its schemas and instances. Our main contribution is the operational part of the data model, the query language IQL, which uses oid's for three critical purposes: (1) to represent data-structures with sharing and cycles, (2) to manipulate sets and (3) to express any computable database query. IQL can be type checked, can be evaluated bottom-up and naturally generalizes most popular rule-based languages. The model can also be extended to incorporate type inheritance, without changes to IQL. Finally, we investigate an analogous value-based data model, whose structural part is founded on regular infinite trees and whose operational part is IQL.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> In Memoriam Paris C. </editor> <title> Kanellakis. </title> <journal> ACM Computing Surveys. pp. </journal> <volume> 5-15. Vol. 28 (1). </volume> <month> March </month> <year> 1996. </year>
Reference-contexts: Kanellakis died tragically in an airplane crash in Columbia on December 20th, 1995. A technical obituary can be found in <ref> [1] </ref>. 1 from the relational model, object-oriented database systems [17] that integrate the relational and object technology have been commercialized, e.g., O 2 or Object-Store. Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems.
Reference: [2] <author> S. Abiteboul, </author> <title> Querying semistructured data, </title> <booktitle> Proceedings of the International Conference on Database Theory, Delphi, </booktitle> <address> Greece, </address> <year> 1997. </year> <type> invited paper. </type>
Reference-contexts: A number of languages have been proposed, e.g., [12, 20, 34, 65, 59, 64]. An important difference with the present work is that typing is in general much more flexible. (See <ref> [2] </ref> for a survey on "semistructured data".) The extension of IQL to semistructured data and the study of complete languages in that new setting are interesting open issues.
Reference: [3] <author> S. Abiteboul, C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects, </title> <type> INRIA Technical Report, No 846, </type> <year> 1988. </year>
Reference-contexts: At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., <ref> [3, 68, 46, 51, 67, 71] </ref>, and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. <p> It generalizes the relational data model [35], most complex-object data models, e.g., [3, 68, 46, 51, 67, 71], and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in <ref> [55, 3] </ref>. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. The actual definitions are not much longer than those for the relational model. <p> As in the relational model, there is a clear separation of the notions of instance and schema. As a consequence, the typing of IQL is similar with that of query languages in <ref> [55, 3, 5] </ref> and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in [23, 62, 58, 56] there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. <p> Thus, it is possible to program directly in popular rule-based formalisms, e.g., Dat-alog. Relations can name subsets of classes and function as useful temporaries. Also, this distinction allows a direct generalization of both [55] and <ref> [3] </ref>. Example 1.1 (From Genesis 4 and 5.) Schema S has class names 1st-generation, 2nd 3 generation and relation names founded-lineage, ancestor-of-celebrity. <p> In Section 6, we add inheritance. More applications can be modeled by adding dependencies to the schema (e.g., relational functional dependencies or statements like for each x the spouse of the spouse of x is x). A first-order-logic in the style of <ref> [55, 3] </ref> and others can be used. Indeed, the language IQL can form the basis of such a logic. 3 The Identity Query Language We first need to define projections of schemas and instances, in order to describe the inputs and outputs of programs. <p> One can show that each COL query can be computed using an IQL program. The proof is easy given the above programs for nest/unnest. As a consequence, all algebraic operations on complex objects of <ref> [68, 46, 67, 3] </ref>, and the calculus queries of [3, 51] are expressible in IQL. Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL. <p> One can show that each COL query can be computed using an IQL program. The proof is easy given the above programs for nest/unnest. As a consequence, all algebraic operations on complex objects of [68, 46, 67, 3], and the calculus queries of <ref> [3, 51] </ref> are expressible in IQL. Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL. One important operation found in the algebra for LDM and the algebra for complex-objects of [3] is powerset. <p> Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL. One important operation found in the algebra for LDM and the algebra for complex-objects of <ref> [3] </ref> is powerset. This operation is expensive: it is exponential in the input size. <p> More specifically, we can show the following propositions. Proposition 4.10 If fl is a dio-transformation, such that the output schema contains no class, then fl is the semantics of some IQL program. In particular, each query in the calculus/algebra of the complex-objects model of <ref> [3] </ref> is expressible in IQL. Proof: The important observation is that, because there are no oid's in the output, the copy elimination is automatic. <p> For example with small modifications of the syntax: on relations, we can identify Datalog, relational calculus and Datalog with negation (stratified or inflationary); on complex-objects, we can identify the restricted calculus of <ref> [3] </ref> and COL with range-restriction [6].
Reference: [4] <author> S. Abiteboul, C. Beeri, M. Gyssens, D. van Gucht, </author> <title> An Introduction to the Completeness of Languages for Complex Objects and Nested Relations. in Nested Relations and Complex Objects Springer-Verlag). </title>
Reference-contexts: The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models <ref> [38, 4, 44] </ref>. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. The originality of our extension comes from the presence of oid's: two instances are viewed as identical if they are isomorphic up-to renaming of oid's.
Reference: [5] <author> S. Abiteboul, S. Grumbach. COL: </author> <title> a Logic-based Language for Complex Objects. </title> <booktitle> In Proc. EDBT, </booktitle> <pages> 271-293, </pages> <year> 1988. </year>
Reference-contexts: As in the relational model, there is a clear separation of the notions of instance and schema. As a consequence, the typing of IQL is similar with that of query languages in <ref> [55, 3, 5] </ref> and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in [23, 62, 58, 56] there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. <p> [name: Cain, occupations: f Farmer, Nomad, Artisan g], -(abel) = [name: Abel, occupations: f Shepherd g], 4 -(seth) = [name: Seth, occupations: f g] -(other) is undefined. (Genesis is rather vague on this point). 2 Operational Part: The design of IQL was greatly influenced by both the COL language of <ref> [5] </ref>, for the manipulation of sets, and the detDL language of [14], for the invention of new oid's. The focus was on adding the minimum to Datalog rules in order to obtain an object-based language, that can express all computable queries. <p> Each p 0 is set valued and its value, noted b p 0 , is a set in which the corresponding q's are collected. This dereferencing and assignment to objects in P 0 simulates the effect of a COL data-function <ref> [5] </ref> or a grouping in LDL [22]. b p 0 (q) R 0 (x; p; p 0 ); R 0 (y; q; q 0 ); R (x; y) In the final stage, the nodes of P have been grouped into P 0 , and the connection in R 0 between x; <p> The reason we use (1) is to code sharing of structures and cyclic structures. Regarding (2), the rule-based language does not need to have any mechanism such as grouping in LDL [22], data-functions in COL <ref> [5] </ref>, or universal quantification [54]. Thus, one of our contributions is to show that: the manipulation and creation of sets can be realized only using invented oid's. 6 We examine (3) in detail in Section 4. The notion of completeness of [33] is adapted to our context. <p> Using composition, it is easy to see that relational calculus queries and Datalog with stratified negation are expressible in IQL almost verbatim. Now consider complex-objects. The most famous operations on complex-objects are nest and unnest. Nest/unnest in IQL resembles the expression of these operations in the language COL <ref> [5, 6] </ref>. The next example shows the IQL realization. For better clarity, we 17 use capital letters, e.g., X,Y , for set variables.
Reference: [6] <author> S. Abiteboul, S. Grumbach, A. Voisard, E. Waller. </author> <title> An Extensible Rule-based Language with Complex Objects and Data-functions. </title> <booktitle> In Proc. DBPL-II Workshop, </booktitle> <address> Oregon USA, </address> <year> 1989. </year> <note> To appear. 47 </note>
Reference-contexts: In Section 5, we specialize IQL using a number of syntactic restrictions. This specialization allows us to discover as IQL sublanguages most of the popular rule-based formalisms. We also show that these restrictions can be used to guarantee efficient query evaluation, i.e., with PTIME data-complexity. In <ref> [6] </ref>, similar restrictions are used in the context of the COL language to obtain queries that are evaluable in PTIME. In summary, IQL is both a mathematical model of computation with types and (particularly in its range restricted form IQL rr ) a useful high level query language. <p> Using composition, it is easy to see that relational calculus queries and Datalog with stratified negation are expressible in IQL almost verbatim. Now consider complex-objects. The most famous operations on complex-objects are nest and unnest. Nest/unnest in IQL resembles the expression of these operations in the language COL <ref> [5, 6] </ref>. The next example shows the IQL realization. For better clarity, we 17 use capital letters, e.g., X,Y , for set variables. <p> For example with small modifications of the syntax: on relations, we can identify Datalog, relational calculus and Datalog with negation (stratified or inflationary); on complex-objects, we can identify the restricted calculus of [3] and COL with range-restriction <ref> [6] </ref>.
Reference: [7] <author> S. Abiteboul, R. Hull. </author> <title> IFO: A Formal Semantic Database Model. </title> <journal> ACM TODS, </journal> <volume> 12 </volume> <pages> 525-565, </pages> <year> 1987. </year>
Reference-contexts: The extension of the theory presented here to these other kinds of collections is nontrivial. Oid's have been part of many data models, for example they are called surrogates in [36], l-values in [55], or object identifiers in <ref> [7] </ref>. They have been highlighted as an essential part of object-oriented database systems [48]. A variety of reasons have been given for their use, e.g., structure sharing, updates [7] or the encoding of cyclicity [55]. <p> have been part of many data models, for example they are called surrogates in [36], l-values in [55], or object identifiers in <ref> [7] </ref>. They have been highlighted as an essential part of object-oriented database systems [48]. A variety of reasons have been given for their use, e.g., structure sharing, updates [7] or the encoding of cyclicity [55]. We use oid's for the traditional encoding of directed (perhaps cyclic) graphs, but also for the manipulation of sets and for making our query language fully expressive. <p> Deleting an oid, forces deletion of other objects that have this oid in their o-value. This of course leads to more complex, but still tractable, definitions (see the treatment of update propagation in <ref> [7] </ref>). From a practical standpoint, it requires more involved evaluation mechanisms, e.g., with reference counts or garbage collection. 5 On the Sublanguages of IQL Queries can be written directly in IQL, they can be type checked, optimized via standard techniques and evaluated bottom-up.
Reference: [8] <author> S. Abiteboul, R. Hull. Data-functions, </author> <title> Datalog and Negation. </title> <booktitle> In Proc. ACM SIG-MOD, </booktitle> <pages> 143-153, </pages> <year> 1988. </year>
Reference-contexts: Note that the value of some node p is a tuple with the name of the node as first component, and a set of P -oid's as a second component. This weak form of assignment is performed only when b p was undefined (see <ref> [8] </ref>). No further changes are made to b p. b p = [x; b p 0 ] R 0 (x; p; p 0 ) We have presented the program in four separate stages. We need not separate the stages. <p> We check only if an oid has a value or is undefined. The cost is less than even recording the derived facts. Unfortunately, deciding at this inexpensive check is needed in some evaluation is not recursive; see <ref> [8] </ref>. All terms of the IQL language are typed. Having to declare the type information for each term would make the programs tedious to write and would hide the simplicity of the rules.
Reference: [9] <author> S. Abiteboul, P. Kanellakis, S. Ramaswamy, E. Waller, </author> <title> Method Schemas, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(3) </volume> <pages> 433-455. </pages> <year> 1995. </year>
Reference-contexts: There are aspects of object-oriented database systems that our mathematical model cannot capture. For example, O 2 emphasizes programming in a modular fashion, by having methods attached to classes and by accessing data only through these methods (encapsulation). (See <ref> [9] </ref>.) Moreover, sharing of programs is possible via method inheritance.
Reference: [10] <author> M. Andries, J. Paredaens. </author> <title> A language for generic graph-transformations. </title> <booktitle> In Proc. Int'l. Workshop WG 91, </booktitle> <pages> pages 63-74. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: By Theorem 4.13, such sophisticate enumeration cannot be realized in IQL. Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research <ref> [10, 26, 27, 28, 39, 40] </ref>. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in [27]. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K.
Reference: [11] <author> M. Atkinson, P. Buneman. </author> <title> Types and Persistence in Database Programming Languages. </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49].
Reference: [12] <author> S. Abiteboul, D. Quass, J. McHugh, J. Widom, and J. Wiener. </author> <title> The lorel query language for semistructured data, </title> <note> 1996. to appear in J. on Digital Libraries. ftp://db.stanford.edu//pub/papers/lorel96.ps. </note>
Reference-contexts: The modelisation of data using objects and graph structures has become one of the major directions of research for modern databases notably influenced by the problem of accessing data on the World Wide Web. A number of languages have been proposed, e.g., <ref> [12, 20, 34, 65, 59, 64] </ref>.
Reference: [13] <author> S. Abiteboul, V. Vianu, </author> <title> Transaction languages for database update and specification. </title> <note> I.N.R.I.A. Technical Report No.715 (1987). To appear in J. </note> <institution> of Computer and Systems Science. </institution>
Reference-contexts: The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational <ref> [33, 13, 14] </ref> and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. <p> A Turing Machine (TM) analog for the inflationary semantics could be a non-erasing TM. Following <ref> [13, 14] </ref>, we first consider only disjoint input-output schemas. <p> Consider the total ordering of pairs of positive integers (1,1), (2,1), (2,2), (3,1), (3,2), (3,3)... The first part of visits each pair of integers in the above order; this exhaustive enumeration can be done as in <ref> [33, 13] </ref>, by realizing counters over a unary alphabet. For a pair (i,j), this part first invents i oid's. <p> Remark N-IQL: Let N-IQL be the language obtained by not enforcing the determinism of the choose, i.e., a computation is indeed allowed to choose one object out of a set even if that violates genericity. The notion of nondeterministic transformations of <ref> [13] </ref> can be extended to the data structure considered here, and one can show that N-IQL is "nondeterministic complete". <p> All the results of the previous subsections (and in particular, Theorem 4.13) can be extended analogously, from disjoint to arbitrary input-output schemas. We omit the formal treatment, since the additional techniques are well known, see <ref> [13, 14] </ref>. We should note that some of the simplicity of the IQL semantics has to be lost in IQL*. Deleting an oid, forces deletion of other objects that have this oid in their o-value.
Reference: [14] <author> S. Abiteboul, V. Vianu, </author> <title> Datalog extensions for database updates and queries, </title> <note> I.N.R.I.A. Technical Report No.900 (1988). To appear in J. </note> <institution> of Computer and Systems Science. </institution>
Reference-contexts: Abel, occupations: f Shepherd g], 4 -(seth) = [name: Seth, occupations: f g] -(other) is undefined. (Genesis is rather vague on this point). 2 Operational Part: The design of IQL was greatly influenced by both the COL language of [5], for the manipulation of sets, and the detDL language of <ref> [14] </ref>, for the invention of new oid's. The focus was on adding the minimum to Datalog rules in order to obtain an object-based language, that can express all computable queries. <p> The focus was on adding the minimum to Datalog rules in order to obtain an object-based language, that can express all computable queries. In summary, IQL is inflationary Datalog with negation <ref> [14, 50] </ref>, combined with set/tuple types, invention of new oid's, and a weak form of assignment. Inflationary semantics has been chosen because of its simplicity and its generality as a control flow mechanism. <p> The following rules are used: R 0 (x) R (x; y) In the second stage, we produce two oid's per node using a semantics in the style of detDL <ref> [14] </ref>. We use a relation R 0 with T (R 0 ) =[A 1 : D; A 2 : P; A 3 : P 0 ] whose tuples contain oid's from class P and from another class P 0 . <p> The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational <ref> [33, 13, 14] </ref> and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. <p> Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in <ref> [33, 14] </ref>. However, on relational schemas, the two notions coincide. The originality of our extension comes from the presence of oid's: two instances are viewed as identical if they are isomorphic up-to renaming of oid's. A basic contribution is a completeness result for IQL. <p> But we show that this technical restriction is necessary. We have to add a choice construct to reach completeness for disjoint input-output schemas. To obtain completeness for non-disjoint schemas, we also need to add non-inflationary features to IQL. These are based on the study of deletions in <ref> [14] </ref>. In Section 5, we specialize IQL using a number of syntactic restrictions. This specialization allows us to discover as IQL sublanguages most of the popular rule-based formalisms. We also show that these restrictions can be used to guarantee efficient query evaluation, i.e., with PTIME data-complexity. <p> Finally, note that we have not included among the terms any constants for the elements of D. This is in order to simplify the presentation as in [33]. Constants can be added easily without changing the framework (see <ref> [14] </ref>). 3.2 Semantics The semantics of program (S; S in ; S out ) is a binary relation fl () on instances. <p> We now formally define the inflationary fixpoint operator of a program using valuations, satisfaction, and the one step inflationary operator. These notions are straightforward extensions of those used for the semantics of detDL in <ref> [14] </ref>. They are slightly complicated by two aspects of the language: (1) the particular mechanism used for oid invention, and (2) the weak assignment of o-values to non-set valued oid's based on Condition (fl) below. <p> The same applies to Datalog with negation and inflationary semantics. Continuing with relational schemas, other relational languages can be viewed as IQL sublanguages, for example detDL <ref> [14] </ref>. The differences between detDL and IQL restricted to relations are: slightly different semantics for valuation-domains and invented constants in detDL versus invented oid's in IQL. However, it is very simple to simulate detDL in IQL. It is shown in [14] that control mechanisms such as composition, if-then-else, and while-statements can <p> languages can be viewed as IQL sublanguages, for example detDL <ref> [14] </ref>. The differences between detDL and IQL restricted to relations are: slightly different semantics for valuation-domains and invented constants in detDL versus invented oid's in IQL. However, it is very simple to simulate detDL in IQL. It is shown in [14] that control mechanisms such as composition, if-then-else, and while-statements can be simulated in detDL (using negation and inflationary semantics). These mechanisms can now be used as shorthands. In particular, we use ";" to denote composition. <p> For example, instances must be well-typed. To formalize what are the meaningful 20 binary relations, we extend the notion of database (db-) transformation of <ref> [14] </ref> and, thus, the notion of computable relational query of [33]. The only departure from the classical notion is that functionality is weakened by allowing transformations that are determinate up to renaming of oids. In this framework, we investigate the expressive power of IQL. <p> More precisely, if (I,J) is in a db-transformation fl then constants (J) constants (I). In contrast, the kind of functionality enforced by Condition (4) allows the presence of oid's in the output that were not in the input. This is a significant addition to the frameworks of <ref> [14, 33] </ref>. It is important to be able to create new oid's in the output, if one wishes to manipulate in a general fashion the types available in the data model. Another intuition formalized by (4) is that the oid's as atomic elements are irrelevant, only their interrelationships matter. <p> A Turing Machine (TM) analog for the inflationary semantics could be a non-erasing TM. Following <ref> [13, 14] </ref>, we first consider only disjoint input-output schemas. <p> Proposition 4.4 Each dio-transformation for relational schemas is the semantics of some IQL program. Proof: The proof follows the proof of <ref> [14] </ref> for showing that each relational transformation can be expressed in the language detDL. The differences between the languages detDL and IQL restricted to relations do not affect the essence of the proof. 2 Proposition 4.5 Each yes/no db-transformation is the semantics of some IQL program. <p> The "if" part is considerably more complex, and is based on a group-theoretic argument. 4.4 Achieving Completeness As shown above, there exist dio-transformations that are not expressible in IQL. There are various ways of "completing" IQL: 1. As in <ref> [14] </ref>, one can introduce nondeterministic dio-transformations and a nondeterministic variant of IQL that expresses all of them: with nondeterminism, selection of one out of a set of copies is easy. (See Remark N-IQL below.) 2. <p> Copy elimination is possible if an ordering of the constants of the input is explicitly provided. (This is important from a practical point of view, because a lexicographic order is usually provided.) For the precise definition of ordered database one can use that of <ref> [14] </ref>. Intuitively, the order on the finite set of constants of the input together with the order of creation of oid's allows the enumeration of instances. 31 However, these two solutions present inelegances. The first one yields transformations that are nondeterministic and are therefore not dio-transformations as defined above. <p> The notion of nondeterministic transformations of [13] can be extended to the data structure considered here, and one can show that N-IQL is "nondeterministic complete". One can also obtain a nondeterministic complete version of IQL along the lines of the "N-" languages of <ref> [14] </ref> by firing one instantiation of a rule at a time instead of firing all rules that are applicable in parallel as done in this paper. 4.5 Arbitrary Input-Output Schemas: Deletions IQL has inflationary semantics and is a simple and elegant model for queries and insertions. <p> However, because of monotonicity it cannot express deletions of ground facts from the input. Let IQL* be the language obtained by allowing negative facts in heads of rules and interpreting them as deletions in the style of the "*"-languages of <ref> [14] </ref>. IQL* allows the manipulation of arbitrary input-output schemas. One can show that: (1) the semantics of an IQL* program is a db-transformation and (2) each db-transformation is the semantics of some IQL* program up to copy. <p> All the results of the previous subsections (and in particular, Theorem 4.13) can be extended analogously, from disjoint to arbitrary input-output schemas. We omit the formal treatment, since the additional techniques are well known, see <ref> [13, 14] </ref>. We should note that some of the simplicity of the IQL semantics has to be lost in IQL*. Deleting an oid, forces deletion of other objects that have this oid in their o-value.
Reference: [15] <author> S. Abiteboul, V. Vianu, </author> <title> Fixpoint Extensions of First-Order Logic and Datalog-Like Languages, </title> <booktitle> Proc. of Symp. on Logic in Computer Science (1989). </booktitle>
Reference-contexts: However, from Theorem 4.7, little is needed to "complete" IQL. To conclude this section, we present IQL + that yields exactly the desired class of transformations. The primitive that we introduce is related to the (nondeterministic) witness operator of <ref> [15] </ref> and the choice of [52]. However, it is essentially different in that it is not causing any nondeterminism. The syntax of IQL + is that of IQL augmented as follows. The new symbol choose is a literal that may occur in a rule body.
Reference: [16] <author> S. Abiteboul, R. Hull, V. Vianu, </author> <title> Foundations of Databases, </title> <publisher> Addison-Wesley, </publisher> <address> Reading-Massachusetts, </address> <year> 1995. </year>
Reference-contexts: More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model [35] that is now equipped with an elegant and relevant theory <ref> [16, 70, 47] </ref>. This paper together with papers such as [21, 39] or [29] participate in clarifying some of the foundations of object-oriented databases.
Reference: [17] <author> F. Bancilhon. </author> <title> Object-Oriented Database Systems. </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> 152-162, </pages> <year> 1988. </year>
Reference-contexts: Kanellakis died tragically in an airplane crash in Columbia on December 20th, 1995. A technical obituary can be found in [1]. 1 from the relational model, object-oriented database systems <ref> [17] </ref> that integrate the relational and object technology have been commercialized, e.g., O 2 or Object-Store. Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. <p> focus of a great deal of experimentation and research since the late eighties, e.g., [11, 63, 72, 18, 41, 32, 24]. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., <ref> [42, 17, 49] </ref>. More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited.
Reference: [18] <author> J. Banerjee, H.-T. Chou, J.F. Garza, W. Kim, D. Woelk, N. Ballou. </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> ACM TOIS, </journal> <volume> 5:1:3-26, </volume> <year> 1987. </year>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49].
Reference: [19] <author> F. Bancilhon, S. Cluet, C. Delobel. </author> <title> Query Languages for Object-Oriented Database Systems. </title> <booktitle> In Proc. DBPL-II Workshop, </booktitle> <address> Oregon USA, </address> <year> 1989. </year> <note> To appear. </note>
Reference: [20] <author> P. Buneman, S. Davidson, G. Hillebrand, and D. Suciu. </author> <title> A query language and optimization techniques for unstructured data. </title> <booktitle> In SIGMOD, </booktitle> <address> San Diego, </address> <year> 1996. </year>
Reference-contexts: The modelisation of data using objects and graph structures has become one of the major directions of research for modern databases notably influenced by the problem of accessing data on the World Wide Web. A number of languages have been proposed, e.g., <ref> [12, 20, 34, 65, 59, 64] </ref>.
Reference: [21] <author> C. Beeri, </author> <title> A formal approach to object-oriented databases, </title> <journal> Journal of Data and Knowledge Engineering, </journal> <volume> 5(4), </volume> <year> 1990, </year> <pages> pages 353-382. </pages>
Reference-contexts: Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model [35] that is now equipped with an elegant and relevant theory [16, 70, 47]. This paper together with papers such as <ref> [21, 39] </ref> or [29] participate in clarifying some of the foundations of object-oriented databases.
Reference: [22] <author> C. Beeri et al. </author> <title> Sets and Negation in a Logic Database Language (LDL1). </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> 21-37, </pages> <year> 1987. </year> <month> 48 </month>
Reference-contexts: Each p 0 is set valued and its value, noted b p 0 , is a set in which the corresponding q's are collected. This dereferencing and assignment to objects in P 0 simulates the effect of a COL data-function [5] or a grouping in LDL <ref> [22] </ref>. b p 0 (q) R 0 (x; p; p 0 ); R 0 (y; q; q 0 ); R (x; y) In the final stage, the nodes of P have been grouped into P 0 , and the connection in R 0 between x; p; p 0 is used to <p> The reason we use (1) is to code sharing of structures and cyclic structures. Regarding (2), the rule-based language does not need to have any mechanism such as grouping in LDL <ref> [22] </ref>, data-functions in COL [5], or universal quantification [54]. Thus, one of our contributions is to show that: the manipulation and creation of sets can be realized only using invented oid's. 6 We examine (3) in detail in Section 4.
Reference: [23] <author> F. Bancilhon, S. Khoshafian. </author> <title> A Calculus for Complex Objects. </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> 53-60, </pages> <year> 1986. </year>
Reference-contexts: As a consequence, the typing of IQL is similar with that of query languages in [55, 3, 5] and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in <ref> [23, 62, 58, 56] </ref> there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. We give brief overviews (by example) of the structural and operational parts of our data model. The detailed definitions are in Sections 2 and 3, respectively. <p> We conclude with two remarks. Remark: incomplete information can be modeled using oid's with undefined value. So our model has some capability for expressing incomplete data, even without complex machinery as in, e.g., <ref> [23] </ref>. Besides this, there is an important technical reason for having oid's with undefined values. The language IQL builds objects in stages, and oid's with undefined values are needed in the intermediate stages.
Reference: [24] <author> F. Bancilhon, G. Barbedette, V. Benzaken, C. Delobel, S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard, F. Velez. </author> <title> The Design and Implementation of O 2 , an Object-Oriented Database System. </title> <booktitle> In Proc. OODBS2 Workshop, </booktitle> <address> Badmunster RFA, </address> <year> 1988. </year>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49]. <p> A major motivation for our work was the study of the formal aspects of the O 2 system, <ref> [24] </ref>. The standard data model for object-oriented data model as defined by the Object Data Management Group [30] was strongly influenced by the O 2 system. As a consequence, our model bears a lot of resemblance with the ODMG data model. The ODMG model does not have union types. <p> We believe that both design choices are natural restrictions to impose. Clearly, they can be enforced by constraining the creation of oid's in a precise class with the exact type of that class (e.g., this form of creation is implicitly enforced in the implementation of <ref> [24] </ref>). 7 A Value-Based Data Model In this section, we introduce a value-based data model and relate it to the object-based model of the previous sections. We use a simplified framework: only class names P and 42 v-type-exp (P).
Reference: [25] <editor> F. Bancilhon, C. Delobel, P. Kanellakis, editors. </editor> <title> The story of O 2 , Morgan Kauf-mann, </title> <address> Los Altos, CA, </address> <year> 1992. </year>
Reference: [26] <author> J. Van den Bussche, D. Van Gucht. Semi-determinism. </author> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 191-201, </pages> <year> 1992. </year>
Reference-contexts: By Theorem 4.13, such sophisticate enumeration cannot be realized in IQL. Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research <ref> [10, 26, 27, 28, 39, 40] </ref>. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in [27]. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K.
Reference: [27] <author> J. Van den Bussche, D. Van Gucht, M. Andries, M. Gyssens. </author> <title> On the completeness of object-creating query languages. </title> <booktitle> In IEEE Conf. on Foundations of Computer Science, </booktitle> <pages> pages 372-379, </pages> <year> 1992. </year>
Reference-contexts: By Theorem 4.13, such sophisticate enumeration cannot be realized in IQL. Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research <ref> [10, 26, 27, 28, 39, 40] </ref>. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in [27]. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K. <p> Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research [10, 26, 27, 28, 39, 40]. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in <ref> [27] </ref>. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K. <p> In particular, an elegant characterization of the determinate queries expressible in IQL was shown in <ref> [27] </ref>. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K. For a pair of instances K; K 0 , Aut (hK; K 0 i) denotes the bijections on D [ O that are automorphisms of both K and K 0 .
Reference: [28] <author> J. Van den Bussche, J. Paredaens. </author> <title> The expressive power of structured values in pure oodbs. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 291-299, </pages> <year> 1991. </year>
Reference-contexts: By Theorem 4.13, such sophisticate enumeration cannot be realized in IQL. Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research <ref> [10, 26, 27, 28, 39, 40] </ref>. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in [27]. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K.
Reference: [29] <author> V. Breazu-Tannen, P. Buneman, S. Naqvi, </author> <title> Structural Recursion as a Query Language, </title> <booktitle> Proc. of Intl. Workshop on Database Programming Languages, </booktitle> <publisher> Morgan-Kaufmann, </publisher> <pages> pages 9-19, </pages> <year> 1992. </year>
Reference-contexts: Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model [35] that is now equipped with an elegant and relevant theory [16, 70, 47]. This paper together with papers such as [21, 39] or <ref> [29] </ref> participate in clarifying some of the foundations of object-oriented databases.
Reference: [30] <author> R.G.G Cattell, </author> <title> The Object Database Standard: ODMG-93, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: A major motivation for our work was the study of the formal aspects of the O 2 system, [24]. The standard data model for object-oriented data model as defined by the Object Data Management Group <ref> [30] </ref> was strongly influenced by the O 2 system. As a consequence, our model bears a lot of resemblance with the ODMG data model. The ODMG model does not have union types. We believe that union type is essential and we use it here. <p> To conclude this paper, it should be observed that the field of object databases has been quite active since IQL was first proposed. Most notably, as already mentioned, a standard model (ODL) and a standard query language (OQL) have been proposed by the ODMG <ref> [30] </ref>. The relative resemblance with the model used in IQL is an a-posteriori motivation for the present paper.
Reference: [31] <author> L. Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year>
Reference-contexts: This condition guarantees the soundness and the typability of IQL programs. However, the removal of this condition is necessary if one is to study type inheritance as proposed in <ref> [31] </ref>. With inheritance, the disjointness condition on the classes is replaced by a less restricted condition that, we argue, is natural. We show that, under this limited addition, type inheritance has simple semantics. The use of the union type constructor is critical in this development. <p> Unfortunately, under the semantics previously defined [A 1 : D; A 2 : D] ^ [A 2 : D; A 3 : D] is equivalent to ;. 38 This example motivates the definition of the alternative fl-interpretations fl , which express the desired equivalences <ref> [31] </ref>.
Reference: [32] <author> M.J. Carey, </author> <title> D.J. Dewitt, S.L. Vandenberg. A Data Model and Query Language for EXODUS. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <pages> 413-423, </pages> <year> 1988. </year>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49].
Reference: [33] <author> A. Chandra, D. Harel. </author> <title> Computable Queries for Relational Data Bases. </title> <journal> JCSS, </journal> <volume> 21:2:156-178, </volume> <year> 1980. </year>
Reference-contexts: Let us comment on these three points: (1) highlights the declarative nature and mathematical clarity of the programming paradigm used, (2) illustrates what is controlled about the use of pointers, and (3) involves generalizing the basic theorem of <ref> [33] </ref> from the relational model to a data model with first-order and recursive types. As in the relational model, there is a clear separation of the notions of instance and schema. <p> This serves a triple goal: (1) objects may be part of the result and oid's must be assigned to them, (2) invented oid's are used for set manipulation, (3) they are also used to obtain completeness in the sense of <ref> [33] </ref>. The reason we use (1) is to code sharing of structures and cyclic structures. Regarding (2), the rule-based language does not need to have any mechanism such as grouping in LDL [22], data-functions in COL [5], or universal quantification [54]. <p> Thus, one of our contributions is to show that: the manipulation and creation of sets can be realized only using invented oid's. 6 We examine (3) in detail in Section 4. The notion of completeness of <ref> [33] </ref> is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models [38, 4, 44]. <p> The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties <ref> [33, 43] </ref>. Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. <p> The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational <ref> [33, 13, 14] </ref> and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. <p> Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in <ref> [33, 14] </ref>. However, on relational schemas, the two notions coincide. The originality of our extension comes from the presence of oid's: two instances are viewed as identical if they are isomorphic up-to renaming of oid's. A basic contribution is a completeness result for IQL. <p> Finally, note that we have not included among the terms any constants for the elements of D. This is in order to simplify the presentation as in <ref> [33] </ref>. Constants can be added easily without changing the framework (see [14]). 3.2 Semantics The semantics of program (S; S in ; S out ) is a binary relation fl () on instances. <p> For example, instances must be well-typed. To formalize what are the meaningful 20 binary relations, we extend the notion of database (db-) transformation of [14] and, thus, the notion of computable relational query of <ref> [33] </ref>. The only departure from the classical notion is that functionality is weakened by allowing transformations that are determinate up to renaming of oids. In this framework, we investigate the expressive power of IQL. We show that each IQL program expresses a db-transformation. <p> The first three conditions are standard and capture well-typedness, effective computability, and genericity. The justification for genericity is that a query language should not "interpret" atomic elements, such as constants and oid's, see <ref> [33, 43] </ref>. The fourth condition is new and expresses a form of functionality. <p> More precisely, if (I,J) is in a db-transformation fl then constants (J) constants (I). In contrast, the kind of functionality enforced by Condition (4) allows the presence of oid's in the output that were not in the input. This is a significant addition to the frameworks of <ref> [14, 33] </ref>. It is important to be able to create new oid's in the output, if one wishes to manipulate in a general fashion the types available in the data model. Another intuition formalized by (4) is that the oid's as atomic elements are irrelevant, only their interrelationships matter. <p> So for example, having as output the input itself is not a dio-transformation, but having as output an O-isomorphic copy of the input is a dio-transformation. For relational schemas, the dio-transformations (by definition) are the same as the graphs of computable queries as defined in <ref> [33] </ref>. For acceptors (programs that answer yes, no or loop for ever) we use the set of yes/no db-transformations: these are all db-transformations with an output schema consisting of a single relation of type the empty tuple. <p> Consider the total ordering of pairs of positive integers (1,1), (2,1), (2,2), (3,1), (3,2), (3,3)... The first part of visits each pair of integers in the above order; this exhaustive enumeration can be done as in <ref> [33, 13] </ref>, by realizing counters over a unary alphabet. For a pair (i,j), this part first invents i oid's.
Reference: [34] <author> V. Christophides, S. Abiteboul, S. Cluet, and M. Scholl. </author> <title> From structured documents to novel query facilities. </title> <booktitle> In SIGMOD'94. ACM, </booktitle> <year> 1994. </year>
Reference-contexts: The modelisation of data using objects and graph structures has become one of the major directions of research for modern databases notably influenced by the problem of accessing data on the World Wide Web. A number of languages have been proposed, e.g., <ref> [12, 20, 34, 65, 59, 64] </ref>.
Reference: [35] <author> E.F. Codd. </author> <title> A Relational Model of Data for Large Shared Data Banks. </title> <journal> CACM, </journal> <volume> 13:6:377-387, </volume> <year> 1970. </year>
Reference-contexts: More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model <ref> [35] </ref> that is now equipped with an elegant and relevant theory [16, 70, 47]. This paper together with papers such as [21, 39] or [29] participate in clarifying some of the foundations of object-oriented databases. <p> At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model <ref> [35] </ref>, most complex-object data models, e.g., [3, 68, 46, 51, 67, 71], and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3].
Reference: [36] <author> T. Codd. </author> <title> Extending the Database Relational Model to Capture more Meaning. </title> <journal> ACM TODS, </journal> <volume> 4:4:397-434, </volume> <year> 1979. </year>
Reference-contexts: The extension of the theory presented here to these other kinds of collections is nontrivial. Oid's have been part of many data models, for example they are called surrogates in <ref> [36] </ref>, l-values in [55], or object identifiers in [7]. They have been highlighted as an essential part of object-oriented database systems [48]. A variety of reasons have been given for their use, e.g., structure sharing, updates [7] or the encoding of cyclicity [55].
Reference: [37] <author> B. Courcelle. </author> <title> Fundamental Properties of Infinite Trees. </title> <journal> TCS, </journal> <volume> 25, </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: Even with these devices, recursive structures stay in the background in a fundamental way. Object-based systems often allow features such as equality-by-value, which is a precise way of addressing the underlying infinite objects. We illustrate a natural connection with a value-based model founded on regular infinite trees <ref> [37] </ref>. Our analysis allows us to show that IQL can serve as a language for this model as well. Object identities, in this context, loose all semantic denotation to become purely, primitives of the language. This is a nontrivial link between value-based and object-based [69]. <p> They have the same kinds of nodes (base, finite set, finite tuple) but there are two differences: (1) no oid's occur in them, (2) they might have infinite depth. These infinite trees are variants of the infinite trees in <ref> [37] </ref>. The only difference is that set nodes do not have a fixed arity and the order of their children is not significant, whereas all functions in [37] do have a fixed arity. <p> These infinite trees are variants of the infinite trees in <ref> [37] </ref>. The only difference is that set nodes do not have a fixed arity and the order of their children is not significant, whereas all functions in [37] do have a fixed arity. However, using the fact that the sets that are considered are finite, it is an easy but tedious exercise to show that: properties of the infinite trees in [37] also hold for pure value infinite trees. <p> a fixed arity and the order of their children is not significant, whereas all functions in <ref> [37] </ref> do have a fixed arity. However, using the fact that the sets that are considered are finite, it is an easy but tedious exercise to show that: properties of the infinite trees in [37] also hold for pure value infinite trees. The assignments and type interpretations of Section 2 have analogs in the value-based case. Given a set of class names P, a finite assignment I for P is a function from P to finite sets of pure values. <p> The technical condition on the T of a v-schema is imposed to avoid pathological cases, such as T (P 1 ) = P 2 which does not specify any structure for P 1 . A regular tree is a tree with a finite number of subtrees <ref> [37] </ref>. An important consequence of the finiteness of assignments is that each value occurring in a v-instance is a regular tree. 43 Proposition 7.3 Each pure value occurring in a v-instance is a regular tree. Proof: Let I be a v-instance. <p> Since the sets are finite, we can view this system as an extended regular Greibach system <ref> [37] </ref>. (The technical condition (+) is also imposed in these systems). By [37], the solution is unique and each component of the solution, i.e., each v i , is regular. 2 Now let us compare object-based and value-based instances over schema (P,T). <p> Since the sets are finite, we can view this system as an extended regular Greibach system <ref> [37] </ref>. (The technical condition (+) is also imposed in these systems). By [37], the solution is unique and each component of the solution, i.e., each v i , is regular. 2 Now let us compare object-based and value-based instances over schema (P,T). From values to objects: Let I be a v-instance over (P,T).
Reference: [38] <author> E. Dahlaus, J. Makowski. </author> <title> Computable Directory Queries. </title> <booktitle> In Proc. CAAP, 1986. </booktitle> <publisher> LNCS 214, Springer-Verlag. </publisher> <pages> 49 </pages>
Reference-contexts: The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models <ref> [38, 4, 44] </ref>. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. The originality of our extension comes from the presence of oid's: two instances are viewed as identical if they are isomorphic up-to renaming of oid's.
Reference: [39] <author> K. Denninghoff, V. Vianu. </author> <title> The power of methods with parallel semantics. </title> <booktitle> In vldb, </booktitle> <pages> pages 221-232, </pages> <year> 1991. </year>
Reference-contexts: Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model [35] that is now equipped with an elegant and relevant theory [16, 70, 47]. This paper together with papers such as <ref> [21, 39] </ref> or [29] participate in clarifying some of the foundations of object-oriented databases. <p> By Theorem 4.13, such sophisticate enumeration cannot be realized in IQL. Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research <ref> [10, 26, 27, 28, 39, 40] </ref>. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in [27]. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K.
Reference: [40] <author> K. Denninghoff, V. Vianu. </author> <title> Database method schemas and object creation. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 265-275, </pages> <year> 1993. </year>
Reference-contexts: By Theorem 4.13, such sophisticate enumeration cannot be realized in IQL. Remark: Since we observed the incompleteness of IQL in 1989, the issue of completeness of languages with object creation has generated a lot of research <ref> [10, 26, 27, 28, 39, 40] </ref>. In particular, an elegant characterization of the determinate queries expressible in IQL was shown in [27]. The characterization is as follows (see [27] for details). For an instance K, let Aut (K) denote the set of DO-automorphisms of K.
Reference: [41] <author> D. Fishman et al. </author> <title> Iris: an Object-Oriented Database Management System. </title> <journal> ACM TOIS, </journal> <volume> 5:1:46-69, </volume> <year> 1987. </year>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49].
Reference: [42] <author> A. Goldberg, D. Robson. </author> <title> Smalltalk 80, the Language and Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: focus of a great deal of experimentation and research since the late eighties, e.g., [11, 63, 72, 18, 41, 32, 24]. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., <ref> [42, 17, 49] </ref>. More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited.
Reference: [43] <author> R. Hull. </author> <title> Relative Information Capacity of Simple Relational Schemata. </title> <journal> Siam J. of Computing, </journal> <volume> 15:3, </volume> <year> 1986. </year>
Reference-contexts: The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties <ref> [33, 43] </ref>. Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models [38, 4, 44]. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. <p> The first three conditions are standard and capture well-typedness, effective computability, and genericity. The justification for genericity is that a query language should not "interpret" atomic elements, such as constants and oid's, see <ref> [33, 43] </ref>. The fourth condition is new and expresses a form of functionality.
Reference: [44] <author> R. Hull, J. Su. </author> <title> Untyped Sets, Invention and Computable Queries. </title> <booktitle> In Proc. ACM PODS 1989. </booktitle>
Reference-contexts: The notion of completeness of [33] is adapted to our context. Intuitively, the language must capture all transformations that are recursively enumerable and that preserve some isomorphism properties [33, 43]. Completeness results have been shown for the relational [33, 13, 14] and for many complex-object data models <ref> [38, 4, 44] </ref>. Our notion of completeness is more general than the notion used in [33, 14]. However, on relational schemas, the two notions coincide. The originality of our extension comes from the presence of oid's: two instances are viewed as identical if they are isomorphic up-to renaming of oid's.
Reference: [45] <author> R. Hull, M. Yoshikawa, </author> <title> On the Equivalence of Data Restructurings Involving Object Identifiers, </title> <booktitle> in Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Note that this is essentially equivalent to using Skolem functors in oid's denotation as introduced by [62], and refined for instance in <ref> [45, 56, 57] </ref>. In a Skolem based approach, one would instead use a rule such as: R 0 (x; f ( x); f 0 (x)) R o (x) where f (x); f 0 (x) would denote the two new oid's. In practice, the use of Skolem functors sometimes facilitate programming.
Reference: [46] <author> B. Jaeschke, H.J. Schek. </author> <title> Remarks on the Algebra of Non-first-normal-form Relations. </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> 124-138, </pages> <year> 1982. </year>
Reference-contexts: At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., <ref> [3, 68, 46, 51, 67, 71] </ref>, and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. <p> One can show that each COL query can be computed using an IQL program. The proof is easy given the above programs for nest/unnest. As a consequence, all algebraic operations on complex objects of <ref> [68, 46, 67, 3] </ref>, and the calculus queries of [3, 51] are expressible in IQL. Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL.
Reference: [47] <author> P. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <year> 1998. </year>
Reference-contexts: More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model [35] that is now equipped with an elegant and relevant theory <ref> [16, 70, 47] </ref>. This paper together with papers such as [21, 39] or [29] participate in clarifying some of the foundations of object-oriented databases.
Reference: [48] <author> S. Khoshafian, G. Copeland. </author> <title> Object Identity. </title> <booktitle> In Proc. </booktitle> <address> OOPSALA, </address> <year> 1986. </year>
Reference-contexts: Oid's have been part of many data models, for example they are called surrogates in [36], l-values in [55], or object identifiers in [7]. They have been highlighted as an essential part of object-oriented database systems <ref> [48] </ref>. A variety of reasons have been given for their use, e.g., structure sharing, updates [7] or the encoding of cyclicity [55]. We use oid's for the traditional encoding of directed (perhaps cyclic) graphs, but also for the manipulation of sets and for making our query language fully expressive.
Reference: [49] <author> W. Kim. </author> <title> A Foundation for Object-Oriented Databases. </title> <type> Technical Report, </type> <institution> MCC, </institution> <year> 1988. </year>
Reference-contexts: focus of a great deal of experimentation and research since the late eighties, e.g., [11, 63, 72, 18, 41, 32, 24]. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., <ref> [42, 17, 49] </ref>. More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited.
Reference: [50] <author> P.G. Kolaitis, C.H. Papadimitriou. </author> <title> Why not Negation by Fixpoint? In Proc. </title> <booktitle> ACM PODS, </booktitle> <pages> 231-239, </pages> <year> 1988. </year>
Reference-contexts: The focus was on adding the minimum to Datalog rules in order to obtain an object-based language, that can express all computable queries. In summary, IQL is inflationary Datalog with negation <ref> [14, 50] </ref>, combined with set/tuple types, invention of new oid's, and a weak form of assignment. Inflationary semantics has been chosen because of its simplicity and its generality as a control flow mechanism.
Reference: [51] <author> H.F. Korth, M.A. Roth, A. Silberschatz. </author> <title> Extended Algebra and Calculus for not 1NF Relational Databases. </title> <type> U. Texas Austin Technical Report, </type> <year> 1985. </year>
Reference-contexts: At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., <ref> [3, 68, 46, 51, 67, 71] </ref>, and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. <p> One can show that each COL query can be computed using an IQL program. The proof is easy given the above programs for nest/unnest. As a consequence, all algebraic operations on complex objects of [68, 46, 67, 3], and the calculus queries of <ref> [3, 51] </ref> are expressible in IQL. Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL. One important operation found in the algebra for LDM and the algebra for complex-objects of [3] is powerset.
Reference: [52] <author> S. Naqvi, R. Krishnamurthy, </author> <title> Non-deterministic Choice in Datalog, </title> <booktitle> Proc. 3rd Int'l. Conf. on Data and Knowledge Bases, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos (1988), </address> <pages> 416-424. </pages>
Reference-contexts: However, from Theorem 4.7, little is needed to "complete" IQL. To conclude this section, we present IQL + that yields exactly the desired class of transformations. The primitive that we introduce is related to the (nondeterministic) witness operator of [15] and the choice of <ref> [52] </ref>. However, it is essentially different in that it is not causing any nondeterminism. The syntax of IQL + is that of IQL augmented as follows. The new symbol choose is a literal that may occur in a rule body. We have to reconsider the definition of valuation-map.
Reference: [53] <author> G.M. Kuper. </author> <title> The Logical Data Model: a New Approach to Database Logic. Stanford U., </title> <type> PhD thesis, </type> <year> 1985. </year>
Reference-contexts: The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., [3, 68, 46, 51, 67, 71], and the logical data model (LDM) <ref> [55, 53] </ref>. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. The actual definitions are not much longer than those for the relational model. <p> It corresponds to schemas of the form (;, P, T), where the types are trees of bounded depth. (For instance, the value of an object cannot be a tuple where one component is itself a tuple.) In Appendix B of <ref> [53] </ref>, an attempt is made to formulate LDM in a fashion closer to our model. A problem with that approach is the requirement of having only classes and forcing some of them to behave like relations, through semantic restrictions. The resulting restrictions for duplicate elimination are quite involved.
Reference: [54] <author> G.M. Kuper. </author> <title> Logic Programming with Sets. </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> 11-20, </pages> <year> 1987. </year>
Reference-contexts: The reason we use (1) is to code sharing of structures and cyclic structures. Regarding (2), the rule-based language does not need to have any mechanism such as grouping in LDL [22], data-functions in COL [5], or universal quantification <ref> [54] </ref>. Thus, one of our contributions is to show that: the manipulation and creation of sets can be realized only using invented oid's. 6 We examine (3) in detail in Section 4. The notion of completeness of [33] is adapted to our context.
Reference: [55] <author> G.M. Kuper, M.Y. Vardi. </author> <title> The Logical Data Model, </title> <journal> ACM tods, </journal> <volume> vol 18, </volume> <pages> pp. 379-413, </pages> <year> 1993. </year>
Reference-contexts: The extension of the theory presented here to these other kinds of collections is nontrivial. Oid's have been part of many data models, for example they are called surrogates in [36], l-values in <ref> [55] </ref>, or object identifiers in [7]. They have been highlighted as an essential part of object-oriented database systems [48]. A variety of reasons have been given for their use, e.g., structure sharing, updates [7] or the encoding of cyclicity [55]. <p> models, for example they are called surrogates in [36], l-values in <ref> [55] </ref>, or object identifiers in [7]. They have been highlighted as an essential part of object-oriented database systems [48]. A variety of reasons have been given for their use, e.g., structure sharing, updates [7] or the encoding of cyclicity [55]. We use oid's for the traditional encoding of directed (perhaps cyclic) graphs, but also for the manipulation of sets and for making our query language fully expressive. At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. <p> The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., [3, 68, 46, 51, 67, 71], and the logical data model (LDM) <ref> [55, 53] </ref>. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. The actual definitions are not much longer than those for the relational model. <p> It generalizes the relational data model [35], most complex-object data models, e.g., [3, 68, 46, 51, 67, 71], and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in <ref> [55, 3] </ref>. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. The actual definitions are not much longer than those for the relational model. <p> As in the relational model, there is a clear separation of the notions of instance and schema. As a consequence, the typing of IQL is similar with that of query languages in <ref> [55, 3, 5] </ref> and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in [23, 62, 58, 56] there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. <p> Since relations are sets of o-values, duplicates are eliminated from them at a logical level. Thus, it is possible to program directly in popular rule-based formalisms, e.g., Dat-alog. Relations can name subsets of classes and function as useful temporaries. Also, this distinction allows a direct generalization of both <ref> [55] </ref> and [3]. Example 1.1 (From Genesis 4 and 5.) Schema S has class names 1st-generation, 2nd 3 generation and relation names founded-lineage, ancestor-of-celebrity. <p> In Section 6, we add inheritance. More applications can be modeled by adding dependencies to the schema (e.g., relational functional dependencies or statements like for each x the spouse of the spouse of x is x). A first-order-logic in the style of <ref> [55, 3] </ref> and others can be used. Indeed, the language IQL can form the basis of such a logic. 3 The Identity Query Language We first need to define projections of schemas and instances, in order to describe the inputs and outputs of programs. <p> Using this order, the tuples of type t representing instances of S with i oid's can be enumerated. Thus there is no need for copy elimination. 2 Proposition 4.12 Each query in the calculus/algebra of the Logical Data Model of <ref> [55] </ref> is the semantics of some IQL program. Proof: In LDM there is limited invention of oid's, but output schemas are constrained. It is simple to simulate all the algebraic operators of LDM in IQL directly, i.e., without any exhaustive enumeration of instances or copies.
Reference: [56] <author> M. Kifer, G. Lausen, F-logic: </author> <title> A Higher-Order Language for Reasoning about Objects, </title> <booktitle> proc. ACM Sigmod conf. on Data Management, </booktitle> <year> 1989. </year> <month> 50 </month>
Reference-contexts: As a consequence, the typing of IQL is similar with that of query languages in [55, 3, 5] and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in <ref> [23, 62, 58, 56] </ref> there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. We give brief overviews (by example) of the structural and operational parts of our data model. The detailed definitions are in Sections 2 and 3, respectively. <p> Note that this is essentially equivalent to using Skolem functors in oid's denotation as introduced by [62], and refined for instance in <ref> [45, 56, 57] </ref>. In a Skolem based approach, one would instead use a rule such as: R 0 (x; f ( x); f 0 (x)) R o (x) where f (x); f 0 (x) would denote the two new oid's. In practice, the use of Skolem functors sometimes facilitate programming.
Reference: [57] <author> M. Kifer, G. Lausen, J. Wu, </author> <booktitle> Logical foundations of object-oriented and frame-based languages, </booktitle> <institution> Dept. Computer Science SUNY Stony Brook, </institution> <type> tech. report 93/06, </type> <year> 1993 </year>
Reference-contexts: Note that this is essentially equivalent to using Skolem functors in oid's denotation as introduced by [62], and refined for instance in <ref> [45, 56, 57] </ref>. In a Skolem based approach, one would instead use a rule such as: R 0 (x; f ( x); f 0 (x)) R o (x) where f (x); f 0 (x) would denote the two new oid's. In practice, the use of Skolem functors sometimes facilitate programming.
Reference: [58] <author> M. Kifer, J. Wu. </author> <title> A Logic for Object-Oriented Logic Programming (Maier's O-logic: Revisited). </title> <booktitle> In Proc. ACM PODS, </booktitle> <year> 1989. </year>
Reference-contexts: As a consequence, the typing of IQL is similar with that of query languages in [55, 3, 5] and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in <ref> [23, 62, 58, 56] </ref> there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. We give brief overviews (by example) of the structural and operational parts of our data model. The detailed definitions are in Sections 2 and 3, respectively.
Reference: [59] <author> D. Konopnicki and O. Shmueli. W3QS: </author> <title> A query system for the World Wide Web. </title> <booktitle> In VLDB, </booktitle> <year> 1995. </year>
Reference-contexts: The modelisation of data using objects and graph structures has become one of the major directions of research for modern databases notably influenced by the problem of accessing data on the World Wide Web. A number of languages have been proposed, e.g., <ref> [12, 20, 34, 65, 59, 64] </ref>.
Reference: [60] <author> C. Lecluse, P. Richard. </author> <title> Modeling Complex Structures in Object-Oriented Databases. </title> <booktitle> In Proc. ACM PODS, </booktitle> <year> 1989. </year>
Reference: [61] <author> C. Lecluse, P. Richard, F. Velez. </author> <title> O 2 , an Object-Oriented Data Model. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <pages> 424-434, </pages> <year> 1988. </year>
Reference: [62] <author> D. Maier. </author> <title> A Logic for Objects. </title> <booktitle> In Proc. of Workshop on Foundations of Deductive Databases and Logic Programming, </booktitle> <address> Washington USA, </address> <year> 1986. </year>
Reference-contexts: As a consequence, the typing of IQL is similar with that of query languages in [55, 3, 5] and corresponds to strong typing in programming languages. A number of recent language proposals in this area do not have these properties. For example, in <ref> [23, 62, 58, 56] </ref> there is no instance-schema separation and the query languages can be viewed as untyped extensions of Prolog. We give brief overviews (by example) of the structural and operational parts of our data model. The detailed definitions are in Sections 2 and 3, respectively. <p> Note that this is essentially equivalent to using Skolem functors in oid's denotation as introduced by <ref> [62] </ref>, and refined for instance in [45, 56, 57]. In a Skolem based approach, one would instead use a rule such as: R 0 (x; f ( x); f 0 (x)) R o (x) where f (x); f 0 (x) would denote the two new oid's.
Reference: [63] <author> D. Maier, A. Otis, A. Purdy. </author> <title> Development of an Object-Oriented Dbms. </title> <journal> Quarterly Bulletin of IEEE on Database Engineering, </journal> <volume> 8, </volume> <year> 1985. </year>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49].
Reference: [64] <author> A. Mendelzohn, G. A. Mihaila, and T. Milo. </author> <title> Querying the world wide web, </title> <note> 1996. draft, available by ftp: milo@math.tau.ac.il. </note>
Reference-contexts: The modelisation of data using objects and graph structures has become one of the major directions of research for modern databases notably influenced by the problem of accessing data on the World Wide Web. A number of languages have been proposed, e.g., <ref> [12, 20, 34, 65, 59, 64] </ref>.
Reference: [65] <author> A. O. Mendelzon and P. T. Wood. </author> <title> Finding regular simple paths in graph databases. </title> <journal> SIAM J. Comp., </journal> <volume> 24(6), </volume> <year> 1995. </year>
Reference-contexts: The modelisation of data using objects and graph structures has become one of the major directions of research for modern databases notably influenced by the problem of accessing data on the World Wide Web. A number of languages have been proposed, e.g., <ref> [12, 20, 34, 65, 59, 64] </ref>.
Reference: [66] <author> A. Ohori. </author> <title> Semantics of Types for Database Objects&lt;/B&gt;. </title> <journal> Theoretical Computer Science, </journal> <volume> 76(1), </volume> <pages> pp. 53-91, </pages> <year> 1990. </year>
Reference-contexts: To do that, one need to use the regularity of the values in the class. An example of such an approach can be found in <ref> [66] </ref>. 8 Conclusions We have extended the techniques of database theory in order to understand the concepts of "object-identity, types and type inheritance" in object-oriented databases. "Methods, method inheritance and encapsulation" are also important elements of an object-oriented 45 database system and have parallels in programming languages, e.g., abstract types.
Reference: [67] <author> H. Schek, M. Scholl. </author> <title> The Relational Model with Relation-valued Attributes. </title> <booktitle> Information Systems, </booktitle> <year> 1986. </year>
Reference-contexts: At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., <ref> [3, 68, 46, 51, 67, 71] </ref>, and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. <p> One can show that each COL query can be computed using an IQL program. The proof is easy given the above programs for nest/unnest. As a consequence, all algebraic operations on complex objects of <ref> [68, 46, 67, 3] </ref>, and the calculus queries of [3, 51] are expressible in IQL. Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL.
Reference: [68] <author> S.J. Thomas, </author> <title> P.C. Fischer. Nested Relational Structures. </title> <booktitle> In Advances in Computing Research, </booktitle> <volume> Vol. 3, </volume> <booktitle> the Theory of Databases, </booktitle> <publisher> JAI press, </publisher> <pages> 269-308, </pages> <year> 1986. </year>
Reference-contexts: At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., <ref> [3, 68, 46, 51, 67, 71] </ref>, and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis. <p> One can show that each COL query can be computed using an IQL program. The proof is easy given the above programs for nest/unnest. As a consequence, all algebraic operations on complex objects of <ref> [68, 46, 67, 3] </ref>, and the calculus queries of [3, 51] are expressible in IQL. Also, it is easy to show that all calculus and algebra queries in LDM can be simulated in IQL.
Reference: [69] <author> J.D. Ullman. </author> <title> Database Theory Past and Future. </title> <booktitle> In Proc. ACM PODS, </booktitle> <pages> 1-10, </pages> <year> 1987. </year>
Reference-contexts: Our analysis allows us to show that IQL can serve as a language for this model as well. Object identities, in this context, loose all semantic denotation to become purely, primitives of the language. This is a nontrivial link between value-based and object-based <ref> [69] </ref>. A value-based point of view can be used to understand pure-values (no oid's) and equality-by-value (as a coercion mechanism for realizing inheritance). There are aspects of object-oriented database systems that our mathematical model cannot capture.
Reference: [70] <author> J.D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volume I. </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: More generally, the integration of programming languages and database systems is an important research activity. Unfortunately, the understanding of the "principles of object-oriented databases" is still rather limited. This is in marked contrast with the relational model [35] that is now equipped with an elegant and relevant theory <ref> [16, 70, 47] </ref>. This paper together with papers such as [21, 39] or [29] participate in clarifying some of the foundations of object-oriented databases.
Reference: [71] <author> J. Verso. Verso: </author> <title> a Database Machine Based on non-1NF Relations. </title> <type> INRIA Technical Report, </type> <year> 1986. </year> <title> (the Verso team). Also in Nested Relations and Complex Objects, </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: At an intuitive level, oid's are "typed pointers" and IQL is based on a controlled use of indirection. The structural part of the object-based model described here is a synthesis of elements that existed in the literature. It generalizes the relational data model [35], most complex-object data models, e.g., <ref> [3, 68, 46, 51, 67, 71] </ref>, and the logical data model (LDM) [55, 53]. It can be viewed as the common upper bound of the models used in [55, 3]. The pleasant surprise is that little mathematical simplicity had to be traded-off in order to achieve this synthesis.
Reference: [72] <author> S. Zdonik. </author> <title> Object Management Systems for Design Environments. </title> <journal> Quarterly Bulletin of IEEE on Database Engineering, </journal> <volume> 8, </volume> <year> 1985. </year> <month> 51 </month>
Reference-contexts: Somewhere in between, some constructors proposed the so-called object-relational systems that provide richer modeling facilities than traditional relational systems. The integration of objects in databases in these various contexts has been the focus of a great deal of experimentation and research since the late eighties, e.g., <ref> [11, 63, 72, 18, 41, 32, 24] </ref>. (See, e.g., recent issues of ACM SIGMOD Conference on the Management of Data.) These developments in databases are largely based on concepts and software tools from object-oriented programming, e.g., [42, 17, 49].
References-found: 72

