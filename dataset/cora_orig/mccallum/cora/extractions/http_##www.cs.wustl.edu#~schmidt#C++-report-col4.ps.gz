URL: http://www.cs.wustl.edu/~schmidt/C++-report-col4.ps.gz
Refering-URL: http://www.acl.lanl.gov/CORBA/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: schmidt@cs.wustl.edu vinoski@ch.hp.com  
Title: Object Interconnections Comparing Alternative Server Programming Techniques (Column 4)  
Author: Douglas C. Schmidt Steve Vinoski 
Date: October  
Note: An earlier version of this column appeared in the  1995 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 Chelmsford, MA 01824  
Affiliation: Department of Computer Science Hewlett-Packard Company Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> A Domain Analysis of Network Daemon Design Dimensions, </title> <journal> C++ Report, </journal> <volume> vol. 6, </volume> <month> March/April </month> <year> 1994. </year>
Reference-contexts: Therefore, the server must be capable of receiving client requests over multiple connections without blocking indefinitely on any single connection. A related topic that server programmers must address is concurrency. The two primary types of server concurrency strategies <ref> [1, 2] </ref> are distinguished as follows: * Iterative servers which handle each client request before servicing subsequent requests. While processing the current request, an iterative server typically queues new client requests. An iterative design is most suitable for short-duration services that exhibit relatively little variation in their execution time. <p> Note that data events are demultiplexed using a round-robin scheduling policy that dispatches the handle quote function in order of ascending HANDLE values. int main (int argc, char *argv []) - u_short port /* Port to listen for connections. */ = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 10000; /* Create a passive-mode listener endpoint. */ HANDLE listener = create_server_endpoint (port); HANDLE maxhp1 = listener + 1; /* fd_sets maintain a set of HANDLEs that select () uses to wait for events. */ fd_set read_hs, temp_hs; FD_ZERO (&read_hs); FD_ZERO (&temp_hs); FD_SET (listener, &read_hs); for (;;) - HANDLE <p> For example, one common variant looks like this: int main (int argc, char *argv []) - u_short port /* Port to listen for connections. */ = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 10000; /* Create a passive-mode listener endpoint. */ HANDLE listener = create_server_endpoint (port); for (;;) - HANDLE h = accept (listener, 0, 0); handle_quote (h); close (h); - /* NOTREACHED */ - In this variant, the server is iterative with respect to both accepting connections and request processing. <p> The main function uses the components defined above to implement the quote server: int main (int argc, char *argv []) - u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 10000; // Event demultiplexer. Reactor reactor; // Factory that produces Quote_Handlers.
Reference: [2] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Therefore, the server must be capable of receiving client requests over multiple connections without blocking indefinitely on any single connection. A related topic that server programmers must address is concurrency. The two primary types of server concurrency strategies <ref> [1, 2] </ref> are distinguished as follows: * Iterative servers which handle each client request before servicing subsequent requests. While processing the current request, an iterative server typically queues new client requests. An iterative design is most suitable for short-duration services that exhibit relatively little variation in their execution time. <p> The select call provides coarse-grained concur-rency control that serializes event handling within a process or thread. This eliminates the need for more complicated threading, synchronization, or locking within our server. In-depth coverage of sockets and select appears in <ref> [2] </ref>. In future columns we'll discuss how to extend our solutions to incorporate more sophisticated concurrency and demulti plexing strategies. 1 3 The Socket Server Solution 3.1 Socket/C Code The following code illustrates how to program the server-side of the stock quote program using sockets, select, and C.
Reference: [3] <author> D. E. Comer and D. L. Stevens, </author> <title> Internetworking with TCP/IP Vol III: Client Server Programming and Applications. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Naturally, this works since the handle quote function only processes with a single request at a time. 2 There are other variants of iterative servers <ref> [3] </ref>.
Reference: [4] <author> D. C. Schmidt, </author> <title> The Reactor: An Object-Oriented Interface for Event-Driven UNIX I/O Multiplexing (Part 1 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: In addition to these activities, the server must also perform demultiplexing and concurrency. Directly programming select to demultiplex events is particularly problematic <ref> [4] </ref>. The select call requires programmers to explicitly handle many low-level details involving bitmasks, descriptor counts, time-outs, and signals. <p> C++ wrappers encapsulate lower-level network programming interfaces such as sockets and select with type-safe, object-oriented interfaces. The IPC SAP [5], Reactor <ref> [4, 6] </ref>, and Acceptor [7] C++ wrappers shown below are part of the ACE object-oriented network programming toolkit. <p> Moreover, we eliminate several common programming errors by not using select directly <ref> [4] </ref>. * Improve portability by shielding applications from platform-specific network programming interfaces. Wrapping sockets with C++ classes (rather than standalone C functions) makes it easy to switch wholesale between different network programming interfaces simply by changing the parameterized types to the Acceptor template.
Reference: [5] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: C++ wrappers encapsulate lower-level network programming interfaces such as sockets and select with type-safe, object-oriented interfaces. The IPC SAP <ref> [5] </ref>, Reactor [4, 6], and Acceptor [7] C++ wrappers shown below are part of the ACE object-oriented network programming toolkit.
Reference: [6] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: C++ wrappers encapsulate lower-level network programming interfaces such as sockets and select with type-safe, object-oriented interfaces. The IPC SAP [5], Reactor <ref> [4, 6] </ref>, and Acceptor [7] C++ wrappers shown below are part of the ACE object-oriented network programming toolkit.
Reference: [7] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Actively and Passively Initializing Network Services, </title> <booktitle> in Workshop on Pattern Languages of Object-Oriented Programs at ECOOP '95, </booktitle> <address> (Aarhus, Denmark), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: C++ wrappers encapsulate lower-level network programming interfaces such as sockets and select with type-safe, object-oriented interfaces. The IPC SAP [5], Reactor [4, 6], and Acceptor <ref> [7] </ref> C++ wrappers shown below are part of the ACE object-oriented network programming toolkit.
Reference: [8] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Reactor pointers. virtual QUOTE_HANDLER *make_svc_handler (void) - return new QUOTE_HANDLER (db_, reactor_); - private: Quote_Database *db_; Reactor *reactor_; - A more dynamically extensible method of selecting be tween sockets or TLI can be achieved via inheritance and dynamic binding by using the Abstract Factory or Factory Method patterns described in <ref> [8] </ref>. An advantage of using parameterized types, however, is that they improve run-time efficiency. For example, parameterized types avoid the over head of virtual method dispatching and allow compilers to in line frequently accessed methods.
Reference: [9] <author> D. C. Schmidt and P. Stephenson, </author> <title> Using Design Patterns to Evolve System Software from UNIX to Windows NT, </title> <journal> C++ Report, </journal> <volume> vol. 7, </volume> <month> March/April </month> <year> 1995. </year>
Reference-contexts: Moreover, the code is more portable since the server no longer accesses select directly. For example, the Reactor can be implemented with other event demultiplexing system calls (such as SVR4 UNIX poll, WIN32 WaitForMultipleObjects, or even separate threads) <ref> [9] </ref>. * Increase reusability and extensibility the Reactor, Quote Acceptor, and Quote Handler components are not as tightly coupled as the version in Section 3.1. Therefore, it is easier to extend the C++ solution to include new services, as well as to enhance existing services.
Reference: [10] <author> C. Horn, </author> <title> The Orbix Architecture, </title> <type> tech. rep., </type> <institution> IONA Technologies, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The exact details will vary depending on the ORB implementation and the desired concurrency strategy (e.g., thread-per-object, thread-per-request, etc.). However, most multi-threaded versions of CORBA (such as MT Orbix <ref> [10] </ref>) require only a few extra lines of code. In contrast, transforming the C or C++ versions to concurrent servers will require more work. A forthcoming column will illustrate the different strategies required to multi-thread each version. Our previous column also described the primary drawbacks to using CORBA.
Reference: [11] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: A forthcoming column will illustrate the different strategies required to multi-thread each version. Our previous column also described the primary drawbacks to using CORBA. Briefly, these drawbacks include the high learning curve for developing and managing distributed objects effectively, performance limitations <ref> [11] </ref>, as well as the lack of portability and security. One particularly problematic drawback for servers is that the BOA is not specified very thoroughly by the CORBA 2.0 specification [12]. The BOA specification is probably the weakest area of CORBA 2.0.
Reference: [12] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: Briefly, these drawbacks include the high learning curve for developing and managing distributed objects effectively, performance limitations [11], as well as the lack of portability and security. One particularly problematic drawback for servers is that the BOA is not specified very thoroughly by the CORBA 2.0 specification <ref> [12] </ref>. The BOA specification is probably the weakest area of CORBA 2.0. For example, the body of the My Quoter::get quote method in Section 5.3 is mostly portable. However, the name of the automatically-generated skeleton base class and the implementation of main remain very ORB-specific.
References-found: 12

