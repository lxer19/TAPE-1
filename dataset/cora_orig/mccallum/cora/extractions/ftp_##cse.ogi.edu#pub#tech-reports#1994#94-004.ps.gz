URL: ftp://cse.ogi.edu/pub/tech-reports/1994/94-004.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: sheard@cse.ogi.edu fegaras@cse.ogi.edu  
Title: Optimizing Algebraic Programs OGI, Tech-report #94-004  
Author: Tim Sheard Leonidas Fegaras 
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: This paper considers a programming language where all control is encoded in algebras and combinators over algebras. This language supports higher levels of abstraction than traditional functional languages and is amenable to calculation based optimization. Three well known transformations are illustrated. Each one, requiring varying levels of insight and creativity over ordinary functional programs, can be fully automated in an algebraic language. The algorithm encoding these transformations is presented. This algorithm is an improvement over our previous work since it works over a richer, more expressive language, encodes more transformations, and is more efficient.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Darlington and R. Burstall. </author> <title> A System which Automatically Improves Programs. </title> <journal> Acta Informatica, </journal> <volume> 6(1) </volume> <pages> 41-60, </pages> <year> 1976. </year>
Reference-contexts: It is our belief that additional generic strategies can strengthen our algorithm. 2 Three Transformations In the this section we quickly outline three transformations in terms of traditional functional programming. The first two were first described over traditional functional programs by Burstall and Darlington <ref> [1] </ref>, the third is a generic construction of distributive laws we believe is new in any context.
Reference: [2] <author> W. Chin. </author> <title> Safe Fusion of Functional Expressions. </title> <booktitle> In Proc. 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, Ca., </address> <month> June </month> <year> 1992. </year>
Reference-contexts: First, it is based upon the hom promotion theorem rather than red, second it computes over a richer language, and terminates over the complete language rather than a syntactically identifiable subset. This algorithm automates deforestation [8, 20, 19] and fusion <ref> [2] </ref> for algebraic programs. From the promotion theorems we know only the property that the h i 's should obey, not how to compute them. The following construction is the basis for the normalization algorithm. <p> first)); (g i ffi (E$c i (id; second)) i; : : :g P x The explicit nature of control in algebraic programs make it possible to recognize and combine two traversals over a single data structure into a single traversal by inspection. 5.3 Generating Distribution Laws for Zero Replacements Chin <ref> [2] </ref> relates how the use of laws may improve the deforestation process. We illustrated this in Section 2.3. The explicit structure of algebraic programs makes it possible to calculate some of the necessary laws on demand. <p> technique allows us to calculate such laws as map f (x @ y) = (map f x) @ (map f y) length (x @ y) = (length x) + (length y) rev (x @ y) = (rev x) @ (rev y) This makes possible the automatic fusion of unsafe terms <ref> [2] </ref>, such as map f (rev x) without the need of any additional laws as was illustrated in Section 2.3 above. 6 Applicability of Algebraic Programs and Future Work The wide spread use of algebraic programming will depend upon several factors. <p> This is handled by the normalization algorithm by essentially skipping over the offending term. Wadlers language may encode algorithms which induct over several objects simultaneously which cannot be handled by the algebraic language described here. Chin's work on fusion <ref> [2] </ref> extends Wadler's work on deforestation. He generalizes Wadler's techniques to all first order programs, not just treeless ones, by recognizing and skipping over terms to which his techniques do not apply in much the same manner the normalization algorithm does.
Reference: [3] <author> J. Cockett and D. Spencer. </author> <title> Strong Categorical Datatypes I. </title> <editor> In R. Seely, editor, </editor> <booktitle> International Meeting on Category Theory 1991, Canadian Mathematical Society Proceedings, </booktitle> <volume> Vol. 13, </volume> <pages> pp 141-169. </pages> <publisher> AMS, </publisher> <address> Montreal, </address> <year> 1992. </year>
Reference-contexts: Our implementation of ADL is the result of the influence of ideas from several areas. First, work by Malcom [14], Meijer, Fokkinga, and Paterson [15, 9], and Cockett <ref> [3, 4] </ref> which describe how to capture patterns of recursion for a large class of algebraic types in a uniform way.
Reference: [4] <author> J. Cockett and T. </author> <type> Fukushima. </type> <institution> About Charity The University of Calgary, Department of Computer Science, </institution> <note> Research Report No. 92/480/18. </note> <month> June </month> <year> 1992. </year>
Reference-contexts: Our implementation of ADL is the result of the influence of ideas from several areas. First, work by Malcom [14], Meijer, Fokkinga, and Paterson [15, 9], and Cockett <ref> [3, 4] </ref> which describe how to capture patterns of recursion for a large class of algebraic types in a uniform way.
Reference: [5] <author> L. Fegaras. </author> <title> A Transformational Approach to Database System Implementation. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of Massachusetts, Amherst, </institution> <month> February </month> <year> 1993. </year> <note> Also appeared as CMPSCI Technical Report 92-68. </note>
Reference-contexts: Such optimizations are amenable to automation, whereas languages which allow arbitrary recursive programs lack the structure necessary for this kind of automation without expensive analysis. The contributions of this paper are several. First we extend our earlier work <ref> [5, 6, 17] </ref> by embedding our optimizations in a richer language, and describe an improved algorithm for computing them. Our previous work focused on a restricted language which has now been extended to include all the features of a modern functional programming language. <p> Many of the theorems which our transformation algorithms are based upon can be found here, second, our previous work on type reflection [13, 16], and our work on program normalization <ref> [5, 6, 17] </ref>. 8 Conclusion The formalism outlined above combining normalization, Zr law calculation, and the tupling lemma with beta and eta contraction provides a theoretical basis for calculation based transformations.
Reference: [6] <author> L. Fegaras, T. Sheard, and D. Stemple. </author> <title> Uniform Traversal Combinators: Definition, Use and Properties. In Proceedings of the 11th International Conference on Automated our red k our hom with a simple algebra where all operators are replaced by their free constructors. </title> <booktitle> 12 Deduction (CADE-11), </booktitle> <address> Saratoga Springs, New York, </address> <pages> pp 148-162. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Such optimizations are amenable to automation, whereas languages which allow arbitrary recursive programs lack the structure necessary for this kind of automation without expensive analysis. The contributions of this paper are several. First we extend our earlier work <ref> [5, 6, 17] </ref> by embedding our optimizations in a richer language, and describe an improved algorithm for computing them. Our previous work focused on a restricted language which has now been extended to include all the features of a modern functional programming language. <p> Many of the theorems which our transformation algorithms are based upon can be found here, second, our previous work on type reflection [13, 16], and our work on program normalization <ref> [5, 6, 17] </ref>. 8 Conclusion The formalism outlined above combining normalization, Zr law calculation, and the tupling lemma with beta and eta contraction provides a theoretical basis for calculation based transformations.
Reference: [7] <author> L. Fegaras, T. Sheard and T. Zhou. </author> <title> Improving Programs which Recurse over Multiple Inductive Structures. </title> <institution> Oregon Graduate Institute, </institution> <note> Technical report #94-005 A version of this paper is ftp-able from cse.ogi.edu:/pub/pacsoft/papers/ImpProgRecMult.ps. Submitted to PEPM'94. </note>
Reference-contexts: This makes algorithms as simple natural number subtraction resort to arcane tricks or be simply unencodable. We would like to encode simple algorithms such as equality, unification, zip, and the nth element of a list function algebraically, and for these functions to be amenable to automatic transformations. Elsewhere <ref> [7] </ref> we report initial results on encoding these functions algebraically by generalizing the E$c i functors and the combinators.
Reference: [8] <author> A. Ferguson, and P. Wadler. </author> <title> When will Deforestation Stop. </title> <booktitle> In Proc. of 1988 Glasgow Workshop on Functional Programming (also as research report 89/R4 of Glasgow University), </booktitle> <pages> pp 39-56, </pages> <address> Rothesay, Isle of Bute, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: It based upon the algorithm of [17] extended in the following ways. First, it is based upon the hom promotion theorem rather than red, second it computes over a richer language, and terminates over the complete language rather than a syntactically identifiable subset. This algorithm automates deforestation <ref> [8, 20, 19] </ref> and fusion [2] for algebraic programs. From the promotion theorems we know only the property that the h i 's should obey, not how to compute them. The following construction is the basis for the normalization algorithm. <p> His techniques apply only to traversals of linear data structures such as lists, vectors, and streams. It is also related to Wadler's work on listlessness, and deforestation <ref> [19, 20, 8] </ref>. Deforestation works on all first order treeless terms. Treelessness is a syntactic property which guarantees that terms can be unfolded without introducing infinite regress.
Reference: [9] <editor> M.M. </editor> <booktitle> Fokkinga Calculate Categorically! Formal Aspects of Computing(1992) Vol 4, </booktitle> <pages> pp 673-692. </pages>
Reference-contexts: Our implementation of ADL is the result of the influence of ideas from several areas. First, work by Malcom [14], Meijer, Fokkinga, and Paterson <ref> [15, 9] </ref>, and Cockett [3, 4] which describe how to capture patterns of recursion for a large class of algebraic types in a uniform way.
Reference: [10] <editor> M.M. Fokkinga, Tupling and Mutamorphisms, </editor> <booktitle> The Squiggolist, </booktitle> <month> 1(4) </month> <year> 1989. </year>
Reference-contexts: 1 + yg x; red [list]f$nil := 0; $cons := (x; y) : x + yg x) This example transforms into red [list]f$nil := (0; 0); $cons := (x; (u; v)) : (1 + u; x + v)g x A general formula for this transformation is called the Tupling lemma <ref> [10] </ref>.
Reference: [11] <author> A. Gill, J. Launchbury, and S. </author> <title> Peyton Jones A Short Cut to Deforestation In Proceedings of the conference on Functional Programming and Computer Architecture, </title> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year> <pages> pp 223-232 </pages>
Reference-contexts: Those not removed are recognizable and are simply "skipped" over in the improvement phase. Our normalization algorithm needs no explicit higher order removal phase, and invents laws on the fly that Chin's algorithm must know a priori. Gill, Launchbury and Jones <ref> [11] </ref> describe a deforestation algorithm currently used in the 11 Glasgow Haskell compiler. It uses two combinators fold and build k , and a higher order theorem which relates the composition of the two.
Reference: [12] <author> R. Kieburtz and J. Lewis. </author> <title> Algebraic Design Language (Preliminary Definition). </title> <type> Technical Report #94-002, </type> <institution> Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: fl Tim Sheard is supported in part by a contract with Air Force Material Command (F19628-93-C-0069). y Leonidas Fegaras is supported by the Advanced Research Projects Agency, ARPA order number 18, moni tored by the US Army Research Laboratory under contract DAAB-07-91-C-Q518. 1 Second, we report on an actual implementation <ref> [12] </ref> which includes a user oriented front-end as well as our optimizing back-end, and a compiler. Experiments with our implementation illustrate that is feasible, practical, and beneficial to program in an algebraic style. <p> The combinators include map, reduction (fold,catamorphism), primitive recursion (paramor-phism), derive (unfold, anamorphism), and hom (hylomorphism), as well as the duals of these combinators (cohom etc.) and mechanism for interpreting all these morphisms in an arbitrary monad. We will not discuss these additional mechanisms here <ref> [12] </ref>. When a combinator is applied to an algebra specification the returned morphism obeys a set of recursive equations particular to that algebra.
Reference: [13] <author> J. Hook, R. Kieburtz, and T. Sheard. </author> <title> Generating Programs by Reflection. </title> <type> Oregon Graduate Institute Technical Report 92-015, </type>
Reference-contexts: A function h (x; y) = Zr y x is associative ( h (w; h (x; y)) = h (h (w; x); y) ), and has the zero, Z, for both a left and right identity ( h (x; Z) = x and h (Z; y) = y ) <ref> [13] </ref>. Recognize that Zr list is the list append operator, and that Zr nat is natural number addition. 9 We postulate that zero replacement functions have an additional important property: 8 f * red [T ]; 9 g : f ffi (Zr y) = g ffi f . <p> Many of the theorems which our transformation algorithms are based upon can be found here, second, our previous work on type reflection <ref> [13, 16] </ref>, and our work on program normalization [5, 6, 17]. 8 Conclusion The formalism outlined above combining normalization, Zr law calculation, and the tupling lemma with beta and eta contraction provides a theoretical basis for calculation based transformations.
Reference: [14] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 335-347. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: The user may use the simpler combinators which are translated by the compiler into hom. 6 4 The Promotion Theorem. The promotion theorem for red describes the conditions under which the composition of a function g with a red can be expressed as another red <ref> [14, 15] </ref>. For a list algebra the theorem is given below. n () = g (f n ()) g (red [list]ff n ; f c g x) = red [list]f n ; c g x A similar theorem can be expressed for every signature. <p> Our implementation of ADL is the result of the influence of ideas from several areas. First, work by Malcom <ref> [14] </ref>, Meijer, Fokkinga, and Paterson [15, 9], and Cockett [3, 4] which describe how to capture patterns of recursion for a large class of algebraic types in a uniform way.
Reference: [15] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The user may use the simpler combinators which are translated by the compiler into hom. 6 4 The Promotion Theorem. The promotion theorem for red describes the conditions under which the composition of a function g with a red can be expressed as another red <ref> [14, 15] </ref>. For a list algebra the theorem is given below. n () = g (f n ()) g (red [list]ff n ; f c g x) = red [list]f n ; c g x A similar theorem can be expressed for every signature. <p> Our implementation of ADL is the result of the influence of ideas from several areas. First, work by Malcom [14], Meijer, Fokkinga, and Paterson <ref> [15, 9] </ref>, and Cockett [3, 4] which describe how to capture patterns of recursion for a large class of algebraic types in a uniform way.
Reference: [16] <author> Tim Sheard. </author> <title> Type parametric programming. </title> <type> Technical Report 93-018, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Many of the theorems which our transformation algorithms are based upon can be found here, second, our previous work on type reflection <ref> [13, 16] </ref>, and our work on program normalization [5, 6, 17]. 8 Conclusion The formalism outlined above combining normalization, Zr law calculation, and the tupling lemma with beta and eta contraction provides a theoretical basis for calculation based transformations.
Reference: [17] <author> Tim Sheard and Leonidas Fegaras. </author> <title> A fold for all seasons. </title> <booktitle> In Proceedings of the conference on Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Such optimizations are amenable to automation, whereas languages which allow arbitrary recursive programs lack the structure necessary for this kind of automation without expensive analysis. The contributions of this paper are several. First we extend our earlier work <ref> [5, 6, 17] </ref> by embedding our optimizations in a richer language, and describe an improved algorithm for computing them. Our previous work focused on a restricted language which has now been extended to include all the features of a modern functional programming language. <p> It based upon the algorithm of <ref> [17] </ref> extended in the following ways. First, it is based upon the hom promotion theorem rather than red, second it computes over a richer language, and terminates over the complete language rather than a syntactically identifiable subset. This algorithm automates deforestation [8, 20, 19] and fusion [2] for algebraic programs. <p> Many of the theorems which our transformation algorithms are based upon can be found here, second, our previous work on type reflection [13, 16], and our work on program normalization <ref> [5, 6, 17] </ref>. 8 Conclusion The formalism outlined above combining normalization, Zr law calculation, and the tupling lemma with beta and eta contraction provides a theoretical basis for calculation based transformations.
Reference: [18] <author> T. Sheard and L. Fegaras. </author> <title> Optimizing Algebraic Programs. OGI, </title> <note> Tech-report #94-004. The Extended version of this paper. Ftp-able from cse.ogi.edu:/pub/pacsoft/papers/OptAlgProg.ps. Submitted to PEPM'94. </note>
Reference-contexts: A proof of correctness of the normalization algorithm can be found in a technical report <ref> [18] </ref>. 8 5.2 Simultaneous Traversal and the Tupling Lemma Algebraic programs make it easy to recognize situations where simultaneous traversal is applicable.
Reference: [19] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness: Lazy Evaluation and Garbage Collection at Compile-time. </title> <booktitle> In Proc. of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin Texas, </address> <month> August, </month> <year> 1984. </year> <month> 13 </month>
Reference-contexts: It based upon the algorithm of [17] extended in the following ways. First, it is based upon the hom promotion theorem rather than red, second it computes over a richer language, and terminates over the complete language rather than a syntactically identifiable subset. This algorithm automates deforestation <ref> [8, 20, 19] </ref> and fusion [2] for algebraic programs. From the promotion theorems we know only the property that the h i 's should obey, not how to compute them. The following construction is the basis for the normalization algorithm. <p> His techniques apply only to traversals of linear data structures such as lists, vectors, and streams. It is also related to Wadler's work on listlessness, and deforestation <ref> [19, 20, 8] </ref>. Deforestation works on all first order treeless terms. Treelessness is a syntactic property which guarantees that terms can be unfolded without introducing infinite regress.
Reference: [20] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Proceedings of the 2nd European Symposium on Programming, </booktitle> <address> Nancy, France, </address> <month> March </month> <year> 1988. </year> <note> Lecture Notes in Computer Science 300. </note>
Reference-contexts: It based upon the algorithm of [17] extended in the following ways. First, it is based upon the hom promotion theorem rather than red, second it computes over a richer language, and terminates over the complete language rather than a syntactically identifiable subset. This algorithm automates deforestation <ref> [8, 20, 19] </ref> and fusion [2] for algebraic programs. From the promotion theorems we know only the property that the h i 's should obey, not how to compute them. The following construction is the basis for the normalization algorithm. <p> His techniques apply only to traversals of linear data structures such as lists, vectors, and streams. It is also related to Wadler's work on listlessness, and deforestation <ref> [19, 20, 8] </ref>. Deforestation works on all first order treeless terms. Treelessness is a syntactic property which guarantees that terms can be unfolded without introducing infinite regress.
Reference: [21] <author> R. Waters. </author> <title> Automatic Transformation of Series Expressions into Loops, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 52-98, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: These generalizations have promotion like theorems but while our experience with generic transformations is limited, our results so far have been quite encouraging. 7 Related Work This work is related to Water's on series expressions <ref> [21] </ref>. His techniques apply only to traversals of linear data structures such as lists, vectors, and streams. It is also related to Wadler's work on listlessness, and deforestation [19, 20, 8]. Deforestation works on all first order treeless terms.
References-found: 21

