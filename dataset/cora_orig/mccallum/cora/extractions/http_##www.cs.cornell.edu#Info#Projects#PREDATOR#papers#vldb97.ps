URL: http://www.cs.cornell.edu/Info/Projects/PREDATOR/papers/vldb97.ps
Refering-URL: http://www.cs.cornell.edu/Info/Projects/PREDATOR/docs.html
Root-URL: 
Email: praveen@cs.cornell.edu  miron@cs.wisc.edu  raghu@cs.wisc.edu  
Title: The Case for Enhanced Abstract Data Types  
Author: Praveen Seshadri Miron Livny Raghu Ramakrishnan 
Address: Ithaca, NY  U.Wisconsin, Madison WI  U.Wisconsin, Madison WI  
Affiliation: Computer Science Department Cornell University,  Computer Sciences Department  Computer Sciences Department  
Abstract: The explosion in complex multi-media content makes it crucial for database systems to support such data efficiently. We make the case that the next generation of object-relational database systems should be based on Enhanced Abstract Data Type (E-ADT) technology, rather than on the blackbox ADTs used in current systems. An E-ADT is an abstract data type that exposes the semantics of its methods. Query optimizations are performed using these semantics, resulting in efficient query processing. The added functionality does not compromise the modularity of data types and the extensibility of the type system. Fundamental architectural changes are required to build such a database system; these have been explored through the implementation of E-ADTs in Predator. Initial performance results demonstrate an order of magnitude in performance improvements.
Abstract-found: 1
Intro-found: 1
Reference: [AF95] <author> Karl Aberer and Gisela Fischer. </author> <title> Semantic Query Optimization for Methods in Object Oriented Database Systems. </title> <booktitle> In Proceedings of the Eleventh IEEE Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <pages> pages 70-79, </pages> <year> 1995. </year>
Reference-contexts: There is a notion of a common object algebra, and every complex type expands (or reveals) its methods into expressions in the common algebra. In contrast, E-ADTs can use individual algebras to represent query plans for their expressions, since there is no notion of a global query optimizer. In <ref> [AF95] </ref>, the actual method code was analyzed to determine the meaning of the method, which was then used in query optimization. We believe that this approach is not viable; most complex data types will be developed in some imperative programming language like C++ or Java.
Reference: [Bla96] <author> Jose Blakeley. </author> <title> Data Access for the Masses through OLE-DB. </title> <booktitle> In Proceedings of ACM SIGMOD '96 International Conference on Management of Data, </booktitle> <address> Montreal, Canada, </address> <pages> pages 161-172, </pages> <year> 1996. </year>
Reference-contexts: The rules are syntactic, and cost-based optimization is performed after an exhaustive application of the rules. Several distributed object broker architectures like CORBA and OLE have recently emerged. The capabilities of distributed objects are described using a common interface. The OLE-DB standard being promoted by Mi-crosoft <ref> [Bla96] </ref> supports the notion of a component database system with well-defined interfaces between different modular components. However, there is a distinction between exporting query capabilities, and exposing query optimization semantics (as E-ADTs do).
Reference: [Cat94] <author> R.G.G. Cattell. </author> <title> The Object Database Standard:ODMB-93. </title> <address> Morgan-Kaufman, </address> <year> 1994. </year>
Reference-contexts: Much of the work in object-oriented query optimization has focused on issues like path expressions [CD92] and not on method expressions, although [CD92] recognizes that methods can be very expensive and merit further attention. While the OQL query language <ref> [Cat94] </ref> for OO databases does permit a method to have several implementations, it does not suggest a mechanism for choosing between these implementations. We direct readers to [MDK + 94] for an excellent survey of work on query optimization for complex data types in OO-DBMSs.
Reference: [CD92] <author> S. Cluet and C. Delobel. </author> <title> A General Framework for the Optimization of Object-Oriented Queries. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <pages> pages 383-392, </pages> <year> 1992. </year>
Reference-contexts: Object-Oriented Databases: Early work on semantic data models incorporated domain semantics into relational query optimization. More recently, the OO-DBMS community has been exploring techniques to optimize queries involving complex objects. Much of the work in object-oriented query optimization has focused on issues like path expressions <ref> [CD92] </ref> and not on method expressions, although [CD92] recognizes that methods can be very expensive and merit further attention. While the OQL query language [Cat94] for OO databases does permit a method to have several implementations, it does not suggest a mechanism for choosing between these implementations. <p> More recently, the OO-DBMS community has been exploring techniques to optimize queries involving complex objects. Much of the work in object-oriented query optimization has focused on issues like path expressions <ref> [CD92] </ref> and not on method expressions, although [CD92] recognizes that methods can be very expensive and merit further attention. While the OQL query language [Cat94] for OO databases does permit a method to have several implementations, it does not suggest a mechanism for choosing between these implementations.
Reference: [CDF + 94] <author> M.J. Carey, D.J. DeWitt, M.J. Franklin, N.E. Hall, M. McAuliffe, J.F. Naughton, D.T. Schuh, M.H. Solomon, C.K. Tan, O. Tsatalos, S. White, and M.J. Zwilling. </author> <title> Shoring Up Persistent Objects. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <pages> pages 526-541, </pages> <year> 1994. </year>
Reference-contexts: The core of the system is a main-memory table in which E-ADTs are registered. The server is built on top of a layer of common database utilities that all E-ADTs can use. An important component of the utility layer is the SHORE Storage Manager <ref> [CDF + 94] </ref> library, which provides facilities for 5 Predator stands for the PRedator Enhanced DAta Type Object Relational DBMS persistent storage, concurrency control, recovery and buffer management. Some of the basic types like integers do not support any enhancements.
Reference: [CDY95] <author> Surajit Chaudhuri, Umeshwar Dayal, and Tak Yan. </author> <title> Join Queries with External Text Sources: Execution and Optimization Techniques. </title> <booktitle> In Proceedings of ACM SIGMOD '95 International Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <pages> pages 410-422, </pages> <year> 1995. </year>
Reference-contexts: However, with E-ADTs , this is indeed feasible. Since E-ADT expressions are expensive, where should they be placed in the SQL query evaluation plan? Expensive function placement has traditionally been studied purely in a tuple-at-a-time execution context [Hel95, CS96], with caching of function results (an exception to this is <ref> [CDY95] </ref>). The assumption has been that every ADT function has a fixed cost specified in the system catalogs. This assumption is not valid when ADT expressions are being optimized.
Reference: [CS93] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Query Optimization in the Presence of Foreign Functions. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Databases (VLDB), Dublin, Ireland, </booktitle> <pages> pages 526-541, </pages> <year> 1993. </year>
Reference-contexts: In fact, we can make the interesting case that the E-ADT paradigm provides an excellent argument in favor of optimizer toolkits in general, and rule-based optimizer toolkits [GM93] in particular! Since the DBMS has several mini-optimizers, one in each E-ADT, a toolkit for optimizer generation is needed. <ref> [CS93] </ref> suggests that queries involving foreign relations can be optimized by specifying the semantics of the foreign relations through high-level rules. The rules are syntactic, and cost-based optimization is performed after an exhaustive application of the rules. Several distributed object broker architectures like CORBA and OLE have recently emerged.
Reference: [CS96] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Optimization of Queries with User-Defined Predicates. </title> <booktitle> In Proceedings of the Twenty Second International Conference on Very Large Databases (VLDB), Bombay, India, </booktitle> <pages> pages 87-98, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: plan should be chosen before the query starts executing, because it is unreasonable to repeatedly explore the options at runtime. * The cost of the chosen plan is used by the SQL optimizer to place the evaluation of the expression at the appro priate position in the join evaluation tree <ref> [Hel95, CS96] </ref>. * In order to perform compile-time optimization, collective meta-information like the storage formats and size statistics need to be maintained over all the pertinent images (in this case, over all photographs in the GeoData table). * The meta-information maintained and the optimizations to be applied are specific to each <p> However, with E-ADTs , this is indeed feasible. Since E-ADT expressions are expensive, where should they be placed in the SQL query evaluation plan? Expensive function placement has traditionally been studied purely in a tuple-at-a-time execution context <ref> [Hel95, CS96] </ref>, with caching of function results (an exception to this is [CDY95]). The assumption has been that every ADT function has a fixed cost specified in the system catalogs. This assumption is not valid when ADT expressions are being optimized.
Reference: [CZ96] <author> Mitch Cherniak and Stanley Zdonik. </author> <title> Rule Languages and Internal Algebras for Rule-Based Optimizers. </title> <booktitle> In Proceedings of ACM SIGMOD '96 International Conference on Management of Data, </booktitle> <address> Montreal, Canada, </address> <year> 1996. </year>
Reference-contexts: We believe that this approach is not viable; most complex data types will be developed in some imperative programming language like C++ or Java. Instead, we allow the E-ADT developer to explicitly specify the method semantics. Other Related Work: Rule-based query optimizers have received much attention recently <ref> [GM93, CZ96] </ref>. A common misconception is that a rule-based optimizer instantiated with the appropriate rules (in this case, with rules for E-ADT optimizations) provides all that E-ADTs do. <p> Instead of breaking a query into many components with local query optimization on each E-ADT ex pression, these approaches try to find a global solution. This requires that the entire query be modeled in an integrated framework. AQUA [SLVZ95] and KOLA <ref> [CZ96] </ref> are algebraic frameworks proposed for this purpose, while CPL/Kleisli [Won94] is a framework based on comprehensions as a query language and monadic operations. These are all frameworks for collection types (like sets, bags, lists, and arrays).
Reference: [DKL + 94] <author> D.J. DeWitt, N. Kabra, J. Luo, J.M. Patel, and J. Yu. </author> <title> Client-Server Paradise. </title> <booktitle> In Proceedings of the Twentieth International Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The Clip method is then applied with the intermediate result image as its input. This input image is decompressed to a main-memory form, it is clipped to the desired dimensions, and the resulting image is written out to disk. Current OR-DBMSs like Illustra [Ill94] and Paradise <ref> [DKL + 94] </ref> use essentially this approach with some individual modifications; we mention these variations at length in Section 5. One could improve this execution strategy as follows: * It is unnecessary for Sharpen to compress and write its result to disk. <p> For example, with the popular JPEG compression technique, the entire image needs to be retrieved sequentially. There are other compression techniques and variants of JPEG that allow a selective portion of the image to be retrieved and decompressed. <ref> [DKL + 94] </ref> discusses these issues in more detail. * Pipelining: Pipelining execution of methods to avoid materializing intermediate results. This is crucial for large data types like audio and video. It may not be possible to fit an entire uncompressed audio (or video) object in memory. <p> The main improvements allow functions to retain the results in main-memory, or to present an iterator interface that helps pipelined execution as well as parallel execution. Transformational and Constraint optimizations are not supported. The Paradise System: Among current research systems, the Paradise client-server DBMS <ref> [DKL + 94] </ref> is developing ADT extensions for the parallel execution of methods on spatial, geographic, and scientific data. This work concentrates on issues of scalable parallelism and the use of tertiary storage for large ADTs.
Reference: [GM93] <author> G. Graefe and W. J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the Ninth IEEE Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <year> 1993. </year>
Reference-contexts: We believe that this approach is not viable; most complex data types will be developed in some imperative programming language like C++ or Java. Instead, we allow the E-ADT developer to explicitly specify the method semantics. Other Related Work: Rule-based query optimizers have received much attention recently <ref> [GM93, CZ96] </ref>. A common misconception is that a rule-based optimizer instantiated with the appropriate rules (in this case, with rules for E-ADT optimizations) provides all that E-ADTs do. <p> Our work differs in that it is focused on complex data type expressions, rather than relational expressions. In fact, we can make the interesting case that the E-ADT paradigm provides an excellent argument in favor of optimizer toolkits in general, and rule-based optimizer toolkits <ref> [GM93] </ref> in particular! Since the DBMS has several mini-optimizers, one in each E-ADT, a toolkit for optimizer generation is needed. [CS93] suggests that queries involving foreign relations can be optimized by specifying the semantics of the foreign relations through high-level rules.
Reference: [Gut77] <author> J. Guttag. </author> <title> Abstract Data Types and the Development of Data Structures. </title> <journal> Communications of the ACM, </journal> <month> June </month> <year> 1977. </year>
Reference-contexts: The basic technology used is that of Abstract Data Types (ADTs), which was adapted from programming language concepts <ref> [Gut77, LZ74] </ref> to databases in the 1980s [SRG83, Sto86] in the Postgres [SRH90] system. The DBMS maintains a table of ADTs, and new ADTs may be added by a database developer. Each ADT implements a common internal interface through which the system can access and manipulate values of that type. <p> We should note that method transformations of the kind suggested in this paper are common in the functional programming community. The pipelining optimizations are similar to the use of lazy evaluation [Jon87]. While the early work on ADTs <ref> [Gut77] </ref> did emphasize the equational theory of the methods, this aspect was not carried into the use of ADTs in database systems. Our work corrects this oversight, and focused on optimizations based on statistics and costs in a database environment.
Reference: [Hel95] <author> Joseph M. Hellerstein. </author> <title> Optimization and Execution Techniques for Queries With Expensive Methods. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: plan should be chosen before the query starts executing, because it is unreasonable to repeatedly explore the options at runtime. * The cost of the chosen plan is used by the SQL optimizer to place the evaluation of the expression at the appro priate position in the join evaluation tree <ref> [Hel95, CS96] </ref>. * In order to perform compile-time optimization, collective meta-information like the storage formats and size statistics need to be maintained over all the pertinent images (in this case, over all photographs in the GeoData table). * The meta-information maintained and the optimizations to be applied are specific to each <p> The Postgres project explored issues dealing with the storage and indexed retrieval of ADTs. It also stressed that functions associated with ADTs could be expensive, and that special relational optimization techniques are necessary when such functions are present <ref> [Hel95] </ref>. The basic ADT approach described in Section 2 corresponds closely to Illustra's support for ADTs. The results of every ADT method are written to disk, and no inter-method optimizations are considered [Ols96]. While Illustra does have a rule engine, it is not used to apply optimization rules. <p> However, with E-ADTs , this is indeed feasible. Since E-ADT expressions are expensive, where should they be placed in the SQL query evaluation plan? Expensive function placement has traditionally been studied purely in a tuple-at-a-time execution context <ref> [Hel95, CS96] </ref>, with caching of function results (an exception to this is [CDY95]). The assumption has been that every ADT function has a fixed cost specified in the system catalogs. This assumption is not valid when ADT expressions are being optimized.
Reference: [Ill94] <institution> Illustra Information Technologies, Inc, </institution> <address> 1111 Broadway, Suite 2000, Oakland, CA 94607. </address> <note> Illustra User's Guide, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: The Clip method is then applied with the intermediate result image as its input. This input image is decompressed to a main-memory form, it is clipped to the desired dimensions, and the resulting image is written out to disk. Current OR-DBMSs like Illustra <ref> [Ill94] </ref> and Paradise [DKL + 94] use essentially this approach with some individual modifications; we mention these variations at length in Section 5. One could improve this execution strategy as follows: * It is unnecessary for Sharpen to compress and write its result to disk. <p> Postgres, Illustra, and Informix: The issue of support for ADTs in relational database systems was first explored in [SRG83] and [Sto86]. This led to the development of the Postgres research DBMS [SRH90] and its commercial version, Illustra <ref> [Ill94] </ref>. The Postgres project explored issues dealing with the storage and indexed retrieval of ADTs. It also stressed that functions associated with ADTs could be expensive, and that special relational optimization techniques are necessary when such functions are present [Hel95].
Reference: [Jon87] <editor> S.L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: However, there is a distinction between exporting query capabilities, and exposing query optimization semantics (as E-ADTs do). We should note that method transformations of the kind suggested in this paper are common in the functional programming community. The pipelining optimizations are similar to the use of lazy evaluation <ref> [Jon87] </ref>. While the early work on ADTs [Gut77] did emphasize the equational theory of the methods, this aspect was not carried into the use of ADTs in database systems. Our work corrects this oversight, and focused on optimizations based on statistics and costs in a database environment.
Reference: [LV91] <author> R.S.G. Lanzelotte and P. Valduriez. </author> <title> Extending the Search Strategy in a Query Optimizer. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <pages> pages 363-373, </pages> <year> 1991. </year>
Reference-contexts: On the other hand, conventional rule-based optimizer proposals do not have such notions of optimization locality. The closest in spirit are the region architecture for query optimizers proposed in [MDZ93], the module architecture proposed in [SS90], and other research on extensible search strategies <ref> [RH87, LV91] </ref>. Our work differs in that it is focused on complex data type expressions, rather than relational expressions.
Reference: [LZ74] <author> B. Liskov and S. Zilles. </author> <title> Programming with Abstract Data Types. </title> <journal> In SIGPLAN Notices, </journal> <month> April </month> <year> 1974. </year>
Reference-contexts: The basic technology used is that of Abstract Data Types (ADTs), which was adapted from programming language concepts <ref> [Gut77, LZ74] </ref> to databases in the 1980s [SRG83, Sto86] in the Postgres [SRH90] system. The DBMS maintains a table of ADTs, and new ADTs may be added by a database developer. Each ADT implements a common internal interface through which the system can access and manipulate values of that type.
Reference: [MDK + 94] <author> D. Maier, S. Daniels, T. Keller, B. Vance, G. Graefe, and W. McKenna. </author> <title> Challenges for Query Processing in Object-Oriented Databases, chapter 12. Query Processing for Advanced Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year> <title> Editor: Freytag, Maier and Vossen. </title>
Reference-contexts: While the OQL query language [Cat94] for OO databases does permit a method to have several implementations, it does not suggest a mechanism for choosing between these implementations. We direct readers to <ref> [MDK + 94] </ref> for an excellent survey of work on query optimization for complex data types in OO-DBMSs. Most closely related to E-ADTs is the REVELATION project [MDK + 94] which correctly identifies that the semantics of methods should be revealed to the query optimizer. <p> We direct readers to <ref> [MDK + 94] </ref> for an excellent survey of work on query optimization for complex data types in OO-DBMSs. Most closely related to E-ADTs is the REVELATION project [MDK + 94] which correctly identifies that the semantics of methods should be revealed to the query optimizer. There is a notion of a common object algebra, and every complex type expands (or reveals) its methods into expressions in the common algebra.
Reference: [MDZ93] <author> Gail Mitchell, Umeshwar Dayal, and Stanley Zdonik. </author> <title> Control of an Extensible Query Optimizer: A Planning-Based Approach. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Databases (VLDB), Dublin, Ireland, </booktitle> <pages> pages 517-528, </pages> <year> 1993. </year>
Reference-contexts: On the other hand, conventional rule-based optimizer proposals do not have such notions of optimization locality. The closest in spirit are the region architecture for query optimizers proposed in <ref> [MDZ93] </ref>, the module architecture proposed in [SS90], and other research on extensible search strategies [RH87, LV91]. Our work differs in that it is focused on complex data type expressions, rather than relational expressions.
Reference: [Ols96] <author> Mike Olson, </author> <year> 1996. </year> <type> Personal Communication. </type>
Reference-contexts: The basic ADT approach described in Section 2 corresponds closely to Illustra's support for ADTs. The results of every ADT method are written to disk, and no inter-method optimizations are considered <ref> [Ols96] </ref>. While Illustra does have a rule engine, it is not used to apply optimization rules. Currently, Illustra's technology has been integrated with the Informix Universal Server and extended to exploit parallelism. Several modifications are being made to improve the evaluation of ADT expressions [Ols96]. <p> and no inter-method optimizations are considered <ref> [Ols96] </ref>. While Illustra does have a rule engine, it is not used to apply optimization rules. Currently, Illustra's technology has been integrated with the Informix Universal Server and extended to exploit parallelism. Several modifications are being made to improve the evaluation of ADT expressions [Ols96]. The main improvements allow functions to retain the results in main-memory, or to present an iterator interface that helps pipelined execution as well as parallel execution. Transformational and Constraint optimizations are not supported.
Reference: [RH87] <author> A. Rosenthal and P. Helman. </author> <title> Understanding and Extending Transformation-Based Optimizers. </title> <journal> Database Engineering, </journal> <volume> 9(4) </volume> <pages> 44-51, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: On the other hand, conventional rule-based optimizer proposals do not have such notions of optimization locality. The closest in spirit are the region architecture for query optimizers proposed in [MDZ93], the module architecture proposed in [SS90], and other research on extensible search strategies <ref> [RH87, LV91] </ref>. Our work differs in that it is focused on complex data type expressions, rather than relational expressions.
Reference: [SFGM93] <author> Michael Stonebraker, James Frew, Kenn Gardels, and Jeff Meredith. </author> <title> The Sequoia 2000 Storage Benchmark. </title> <booktitle> In Proceedings of ACM SIGMOD '93 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <pages> pages 2-11, </pages> <year> 1993. </year>
Reference-contexts: Consequently, opportunities to optimize method expressions often exist. There are two other cases where E-ADT optimizations can be beneficial. * Aggregates: Aggregate methods are very important in summarization queries involving multi-media data types. For example, the Sequoia benchmark <ref> [SFGM93] </ref> includes a query that computes a weighted average of a number of clipped raster images.
Reference: [SLR97] <author> Praveen Seshadri, Miron Livny, and Raghu Ramakrish-nan. </author> <title> The Case for Enhanced Abstract Data Types. </title> <type> Technical Report TR-97-1619, </type> <institution> Cornell University, Computer Science Department, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Current OR-DBMSs do not perform such optimizations; further, they lack the structural framework to do so. In contrast, Predator is a practical demonstration of an architectural framework in which E-ADT optimizations may be applied. While the low-level implementation details are described in <ref> [SLR97] </ref>, this paper describes the high-level system design. 3 Predator and E-ADTs An Enhanced Abstract Data Type (E-ADT) enhances the concept of blackbox ADTs in database systems to improve the performance of query processing. <p> Some existing OR-DBMS systems already support this feature. Predator 5 is a client-server OR-DBMS in which the server is a loosely-coupled system of E-ADTs. A detailed description of the system is presented in <ref> [SLR97] </ref>. The high-level picture of the system is shown in Figure 1. The core of the system is a main-memory table in which E-ADTs are registered. The server is built on top of a layer of common database utilities that all E-ADTs can use.
Reference: [SLVZ95] <author> Bharati Subramaniam, Theodore Leung, Scott Vanden-berg, and Stanley Zdonik. </author> <title> The AQUA Approach to Querying Lists and Trees in Object-Oriented Databases. </title> <booktitle> In Proceedings of the Eleventh IEEE Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Instead of breaking a query into many components with local query optimization on each E-ADT ex pression, these approaches try to find a global solution. This requires that the entire query be modeled in an integrated framework. AQUA <ref> [SLVZ95] </ref> and KOLA [CZ96] are algebraic frameworks proposed for this purpose, while CPL/Kleisli [Won94] is a framework based on comprehensions as a query language and monadic operations. These are all frameworks for collection types (like sets, bags, lists, and arrays).
Reference: [SRG83] <author> M. Stonebraker, B. Rubenstein, and A. Guttman. </author> <title> Application of Abstract Data Types and Abstract Indices to CAD Data Bases. </title> <booktitle> In Proceedings of the Engineering Applications Stream of Database Week, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1983. </year>
Reference-contexts: The basic technology used is that of Abstract Data Types (ADTs), which was adapted from programming language concepts [Gut77, LZ74] to databases in the 1980s <ref> [SRG83, Sto86] </ref> in the Postgres [SRH90] system. The DBMS maintains a table of ADTs, and new ADTs may be added by a database developer. Each ADT implements a common internal interface through which the system can access and manipulate values of that type. <p> The effort required to add a traditional ADT (with no E-ADT enhancements) to Predator is just the same as the effort required to add an ADT to a standard OR-DBMS. Postgres, Illustra, and Informix: The issue of support for ADTs in relational database systems was first explored in <ref> [SRG83] </ref> and [Sto86]. This led to the development of the Postgres research DBMS [SRH90] and its commercial version, Illustra [Ill94]. The Postgres project explored issues dealing with the storage and indexed retrieval of ADTs.
Reference: [SRH90] <author> Michael Stonebraker, Lawrence Rowe, and Michael Hi-rohama. </author> <title> The Implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The basic technology used is that of Abstract Data Types (ADTs), which was adapted from programming language concepts [Gut77, LZ74] to databases in the 1980s [SRG83, Sto86] in the Postgres <ref> [SRH90] </ref> system. The DBMS maintains a table of ADTs, and new ADTs may be added by a database developer. Each ADT implements a common internal interface through which the system can access and manipulate values of that type. <p> Postgres, Illustra, and Informix: The issue of support for ADTs in relational database systems was first explored in [SRG83] and [Sto86]. This led to the development of the Postgres research DBMS <ref> [SRH90] </ref> and its commercial version, Illustra [Ill94]. The Postgres project explored issues dealing with the storage and indexed retrieval of ADTs. It also stressed that functions associated with ADTs could be expensive, and that special relational optimization techniques are necessary when such functions are present [Hel95].
Reference: [SS90] <author> Edward Sciore and John Sieg. </author> <title> A Modular Query Optimizer Generator. </title> <booktitle> In Proceedings of the Sixth IEEE Conference on Data Engineering, </booktitle> <pages> pages 146-153, </pages> <year> 1990. </year>
Reference-contexts: On the other hand, conventional rule-based optimizer proposals do not have such notions of optimization locality. The closest in spirit are the region architecture for query optimizers proposed in [MDZ93], the module architecture proposed in <ref> [SS90] </ref>, and other research on extensible search strategies [RH87, LV91]. Our work differs in that it is focused on complex data type expressions, rather than relational expressions.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of New Types in Relational Data Base Systems. </title> <booktitle> In Proceedings of the Second IEEE Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <year> 1986. </year>
Reference-contexts: The basic technology used is that of Abstract Data Types (ADTs), which was adapted from programming language concepts [Gut77, LZ74] to databases in the 1980s <ref> [SRG83, Sto86] </ref> in the Postgres [SRH90] system. The DBMS maintains a table of ADTs, and new ADTs may be added by a database developer. Each ADT implements a common internal interface through which the system can access and manipulate values of that type. <p> Postgres, Illustra, and Informix: The issue of support for ADTs in relational database systems was first explored in [SRG83] and <ref> [Sto86] </ref>. This led to the development of the Postgres research DBMS [SRH90] and its commercial version, Illustra [Ill94]. The Postgres project explored issues dealing with the storage and indexed retrieval of ADTs.
Reference: [Won94] <author> Limsoon Wong. </author> <title> Querying Nested Collections. </title> <type> PhD thesis, </type> <institution> U.Pennsylvania, </institution> <year> 1994. </year>
Reference-contexts: This requires that the entire query be modeled in an integrated framework. AQUA [SLVZ95] and KOLA [CZ96] are algebraic frameworks proposed for this purpose, while CPL/Kleisli <ref> [Won94] </ref> is a framework based on comprehensions as a query language and monadic operations. These are all frameworks for collection types (like sets, bags, lists, and arrays). However, many important complex data types including multi-media types do not fall in this category.
References-found: 29

