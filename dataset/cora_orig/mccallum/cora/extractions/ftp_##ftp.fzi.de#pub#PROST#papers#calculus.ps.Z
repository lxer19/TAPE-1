URL: ftp://ftp.fzi.de/pub/PROST/papers/calculus.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Email: sekerinski@fzi.de  
Title: A Calculus for Predicative Programming  
Author: Emil Sekerinski 
Address: Haid-und-Neu Strasse 10-14, 7500 Karlsruhe, Germany,  
Affiliation: Forschungszentrum Informatik Karlsruhe,  
Abstract: A calculus for developing programs from specifications written as predicates that describe the relationship between the initial and final state is proposed. Such specifications are well known from the specification language Z. All elements of a simple sequential programming notation are defined in terms of predicates. Hence programs form a subset of specifications. In particular, sequential composition is defined by 'demonic composition', nondeterministic choice by 'demonic disjunction', and iteration by fixed points. Laws are derived which allow proving equivalence and refinement of specifications and programs. The weakest precondition is expressed by sequential composition. The approach is compared to the predicative programming approach of E. Hehner and to other refinement calculi. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Back, R. J. R. </author> <title> A Calculus of Refinement for Program Derivations. </title> <note> Acta Informatica 23 (1988). </note>
Reference-contexts: For example, &gt; acts as the identity of composition, rather than II, and equality and refinement of operations have to take the alphabet (set of all free variables) into account. We arrive at a similar set of laws as the refinement calculi of R. J. Back <ref> [1] </ref>, C. Morgan [12, 13], and J. Morris [14] do. Apart from the notational difference, these calculi include miracles. For example, Morgan writes specifications of the form x : [pre; post], with pre a predicate over the initial state and post a predicate over initial and final state.
Reference: 2. <author> Dijkstra, E. W. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: They are called demonic operators, as if several possibilities for execution exist, the implementor is free to choose one arbitrarily (and we have to be prepared that always the worst one is chosen). This approach leads to a nice way for expressing Dijkstras <ref> [2] </ref> weakest preconditions wp (P; b): Let b be a condition, i.e. a specification over the initial state only. P generalized to the case that it is a specification, not necessarily a program. The meaning of wp (P; b) is given by sequential composition P ; b.
Reference: 3. <author> Dijkstra, E. W. and C. S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <publisher> Springer- Verlag, </publisher> <year> 1990. </year>
Reference-contexts: C: (8c j c 2 C p (c)) , (8c j c 2 C (8d j d 2 C ^ d &lt; c p (d)) ) p (c))) (8) "Principle of mathematical induction" (set C is well-founded) , (mathematical induction over C is valid) The definitions above are taken from <ref> [3] </ref>, where also a proof of the principle of mathematical induction is given.
Reference: 4. <author> Gravell, A. </author> <title> Constructive Refinement of First Order Specifications. </title> <booktitle> to appear in Proceedings of the 5th Refinement Workshop, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: 5. <author> Hehner, E. C. R. </author> <title> Predicative Programming Parts I and II. </title> <journal> Communications of the ACM 27, </journal> <month> 2 </month> <year> (1984). </year>
Reference-contexts: In this report, the programming notation consists of assignment, sequential composition, conditional, nondeterministic choice, variable declaration, and iteration. The predicative programming approach was originally proposed by Eric Hehner in <ref> [5] </ref> for both a sequential and concurrent programming notation, and later refined in [6], [7], and [8]. <p> However, it is not easy to give a recursion theorem similar to the iteration theorem. Finally, we have only treated operational refinement and left out data refinement, which is the subject of our further research. 18 Closely related to our work is the predicative programming approach of E. Hehner <ref> [5, 6, 7, 8] </ref>. A difference is that in Hehners approach specifications have to be total in order to be implementable. With this restriction, sequential composition is defined by relational composition and nondeterministic choice by disjunction. Refinement is given by (converse) implication.
Reference: 6. <author> Hehner, E. C. R., L. E. Gupta, and A. J. Malton. </author> <title> Predicative Methodology. </title> <note> Acta Informatica 23 (1986). </note>
Reference-contexts: In this report, the programming notation consists of assignment, sequential composition, conditional, nondeterministic choice, variable declaration, and iteration. The predicative programming approach was originally proposed by Eric Hehner in [5] for both a sequential and concurrent programming notation, and later refined in <ref> [6] </ref>, [7], and [8]. <p> However, it is not easy to give a recursion theorem similar to the iteration theorem. Finally, we have only treated operational refinement and left out data refinement, which is the subject of our further research. 18 Closely related to our work is the predicative programming approach of E. Hehner <ref> [5, 6, 7, 8] </ref>. A difference is that in Hehners approach specifications have to be total in order to be implementable. With this restriction, sequential composition is defined by relational composition and nondeterministic choice by disjunction. Refinement is given by (converse) implication.
Reference: 7. <author> Hehner, E. C. R. </author> <title> Termination is Timing. </title> <editor> In J. L. A. van de Snepscheut (Ed.) </editor> <booktitle> Mathematics of Program Construction, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In this report, the programming notation consists of assignment, sequential composition, conditional, nondeterministic choice, variable declaration, and iteration. The predicative programming approach was originally proposed by Eric Hehner in [5] for both a sequential and concurrent programming notation, and later refined in [6], <ref> [7] </ref>, and [8]. <p> However, it is not easy to give a recursion theorem similar to the iteration theorem. Finally, we have only treated operational refinement and left out data refinement, which is the subject of our further research. 18 Closely related to our work is the predicative programming approach of E. Hehner <ref> [5, 6, 7, 8] </ref>. A difference is that in Hehners approach specifications have to be total in order to be implementable. With this restriction, sequential composition is defined by relational composition and nondeterministic choice by disjunction. Refinement is given by (converse) implication.
Reference: 8. <author> Hehner, E. C. R. </author> <booktitle> A Practical Theory of Programming Science of Computer Programming 14, </booktitle> <month> 2 </month> <year> (1990). </year>
Reference-contexts: In this report, the programming notation consists of assignment, sequential composition, conditional, nondeterministic choice, variable declaration, and iteration. The predicative programming approach was originally proposed by Eric Hehner in [5] for both a sequential and concurrent programming notation, and later refined in [6], [7], and <ref> [8] </ref>. <p> However, it is not easy to give a recursion theorem similar to the iteration theorem. Finally, we have only treated operational refinement and left out data refinement, which is the subject of our further research. 18 Closely related to our work is the predicative programming approach of E. Hehner <ref> [5, 6, 7, 8] </ref>. A difference is that in Hehners approach specifications have to be total in order to be implementable. With this restriction, sequential composition is defined by relational composition and nondeterministic choice by disjunction. Refinement is given by (converse) implication.
Reference: 9. <author> Hoare, C. A. R. and He Jifeng. </author> <note> The weakest prespecification. Fundamenta Informaticae 9 (1986). </note>
Reference-contexts: Hence, we may impose the restriction that if an initial state relates to ?, it relates to everything else as well. This is, for example, the approach taken by Hoare et al. in [10] and <ref> [9] </ref>. The correspondence between that model and the model taken here is that an initial state which relates to ? corresponds to an undefined initial state and vice versa, leaving all other initial states unmodified. <p> We should also note that the refinement calculi stress, as indicated by the name, refinement rather than equivalence. Here we have tried to give rules which allow for stating equivalence whenever it holds. After all, it is important to understand which expressions denote the same value. In <ref> [9] </ref> a comprehensive set of equivalence laws for straight line programming operators are given. All these laws hold in our framework as well, and we have given additionally a law for the equivalence of iterations.
Reference: 10. <author> Hoare, C. A. R., I. J. Hayes, He Jifeng, C. C. Morgan, A. W. Roscoe, J. W. Sanders, I. H. Sorensen, J. M. Spivey, and B. A. Sufrin. </author> <title> Laws of Programming. </title> <journal> Communications of the ACM 30, </journal> <month> 8 </month> <year> (1987). </year>
Reference-contexts: In the proof, we concentrate rather on the programming calculus than on the problem domain used for this example. We also allow the expression e in v := e to be undefined, with the meaning that v := e = e ^ (v := e), as done in <ref> [10] </ref>, for simplifying the formulation of the theorem. (1) "Linear Search Theorem". Let v be an integer variable, and b a function from integer to boolean. <p> Hence, we may impose the restriction that if an initial state relates to ?, it relates to everything else as well. This is, for example, the approach taken by Hoare et al. in <ref> [10] </ref> and [9]. The correspondence between that model and the model taken here is that an initial state which relates to ? corresponds to an undefined initial state and vice versa, leaving all other initial states unmodified. <p> Sequential composition and nondeterministic choice are defined here just in such a way to achieve this correspondence. Hence, all laws given in <ref> [10] </ref> for programs also hold in the calculus presented here. There exist other equivalent semantic models: For example, nondeterministic programs can also be represented by total functions from the state space X to P (X) [ fX [ f?gg or by a set of functions.
Reference: 11. <author> King, S. </author> <title> Z and the Refinement Calculus. </title> <editor> In D. Bjorner, C. A. R. Hoare, J. Langmaack (Eds.) </editor> <title> VDM '90: VDM and Z Formal Methods in Software Development Springer-Verlag, </title> <year> 1990. </year>
Reference-contexts: For each intermediate result, we can state whether it is equivalent to or a refinement of (less than, a subset of, or stronger than) the previous one. 19 Our work is much in the same direction as that of King <ref> [11] </ref>. King proposes a program development which starts with a Z specification and uses the refinement calculus for program development. This requires making a transitions from the Z specification to the refinement notation during the development, which we can avoid in our approach. Acknowledgements.
Reference: 12. <author> Morgan, C. </author> <title> The Specification Statement. </title> <journal> ACM Transactions on Programming Languages and Systems 10,3 (1988). </journal>
Reference-contexts: For example, &gt; acts as the identity of composition, rather than II, and equality and refinement of operations have to take the alphabet (set of all free variables) into account. We arrive at a similar set of laws as the refinement calculi of R. J. Back [1], C. Morgan <ref> [12, 13] </ref>, and J. Morris [14] do. Apart from the notational difference, these calculi include miracles. For example, Morgan writes specifications of the form x : [pre; post], with pre a predicate over the initial state and post a predicate over initial and final state.
Reference: 13. <author> Morgan, C. </author> <title> Programming from Specifications. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: For example, &gt; acts as the identity of composition, rather than II, and equality and refinement of operations have to take the alphabet (set of all free variables) into account. We arrive at a similar set of laws as the refinement calculi of R. J. Back [1], C. Morgan <ref> [12, 13] </ref>, and J. Morris [14] do. Apart from the notational difference, these calculi include miracles. For example, Morgan writes specifications of the form x : [pre; post], with pre a predicate over the initial state and post a predicate over initial and final state.
Reference: 14. <author> Morris, J. M. </author> <title> Programs from Specifications. In Dijkstra, </title> <editor> E. W. (Ed.) </editor> <title> Formal Development of Programs and Proofs. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We arrive at a similar set of laws as the refinement calculi of R. J. Back [1], C. Morgan [12, 13], and J. Morris <ref> [14] </ref> do. Apart from the notational difference, these calculi include miracles. For example, Morgan writes specifications of the form x : [pre; post], with pre a predicate over the initial state and post a predicate over initial and final state.
Reference: 15. <author> Nelson, G. </author> <title> A Generalization of Dijkstra's Calculus. </title> <journal> ACM Transactions on Programming Languages and Systems 11,4 (1989). </journal>
Reference-contexts: A survey of semantic models, which include those for partial correctness and those based on partial relations with ?, can be found in <ref> [15] </ref>. <p> If pre implies the domain of post, this can be expressed in our approach as pre ^ post. Otherwise, the specification is miraculous, which cannot be expressed by our demonic model. Models which include miracles are discussed by Nelson <ref> [15] </ref>. Another difference is that refinement calculi define the meaning of both programs and specifications by weakest preconditions. We define programs by specifications and consider weakest preconditions later on, which seems to be more natural.
Reference: 16. <author> Spivey, J. M. </author> <title> The Z Reference Manual. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Another benefit is that when presenting the calculus, we can start with the specification notation and gradually introduce the programming operators by their definition. For specifications we use a style which is similar to the specification language Z <ref> [16] </ref>. Specifications are basically predicates relating the initial to the final state, given by the values of primed and unprimed symbols respectively. We will use the Z notation whenever appropriate, for example for the predicates and for the refinement relation.
References-found: 16

