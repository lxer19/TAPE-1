URL: http://www.eecs.umich.edu/techreports/cse/1994/CSE-TR-215-94.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse94.html
Root-URL: http://www.eecs.umich.edu
Title: A Flexible Object-Oriented Database Model and Implementation for Capacity-Augmenting Views  
Author: Y. G. Ra, H. A. Kuno, and E. A. Rundensteiner 
Keyword: Object-Slicing Paradigm, Multiple Classification, Dynamic Reclassification, Flexible Restructuring, Migration Paths to Technological Advances, Capacity-Augmenting Views, Object-Oriented Databases.  
Note: This work was supported in part by the NSF RIA grant #IRI-9309076 and the University of Michigan Faculty Award Program. Harumi Kuno is also grateful for support from the NASA Graduate Student Researchers Program.  
Address: 1301 Beal Avenue Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory The University of Michigan,  
Email: e-mail: ygra@eecs.umich.edu, kuno@umich.edu, rundenst@eecs.umich.edu  
Phone: fax: (313) 763-1503 phone: (313) 936-2971  
Date: April, 1994  
Abstract: In this paper, we identify key features required from OODB systems in order to provide support for advanced object-oriented tools that facilitate customized tool integration and transparent changes to database schemata. These features include multiple classification, derived classes, view schemata, dynamic reclassification, and flexible restructuring. Unfortunately, such features are currently not supported by commercial OODBMSs. In fact, in this paper we demonstrate that the object model assumptions underlying most OODB systems, namely, contiguous object layout, fixed typing and upwards inheritance, conflict with the identified requirements. We thus propose a flexible object-oriented modeling approach based on the object-slicing paradigm that overcomes these limitations. We describe a prototype of this object model that we have build on top of the commercial system GemStone to demonstrate the feasibility of our approach. This MultiView prototype realizes all features required for supporting capacity-augmenting views. We also compare and discuss the performance results of MultiView versus GemStone on the OO7 Benchmark. The system now serves as a platform suitable for implementing advanced OODB tools, such as schema evolution tools. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction As views in relational databases successfully provide programmers with the capability to restructure a schema so that it meets the needs of specific applications, a number of researchers have proposed view systems in the context of object-oriented databases (OODBs) <ref> [1, 12, 17, 28, 25, 26] </ref>. However, most of them fail to preserve the advantages of relational views in OODBs. Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. <p> Their proposed virtual schemata behave differently from the real schema, especially regarding the updatability of the view classes and the inheritance of methods and attributes <ref> [1, 32] </ref>. The objectives of this paper are to identify what features must be provided by the underlying object model in order to support object-oriented view schemata that look and feel like (basic) object-oriented schemata and to demonstrate a general methodology for achieving them. <p> The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs [32, 8]. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. Instead, they either advocate downward search for some virtual classes <ref> [32, 1] </ref> or else they statically compile all methods with each virtual class, thus forestalling dynamic inheritance. For example, suppose a virtual class projecting some methods from a base class were to be placed above the base class. <p> In the future, we may also be able to improve upon this cost by maintaining partial caches of methods with classes in order to speed method lookups. 6 Related Work In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 4, 12, 21, 28, 31] </ref>. Below, we first compare other approaches towards view management with the MultiView approach, and then we compare the object-slicing approach used in our implementation with similar approaches. <p> Most of the current proposals for view management systems have not yet been implemented. Furthermore, none of those which have been implemented support all of the features we identify as desirable for view systems (Section 2.2). O2 Views [21] [8], based on Abiteboul and Bonner <ref> [1] </ref>, is the first and only commercial implementation of an object-oriented view management system, currently realized.
Reference: [2] <author> T. Atwood, R. Cattell, J. Duhl, G. Ferran, and D. Wade. </author> <title> The odmg object model. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> pages 64-69, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: J. Kim [14], have been built. Furthermore, the proposed ODMG standard <ref> [2] </ref> recently formulated by several key OODB vendors also follows this approach. 2 Similarly, because object instances that belong to a virtual class should possess the types of both the virtual and the original class, the data model must provide multiple classification.
Reference: [3] <author> J. Banerjee, W. Kim, H. J. Kim, and H. F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 311-322, </pages> <year> 1987. </year>
Reference-contexts: We also demonstrate that a schema evolution system built using a view approach bears many advantages over a version-based approach <ref> [3, 20] </ref> it guarantees that uninvolved views will not be affected by schema change and it allows instance objects to be shared by old and new versions of a schema [24]. This clearly demonstrates the need for developing capacity-augmenting view mechanisms.
Reference: [4] <author> E. Bertino. </author> <title> A view mechanism for object-oriented databases. </title> <booktitle> In 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Traditional views, however, cannot handle all cases of data restructuring; for example, they cannot extend virtual classes with stored data. However, such advanced capability is required if schema versioning based on object-oriented views is to be supported <ref> [4, 24] </ref>. Therefore, we extend the traditional class-restructuring capabilities of views to include the creation of capacity-augmenting virtual classes that augment the information content of classes on which the virtual classes are based on. <p> Then this method should be inherited downwards to all subclasses rather than upwards to all superclasses of the class C. None of the available OODB view systems, however, support uniform inheritance for both virtual and base classes <ref> [4, 8, 32] </ref>. The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs [32, 8]. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. <p> The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy. <p> In the future, we may also be able to improve upon this cost by maintaining partial caches of methods with classes in order to speed method lookups. 6 Related Work In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 4, 12, 21, 28, 31] </ref>. Below, we first compare other approaches towards view management with the MultiView approach, and then we compare the object-slicing approach used in our implementation with similar approaches.
Reference: [5] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The gemstone object database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Unfortunately, such features are currently not supported by commercial OODBMSs <ref> [5, 10, 15, 21] </ref>. In this paper we demonstrate that the object representation assumptions underlying most OODB systems, namely, contiguous object layout, fixed typing and upwards inheritance, conflict with the identified requirements. We then propose a novel object-oriented modeling approach based on the object-slicing paradigm that overcomes these limitations. <p> Classification also requires a more flexible, dynamically changeable class hierarchy than is provided by currently available OODBs, most of which don't allow the insertion of a class into the middle of the hierarchy even if it wouldn't affect the types or extents of existing classes <ref> [5, 23, 9] </ref>. To integrate virtual classes into the global schema, we must be able to insert a newly created virtual class into the global class hierarchy at the proper position.
Reference: [6] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The oo7 benchmark. </title> <booktitle> SIGMOD, </booktitle> <year> 1993. </year>
Reference-contexts: detailed treatment of view materialization issues is beyond the scope of this paper. 5.3 Performance studies using the OO7 benchmark To justify our object-slicing representation paradigm, we have run several test queries from the OO7 benchmark with the goal of comparing GemStone's native implementation versus our MultiView object model implementation <ref> [6] </ref>. GemStone is a Smalltalk-based system while the four systems compared in the OO7 benchmark paper [6, 7] are all C++ based. GemStone thus supports dynamic method resolution, run-time augmentation of the schema with new methods, etc. <p> GemStone is a Smalltalk-based system while the four systems compared in the OO7 benchmark paper <ref> [6, 7] </ref> are all C++ based. GemStone thus supports dynamic method resolution, run-time augmentation of the schema with new methods, etc. For these reasons, we did not compare GemStone against other systems but limited our study to comparing "pure" GemStone with MultiView. <p> First, we compare results for navigation-type queries, e.g., for the "Traversal 1" query, which required more than ten minutes on the average to run. The "Traversal 1" query tests raw pointer traversal speed with a high degree of locality <ref> [6] </ref>. The query requires a traversal of the assembly hierarchy (shown in Figure 11) and performs a depth-first search on each part's graph of atomic parts. For this type of queries, MultiView slightly improved upon GemStone's time (by 4%).
Reference: [7] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The oo7 benchmark. </title> <type> Technical report, </type> <institution> University of Wisconsin-Madison, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: GemStone is a Smalltalk-based system while the four systems compared in the OO7 benchmark paper <ref> [6, 7] </ref> are all C++ based. GemStone thus supports dynamic method resolution, run-time augmentation of the schema with new methods, etc. For these reasons, we did not compare GemStone against other systems but limited our study to comparing "pure" GemStone with MultiView.
Reference: [8] <author> C. Souza dos Santos, S. Abiteboul, and C. Delobel. </author> <title> Virtual schemas and bases. </title> <note> To appear in EDBT '94. </note>
Reference-contexts: Then this method should be inherited downwards to all subclasses rather than upwards to all superclasses of the class C. None of the available OODB view systems, however, support uniform inheritance for both virtual and base classes <ref> [4, 8, 32] </ref>. The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs [32, 8]. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. <p> None of the available OODB view systems, however, support uniform inheritance for both virtual and base classes [4, 8, 32]. The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs <ref> [32, 8] </ref>. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. Instead, they either advocate downward search for some virtual classes [32, 1] or else they statically compile all methods with each virtual class, thus forestalling dynamic inheritance. <p> Most of the current proposals for view management systems have not yet been implemented. Furthermore, none of those which have been implemented support all of the features we identify as desirable for view systems (Section 2.2). O2 Views [21] <ref> [8] </ref>, based on Abiteboul and Bonner [1], is the first and only commercial implementation of an object-oriented view management system, currently realized.
Reference: [9] <editor> O. Deux et al. </editor> <title> The story of o2. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year> <month> 18 </month>
Reference-contexts: Classification also requires a more flexible, dynamically changeable class hierarchy than is provided by currently available OODBs, most of which don't allow the insertion of a class into the middle of the hierarchy even if it wouldn't affect the types or extents of existing classes <ref> [5, 23, 9] </ref>. To integrate virtual classes into the global schema, we must be able to insert a newly created virtual class into the global class hierarchy at the proper position.
Reference: [10] <author> D.H. Fishman. </author> <title> Iris: An object oriented database management system. </title> <journal> In ACM Transactions on Office Information Systems, </journal> <volume> volume 5, </volume> <pages> pages 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Unfortunately, such features are currently not supported by commercial OODBMSs <ref> [5, 10, 15, 21] </ref>. In this paper we demonstrate that the object representation assumptions underlying most OODB systems, namely, contiguous object layout, fixed typing and upwards inheritance, conflict with the identified requirements. We then propose a novel object-oriented modeling approach based on the object-slicing paradigm that overcomes these limitations. <p> To the best of our knowledge, current OODB systems do not support multiple classification | with the exception of IRIS <ref> [10] </ref>, 3 While regular view systems (i.e., that do not support capacity-augmenting views) also must permit an object to be an instance of multiple virtual classes (in addition to its base class), note that virtual classes do not carry any additional stored data and it is thus trivial to make the <p> Rather than use contiguous storage for objects, a MultiView object is distributed among multiple object-slicing implementation objects. The Iris functional database system resembles our implementation in that, being built on top of a relational engine, it distributes data over several relational tables <ref> [10] </ref>. Iris does not support view mechanisms, and does not address issues of classification, inheritance for virtual classes, etc. Most of the current proposals for view management systems have not yet been implemented.
Reference: [11] <author> G. Gottlob, M. Schrefl, and B. Rock. </author> <title> Extending object-oriented systems with roles. </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: However, they do not address the classification of view classes into a global schema, the automatic generation of complete view schemata, nor the implementation of capacity-augmenting views. The object-slicing implementation underlying the current implementation of MultiView can also be compared to mechanisms used in role modeling approaches <ref> [11, 22] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically. <p> This achieves an efficient and uniform inheritance scheme. Also, unlike many role systems, in our implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [11] </ref>. Role systems do not deal with the issues of virtual class derivation, classification, nor with method promotion. Finally, the role system discussed in [11] was implemented using techniques similar to object-slicing. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [11] and our <p> Also, unlike many role systems, in our implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [11] </ref>. Role systems do not deal with the issues of virtual class derivation, classification, nor with method promotion. Finally, the role system discussed in [11] was implemented using techniques similar to object-slicing. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [11] and our implementation is that [11] is a role system while our implementation is a view system. For example, unlike [11], we do not permit entities <p> given type <ref> [11] </ref>. Role systems do not deal with the issues of virtual class derivation, classification, nor with method promotion. Finally, the role system discussed in [11] was implemented using techniques similar to object-slicing. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [11] and our implementation is that [11] is a role system while our implementation is a view system. For example, unlike [11], we do not permit entities to occur several times in the same type of role. Also, the [11] system does not permit the derivation of new virtual classes, thus <p> Finally, the role system discussed in <ref> [11] </ref> was implemented using techniques similar to object-slicing. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [11] and our implementation is that [11] is a role system while our implementation is a view system. For example, unlike [11], we do not permit entities to occur several times in the same type of role. Also, the [11] system does not permit the derivation of new virtual classes, thus not addressing any of the issues <p> the role system discussed in <ref> [11] </ref> was implemented using techniques similar to object-slicing. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [11] and our implementation is that [11] is a role system while our implementation is a view system. For example, unlike [11], we do not permit entities to occur several times in the same type of role. Also, the [11] system does not permit the derivation of new virtual classes, thus not addressing any of the issues related to view management. 7 Conclusions and Future Work In this paper, we have re-examined <p> The difference between <ref> [11] </ref> and our implementation is that [11] is a role system while our implementation is a view system. For example, unlike [11], we do not permit entities to occur several times in the same type of role. Also, the [11] system does not permit the derivation of new virtual classes, thus not addressing any of the issues related to view management. 7 Conclusions and Future Work In this paper, we have re-examined the representation assumptions underlying most OODB systems from the perspective of achieving a flexible and powerful view system.
Reference: [12] <author> S. Heiler and S. B. Zdonik. </author> <title> Object views: Extending the vision. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 86-93, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction As views in relational databases successfully provide programmers with the capability to restructure a schema so that it meets the needs of specific applications, a number of researchers have proposed view systems in the context of object-oriented databases (OODBs) <ref> [1, 12, 17, 28, 25, 26] </ref>. However, most of them fail to preserve the advantages of relational views in OODBs. Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. <p> Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. For example, most systems create only individual virtual classes rather than a complete schema graphs for customized views <ref> [12] </ref>. Even those researchers who have adopted the concept of virtual schemata, that is, customized view class hierarchies over the real schema, do not meet this goal. <p> The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy. <p> In the future, we may also be able to improve upon this cost by maintaining partial caches of methods with classes in order to speed method lookups. 6 Related Work In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 4, 12, 21, 28, 31] </ref>. Below, we first compare other approaches towards view management with the MultiView approach, and then we compare the object-slicing approach used in our implementation with similar approaches.
Reference: [13] <author> H. J. Kim. </author> <title> Issues in Object Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy. <p> Members of our team are currently using this extended architecture as a foundation for quickly constructing advanced OODB tools, such as object-oriented view management systems <ref> [13] </ref> and the Transparent Schema Evolution manager for OODBs [24]. 15 5.2 View updates in object-slicing model In relational systems, updates on views (virtual tables) are usually translated into updates onto the appropriate base relations.
Reference: [14] <author> W. Kim. </author> <title> A model of queries in object-oriented databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 423-432, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Note that although there is no general agreement on whether or not classes in OODBs should incorporate their own extents rather than requiring users to maintain their own collections of class-instances, several systems that follow this philosophy, including Orion and the system proposed by H. J. Kim <ref> [14] </ref>, have been built. <p> The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy.
Reference: [15] <author> W. Kim, J. F. Garza, N. Ballou, and D. Woelk. </author> <title> Architecture of the orion next-generation database system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: Unfortunately, such features are currently not supported by commercial OODBMSs <ref> [5, 10, 15, 21] </ref>. In this paper we demonstrate that the object representation assumptions underlying most OODB systems, namely, contiguous object layout, fixed typing and upwards inheritance, conflict with the identified requirements. We then propose a novel object-oriented modeling approach based on the object-slicing paradigm that overcomes these limitations.
Reference: [16] <author> H. A. Kuno. </author> <title> View management issues in object-oriented databases. Dissertation Proposal, </title> <year> 1994. </year>
Reference-contexts: The proof for this is presented elsewhere <ref> [16] </ref>. 4.3 Construction of view schemata MultiView uses the augmented global schema graph for the selection of both base and virtual classes and for arranging these classes in a consistent class hierarchy, called a view schema.
Reference: [17] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Implementation experience with building an object-oriented view management system. </title> <type> Technical Report CSE-TR-191-93, </type> <institution> University of Michigan, </institution> <address> Ann Arbor, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction As views in relational databases successfully provide programmers with the capability to restructure a schema so that it meets the needs of specific applications, a number of researchers have proposed view systems in the context of object-oriented databases (OODBs) <ref> [1, 12, 17, 28, 25, 26] </ref>. However, most of them fail to preserve the advantages of relational views in OODBs. Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. <p> At each node, we apply the subsumes function to determine the relationship between the newly inserted class and the existing class <ref> [17] </ref>.
Reference: [18] <author> S. Marche. </author> <title> Measuring the Stability of Data Models. </title> <journal> European Journal of Information Systems, </journal> <volume> 2(1) </volume> <pages> 37-47, </pages> <year> 1993. </year>
Reference-contexts: Along with view mechanisms, schema evolution is also an important issue in OODB research, both because data models are less stable than expected <ref> [18] </ref> and also because typical OODB application domains such CAD/CAM and multimedia information systems are not well understood and require frequent schema changes.
Reference: [19] <author> J. Martin and J. Odell. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: They adhere to the invariant that an object belongs to exactly one class only | and indirectly also to all the class's superclasses. We identify two approaches for overcoming this limitation of current OODB systems: (1) the intersection-class approach and (2) the object-slicing approach <ref> [19] </ref>. Both approaches provide explicit support for multiple classification in the object model. In the first approach, whenever an object is an instance of two classes, a new class that is an intersection of the two classes must be created to accommodate the instance.
Reference: [20] <author> M. A. Morsi, S. B. Navath, and H. J. Kim. </author> <title> A schema management and prototyping interface for an object-oriented database environment. </title> <editor> In F. Van Assche, B. Moulin, and C. Rolland, editors, </editor> <booktitle> Object Oriented Approach in Information Systems, </booktitle> <pages> pages 157-180. </pages> <publisher> Elsevier Science Publishers B. V. (North Holland), </publisher> <year> 1991. </year>
Reference-contexts: We also demonstrate that a schema evolution system built using a view approach bears many advantages over a version-based approach <ref> [3, 20] </ref> it guarantees that uninvolved views will not be affected by schema change and it allows instance objects to be shared by old and new versions of a schema [24]. This clearly demonstrates the need for developing capacity-augmenting view mechanisms. <p> This feature of MultiView is significantly different from other approaches. For instance, in <ref> [20] </ref>, the specification of a virtual class (both type and extent) must be dynamically recomputed for each view schema it is inserted in, since, for example, the addition of an is-a relationship may add new inherited attributes to the virtual type.
Reference: [21] <author> O2 Technology. </author> <title> O2 Views User Manual, </title> <note> version 1 edition, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: Unfortunately, such features are currently not supported by commercial OODBMSs <ref> [5, 10, 15, 21] </ref>. In this paper we demonstrate that the object representation assumptions underlying most OODB systems, namely, contiguous object layout, fixed typing and upwards inheritance, conflict with the identified requirements. We then propose a novel object-oriented modeling approach based on the object-slicing paradigm that overcomes these limitations. <p> In the future, we may also be able to improve upon this cost by maintaining partial caches of methods with classes in order to speed method lookups. 6 Related Work In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 4, 12, 21, 28, 31] </ref>. Below, we first compare other approaches towards view management with the MultiView approach, and then we compare the object-slicing approach used in our implementation with similar approaches. <p> Most of the current proposals for view management systems have not yet been implemented. Furthermore, none of those which have been implemented support all of the features we identify as desirable for view systems (Section 2.2). O2 Views <ref> [21] </ref> [8], based on Abiteboul and Bonner [1], is the first and only commercial implementation of an object-oriented view management system, currently realized.
Reference: [22] <author> M. P. Papazoglou. </author> <title> Roles: A methodology for representing multifaceted objects. </title> <booktitle> In International Conference on Database and Expert Systems Applications, </booktitle> <pages> pages 7-12. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, they do not address the classification of view classes into a global schema, the automatic generation of complete view schemata, nor the implementation of capacity-augmenting views. The object-slicing implementation underlying the current implementation of MultiView can also be compared to mechanisms used in role modeling approaches <ref> [11, 22] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically.
Reference: [23] <author> D. J. Penney and J. Stein. </author> <title> Class modification in the gemstone object-oriented dbms. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 111-117, </pages> <year> 1987. </year>
Reference-contexts: Classification also requires a more flexible, dynamically changeable class hierarchy than is provided by currently available OODBs, most of which don't allow the insertion of a class into the middle of the hierarchy even if it wouldn't affect the types or extents of existing classes <ref> [5, 23, 9] </ref>. To integrate virtual classes into the global schema, we must be able to insert a newly created virtual class into the global class hierarchy at the proper position.
Reference: [24] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <type> Technical Report CSE-TR-211-94, </type> <institution> University of Michigan, </institution> <year> 1994. </year>
Reference-contexts: In an earlier paper <ref> [24] </ref>, we show that capacity-augmenting view systems (views that augment the information content of a database by adding stored data in addition to deriving data as a function of already existing data [33]) can be used to achieve transparent schema evolution. <p> We also demonstrate that a schema evolution system built using a view approach bears many advantages over a version-based approach [3, 20] it guarantees that uninvolved views will not be affected by schema change and it allows instance objects to be shared by old and new versions of a schema <ref> [24] </ref>. This clearly demonstrates the need for developing capacity-augmenting view mechanisms. <p> In addition, our architecture is being used to implement a powerful object-oriented view management system (MultiView [26]) and for implementing a transparent schema evolution system (TSE <ref> [24] </ref>) to demonstrate the support our model offers for such systems. In Section 2, we identify the object model requirements for supporting powerful view systems. Section 3 explains the implementation of our object model, and Section 4 the implementation of features that are used for constructing virtual schemata. <p> Traditional views, however, cannot handle all cases of data restructuring; for example, they cannot extend virtual classes with stored data. However, such advanced capability is required if schema versioning based on object-oriented views is to be supported <ref> [4, 24] </ref>. Therefore, we extend the traditional class-restructuring capabilities of views to include the creation of capacity-augmenting virtual classes that augment the information content of classes on which the virtual classes are based on. <p> For the object-slicing approach, the object representation is the same regardless of which resolution scheme is chosen for multiple inheritance. This means that we have the flexibility to adopt various resolution schemes dynamically. Both approaches have their advantages and their disadvantages and a detailed comparison is presented elsewhere <ref> [24] </ref>. We have chosen the object-slicing approach as the basic architecture of our object model because an explosion of intersection classes is likely to be generated in the intersection-class approach. In the worst case, the number of intersection classes could grow exponentially with respect to the number of user-defined classes. <p> Members of our team are currently using this extended architecture as a foundation for quickly constructing advanced OODB tools, such as object-oriented view management systems [13] and the Transparent Schema Evolution manager for OODBs <ref> [24] </ref>. 15 5.2 View updates in object-slicing model In relational systems, updates on views (virtual tables) are usually translated into updates onto the appropriate base relations. Unfortunately, many view queries cannot be unambiguously translated into base queries, and thus relational views are often not updatable.
Reference: [25] <author> E. A. Rundensteiner. </author> <title> A class integration algorithm and its application for supporting consistent object views. </title> <type> Technical Report 92-50, </type> <institution> University of California, Irvine, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction As views in relational databases successfully provide programmers with the capability to restructure a schema so that it meets the needs of specific applications, a number of researchers have proposed view systems in the context of object-oriented databases (OODBs) <ref> [1, 12, 17, 28, 25, 26] </ref>. However, most of them fail to preserve the advantages of relational views in OODBs. Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. <p> We have developed a classification algorithm for MultiView based on type lattice theory that successfully solves this classification problem <ref> [25] </ref>. The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation [25, 4, 12, 13, 14, 28, 32]. <p> The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy. <p> The addition of intermediate classes ensures that a complete global schema can be calculated for any configuration of base and virtual classes with the inform inheritance mechanism outlined above <ref> [25] </ref>. When inserting a new class into the global schema, our classifier creates a set of intermediate classes that is both necessary and sufficient to guarantee the closure of the resulting class hierarchy [25]. <p> be calculated for any configuration of base and virtual classes with the inform inheritance mechanism outlined above <ref> [25] </ref>. When inserting a new class into the global schema, our classifier creates a set of intermediate classes that is both necessary and sufficient to guarantee the closure of the resulting class hierarchy [25]. The creation of intermediate classes is a key feature for achieving the object-slicing paradigm, because it assures a unique source of inheritance for all properties. <p> At each node, we apply the subsumes function to determine the relationship between the newly inserted class and the existing class [17]. The resulting global schema incorporates the virtual class in a consistent and efficient manner, as shown in <ref> [25] </ref>. 4.2.2 Method and attribute promotion As described in Section 2.2, in order to preserve uniform upwards inheritance, it may be necessary to promote methods and/or attributes from a subclass to a new superclass.
Reference: [26] <author> E. A. Rundensteiner. </author> <title> Multiview: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <year> 1992. </year>
Reference-contexts: 1 Introduction As views in relational databases successfully provide programmers with the capability to restructure a schema so that it meets the needs of specific applications, a number of researchers have proposed view systems in the context of object-oriented databases (OODBs) <ref> [1, 12, 17, 28, 25, 26] </ref>. However, most of them fail to preserve the advantages of relational views in OODBs. Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. <p> A key characteristic here is that an object that is a member of both a base and a virtual class can now share data storage at the attribute level, even if materialized. In addition, our architecture is being used to implement a powerful object-oriented view management system (MultiView <ref> [26] </ref>) and for implementing a transparent schema evolution system (TSE [24]) to demonstrate the support our model offers for such systems. In Section 2, we identify the object model requirements for supporting powerful view systems. <p> We present below the procedures by which a virtual class is created in our system, the type determined from the class definition, and the getExtent method implemented. We support an object-preserving object algebra for virtual class specification <ref> [26] </ref>, composed of the following operators: * The select operator defined by (&lt;class&gt; createSelectClass: &lt;new-class-name&gt; query: &lt; predicate &gt;) creates a select virtual class that is a GemStone subclass of the SelectClass meta-class (Figure 8). <p> Unfortunately, many view queries cannot be unambiguously translated into base queries, and thus relational views are often not updatable. Two reasons why object-oriented systems more naturally permit updatable views are that (1) objects have unique, system-generated object identifiers, and (2) class-specific methods are associated with each object <ref> [26] </ref>. An object-oriented query operates upon objects rather than values, so all updates are specified in terms of these object-identifiers. <p> This is one reason why although in relational systems most views are not updatable, in object-oriented systems, a large class of views are updatable (subject to the intentions of the user). Our current MultiView implementation provides fully updatable views, since we utilize an object-preserving algebra for class derivation <ref> [26, 28] </ref>. Because attributes for both base and virtual classes are stored in a single place in our object-slicing model, update methods applied to instances of virtual classes automatically propagate to the classes where the attributes are stored.
Reference: [27] <author> E. A. Rundensteiner. </author> <title> Tools for view generation in oodbs. </title> <booktitle> In ACM 2nd Int. Conf on Information and Knowledge Management (CIKM), </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Because the global schema maintains the relationships between all base and virtual classes, we can generate the view schema relationships in polynomial time. The process of constructing a view schema from a set of classes can be divided into three tasks <ref> [27] </ref>: First, let V = c 1 ; c 2 ; : : : ; c n be the subset of the classes in the global hierarchy chosen to participate in the view schema.
Reference: [28] <author> M. H. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: 1 Introduction As views in relational databases successfully provide programmers with the capability to restructure a schema so that it meets the needs of specific applications, a number of researchers have proposed view systems in the context of object-oriented databases (OODBs) <ref> [1, 12, 17, 28, 25, 26] </ref>. However, most of them fail to preserve the advantages of relational views in OODBs. Specifically, the proposed view systems typically cannot create views such that users perceive them as real database schemas. <p> Finally, most views in relational systems are not updatable due to the update ambiguity problem, but this ambiguity can be overcome in the context of object-oriented systems due to the concepts of object identity <ref> [28] </ref> and of class-specific update methods. View schemata, being updatable, thus behave more like base schemata. 3 The MultiView Object Model and Its Implementation Our goal is to design an object model that supports all required features outlined in Section 2, such as multiple classification, capacity-augmentation, etc. <p> The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy. <p> This is one reason why although in relational systems most views are not updatable, in object-oriented systems, a large class of views are updatable (subject to the intentions of the user). Our current MultiView implementation provides fully updatable views, since we utilize an object-preserving algebra for class derivation <ref> [26, 28] </ref>. Because attributes for both base and virtual classes are stored in a single place in our object-slicing model, update methods applied to instances of virtual classes automatically propagate to the classes where the attributes are stored. <p> In the future, we may also be able to improve upon this cost by maintaining partial caches of methods with classes in order to speed method lookups. 6 Related Work In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 4, 12, 21, 28, 31] </ref>. Below, we first compare other approaches towards view management with the MultiView approach, and then we compare the object-slicing approach used in our implementation with similar approaches. <p> It thus has limited update capabilities. O2 Views does not provide type closure in views, does not support union classes (because of its lack of a type inference mechanism), and does not support capacity-augmenting views. Scholl et al's work on views comes closest to our work <ref> [28, 29] </ref>. They suggest use of an object-preserving subset of their algebra to define virtual classes and thus achieve updatable views. However, they do not address the classification of view classes into a global schema, the automatic generation of complete view schemata, nor the implementation of capacity-augmenting views.
Reference: [29] <author> M. H. Scholl and H. J. Schek. </author> <title> Survey of the cocoon project. </title> <institution> Objektbanken fur Experten, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: It thus has limited update capabilities. O2 Views does not provide type closure in views, does not support union classes (because of its lack of a type inference mechanism), and does not support capacity-augmenting views. Scholl et al's work on views comes closest to our work <ref> [28, 29] </ref>. They suggest use of an object-preserving subset of their algebra to define virtual classes and thus achieve updatable views. However, they do not address the classification of view classes into a global schema, the automatic generation of complete view schemata, nor the implementation of capacity-augmenting views.
Reference: [30] <author> E. Sciore. </author> <title> Object specialization. </title> <journal> ACM Transactions on Information Systems, </journal> <pages> pages 103-122, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: View systems, on the other hand, enable users to restructure the types and class membership of classes based on content-based queries. 17 Unlike many role systems, which allow object hierarchies to exist independently from class hierarchies <ref> [30] </ref>, objects in our implementation always conform to the existing global class hierarchy in that if an object possesses an implementation object of a given class's type, it must also possess an implementation object for every class that is a superclass of that given type.
Reference: [31] <author> J. Shilling and P. Sweeney. </author> <title> Three steps to views: Extending the object-oriented paradigm. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 353 - 361, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In the future, we may also be able to improve upon this cost by maintaining partial caches of methods with classes in order to speed method lookups. 6 Related Work In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 4, 12, 21, 28, 31] </ref>. Below, we first compare other approaches towards view management with the MultiView approach, and then we compare the object-slicing approach used in our implementation with similar approaches.
Reference: [32] <author> K. Tanaka, M. Yoshikawa, and K. Ishihara. </author> <title> Schema virtualization in object-oriented databases. </title> <booktitle> IEEE International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1988. </year>
Reference-contexts: Their proposed virtual schemata behave differently from the real schema, especially regarding the updatability of the view classes and the inheritance of methods and attributes <ref> [1, 32] </ref>. The objectives of this paper are to identify what features must be provided by the underlying object model in order to support object-oriented view schemata that look and feel like (basic) object-oriented schemata and to demonstrate a general methodology for achieving them. <p> Then this method should be inherited downwards to all subclasses rather than upwards to all superclasses of the class C. None of the available OODB view systems, however, support uniform inheritance for both virtual and base classes <ref> [4, 8, 32] </ref>. The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs [32, 8]. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. <p> None of the available OODB view systems, however, support uniform inheritance for both virtual and base classes [4, 8, 32]. The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs <ref> [32, 8] </ref>. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. Instead, they either advocate downward search for some virtual classes [32, 1] or else they statically compile all methods with each virtual class, thus forestalling dynamic inheritance. <p> The issue of inheritance mechanisms for view classes (referred to as "method resolution") has also been discussed by other researchers in OODBs [32, 8]. However, to the best of our knowledge, none of them achieves uniform inheritance semantics. Instead, they either advocate downward search for some virtual classes <ref> [32, 1] </ref> or else they statically compile all methods with each virtual class, thus forestalling dynamic inheritance. For example, suppose a virtual class projecting some methods from a base class were to be placed above the base class. <p> The automatic classification of virtual classes into the global generalization hierarchy is a unique feature of MultiView with other view systems either avoiding the issue of integration and/or requiring manual graph manipulation <ref> [25, 4, 12, 13, 14, 28, 32] </ref>. After a virtual class has been created, the MultiView classifier performs the following steps: First the system generates intermediate classes to serve as unique point of inheritance, if warranted by the addition of the new class into the hierarchy.
Reference: [33] <author> M. Tresch and M. H. Scholl. </author> <title> Schema Transformation without Database Reorganization. </title> <booktitle> In SIGMOD RECORD, </booktitle> <pages> pages 21-27, </pages> <year> 1993. </year>
Reference-contexts: In an earlier paper [24], we show that capacity-augmenting view systems (views that augment the information content of a database by adding stored data in addition to deriving data as a function of already existing data <ref> [33] </ref>) can be used to achieve transparent schema evolution.
Reference: [34] <author> R. Zicari. </author> <title> A Framework for O 2 Schema Updates. </title> <booktitle> In 7th IEEE International Conf. on Data Engineering, </booktitle> <pages> pages 146-182, </pages> <month> April </month> <year> 1991. </year> <month> 19 </month>
Reference-contexts: Our solution is to force users to resolve the conflict by renaming, otherwise the invocation is rejected with an error message. This simple solution, also adopted by other OODB systems for dealing with name conflicts <ref> [34] </ref>, could be modified to avoid such rejections by allowing, for example, (1) a fixed ordering of superclasses to determine the choice of the method resolution or (2) user-constructs indicating priority among superclasses for the purposes of name resolution. 3.2.3 Creating and deleting an object Since the physical representation of a
References-found: 34

