URL: http://www.cs.rice.edu/CS/PLT/Publications/tr93-218.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Email: fwright,cartwrightg@cs.rice.edu.  
Title: A Practical Soft Type System for Scheme  
Author: Andrew K. Wright Robert Cartwright 
Note: The first author was supported in part by the United States Department of Defense under a National Defense Science and Engineering Graduate Fellowship. The second author was supported by NSF grant CCR-9122518 and the Texas Advanced Technology Program under grant 003604-014.  
Date: December 6, 1993  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  Rice University  
Pubnum: Technical Report TR93-218  
Abstract: Soft type systems provide the benefits of static type checking for dynamically typed languages without rejecting untypable programs. A soft type checker infers types for variables and expressions and inserts explicit run-time checks to transform untypable programs to typable form. We describe a practical soft type system for R4RS Scheme. Our type checker uses a representation for types that is expressive, easy to interpret, and supports efficient type inference. Soft Scheme supports all of R4RS Scheme, including procedures of fixed and variable arity, assignment, continuations, and top-level definitions. Our implementation is available by anonymous FTP. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiken, A., and Wimmers, E. L. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> Proceedings of the International Conference on Functional Programming Languages and Computer Architecture (1993), </booktitle> <pages> 31-41. </pages>
Reference-contexts: The representation does not support incremental definition of new type constructors, and type inference is not particularly efficient because simple types can have large representations. Aiken and Wimmers have recently developed a sophisticated soft type system for the functional language FL <ref> [1, 2] </ref>. Their system supports a rich type language including tidy unions, recursive types, subtype constraints, intersection types, and conditional types.
Reference: [2] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> Proceedings of the 21st Annual Symposium on Principles of Programming Languages (January 1994), to appear. </booktitle>
Reference-contexts: This type includes num, hence a run-time check is inserted. In contrast, the equivalent code: 10 (let ([x 1]) (match x [(a . ) a] <ref> [ 2] </ref>) couples the type test to the decomposition of x. By extending the type system to directly type pattern matching expressions, we avoid the unnecessary run-time check. <p> The representation does not support incremental definition of new type constructors, and type inference is not particularly efficient because simple types can have large representations. Aiken and Wimmers have recently developed a sophisticated soft type system for the functional language FL <ref> [1, 2] </ref>. Their system supports a rich type language including tidy unions, recursive types, subtype constraints, intersection types, and conditional types.
Reference: [3] <author> Beer, R. D. </author> <title> Preliminary report on a practical type inference system for Common Lisp. Lisp Pointers 1, </title> <booktitle> 2 (1987), </booktitle> <pages> 5-11. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [3, 11, 12, 13, 19] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [4] <author> Cartwright, R., and Fagan, M. </author> <title> Soft typing. </title> <booktitle> Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <pages> 278-292. </pages>
Reference-contexts: To ensure safety, programs that do not meet the stringent requirements of the type checker are ineligible for execution. In rejecting untypable programs, the type checker also rejects meaningful programs that it cannot prove are safe. Equivalent typable programs are often longer and more complicated. Soft type systems <ref> [4, 6] </ref> provide the benefits of static typing for dynamically typed languages. Like a static type checker, a soft type checker infers types for variables and expressions. But rather than reject programs containing untypable fragments, a soft type checker inserts explicit run-time checks to transform untypable programs to typable form. <p> We have observed consequent speedups of up to 70% over a high quality Scheme compiler. Soft Scheme is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [4, 6] </ref>. Their type system extends Hindley-Milner typing with union types, recursive types, and a modicum of subtyping as subset on union types. Soft Scheme includes several major extensions to their technical results. <p> To present more palatable types to the programmer, we define a translation into the succinct presentation type language introduced in Section 2.1. This translation eliminates (i) variables used to encode subtyping, and (ii) flags. Our decoding translation is a straightforward adaptation of that described by Cartwright and Fagan <ref> [4, 6] </ref>. 3.4 Soft Type Checking The preceding static type system can be used to statically type check Core Scheme programs. The type system will reject programs that contain incorrect uses of unchecked primitives, ensuring safe execution. <p> Using immutable pairs when possible adequately addresses the problem for set-car! and set-cdr!. At present, we have no satisfactory solutions for global variable assignments. 5 Related Work Our practical soft type system is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [4, 6] </ref>. Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an encoding technique Remy developed to reduce record subtyping to polymorphism [17].
Reference: [5] <editor> Clinger, W., Rees, J., et al. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <booktitle> ACM Lisp Pointers IV (July-September 1991). </booktitle>
Reference-contexts: 1 Introduction Dynamically typed languages like Scheme <ref> [5] </ref> permit program operations to be defined over any computable subset of the data domain. To ensure safe execution, 1 primitive operations confirm that their arguments belong to appropriate subsets known as types. The types enforced by primitive operations induce types for defined operations. <p> Soft type checking minimizes the number of run-time checks in the compiled code, enabling dynamically typed languages to attain the efficiency of statically typed languages like ML. We have developed a practical soft type system for R4RS Scheme <ref> [5] </ref>, a modern dialect of Lisp. Soft Scheme is based on an extension of the Hindley-Milner polymorphic type discipline that requires no programmer supplied type annotations. It presents types in a natural type language that is easy for non-expert programmers to interpret.
Reference: [6] <author> Fagan, M. </author> <title> Soft Typing: An Approach to Type Checking for Dynamically Typed Languages. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: To ensure safety, programs that do not meet the stringent requirements of the type checker are ineligible for execution. In rejecting untypable programs, the type checker also rejects meaningful programs that it cannot prove are safe. Equivalent typable programs are often longer and more complicated. Soft type systems <ref> [4, 6] </ref> provide the benefits of static typing for dynamically typed languages. Like a static type checker, a soft type checker infers types for variables and expressions. But rather than reject programs containing untypable fragments, a soft type checker inserts explicit run-time checks to transform untypable programs to typable form. <p> We have observed consequent speedups of up to 70% over a high quality Scheme compiler. Soft Scheme is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [4, 6] </ref>. Their type system extends Hindley-Milner typing with union types, recursive types, and a modicum of subtyping as subset on union types. Soft Scheme includes several major extensions to their technical results. <p> To present more palatable types to the programmer, we define a translation into the succinct presentation type language introduced in Section 2.1. This translation eliminates (i) variables used to encode subtyping, and (ii) flags. Our decoding translation is a straightforward adaptation of that described by Cartwright and Fagan <ref> [4, 6] </ref>. 3.4 Soft Type Checking The preceding static type system can be used to statically type check Core Scheme programs. The type system will reject programs that contain incorrect uses of unchecked primitives, ensuring safe execution. <p> Using immutable pairs when possible adequately addresses the problem for set-car! and set-cdr!. At present, we have no satisfactory solutions for global variable assignments. 5 Related Work Our practical soft type system is based on a soft type system designed by Cartwright and Fagan for an idealized functional language <ref> [4, 6] </ref>. Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an encoding technique Remy developed to reduce record subtyping to polymorphism [17].
Reference: [7] <author> Gomard, C. K. </author> <title> Partial type inference for untyped functional programs. </title> <booktitle> Proceedings of the 1990 ACM Conference on LISP and Functional Programming (June 1990), </booktitle> <pages> 282-287. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [7, 8, 16, 20, 21] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [8] <author> Henglein, F. </author> <title> Global tagging optimization by type inference. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> 205-215. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [7, 8, 16, 20, 21] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [9] <author> Hindley, R. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society 146 (December 1969), </journal> <pages> 29-60. </pages>
Reference-contexts: The types enforced by primitive operations induce types for defined operations. Scheme programmers typically have strong intuitive ideas about the types of program operations, but dynamically typed languages offer no tools to discover, verify, or express such types. Static type systems like the Hindley-Milner type discipline <ref> [9, 14] </ref> provide a framework to discover and express types. Static type checking detects certain errors prior to execution and enables compilers to omit many run-time type checks. Unfortunately, static type systems inhibit the freedom of expression enjoyed with dynamic typing.
Reference: [10] <author> Kaes, S. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> 193-204. </pages>
Reference-contexts: By permitting more subtyping, soft type systems based on structural subtyping can infer more precise types. However, our experience to date with such systems has been disappointing. They yield only a small improvement in precision because existing extensions to recursive types <ref> [10, 22] </ref> do not yield principal types. This minor improvement comes at the cost of significantly less efficient type inference. We continue to investigate adaptations of structural subtyping. 14 Assignment: Because assignment interferes with polymorphism, and therefore with sub--typing, assignment can be a major source of imprecision.
Reference: [11] <author> Kaplan, M. A., and Ullman, J. D. </author> <title> A scheme for the automatic inference of variable types. </title> <journal> Journal of the Association for Computing Machinery 27, </journal> <month> 1 (January </month> <year> 1980), </year> <pages> 128-145. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [3, 11, 12, 13, 19] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [12] <author> Kind, A., and Friedrich, H. </author> <title> A practical approach to type inference in EuLisp. </title> <booktitle> Lisp and Symbolic Computation 6, </booktitle> <month> 1/2 (August </month> <year> 1993), </year> <pages> 159-175. 16 </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [3, 11, 12, 13, 19] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [13] <author> Ma, K. L., and Kessler, R. R. </author> <title> TICL|a type inference system for Common Lisp. </title> <journal> Software Practice and Experience 20, </journal> <month> 6 (June </month> <year> 1990), </year> <pages> 593-623. </pages>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [3, 11, 12, 13, 19] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [14] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978), </journal> <pages> 348-375. </pages>
Reference-contexts: The types enforced by primitive operations induce types for defined operations. Scheme programmers typically have strong intuitive ideas about the types of program operations, but dynamically typed languages offer no tools to discover, verify, or express such types. Static type systems like the Hindley-Milner type discipline <ref> [9, 14] </ref> provide a framework to discover and express types. Static type checking detects certain errors prior to execution and enables compilers to omit many run-time type checks. Unfortunately, static type systems inhibit the freedom of expression enjoyed with dynamic typing.
Reference: [15] <author> Mitchell, J. C. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming 1, </journal> <month> 3 (July </month> <year> 1991), </year> <month> 245-286. </month> <title> Preliminary version in: Coercion and Type Inference, </title> <booktitle> Proc. 11th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> pp. 175-185. </pages>
Reference-contexts: The extra bookkeeping required for this technique is minimal. The improvement in typing precision and the attendant reduction in run-time checking can be significant. We have also investigated several adaptations of structural subtyping <ref> [15] </ref> to address the reverse flow problem. Structural subtyping is more powerful than encoding subtyping with polymorphism as it permits subtyping at all function applications. By permitting more subtyping, soft type systems based on structural subtyping can infer more precise types.
Reference: [16] <author> O'Keefe, P. M., and Wand, M. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proceedings of the European Symposium on Programming, LNCS 582 (1992), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 408-417. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [7, 8, 16, 20, 21] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [17] <author> R emy, D. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> Proceedings of the 16th Annual Symposium on Principles of Programming Languages (January 1989), </booktitle> <pages> 77-87. </pages>
Reference-contexts: (num [ t)g. 7 We use infix notation and write ( 1 ! f 2 ) [ : : : rather than (! f 1 2 ) [ : : : for procedure types. 8 Mapping type variables to types with the same label, which preserves tidiness. 8 As Remy <ref> [17, 18] </ref> discovered, polymorphism can encode a limited form of subtyping. In our framework, we use polymorphism to express supersets and subsets of types. <p> Cartwright and Fagan discovered how to incorporate a limited form of union type in a Hindley-Milner polymorphic type system. Their method is based on an encoding technique Remy developed to reduce record subtyping to polymorphism <ref> [17] </ref>. Their system has essentially the same types as Section 3.1 describes, except that all type variables must have label ;.
Reference: [18] <author> R emy, D. </author> <title> Type inference for records in a natural extension of ML. </title> <type> Tech. Rep. 1431, </type> <institution> INRIA, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: (num [ t)g. 7 We use infix notation and write ( 1 ! f 2 ) [ : : : rather than (! f 1 2 ) [ : : : for procedure types. 8 Mapping type variables to types with the same label, which preserves tidiness. 8 As Remy <ref> [17, 18] </ref> discovered, polymorphism can encode a limited form of subtyping. In our framework, we use polymorphism to express supersets and subsets of types.
Reference: [19] <author> Shivers, O. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <note> Also: Tech. Rep. CMU-CS-91-145. </note>
Reference-contexts: Nevertheless, Henglein has used a formulation of static typing enhanced with &gt; to eliminate many run-time checks from Scheme programs. The designers of optimizing compilers for Scheme and Lisp have developed type analyzers based on data flow analysis <ref> [3, 11, 12, 13, 19] </ref>. The information gathered by these systems is important for program optimization, but it is much too coarse to serve as the basis for a soft type system.
Reference: [20] <author> Thatte, S. R. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, LNCS 317 (July 1988), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 615-629. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [7, 8, 16, 20, 21] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [21] <author> Thatte, S. R. </author> <title> Quasi-static typing. </title> <booktitle> Proceedings of the 17th Annual Symposium on Principles of Programming Languages (January 1990), </booktitle> <pages> 367-381. </pages>
Reference-contexts: Several researchers have developed static type systems that extend the Hindley-Milner type discipline by adding a maximal type &gt; as the type of otherwise untypable phrases <ref> [7, 8, 16, 20, 21] </ref>. This framework is too imprecise to form the basis for a soft type system because it does not support union types or inferred recursive types.
Reference: [22] <author> Tiuryn, J., and Wand, M. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <booktitle> In TAPSOFT '93: Theory and Practice of Software Development (Berlin, </booktitle> <address> Heidelber, New York, </address> <month> apr </month> <year> 1993), </year> <editor> M.-C. Gaudel and J.-P. Jouannaud, Eds., </editor> <publisher> Springer, </publisher> <pages> pp. 686-701. </pages>
Reference-contexts: By permitting more subtyping, soft type systems based on structural subtyping can infer more precise types. However, our experience to date with such systems has been disappointing. They yield only a small improvement in precision because existing extensions to recursive types <ref> [10, 22] </ref> do not yield principal types. This minor improvement comes at the cost of significantly less efficient type inference. We continue to investigate adaptations of structural subtyping. 14 Assignment: Because assignment interferes with polymorphism, and therefore with sub--typing, assignment can be a major source of imprecision.
Reference: [23] <author> Wright, A. K. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Tech. Rep. 93-200, </type> <institution> Rice University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Assignment and the continuation operator call/cc are important features of Scheme. There are several solutions to typing assignment and continuations in a polymorphic framework. Our prototype uses the simplest method which restricts polymorphism to let-expressions where the bound expression is a syntactic value <ref> [23] </ref>. For Scheme, all expressions are values except those that contain an application of a non-primitive function or an "impure" primitive (like cons or call/cc). In our prototype, call/cc has the type (((X1 &gt; X2) &gt; X1) &gt; X1).
Reference: [24] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> To appear in: Information and Computation, 1994. 17 Appendices </note>
Reference-contexts: Proof. We use Wright and Felleisen's technique based on subject reduction <ref> [24] </ref>. 3.3 Translating to Presentation Types The types assigned by this type system are awkward to read. To present more palatable types to the programmer, we define a translation into the succinct presentation type language introduced in Section 2.1.
References-found: 24

