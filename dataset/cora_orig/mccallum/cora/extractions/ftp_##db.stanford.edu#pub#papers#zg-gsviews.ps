URL: ftp://db.stanford.edu/pub/papers/zg-gsviews.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: fzhuge,hectorg@cs.stanford.edu  
Title: Graph Structured Views and Their Incremental Maintenance  
Author: Yue Zhuge and Hector Garcia-Molina 
Address: Stanford, CA 94305-2140, USA  
Affiliation: Computer Science Department Stanford University  
Abstract: We study the problem of maintaining materialized views of graph structured data. The base data consists of records containing identifiers of other records. The data could represent traditional objects (with methods, attributes, and a class hierarchy), but it could also represent a lower level data structure. We define simple views and materialized views for such graph structured data, analyzing options for representing record identity and references in the view. We develop incremental maintenance algorithms for these views. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: However, as we discuss in Section 4.4, directly using the relational algorithms on graph data is not very effective. Most previous research on object views (e.g., <ref> [1, 3, 14] </ref>) use object databases with classes. Views are defined by adding and hiding attributes to base classes. In contrast, since there is no class concept in a GSDB, views in a GSDB need to be defined by query expressions (as we do here).
Reference: [2] <author> S. Abiteboul, D. Quass, J. McHugh, J. Widom, and J. Wiener. </author> <title> The lorel query language for semistructured data. </title> <journal> Journal of Digital Libraries, </journal> <volume> 1(1), </volume> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: We assume that these resulting objects have an arbitrary unique OID and take on the label of S1 3 . These operations are mainly used to manipulate database objects and query answers, although they could apply to any set objects. Many languages have been proposed for querying object-oriented databases <ref> [9, 4, 5, 13, 2] </ref>. Here we use a simple but representative language that lets us study view management issues. <p> Finally, we want to stress that we have selected a simple language, not because other features are not useful, but because these other features are not necessary for discussing simple view management. Features such as FROM clauses (e.g., in OQL [5] or Lorel <ref> [2] </ref>), multiple paths in SELECT clauses, or multiple conditions in WHERE clauses could easily be added to our language.
Reference: [3] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis, editors. </editor> <title> Building an Object-Oriented Database System: The Story of O2. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: However, as we discuss in Section 4.4, directly using the relational algorithms on graph data is not very effective. Most previous research on object views (e.g., <ref> [1, 3, 14] </ref>) use object databases with classes. Views are defined by adding and hiding attributes to base classes. In contrast, since there is no class concept in a GSDB, views in a GSDB need to be defined by query expressions (as we do here).
Reference: [4] <author> P. Buneman, S. Davidson, G. Hillebrand, and D. Suciu. </author> <title> A query language and optimization techniques for unstructured data. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 505-516, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Another work that is related to this paper is the view maintenance methods proposed in [15]. Their data model is edge-labeled trees without OIDs, which is similar to our model. They use a query language UnQL <ref> [4] </ref> to define their views, and use an algebraic approach to maintain the views. That is, they find ex pressions that can compute delta views corresponding to the changes of base data. <p> Then the record &lt;`Joe', 50k&gt; can be represented by the same object above. As a third example, some graph structured data models (e.g., <ref> [4] </ref>,[13]) have values or labels on edges. These models can be mapped to ours [4]. Incidentally, note that our model is a conceptual one. The actual implementation could differ. For example, the OID field may not be stored in the record, and could be inferred from the record's location on disk. Repeated labels or values could be compressed in various ways. <p> We assume that these resulting objects have an arbitrary unique OID and take on the label of S1 3 . These operations are mainly used to manipulate database objects and query answers, although they could apply to any set objects. Many languages have been proposed for querying object-oriented databases <ref> [9, 4, 5, 13, 2] </ref>. Here we use a simple but representative language that lets us study view management issues.
Reference: [5] <author> R. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: The algorithm takes as input a view definition and a sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance [7], object technology <ref> [5] </ref>, querying object oriented database [6, 9, 10], and semi-structured data models [16, 13]. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. <p> However, their approach only works for views that are defined using "join free" queries, and updates that are either concatenation or replacement of two disjointed graphs. In their case, a view is always self-maintainable. In contrast, we define our views using an extension of OQL <ref> [5] </ref> and designing incremental view maintenance algorithms using common insertion, deletion and update operations. Views defined in this paper can not generally be handled by techniques discussed in [15]. 2 Data model In this section we introduce our object and database model. For objects, we use the OEM model [12]. <p> We assume that these resulting objects have an arbitrary unique OID and take on the label of S1 3 . These operations are mainly used to manipulate database objects and query answers, although they could apply to any set objects. Many languages have been proposed for querying object-oriented databases <ref> [9, 4, 5, 13, 2] </ref>. Here we use a simple but representative language that lets us study view management issues. <p> Finally, we want to stress that we have selected a simple language, not because other features are not useful, but because these other features are not necessary for discussing simple view management. Features such as FROM clauses (e.g., in OQL <ref> [5] </ref> or Lorel [2]), multiple paths in SELECT clauses, or multiple conditions in WHERE clauses could easily be added to our language.
Reference: [6] <author> S. Cluet and C. Delobel. </author> <title> A general framework for the optimization of object-oriented queries. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 383-392, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: as input a view definition and a sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance [7], object technology [5], querying object oriented database <ref> [6, 9, 10] </ref>, and semi-structured data models [16, 13]. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. Most of the incremental view maintenance work focuses on the relational model (see [7] for references).
Reference: [7] <author> A. Gupta and I. Mumick. </author> <title> Maintenance of materialized views: Problems, techniques, </title> <journal> and applications. IEEE Data Engineering Bulletin, Special Issue on Materialized Views and Data Warehousing, </journal> <volume> 18(2) </volume> <pages> 3-18, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The algorithm takes as input a view definition and a sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance <ref> [7] </ref>, object technology [5], querying object oriented database [6, 9, 10], and semi-structured data models [16, 13]. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. <p> In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. Most of the incremental view maintenance work focuses on the relational model (see <ref> [7] </ref> for references). <p> Incremental view maintenance algorithms have been developed for the relational model in both centralized and distributed cases <ref> [7] </ref>. In this section we develop an algorithm for GSDB views in a centralized system, where the base databases and the material-ized view reside at the same site. In this environment, the view maintenance algorithm has direct access to the base data.
Reference: [8] <author> R. Hull and M. Yoshikawa. </author> <title> Ilog: Declarative creation and manipulation of object identifiers. </title> <booktitle> In VLDB, </booktitle> <pages> pages 455-468, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: For example, in a materialized view MV, the delegate of base object P 1 has OID M V:P 1. This approach is similar to semantic OIDs as used in <ref> [11, 8, 9] </ref>. Since object identifiers in a materialized view have meaning, they cannot be changed arbitrarily. Some storage systems may not allow semantic OIDs (e.g., the system assigns its own OIDs).
Reference: [9] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object oriented databases. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 393-402, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: as input a view definition and a sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance [7], object technology [5], querying object oriented database <ref> [6, 9, 10] </ref>, and semi-structured data models [16, 13]. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. Most of the incremental view maintenance work focuses on the relational model (see [7] for references). <p> In contrast, since there is no class concept in a GSDB, views in a GSDB need to be defined by query expressions (as we do here). Views defined by adding and hiding attributes over a object classes are a subset of possible views defined using path expressions <ref> [9] </ref>. Also, most of the views considered by researchers so far are virtual views. In our work we consider both virtual and materialized views. There is, nonetheless, some recent work on materialized object views by the MultiView group at University of Michigan [14]. <p> We assume that these resulting objects have an arbitrary unique OID and take on the label of S1 3 . These operations are mainly used to manipulate database objects and query answers, although they could apply to any set objects. Many languages have been proposed for querying object-oriented databases <ref> [9, 4, 5, 13, 2] </ref>. Here we use a simple but representative language that lets us study view management issues. <p> For example, in a materialized view MV, the delegate of base object P 1 has OID M V:P 1. This approach is similar to semantic OIDs as used in <ref> [11, 8, 9] </ref>. Since object identifiers in a materialized view have meaning, they cannot be changed arbitrarily. Some storage systems may not allow semantic OIDs (e.g., the system assigns its own OIDs).
Reference: [10] <author> D. Konopnicki and O. Shmueli. W3qs: </author> <title> A query system for the world wide web. </title> <booktitle> In VLDB, </booktitle> <pages> pages 54-65, </pages> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: as input a view definition and a sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance [7], object technology [5], querying object oriented database <ref> [6, 9, 10] </ref>, and semi-structured data models [16, 13]. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. Most of the incremental view maintenance work focuses on the relational model (see [7] for references).
Reference: [11] <author> Y. Papakonstantinou, S. Abiteboul, and H. Garcia-Molina. </author> <title> Object fusion in mediator systems. </title> <booktitle> In VLDB, </booktitle> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: For example, in a materialized view MV, the delegate of base object P 1 has OID M V:P 1. This approach is similar to semantic OIDs as used in <ref> [11, 8, 9] </ref>. Since object identifiers in a materialized view have meaning, they cannot be changed arbitrarily. Some storage systems may not allow semantic OIDs (e.g., the system assigns its own OIDs).
Reference: [12] <author> Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. </author> <title> Object exchange across heterogeneous information sources. </title> <booktitle> In ICDE, </booktitle> <pages> pages 251-260, </pages> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Views defined in this paper can not generally be handled by techniques discussed in [15]. 2 Data model In this section we introduce our object and database model. For objects, we use the OEM model <ref> [12] </ref>. Each object contains four fields: an OID, a label, a type and a value. The OID of an object is a universally unique identifier. The label is a string that explains the meaning of the object and does not need to be unique.
Reference: [13] <author> D. Quass, A. Rajaraman, J. Ullman, and J. Widom. </author> <title> Querying semistructured heterogeneous information. </title> <booktitle> In DOOD, </booktitle> <pages> pages 319-344, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance [7], object technology [5], querying object oriented database [6, 9, 10], and semi-structured data models <ref> [16, 13] </ref>. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. Most of the incremental view maintenance work focuses on the relational model (see [7] for references). <p> We assume that these resulting objects have an arbitrary unique OID and take on the label of S1 3 . These operations are mainly used to manipulate database objects and query answers, although they could apply to any set objects. Many languages have been proposed for querying object-oriented databases <ref> [9, 4, 5, 13, 2] </ref>. Here we use a simple but representative language that lets us study view management issues.
Reference: [14] <author> E. Rundensteiner. </author> <title> Multiview: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In VLDB, </booktitle> <pages> pages 187-198, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: However, as we discuss in Section 4.4, directly using the relational algorithms on graph data is not very effective. Most previous research on object views (e.g., <ref> [1, 3, 14] </ref>) use object databases with classes. Views are defined by adding and hiding attributes to base classes. In contrast, since there is no class concept in a GSDB, views in a GSDB need to be defined by query expressions (as we do here). <p> Also, most of the views considered by researchers so far are virtual views. In our work we consider both virtual and materialized views. There is, nonetheless, some recent work on materialized object views by the MultiView group at University of Michigan <ref> [14] </ref>. The major difference between their approach and ours, besides that they define views as virtual classes, is that in their system each real value (attribute value or method of an object) has only one single physical copy. A materialized view stores only OIDs (pointers) of the base value.
Reference: [15] <author> D. Suciu. </author> <title> Query decomposition and view maintenance for query language for unstructured data. </title> <booktitle> In VLDB, </booktitle> <pages> pages 227-238, </pages> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: Another work that is related to this paper is the view maintenance methods proposed in <ref> [15] </ref>. Their data model is edge-labeled trees without OIDs, which is similar to our model. They use a query language UnQL [4] to define their views, and use an algebraic approach to maintain the views. <p> In their case, a view is always self-maintainable. In contrast, we define our views using an extension of OQL [5] and designing incremental view maintenance algorithms using common insertion, deletion and update operations. Views defined in this paper can not generally be handled by techniques discussed in <ref> [15] </ref>. 2 Data model In this section we introduce our object and database model. For objects, we use the OEM model [12]. Each object contains four fields: an OID, a label, a type and a value. The OID of an object is a universally unique identifier.
Reference: [16] <editor> D. Suciu, editor. </editor> <booktitle> Proceedings of the Workshop on Management of Semistructured Data, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: sequence of updates to the base data, and propagates the changes to the copied data, querying the base data when necessary. 1.1 Related Work Our work is based on previous work on materialized view maintenance [7], object technology [5], querying object oriented database [6, 9, 10], and semi-structured data models <ref> [16, 13] </ref>. In the rest of this subsection we specifically compare our GSDB views to relational views and object views defined using object classes. Most of the incremental view maintenance work focuses on the relational model (see [7] for references).
Reference: [17] <author> Y. Zhuge and H. Garcia-Molina. </author> <title> Graph structured views and their incremental maintenance. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <month> Oct. </month> <year> 1997. </year> <note> www-db.stanford.edu/pub/papers/gsvfull.ps. </note>
Reference-contexts: We discuss in <ref> [17] </ref> how to handle related issues.
References-found: 17

