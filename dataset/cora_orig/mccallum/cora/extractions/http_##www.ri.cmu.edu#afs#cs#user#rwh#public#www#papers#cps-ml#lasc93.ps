URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers/cps-ml/lasc93.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Email: (rwh@cs.cmu.edu)  (mdl@cs.cmu.edu)  
Title: Polymorphic Type Assignment and CPS Conversion  
Author: ROBERT HARPER MARK LILLIBRIDGE 
Keyword: Polymorphism, continuations  
Address: 5000 Forbes Avenue Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal, 1993 c 1993 Kluwer Academic Publishers Manufactured in The Netherlands  
Abstract: Meyer and Wand established that the type of a term in the simply typed - calculus may be related in a straightforward manner to the type of its call-by-value CPS transform. This typing property may be extended to Scheme-like continuation-passing primitives, from which the soundness of these extensions follows. We study the extension of these results to the Damas-Milner polymorphic type assignment system under both the call-by-value and call-by-name interpretations. We obtain CPS transforms for the call-by-value interpretation, provided that the polymorphic let is restricted to values, and for the call-by-name interpretation with no restrictions. We prove that there is no call-by-value CPS transform for the full Damas-Milner language that validates the Meyer-Wand typing property and is equivalent to the standard call-by-value transform up to operational equivalence. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> William Clinger, Daniel P. Friedman, and Mitchell Wand. </author> <title> A scheme for higher-level semantic algebra. </title> <editor> In Maurice Nivat and John C. Reynolds, </editor> <title> POLYMORPHIC TYPE ASSIGNMENT AND CPS CONVERSION 17 editors, </title> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 237-250. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) <ref> [1, 4] </ref>. <p> We include the let construct as a primitive because it is needed in the discussion of polymorphic type assignment. The constants callcc and throw stand for continuation-passing primitives whose definitions are derived from analogous constructs in Scheme <ref> [1] </ref> and Standard ML of New Jersey [4]. We consider two CPS transforms for untyped terms, corresponding to the call-by-value and call-by-name operational semantics [17]. Each CPS transform consists of a transformation jj for untyped terms and a transformation jjjj for untyped values.
Reference: 2. <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) [1, 4]. Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner <ref> [14, 2] </ref>, and since the call-by-value CPS transform faithfully mimics the call-by-value semantics [17], it follows that fl This is a revised version of a paper presented at the ACM SIGPLAN Workshop on Continuations, San Francisco, June 1992. y This work was sponsored by the Defense Advanced Research Projects Agency, CSTO, <p> In this paper we undertake a systematic study of the interaction between continuations and polymorphism by considering the typing properties of the CPS transform for both the call-by-value and call-by-name variants of the Damas-Milner language <ref> [2] </ref> and its extension with continuation-passing primitives. We obtain suitable extensions of the Meyer-Wand theorem for the call-by-value CPS transform, provided that the polymorphic let is restricted to values, and for the call-by-name transform, under no restrictions. <p> Our main positive results are the extension of the Meyer-Wand 16 HARPER AND LILLIBRIDGE theorem to the call-by-value interpretation of a restricted form of polymor-phism, and to the call-by-name interpretation of the unrestricted language. These results have as a consequence the soundness (in the sense of Damas and Milner <ref> [2] </ref>) of these programming languages. We have also argued that there is no "natural" call-by-value CPS transform for the unrestricted language, but this leaves open the possibility of finding a transformation that is radically different in character from the usual one.
Reference: 3. <author> Olivier Danvy and John Hatcliff. </author> <title> Thunks (continued). </title> <booktitle> In Proceedings of the Workshop on Static Analysis WSA'92, volume 81-82 of Bi-gre Journal, </booktitle> <pages> pages 3-11, </pages> <address> Bordeaux, France, </address> <month> September </month> <year> 1992. </year> <institution> IRISA, Rennes, France. </institution> <note> Extended version available as Technical Report CIS-92-28, </note> <institution> Kansas State University. </institution>
Reference-contexts: The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin [17] and was extended to continuation-passing primitives (for the call-by-value case) by Griffin [6]. (See also <ref> [5, 19, 20, 21, 3] </ref>.) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name.
Reference: 4. <author> Bruce Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) <ref> [1, 4] </ref>. <p> We include the let construct as a primitive because it is needed in the discussion of polymorphic type assignment. The constants callcc and throw stand for continuation-passing primitives whose definitions are derived from analogous constructs in Scheme [1] and Standard ML of New Jersey <ref> [4] </ref>. We consider two CPS transforms for untyped terms, corresponding to the call-by-value and call-by-name operational semantics [17]. Each CPS transform consists of a transformation jj for untyped terms and a transformation jjjj for untyped values. Exactly what is considered a value depends on which operational semantics is being used. <p> The call-by-value type transform is extended to ! + cont by defining jjt contjj cbv = jjt jj cbv ! ff. It is straightforward to verify that Theorem 2 extends to ! + cont in this way <ref> [4] </ref>. <p> Meyer and Wand exploited this relationship in their proof of the equivalence of the direct and continuation semantics of ! [13]. A minor extension of this result may be used to establish the soundness of typing for ! + cont, the extension of ! with continuation-passing primitives <ref> [4] </ref>, under call-by-value. In this paper we have presented a systematic study of the extension of the Meyer-Wand theorem to the Damas-Milner system of polymorphic type assignment.
Reference: 5. <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin [17] and was extended to continuation-passing primitives (for the call-by-value case) by Griffin [6]. (See also <ref> [5, 19, 20, 21, 3] </ref>.) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name.
Reference: 6. <author> Timothy Griffin. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Fran-cisco, CA, </address> <month> January </month> <year> 1990. </year> <note> ACM, ACM. </note>
Reference-contexts: The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin [17] and was extended to continuation-passing primitives (for the call-by-value case) by Griffin <ref> [6] </ref>. (See also [5, 19, 20, 21, 3].) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name.
Reference: 7. <author> Timothy Griffin. </author> <title> Private communication, </title> <month> January </month> <year> 1992. </year>
Reference-contexts: The syntax of types and contexts in (DM) is defined by the following grammar: 3 The term "call-by-name type transform" is something of a misnomer since there exists a by-value CPS transform that validates the by-name typing property <ref> [20, 7] </ref>.
Reference: 8. <author> Robert Harper, Bruce Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <note> Revised and expanded version of [4]. To appear, Journal of Functional Programming. </note>
Reference-contexts: The source of this discrepancy may be traced to the interaction between the polymorphic let construct and the typing rules for callcc. Several ad-hoc methods for restricting the language to recover soundness have been proposed <ref> [8, 23] </ref>. In this paper we undertake a systematic study of the interaction between continuations and polymorphism by considering the typing properties of the CPS transform for both the call-by-value and call-by-name variants of the Damas-Milner language [2] and its extension with continuation-passing primitives. <p> with the call-by-name transform in Definition 2 below.) The transformation of callcc differs from that in Scheme since continuations are not here represented as functions which are applied to their arguments, but rather are represented directly as continuations which are invoked using the throw primitive. (See Harper, Duba, and MacQueen <ref> [8] </ref> for further discussion of this point.) The call-by-value CPS transform is compositional in the sense that it commutes with substitution.
Reference: 9. <author> Robert Harper and Mark Lillibridge. </author> <title> Announcement on the types electronic forum, </title> <month> July </month> <year> 1991. </year>
Reference-contexts: The extension of the Meyer-Wand transform to ! + cont establishes the soundness of the monomorphic fragment of the language, but the soundness of the polymorphic language with continuation-passing primitives was left open. It was subsequently proved by the authors <ref> [9] </ref> that the full polymorphic language is unsound when extended with callcc and throw. The source of this discrepancy may be traced to the interaction between the polymorphic let construct and the typing rules for callcc. <p> Our investigation makes clear that there is a fundamental tension between implicit polymorphism and the call-by-value interpretation of let. This is consistent with earlier results establishing the inconsistency between unrestricted polymorphism and polymorphic reference types [22, 12] and first-class continuations <ref> [9, 10] </ref>. The source of the inconsistency may be traced to conflicting motivations for the static and dynamic semantics of the language.
Reference: 10. <author> Robert Harper and Mark Lillibridge. </author> <title> Polymorphic type assignment and CPS conversion. </title> <editor> In Olivier Danvy and Carolyn Talcott, editors, </editor> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Continuations CW92, </booktitle> <pages> pages 13-22, </pages> <address> Stanford, CA 94305, </address> <month> June </month> <year> 1992. </year> <institution> Department of Computer Science, Stanford University. </institution> <note> Published as technical report STAN-CS-92-1426. </note>
Reference-contexts: Our investigation makes clear that there is a fundamental tension between implicit polymorphism and the call-by-value interpretation of let. This is consistent with earlier results establishing the inconsistency between unrestricted polymorphism and polymorphic reference types [22, 12] and first-class continuations <ref> [9, 10] </ref>. The source of the inconsistency may be traced to conflicting motivations for the static and dynamic semantics of the language.
Reference: 11. <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year> <note> ACM, ACM. 18 HARPER AND LILLIBRIDGE </note>
Reference-contexts: This suggests that a language in which polymorphic generalization and instantiation are semantically significant would be a well-behaved alternative to ML-style implicit polymorphism. This perspective has been explored in some detail in subsequent work of the authors <ref> [11] </ref>. 6. Acknowledgments We are grateful to Olivier Danvy, Bruce Duba, Tim Griffin, Mark Leone, and the anonymous referees for their helpful comments and suggestions.
Reference: 12. <author> Xavier Leroy and Pierre Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 291-302, </pages> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year> <note> ACM SIGACT/SIGPLAN. </note>
Reference-contexts: Our investigation makes clear that there is a fundamental tension between implicit polymorphism and the call-by-value interpretation of let. This is consistent with earlier results establishing the inconsistency between unrestricted polymorphism and polymorphic reference types <ref> [22, 12] </ref> and first-class continuations [9, 10]. The source of the inconsistency may be traced to conflicting motivations for the static and dynamic semantics of the language.
Reference: 13. <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: their study of the relationship between direct and continuation semantics for the simply typed -calculus ( ! ), Meyer and Wand note that the type of a term in ! may be related in a simple and natural way to the type of its call-by-value continuation passing style (CPS) transform <ref> [13] </ref>. This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) [1, 4]. <p> Meyer and Wand exploited this relationship in their proof of the equivalence of the direct and continuation semantics of ! <ref> [13] </ref>. A minor extension of this result may be used to establish the soundness of typing for ! + cont, the extension of ! with continuation-passing primitives [4], under call-by-value.
Reference: 14. <author> Robin Milner. </author> <title> A theory of type polymorphism in programming languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) [1, 4]. Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner <ref> [14, 2] </ref>, and since the call-by-value CPS transform faithfully mimics the call-by-value semantics [17], it follows that fl This is a revised version of a paper presented at the ACM SIGPLAN Workshop on Continuations, San Francisco, June 1992. y This work was sponsored by the Defense Advanced Research Projects Agency, CSTO,
Reference: 15. <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: F19628-91-C-0168. z Supported by a National Science Foundation Graduate Fellowship. 2 HARPER AND LILLIBRIDGE ! + cont under a call-by-value operational semantics is also type safe. In a subsequent study Duba, Harper, and MacQueen studied the addition of callcc and throw to Standard ML <ref> [15] </ref>. The extension of the Meyer-Wand transform to ! + cont establishes the soundness of the monomorphic fragment of the language, but the soundness of the polymorphic language with continuation-passing primitives was left open.
Reference: 16. <author> John C. Mitchell. </author> <title> A type-inference approach to reduction properties and semantics of polymorphic expressions. </title> <booktitle> In 1986 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 308-319, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Accordingly we generalize the target language of the CPS transform to the language DM + which is defined by eliminating the distinction between monotypes and polytypes in DM. The resulting system is equivalent to full polymorphic type assignment <ref> [16] </ref>. Although the decidability of type inference in DM + remains an open problem, this is not important for our purposes. The main property of DM + that we require is closure under fi-reduction [16]. 12 HARPER AND LILLIBRIDGE With these changes to the type transformation and the associated enrichment of <p> The resulting system is equivalent to full polymorphic type assignment <ref> [16] </ref>. Although the decidability of type inference in DM + remains an open problem, this is not important for our purposes. The main property of DM + that we require is closure under fi-reduction [16]. 12 HARPER AND LILLIBRIDGE With these changes to the type transformation and the associated enrichment of the target type system, the putative proof of type preservation goes through in the case of let expressions, but now polymorphic generalization is problematic. <p> not preserve typability in the sense of Meyer & Wand, for by the correctness of the call-by-value CPS transform for DM+ cont, the expression je 0 j x:x also evaluates to 0 (under call-by-name or call-by-value), yet has type bool, a violation of the subject reduction property of DM + <ref> [16] </ref>. Consequently the call-by-value CPS transform does not verify the Meyer-Wand typing property even in the absence of continuation-passing primitives.
Reference: 17. <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner [14, 2], and since the call-by-value CPS transform faithfully mimics the call-by-value semantics <ref> [17] </ref>, it follows that fl This is a revised version of a paper presented at the ACM SIGPLAN Workshop on Continuations, San Francisco, June 1992. y This work was sponsored by the Defense Advanced Research Projects Agency, CSTO, under the title "The Fox Project: Advanced Development of Systems Software", ARPA Order <p> The constants callcc and throw stand for continuation-passing primitives whose definitions are derived from analogous constructs in Scheme [1] and Standard ML of New Jersey [4]. We consider two CPS transforms for untyped terms, corresponding to the call-by-value and call-by-name operational semantics <ref> [17] </ref>. Each CPS transform consists of a transformation jj for untyped terms and a transformation jjjj for untyped values. Exactly what is considered a value depends on which operational semantics is being used. <p> Proof: By simultaneous induction on the structure of n and e 0 . The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin <ref> [17] </ref> and was extended to continuation-passing primitives (for the call-by-value case) by Griffin [6]. (See also [5, 19, 20, 21, 3].) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name. <p> In particular, if e evaluates to a constant c, then jej cbv (x:x) evaluates to c, and vice-versa, assuming that jjcjj cbv = c. A similar result for the call-by-name interpretation may also be proved <ref> [17] </ref>. 2 In each equation any bound variable occurring on the right that does not also occur on the left is assumed to be chosen so as to avoid capture. 6 HARPER AND LILLIBRIDGE 3.
Reference: 18. <author> Gordon Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-257, </pages> <year> 1977. </year>
Reference-contexts: But the latter term has type bool, in contra diction to the subject reduction property of DM + . 5 Two terms e 1 and e 2 are operationally equivalent iff they are indistinguishable in all program contexts <ref> [18] </ref>. 14 HARPER AND LILLIBRIDGE The conditions of the theorem leave open the possibility of there being a call-by-value transform for DM that is operationally inequivalent to the standard one, or of there being a type transform for which a Meyer-Wand-like type preservation theorem can be proved but for which either
Reference: 19. <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Conference Record of the 25th National ACM Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <note> ACM. </note>
Reference-contexts: The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin [17] and was extended to continuation-passing primitives (for the call-by-value case) by Griffin [6]. (See also <ref> [5, 19, 20, 21, 3] </ref>.) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name. <p> In the terminology of Reynolds <ref> [19] </ref>, polymorphic instantiation is given a "trivial" interpretation in that no interesting computation can occur as a result of polymorphic instantiation. The definition of j8t:j cbv reflects the fact that in DM there is no need of continuations whose domain is a polymorphic type. <p> This transform is defined by taking jj8t:jj = 8t:jj, and jj = (jjjj ! ff) ! ff. The intuition behind this choice is to regard polymorphic instantiation as a "serious" computation (in roughly the sense of Reynolds <ref> [19] </ref>). This interpretation is at variance with the usual semantics of ML polymorphism since it admits primitives that have non-trivial computational effects when polymorphically instantiated.
Reference: 20. <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <editor> In Jacques Loeckx, editor, </editor> <booktitle> Second Colloquium on Automata, Languages, and Programming, volume 14 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156, </pages> <address> Saarbrucken, West Germany, 1974. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin [17] and was extended to continuation-passing primitives (for the call-by-value case) by Griffin [6]. (See also <ref> [5, 19, 20, 21, 3] </ref>.) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name. <p> The syntax of types and contexts in (DM) is defined by the following grammar: 3 The term "call-by-name type transform" is something of a misnomer since there exists a by-value CPS transform that validates the by-name typing property <ref> [20, 7] </ref>.
Reference: 21. <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In 1992 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 288-298, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: The relationship between the call-by-value and call-by-name CPS transforms and the corresponding call-by-value and call-by-name operational semantics was established for pure -terms by Plotkin [17] and was extended to continuation-passing primitives (for the call-by-value case) by Griffin [6]. (See also <ref> [5, 19, 20, 21, 3] </ref>.) Theorem 1 (Plotkin, Griffin) The closed expression e evaluates to v under call-by-value iff jej cbv (x:x) evaluates to jjvjj cbv under either call-by-value or call-by-name.
Reference: 22. <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year> <title> POLYMORPHIC TYPE ASSIGNMENT AND CPS CONVERSION 19 </title>
Reference-contexts: Our investigation makes clear that there is a fundamental tension between implicit polymorphism and the call-by-value interpretation of let. This is consistent with earlier results establishing the inconsistency between unrestricted polymorphism and polymorphic reference types <ref> [22, 12] </ref> and first-class continuations [9, 10]. The source of the inconsistency may be traced to conflicting motivations for the static and dynamic semantics of the language.
Reference: 23. <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> July </month> <year> 1991. </year> <note> To appear, Information and Computation. </note>
Reference-contexts: The source of this discrepancy may be traced to the interaction between the polymorphic let construct and the typing rules for callcc. Several ad-hoc methods for restricting the language to recover soundness have been proposed <ref> [8, 23] </ref>. In this paper we undertake a systematic study of the interaction between continuations and polymorphism by considering the typing properties of the CPS transform for both the call-by-value and call-by-name variants of the Damas-Milner language [2] and its extension with continuation-passing primitives.
References-found: 23

