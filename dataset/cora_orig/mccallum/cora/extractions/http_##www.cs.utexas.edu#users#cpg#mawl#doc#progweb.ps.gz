URL: http://www.cs.utexas.edu/users/cpg/mawl/doc/progweb.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/cpg/mawl/papers.html
Root-URL: 
Email: ladd@research.att.com jcr@research.att.com  
Title: Programming the Web: An Application-oriented Language for Hypermedia Services  
Author: David A. Ladd J. Christopher Ramming 
Date: October 9, 1995  
Affiliation: AT&T Bell Laboratories  
Abstract: MAWL is an application language for programming interactive services in the context of the Worldwide Web. The language is small, because no construct was introduced without compelling justification; as with yacc [8], general-purpose computation is done in a host language. MAWL offers conveniences such as control abstraction, persistent state management, synchronization, and shared memory. In addition, the MAWL compiler performs static checking designed to prevent common Web programming errors. In this paper we discuss the design and engineering of MAWL. We describe the problems MAWL is intended to solve, and then discuss our design choices in the context of our general language design philosophy, We also include an appendix of commentary on several short MAWL programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, B. W. Kernighan, and P. J. Weinberger. </author> <title> The AWK Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: In order to provide quality services, Web programmers need appropriate reusable abstractions. Unfortunately, the languages that are commonly used to build Web services (Tcl [18], Perl [21], awk <ref> [1] </ref>, and various shells [11]) offer little in the way of static analysis or guarantees.
Reference: [2] <author> Scot Anderson and Rick Garvin. Sessioneer: </author> <title> Flexible session level authentication with off the shelf servers and clients. </title> <booktitle> In Third International WWW Conference, </booktitle> <year> 1995. </year> <month> 20 </month>
Reference-contexts: Both careless users and misbehaving browsers are detected in this fashion. 12 5 Other Work While several authors <ref> [2, 17] </ref> have identified and addressed problems with current Web programming practice, the techniques needed for advanced Web programming have not been brought together in a single place. The state of the art still consists of monolithic, relatively inflexible daemons, ad-hoc cgi scripts, and interpretive languages for clients.
Reference: [3] <author> T. Berners-Lee. </author> <title> Hypertext transfer protocol (HTTP). Working Draft of the Internet Engineering Task Force, </title> <year> 1993. </year>
Reference-contexts: 1 Introduction The scope and diversity of the World Wide Web (the Web) are expanding daily. Much of the popularity of the Web is undoubtedly due to the simplicity and robustness of its underlying protocol, HTTP <ref> [3] </ref>. The source of this simplicity is the fact that HTTP is a stateless protocol: no HTTP transaction is defined in terms of the transactions that precede it. Because HTTP was originally designed for straightforward hypertext document publishing, the stateless nature of HTTP has been acceptable.
Reference: [4] <author> T. Berners-Lee and D. Connolly. </author> <title> Hypertext markup language (HTML). </title> <institution> Working Draft of the Internet Engineering Task Force, </institution> <year> 1993. </year>
Reference-contexts: Moreover, there are many problems that are specific to the nature of Web services. For example, all Web programmers must guard against a user's failure to fill in required 1 form fields. Likewise, since many services require the dynamic generation of documents format-ted in HTML <ref> [4] </ref>, many Web programmers must hand-code solutions to the HTML parsing problem. Web programmers also need to be aware that servers handle numerous requests concurrently, and that resources, such as shared files, need to be protected from conflicting simultaneous requests.
Reference: [5] <author> S. I. Feldman. </author> <title> Make: a program for maintaining computer programs. </title> <type> Technical report, </type> <institution> Bell Telephone Laboratories, </institution> <year> 1979. </year>
Reference-contexts: Numerous application languages, each with its own general-purpose computing constructs, would be difficult to sustain. Therefore we favor the third approach, which has been used to good effect by successful application languages such as yacc [8] and make <ref> [5] </ref>. On the principle of parsimony, we included no constructs in MAWL that were easily obtained from general-purpose computing languages. We strove for an application language in which each construct is clearly related to a design goal that could not be easily fulfilled by a general-purpose computing language.
Reference: [6] <author> T. G. Griffin and H. Trickey. </author> <title> Integrity maintenance in a telecommunications switch. </title> <journal> IEEE Data Engineering Bulletin, </journal> <month> June </month> <year> 1994. </year>
Reference-contexts: Users of make are informed of circular dependencies. A language called PRL5, for specifying database constraints, was designed at AT&T Bell Laboratories so that constraints expressed in the language could always be transformed into efficient transaction guards. <ref> [13, 6] </ref> Thus application-language design is primarily a problem of determining which compile-time analyses are useful in a particular domain, and then finding a way to express the necessary computation in ways that the analyses are nonetheless decidable.
Reference: [7] <author> Adobe Systems Inc. </author> <title> PostScript Language Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Another pitfall is that the extended language is tied to (some particular implementation of) the base language, and any changes in the base language need to be reflected in the extended language. Numerous application languages have been designed with their own general-purpose computing constructs (PostScript is a good example <ref> [7] </ref>). To learn a variety of syntaxes for similar language constructs is irritating, and subtle semantic variations can pose serious problems. Numerous application languages, each with its own general-purpose computing constructs, would be difficult to sustain.
Reference: [8] <author> S. C. Johnson. </author> <title> Yacc: Yet another compiler compiler. </title> <type> Technical report, </type> <institution> Bell Telephone Laboratories, </institution> <year> 1975. </year>
Reference-contexts: Numerous application languages, each with its own general-purpose computing constructs, would be difficult to sustain. Therefore we favor the third approach, which has been used to good effect by successful application languages such as yacc <ref> [8] </ref> and make [5]. On the principle of parsimony, we included no constructs in MAWL that were easily obtained from general-purpose computing languages.
Reference: [9] <author> Andrew R. Koenig. </author> <title> Language design is library design. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> July </month> <year> 1991. </year>
Reference-contexts: It is commonly held that library design and language design are equivalent, or, stated in more general terms, that the abstraction facilities built into existing general-purpose languages are sufficient to achieve the effect of any application language <ref> [10, 9] </ref>. To the contrary, we hold that application languages motivated only by functional abstraction, control abstraction, and/or data abstraction (possibly buried in syntactic sugar) are on shaky ground for precisely the reason that the same effect could be achieved with a good general-purpose language and an application library.
Reference: [10] <author> Andrew R. Koenig. </author> <title> Library design is language design. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> June </month> <year> 1991. </year>
Reference-contexts: It is commonly held that library design and language design are equivalent, or, stated in more general terms, that the abstraction facilities built into existing general-purpose languages are sufficient to achieve the effect of any application language <ref> [10, 9] </ref>. To the contrary, we hold that application languages motivated only by functional abstraction, control abstraction, and/or data abstraction (possibly buried in syntactic sugar) are on shaky ground for precisely the reason that the same effect could be achieved with a good general-purpose language and an application library.
Reference: [11] <author> D.G. Korn. </author> <title> Ksha shell programming language. </title> <type> Technical report, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1986. </year>
Reference-contexts: In order to provide quality services, Web programmers need appropriate reusable abstractions. Unfortunately, the languages that are commonly used to build Web services (Tcl [18], Perl [21], awk [1], and various shells <ref> [11] </ref>) offer little in the way of static analysis or guarantees. And general-purpose languages such as ML [15], C++ [20], and Eiffel [16], that as a matter of policy guard against dynamically discovered errors, do not specifically address common Web-programming errors, such as dangling URLs and incorrect HTML.
Reference: [12] <author> D. A. Ladd and J. C. Ramming. </author> <title> A*: A language for implementing language processors. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <year> 1994. </year>
Reference-contexts: be extended with application-specific constructs. * A specially constructed application language can include its own, idiosyncratic, general purpose facilities. * An application language can be designed with the capacity to interface with one or more existing general-purpose languages. 3.2.1 Three strategies We have adopted the extension approach in earlier work <ref> [12] </ref>, but the results have not been entirely satisfactory. One drawback is that there is no universally accepted language for general-purpose computing, so any choice will be the wrong one.
Reference: [13] <author> D. A. Ladd and J. C. Ramming. </author> <title> Two application languages in software production. </title> <booktitle> In USENIX Symposium on Very High Level Languages, </booktitle> <year> 1994. </year>
Reference-contexts: Users of make are informed of circular dependencies. A language called PRL5, for specifying database constraints, was designed at AT&T Bell Laboratories so that constraints expressed in the language could always be transformed into efficient transaction guards. <ref> [13, 6] </ref> Thus application-language design is primarily a problem of determining which compile-time analyses are useful in a particular domain, and then finding a way to express the necessary computation in ways that the analyses are nonetheless decidable.
Reference: [14] <author> John C. Mallery. </author> <title> A common lisp hypermedia server. </title> <booktitle> In First International WWW Conference, </booktitle> <year> 1994. </year>
Reference-contexts: The state of the art still consists of monolithic, relatively inflexible daemons, ad-hoc cgi scripts, and interpretive languages for clients. The one notable exception to this rule is Mallery's Common Lisp HTTP server <ref> [14] </ref>, which we will refer to as CL-HTTP. CL-HTTP is a library for Common Lisp that that allows Lisp applications to serve dynamic hypertext. CL-HTTP and MAWL have differing orientations toward the programming problem.
Reference: [15] <author> D. B. McQueen and A. Appel. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Proceedings of the 3rd International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-2. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In order to provide quality services, Web programmers need appropriate reusable abstractions. Unfortunately, the languages that are commonly used to build Web services (Tcl [18], Perl [21], awk [1], and various shells [11]) offer little in the way of static analysis or guarantees. And general-purpose languages such as ML <ref> [15] </ref>, C++ [20], and Eiffel [16], that as a matter of policy guard against dynamically discovered errors, do not specifically address common Web-programming errors, such as dangling URLs and incorrect HTML. Therefore, it is worthwhile to explore systems in which typical Web-programming problems are detected at compile time.
Reference: [16] <author> Bertrand Meyer. </author> <title> Eiffel: the Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Unfortunately, the languages that are commonly used to build Web services (Tcl [18], Perl [21], awk [1], and various shells [11]) offer little in the way of static analysis or guarantees. And general-purpose languages such as ML [15], C++ [20], and Eiffel <ref> [16] </ref>, that as a matter of policy guard against dynamically discovered errors, do not specifically address common Web-programming errors, such as dangling URLs and incorrect HTML. Therefore, it is worthwhile to explore systems in which typical Web-programming problems are detected at compile time.
Reference: [17] <author> David Nicol, Calum Smeaton, and Alan Falconer Slater. Footsteps: </author> <title> Trail-blazing the Web. </title> <booktitle> In Third International WWW Conference, </booktitle> <year> 1995. </year>
Reference-contexts: Both careless users and misbehaving browsers are detected in this fashion. 12 5 Other Work While several authors <ref> [2, 17] </ref> have identified and addressed problems with current Web programming practice, the techniques needed for advanced Web programming have not been brought together in a single place. The state of the art still consists of monolithic, relatively inflexible daemons, ad-hoc cgi scripts, and interpretive languages for clients.
Reference: [18] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: In order to provide quality services, Web programmers need appropriate reusable abstractions. Unfortunately, the languages that are commonly used to build Web services (Tcl <ref> [18] </ref>, Perl [21], awk [1], and various shells [11]) offer little in the way of static analysis or guarantees.
Reference: [19] <author> John H. Reppy. </author> <title> Concurrent ML: Design, application and semantics. </title> <editor> In Peter E. Lauer, editor, </editor> <booktitle> Functional Programming, Concurrency, Simulation and Automated Reasoning (LNCS 693), </booktitle> <pages> pages 165-198. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The ML instantiation of MAWL can generate code for 7 either execution model. In the case that the MAWL service assumes the role of HTTP server, each instance of a session corresponds to a Concurrent ML thread <ref> [19] </ref>. Thus, a form submission simply leads to the awakening of a lightweight thread with a new output file descriptor, not the fork (), exec (), and interpreter start-up overhead of, for instance, a Tcl process.
Reference: [20] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Unfortunately, the languages that are commonly used to build Web services (Tcl [18], Perl [21], awk [1], and various shells [11]) offer little in the way of static analysis or guarantees. And general-purpose languages such as ML [15], C++ <ref> [20] </ref>, and Eiffel [16], that as a matter of policy guard against dynamically discovered errors, do not specifically address common Web-programming errors, such as dangling URLs and incorrect HTML. Therefore, it is worthwhile to explore systems in which typical Web-programming problems are detected at compile time.

References-found: 20

