URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/ps/ChSS96.ps
Refering-URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/sark_pub.html
Root-URL: 
Email: jdchoi@watson.ibm.com -or- vivek sarkar@vnet.ibm.com -or- schnbrg@watson.ibm.com  
Title: Incremental Computation of Static Single Assignment Form  
Author: Jong-Deok Choi, Vivek Sarkar, Edith Schonberg 
Address: PO Box 49023 San Jose, California 95161-9023  
Affiliation: International Business Machines Corporation Software Solutions Division Application Development Technology Institute  
Date: November, 1992)  
Note: Document Number TR ADTI-1995-019 (also available as STL TR 03.638) November, 1995 (original version:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Frances Allen, Michael Burke, Philippe Charles, Ron Cytron, and Jeanne Ferrante. </author> <title> An overview of the ptran analysis system for multiprocessing. </title> <booktitle> Proceedings of the ACM 1987 International Conference on Supercomputing, </booktitle> <year> 1987. </year> <note> Also published in The Journal of Parallel and Distributed Computing, </note> <month> Oct., </month> <year> 1988, </year> <pages> 5(5) pages 617-640. </pages>
Reference-contexts: and We denote the header node of interval I by hdr (I). 2 Informally, Interval (h) is the union of all the nodes in I fl (h) that do not "belong to" intervals nested in I fl (h), and edges between these nodes. 2 The program representation used in PTRAN <ref> [1, 13] </ref> is an augmented control flow graph, (CF G aug ). As compared to the original CF G, CF G aug makes loop (interval) structure evident via preheader and postexit nodes. These extra nodes also provide convenient locations for summarizing data flow information for the loop. <p> Figure 1 shows an example CF G and the corresponding CF G aug . More details on how to compute CF G aug of a CF G are given in <ref> [1, 13] </ref>. 2.2 Properties of SSA Rendering a program into SSA form simplifies and increases the accuracy of solving a useful subset of data-flow optimization problems, such as constant propagation [16], global value numbering [3], and program equivalence detection [18].
Reference: [2] <author> Frances Allen and John Cocke. </author> <title> A catalogue of optimizing transformation. </title> <booktitle> Design and Optimization of Compilers, </booktitle> <pages> pages 1-30, </pages> <year> 1972. </year>
Reference-contexts: Therefore, no further update is required. 2 This SSA update has O (n 2 + n 02 ) execution-time complexity, which is independent of the size of the loop body. 4.4 Loop Fusion The effect of loop fusion <ref> [2] </ref> is to fuse together the bodies of two adjacent conformable loops to obtain a single fused loop body: do i = e1, e2, e3 BODY-1 do i = e1, e2, e3 enddo ---&gt; BODY-1 do i = e1, e2, e3 BODY-2 BODY-2 enddo enddo For simplicity, the above schema makes
Reference: [3] <author> Bowen Alpern, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Detecting equality of variables in programs. </title> <booktitle> Fifteenth ACM Principles of Programming Languages Symposium, </booktitle> <pages> pages 1-11, </pages> <month> January </month> <year> 1988. </year> <institution> San Diego, </institution> <address> CA. </address>
Reference-contexts: 1 Introduction Static single assignment (SSA) form is a compact intermediate program representation that is well suited to a large number of compiler optimization algorithms, including constant propagation [16], global value numbering <ref> [3] </ref>, and program equivalence detection [18]. In SSA form, each variable appears as a target of an assignment at most once, so that each variable use is reached by a single definition. Special variable definitions called f unctions are added to the program to represent multiple reaching definitions. <p> More details on how to compute CF G aug of a CF G are given in [1, 13]. 2.2 Properties of SSA Rendering a program into SSA form simplifies and increases the accuracy of solving a useful subset of data-flow optimization problems, such as constant propagation [16], global value numbering <ref> [3] </ref>, and program equivalence detection [18]. These results are largely due to the statically functional nature of an SSA form program: each "variable" in the transformed program appears as the target of exactly one assignment statement.
Reference: [4] <author> M.G. Burke and B.G. Ryder. </author> <title> A critical analysis of incremental iterative data flow analysis algorithms. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7) </volume> <pages> 723-728, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Previous work on incremental data flow analysis focuses on obtaining an updated fixed-point solution after a small program change <ref> [5, 4, 10, 9] </ref>. These incremental data flow techniques apply to any monotone data flow problem expressed 1 within the classic data flow framework.
Reference: [5] <author> Michael Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data-flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Previous work on incremental data flow analysis focuses on obtaining an updated fixed-point solution after a small program change <ref> [5, 4, 10, 9] </ref>. These incremental data flow techniques apply to any monotone data flow problem expressed 1 within the classic data flow framework.
Reference: [6] <author> Ron Cytron. </author> <title> private communication. </title> <type> 16 </type>
Reference-contexts: For an irreducible CFG, restoring minimal SSA form, after a deletion of a def, requires an additional step of identifying and removing a set of -functions that have as their parameters only themselves plus a single, identical renamed variable. <ref> [6] </ref> 3.2 Incremental SSA for Updating an Interval In this section, we generalize the above algorithms to handle arbitrary update of an interval.
Reference: [7] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: Special variable definitions called f unctions are added to the program to represent multiple reaching definitions. This paper addresses the problem of rebuilding SSA form after program transformation. The traditional algorithm for building minimal SSA form <ref> [7, 15] </ref> is efficient but exhaustive. Even when program changes are small, the cost of updating SSA with this algorithm is proportional to the size of the procedure. As a result, maintaining current and correct SSA form during a multi-pass compilation process is prohibitively expensive. <p> More specifically, the set of nodes containing -functions for variable v can be precomputed as the iterated dominance frontier of nodes containing defs of v. The SSA construction algorithm then traverses the dominator tree of the program's control flow graph, maintaining a stack of renamed defs for each variable <ref> [7] </ref>. More details of SSA algorithm are given in Section 3. that each variable in the transformed program appears as the target of exactly one assignment statement. A -function is introduced at statement ^ S 4 to explicitly represent the merge of value defs Y 1 and Y 2 . <p> redundant -function is given as follows: Definition 7 A -function F is redundant if all the parameters, except those identical to the target of the -function, are the same renamed variable. 1 By minimal SSA form, we mean the SSA form that would be constructed from the exhaustive algorithm in <ref> [7] </ref>. 5 Examples of redundant -functions are: X i = (X j ; X j ; X j ); X k = (X l ; X k ; X l ): In the incremental SSA update algorithms specified below, it is assumed that same-named variables are represented by def-use chains after <p> Delete use u of variable v at statement S. Remove u from U ses (r). 2. Insert use u of variable v at statement S. Add u to U ses (r). 3. Delete def d of variable v at statement S. Like the original SSA algorithm in <ref> [7] </ref>, the incremental update algorithm works in several steps: (a) Update Uses sets. All uses of d, including parameters of -functions, become uses of r, which is reaching def (S; v). (b) Delete redundant -functions. <p> Following <ref> [7] </ref>, S is a set of stacks of defs reaching the current CFG node. For each variable A, S (A) initially contains reaching def (prehdr (I); A). 1. Rebuild CFG dominator tree for ^ I. 2. Compute dominance frontier for ^ I. 3. Update f unctions in ^ I. 4. <p> For each variable A, S (A) initially contains reaching def (prehdr (I); A). 1. Rebuild CFG dominator tree for ^ I. 2. Compute dominance frontier for ^ I. 3. Update f unctions in ^ I. 4. Rename variables in ^ I, using an algorithm similar to <ref> [7] </ref>, but without modifying the SSA structure of inner loops except for the upwards-exposed uses of variables in them. 5. Incrementally update SSA for outer intervals, using the algorithms in Section 3.1, for variables defined in ^ I and not in I, and vice versa.
Reference: [8] <author> Ron Cytron and Reid Gershbein. </author> <title> Efficiently accommodating may-alias information in ssa form. </title> <booktitle> Proceedings of the ACM Conference on Programming Language Design and Implementation, </booktitle> <year> 1993. </year>
Reference-contexts: Our work differs from these in that we are interested in maintaining the correctness of an internal program representation used to solve data flow problems, but which is not itself a data flow solution. Cytron and Gershbein <ref> [8] </ref> also present techniques for incrementally buidling SSA form to accommodate may-aliases. Their techniques deal with inserting special definitions, called may-defs, generated by may-aliases. Ryder and Carroll [12] present techniques for incrementally updating the dominator tree of a directed graph. Section 2 presents definitions and background material on SSA form.
Reference: [9] <author> T. J. Marlowe and B. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> ACM SIGPLAN Symp. on Principles of Programming Language, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Previous work on incremental data flow analysis focuses on obtaining an updated fixed-point solution after a small program change <ref> [5, 4, 10, 9] </ref>. These incremental data flow techniques apply to any monotone data flow problem expressed 1 within the classic data flow framework.
Reference: [10] <author> Thomas J. Marlowe. </author> <title> Data Flow Analysis and Incremental Iteration. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Previous work on incremental data flow analysis focuses on obtaining an updated fixed-point solution after a small program change <ref> [5, 4, 10, 9] </ref>. These incremental data flow techniques apply to any monotone data flow problem expressed 1 within the classic data flow framework.
Reference: [11] <author> David A. Padua and Michael J. Wolfe. </author> <title> Advanced compiler optimizations for supercomputers. </title> <journal> Communications of the ACM, </journal> <volume> 29(12) </volume> <pages> 1184-1201, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: It is important to use more efficient customized SSA-update algorithms for common loop transformations because: * Loop transformations are increasingly important in multi-pass compilers to facilitate instruction scheduling, increase parallelism, improve reference locality, and enable other optimiza tions <ref> [11] </ref>. * Loop transformations often constitute a small program change, relative to the size of the procedure. * SSA form for loops has special properties which make incremental update on a single loop basis efficient and straightforward.
Reference: [12] <author> Barbara G. Ryder and Martin D. Carroll. </author> <title> Incrementally updating the dominator tree of a rooted diagraph. </title> <type> Technical report, </type> <institution> Rutgers U., </institution> <month> December </month> <year> 1986. </year> <institution> Center for Computer Aids for Industrial Productivity Technical Report CAIP-TR-029. </institution>
Reference-contexts: Cytron and Gershbein [8] also present techniques for incrementally buidling SSA form to accommodate may-aliases. Their techniques deal with inserting special definitions, called may-defs, generated by may-aliases. Ryder and Carroll <ref> [12] </ref> present techniques for incrementally updating the dominator tree of a directed graph. Section 2 presents definitions and background material on SSA form. Section 3 presents basic techniques for updating SSA form after changes to individual assignment statements and program loops.
Reference: [13] <author> Vivek Sarkar. </author> <title> The ptran parallel programming system. </title> <booktitle> Parallel Functional Programming Languages and Compilers, </booktitle> <pages> pages 309-391, </pages> <year> 1991. </year>
Reference-contexts: and We denote the header node of interval I by hdr (I). 2 Informally, Interval (h) is the union of all the nodes in I fl (h) that do not "belong to" intervals nested in I fl (h), and edges between these nodes. 2 The program representation used in PTRAN <ref> [1, 13] </ref> is an augmented control flow graph, (CF G aug ). As compared to the original CF G, CF G aug makes loop (interval) structure evident via preheader and postexit nodes. These extra nodes also provide convenient locations for summarizing data flow information for the loop. <p> Figure 1 shows an example CF G and the corresponding CF G aug . More details on how to compute CF G aug of a CF G are given in <ref> [1, 13] </ref>. 2.2 Properties of SSA Rendering a program into SSA form simplifies and increases the accuracy of solving a useful subset of data-flow optimization problems, such as constant propagation [16], global value numbering [3], and program equivalence detection [18].
Reference: [14] <author> Vivek Sarkar and Radhika Thekkath. </author> <title> A general framework for iteration-reordering loop transformations. </title> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 175-187, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Therefore, no further update is required. 2 This result can be extended to any general permutation of n triangular/trapezoidal loops by applying the theorem pairwise to each pair of loops (x,y) such that 1 x &lt; y n and perm [x] &gt; perm [y] <ref> [14] </ref>. <p> skewing, unimod-ular, blocking, coalescing or any combination thereof can be represented by the schema shown in with initialization statements that map the new index variables x 0 1 ; : : : ; x 0 n 0 to the old index variables x 1 ; : : :; x n <ref> [14] </ref>. From our earlier assumption that an index variable is local in scope to its loop construct, we can assume that variables x 1 ; : : : ; x n are local in scope to the loop body of the transformed loop nest shown in Figure 7.
Reference: [15] <author> Vugranam C. Sreedhar and Guang R. Gao. </author> <title> A linear time algorithm for placing -nodes. </title> <booktitle> In 22nd Annual ACM SIGACT-SIGPLAN Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 62-73, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Special variable definitions called f unctions are added to the program to represent multiple reaching definitions. This paper addresses the problem of rebuilding SSA form after program transformation. The traditional algorithm for building minimal SSA form <ref> [7, 15] </ref> is efficient but exhaustive. Even when program changes are small, the cost of updating SSA with this algorithm is proportional to the size of the procedure. As a result, maintaining current and correct SSA form during a multi-pass compilation process is prohibitively expensive.
Reference: [16] <author> Mark Wegman and Ken Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> pages 181-210, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Static single assignment (SSA) form is a compact intermediate program representation that is well suited to a large number of compiler optimization algorithms, including constant propagation <ref> [16] </ref>, global value numbering [3], and program equivalence detection [18]. In SSA form, each variable appears as a target of an assignment at most once, so that each variable use is reached by a single definition. <p> More details on how to compute CF G aug of a CF G are given in [1, 13]. 2.2 Properties of SSA Rendering a program into SSA form simplifies and increases the accuracy of solving a useful subset of data-flow optimization problems, such as constant propagation <ref> [16] </ref>, global value numbering [3], and program equivalence detection [18]. These results are largely due to the statically functional nature of an SSA form program: each "variable" in the transformed program appears as the target of exactly one assignment statement.
Reference: [17] <author> Michael J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> Pitman, London and The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year> <title> In the series, </title> <note> Research Monographs in Parallel and Distributed Computing This monograph is a revised version of the author's Ph.D. dissertation published as Technical Report UIUCDCS-R-82-1105, </note> <institution> U. Illinois at Urbana-Champaign, </institution> <year> 1982. </year>
Reference-contexts: In this section, we discuss many popular loop-oriented program transformations, and present incremental update algorithms that are more efficient than the algorithms in Section 3 for these special-case loop transformations. 4.1 Interchange of Rectangular Loops The effect of loop interchange <ref> [17] </ref> is to interchange two perfectly nested loops as shown below in Fortran-like syntax: do i = e1, e2, e3 do j = e4, e5, e6 BODY ---&gt; BODY enddo enddo enddo enddo (BEFORE) (AFTER) The above schema assumes that loops i and j are rectangular i.e. expressions e4, e5, e6 <p> The O (n) execution-time complexity is independent of the size of the loop body. 11 4.2 Interchange of Trapezoidal Loops The loop interchange transformation can also be applied to triangular/trapezoidal loops (i.e. cases in which e4, e5 are linear functions of i, and e3, e6 are compile-time constants) as follows <ref> [17] </ref>: do i = e1, e2, e3 do j = e7, e8, e9 BODY ---&gt; BODY enddo enddo enddo enddo The loop body is unchanged as in the case of rectangular loop interchange. <p> However, it may be necessary to generate new loop bound expressions that are different from the old loop bound expressions as in the following example from <ref> [17] </ref>: do i = 1, n, 1 do j = 1, n+n, 1 BODY ---&gt; BODY enddo enddo enddo enddo and after interchange of trapezoidal loops. The lines labeled with **** identify the computations that have been altered after applying the transformation.
Reference: [18] <author> Wuu Yang, Susan Horwitz, and Thomas Reps. </author> <title> Detecting program components with equivalent behaviors. </title> <type> Technical report, </type> <institution> University of Wisconsin, Madison, </institution> <month> April </month> <year> 1989. </year> <note> Computer Sciences Technical Report Number 840. 17 </note>
Reference-contexts: 1 Introduction Static single assignment (SSA) form is a compact intermediate program representation that is well suited to a large number of compiler optimization algorithms, including constant propagation [16], global value numbering [3], and program equivalence detection <ref> [18] </ref>. In SSA form, each variable appears as a target of an assignment at most once, so that each variable use is reached by a single definition. Special variable definitions called f unctions are added to the program to represent multiple reaching definitions. <p> compute CF G aug of a CF G are given in [1, 13]. 2.2 Properties of SSA Rendering a program into SSA form simplifies and increases the accuracy of solving a useful subset of data-flow optimization problems, such as constant propagation [16], global value numbering [3], and program equivalence detection <ref> [18] </ref>. These results are largely due to the statically functional nature of an SSA form program: each "variable" in the transformed program appears as the target of exactly one assignment statement.
References-found: 18

