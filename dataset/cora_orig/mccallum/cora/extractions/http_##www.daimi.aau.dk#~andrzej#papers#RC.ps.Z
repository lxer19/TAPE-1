URL: http://www.daimi.aau.dk/~andrzej/papers/RC.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Email: (danvy@cis.ksu.edu)  (Andrzej.Filinski@cs.cmu.edu)  
Phone: 2  
Title: Representing control: a study of the CPS transformation O L I V I E R
Author: E J F I L I N S K I 
Date: Received February 1991; Revised June 1992  
Address: 66506, USA.  Pittsburgh, Pennsylvania 15213, USA.  
Affiliation: 1 Department of Computing and Information Sciences, Kansas State University, Manhattan, Kansas  School of Computer Science, Carnegie Mellon University,  
Note: Math. Struct. in Comp. Science (1992), vol. 2, pp. 361-391. PREPRINT  
Abstract: This paper investigates the transformation of v -terms into continuation-passing style (CPS). We show that by appropriate j-expansion of Fischer and Plotkin's two-pass equational specification of the CPS transform, we can obtain a static and context-free separation of the result terms into "essential" and "administrative" constructs. Interpreting the former as syntax builders and the latter as directly executable code, we obtain a simple and efficient one-pass transformation algorithm, easily extended to conditional expressions, recursive definitions, and similar constructs. This new transformation algorithm leads to a simpler proof of Plotkin's simulation and indifference results. We go on to show how CPS-based control operators similar to, but more general than, Scheme's call/cc can be naturally accommodated by the new transformation algorithm. To demonstrate the expressive power of these operators, we use them to present an equivalent but even more concise formulation of the efficient CPS transformation algorithm. Finally, we relate the fundamental ideas underlying this derivation to similar concepts from other works on program manipulation; we derive a one-pass CPS transformation of n -terms; and we outline some promising areas for future research. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Appel, A. W. </author> <year> (1992). </year> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press. </publisher>
Reference-contexts: O. Danvy and A. Filinski 24 6. Related Work 6.1. CPS transformation Two other works have independently employed CPS translations similar to the one presented here. The first one is Appel's CPS transformer in the Standard ML of New Jersey compiler <ref> (Appel, 1992) </ref>. The second one is Wand's combinator-based compilation technique (Wand, 1991). But neither motivate their transformer, e.g., as we do in Section 2, nor extend it to control operators or normal order, as we do in Sections 5 and 7.
Reference: <author> Bondorf, A. </author> <year> (1991). </year> <title> Automatic autoprojection of higher-order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 17 </volume> <pages> 3-34. </pages>
Reference-contexts: Recent works by Bondorf and the first author emphasize the issues of code duplication and termination properties <ref> (Bondorf and Danvy, 1991) </ref>, and use the technique of enumerating finitary constructs (Bondorf, 1991), as we do in Sections 2 and 4.2. The latter is also central to Shivers's work on higher-order flow analysis (Shivers, 1991). All these concepts were pervasive in our derivation of a one-pass CPS transformer. <p> Recent works by Bondorf and the first author emphasize the issues of code duplication and termination properties (Bondorf and Danvy, 1991), and use the technique of enumerating finitary constructs <ref> (Bondorf, 1991) </ref>, as we do in Sections 2 and 4.2. The latter is also central to Shivers's work on higher-order flow analysis (Shivers, 1991). All these concepts were pervasive in our derivation of a one-pass CPS transformer.
Reference: <author> Bondorf, A. and Danvy, O. </author> <year> (1991). </year> <title> Automatic autoprojection of recursive equations with global variables and abstract data types. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 151-195. </pages>
Reference-contexts: Recent works by Bondorf and the first author emphasize the issues of code duplication and termination properties <ref> (Bondorf and Danvy, 1991) </ref>, and use the technique of enumerating finitary constructs (Bondorf, 1991), as we do in Sections 2 and 4.2. The latter is also central to Shivers's work on higher-order flow analysis (Shivers, 1991). All these concepts were pervasive in our derivation of a one-pass CPS transformer. <p> Recent works by Bondorf and the first author emphasize the issues of code duplication and termination properties (Bondorf and Danvy, 1991), and use the technique of enumerating finitary constructs <ref> (Bondorf, 1991) </ref>, as we do in Sections 2 and 4.2. The latter is also central to Shivers's work on higher-order flow analysis (Shivers, 1991). All these concepts were pervasive in our derivation of a one-pass CPS transformer.
Reference: <author> Clinger, W. </author> <year> (1984). </year> <title> The Scheme 311 compiler, an exercise in Denotational Semantics. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 356-364, </pages> <address> Austin, Texas. </address>
Reference-contexts: Or equivalently we can duplicate the rules to account for tail-call contexts, as in Figure 3, and in a way reminiscent of Clinger's double induction proof in his Scheme compiler <ref> (Clinger, 1984) </ref>. Rationale: The auxiliary translation [[:::]] 0 is used when the static continuation would have the form m:@k m; this avoids building an j-redex in the transformation of applications (hence the term "properly tail-recursive" (Steele, 1978)). <p> These cases can be handled by a suitable series of tests on intermediate result or again by duplicating the rules as in (2), and [[:::]] 00 terms correspond to case (3). This suggests that a Clinger-style compiler for n -terms would be proven using a triple induction hypothesis <ref> (Clinger, 1984) </ref>.
Reference: <editor> Clinger, W. and Rees, J., editors (1991). </editor> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <publisher> IV(3):1-55. </publisher>
Reference-contexts: Prerequisites In the following, we will assume a basic familiarity with CPS and the v -calculus, i.e., the applicative order -calculus that forms the core of languages such as Scheme <ref> (Clinger and Rees, 1991) </ref> and Standard ML (Milner et al., 1990). For convenience in referring to individual applications, we will generally express them with an explicit operator @, writing @M N instead of the traditional simple juxtaposition M N .
Reference: <author> Consel, C. and Danvy, O. </author> <year> (1991a). </year> <title> Static and dynamic semantics processing. </title> <booktitle> In (POPL, </booktitle> <year> 1991), </year> <pages> pages 14-24. </pages>
Reference-contexts: Partial evaluation Partial evaluation (or more accurately: program specialization (Jones et al., 1989)) makes heavy use of binding time information to process the static and the dynamic semantics of source programs <ref> (Consel and Danvy, 1991a) </ref>, as we do here. Recent works by Bondorf and the first author emphasize the issues of code duplication and termination properties (Bondorf and Danvy, 1991), and use the technique of enumerating finitary constructs (Bondorf, 1991), as we do in Sections 2 and 4.2.
Reference: <author> Consel, C. and Danvy, O. </author> <year> (1991b). </year> <title> For a better support of static data flow. </title> <booktitle> In Proceedings of the Fifth ACM Conference on Functional Programming and Computer Architecture, number 523 in Lecture Notes in Computer Science, </booktitle> <pages> pages 496-519, </pages> <address> Cambridge, Massachusetts. </address>
Reference-contexts: The former is a two-level version of the latter. Moreover, our derivation illustrates a new trend in partial evaluation: using CPS to improve binding time properties of source programs, leading to better specialization <ref> (Consel and Danvy, 1991b) </ref>. Work is going on to further automate the process. 7. Conclusion and Issues As proven constructively in this paper, transforming -terms into CPS can be expressed in one pass by moving administrative redexes to translation time in a context-free way.
Reference: <author> Danvy, O. </author> <year> (1989). </year> <title> Programming with tighter control. </title> <journal> Special issue of the BIGRE journal: Putting Scheme to Work, </journal> (65):10-29. 
Reference-contexts: Earlier on, prompts were specified with an operational description in terms of textual reductions (Felleisen, 1988). In general, these static vs. dynamic interpretations lead to different behaviors <ref> (Danvy, 1989) </ref>. In our framework, reset naturally is the direct style counterpart of initializing the continuation of a CPS -term with the identity function. Reset seems to be equivalent to prompt, but terms using control in general have no CPS counterpart. 5.4.
Reference: <author> Danvy, O. </author> <year> (1992). </year> <title> Back to direct style. </title> <editor> In Krieg-Bruckner, B., editor, </editor> <booktitle> Proceedings of the Fourth European Symposium on Programming, number 582 in Lecture Notes in Computer Science, </booktitle> <pages> pages 130-150, </pages> <publisher> Rennes, </publisher> <address> France. </address>
Reference: <author> Danvy, O. and Filinski, A. </author> <year> (1990). </year> <title> Abstracting control. </title> <booktitle> In (LFP, </booktitle> <year> 1990), </year> <pages> pages 151-160. </pages>
Reference-contexts: Danvy and A. Filinski 20 structures, where further tests may depend on outcome of previous "guesses", e.g., for simulating a nondeterministic finite automaton <ref> (Danvy and Filinski, 1990) </ref>. 5.3. <p> But the second CPS transformation now gives a proper CPS term (with h as the continuation parameter): let f cc = x:k:h:k x (a:k a h) Remark: Iterating this construction leads to "extended CPS" and a whole hierarchy of control operators <ref> (Danvy and Filinski, 1990) </ref>. This is the real forte of a CPS-based approach to advanced control structures: we obtain a natural notion of "levels" of control, allowing us to express, e.g., collections over all paths of a nondeterministic subcomputation, as defined in Section 5.2. 5.5. <p> These could be unfolded by substituting the control abstractions for the identifiers in the translated terms, as we first specified it <ref> (Danvy and Filinski, 1990) </ref>: [[escape c in M ]] = :(@[[M [c c 0 ]]])[c 0 a: 0 :@ a] [[shift c in M ]] = :(@[[M [c c 0 ]]](m:m))[c 0 a: 0 :@ 0 (@a)] However, these substitutions introduce residual fi-redexes when control abstractions are applied within the scope <p> On the other hand, we can get an interpretive semantics for the extended language by translating a trivial (i.e., defining shift in terms of shift, etc.) self-interpreter into extended CPS <ref> (Danvy and Filinski, 1990) </ref>. This correspondence helps to ensure consistency between the two methods of language definition. O. Danvy and A. Filinski 24 6. Related Work 6.1. CPS transformation Two other works have independently employed CPS translations similar to the one presented here. <p> In particular, shift and reset are introduced together as representing composition and identity on continuation functions respectively; proper CPS form is restored by iterating the CPS transformation <ref> (Danvy and Filinski, 1990) </ref>. 6.4. Partial evaluation Partial evaluation (or more accurately: program specialization (Jones et al., 1989)) makes heavy use of binding time information to process the static and the dynamic semantics of source programs (Consel and Danvy, 1991a), as we do here. <p> And in fact, recent developments seem to support this conviction (Murthy, 1992). Moreover, there is a close relationship between computational monads (Moggi, 1989) and "generalized CPS", as suggested in "Abstracting Control" <ref> (Danvy and Filinski, 1990) </ref> and properly formalized by Wadler (Wadler, 1992). Effectively, this implies that CPS-based control operators like shift and reset can by themselves uniformly express a rich class of computational behaviors, including partiality, nondeterminism, and state.
Reference: <author> O. Danvy and A. Filinski 30 Danvy, O. and Lawall, J. L. </author> <year> (1992). </year> <title> Back to direct style II: First-class continuations. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, California. </address>
Reference: <author> Danvy, O. and Talcott, C. L., </author> <title> editors (1992). </title> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Continuations, </booktitle> <address> San Francisco, </address> <institution> California. </institution> <type> Technical report, </type> <institution> Stanford University. </institution>
Reference: <author> Duba, B. F., Harper, R., and MacQueen, D. </author> <year> (1991). </year> <title> Typing first-class continuations in ML. </title> <booktitle> In (POPL, </booktitle> <year> 1991), </year> <pages> pages 163-173. </pages>
Reference-contexts: We adopt the same simple solution: at syntax-analysis time, occurrences of identifiers declared within a control O. Danvy and A. Filinski 22 abstraction are guaranteed to occur only in application position, which we single out by tagging this application with throw, as in Standard ML of New Jersey <ref> (Duba et al., 1991) </ref>. [[escape c in M ]] = :(@[[M [c c 0 ]]])[c 0 a: 0 :@ a] [[shift c in M ]] = :(@[[M [c c 0 ]]](m:m))[c 0 a: 0 :@ 0 (@a)] [[throw c M ]] = :@[[M]] (m:@(@c m) ) To avoid dealing with substitutions
Reference: <author> Felleisen, M. </author> <year> (1988). </year> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <address> San Diego, California. </address>
Reference-contexts: Danvy and A. Filinski 20 structures, where further tests may depend on outcome of previous "guesses", e.g., for simulating a nondeterministic finite automaton (Danvy and Filinski, 1990). 5.3. Control and prompt While shift and reset are very similar to Felleisen's operators control and prompt <ref> (Felleisen, 1988) </ref>, there is a significant semantical difference between shift/reset and control/prompt: the context abstracted by shift is determined statically by the static program text, while control captures the context up to the nearest dynamically enclosing prompt. <p> Their two denotational descriptions introduce an algebra of control and lead to a representation of continuations as prompt-delimited sequences of activation frames, and their composition as the concatenation of these sequences <ref> (Felleisen et al., 1988) </ref>. Earlier on, prompts were specified with an operational description in terms of textual reductions (Felleisen, 1988). In general, these static vs. dynamic interpretations lead to different behaviors (Danvy, 1989). <p> Their two denotational descriptions introduce an algebra of control and lead to a representation of continuations as prompt-delimited sequences of activation frames, and their composition as the concatenation of these sequences (Felleisen et al., 1988). Earlier on, prompts were specified with an operational description in terms of textual reductions <ref> (Felleisen, 1988) </ref>. In general, these static vs. dynamic interpretations lead to different behaviors (Danvy, 1989). In our framework, reset naturally is the direct style counterpart of initializing the continuation of a CPS -term with the identity function. <p> However, because CPS appears to constrain expressive power, Felleisen and others have successively proposed new control operators to compose continuations (Felleisen et al., 1987a) and to limit their extent <ref> (Felleisen, 1988) </ref>. As later shown by Sitaram and Felleisen (Sitaram and Felleisen, 1990), inclusion of control delimiters is also necessary to obtain fully abstract models of control for CPS models with escape.
Reference: <author> Felleisen, M., Friedman, D. P., Duba, B., and Merrill, J. </author> <year> (1987a). </year> <title> Beyond continuations. </title> <type> Technical Report 216, </type> <institution> Computer Science Department, Indiana University, Bloomington, Indiana. </institution>
Reference-contexts: Control operators From Reynolds's escape to call/cc in Scheme, control operators are nicely introduced within the CPS transformation (Reynolds, 1972; Felleisen et al., 1986). However, because CPS appears to constrain expressive power, Felleisen and others have successively proposed new control operators to compose continuations <ref> (Felleisen et al., 1987a) </ref> and to limit their extent (Felleisen, 1988). As later shown by Sitaram and Felleisen (Sitaram and Felleisen, 1990), inclusion of control delimiters is also necessary to obtain fully abstract models of control for CPS models with escape.
Reference: <author> Felleisen, M., Friedman, D. P., Kohlbecker, E., and Duba, B. </author> <year> (1986). </year> <title> Reasoning with continuations. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 131-141, </pages> <address> Cambridge, Massachusetts. </address> <publisher> IEEE. </publisher>
Reference: <author> Felleisen, M., Friedman, D. P., Kohlbecker, E., and Duba, B. </author> <year> (1987b). </year> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237. </pages>
Reference-contexts: Shift also differs from escape by not implicitly duplicating the current continuation (Felleisen's C-operator introduced the behavior of not duplicating continuations <ref> (Felleisen et al., 1987b) </ref>).
Reference: <author> Felleisen, M., Wand, M., Friedman, D. P., and Duba, B. F. </author> <year> (1988). </year> <title> Abstract continuations: A mathematical semantics for handling full functional jumps. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 52-62, </pages> <address> Snowbird, Utah. </address>
Reference-contexts: Danvy and A. Filinski 20 structures, where further tests may depend on outcome of previous "guesses", e.g., for simulating a nondeterministic finite automaton (Danvy and Filinski, 1990). 5.3. Control and prompt While shift and reset are very similar to Felleisen's operators control and prompt <ref> (Felleisen, 1988) </ref>, there is a significant semantical difference between shift/reset and control/prompt: the context abstracted by shift is determined statically by the static program text, while control captures the context up to the nearest dynamically enclosing prompt. <p> Their two denotational descriptions introduce an algebra of control and lead to a representation of continuations as prompt-delimited sequences of activation frames, and their composition as the concatenation of these sequences <ref> (Felleisen et al., 1988) </ref>. Earlier on, prompts were specified with an operational description in terms of textual reductions (Felleisen, 1988). In general, these static vs. dynamic interpretations lead to different behaviors (Danvy, 1989). <p> Their two denotational descriptions introduce an algebra of control and lead to a representation of continuations as prompt-delimited sequences of activation frames, and their composition as the concatenation of these sequences (Felleisen et al., 1988). Earlier on, prompts were specified with an operational description in terms of textual reductions <ref> (Felleisen, 1988) </ref>. In general, these static vs. dynamic interpretations lead to different behaviors (Danvy, 1989). In our framework, reset naturally is the direct style counterpart of initializing the continuation of a CPS -term with the identity function. <p> However, because CPS appears to constrain expressive power, Felleisen and others have successively proposed new control operators to compose continuations (Felleisen et al., 1987a) and to limit their extent <ref> (Felleisen, 1988) </ref>. As later shown by Sitaram and Felleisen (Sitaram and Felleisen, 1990), inclusion of control delimiters is also necessary to obtain fully abstract models of control for CPS models with escape.
Reference: <author> Filinski, A. </author> <year> (1992). </year> <title> Linear continuations. </title> <booktitle> In (POPL, </booktitle> <year> 1992), </year> <pages> pages 27-38. </pages>
Reference: <author> Fischer, M. J. </author> <year> (1972). </year> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of the ACM Conference on Proving Assertions about Programs, </booktitle> <pages> pages 104-109. </pages> <booktitle> SIGPLAN Notices, </booktitle> <volume> Vol. 7, No 1 and SIGACT News, No 14. </volume>
Reference: <author> Fradet, P. and Le Metayer, D. </author> <year> (1991). </year> <title> Compilation of functional languages by program transformation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13 </volume> <pages> 21-51. </pages>
Reference-contexts: However, readability appears to suffer when the continuation argument, which is often large, must be followed by others in an application. Making continuations occur first is used sometimes to compile functional programs by program transformation <ref> (Fradet and Le Metayer, 1991) </ref>. It is simple to write a one-pass CPS transformer where continuations precede values | just swap values and continuations in any of the specifications displayed in the figures. 5. Abstracting Control So far we have been investigating how to perform the CPS transformation.
Reference: <author> Griffin, T. G. </author> <year> (1990). </year> <title> A formulae-as-types notion of control. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 47-58, </pages> <address> San Fran-cisco, California. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the new translation, on the other hand, we get a direct correspondence between reduction steps in the original and the translated term. Remark: It does seem possible to modify the colon-translation to perform more administrative reductions at translation time <ref> (Griffin, 1990) </ref>. Nevertheless, a practical translation (i.e., for a full language like Scheme) based on such an approach could be awkward because of the combinatorial explosion arising from translation-time distinctions between values and non-values in source terms. Let us first observe a few elementary properties of the two-level translation.
Reference: <author> Griswold, R. E. and Griswold, M. T. </author> <year> (1983). </year> <title> The Icon Programming Language. </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: For example, let us consider a functional representation of "applicative" nondeterministic (in the sense of backtracking) programming, as embodied, e.g., in the programming language Icon <ref> (Griswold and Griswold, 1983) </ref>. Let us define a basic "nondeterministic choice" procedure: flip = ():shift c in @c tt _ @c ff When invoked, flip will "return" twice: once with each possible truth value.
Reference: <author> Harper, B. and Lillibridge, M. </author> <year> (1992). </year> <title> Polymorphic type assignment and CPS conversion. </title> <booktitle> In (Danvy and Talcott, </booktitle> <year> 1992). </year>
Reference-contexts: Thus, the translation seems compatible with a restricted variant of ML-style polymorphism in which generalization can only be applied to values <ref> (Harper and Lillibridge, 1992) </ref>. 4.2. On duplicating contexts The CPS translation above duplicates contexts for each conditional expression: [[P !M; N ]] = :@[[P ]] (p:p ! @[[M ]] ; @[[N]] ) which increases the size of residual terms, as pointed out by Steele (Steele, 1978).
Reference: <author> Jones, N. D., Sestoft, P., and Sondergaard, H. </author> <year> (1989). </year> <title> MIX: A self-applicable partial evaluator for experiments in compiler generation. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50. </pages> <booktitle> LFP (1990). Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, Nice, France. LFP (1992). Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, California. </address>
Reference-contexts: In particular, shift and reset are introduced together as representing composition and identity on continuation functions respectively; proper CPS form is restored by iterating the CPS transformation (Danvy and Filinski, 1990). 6.4. Partial evaluation Partial evaluation (or more accurately: program specialization <ref> (Jones et al., 1989) </ref>) makes heavy use of binding time information to process the static and the dynamic semantics of source programs (Consel and Danvy, 1991a), as we do here.
Reference: <author> Mellish, C. and Hardy, S. </author> <year> (1984). </year> <title> Integrating Prolog in the POPLOG environment. </title> <editor> In Campbell, J. A., editor, </editor> <booktitle> Implementations of PROLOG, </booktitle> <pages> pages 147-162. </pages> <publisher> Ellis Horwood. </publisher>
Reference-contexts: The CPS transformation permits a simple definition of generalized escape constructs like Scheme's call/cc. Such operators are often perceived to eliminate the need for explicit CPS programs. However, sometimes the greater generality of "genuine" CPS is actually needed to express an algorithm (e.g., to implement backtracking <ref> (Mellish and Hardy, 1984) </ref>.) Our investigation of the CPS transform leads naturally to the introduction of two new control operators, shift and reset, which allow the additional power of general CPS to be exploited in direct style programs.
Reference: <author> Milner, R., Tofte, M., and Harper, R. </author> <year> (1990). </year> <title> The Definition of Standard ML. </title> <publisher> The MIT Press. </publisher>
Reference-contexts: Prerequisites In the following, we will assume a basic familiarity with CPS and the v -calculus, i.e., the applicative order -calculus that forms the core of languages such as Scheme (Clinger and Rees, 1991) and Standard ML <ref> (Milner et al., 1990) </ref>. For convenience in referring to individual applications, we will generally express them with an explicit operator @, writing @M N instead of the traditional simple juxtaposition M N . This is a purely syntactical variation: no change or refinement of semantics is implied by the @-notation.
Reference: <author> Moggi, E. </author> <year> (1989). </year> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Pacific Grove, California. </address> <publisher> IEEE. </publisher>
Reference-contexts: And in fact, recent developments seem to support this conviction (Murthy, 1992). Moreover, there is a close relationship between computational monads <ref> (Moggi, 1989) </ref> and "generalized CPS", as suggested in "Abstracting Control" (Danvy and Filinski, 1990) and properly formalized by Wadler (Wadler, 1992). Effectively, this implies that CPS-based control operators like shift and reset can by themselves uniformly express a rich class of computational behaviors, including partiality, nondeterminism, and state.
Reference: <author> Murthy, C. R. </author> <year> (1990). </year> <title> Extracting Constructive Content from Classical Proofs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference: <author> Murthy, C. R. </author> <year> (1992). </year> <title> Control operators, hierarchies, and pseudo-classical type systems: A-translation at work. In (Danvy and Talcott, 1992). Representing Control 31 Nielson, </title> <editor> F. </editor> <year> (1989). </year> <title> Two-level semantics and abstract interpretation. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(2) </volume> <pages> 117-242. </pages>
Reference-contexts: We believe that any investigation of advanced control structures based on the CPS transform will be able to pick up and integrate such developments more directly than a free-standing approach derived from more intuitively "desirable" operational behavior could. And in fact, recent developments seem to support this conviction <ref> (Murthy, 1992) </ref>. Moreover, there is a close relationship between computational monads (Moggi, 1989) and "generalized CPS", as suggested in "Abstracting Control" (Danvy and Filinski, 1990) and properly formalized by Wadler (Wadler, 1992).
Reference: <author> Nielson, F. and Nielson, H. R. </author> <year> (1988). </year> <title> Two-level semantics and code generation. </title> <journal> Theoretical Computer Science, </journal> <volume> 56(1) </volume> <pages> 59-133. </pages>
Reference-contexts: One-pass CPS transformation of v -terms 2.5. The complete transformation To conclude, Figure 2 shows the final version of the transformer, without labels since they were only used for expository purposes. With its static/dynamic annotations, it can be read as a two-level specification a la Nielson and Nielson <ref> (Nielson and Nielson, 1988) </ref>. Operationally, the overlined 's and @'s correspond to functional abstractions and applications in the translation program, while only the underlined occurrences represent abstract-syntax constructors. Transforming a -term into CPS amounts to representing contexts (i.e., -terms with a hole) as -abstractions. <p> The latter is also central to Shivers's work on higher-order flow analysis (Shivers, 1991). All these concepts were pervasive in our derivation of a one-pass CPS transformer. In particular, the notion of a two-level - calculus as advocated in Nielson and Nielson's TML <ref> (Nielson and Nielson, 1988) </ref> proves useful to develop and to express new CPS transformations that distinguish properly between translation-time and run-time constructs. With respect to partial evaluation, this development illustrates the connection between a CPS transformer and a -calculus interpreter expressed in CPS.
Reference: <author> Plotkin, G. D. </author> <year> (1975). </year> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159. </pages> <booktitle> POPL (1991). Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, Florida. </address> <publisher> ACM Press. </publisher> <address> POPL (1992). </address> <booktitle> Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1. Introduction and Motivation The usual presentation of the continuation-passing style (CPS) transformation <ref> (Plotkin, 1975) </ref> is concise and simple, but tends to yield unreasonably large residual terms containing a lot of "administrative redexes." While these redexes turn out to be relatively harmless from a theoretical perspective, they do require a special twist (the so-called "colon-translation") for proving certain important properties of the transformation (Plotkin, <p> One therefore has to prove instead that the implication above holds "modulo administrative reductions". This is formalized by the so-called "colon-translation" developed by Plotkin <ref> (Plotkin, 1975) </ref>. For any term M and value K, one defines syntactically a term M : K and proves it equal to @[[M]] K with the first series of administrative reductions performed (i.e., corresponding to the term M 0 above). <p> Let us now recall the formal definition of the reduction strategies <ref> (Plotkin, 1975) </ref>: Definition 3. One-step by-value reduction is defined as follows: @(x:M ) V ! v M [x V ] @M N ! v @M 0 N @V N ! v @V N 0 (where V is a value), and similarly one-step by-name reduction: O. Danvy and A. <p> It seems natural to take this as another indication that both the theoretical and practical significance of functional representations of control will only grow stronger in the years to come. Appendix: call by name Let us consider Plotkin's equational specification for transforming a n -term into CPS <ref> (Plotkin, 1975) </ref>, as displayed in Figure 6. We want to apply the method of Section 2 to stage the CPS n -transformation. Again, taken literally, this translation yields artificial redexes that must be post-reduced in a second pass, although the size explosion is not as drastic as for call-by-value.
Reference: <author> Reynolds, J. C. </author> <year> (1972). </year> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of 25th ACM National Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston. </address>
Reference-contexts: Note, however, that we adopt this convention only to simplify the presentation, not to advocate a general style of programming which depends implicitly on argument evaluation order. Occasionally, we will use Reynolds's notion of "serious" and "trivial" v -terms <ref> (Reynolds, 1972) </ref>. Evaluating a serious term might loop so this term must be transformed into CPS, whereas evaluating a trivial one cannot loop so this term does not need to be transformed. Finally, let us recall the main property of a CPS -term: the independence of its reduction order.
Reference: <author> Riecke, J. G. </author> <year> (1989). </year> <title> Should a function continue? Master's thesis, </title> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, Mas-sachusetts. </address>
Reference: <author> Sabry, A. and Felleisen, M. </author> <year> (1992). </year> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In (LFP, </booktitle> <year> 1992). </year>
Reference: <author> Shivers, O. </author> <year> (1991). </year> <title> The semantics of Scheme control-flow analysis. </title> <editor> In Hudak, P. and Jones, N. D., editors, </editor> <title> Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 26, No 9, </volume> <pages> pages 190-198, </pages> <address> New Haven, Connecticut. </address> <publisher> ACM, ACM Press. </publisher>
Reference-contexts: Primitive operators Most CPS-based compilers (Steele, 1978; Appel, 1992; Wand, 1991) and program analyzers <ref> (Shivers, 1991) </ref> also use continuation-passing forms of even the primitive operators. However, the practical justification of such a "radical CPS" transform is not completely clear. In particular, the oft-quoted advantage of having explicit names for all subexpres-sions can be realized equally well with let-expressions. <p> The latter is also central to Shivers's work on higher-order flow analysis <ref> (Shivers, 1991) </ref>. All these concepts were pervasive in our derivation of a one-pass CPS transformer.
Reference: <author> Sitaram, D. and Felleisen, M. </author> <year> (1990). </year> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In (LFP, </booktitle> <year> 1990), </year> <pages> pages 161-175. </pages>
Reference-contexts: However, because CPS appears to constrain expressive power, Felleisen and others have successively proposed new control operators to compose continuations (Felleisen et al., 1987a) and to limit their extent (Felleisen, 1988). As later shown by Sitaram and Felleisen <ref> (Sitaram and Felleisen, 1990) </ref>, inclusion of control delimiters is also necessary to obtain fully abstract models of control for CPS models with escape.
Reference: <author> Steele Jr., G. L. </author> <year> (1978). </year> <title> Rabbit: A compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts. </institution>
Reference-contexts: However, such a "post-reduction" pass is often y This work was partly supported by NSF under grant CCR-9102625. O. Danvy and A. Filinski 2 integrated with other, independent simplifications and optimization steps, and leads to relatively complex CPS transformers <ref> (Steele, 1978) </ref>. In the following, we will consider a systematization of the two-pass CPS transformation by focusing the attention on redexes that are introduced by the transformation itself, and by explicitly not reducing what would correspond to redexes in the source -term. <p> Source terms are represented between double brackets and is a fresh variable. Taken literally, this translation yields many artificial "administrative" redexes that must be post-reduced in a second pass; only then do we obtain a result in what is commonly recognized as "continuation-passing style" <ref> (Steele, 1978) </ref>. <p> Rationale: The auxiliary translation [[:::]] 0 is used when the static continuation would have the form m:@k m; this avoids building an j-redex in the transformation of applications (hence the term "properly tail-recursive" <ref> (Steele, 1978) </ref>). <p> On duplicating contexts The CPS translation above duplicates contexts for each conditional expression: [[P !M; N ]] = :@[[P ]] (p:p ! @[[M ]] ; @[[N]] ) which increases the size of residual terms, as pointed out by Steele <ref> (Steele, 1978) </ref>. For example, translating the direct style expression @f ((x ! y; z) ! 4; 5) yields the more voluminous :x ! (y ! @(@f 4)(v:@k v) ; @(@f 5)(v:@k v) ) ; O. Danvy and A.
Reference: <author> Wadler, P. </author> <year> (1992). </year> <title> The essence of functional programming. </title> <booktitle> In (POPL, </booktitle> <year> 1992), </year> <pages> pages 1-14. </pages>
Reference-contexts: And in fact, recent developments seem to support this conviction (Murthy, 1992). Moreover, there is a close relationship between computational monads (Moggi, 1989) and "generalized CPS", as suggested in "Abstracting Control" (Danvy and Filinski, 1990) and properly formalized by Wadler <ref> (Wadler, 1992) </ref>. Effectively, this implies that CPS-based control operators like shift and reset can by themselves uniformly express a rich class of computational behaviors, including partiality, nondeterminism, and state.
Reference: <author> Wand, M. </author> <year> (1991). </year> <title> Correctness of procedure representations in higher-order assembly language. </title> <editor> In Brookes, S., Main, M., Melton, A., Mislove, M., and Schmidt, D., editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 294-311, </pages> <address> Pittsburgh, Pennsylvania. </address> <booktitle> 7th International Conference. </booktitle>
Reference-contexts: Filinski 24 6. Related Work 6.1. CPS transformation Two other works have independently employed CPS translations similar to the one presented here. The first one is Appel's CPS transformer in the Standard ML of New Jersey compiler (Appel, 1992). The second one is Wand's combinator-based compilation technique <ref> (Wand, 1991) </ref>. But neither motivate their transformer, e.g., as we do in Section 2, nor extend it to control operators or normal order, as we do in Sections 5 and 7.
References-found: 40

