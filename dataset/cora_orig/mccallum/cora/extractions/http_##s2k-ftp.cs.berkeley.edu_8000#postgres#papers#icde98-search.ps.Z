URL: http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/icde98-search.ps.Z
Refering-URL: http://gist.cs.berkeley.edu:8000/gist/gist1.html
Root-URL: http://www.cs.berkeley.edu
Title: Generalizing ``Search'' in Generalized Search Trees (extended abstract)  
Author: Paul M. Aoki 
Address: Berkeley, CA 94720-1776  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California  
Abstract: The generalized search tree, or GiST, defines a framework of basic interfaces required to construct a hierarchical access method for database systems. As originally specified, GiST only supports record selection. In this paper, we show how a small number of additional interfaces enable GiST to support a much larger class of operations. Members of this class, which includes nearest-neighbor and ranked search, user-defined aggregation and index-assisted selectivity estimation, are increasingly common in new database applications. The advantages of implementing these operations in the GiST framework include reduction of user development effort and the ability to use ``industrial strength'' concurrency and recovery mechanisms provided by expert implementors. 
Abstract-found: 1
Intro-found: 1
Reference: [ANDE88] <author> M.J. Anderson, R.L. Cole, W.S. Davidson, W.D. Lee, P.B. Passe, G. R. Ricard and L. W. Youngren, </author> <title> Index Key Range Estimator, </title> <type> U.S. Patent 4,774,657, </type> <institution> IBM Corp., </institution> <address> Armonk, NY, </address> <month> Sep. </month> <year> 1988. </year> <month> Filed June 6, </month> <year> 1986. </year>
Reference-contexts: Second, the non-parametric statistics used by commercial query optimizers necessarily have vulnerabilities related to their fixed resolution. Practitioners have recognized the latter problem and have shown that index-assisted approaches can be a cost-effective solution; Digital Rdb/VMS [ANTO93] (now Oracle Rdb) and IBM SQL/400 <ref> [ANDE88] </ref> (now IBM DB2/400) have long supplemented the standard selectivity estimation techniques by performing index probes. <p> This use of sloppy counts significantly reduces the rate of non-leaf-node updates [ANTO92]. Oracle Rdb uses the same 11 SQL/400 actually uses AS/400 radix trees, which are not height-balanced. The discussion here therefore takes some liberties with the ideas of <ref> [ANDE88] </ref>. For example, we ignore SQL/400's pilot probes, which only serve to estimate the radix tree height. traversal and partial-match logic as Rdb/VMS, so only STATEITER changes (to add the counts for each CONSISTENT entry instead of using fanout statistics).
Reference: [ANTO92] <author> G. Antoshenkov, </author> <title> Random Sampling from Pseudo-Ranked B + Trees, </title> <booktitle> Proc. 18th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Vancouver, BC, Canada, </address> <month> Aug. </month> <year> 1992, </year> <pages> 375-382. </pages>
Reference-contexts: Oracle has implemented pseudo-ranked B + -trees in Rdb 7.0 [SMIT96]. In essence, their ADJUSTKEYS algorithm makes the parent predicate slightly larger than the Union of the predicates in the child node. This use of sloppy counts significantly reduces the rate of non-leaf-node updates <ref> [ANTO92] </ref>. Oracle Rdb uses the same 11 SQL/400 actually uses AS/400 radix trees, which are not height-balanced. The discussion here therefore takes some liberties with the ideas of [ANDE88].
Reference: [ANTO93] <author> G. Antoshenkov, </author> <title> Dynamic Query Optimization in Rdb/VMS, </title> <booktitle> Proc. 9th IEEE Int'l Conf. on Data Eng., </booktitle> <address> Vienna, Austria, </address> <month> Apr. </month> <year> 1993, </year> <pages> 538-547. </pages>
Reference-contexts: Second, the non-parametric statistics used by commercial query optimizers necessarily have vulnerabilities related to their fixed resolution. Practitioners have recognized the latter problem and have shown that index-assisted approaches can be a cost-effective solution; Digital Rdb/VMS <ref> [ANTO93] </ref> (now Oracle Rdb) and IBM SQL/400 [ANDE88] (now IBM DB2/400) have long supplemented the standard selectivity estimation techniques by performing index probes.
Reference: [AOKI97] <author> P.M. Aoki, </author> <title> Generalizing ``Search'' in Generalized Search Trees, </title> <type> Tech. Rep. </type> <institution> UCB//CSD-97-950, Univ. of California, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Section 5 applies the new extensions to some of our test applications, giving specific examples of its use. (Further discussion of the remaining applications, along with an extensive description of related work for all of the applications, appears in the full paper <ref> [AOKI97] </ref>.) We conclude in Section 6 with a discussion of project status and future directions. 2. A re view of GiST In this section, we review the current state of generalized search tree research. <p> For example, a query optimizer might only invoke index estimation when the uncertainty of its histogram-based estimate is high. The estimated impact on the rest of the query plan might also be considered. There are many other possible directions, which we discuss in the full paper <ref> [AOKI97] </ref>. Acknowledgements Joe Hellerstein, Marcel Kornacker and Allison Woodruff hav e provided many comments that have improved the presentation and generality of the concepts in this paper. In particular, Marcel's skepticism about non-priority-based traversals inuenced the design of the traversal control interface. The feedback of Dr.
Reference: [ASTR76] <author> M.M. Astrahan, M.W. Blasgen, D. D. Chamberlin, K. P. Eswaran, J.N. Gray, P.P. Griffiths, W.F. King, R. A. Lorie, P.R. McJones, J.W. Mehl, G. R. Putzolu, I. L. Traiger, B.W. Wade and V. Watson, </author> <title> System R: Relational Approach to Database Management, </title> <journal> ACM Trans. Database Sys. </journal> <volume> 1, </volume> <month> 2 (June </month> <year> 1976), </year> <pages> 97-137. </pages>
Reference-contexts: The problem is not a lack of access method extension interfaces. The iterator interface (by which the database invokes access methods) existed in System R <ref> [ASTR76] </ref>. Query optimizer cost model interfaces (by which the database decides to invoke access methods) were introduced in the early extensible database prototypes (e.g., ADT-INGRES/POSTGRES [STON86] and Starburst [LIND87]). These well-understood interfaces still constitute the commercial state of the art [INFO97].
Reference: [BAT O88] <author> D. Batory, J.R. Barnett, J.F. Garza, K. P. Smith, K. Tsukuda, B.C. Twichell and T.E. Wise, </author> <title> GENESIS: An Extensible Database Management System, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> 14, </volume> <month> 11 (Nov. </month> <year> 1988), </year> <pages> 1711-1730. </pages>
Reference: [BERC97] <author> S. Berchtold, C. Bhm, D. A. Keim and H.-P. Kriegel, </author> <title> A Cost Model for Nearest Neighbor Search, </title> <booktitle> Proc. 16th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Sys., </booktitle> <address> Tucson, AZ, </address> <month> May </month> <year> 1997, </year> <pages> 78-86. </pages>
Reference-contexts: We present the algorithm of [HJAL95] here because (1) it is more clear and (2) it has been shown to be I/O-optimal <ref> [BERC97] </ref>. specific state includes the closest record found and the tightest bounding distance seen. Third, it uses algorithm-specific state to eliminate nodes from consideration. GiST only prunes subtrees using CONSISTENT. The SS-tree itself has three structural properties that GiST does not support cleanly. <p> kth closest entry that we have seen. (It can be shown that upper bound distances reduce the memory required but give no advantage in terms of bounding the actual search 10 Extensible systems such as Informix Universal Server typically require the definition of EQUALITY for all ADTs (defaulting to bit-equality). <ref> [BERC97] </ref>.) These techniques are easily implemented using a STATECONSISTENT method that maintains a separate, additional priority queue, specifically for pruning, of size k. Application of divergence control: Some kinds of similarity search use cluster centroids rather than bounding predicates.
Reference: [COME79] <author> D. Comer, </author> <title> The Ubiquitous B-tree, </title> <journal> Computing Surveys 11, </journal> <volume> 2 (1979), </volume> <pages> 122-137. </pages>
Reference-contexts: The subtrees recursively partition the data records. However, they do not necessarily partition the data space. GiST can therefore model ordered, space-partitioning trees (e.g., B + -trees <ref> [COME79] </ref>) as well as unordered, non-space-partitioning trees (e.g., R-trees [GUTT84]). Tw o terms will be used in this paper that require additional explanation.
Reference: [CORM90] <author> T.H. Cormen, C.E. Leiserson and R.L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: However, these amortized costs are not guaranteed for all work-loads and are often not achieved in practice <ref> [CORM90] </ref>. STATECONSISTENT returns a list of node entries to be inserted into the priority queue. For example, it may be used to prune the current node's list of CONSISTENT entries using the internal state.
Reference: [GUTT84] <author> A. Guttman, R-trees: </author> <title> A Dynamic Index Structure for Spatial Searching, </title> <booktitle> Proc. 1984 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1984, </year> <pages> 47-57. </pages>
Reference-contexts: The subtrees recursively partition the data records. However, they do not necessarily partition the data space. GiST can therefore model ordered, space-partitioning trees (e.g., B + -trees [COME79]) as well as unordered, non-space-partitioning trees (e.g., R-trees <ref> [GUTT84] </ref>). Tw o terms will be used in this paper that require additional explanation.
Reference: [HELL95] <author> J.M. Hellerstein, J.F. Naughton and A. Pfeffer, </author> <title> Generalized Search Trees for Database Systems, </title> <booktitle> Proc. 21st Int'l Conf. on Very Large Data Bases, </booktitle> <address> Zrich, Switzerland, </address> <month> Sep. </month> <year> 1995, </year> <pages> 562-573. </pages>
Reference-contexts: Writing this kind of structural maintenance code for an ``industrial strength'' access method requires a great deal of familiarity with buffer management, concurrency control and recovery protocols. To make matters worse, these protocols are different in every database server. The generalized search tree, or GiST <ref> [HELL95] </ref>, addresses this problem in part. Like the previous work in this area, GiST defines a set of interfaces for implementing a search index. <p> We say that GiST solves the access method problem ``in part'' because, as originally specified in <ref> [HELL95] </ref>, GiST does not provide the functionality required by certain advanced applications. For example, database extension modules for multimedia ADTs (images, video, audio, etc.) usually include specialized index structures. Unfortunately, these applications need specialized index operations as well. <p> However, they do not necessarily partition the data space. GiST can therefore model ordered, space-partitioning trees (e.g., B + -trees [COME79]) as well as unordered, non-space-partitioning trees (e.g., R-trees [GUTT84]). Tw o terms will be used in this paper that require additional explanation. First, for consistency with <ref> [HELL95] </ref>, we call each datum stored in p a ``predicate'' rather than a ``key'' or ``index column.'' Second, we describe the combination of an ADT and any GiST methods associated with that ADT as a domain. <p> In order to perform this compensation, we need to be able to control divergence between the predicate value and its expected value. <ref> [HELL95] </ref> proposed discussed interface interface in section CONSISTENT CONSISTENT UNION UNION PENALTY PENALTY PICKSPLIT PICKSPLIT Basic tree operations Optional tree operations 4.1 COMPRESS DECOMPRESS COMPRESS DECOMPRESS Specialized traversal operations PRIORITY 4.2 FINDMIN NEXT STATEINIT STATECONSISTENT STATEITER STATEFINAL 4.3 Stateful computation Divergence control ACCURATE 4.4 Table 1. <p> Finally, we (more thoroughly) justify the need for divergence control and demonstrate its uses. For convenience of reference, we summarize our interface changes in Table 1. The table classifies the old and new operations according to their functionality. In addition, the table clearly shows which of the operations of <ref> [HELL95] </ref> have been modified. The basic and optional operations, described in Section 2.2, remain largely unchanged. Additional specialized operations having to do with specific tree traversal algorithms have been generalized. Finally, the stateful computation and divergence control operations are entirely new. 4.1. <p> In the full paper, we show how the combination of priority queues and stateful computation eliminates the need for the special ordered traversal methods (FINDMIN and NEXT) described in <ref> [HELL95] </ref>. We also show that such ordered ``leaf scans'' can only work correctly for multiple predicates over ordinal domains, i.e., for multikey B -trees. 4.4. Divergence control In our new framework, a parent node entry predicate and the UNION of its child subtree predicates may diverge.
Reference: [HJAL95] <author> G. R. Hjaltason and H. Samet, </author> <title> Ranking in Spatial Databases, </title> <booktitle> in Advances in Spatial Databases (Proc. 4th Int'l Symp. on Spatial Databases, </booktitle> <address> Portland, ME, </address> <month> Aug. </month> <year> 1995), </year> <editor> M.J. Egenhofer and J.R. Herring (eds.), </editor> <publisher> Springer Verlag, LNCS Vol. </publisher> <address> 951, Berlin, </address> <year> 1995, </year> <pages> 83-95. </pages>
Reference-contexts: This algorithm and updated separately, it is more natural to treat them as separate predicates. 3 The SS-tree search algorithm originally presented in [WHIT96] is based on that of [ROUS95]. We present the algorithm of <ref> [HJAL95] </ref> here because (1) it is more clear and (2) it has been shown to be I/O-optimal [BERC97]. specific state includes the closest record found and the tightest bounding distance seen. Third, it uses algorithm-specific state to eliminate nodes from consideration. GiST only prunes subtrees using CONSISTENT.
Reference: [ILLU95] <author> Illustra User's Guide, </author> <title> Server Release 3.2, Part Number DBMS-00-42-UG, Illustra Information Technologies, </title> <publisher> Inc., </publisher> <address> Oakland, CA, </address> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: For example, one stateful computation is the standard aggregate function, COUNT. Other computations actually inuence the tree traversal (we briey described in Section 3.1 how node entries can be pruned from the search queue). Our new methods are modelled on Illustra's user-defined aggregate interface <ref> [ILLU95] </ref>. Each iterator consists of four methods. STATEINIT and STATEFINAL perform initialization and finalization, respectively, whereas STATE-CONSISTENT and STATEITER implement the computation over the node entries. They can be summarized as follows: STATEINIT allocates and initializes any internal state.
Reference: [INFO97] <institution> Guide to the Virtual-Table Interface, </institution> <note> Version 9.01, Part Number 000-3692, </note> <institution> Informix Corp., </institution> <address> Menlo Park, CA, </address> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: Query optimizer cost model interfaces (by which the database decides to invoke access methods) were introduced in the early extensible database prototypes (e.g., ADT-INGRES/POSTGRES [STON86] and Starburst [LIND87]). These well-understood interfaces still constitute the commercial state of the art <ref> [INFO97] </ref>. The problem is that these interfaces relate to the functions performed by access methods and do not isolate the primitive operations required to construct new access methods. <p> There are two main reasons for this. First, analytic selectivity estimation techniques may simply not exist for novel user-defined types and functions, and the techniques used for ordinal domains may not extend straightforwardly. Extensible database systems do provide selectivity function interfaces (e.g., the am_scancost interface in Informix Universal Server <ref> [INFO97] </ref>) but can only provide general guidance for their use. Second, the non-parametric statistics used by commercial query optimizers necessarily have vulnerabilities related to their fixed resolution.
Reference: [KORN97] <author> M. Kornacker, C. Mohan and J.M. Hellerstein, </author> <title> Concurrency and Recovery in Generalized Search Trees, </title> <booktitle> Proc. 1997 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> Tucson, AZ, </address> <month> May </month> <year> 1997, </year> <pages> 62-72. </pages>
Reference-contexts: However, the GiST interfaces are essentially expressed in terms of the abstract data types (ADTs) being indexed rather than in terms of pages, records and query processing primitives. Since a GiST implementor need not write any structural maintenance code, e.g., for concurrency control <ref> [KORN97] </ref>, they need not understand the server-specific protocols discussed in the previous paragraph. Given that database extension modules tend to be produced by domain knowledge experts rather than database server experts, we believe that GiST serves the majority of database extenders much better than the previous work.
Reference: [LIND87] <author> B. Lindsay, J. McPherson and H. Pirahesh, </author> <title> A Data Management Extension Architecture, </title> <booktitle> Proc. 1987 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> San Francisco, CA, </address> <month> May </month> <year> 1987, </year> <pages> 220-226. </pages>
Reference-contexts: The iterator interface (by which the database invokes access methods) existed in System R [ASTR76]. Query optimizer cost model interfaces (by which the database decides to invoke access methods) were introduced in the early extensible database prototypes (e.g., ADT-INGRES/POSTGRES [STON86] and Starburst <ref> [LIND87] </ref>). These well-understood interfaces still constitute the commercial state of the art [INFO97]. The problem is that these interfaces relate to the functions performed by access methods and do not isolate the primitive operations required to construct new access methods.
Reference: [LYNC88] <author> C.A. Lynch and M. Stonebraker, </author> <title> Extended User-Defined Indexing with Application to Textual Databases, </title> <booktitle> Proc. 14th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Los Angeles, CA, </address> <month> Aug. </month> <year> 1988, </year> <pages> 306-317. </pages>
Reference-contexts: For example, to build a multikey B + -tree over columns of type int and text, the user had to write C functions implementing a new int_text ADT and then create a functional B + -tree <ref> [LYNC88] </ref>. PICKSPLIT, which divides the entries of a split node among the new nodes, must now maintain the correctness of multiple predicates. Like PENALTY, PICKSPLIT uses successive domains to break ties.
Reference: [MURA88] <author> M. Muralikrishna and D. J. DeWitt, </author> <title> Equi-depth Histograms for Estimating Selectivity Factors for Multi-Dimensional Queries, </title> <booktitle> Proc. 1988 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> Chicago, IL, </address> <month> June </month> <year> 1988, </year> <pages> 28-36. </pages>
Reference-contexts: We are actively investigating improved techniques for selectivity estimation using GiSTs. Salient issues include: Many researchers have pointed out that multidimensional selectivity estimation can benefit from specialized main memory data structures that resemble condensed search trees (e.g., <ref> [MURA88] </ref>). Such structures could easily be constructed using GiST concepts; the costs and benefits of this approach relative to that of augmenting secondary memory structures (as dis cussed here) are not well-understood. Balancing I/O cost and estimation accuracy in traversal strategies. The previously proposed descent strategies have many obvious vulnerabilities.
Reference: [PU91] <author> C. Pu and A. Leff, </author> <title> Replica Control in Distributed Systems: An Asynchronous Approach, </title> <booktitle> Proc. 1991 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> Denver, CO, </address> <month> May </month> <year> 1991, </year> <pages> 377-386. </pages>
Reference-contexts: Checking the consistency of all of a node's entries at once allows us to do this. after that of the epsilon serializability literature <ref> [PU91] </ref>.) It is not immediately clear why div ergence between parent and child node predicates should be allowed. For example, too-large bounding predicates increase the number of ``false positive'' predicates, thereby increasing the number of nodes visited during SEARCH. Here, we justify the need for divergence control in new applications.
Reference: [ROUS95] <author> N. Roussopoulos, S. Kelley and F. Vincent, </author> <title> Nearest Neighbor Queries, </title> <booktitle> Proc. 1995 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995, </year> <pages> 71-79. </pages>
Reference-contexts: Second, unlike GiST's depth-first search, it has search state beyond a simple stack of unvisited nodes. This algorithm and updated separately, it is more natural to treat them as separate predicates. 3 The SS-tree search algorithm originally presented in [WHIT96] is based on that of <ref> [ROUS95] </ref>. We present the algorithm of [HJAL95] here because (1) it is more clear and (2) it has been shown to be I/O-optimal [BERC97]. specific state includes the closest record found and the tightest bounding distance seen. Third, it uses algorithm-specific state to eliminate nodes from consideration.
Reference: [SELI79] <author> P.G. Selinger, M.M. Astrahan, D. D. Chamberlin, R. A. Lorie and T.G. Price, </author> <title> Access Path Selection in a Relational Database Management System, </title> <booktitle> Proc. 1979 ACM SIGMOD Int'l Conf. on Mgmt. of Data, </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1979, </year> <pages> 23-34. </pages>
Reference-contexts: Obviously, more sophisticated estimation and traversal algorithms are possible. For example, one can use uniformity models <ref> [SELI79] </ref> in any domain in which we can sensibly measure degree of overlap. This is straightforward in multidimensional domains [WHAN94]. Again, this simply requires replacing STATEITER. Application of divergence control: Ranked trees are a good application for divergence control.
Reference: [SMIT96] <author> I. Smith, </author> <title> Oracle Rdb: </title> <address> What's New, in DECUS Spring '96 (St. Louis, MO), DECUS, Littleton, MA, </address> <month> June </month> <year> 1996, </year> <month> IM-016. </month>
Reference-contexts: Divergence does lead to some estimation inaccuracy, but at least the inaccuracy has tight bounds. Oracle has implemented pseudo-ranked B + -trees in Rdb 7.0 <ref> [SMIT96] </ref>. In essence, their ADJUSTKEYS algorithm makes the parent predicate slightly larger than the Union of the predicates in the child node. This use of sloppy counts significantly reduces the rate of non-leaf-node updates [ANTO92].
Reference: [SRIV88] <author> J. Srivastava and V.Y. Lum, </author> <title> A Tree Based Access Method (TBSAM) for Fast Processing of Aggregate Queries, </title> <booktitle> Proc. 4th IEEE Int'l Conf. on Data Eng., </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1988, </year> <pages> 504-510. </pages>
Reference-contexts: Fortunately, it adds no work in the common case, since the default ACCURATE is simply the EQUALITY method defined for each ADT. 10 That is, a parent entry predicate must be equal to the UNION of the predicates in the child node. The alternative, batched updates <ref> [SRIV88, WHIT96] </ref>, is of questionable value in almost any domain because it provides no bounds on the imprecision of the answers provided to the end-user. 5. Applications In this section, we show how to support several common traversal and computation operations in the framework just presented.
Reference: [STON86] <author> M.R. Stonebraker, </author> <title> Inclusion of New Types in Relational Data Base Systems, </title> <booktitle> Proc. 2nd IEEE Int'l Conf. on Data Eng., </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1986, </year> <pages> 262-269. </pages>
Reference-contexts: The iterator interface (by which the database invokes access methods) existed in System R [ASTR76]. Query optimizer cost model interfaces (by which the database decides to invoke access methods) were introduced in the early extensible database prototypes (e.g., ADT-INGRES/POSTGRES <ref> [STON86] </ref> and Starburst [LIND87]). These well-understood interfaces still constitute the commercial state of the art [INFO97]. The problem is that these interfaces relate to the functions performed by access methods and do not isolate the primitive operations required to construct new access methods.
Reference: [STON91] <author> M. Stonebraker and G. Kemnitz, </author> <title> The POSTGRES Next-Generation Database Management System, </title> <journal> Comm. ACM 34, </journal> <month> 10 (Oct. </month> <year> 1991), </year> <pages> 78-92. </pages>
Reference-contexts: In general, it is unreasonable to expect the user to define new ADTs for each combination of keys that could be stored in an index. A common complaint from POSTGRES <ref> [STON91] </ref> users was the need to define combined ADTs in order to achieve the functionality of standard multikey B + -trees.
Reference: [WHAN94] <author> K.-Y. Whang, S.-W. Kim and G. Wiederhold, </author> <title> Dynamic Maintenance of Data Distribution for Selectivity Estimation, </title> <journal> VLDB J. </journal> <volume> 3, </volume> <month> 1 (Jan. </month> <year> 1994), </year> <pages> 29-51. </pages>
Reference-contexts: Obviously, more sophisticated estimation and traversal algorithms are possible. For example, one can use uniformity models [SELI79] in any domain in which we can sensibly measure degree of overlap. This is straightforward in multidimensional domains <ref> [WHAN94] </ref>. Again, this simply requires replacing STATEITER. Application of divergence control: Ranked trees are a good application for divergence control.
Reference: [WHIT96] <author> D. A. White and R. Jain, </author> <title> Similarity Indexing with the SS-tree, </title> <booktitle> Proc. 12th IEEE Int'l Conf. on Data Eng., </booktitle> <address> New Orleans, LA, </address> <month> Feb. </month> <year> 1996, </year> <pages> 516-523. </pages>
Reference-contexts: When retrieving multiple items, users generally want the results ranked (ordered) by similarity. Similarity search, ranked search and the well-known nearest-neighbor problem are very closely related. For concreteness, our example will use a specific data structure, the SS-tree <ref> [WHIT96] </ref>. We choose the SS-tree because it is a feature vector access method that cannot be modelled using the original GiST design. <p> Also, the centroid is used separately during insertion. (For additional details, see <ref> [WHIT96] </ref>.) Since the SS-tree centroid and radius are often accessed node corresponds to one cluster, and the centroid and bounding radius of each cluster are stored in an entry in the cluster's parent node. <p> Second, unlike GiST's depth-first search, it has search state beyond a simple stack of unvisited nodes. This algorithm and updated separately, it is more natural to treat them as separate predicates. 3 The SS-tree search algorithm originally presented in <ref> [WHIT96] </ref> is based on that of [ROUS95]. We present the algorithm of [HJAL95] here because (1) it is more clear and (2) it has been shown to be I/O-optimal [BERC97]. specific state includes the closest record found and the tightest bounding distance seen. <p> Fortunately, it adds no work in the common case, since the default ACCURATE is simply the EQUALITY method defined for each ADT. 10 That is, a parent entry predicate must be equal to the UNION of the predicates in the child node. The alternative, batched updates <ref> [SRIV88, WHIT96] </ref>, is of questionable value in almost any domain because it provides no bounds on the imprecision of the answers provided to the end-user. 5. Applications In this section, we show how to support several common traversal and computation operations in the framework just presented.
References-found: 27

