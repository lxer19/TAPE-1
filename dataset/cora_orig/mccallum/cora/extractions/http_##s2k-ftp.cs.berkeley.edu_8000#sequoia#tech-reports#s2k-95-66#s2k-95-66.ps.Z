URL: http://s2k-ftp.cs.berkeley.edu:8000/sequoia/tech-reports/s2k-95-66/s2k-95-66.ps.Z
Refering-URL: http://s2k-ftp.cs.berkeley.edu:8000/sequoia/tech-reports/s2k-95-66/
Root-URL: http://www.cs.berkeley.edu
Email: aoki@CS.Berkeley.EDU  
Title: Recycling Secondary Index Structures  
Author: Paul M. Aoki 
Address: Berkeley, CA 94720-1776  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California  
Abstract: Several important database reorganization techniques move tuples in a table from one location to another in a single pass. For example, the Mariposa distributed database system frequently moves or copies tables between sites. However, moving a table generally invalidates the pointers contained in its secondary indices. Because index reconstruction is extremely resource-intensive, table movement has been considered a expensive operation. In this paper, we present simple, efficient mechanisms for translating index pointers. We also demonstrate their effectiveness using performance measurements of an implementation in Mariposa. Use of these mechanisms will enable parallel and distributed systems like Mariposa to move tables more freely, pro viding many more options for performance-enhancing reorganizations of the database. 
Abstract-found: 1
Intro-found: 1
Reference: [BECK90] <author> N. Beckmann, H. Kriegel, R. Schneider and B. Seeger, </author> <title> The R*-tree: An Efficient and Robust Access Method for Points and Rectangles, </title> <booktitle> Proc. 1990 ACM-SIGMOD Conf. on Management of Data, </booktitle> <address> Atlantic City, NJ, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Overow chains make it easy to grow or shrink buckets. By contrast, 4 naive splitting/merging of unordered tree structures such as R-trees is easy but intelligent split- ting/merging is much more difficult <ref> [BECK90] </ref>. 2 2.2. TID Translation In the remainder of the paper, we will use the terms translation and mapping to mean the same thing: conversion of S TIDs into valid T TIDs within the target index pages.
Reference: [CARE88] <author> M. J. Carey, D. J. DeWitt, G. Graefe, D. M. Haight, J. E. Richardson, D. T. Schuh, E. J. Shekita and S. L. Vandenberg, </author> <title> The EXODUS Extensible DBMS Project: An Overview, </title> <type> CS Tech. Rep. 808, </type> <institution> Univ. of Wisconsin, Madison, WI, </institution> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: This scheme is discussed in more detail elsewhere [GRAY93, p. 755]. Systems using this scheme include a wide range of relational and object-relational (e.g., Rdb/VMS [HOBB91, p. 79], nearly all IBM relational systems [MOHA93], POSTGRES [STON91], Illustra) as well as object-oriented (e.g., ObServer [HORN87], ESM <ref> [CARE88] </ref>) data managers.
Reference: [CHEN91] <author> J. Cheng, D. Haderle, R. Hedges, B. R. Iyer, T. Messinger, C. Mohan and Y. Wang, </author> <title> An Efficient Hybrid Join Algorithm: A DB2 Prototype, </title> <booktitle> Proc. 7th IEEE Int. Conf. on Data Eng., </booktitle> <address> Kobe, Japan, </address> <month> Apr. </month> <year> 1991, </year> <pages> 171-180. </pages>
Reference-contexts: One might think of applying one of 8 the many TID-join techniques to make this more efficient. Such techniques make the process of dereferencing many TIDs more I/O-efficient by reordering the references. For example, one might try to adapt ideas from hybrid join <ref> [CHEN91] </ref>. However, hybrid join requires several sorting steps (something we are trying to avoid because of its expense, especially since we join the entirety of both tables). Another alternative, the nested-block join algorithm, does not scale well.
Reference: [COCK84] <author> W. P. Cockshot, M. P. Atkinson, K. J. Chisholm, P. J. Bailey and R. Morrison, </author> <title> Persistent Object Management System, </title> <journal> SoftwarePractice & Experience 14, </journal> <month> 1 (Jan. </month> <year> 1984), </year> <pages> 49-71. </pages>
Reference-contexts: This is discussed in more detail in [GRAY93, p. 760]. All are used in one system or another. For example, object systems (e.g., POMS <ref> [COCK84] </ref>) often use relative byte addresses, whereas a few relational systems (e.g., NonStop SQL) use primary keys as TIDs. In fact, most database systems use a particular kind of TID instead of the physical TIDs discussed in [SUN94].
Reference: [DEWI91] <author> D. J. DeWitt, J. F. Naughton and D. A. Schneider, </author> <title> Parallel Sorting on a Shared-Nothing Architecture Using Probabilistic Splitting, </title> <booktitle> Proc. 1st Int. Conf. on Parallel and Dist. Info. Sys., </booktitle> <address> Miami Beach, FL, </address> <month> Dec. </month> <year> 1991, </year> <pages> 280-291. </pages>
Reference-contexts: Our bulk-load routine uses the standard technique of extracting -key,TID- pairs from the base table, sorting the pairs into index leaf pages and then building the rest of the tree bottom-up. Our external sorting routine follows the recent trend <ref> [DEWI91, GRAE92, NYBE94] </ref> toward quicksort-based run generation and uses large private buffers to accelerate its sequential I/O. A credible sort/build bulk-load is important as a base case for our tests, inasmuch as insertion-load is not used in practice.
Reference: [EICK95] <author> A. Eickler, C. A. Gerlhof and D. Kossmann, </author> <title> A Performance Evaluation of OID Mapping Techniques, </title> <booktitle> Proc. 21st VLDB Conf., </booktitle> <address> Zurich, Switzerland, </address> <month> Sep. </month> <year> 1995. </year> <note> (To appear.). </note>
Reference-contexts: When primary memory pointers are OIDs, the how (as opposed to the when) part of swizzling is known as the OID mapping problem. The mechanisms used include segmented mapping tables (e.g., ObServer [HORN87]), hash tables (e.g., Itasca <ref> [EICK95] </ref>) and B-trees (e.g., GemStone [MAIE87]). Simple data structures full of OID fi address entries work in this environment because programs frequently exhibit locality of reference and have small reference sets. This means that the portion of the mapping structure kept in memory will be small and well-utilized.
Reference: [GRAE92] <author> G. Graefe and S. S. Thakkar, </author> <title> Tuning a Parallel Database Algorithm on a Shared-Memory Multiprocessor, </title> <journal> SoftwarePractice & Experience 22, </journal> <month> 7 (July </month> <year> 1992), </year> <pages> 495-517. </pages>
Reference-contexts: Our bulk-load routine uses the standard technique of extracting -key,TID- pairs from the base table, sorting the pairs into index leaf pages and then building the rest of the tree bottom-up. Our external sorting routine follows the recent trend <ref> [DEWI91, GRAE92, NYBE94] </ref> toward quicksort-based run generation and uses large private buffers to accelerate its sequential I/O. A credible sort/build bulk-load is important as a base case for our tests, inasmuch as insertion-load is not used in practice.
Reference: [GRAY93] <author> J. Gray and A. Reuter, </author> <title> Tr ansaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Just as one can have physical, logical or physiological logging, one can have physical TIDs (e.g., relative byte addresses of the form -page,offset-), logical TIDs (e.g., primary key addresses of the form -key-), and any number of hybrid physiological TIDs (e.g., -page,key-). This is discussed in more detail in <ref> [GRAY93, p. 760] </ref>. All are used in one system or another. For example, object systems (e.g., POMS [COCK84]) often use relative byte addresses, whereas a few relational systems (e.g., NonStop SQL) use primary keys as TIDs. <p> Although index is an index into a physical array, it is immutable (as long as the tuple does not move to a different page) and is therefore a logical identifier within the page. This scheme is discussed in more detail elsewhere <ref> [GRAY93, p. 755] </ref>. Systems using this scheme include a wide range of relational and object-relational (e.g., Rdb/VMS [HOBB91, p. 79], nearly all IBM relational systems [MOHA93], POSTGRES [STON91], Illustra) as well as object-oriented (e.g., ObServer [HORN87], ESM [CARE88]) data managers.
Reference: [HOBB91] <author> L. Hobbs and K. </author> <title> England, Rdb/VMS: A Comprehensive Guide, </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1991. </year> <title> DEC Order Number EY-H873E-DP. </title>
Reference-contexts: This scheme is discussed in more detail elsewhere [GRAY93, p. 755]. Systems using this scheme include a wide range of relational and object-relational (e.g., Rdb/VMS <ref> [HOBB91, p. 79] </ref>, nearly all IBM relational systems [MOHA93], POSTGRES [STON91], Illustra) as well as object-oriented (e.g., ObServer [HORN87], ESM [CARE88]) data managers.
Reference: [HORN87] <author> M. F. Hornick and S. B. Zdonik, </author> <title> A Shared, Segmented Memory System for an Object-Oriented Database, </title> <journal> Tr ans. on Office Info. Systems 5, </journal> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 70-95. </pages>
Reference-contexts: When primary memory pointers are OIDs, the how (as opposed to the when) part of swizzling is known as the OID mapping problem. The mechanisms used include segmented mapping tables (e.g., ObServer <ref> [HORN87] </ref>), hash tables (e.g., Itasca [EICK95]) and B-trees (e.g., GemStone [MAIE87]). Simple data structures full of OID fi address entries work in this environment because programs frequently exhibit locality of reference and have small reference sets. <p> This scheme is discussed in more detail elsewhere [GRAY93, p. 755]. Systems using this scheme include a wide range of relational and object-relational (e.g., Rdb/VMS [HOBB91, p. 79], nearly all IBM relational systems [MOHA93], POSTGRES [STON91], Illustra) as well as object-oriented (e.g., ObServer <ref> [HORN87] </ref>, ESM [CARE88]) data managers.
Reference: [KAME94] <author> I. Kamel and C. Faloutsos, Hilbert R-tree: </author> <title> An Improved R-tree Using Fractals, </title> <institution> CS-TR-3032 , Univ. of Maryland Institute for Advanced Computer Studies, Dept. of Computer Science, Univ. of Maryland, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: For example, assume for the moment that (1) we are using physical -page,offset- TIDs, (2) tuples cannot change size and cannot be reordered, and (3) old 2 Fortunately, in some cases we can impose an inexpensive linear ordering that clusters the data (e.g., least Hilbert value clustering <ref> [KAME94] </ref>), which makes the R-tree more closely resemble the B + -tree in terms of our ability to make local clustering decisions. 5 pages map directly to a fixed number of new pages (e.g., using a constant expansion or contrac-tion factor).
Reference: [LITW80] <author> W. Litwin, </author> <title> Linear Hashing: A New Tool for File and Table Addressing, </title> <booktitle> Proc. 6th VLDB Conf., </booktitle> <address> Montreal, Quebec, </address> <month> Oct. </month> <year> 1980, </year> <pages> 212-223. </pages>
Reference-contexts: Dynamic hashing access methods that use external overow techniques, such as linear hashing <ref> [LITW80] </ref>, should also be amenable to recycling. Overow chains make it easy to grow or shrink buckets. By contrast, 4 naive splitting/merging of unordered tree structures such as R-trees is easy but intelligent split- ting/merging is much more difficult [BECK90]. 2 2.2.
Reference: [MAIE87] <author> D. Maier and J. Stein, </author> <title> Development and Implementation of an Object-Oriented DBMS, in Research Directions in Object-Oriented Programming, </title> <editor> B. Shriver and P. Wegner (editor), </editor> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> 355-392. </pages> <note> Reprinted in: Readings in Object-Oriented Database Systems, </note> <editor> S. B. Zdonik and D. Maier (eds.), </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: When primary memory pointers are OIDs, the how (as opposed to the when) part of swizzling is known as the OID mapping problem. The mechanisms used include segmented mapping tables (e.g., ObServer [HORN87]), hash tables (e.g., Itasca [EICK95]) and B-trees (e.g., GemStone <ref> [MAIE87] </ref>). Simple data structures full of OID fi address entries work in this environment because programs frequently exhibit locality of reference and have small reference sets. This means that the portion of the mapping structure kept in memory will be small and well-utilized.
Reference: [MOHA92] <author> C. Mohan and I. Narang, </author> <title> Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates, </title> <booktitle> Proc. 1992 ACM-SIGMOD Conf. on Management of Data, </booktitle> <address> San Diego, CA, </address> <month> June </month> <year> 1992, </year> <pages> 361-370. </pages>
Reference-contexts: One problem with naive old-master/new-master techniques is that they are not highly concurrent. However, known techniques used to improve concurrency of index-building (e.g., <ref> [MOHA92, SRIN92] </ref>) and other forms of reorganization [SOCK93] can be applied. For example, base table updates can be saved into side files during the translation process and then applied to both the source and target tables.
Reference: [MOHA93] <author> C. Mohan, </author> <title> IBM Relational DBMS Products: Features and Technologies, </title> <booktitle> Proc. 1993 ACM-SIGMOD Conf. on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993, </year> <pages> 445-448. 20 </pages>
Reference-contexts: This scheme is discussed in more detail elsewhere [GRAY93, p. 755]. Systems using this scheme include a wide range of relational and object-relational (e.g., Rdb/VMS [HOBB91, p. 79], nearly all IBM relational systems <ref> [MOHA93] </ref>, POSTGRES [STON91], Illustra) as well as object-oriented (e.g., ObServer [HORN87], ESM [CARE88]) data managers.
Reference: [NYBE94] <author> C. Nyberg, T. Barclay, Z. Cvetanovic, J. Gray and D. Lomet, AlphaSort: </author> <title> A RISC Machine Sort, </title> <booktitle> Proc. 1994 ACM--SIGMOD Conf. on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994, </year> <pages> 233-242. </pages>
Reference-contexts: Our bulk-load routine uses the standard technique of extracting -key,TID- pairs from the base table, sorting the pairs into index leaf pages and then building the rest of the tree bottom-up. Our external sorting routine follows the recent trend <ref> [DEWI91, GRAE92, NYBE94] </ref> toward quicksort-based run generation and uses large private buffers to accelerate its sequential I/O. A credible sort/build bulk-load is important as a base case for our tests, inasmuch as insertion-load is not used in practice.
Reference: [PEAR91] <author> C. Pearson, </author> <title> Moving Data in Parallel, </title> <booktitle> Digest of Papers, 36th IEEE Computer Society Int. Conf. (COMPCON Spring '91), </booktitle> <month> Feb. </month> <year> 1991, </year> <pages> 100-104. </pages>
Reference-contexts: Rebuilding an entire set of secondary indices from scratch can be expensive, making reorganization a lengthy, heavy weight process. Although this process can be accelerated using parallel sorting and bulk-loading algorithms <ref> [PEAR91] </ref>, parallelism makes the process even more resource-intensive.
Reference: [SOCK93] <author> G. H. Sockut and B. R. Iyer, </author> <title> Reorganizing Databases Concurrently with Usage: A Survey, Document Nr. </title> <type> TR 03.488, </type> <institution> IBM Santa Teresa Laboratory, </institution> <address> San Jose, CA, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: One problem with naive old-master/new-master techniques is that they are not highly concurrent. However, known techniques used to improve concurrency of index-building (e.g., [MOHA92, SRIN92]) and other forms of reorganization <ref> [SOCK93] </ref> can be applied. For example, base table updates can be saved into side files during the translation process and then applied to both the source and target tables. An additional possibility involves keeping reference counts for the source base table pages in our translation table.
Reference: [SRIN92] <author> V. Srinivasan, </author> <title> On-Line Processing in Large-Scale Transaction Systems, </title> <type> Ph.D. thesis, </type> <institution> Univ. of Wisconsin, Madison, WI, </institution> <month> Jan. </month> <year> 1992. </year> <note> Also available as CS Tech. Rep. 1071. </note>
Reference-contexts: One problem with naive old-master/new-master techniques is that they are not highly concurrent. However, known techniques used to improve concurrency of index-building (e.g., <ref> [MOHA92, SRIN92] </ref>) and other forms of reorganization [SOCK93] can be applied. For example, base table updates can be saved into side files during the translation process and then applied to both the source and target tables.
Reference: [STON87] <author> M. Stonebraker, </author> <title> The Design of the POSTGRES Storage System, </title> <booktitle> Proc. 13th VLDB Conf., </booktitle> <address> Brighton, England, </address> <month> Sep. </month> <year> 1987, </year> <pages> 289-300. </pages>
Reference-contexts: Such situations include copying a table to a different disk partition, changing a table's page size, and compacting pages to reclaim storage space. In Mariposa, the latter operation becomes very desirable after the vacuum cleaner <ref> [STON87] </ref> runs. Media interchange.
Reference: [STON91] <author> M. Stonebraker and G. Kemnitz, </author> <title> The POSTGRES Next-Generation Database Management System, </title> <journal> Comm. of the ACM 34, </journal> <month> 10 (Oct. </month> <year> 1991), </year> <pages> 78-92. </pages>
Reference-contexts: This scheme is discussed in more detail elsewhere [GRAY93, p. 755]. Systems using this scheme include a wide range of relational and object-relational (e.g., Rdb/VMS [HOBB91, p. 79], nearly all IBM relational systems [MOHA93], POSTGRES <ref> [STON91] </ref>, Illustra) as well as object-oriented (e.g., ObServer [HORN87], ESM [CARE88]) data managers.
Reference: [STON93] <author> M. Stonebraker, P. M. Aoki, R. Devine, W. Litwin and M. Olson, Mariposa: </author> <title> A New Architecture for Distributed Data, </title> <type> Sequoia 2000 Tech. Rep. 93/31, </type> <institution> Univ. of California, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Both use page number translation tables that fit in main memory. Howev er, as we will see, both algorithms also fail to translate the source byte offset into a target byte offset without high cost. Like the simple proposal just described, the original Mariposa design <ref> [STON93] </ref> uses a simple page number translation table. However, the Mariposa design does assume that tuples can change size in unpredictable ways. This means that an arithmetic expression can no longer be used to calculate byte offsets.
Reference: [STON94a] <author> M. Stonebraker, R. Devine, M. Kornacker, W. Litwin, A. Pfeffer and C. Staelin, </author> <title> An Economic Paradigm for Query Processing and Data Migration in Mariposa, </title> <booktitle> Proc. 3rd Int. Conf. on Parallel and Dist. Info. Sys., </booktitle> <address> Austin, TX, </address> <month> Sep. </month> <year> 1994, </year> <pages> 58-67. </pages>
Reference-contexts: Many, if not most, database sites are workstation-class machines; Mariposa algorithms must therefore work well on commodity desktop hardware as well as centrally-administered, massively-parallel servers. Furthermore, the Mariposa design includes an economic model for management of query processing and storage space <ref> [STON94a] </ref>. A lightweight primitive for moving and copying tables between sites is critical to the system's ability to perform automatic tuning and load balancing using this economic model. In this paper, we explore the tradeoffs involved in preserving index structures when the underlying tuples shift beneath them.
Reference: [STON94b] <author> M. Stonebraker, P. M. Aoki, R. Devine, W. Litwin and M. Olson, Mariposa: </author> <title> A New Architecture for Distributed Data, </title> <booktitle> Proc. 10th IEEE Int. Conf. on Data Eng., </booktitle> <address> Houston, TX, </address> <month> Feb. </month> <year> 1994, </year> <pages> 54-65. </pages>
Reference-contexts: Reducing the expense of data movement has become an important factor in the design of the Mariposa distributed database management system <ref> [STON94b] </ref>. The Mariposa model assumes that there are many database sites with widely-varying network connectivity and processing power. Many, if not most, database sites are workstation-class machines; Mariposa algorithms must therefore work well on commodity desktop hardware as well as centrally-administered, massively-parallel servers. <p> table and its indices may not be heavily used before the next time they are moved? Are there convincing arguments for recycling internal nodes? What performance improvements are possible when recycling access methods in which reclustering can be extremely expensive (e.g., R-trees without an ordering heuristic)? The Mariposa design in <ref> [STON94b] </ref> proposes a Mariposa canonical representation (MCR) for tables and indices.
Reference: [SUN94] <author> W. Sun, W. Meng, C. Yu and W. Kim, </author> <title> An Efficient Way to Reestablish B + Trees in a Distributed Environment, </title> <booktitle> Information Sciences 77, </booktitle> <month> 3-4 (Mar. </month> <year> 1994), </year> <pages> 227-251. 21 </pages>
Reference-contexts: Finally, the translation table does not provide us with a unique page within the target base table, only a set of potential pages. This makes the search for the matching tuple much more inefficient. Sun et al. <ref> [SUN94] </ref> address the TID translation problem for the special case of B + -trees. Like the Mariposa design, they use a page-level translation table and therefore cannot compute the target byte offset without great effort. <p> Eliminating these cells results in the representation shown in Figure 1 (c). If page numbers are 32 bits and byte offsets are 16 bits, we need at least 8|S| + 2 (|S| - 1) + 2|T | 10|S| + 2|T | bytes to construct the table. In fact, <ref> [SUN94] </ref> uses a hash table instead of an array and therefore requires more memory. We note again that the final, key-based translation can be very costly for the two algorithms just described. <p> For example, object systems (e.g., POMS [COCK84]) often use relative byte addresses, whereas a few relational systems (e.g., NonStop SQL) use primary keys as TIDs. In fact, most database systems use a particular kind of TID instead of the physical TIDs discussed in <ref> [SUN94] </ref>. <p> The nominal overhead of the mapping table is therefore only 2 bytes more per source page than in <ref> [SUN94] </ref>; in fact, because we use an array and do not have to store the source page number (the hash table key), our structure is actually 8|S| + 2|T | bytes (i.e., 2|S| bytes smaller than theirs). <p> The algorithms are implemented as described in the respective papers, with the following exception: we do not need the MAP array described in <ref> [SUN94] </ref> because POSTGRES page numbers are already logical page numbers within a file instead of physical disk block addresses. The target site therefore does not need to perform this step. 3.2. Experimental Environment Our experimental environment consists of DECstation 3000/300 desktop workstations. <p> Experimental Results We performed a large number of experiments, the most significant of which we report here. Motivated by the analytic results of <ref> [SUN94] </ref>, we measured the performance of our algorithms using some of the same parameters used in their study. The figures show comparisons between the Sun et al. byte offset translation mechanism, our own slotted page translation mechanism, and the standard sort/build mechanism. The latter forms our base case. <p> We performed additional experiments that varied the amount of buffer space available to the sort/build routine, but varying this parameter did not make an appreciable differ ence because very large I/O units provided diminishing returns. Merge fan-in was fixed at seven, a typical value according to <ref> [SUN94] </ref>, for all experiments. the elapsed time and the number of I/Os increases in a linear fashion. Even the sort/build algorithm appears to scale linearly, since n log n growth is difficult to distinguish from linear growth when n is large. <p> This is true for Figure 4 as well. As predicted in Section 2, translating byte offsets by searching base table pages is extremely time-consuming. performance of reformatting 8KB pages into 2KB, 4KB and 8KB pages. The plots of the sort/build and slotted page algorithms resemble the predictions of <ref> [SUN94] </ref> for sort/build and 16 (a) Elapsed time. (b) Number of block I/Os. 6 tuples). their own algorithm. <p> Representative network transmission delays for index files. (a) MAN case. (b) WAN case. Our final set of results show how network bandwidth limitations affects the relative perfor mance of the algorithms. The performance analysis in <ref> [SUN94] </ref> was limited to the Ethernet LAN case. Table 1 shows mean network transmission delays obtained by repeated measurement 18 on representative local area (Berkeley), metropolitan area (BARRNet) and wide area (MCINet/AlterNet) networks. <p> Under the characteristics described in this section, index recycling appears to be practical in local area (10-100 Mb/s) as well as metropolitan area networks ( 1 Mb/s). However, below 100 Kb/s the scheme uses too much network bandwidth to be competitive. 4. Conclusions While the ideas proposed in <ref> [SUN94] </ref> are useful, the algorithms described are not a good fit for implementation in existing systems. By adapting their algorithms for use with slotted pages, we have produced practical techniques for recycling secondary indices. <p> By adapting their algorithms for use with slotted pages, we have produced practical techniques for recycling secondary indices. Our techniques do not require modification of the query execution engine, novel index/heap join methods or prohibitively expensive translation steps. Furthermore, unlike <ref> [SUN94] </ref>, we have demonstrated the performance benefits by implementation and measurement and have provided evidence that our techniques may have wider applicability than LANs. We are investigating several new directions in data movement algorithms.
References-found: 25

