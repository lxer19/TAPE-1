URL: http://www.cs.purdue.edu/homes/palsberg/paper/ipl92.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk mis@daimi.aau.dk  
Title: Safety Analysis versus Type Inference for Partial Types  
Author: Jens Palsberg Michael I. Schwartzbach 
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Date: 43 (1992) 175-180.  
Note: Information Processing Letters  
Abstract: Safety analysis is an algorithm for determining if a term in an untyped lambda calculus with constants is safe, i.e., if it does not cause an error during evaluation. We prove that safety analysis accepts strictly more safe lambda terms than does type inference for Thatte's partial types.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 17(1-3):3-34, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: This is in contrast to safety analysis which is based on closure analysis <ref> [7, 1] </ref> (also called control flow analysis by Jones [2] and Shivers [8]). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [2, 7, 1, 8]. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [2, 7, 1, 8] </ref>. Safety analysis is simply a closure analysis that does appropriate safety checks. Our safety analysis requires that the initial type environment only binds variables to base types. This is because it requires knowledge of all closures that may occur during evaluation.
Reference: [2] <author> Neil D. Jones. </author> <title> Flow analysis of lambda expressions. </title> <booktitle> In Proc. Eighth Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 114-128. </pages> <publisher> Springer-Verlag (LNCS 115), </publisher> <year> 1981. </year>
Reference-contexts: This is in contrast to safety analysis which is based on closure analysis [7, 1] (also called control flow analysis by Jones <ref> [2] </ref> and Shivers [8]). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [2, 7, 1, 8]. Safety analysis is simply a closure analysis that does appropriate safety checks. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [2, 7, 1, 8] </ref>. Safety analysis is simply a closure analysis that does appropriate safety checks. Our safety analysis requires that the initial type environment only binds variables to base types. This is because it requires knowledge of all closures that may occur during evaluation.
Reference: [3] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49(2) </volume> <pages> 306-324, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> FOCS'92, </editor> <booktitle> 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Two examples of type systems for which type inference algorithms exist are those of simple types [4] and Thatte's partial types <ref> [9, 5, 3] </ref>. Note that any term that has a simple type also has a partial type. 1 Another way of achieving a safety guarantee is the analysis method of the present authors, simply called safety analysis (SA) [6]. <p> Intuitively, t allows a coercion from t to that forgets some type structure. The type contains only the information "well-typed". The constraints are generated inductively in the syntax, see figure 2. A cubic time algorithm for solving such constraints has been presented by Kozen and the present authors <ref> [3] </ref>. It improved the exponential time algorithm of O'Keefe and Wand [5]. If no solution exists, then the program is not typable. Note that, if the inequalities are strengthened to equalities, then we get the constraints of type inference for simple types. Such equalities are solvable in linear time.
Reference: [4] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Two examples of type systems for which type inference algorithms exist are those of simple types <ref> [4] </ref> and Thatte's partial types [9, 5, 3]. Note that any term that has a simple type also has a partial type. 1 Another way of achieving a safety guarantee is the analysis method of the present authors, simply called safety analysis (SA) [6].
Reference: [5] <author> Patrick M. O'Keefe and Mitchell Wand. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proc. ESOP'92, European Symposium on Programming, </booktitle> <pages> pages 408-417. </pages> <publisher> Springer-Verlag (LNCS 582), </publisher> <year> 1992. </year>
Reference-contexts: Two examples of type systems for which type inference algorithms exist are those of simple types [4] and Thatte's partial types <ref> [9, 5, 3] </ref>. Note that any term that has a simple type also has a partial type. 1 Another way of achieving a safety guarantee is the analysis method of the present authors, simply called safety analysis (SA) [6]. <p> The type contains only the information "well-typed". The constraints are generated inductively in the syntax, see figure 2. A cubic time algorithm for solving such constraints has been presented by Kozen and the present authors [3]. It improved the exponential time algorithm of O'Keefe and Wand <ref> [5] </ref>. If no solution exists, then the program is not typable. Note that, if the inequalities are strengthened to equalities, then we get the constraints of type inference for simple types. Such equalities are solvable in linear time. <p> As an example, consider the term (x:xx)(x:xx). It is accepted by SA because it contains no constants, so no safety constraints will be involved. The term is not accepted by TI, however, as shown by O'Keefe and Wand <ref> [5] </ref>. The proof of our theorem sheds some light on why and how SA accepts more safe terms than TI. Consider a solution of TI that is transformed into a solution of SA 8 according to the strategy implied in figure 5.
Reference: [6] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 128-141, </pages> <year> 1995. </year>
Reference-contexts: Note that any term that has a simple type also has a partial type. 1 Another way of achieving a safety guarantee is the analysis method of the present authors, simply called safety analysis (SA) <ref> [6] </ref>. In a previous paper [6], we proved that SA accepts strictly more safe terms that does TI for simple types. This paper improves our result by proving that SA accepts strictly more safe terms than does TI for partial types. <p> Note that any term that has a simple type also has a partial type. 1 Another way of achieving a safety guarantee is the analysis method of the present authors, simply called safety analysis (SA) <ref> [6] </ref>. In a previous paper [6], we proved that SA accepts strictly more safe terms that does TI for simple types. This paper improves our result by proving that SA accepts strictly more safe terms than does TI for partial types. <p> Thus, closure information can always be obtained for a lambda term. It is easy to see that if SA has a solution, then it has a unique minimal one. The proof follows from observing that solutions are closed under intersection, see <ref> [6] </ref>. <p> There is a cubic time algorithm that, given E 0 , computes the minimal solution of SA, or decides that none exists. The algorithm is based on a straightforward fixed-point computation. In the paper <ref> [6] </ref> we showed that safety analysis is sound with respect to both a strict and a lazy semantics of the lambda calculus. Soundness means that if a term is accepted, then it is safe. We actually proved the soundness of a strictly better safety analysis, see [6]. <p> In the paper <ref> [6] </ref> we showed that safety analysis is sound with respect to both a strict and a lazy semantics of the lambda calculus. Soundness means that if a term is accepted, then it is safe. We actually proved the soundness of a strictly better safety analysis, see [6]. The improved safety analysis will for example correctly accept x:00 because it recognizes that 00 is "dead code". 3 The Result We now show that safety analysis accepts strictly more safe terms than does type inference for partial types. The proof involves several lemmas, see figure 5. <p> Type inference with recursive types will accept all terms without constants, as does SA. It remains to be seen if the containment in SA is still strict. Note though that the containment in the improved safety analysis <ref> [6] </ref> is trivially strict. The development in this paper can straightforwardly be extended to an arbitrary signature of constants. The idea is to treat base types like we have treated Int, and to treat structured types, such as List, like we have treated lambda abstractions.
Reference: [7] <author> Peter Sestoft. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 39-53, </pages> <year> 1989. </year>
Reference-contexts: This is in contrast to safety analysis which is based on closure analysis <ref> [7, 1] </ref> (also called control flow analysis by Jones [2] and Shivers [8]). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [2, 7, 1, 8]. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [2, 7, 1, 8] </ref>. Safety analysis is simply a closure analysis that does appropriate safety checks. Our safety analysis requires that the initial type environment only binds variables to base types. This is because it requires knowledge of all closures that may occur during evaluation.
Reference: [8] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, CMU, </type> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: This is in contrast to safety analysis which is based on closure analysis [7, 1] (also called control flow analysis by Jones [2] and Shivers <ref> [8] </ref>). The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate [2, 7, 1, 8]. Safety analysis is simply a closure analysis that does appropriate safety checks. <p> The closures of a term are simply the subterms corresponding to lambda abstractions. A closure analysis approximates for every subterm the set of possible closures to which it may evaluate <ref> [2, 7, 1, 8] </ref>. Safety analysis is simply a closure analysis that does appropriate safety checks. Our safety analysis requires that the initial type environment only binds variables to base types. This is because it requires knowledge of all closures that may occur during evaluation.
Reference: [9] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1988, </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag (LNCS 317), </publisher> <year> 1988. </year>
Reference-contexts: Two examples of type systems for which type inference algorithms exist are those of simple types [4] and Thatte's partial types <ref> [9, 5, 3] </ref>. Note that any term that has a simple type also has a partial type. 1 Another way of achieving a safety guarantee is the analysis method of the present authors, simply called safety analysis (SA) [6].
Reference: [10] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <address> Fundamentae Informat-icae, X:115-122, </address> <year> 1987. </year> <month> 9 </month>
Reference-contexts: Second, a type variable [[E]] is assigned to every subterm E. Third, a finite collection of constraints over these variables is generated from the syntax. Finally, these constraints are solved. This presentation of type inference is due to Wand <ref> [10] </ref>. Polymorphic let could be treated by both analyses by doing syntactic expansion. Type inference and safety analysis employ constraints over different domains.
References-found: 10

