URL: http://www.cs.wustl.edu/~schmidt/C++-report-col8.ps.gz
Refering-URL: http://www.acl.lanl.gov/CORBA/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: schmidt@cs.wustl.edu vinoski@ch.hp.com  
Title: Object Interconnections Distributed Callbacks and Decoupled Communication in CORBA (Column 8)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column will appear in the October 1996 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 Chelmsford, MA 01824  
Affiliation: Department of Computer Science Hewlett-Packard Company Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Object Management Group, </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, </note> <editor> 95-3-31 ed., </editor> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: In this approach, requests flow from client to server and responses flow back from server to client. In this column, we'll discuss distributed callbacks and extend our stock quoting example to show why they're useful. We'll also briefly discuss the OMG Events object service <ref> [1] </ref>, which supports decoupled peer-to-peer relationships between consumers and suppliers. <p> One way to relieve some of the burden we've placed on the stock quoter is to utilize the OMG Events Service for notification delivery. The Events Service is part of the OMG Common Object Services Specification (COSS) Volume 1 <ref> [1] </ref>. Its purpose is to provide delivery of event data from event suppliers to event consumers without requiring the suppliers and consumers to know about each other. An implementation of the Events Service acts as a mediator that provides for decoupled communications between objects.
Reference: [2] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This model, where one or more applications register to receive data as it is generated, is often referred to as the publish/subscribe model. The publish/subscribe model has its roots in patterns like Observer <ref> [2] </ref> and Model/View/Controller [3]. 3 Using Distributed Callbacks in the Quoter Application This section illustrates how to use distributed callbacks to implement a more flexible, and potentially more efficient, stock quoter application. 3.1 Defining the IDL Interface As we've shown in our last few columns, CORBA applications must have an object <p> To actually implement a Notifying Quoter, we first define a C++ class. ORBs generally allow the implementor to select how to integrate their code with the skeleton generated by the IDL compiler. As we've shown in previous columns, the two main choices are variants of the Adapter pattern <ref> [2] </ref>: * Class Adapter which derives the implementation class from a skeleton class generated by an OMG IDL com piler; * Object Adapter which makes a stand-alone class where an interface (the Adapter) delegates to an object it holds (the implementation).
Reference: [3] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: This model, where one or more applications register to receive data as it is generated, is often referred to as the publish/subscribe model. The publish/subscribe model has its roots in patterns like Observer [2] and Model/View/Controller <ref> [3] </ref>. 3 Using Distributed Callbacks in the Quoter Application This section illustrates how to use distributed callbacks to implement a more flexible, and potentially more efficient, stock quoter application. 3.1 Defining the IDL Interface As we've shown in our last few columns, CORBA applications must have an object reference before a
Reference: [4] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> (Reading, MA), </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Monitor for real-time stock feed This monitor provides up-to-date stock information to the stock quote supplier. The supplier uses this information to determine when callbacks should be issued to consumer (s). Our Notifying Quoter implementation is an active object <ref> [4] </ref>. It spawns a thread in its constructor to monitor the real-time stock feed. This means that our registration and unregistration operations must occur in their own threads. Therefore, we must make sure that updates to the registration map do not occur while the monitoring method accesses the map.
Reference: [5] <author> M. L. Powell, </author> <title> Objects, References, Identifiers, and Equality White Paper. SunSoft, </title> <publisher> Inc., </publisher> <editor> OMG Document 93-07-05 ed., </editor> <month> July </month> <year> 1993. </year>
Reference-contexts: The main reason is equivalent has these somewhat odd semantics is to allow greater freedom for ORB implementors. The OMG members in favor of these semantics were concerned that stronger guarantees for is equivalent would be difficult to implement in some CORBA environments. For more information, see <ref> [5] </ref> and [6], which discuss the pros and cons of this issue, respectively. Since we can't count on is equivalent in our implementation of the unregister handler operation, our implementation must be redesigned.
Reference: [6] <author> W. Harrison, </author> <title> The Importance of Using Object References as Identifiers of Objects: Comparison of CORBA Object. IBM, </title> <editor> OMG Document 94-06-12 ed., </editor> <month> June </month> <year> 1994. </year>
Reference-contexts: The main reason is equivalent has these somewhat odd semantics is to allow greater freedom for ORB implementors. The OMG members in favor of these semantics were concerned that stronger guarantees for is equivalent would be difficult to implement in some CORBA environments. For more information, see [5] and <ref> [6] </ref>, which discuss the pros and cons of this issue, respectively. Since we can't count on is equivalent in our implementation of the unregister handler operation, our implementation must be redesigned.
Reference: [7] <author> S. Maffeis, </author> <title> Adding Group Communication and Fault-Tolerance to CORBA, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Another way to improve the scalability of distributed callback notifications is to utilize an ORB that supports reliable multicast semantics. The CORBA 2.0 specification deals mainly with point-to-point communication and offers no standard support for reliable multicast. However, there are ORB implementations (such as Electra <ref> [7] </ref> or Orbix+ISIS [8]) that extend CORBA to provide reliable multicast and fault-tolerant group communication. * Potential for deadlock: Since unregister callback is a twoway CORBA call, our distributed callback design can deadlock if the Supplier tries to push to a Consumer that simultaneously tries to unregister.
Reference: [8] <author> C. Horn, </author> <title> The Orbix Architecture, </title> <type> tech. rep., </type> <institution> IONA Technologies, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Another way to improve the scalability of distributed callback notifications is to utilize an ORB that supports reliable multicast semantics. The CORBA 2.0 specification deals mainly with point-to-point communication and offers no standard support for reliable multicast. However, there are ORB implementations (such as Electra [7] or Orbix+ISIS <ref> [8] </ref>) that extend CORBA to provide reliable multicast and fault-tolerant group communication. * Potential for deadlock: Since unregister callback is a twoway CORBA call, our distributed callback design can deadlock if the Supplier tries to push to a Consumer that simultaneously tries to unregister.
Reference: [9] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year> <month> 9 </month>
Reference-contexts: Such problems are very common, and often don't manifest themselves until late in a project lifecycle. This is yet one more reason why it's so important to build prototypes and conduct experiments using realistic use-cases and distributed environments <ref> [9] </ref>, before adopting a particular communication architecture wholesale. Luckily, the flexibility and higher levels of abstraction in CORBA help to alleviate unnecessary complexity and coupling.
References-found: 9

