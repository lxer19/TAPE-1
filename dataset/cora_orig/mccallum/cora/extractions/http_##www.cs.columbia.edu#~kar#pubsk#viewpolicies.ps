URL: http://www.cs.columbia.edu/~kar/pubsk/viewpolicies.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: colby@redbrick.com  akira@cs.columbia.edu  lieuwen@research.bell-labs.com  mumick@research.att.com  kar@cs.columbia.edu  
Title: Supporting Multiple View Maintenance Policies  
Author: Latha S. Colby Akira Kawaguchi Daniel F. Lieuwen Inderpal Singh Mumick Kenneth A. Ross 
Affiliation: Red Brick Systems  Columbia University  Bell Labs, Lucent Technologies  AT&T Laboratories  Columbia University  
Abstract: Materialized views and view maintenance are becoming increasingly important in practice. In order to satisfy different data currency and performance requirements, a number of view maintenance policies have been proposed. Immediate maintenance involves a potential refresh of the view after every update to the deriving tables. When staleness of views can be tolerated, a view may be refreshed periodically or (on-demand) when it is queried. The maintenance policies that are chosen for views have implications on the validity of the results of queries and affect the performance of queries and updates. In this paper, we investigate a number of issues related to supporting multiple views with different maintenance policies. We develop formal notions of consistency for views with different maintenance policies. We then introduce a model based on view groupings for view maintenance policy assignment, and provide algorithms, based on the viewgroup model, that allow consistency of views to be guaranteed. Next, we conduct a detailed study of the performance aspects of view maintenance policies based on an actual implementation of our model. The performance study investigates the trade-offs between different maintenance policy assignments. Our analysis of both the consistency and performance aspects of various view maintenance policies are important in making correct maintenance policy assignments. 
Abstract-found: 1
Intro-found: 1
Reference: [AG89] <author> R. Agrawal and N. Gehani. </author> <title> Ode (object database and environment): the language and the data model. </title> <booktitle> In SIGMOD 1989. </booktitle>
Reference-contexts: We chose the Ode database system <ref> [AG89] </ref> as the implementation vehicle for materialized views. This choice was made since we have expertise and access to the source code for Ode, allowing us to experiment with special data structures for storing logs.
Reference: [AGK95] <author> B. Adelberg, H. Garcia-Molina, and B. Kao. </author> <title> Applying update streams in a soft real-time database system. </title> <booktitle> In SIGMOD 1995. </booktitle>
Reference-contexts: Three common policies are: (1) Immediate Views: The view is maintained immediately upon an update to a base table, as a part of the transaction that updates the base table. Immediate maintenance allows fast querying, at the expense of slowing down update transactions. (2) Deferred Views <ref> [RK86, AGK95, AKG96, CGL + 96] </ref>: The view is maintained by a transaction that is separate from the update transactions and is typically invoked when the view is queried. <p> The paper also proposes a high-level scheme for minimizing the time taken to refresh a view. Strategies for updating a view based on different priorities for transactions that apply computed updates to a view and transactions that read a view, are presented in <ref> [AGK95] </ref>. Their experiments focus on that portion of the maintenance procedure that applies previously computed changes to a view. Concurrency control problems and a serializability model to guarantee serializability in the presence of deferred views are discussed in [KLM + 97].
Reference: [AKG96] <author> B. Adelberg, B. Kao, and H. Garcia-Molina. </author> <title> Database support for efficiently maintaining derived data. </title> <booktitle> In EDBT 1996. </booktitle>
Reference-contexts: Three common policies are: (1) Immediate Views: The view is maintained immediately upon an update to a base table, as a part of the transaction that updates the base table. Immediate maintenance allows fast querying, at the expense of slowing down update transactions. (2) Deferred Views <ref> [RK86, AGK95, AKG96, CGL + 96] </ref>: The view is maintained by a transaction that is separate from the update transactions and is typically invoked when the view is queried.
Reference: [AL80] <author> M. Adiba and B. Lindsay. </author> <title> Database snapshots. </title> <booktitle> In VLDB 1980. </booktitle>
Reference-contexts: Deferred maintenance thus leads to comparatively slower querying than immediate maintenance, but allows faster updates. (3) Snapshot Views <ref> [AL80, LHM + 86] </ref>: The view is maintained periodically, say once a day or once a week, by an asynchronous process. Snapshot maintenance allows fast querying and updates, but queries can read data that is not up-to-date with base tables. <p> Our study is a start in this direction, and is the first one to compare the impact of different maintenance policies for different views. Snapshots were first proposed in <ref> [AL80] </ref>. Implementation techniques for snapshot views are described in [LHM + 86, KR87, SP89].
Reference: [BC79] <author> P. Buneman and E. Clemons. </author> <title> Efficiently monitoring relational databases. </title> <journal> ACM TODS, </journal> <volume> 4(3) </volume> <pages> 368-382, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail.
Reference: [BLT86] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In SIGMOD 1986. </booktitle>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail. <p> An edge tuple for a pair (B; V ) contains a pointer to the last log entry for B that was used to maintain V (if V is a deferred or snapshot view). Computing Incremental Changes: The implemented incremental maintenance algorithm is based on the counting algorithm of <ref> [BLT86, GMS93] </ref>. The algorithm is slightly enhanced to incorporate replace operations. <p> Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed <ref> [BLT86, CW91, QW91, GL95, CGL + 96] </ref>. In [CGL + 96], equations that compute incremental changes to a view using only the post-update state of tables are derived. The paper also proposes a high-level scheme for minimizing the time taken to refresh a view.
Reference: [BM90] <author> J. Blakeley and N. Martin. </author> <title> Join index, materialized view, and hybrid hash join: A performance analysis. </title> <booktitle> In Proc. Data Engineering, </booktitle> <year> 1990. </year>
Reference-contexts: Consistency of views in distributed warehousing environments was studied in [ZGHW95] and [HZ96]. Our focus, on the other hand, is on the consistency aspects of views with different policies in the same system. Another analytical performance study by <ref> [BM90] </ref> compared the use of join indices, fully materialized views, and recomputation for querying join views, and found that either method can perform better depending upon the update rate and join selectivity. [Han87] presents an analytical performance comparison of answering queries over a single view by (1) recomputation, (2) an immediately
Reference: [CG96] <author> L. Colby and T. Griffin. </author> <title> An algebraic approach to supporting multiple deferred views. </title> <booktitle> In Proc. Int'l Workshop on Materialized Views: Techniques and Applications, </booktitle> <address> Montreal, Canada, </address> <month> June 7 </month> <year> 1996. </year>
Reference-contexts: The problem of maintaining a single log for a table that has multiple views (with different refresh times) defined on it was also considered in [SP89], [KR87], and <ref> [CG96] </ref>. Our log structures are based on the general principles presented in those papers. We create one log entry per update operation. Each log entry has an operation flag and the oid 1 of the tuple in the materialization to which the operation was applied.
Reference: [CGL + 96] <author> L. Colby, T. Griffin, L. Libkin, I. Mumick, and H. Trickey. </author> <title> Algorithms for deferred view maintenance. </title> <booktitle> In SIGMOD 1996. </booktitle>
Reference-contexts: Three common policies are: (1) Immediate Views: The view is maintained immediately upon an update to a base table, as a part of the transaction that updates the base table. Immediate maintenance allows fast querying, at the expense of slowing down update transactions. (2) Deferred Views <ref> [RK86, AGK95, AKG96, CGL + 96] </ref>: The view is maintained by a transaction that is separate from the update transactions and is typically invoked when the view is queried. <p> Section 4 describes our storage model and implementation. The function that takes an update transaction and executes the transaction as well as the required additional work is called makesafe, as in <ref> [CGL + 96] </ref>, and the function that changes the view is called refresh. <p> Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed <ref> [BLT86, CW91, QW91, GL95, CGL + 96] </ref>. In [CGL + 96], equations that compute incremental changes to a view using only the post-update state of tables are derived. The paper also proposes a high-level scheme for minimizing the time taken to refresh a view. <p> Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed [BLT86, CW91, QW91, GL95, CGL + 96]. In <ref> [CGL + 96] </ref>, equations that compute incremental changes to a view using only the post-update state of tables are derived. The paper also proposes a high-level scheme for minimizing the time taken to refresh a view.
Reference: [CKL + 96] <author> L. Colby, A. Kawaguchi, D. Lieuwen, I. Mumick, and K. Ross. </author> <title> Supporting Multiple View Maintenance Policies: Concepts, Algorithms, and Performance Analysis. </title> <type> AT&T Technical Memo. </type>
Reference-contexts: We list the design rules that constrain the assignment of maintenance policies and viewgroups. See <ref> [CKL + 96] </ref> for a detailed explanation of the reasons for these design rules.
Reference: [CM96] <author> L. Colby and I. Mumick. </author> <title> Staggered maintenance of multiple views. </title> <booktitle> In Proc. Int'l Workshop on Materialized Views: Techniques and Applications, </booktitle> <address> Montreal, Canada, </address> <month> June 7 </month> <year> 1996. </year>
Reference-contexts: The algorithm is slightly enhanced to incorporate replace operations. To use the counting algorithm efficiently, we found it important to be able to access both the pre- and post-update states of the tables <ref> [CM96, HZ96] </ref>, and to avoid redundant computations caused by deletions when maintaining a join of two or more deriving tables.
Reference: [CW91] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In VLDB 1991. </booktitle>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail. <p> Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed <ref> [BLT86, CW91, QW91, GL95, CGL + 96] </ref>. In [CGL + 96], equations that compute incremental changes to a view using only the post-update state of tables are derived. The paper also proposes a high-level scheme for minimizing the time taken to refresh a view.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In SIGMOD 1995. </booktitle>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail. <p> Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed <ref> [BLT86, CW91, QW91, GL95, CGL + 96] </ref>. In [CGL + 96], equations that compute incremental changes to a view using only the post-update state of tables are derived. The paper also proposes a high-level scheme for minimizing the time taken to refresh a view.
Reference: [GM95] <author> A. Gupta and I. Mumick. </author> <title> Maintenance of Materialized Views: Problems, Techniques, </title> <journal> and Applications. IEEE Data Engineering Bulletin, Special Issue on Materialized Views and Data Warehousing, </journal> <volume> 18(2) </volume> <pages> 3-19, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Kawaguchi and K. Ross was performed while visiting AT&T Laboratories and Bell Laboratories, and was partially supported by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, and by an NSF Young Investigator award. gration <ref> [GM95, Mum95, ZGHW95, HZ96] </ref>. A materialized view is like a data cache; the main reason for defining and storing a materialized view is to increase query performance. However, view maintenance imposes a penalty on update transactions.
Reference: [GMS93] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In SIGMOD 1993. </booktitle>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail. <p> An edge tuple for a pair (B; V ) contains a pointer to the last log entry for B that was used to maintain V (if V is a deferred or snapshot view). Computing Incremental Changes: The implemented incremental maintenance algorithm is based on the counting algorithm of <ref> [BLT86, GMS93] </ref>. The algorithm is slightly enhanced to incorporate replace operations. <p> The log structures in our implementation are based on the ideas in [SP89]. Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of <ref> [GMS93] </ref> for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed [BLT86, CW91, QW91, GL95, CGL + 96]. In [CGL + 96], equations that compute incremental changes to a view using only the post-update state of tables are derived.
Reference: [Han87] <author> E. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In SIGMOD 1987. </booktitle>
Reference-contexts: Another analytical performance study by [BM90] compared the use of join indices, fully materialized views, and recomputation for querying join views, and found that either method can perform better depending upon the update rate and join selectivity. <ref> [Han87] </ref> presents an analytical performance comparison of answering queries over a single view by (1) recomputation, (2) an immediately maintained materialized view, and (3) a deferred materialized view. <p> In contrast, our performance study uses an actual implementation, and compares the maintenance policies for sets of materialized views. Also, deferred view maintenance is treated somewhat differently in <ref> [Han87] </ref>, where it is assumed that the changes to the base tables are also deferred until the view is queried. An analytical study of optimal refresh policies, based on queuing models and parameterization of response time and cost constraints, is described in [SR88].
Reference: [HZ96] <author> R. Hull and G. Zhou. </author> <title> A framework for supporting data integration using the materialized and virtual approaches. </title> <booktitle> In SIGMOD 1996. </booktitle>
Reference-contexts: Kawaguchi and K. Ross was performed while visiting AT&T Laboratories and Bell Laboratories, and was partially supported by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, and by an NSF Young Investigator award. gration <ref> [GM95, Mum95, ZGHW95, HZ96] </ref>. A materialized view is like a data cache; the main reason for defining and storing a materialized view is to increase query performance. However, view maintenance imposes a penalty on update transactions. <p> A related problem of concurrency control, to ensure that consistency is achieved in the presence of concurrent transactions, is discussed in [KLM + 97]. Notions of consistency for views in distributed environments have been presented in [ZGHW95] and <ref> [HZ96] </ref>. To identify related views that should be consistent with each other, and to localize the maintenance activity within a small set of views, we place base and view tables into view-groups. A viewgroup consists of a set of tables, along with logs holding the changes to the tables. <p> The algorithm is slightly enhanced to incorporate replace operations. To use the counting algorithm efficiently, we found it important to be able to access both the pre- and post-update states of the tables <ref> [CM96, HZ96] </ref>, and to avoid redundant computations caused by deletions when maintaining a join of two or more deriving tables. <p> An analytical and experimental study comparing the benefits of deferred incremental maintenance over re-computation using different join methods was presented. However, they did not compare the performance of the different maintenance policies. Consistency of views in distributed warehousing environments was studied in [ZGHW95] and <ref> [HZ96] </ref>. Our focus, on the other hand, is on the consistency aspects of views with different policies in the same system.
Reference: [KLM + 96] <author> A. Kawaguchi, D. Lieuwen, I. Mumick, and K. Ross. </author> <title> View maintenance in nested data models. </title> <booktitle> In Proc. Int'l Workshop on Materialized Views: Techniques and Applications, </booktitle> <address> Montreal, Canada, </address> <month> June 7 </month> <year> 1996. </year>
Reference: [KLM + 97] <author> A. Kawaguchi, D. Lieuwen, I. Mumick, D. Quass, and K. Ross. </author> <title> Concurrency control theory for deferred materialized views. </title> <booktitle> In ICDT 1997. </booktitle>
Reference-contexts: Note that the consistency discussion here is on the desired relationship between states of materialized views and base tables in a central system with one user. A related problem of concurrency control, to ensure that consistency is achieved in the presence of concurrent transactions, is discussed in <ref> [KLM + 97] </ref>. Notions of consistency for views in distributed environments have been presented in [ZGHW95] and [HZ96]. To identify related views that should be consistent with each other, and to localize the maintenance activity within a small set of views, we place base and view tables into view-groups. <p> Their experiments focus on that portion of the maintenance procedure that applies previously computed changes to a view. Concurrency control problems and a serializability model to guarantee serializability in the presence of deferred views are discussed in <ref> [KLM + 97] </ref>. The focus of that paper is on doing concurrency control when multiple transactions reading and updating tables are executing concurrently in the system. 7 Conclusions In this paper we investigated issues related to supporting multiple materialized views with different maintenance policies.
Reference: [KR87] <author> B. Kahler and O. Risnes. </author> <title> Extended logging for database snapshots. </title> <booktitle> In VLDB 1987. </booktitle>
Reference-contexts: Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in <ref> [KR87, SP89, Rou91] </ref>. However, global issues in supporting many views with different policies have not been explored in detail. Summary of Contributions: This paper investigates a number of issues related to supporting multiple views with different maintenance policies. <p> The problem of maintaining a single log for a table that has multiple views (with different refresh times) defined on it was also considered in [SP89], <ref> [KR87] </ref>, and [CG96]. Our log structures are based on the general principles presented in those papers. We create one log entry per update operation. Each log entry has an operation flag and the oid 1 of the tuple in the materialization to which the operation was applied. <p> Our study is a start in this direction, and is the first one to compare the impact of different maintenance policies for different views. Snapshots were first proposed in [AL80]. Implementation techniques for snapshot views are described in <ref> [LHM + 86, KR87, SP89] </ref>. <p> Snapshots were first proposed in [AL80]. Implementation techniques for snapshot views are described in [LHM + 86, KR87, SP89]. These papers consider only SP (select-project) views. [LHM + 86] focuses on detecting relevant changes to a snapshot based on update tags on base tables. <ref> [KR87] </ref> and [SP89] present techniques for maintaining logs and computing the net update to a view when multiple views share common parents. The log structures in our implementation are based on the ideas in [SP89].
Reference: [LHM + 86] <author> B. Lindsay, L. Haas, C. Mohan, H. Pirahesh, and P. Wilms. </author> <title> A snapshot differential refresh algorithm. </title> <booktitle> In SIGMOD 1986. </booktitle>
Reference-contexts: Deferred maintenance thus leads to comparatively slower querying than immediate maintenance, but allows faster updates. (3) Snapshot Views <ref> [AL80, LHM + 86] </ref>: The view is maintained periodically, say once a day or once a week, by an asynchronous process. Snapshot maintenance allows fast querying and updates, but queries can read data that is not up-to-date with base tables. <p> Our study is a start in this direction, and is the first one to compare the impact of different maintenance policies for different views. Snapshots were first proposed in [AL80]. Implementation techniques for snapshot views are described in <ref> [LHM + 86, KR87, SP89] </ref>. <p> Snapshots were first proposed in [AL80]. Implementation techniques for snapshot views are described in [LHM + 86, KR87, SP89]. These papers consider only SP (select-project) views. <ref> [LHM + 86] </ref> focuses on detecting relevant changes to a snapshot based on update tags on base tables. [KR87] and [SP89] present techniques for maintaining logs and computing the net update to a view when multiple views share common parents.
Reference: [LMSS95] <author> J. Lu, G. Moerkotte, J. Schu, and V. Subrahmanian. </author> <title> Efficient maintenance of materialized mediated views. </title> <booktitle> In SIGMOD 1995. </booktitle>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail.
Reference: [MRS93] <author> I. Mumick, K. Ross, and S. Sudarshan. </author> <title> Design and implementation of the SWORD declarative object-oriented database system, 1993. </title> <type> Unpublished Manuscript. </type>
Reference-contexts: Ode is an object-oriented database; its data manipulation language is O++, a variant of C++ with persistence and transactions. It also offers relational features through the SWORD interface <ref> [MRS93] </ref>. The ideas used in the implementation are equally applicable to commercial relational systems (e.g. Oracle, Sybase). Tables: A table (base or materialized view) is realized by a collection class in Ode. A collection instantiation returns a descriptor (or handle) that is used to reference a materialization of tuples.
Reference: [Mum95] <author> I. Mumick. </author> <title> The Rejuvenation of Materialized Views. </title> <booktitle> In Proc. Int'l Conf. on Information Systems and Management of Data (CISMOD), </booktitle> <address> Bombay, India, </address> <month> November 15-17 </month> <year> 1995. </year>
Reference-contexts: Kawaguchi and K. Ross was performed while visiting AT&T Laboratories and Bell Laboratories, and was partially supported by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, and by an NSF Young Investigator award. gration <ref> [GM95, Mum95, ZGHW95, HZ96] </ref>. A materialized view is like a data cache; the main reason for defining and storing a materialized view is to increase query performance. However, view maintenance imposes a penalty on update transactions.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE TKDE, </journal> <pages> pages 337-341, </pages> <year> 1991. </year>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail. <p> Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance. Several other incremental algorithms have been proposed <ref> [BLT86, CW91, QW91, GL95, CGL + 96] </ref>. In [CGL + 96], equations that compute incremental changes to a view using only the post-update state of tables are derived. The paper also proposes a high-level scheme for minimizing the time taken to refresh a view.
Reference: [RK86] <author> N. Roussopoulos and H. Kang. </author> <booktitle> Principles and techniques in the design of ADMS+. IEEE Computer, </booktitle> <pages> pages 19-25, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Three common policies are: (1) Immediate Views: The view is maintained immediately upon an update to a base table, as a part of the transaction that updates the base table. Immediate maintenance allows fast querying, at the expense of slowing down update transactions. (2) Deferred Views <ref> [RK86, AGK95, AKG96, CGL + 96] </ref>: The view is maintained by a transaction that is separate from the update transactions and is typically invoked when the view is queried. <p> The linear tree schema is somewhat simpler, with the same base tables as in the earlier schema, but with the views defined in a linear tree form. The results were found to be similar to those reported above for the schema of Figure 3. 6 Related Work ADMS <ref> [RK86, Rou91] </ref> was the first system to realize the importance of supporting multiple maintenance policies. However ADMS did not propose any model of consistency in the presence of multiple policies.
Reference: [Rou91] <author> N. Roussopoulos. </author> <title> The incremental access method of view cache: Concept, algorithms, and cost analysis. </title> <journal> ACM TODS, </journal> <volume> 16(3) </volume> <pages> 535-563, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in <ref> [KR87, SP89, Rou91] </ref>. However, global issues in supporting many views with different policies have not been explored in detail. Summary of Contributions: This paper investigates a number of issues related to supporting multiple views with different maintenance policies. <p> The linear tree schema is somewhat simpler, with the same base tables as in the earlier schema, but with the views defined in a linear tree form. The results were found to be similar to those reported above for the schema of Figure 3. 6 Related Work ADMS <ref> [RK86, Rou91] </ref> was the first system to realize the importance of supporting multiple maintenance policies. However ADMS did not propose any model of consistency in the presence of multiple policies.
Reference: [SI84] <author> O. Shmueli and A. Itai. </author> <title> Maintenance of Views. </title> <booktitle> In SIGMOD 1984. </booktitle>
Reference-contexts: Most of the research on materialized views has focused on high level incremental algorithms for updating materialized views efficiently when the base tables are updated <ref> [BC79, SI84, BLT86, QW91, CW91, GMS93, GL95, LMSS95] </ref>. Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in [KR87, SP89, Rou91]. However, global issues in supporting many views with different policies have not been explored in detail.
Reference: [SP89] <author> A. Segev and J. Park. </author> <title> Updating distributed materialized views. </title> <journal> IEEE TKDE, </journal> <volume> 1(2) </volume> <pages> 173-184, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Efficient data structures for supporting incremental view maintenance in the presence of multiple views were described in <ref> [KR87, SP89, Rou91] </ref>. However, global issues in supporting many views with different policies have not been explored in detail. Summary of Contributions: This paper investigates a number of issues related to supporting multiple views with different maintenance policies. <p> The problem of maintaining a single log for a table that has multiple views (with different refresh times) defined on it was also considered in <ref> [SP89] </ref>, [KR87], and [CG96]. Our log structures are based on the general principles presented in those papers. We create one log entry per update operation. Each log entry has an operation flag and the oid 1 of the tuple in the materialization to which the operation was applied. <p> Our study is a start in this direction, and is the first one to compare the impact of different maintenance policies for different views. Snapshots were first proposed in [AL80]. Implementation techniques for snapshot views are described in <ref> [LHM + 86, KR87, SP89] </ref>. <p> Snapshots were first proposed in [AL80]. Implementation techniques for snapshot views are described in [LHM + 86, KR87, SP89]. These papers consider only SP (select-project) views. [LHM + 86] focuses on detecting relevant changes to a snapshot based on update tags on base tables. [KR87] and <ref> [SP89] </ref> present techniques for maintaining logs and computing the net update to a view when multiple views share common parents. The log structures in our implementation are based on the ideas in [SP89]. <p> 86] focuses on detecting relevant changes to a snapshot based on update tags on base tables. [KR87] and <ref> [SP89] </ref> present techniques for maintaining logs and computing the net update to a view when multiple views share common parents. The log structures in our implementation are based on the ideas in [SP89]. Replication servers from Oracle and IBM essentially implement snapshot materialized views, where the snapshot view is materialized in a remote system. Our implementation uses the counting incremental maintenance algorithm of [GMS93] for immediate, deferred, and snapshot maintenance.
Reference: [SR88] <author> J. Srivastava and D. Rotem. </author> <title> Analytical modeling of materialized view maintenance. </title> <booktitle> In PODS 1988. </booktitle>
Reference-contexts: An analytical study of optimal refresh policies, based on queuing models and parameterization of response time and cost constraints, is described in <ref> [SR88] </ref>. As one can see, many issues in the performance analysis of materialized views have yet to be explored. There have been isolated attempts to study certain narrow aspects, and there is a need for a comprehensive performance study using an actual implementation.
Reference: [ZGHW95] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In SIGMOD 1995. </booktitle>
Reference-contexts: Kawaguchi and K. Ross was performed while visiting AT&T Laboratories and Bell Laboratories, and was partially supported by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, by a Sloan Foundation Fellowship, and by an NSF Young Investigator award. gration <ref> [GM95, Mum95, ZGHW95, HZ96] </ref>. A materialized view is like a data cache; the main reason for defining and storing a materialized view is to increase query performance. However, view maintenance imposes a penalty on update transactions. <p> A related problem of concurrency control, to ensure that consistency is achieved in the presence of concurrent transactions, is discussed in [KLM + 97]. Notions of consistency for views in distributed environments have been presented in <ref> [ZGHW95] </ref> and [HZ96]. To identify related views that should be consistent with each other, and to localize the maintenance activity within a small set of views, we place base and view tables into view-groups. <p> An analytical and experimental study comparing the benefits of deferred incremental maintenance over re-computation using different join methods was presented. However, they did not compare the performance of the different maintenance policies. Consistency of views in distributed warehousing environments was studied in <ref> [ZGHW95] </ref> and [HZ96]. Our focus, on the other hand, is on the consistency aspects of views with different policies in the same system.
References-found: 31

