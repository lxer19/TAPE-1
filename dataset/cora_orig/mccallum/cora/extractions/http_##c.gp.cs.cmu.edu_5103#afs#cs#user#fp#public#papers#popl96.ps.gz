URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/popl96.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/
Root-URL: http://www.cs.cmu.edu
Email: rowan@cs.cmu.edu and fp@cs.cmu.edu  
Title: A Modal Analysis of Staged Computation  
Author: Rowan Davies and Frank Pfenning 
Address: Pittsburgh, PA 15213, U.S.A.  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We show that a type system based on the intuitionistic modal logic S4 provides an expressive framework for specifying and analyzing computation stages in the context of functional languages. Our main technical result is a conservative embedding of Nielson & Nielson's two-level functional language in our language Mini-ML 2 , thus proving that binding-time correctness is equivalent to modal correctness on this fragment. In addition Mini-ML 2 can also express immediate evaluation and sharing of code across multiple stages, thus supporting run-time code generation as well as partial evaluation. 
Abstract-found: 1
Intro-found: 1
Reference: [BdP92] <author> Gavin Bierman and Valeria de Paiva. </author> <title> Intu-itionistic necessity revisited. </title> <booktitle> In Proceedings of the Logic at Work Conference, </booktitle> <address> Amsterdam, Hol-land, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: We begin by considering Mini-ML 2 e , a formulation of in-tuitionistic modal S4 in which the permissible operations on code and the staging of computation are represented very explicitly. The presentation is new, but draws on ideas in <ref> [BdP92, PW95] </ref>. It is augmented with a fixpoint operator, natural numbers, and pairs and endowed with a natural call-by-value operational semantics along the lines of Mini-ML [CDDK86]. Mini-ML 2 e is somewhat awkward because it requires the broad syntactic structuring of the program to directly reflect staging. <p> providing further evidence that Mini-ML 2 provides an intuitively appealing, technically correct, and logically motivated view of staged computation. 2 Modal Mini-ML: Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML [CDDK86] with a modal -calculus for intuitionistic S4 following ideas in <ref> [BdP92, PW95] </ref>. For the sake of simplicity Mini-ML 2 e is explicitly typed. ML-style or explicit polymorphism can also be added in a straightforward manner; we omit the details here in order to concentrate on the essential issues within the given space constraints. <p> The outer context contains variables that may be bound only to code during evaluation; contains variables that may be bound to arbitrary values. Only variables in are permitted to occur free inside box expressions. This presentation simplifies that of the modal -calculus !2 e from <ref> [BdP92, PW95] </ref> by eliminating the need for simultaneous substitution while preserving subject reduction. The elimination construct for box allows us to bind a variable x in to code of type A, written as let box x = E 1 in E 2 . <p> The problem of typing the modal fragment is well understood; we present here a variant of known systems <ref> [BdP92, PW95] </ref> with two contexts as motivated above. ; ` e E : A E has type A in modal context and non-modal context .
Reference: [BW93] <author> Lars Birkedal and Morten Welinder. </author> <title> Partial evaluation of Standard ML. </title> <type> Master's thesis, </type> <institution> University of Copenhagen, Department of Computer Science, </institution> <year> 1993. </year> <note> Available as Technical Report DIKU-report 93/22. </note>
Reference-contexts: More complicated examples would generally require polyvariant specialization, which could be provided to the programmer as a library function that memoized when generating code. Further, this approach could be extended to prevent code copying during specialization. See <ref> [BW93] </ref> for a description of a realistic partial evaluator for Standard ML and [JGS93] for an overview of standard techniques and examples of partial evaluation. Our language Mini-ML 2 requires the insertion of the box, unbox and pop operators into a functional program.
Reference: [CDDK86] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming, </booktitle> <pages> pages 13-27. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: The presentation is new, but draws on ideas in [BdP92, PW95]. It is augmented with a fixpoint operator, natural numbers, and pairs and endowed with a natural call-by-value operational semantics along the lines of Mini-ML <ref> [CDDK86] </ref>. Mini-ML 2 e is somewhat awkward because it requires the broad syntactic structuring of the program to directly reflect staging. We thus consider a more implicit formulation of S4 directly motivated by its Kripke semantics following [MM94, PW95] and then augment it as before to form Mini-ML 2 . <p> of Nielson & Nielson's two-level language [NN92] in Mini-ML 2 , providing further evidence that Mini-ML 2 provides an intuitively appealing, technically correct, and logically motivated view of staged computation. 2 Modal Mini-ML: Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML <ref> [CDDK86] </ref> with a modal -calculus for intuitionistic S4 following ideas in [BdP92, PW95]. For the sake of simplicity Mini-ML 2 e is explicitly typed.
Reference: [Dav95] <author> Rowan Davies. </author> <title> A temporal-logic approach to binding-time analysis. Research Series RS-95-51, </title> <type> BRICS, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Gluck and Jtrgensen [GJ95] have presented a multi-level binding-time analysis, along with practical motivations for multi-level partial evaluation, and also use the less strict binding-time correctness criterion. In other work <ref> [Dav95] </ref> 10 let times 0 :2 (nat ! 2 (nat ! nat)) = box (m:nat: case m of z ) box (n:nat: z) | s m 0 ) box (n:nat: times n (unbox 1 (lift nat m)))) in let iprod 0 = fix ip:nat ! 2 (vector ! 2 (vector !
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: These operators may be considered implicit coercions in a system of subtypes, where type inference corresponds to a form of generalized, polyvariant binding-time analysis. Principal types will only exist if we add restricted intersections, yielding a form of refinement types <ref> [FP91] </ref>, but such a system would nonetheless raise serious coherence problems. Practical experience with larger examples will have to show how much inference along these lines is desirable and feasible. We have omitted polymorphism in this paper, though ML-style polymorphism would only require the addition of a let construct.
Reference: [GJ91] <author> Carsten Gomard and Neil Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Petersburg Beach, Florida. An earlier version appears as Technical Report CMU-CS-95-145, Carnegie Mellon School of Computer Science. tive type system, and that binding-time analysis should be a form of type checking. The work on two-level functional languages [NN92] and some work on partial evaluation (e.g. <ref> [GJ91, Hen91] </ref>) shows that this view is indeed possible and fruitful. Up to now these type systems have been motivated algorithmically, that is, they are explicitly designed to support specialization. <p> This justifies the inclusion of the lift primitive for base types in two-level languages such as in <ref> [GJ91] </ref> and, in a more realistic version of our language, we would also include it as a primitive. 3.4 Translation to Explicit Language We do not define an operational semantics for Mini-ML 2 directly; instead we depend upon a translation to Mini-ML 2 e . <p> Our language differs slightly from [NN92] in that we inject all run-time types into compile-time types, instead of just function types. This follows <ref> [GJ91] </ref>, where there is no such restriction. Also, we find it convenient to divide the variables and contexts into run-time and compile-time. <p> For example, the two-level language we consider, Mini-ML 2 , is directly based on the one in [NN92]. This has a stricter binding-time correctness criterion than used, for example, in <ref> [GJ91] </ref>, even taking into account that the run-time part of the latter is dynamically typed. Essentially, this restriction may be traced to the fact that our underlying evaluation model applies only to closed terms, while [GJ91] requires manipulation of code with free variables. <p> This has a stricter binding-time correctness criterion than used, for example, in <ref> [GJ91] </ref>, even taking into account that the run-time part of the latter is dynamically typed. Essentially, this restriction may be traced to the fact that our underlying evaluation model applies only to closed terms, while [GJ91] requires manipulation of code with free variables. Thus, our system allows the inclusion of the unbox operator to evaluate closed code fragments, with no danger of encountering unbound variables.
Reference: [GJ95] <author> Robert Gluck and Jesper Jtrgensen. </author> <title> Efficient multi-level generating extensions for program specialization. In S.D. </title> <editor> Swierstra and M. Hermenegildo, editors, </editor> <booktitle> Programming Languages, Implementations, Logics and Programs, </booktitle> <pages> pages 259-278. </pages> <publisher> Springer-Verlag LNCS 982, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: This would be avoided if memoization was employed during the compilation or if we had explicitly bound a variable to the result of this computation. 5.2 Inner Products In <ref> [GJ95] </ref> the calculation of inner products is given as an example of a program with more than two phases. We now show how this example can be coded in Mini-ML 2 . <p> Thus, our system allows the inclusion of the unbox operator to evaluate closed code fragments, with no danger of encountering unbound variables. Gluck and Jtrgensen <ref> [GJ95] </ref> have presented a multi-level binding-time analysis, along with practical motivations for multi-level partial evaluation, and also use the less strict binding-time correctness criterion.
Reference: [Hat95] <author> John Hatcliff. </author> <title> Mechanically verifying the correctness of an o*ine partial evaluator. In S.D. </title> <editor> Swierstra and M. Hermenegildo, editors, </editor> <title> Programming Languages, Implementations, Logics and Programs. </title> <publisher> Springer-Verlag LNCS 982, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Similarly, in [PW95] an algorithm for converting pure modal -terms in implicit form to long normal form is given and proven correct. This algorithm bears no resemblance to the staged computation achieved via Mini-ML 2 e . We also have constructed a direct operational semantics for Mini-ML 2 generalizing <ref> [Hat95] </ref> that does capture staging, but prefer the compilation because it makes operational properties more evident. 4 A Two-level Language In this section we define Mini-ML 2 , a two-level functional language very close to the one described in [NN92].
Reference: [Hen91] <author> Fritz Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, 5th ACM Conference, </booktitle> <pages> pages 448-472. </pages> <publisher> Springer-Verlag LNCS 523, </publisher> <year> 1991. </year>
Reference-contexts: Petersburg Beach, Florida. An earlier version appears as Technical Report CMU-CS-95-145, Carnegie Mellon School of Computer Science. tive type system, and that binding-time analysis should be a form of type checking. The work on two-level functional languages [NN92] and some work on partial evaluation (e.g. <ref> [GJ91, Hen91] </ref>) shows that this view is indeed possible and fruitful. Up to now these type systems have been motivated algorithmically, that is, they are explicitly designed to support specialization.
Reference: [JGS93] <author> Neil D. Jones, Carsten Gomard, and Peter Ses-toft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Further, this approach could be extended to prevent code copying during specialization. See [BW93] for a description of a realistic partial evaluator for Standard ML and <ref> [JGS93] </ref> for an overview of standard techniques and examples of partial evaluation. Our language Mini-ML 2 requires the insertion of the box, unbox and pop operators into a functional program.
Reference: [Jon91] <author> Neil D. Jones. </author> <title> Efficient algebraic operations on programs. </title> <editor> In T. Rus, editor, </editor> <booktitle> AMAST Preliminary Proceedings, </booktitle> <institution> University of Iowa, </institution> <month> April </month> <year> 1991. </year> <note> A version appears as a chapter in [JGS93]. </note>
Reference-contexts: This observation immediately gives rise to a natural generalization of standard binding-time analysis by allowing multiple computation stages, initiation of successor stages, and sharing of code across multiple stages. Such extensions are normally considered external issues. For example, Jones <ref> [Jon91] </ref> describes a typed framework for such concepts, but only at the level of operations on whole programs. Our framework instead provides these operations within the language of programs.
Reference: [JS86] <author> Ulrik Jtrring and William L. Scherlis. </author> <title> Compilers and staging transformations. </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 86-96, </pages> <address> St. Petersburg Beach, Florida, </address> <month> Jan-uary </month> <year> 1986. </year>
Reference-contexts: As an example of the compilation, it maps the definition of power from Section 3.3 to the one in Section 2.4. Note that the restructuring achieved by the compiler is similar to a staging transformation <ref> [JS86] </ref>. The operational semantics induced by the translation is very different from the obvious ones defined directly on Mini-ML 2 . In [MM94] a simple reduction semantics is introduced for a system similar to the pure fragment of our implicit system.
Reference: [KEH93] <author> David Keppel, Susan J. Eggers, and Robert R. Henry. </author> <title> A case for runtime code generation. </title> <type> Technical Report TR 93-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The representation must support substitution of one code fragment into another, as required by the ev let box rule. If the code is machine code, this nat urally leads to the idea of templates, as used in run-time code generation (see <ref> [KEH93] </ref>). For many applications this code would instead be source expressions or some intermediate language, thus allowing optimization after code substitution.
Reference: [Kri63] <author> Saul A. Kripke. </author> <title> Semantic analysis of modal logic. I: Normal propositional calculi. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 9 </volume> <pages> 67-96, </pages> <year> 1963. </year>
Reference-contexts: This means that typing derivations for valid terms are unique and the compilation from implicit to explicit terms is deterministic, avoiding some unpleasant problems concerning coherence. The intuition for this system comes from the multiple-world or Kripke semantics for modal logic <ref> [Kri63] </ref>. We think of a world as representing a stage of the computation. Computation is postponed to another stage by applying the box operator to a term M to generate code.
Reference: [LL94] <author> Mark Leone and Peter Lee. </author> <title> Deferred compilation: The automation of run-time code generation. </title> <booktitle> In Proceedings of the Workshop on Partial Evaluation and Semantics-based Program Manipulation (PEPM'94), </booktitle> <address> Orlando, </address> <month> June </month> <year> 1994. </year> <note> An earlier version appears as Carnegie Mellon School of Computer Science Technical Report CMU-CS-93-225, </note> <month> November </month> <year> 1993. </year>
Reference-contexts: If the code is machine code, this nat urally leads to the idea of templates, as used in run-time code generation (see [KEH93]). For many applications this code would instead be source expressions or some intermediate language, thus allowing optimization after code substitution. The deferred compilation approach described in <ref> [LL94] </ref> would provide a more sophisticated implementation, supporting fast run-time generation of optimized code. 3 Modal Mini-ML: Implicit Formulation We now define Mini-ML 2 , an "implicit" formulation of modal Mini-ML following the pure system !2 in [PW95].
Reference: [MM94] <author> Simone Martini and Andrea Masini. </author> <title> A computational interpretation of modal proofs. </title> <editor> In H. Wansing, editor, </editor> <title> Proof theory of Modal Logics. </title> <publisher> Kluwer, </publisher> <year> 1994. </year> <booktitle> Workshop proceedings. </booktitle>
Reference-contexts: Mini-ML 2 e is somewhat awkward because it requires the broad syntactic structuring of the program to directly reflect staging. We thus consider a more implicit formulation of S4 directly motivated by its Kripke semantics following <ref> [MM94, PW95] </ref> and then augment it as before to form Mini-ML 2 . With some syntactic sugar, Mini-ML 2 is intended to serve as the basis for a conservative extension of ML with a practical means to express and check staging of computation. <p> Note that the restructuring achieved by the compiler is similar to a staging transformation [JS86]. The operational semantics induced by the translation is very different from the obvious ones defined directly on Mini-ML 2 . In <ref> [MM94] </ref> a simple reduction semantics is introduced for a system similar to the pure fragment of our implicit system. It does not reflect staging, and is instead used to prove a Church-Rosser theorem and strong normalization for a pure modal -calculus. <p> This fragment corresponds to a weaker modal logic, K, in which we drop the assumption in S4 that the accessibility relation is reflexive and transitive <ref> [MM94] </ref>. Thus a corollary of the generalized theorem is that Mini-ML 2 K is equivalent to a B-level language, since the translation is then a typing-preserving bijection. 5 Examples We now present some standard examples from partial eval uation to illustrate the expressiveness of our language Mini-ML 2 .
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda calculus and monads. </title> <booktitle> In Proceedings of the Fourth Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Asilomar, California, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Note that this is quite different from Moggi's computational -calculus <ref> [Mog89] </ref> which only distinguishes values from computations and does not allow us to express stage separation. Moreover, the intended implementation of code is intensional, since we wish to allow refinements of our semantics to optimize code, while Moggi's computations are extensional with evaluation as the only operation.
Reference: [NN92] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Petersburg Beach, Florida. An earlier version appears as Technical Report CMU-CS-95-145, Carnegie Mellon School of Computer Science. tive type system, and that binding-time analysis should be a form of type checking. The work on two-level functional languages <ref> [NN92] </ref> and some work on partial evaluation (e.g. [GJ91, Hen91]) shows that this view is indeed possible and fruitful. Up to now these type systems have been motivated algorithmically, that is, they are explicitly designed to support specialization. <p> The operational semantics of Mini-ML 2 is given by a type-preserving translation to Mini-ML 2 e whose correctness is not entirely trivial. We then exhibit a simple full and faithful embedding of Nielson & Nielson's two-level language <ref> [NN92] </ref> in Mini-ML 2 , providing further evidence that Mini-ML 2 provides an intuitively appealing, technically correct, and logically motivated view of staged computation. 2 Modal Mini-ML: Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML [CDDK86] with a modal -calculus for intuitionistic <p> also have constructed a direct operational semantics for Mini-ML 2 generalizing [Hat95] that does capture staging, but prefer the compilation because it makes operational properties more evident. 4 A Two-level Language In this section we define Mini-ML 2 , a two-level functional language very close to the one described in <ref> [NN92] </ref>. We then define a simple translation into Mini-ML 2 and prove that binding-time correctness in Mini-ML 2 is equivalent to modal correctness of the translation in Mini-ML 2 . Our language differs slightly from [NN92] in that we inject all run-time types into compile-time types, instead of just function types. <p> define Mini-ML 2 , a two-level functional language very close to the one described in <ref> [NN92] </ref>. We then define a simple translation into Mini-ML 2 and prove that binding-time correctness in Mini-ML 2 is equivalent to modal correctness of the translation in Mini-ML 2 . Our language differs slightly from [NN92] in that we inject all run-time types into compile-time types, instead of just function types. This follows [GJ91], where there is no such restriction. Also, we find it convenient to divide the variables and contexts into run-time and compile-time. All other differences to [NN92] are due to minor differences between <p> Our language differs slightly from <ref> [NN92] </ref> in that we inject all run-time types into compile-time types, instead of just function types. This follows [GJ91], where there is no such restriction. Also, we find it convenient to divide the variables and contexts into run-time and compile-time. All other differences to [NN92] are due to minor differences between their underlying language and Mini-ML. 4.1 Syntax Run-time Types t ::= nat j t 1 !t 2 j t 1 fit 2 Compile-time Types ::= nat j 1 ! 2 j 1 fi 2 j t Terms e ::= x j x:t: e j <p> : nat ` c e 3 : tpc case ` c (case e 1 of z ) e 2 | s y ) e 3 ) : ; ` r e : t ` c e : t Note that we remove run-time assumptions at the down rule, while in <ref> [NN92] </ref> this is done later at the up rule. This change is justified since by the structure of their rules, such assumptions can never be used in the compile-time deduction in between. 4.3 Translation to Implicit Language The translation to Mini-ML 2 is now very simple. <p> The translation and proof can be easily generalized from a two-level language to a B-level language <ref> [NN92] </ref> with an infinite linear ordering. In this case the image of the translation on well-typed terms is exactly the fragment Mini-ML 2 K , where unbox and pop are replaced by a combined constructor unbox 1 . <p> The operational semantics of Mini-ML 2 is given by a type-preserving compilation to Mini-ML 2 e . Further, Mini-ML 2 generalizes Nielson & Nielson's two-level functional language <ref> [NN92] </ref> which is demonstrated by a conservative embedding theorem, the main technical result of this paper. Our investigation remains at a relatively abstract level, thus providing a general framework in which various staging mechanisms may be studied from a new point of view. <p> Concrete instances such as partial evaluation, runtime code generation, or macro expansion will require some additional considerations for their effective use and efficient implementation. For example, the two-level language we consider, Mini-ML 2 , is directly based on the one in <ref> [NN92] </ref>. This has a stricter binding-time correctness criterion than used, for example, in [GJ91], even taking into account that the run-time part of the latter is dynamically typed. <p> In future work we will consider how aspects of both type systems can be combined to allow both manipulation of code with free variables and type-safe evaluation of code in the same language. Sheard and Nelson [SN95] have investigated a two-level extension of Standard ML based on <ref> [NN92] </ref>, with the particular aim of statically typing program generators. They show that a form of dependent types allow a larger class of program generators to be typed.
Reference: [Pal93] <author> Jens Palsberg. </author> <title> Correctness of binding time analysis. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 347-363, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: We can now justify the claim that the type system of Mini-ML 2 e captures the separation of a computation into stages. We follow the basic criteria for correctness of <ref> [Pal93] </ref> in which a modular proof of correctness for binding-time analyzes was presented. Suppose that ; ` e E : 2A and E ,! V . By 1 and 3 we have V box E 0 .
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: As such it allows efficient code to be generated within a declarative style of programming, and provides an automatic check that the intended staging is achieved. We have implemented a simple version of Mini-ML 2 in the logic programming language Elf <ref> [Pfe91] </ref>.
Reference: [PW95] <author> Frank Pfenning and Hao-Chi Wong. </author> <title> On a modal -calculus for S4. </title> <editor> In S. Brookes and M. Main, editors, </editor> <booktitle> Proceedings of the Eleventh Conference on Mathematical Foundations of Programming Sematics, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: We begin by considering Mini-ML 2 e , a formulation of in-tuitionistic modal S4 in which the permissible operations on code and the staging of computation are represented very explicitly. The presentation is new, but draws on ideas in <ref> [BdP92, PW95] </ref>. It is augmented with a fixpoint operator, natural numbers, and pairs and endowed with a natural call-by-value operational semantics along the lines of Mini-ML [CDDK86]. Mini-ML 2 e is somewhat awkward because it requires the broad syntactic structuring of the program to directly reflect staging. <p> Mini-ML 2 e is somewhat awkward because it requires the broad syntactic structuring of the program to directly reflect staging. We thus consider a more implicit formulation of S4 directly motivated by its Kripke semantics following <ref> [MM94, PW95] </ref> and then augment it as before to form Mini-ML 2 . With some syntactic sugar, Mini-ML 2 is intended to serve as the basis for a conservative extension of ML with a practical means to express and check staging of computation. <p> providing further evidence that Mini-ML 2 provides an intuitively appealing, technically correct, and logically motivated view of staged computation. 2 Modal Mini-ML: Explicit Formulation This section presents Mini-ML 2 e , a language that combines some elements of Mini-ML [CDDK86] with a modal -calculus for intuitionistic S4 following ideas in <ref> [BdP92, PW95] </ref>. For the sake of simplicity Mini-ML 2 e is explicitly typed. ML-style or explicit polymorphism can also be added in a straightforward manner; we omit the details here in order to concentrate on the essential issues within the given space constraints. <p> The outer context contains variables that may be bound only to code during evaluation; contains variables that may be bound to arbitrary values. Only variables in are permitted to occur free inside box expressions. This presentation simplifies that of the modal -calculus !2 e from <ref> [BdP92, PW95] </ref> by eliminating the need for simultaneous substitution while preserving subject reduction. The elimination construct for box allows us to bind a variable x in to code of type A, written as let box x = E 1 in E 2 . <p> The problem of typing the modal fragment is well understood; we present here a variant of known systems <ref> [BdP92, PW95] </ref> with two contexts as motivated above. ; ` e E : A E has type A in modal context and non-modal context . <p> The deferred compilation approach described in [LL94] would provide a more sophisticated implementation, supporting fast run-time generation of optimized code. 3 Modal Mini-ML: Implicit Formulation We now define Mini-ML 2 , an "implicit" formulation of modal Mini-ML following the pure system !2 in <ref> [PW95] </ref>. The main advantage of this system over the explicit language is that altering the staging of a computation often only requires the insertion or deletion of modal constructors. <p> The operational semantics of the new system is given in terms of a type-preserving compilation to Mini-ML 2 e which resembles the proof of equivalence between !2 e and !2 given in <ref> [PW95] </ref>. Besides the differences in the explicit system mentioned earlier, we add here a term constructor pop. This means that typing derivations for valid terms are unique and the compilation from implicit to explicit terms is deterministic, avoiding some unpleasant problems concerning coherence. <p> In [MM94] a simple reduction semantics is introduced for a system similar to the pure fragment of our implicit system. It does not reflect staging, and is instead used to prove a Church-Rosser theorem and strong normalization for a pure modal -calculus. Similarly, in <ref> [PW95] </ref> an algorithm for converting pure modal -terms in implicit form to long normal form is given and proven correct. This algorithm bears no resemblance to the staged computation achieved via Mini-ML 2 e .
Reference: [Smi84] <author> Brian Cantwell Smith. </author> <title> Reflection and semantics in Lisp. </title> <booktitle> In Proceedings of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Salt Lake City, </address> <pages> pages 23-35. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1984. </year>
Reference-contexts: Note however that this analogy can also sometimes be misleading, and the actual behavior of code is closer to the quotations of a "semantically rationalized dialect" of Lisp called 2-Lisp <ref> [Smi84] </ref>. 3.1 Syntax Types A ::= nat j A 1 ! A 2 j A 1 fi A 2 j 2A Terms M ::= x j x:A: M j M 1 M 2 j fix x:A: M j z j s M j (case M 1 of z ) M 2
Reference: [SN95] <author> Tim Sheard and Neal Nelson. </author> <title> Type safe abstractions using program generators. </title> <type> Technical Report OGI-TR-95-013, </type> <institution> Oregon Graduate Institute of Science and Technology, Department of Computer Science, </institution> <year> 1995. </year> <month> 13 </month>
Reference-contexts: In future work we will consider how aspects of both type systems can be combined to allow both manipulation of code with free variables and type-safe evaluation of code in the same language. Sheard and Nelson <ref> [SN95] </ref> have investigated a two-level extension of Standard ML based on [NN92], with the particular aim of statically typing program generators. They show that a form of dependent types allow a larger class of program generators to be typed.
References-found: 23

