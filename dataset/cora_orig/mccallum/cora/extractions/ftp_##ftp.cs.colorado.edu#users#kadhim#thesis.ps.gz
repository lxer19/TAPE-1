URL: ftp://ftp.cs.colorado.edu/users/kadhim/thesis.ps.gz
Refering-URL: http://www.cs.colorado.edu/~kadhim/thesis.html
Root-URL: http://www.cs.colorado.edu
Title: DEBUGGER GENERATION IN A COMPILER GENERATION SYSTEM  
Author: by BASIM MARKUS KADHIM B. S., M. S., 
Degree: 1993 A thesis submitted to the Faculty of the Graduate School of the  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: 1998  
Address: 1990  
Affiliation: University of Colorado,  University of Colorado,  University of Colorado  Department of Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Vincenzo Ambriola and Carlo Montangero. </author> <title> Automatic generation of execution tools in a GANDALF environment. </title> <journal> Journal of Systems and Software, </journal> <volume> 5 </volume> <pages> 155-171, </pages> <year> 1985. </year>
Reference-contexts: One of the primary areas in which they differ is in the specification of dynamic semantics. PSG uses denotational semantics, the Synthesizer Generator uses attribute grammars, and Centaur uses what it calls "Natural Semantics". The Gandalf project [27] produced another tool to generate language-sensitive structure editors. Ambriola and Montangero <ref> [1] </ref> developed a tool in conjunction with Gandalf that allowed automatic generation of execution tools, such as interpreters and debuggers. Dynamic semantics in their tool were specified using denotational semantics. Despite their differences, a central theme is the use of abstract syntax trees to describe semantic structure.
Reference: [2] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language, appendix D. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The most important is the programming language used and generated. Some languages and language extensions provide direct support for persistence. PS-Algol is an example of such a language [3]. In Java, classes of objects can be made eligible for persistence by marking them as "Serializable" <ref> [2] </ref>. In general, implementing persistence for strongly typed languages is a great deal easier than for weakly typed languages, since it is possible to automatically determine the types of the objects being stored.
Reference: [3] <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, P.W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <year> 1983. </year>
Reference-contexts: There are a number of requirements that constrain the choice of the mechanism for persistence. The most important is the programming language used and generated. Some languages and language extensions provide direct support for persistence. PS-Algol is an example of such a language <ref> [3] </ref>. In Java, classes of objects can be made eligible for persistence by marking them as "Serializable" [2]. In general, implementing persistence for strongly typed languages is a great deal easier than for weakly typed languages, since it is possible to automatically determine the types of the objects being stored.
Reference: [4] <author> AT&T. </author> <title> UNIX System V Release 4 Programmer's Guide: ANSI C and Programming Support Tools, </title> <year> 1990. </year>
Reference-contexts: The author of the debugger can also code to the same interface for data structures that the compiler uses. The common existing solution to the task of transferring information from translator to debugger is to use standardized debugging information formats, such as stabs [22] and DWARF <ref> [4] </ref>. The advantage that such standards have is that it is easier for a large number of debuggers to use the same standardized interface to debug code generated from translators that conform to the interface. <p> The standard method for making compilation data persistent is to translate the information into a standardized format that can be stored as part of compiled object code. DWARF <ref> [4] </ref> and stabs [22] are two examples of such debugging information formats. This kind of standardization is useful for compilers that wish to be usable with a large number of debuggers.
Reference: [5] <author> Ron Baecker, Chris DiGiano, and Aaron Marcus. </author> <title> Software visualization for debugging. </title> <journal> Communications of the ACM, </journal> <volume> 40(4) </volume> <pages> 44-54, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: The simplest form of this is a command-line interface, which reads a line typed by the user and provides a method for displaying lines of output. Considerable research has recently been devoted to the exploration of more user friendly interfaces to debugging <ref> [5, 28, 43, 68] </ref>. This particular avenue of research, however, is beyond the scope of this thesis. Many of the approaches to providing more complex user interfaces for debugging demonstrate the viability of either building a wrapper around or instrumenting an existing line mode debugger.
Reference: [6] <author> Rolf Bahlke, Bernhard Moritz, and Gregor Snelting. </author> <title> A generator for language-specific debugging systems. </title> <booktitle> In Proceedings of the SIGPLAN Symposium on Interpreters and Interpretive Techniques, </booktitle> <volume> volume 22, </volume> <pages> pages 92-101. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> July </month> <year> 1987. </year>
Reference-contexts: Extensions for debugging in these systems then focus on controlling the execution of the dynamic semantics. The typical approach is to allow breakpoints to be set at specific nodes of the abstract syntax tree that correspond to source language constructs. Bahlke, Moritz, and Snelting <ref> [6] </ref> outline how this is done for PSG. A system called Maygen [61] provides a very different kind of support for generating debuggers. Maygen assumes the existence of components that implement a source language interface and a machine architecture interface.
Reference: [7] <author> Rolf Bahlke and Gregor Snelting. </author> <title> The PSG system: From formal language definitions to interactive programming environments. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 547-576, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: Existing techniques for the generation of programming support tools focus primarily on tools to generate interpreters. Examples of such systems are PSG <ref> [7] </ref> and Centaur [9]. Both use high-level specifications to generate interpreters and debuggers for the languages specified. Because these systems are based on interpreted environments, the use of the generated tools is tied very closely to the environment in which they are generated. <p> As indicated before, most research efforts to date in generating debuggers, and programming support tools in general, have focused on providing tools in interpreted environments rather than providing tools for compiled code. For example, the PSG system <ref> [7] </ref> generates interactive environments that include a language-sensitive structure editor and interpreter from a set of specifications. The Synthesizer Generator [54, 60] and Centaur [9] both generate similar kinds of tools, but differ in the mechanisms used to produce these tools.
Reference: [8] <author> David M. Beazley. </author> <title> SWIG : An easy to use tool for integrating scripting languages with C and C++. </title> <booktitle> Presented at the 4th Annual Tcl/Tk Workshop, </booktitle> <address> Monterey, CA., </address> <month> July </month> <year> 1996. </year>
Reference-contexts: formulate the query and pass it via Expect to the 1 The Expect command interpreter is actually just a superset of Tcl augmented to provide Expect functionality. 2 It may be possible to generate a suitable Tcl interface to the generated query processing code using a tool such as SWIG <ref> [8] </ref>. 38 existing debugger. Expect then allows the author of the debugger to capture the output from the existing debugger and either print it out directly or transform it before printing it out.
Reference: [9] <author> P. Borras, D. Clement, Th. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> Centaur: the system. </title> <booktitle> In Proceedings of SIGSOFT'88, Third Annual Symposium on Software Development Environments (SDE3), </booktitle> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: Existing techniques for the generation of programming support tools focus primarily on tools to generate interpreters. Examples of such systems are PSG [7] and Centaur <ref> [9] </ref>. Both use high-level specifications to generate interpreters and debuggers for the languages specified. Because these systems are based on interpreted environments, the use of the generated tools is tied very closely to the environment in which they are generated. <p> For example, the PSG system [7] generates interactive environments that include a language-sensitive structure editor and interpreter from a set of specifications. The Synthesizer Generator [54, 60] and Centaur <ref> [9] </ref> both generate similar kinds of tools, but differ in the mechanisms used to produce these tools. One of the primary areas in which they differ is in the specification of dynamic semantics.
Reference: [10] <editor> Jan Bosch and Gorel Hedin (eds.). </editor> <title> Proceedings of ALEL'96, workshop on compiler techniques for application domain languages and extensible language models. </title> <type> Technical Report LU-CS-TR:96-173, </type> <institution> Lund University, Sweden, </institution> <year> 1996. </year>
Reference-contexts: Recent workshops and conferences devoted to the discussion of special-purpose languages and the infrastructure for implementing translators for them provide evidence of this <ref> [10, 34] </ref>. If we look beyond the construction of the translator to its use, we find that we do not yet have the programming support tools we are accustomed to using in conjunction with other compilers. These include tools such as symbolic debuggers and profilers.
Reference: [11] <author> Per Brinch Hansen. </author> <title> Brinch Hansen on Pascal Compilers. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, N.J., </address> <year> 1985. </year>
Reference-contexts: The two examples both translate the same source language (Pascal- as defined by Per Brinch Hansen <ref> [11] </ref>), but translate to different target languages. The first target language is code for an abstract stack-oriented machine and the second is Digital Alpha assembly language code. <p> The next chapter will demonstrate how the debugger is constructed and how it utilizes the information provided by the compiler. The two examples both translate the same language, but translate to different target code. The language is a subset of Pascal defined by Per Brinch Hansen <ref> [11] </ref> that I will refer to as Pascal-. One of the translations targets is an abstract stack-oriented machine defined by Brinch Hansen. A complete Eli specification for this translation can be found in [62].
Reference: [12] <author> Gary Brooks, Gilbert J. Hansen, and Steve Simmons. </author> <title> A new approach to debugging 76 optimized code. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-11, </pages> <year> 1992. </year>
Reference-contexts: As indicated earlier in this chapter, data structures for mapping source and target representations of a program are complicated significantly by optimizations performed by a compiler. A paper by Brooks et al., of Convex Computer Corporation <ref> [12] </ref> details their experience in developing a debugger for optimized code that relies heavily on developing a specialized set of data structures to present an appropriate view of the running program to users.
Reference: [13] <author> Geoffrey Clemm and Leon Osterweil. </author> <title> A mechanism for environment integration. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 2-25, </pages> <year> 1990. </year>
Reference-contexts: Eli permits redundant declarations to appear in more than one module so that each module can be used independently. The interface to the integrated set of components that make up Eli is a derived object manager called Odin <ref> [13] </ref>. Odin operates on the basis of a derivation graph that specifies derivation steps and dependencies required to construct derived objects from source objects provided by a user.
Reference: [14] <author> Deborah S. Coutant, Sue Meloy, and Michelle Ruscetta. </author> <title> DOC: A practical approach to source-level debugging of globally optimized code. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 125-134, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: A paper by Brooks et al., of Convex Computer Corporation [12] details their experience in developing a debugger for optimized code that relies heavily on developing a specialized set of data structures to present an appropriate view of the running program to users. DOC, described by Coutant et al. <ref> [14] </ref> is another example of a compiler and debugger 46 that have been instrumented to produce and use new data structures for the purpose of debugging optimized code.
Reference: [15] <author> Fabio Q. B. da Silva. </author> <title> Correctness proofs of compilers and debuggers: an overview of an approach based on structural operational semantics. </title> <type> Technical Report ECS-LFCS-92-233, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: The doctoral thesis of Fabio da Silva <ref> [15] </ref> advocates building debuggers that conform to the semantics of the source language, such that a direct formal correspondence can be made between the semantics of the source language and execution under a debugger.
Reference: [16] <author> Tor Didriksen, Anund Lie, and Reidar Conradi. </author> <title> IDL as a data description language for a programming environment database. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(11) </volume> <pages> 71-78, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Yet another approach is the use of schemas or interface definition languages (IDL's) to describe the data that is to be made persistent. Didriksen et al., discuss the use of IDL [64] as the data model for use in a programming environment database in <ref> [16] </ref>. Powell and Linton [52] describe the use of a relational database to support persistence of information in programming environments. Their approach requires specifying the persistent data types in a database schema language.
Reference: [17] <author> Digital Equipment Corporation. </author> <title> DEC OSF/1 Assembly Language Programmer's Guide, </title> <month> March </month> <year> 1993. </year> <title> Part Number: </title> <publisher> AA-PS31A-TE. </publisher>
Reference-contexts: One of the translations targets is an abstract stack-oriented machine defined by Brinch Hansen. A complete Eli specification for this translation can be found in [62]. The second translation targets assembly code for a Digital Alpha processor running the DEC OSF/1 operating system <ref> [17] </ref>. I wrote the Eli specification for this translation based on the specifications for the first translation. Compiler construction systems are used for a wide variety of translations and these two translations are representative of the significant differences in the kinds of generated target code.
Reference: [18] <author> John Doppke. </author> <type> Personal communications. </type>
Reference-contexts: These are features often found in conjunction with persistence mechanisms, but they introduce unnecessary overhead and complexity to the problem presented here. The solution described here is a C++ library and headers called SOS (for Simple Object Storage). The original version of SOS was written by John Doppke <ref> [18] </ref>. This version provided class-based persistence, i.e., the decision about which objects to be made persistent was decided statically according to class. I modified the system to change this static policy to a dynamic one based on reachability analysis.
Reference: [19] <author> D. R. Engler. </author> <title> VCODE: a retargetable, extensible, very fast dynamic code generation system. </title> <booktitle> In Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year> <note> http://www.pdos.lcs.mit.edu/~engler/vcode.html. </note>
Reference-contexts: Techniques for generating interpreters using attribute grammars is discussed in [39]. An alternative to interpreting debugging requests is to dynamically generate code in the same way the translator does and then to execute the generated code. VCODE <ref> [19] </ref> is an example of a system for dynamic code generation and [42] describes how to execute generated code. Unfortunately, the interfaces for using such systems differ enough from the way code is generated by the translator that no significant leverage is achieved by following this approach.
Reference: [20] <author> C. W. Fraser, D. R. Hanson, and T. A. Proebsting. </author> <title> Engineering a simple, efficient code generator generator. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 213-226, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Scanning and parsing are well understood tasks for which a wide variety of tools exist, while automated and portable machine code generation is not as well understood and is still the subject of considerable research <ref> [20, 53] </ref>. Existing techniques for the generation of programming support tools focus primarily on tools to generate interpreters. Examples of such systems are PSG [7] and Centaur [9]. Both use high-level specifications to generate interpreters and debuggers for the languages specified.
Reference: [21] <institution> Free Software Foundation. The GNU linker. </institution>
Reference-contexts: In addition to this encumbrance placed on the user, the implementation of this approach is not very portable. Many standard linkers do not provide the support needed to implement this solution. While the GNU linker <ref> [21] </ref> does provide the needed support, it only supports a restricted set of platforms. In addition, issues of name mangling can cause problems. Depending on the platform and compiler, the names generated in the object code may or may not be prefaced by an underscore.
Reference: [22] <author> Free Software Foundation. </author> <title> The "stabs" debugging format. GNU info document. </title>
Reference-contexts: The author of the debugger can also code to the same interface for data structures that the compiler uses. The common existing solution to the task of transferring information from translator to debugger is to use standardized debugging information formats, such as stabs <ref> [22] </ref> and DWARF [4]. The advantage that such standards have is that it is easier for a large number of debuggers to use the same standardized interface to debug code generated from translators that conform to the interface. <p> The standard method for making compilation data persistent is to translate the information into a standardized format that can be stored as part of compiled object code. DWARF [4] and stabs <ref> [22] </ref> are two examples of such debugging information formats. This kind of standardization is useful for compilers that wish to be usable with a large number of debuggers.
Reference: [23] <author> Free Software Foundation. </author> <title> The GNU debugger, </title> <address> 4.12 edition, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Many debuggers also provide commands that allow users to alter the scope of evaluation. For example, the up command in the gdb debugger changes the current scope of evaluation to be the scope associated with the stack frame of the calling routine <ref> [23] </ref>. The implementation of scoping rules in Eli uses an abstract data type described by Kastens and Waite [40], which is implemented as a tree of scopes. Each scope maintains the relationship between identifiers and definition table keys (definition table keys are described in detail in Chapter 2).
Reference: [24] <author> Michael Golan and David R. Hanson. </author> <title> DUEL a very high-level debugging language. </title> <booktitle> In Proceedings of the USENIX Winter Conference. USENIX, </booktitle> <month> January </month> <year> 1993. </year> <institution> In San Diego, California. </institution>
Reference-contexts: The descriptions in this chapter have focused on a scenario in which the debugging request language is modeled closely after the source language. In this way, existing translator specifications can be most fully utilized in specifying a debugger. Duel <ref> [24] </ref>, Dalek [48], and ACID [66] are examples of debuggers in which the debugging language has been extended with constructs aimed at providing greater expressibility for debugging but do not have direct analogs in the source language. <p> The support provided as part of this research for passing arbitrary information from the translator to the debugger may more easily enable experimentation. In addition, some recent debugging research aims to extend the constructs provided in debugging query languages. For example, the Duel debugger <ref> [24] </ref> adds debugging language constructs that enhance the users ability to explore the state of the program. Using compiler generation tools to process the query language can make it easier to experiment with changes of this kind.
Reference: [25] <author> Robert W. Gray. </author> <title> A generator for lexical analyzers that programmers can use. </title> <booktitle> In Proceedings of the 1988 USENIX Conference, </booktitle> <pages> pages 147-160, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Beyond scanner and parser generation, the framework I describe in this thesis assumes support for computations over abstract syntax trees and some uniform representation for definition table information. 1 Eli includes a scanner generator called GLA <ref> [25] </ref> and two parser generators: COLA and PGS. Computations over trees in Eli are supported by the Liga attribute grammar evaluation system [38] and the interface to the definition table is described by a property definition language, called PDL.
Reference: [26] <author> Robert W. Gray, Vincent P. Heuring, Steve P. Levi, Anthony M. Sloane, and William M. </author> <title> 77 Waite. Eli: A complete, flexible compiler construction system. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Prior to this work, no such debuggers for Pascal- existed. The test bed for the work described in this thesis is the Eli Compiler Construction System <ref> [26] </ref>. While many of the techniques described are not specific to Eli, a number of Eli's features significantly contribute to the success of this research.
Reference: [27] <author> A. Nico Habermann and David Notkin. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(12) </volume> <pages> 1117-1127, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: One of the primary areas in which they differ is in the specification of dynamic semantics. PSG uses denotational semantics, the Synthesizer Generator uses attribute grammars, and Centaur uses what it calls "Natural Semantics". The Gandalf project <ref> [27] </ref> produced another tool to generate language-sensitive structure editors. Ambriola and Montangero [1] developed a tool in conjunction with Gandalf that allowed automatic generation of execution tools, such as interpreters and debuggers. Dynamic semantics in their tool were specified using denotational semantics.
Reference: [28] <author> David R. Hanson and Jeffrey L. Korn. </author> <title> A simple and extensible graphical debugger. </title> <booktitle> In Proceedings of the USENIX 1997 Annual Technical Conference, </booktitle> <pages> pages 163-174, </pages> <address> Anaheim, CA, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The simplest form of this is a command-line interface, which reads a line typed by the user and provides a method for displaying lines of output. Considerable research has recently been devoted to the exploration of more user friendly interfaces to debugging <ref> [5, 28, 43, 68] </ref>. This particular avenue of research, however, is beyond the scope of this thesis. Many of the approaches to providing more complex user interfaces for debugging demonstrate the viability of either building a wrapper around or instrumenting an existing line mode debugger. <p> One is also limited to the set of platforms supported by the library. The approach taken in my framework bears some resemblance to the way debuggers like DEET <ref> [28] </ref> and DDD [68] are constructed. The goal for these debuggers is to provide a unique user interface to existing debuggers. DEET calls the code that wraps around an existing debugger, such as gdb, a "debug nub".
Reference: [29] <author> Jurgen Heymann. </author> <title> A 100% portable inline-debugger. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 39-46, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Because significant effort is required in providing the components for Maygen's interfaces, it is not clear how much leverage is achieved. One other relevant area is that of debuggers for source to source translations. One of the few examples of such a debugger is described by Heymann <ref> [29] </ref>. This debugger debugs a translation from a simulation language called SIMSCRIPT II.5 to C. 9 1.4 Outline The next three chapters will focus on the major components of the framework: persistence of debugging information, query processing, and debugging functionality provided by the run-time library.
Reference: [30] <author> Mark Scott Johnson. </author> <title> The design and implementation of a run-time analysis and interactive debugging environment. </title> <type> Technical Report 78-6, </type> <institution> University of British Columbia, </institution> <month> August </month> <year> 1978. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: This section talks about work related to the complete task of generating a debugger. In 1978, Mark Johnson first suggested the notion of a debugger generation system [31], which ... given a language definition, produces a language-dependent debugger for programs written in that language. <ref> [30, page 65] </ref>. As indicated before, most research efforts to date in generating debuggers, and programming support tools in general, have focused on providing tools in interpreted environments rather than providing tools for compiled code.
Reference: [31] <author> Mark Scott Johnson. </author> <title> A software debugging glossary. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(2):53, </volume> <month> February </month> <year> 1982. </year>
Reference-contexts: Related work that falls into these categories will be discussed in the chapter of the thesis that focuses on that component. This section talks about work related to the complete task of generating a debugger. In 1978, Mark Johnson first suggested the notion of a debugger generation system <ref> [31] </ref>, which ... given a language definition, produces a language-dependent debugger for programs written in that language. [30, page 65].
Reference: [32] <author> Basim M. Kadhim. </author> <title> Property definition language manual. </title> <type> Technical Report CU-CS-776-95, </type> <institution> University of Colorado, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: for persistence in these components requires principles beyond the straightforward application of SOS described in the last section. 2.2.1 Persistence of a Definition Table The definition table interface in Eli consists of a fixed portion and one that is generated from a specification written in PDL (for Property Definition Language) <ref> [32, 63] </ref>. The fixed portion exports a type representing a definition table key, DefTableKey, an operation to create new instances of these keys, and a generic accessor function. The PDL language allows users to specify a set of properties, their types, and access operations (a default set is provided).
Reference: [33] <author> Basim M. Kadhim and William M. Waite. </author> <title> Maptool supporting modular syntax development. </title> <editor> In Tibor Gyimothy, editor, </editor> <booktitle> Proceedings of the 6th International Conference on Compiler Construction, CC'96, volume 1060 of Lecture Notes on Computer Science, </booktitle> <pages> pages 268-280, </pages> <address> Linkoping, Sweden, April 1996. </address> <publisher> Springer. </publisher>
Reference-contexts: For example, code to construct an abstract syntax tree does not need to be provided by the user as it can be provided automatically based on an analysis of the concrete and abstract syntaxes <ref> [33] </ref>. Integration is also done with an eye towards extensibility: users are given the possibility of overriding default behaviors of the system as well as introducing their own components.
Reference: [34] <author> Sam Kamin(ed.). </author> <title> Proceedings of DSL'97 workshop on domain-specific languages. </title> <type> Technical report, </type> <institution> University of Illinois, </institution> <year> 1997. </year> <note> Contents available from URL http://www-sal.cs.uiuc.edu/~kamin/dsl. </note>
Reference-contexts: Recent workshops and conferences devoted to the discussion of special-purpose languages and the infrastructure for implementing translators for them provide evidence of this <ref> [10, 34] </ref>. If we look beyond the construction of the translator to its use, we find that we do not yet have the programming support tools we are accustomed to using in conjunction with other compilers. These include tools such as symbolic debuggers and profilers.
Reference: [35] <author> U. Kastens. PTG: </author> <title> Pattern-based Text Generator. University of Paderborn. Distributed with the Eli Compiler Construction System. </title>
Reference-contexts: For the abstract machine translation, this code is isolated in a function called LineMarker that takes an integer line number and prints out the appropriate directive. generation component called PTG (for Pattern-Based Text Generator) <ref> [35] </ref>. The function's first argument is of type PTG OUTPUT FILE, which is PTG's representation of the output file descriptor. It uses other PTG-defined macros to print out a C preprocessor line directive. SRCFILE is a macro that represents the name of the input file.
Reference: [36] <author> Uwe Kastens. </author> <title> LIDO Computations in Trees. University of Paderborn. Distributed with the Eli Compiler Construction System. </title>
Reference-contexts: These specification methods are common to most compiler generation toolsets. Semantic analysis in Eli is described by an attribute grammar that defines computations over abstract syntax trees. Using an attribute grammar allows the specification of computations and dependencies to be separated from the tree traversal strategy <ref> [36] </ref>. This separation of concerns greatly simplifies the composability and reuse of existing specifications. Being able to reuse translator specification fragments and compose these with specifications specific to a debugger is one of the central themes of the framework described by this thesis.
Reference: [37] <author> Uwe Kastens. </author> <title> LIDO Reference Manual. University of Paderborn. Distributed with the Eli Compiler Construction System. </title>
Reference-contexts: VariableNameUse: Name . FieldNameUse: Name . RULE: Location ::= Procedure COMPUTE CHAINSTART Procedure.ProcChain = NoKey; Location.Key = Procedure.ProcChain; END; RULE: Procedure ::= Name COMPUTE Procedure.ProcChain = KeyInEnv (GetEnv (Procedure.ProcChain, CurrentEnv), Name); END; 61 in the LIDO attribute grammar language <ref> [37] </ref>. A chain results in a depth-first left-to-right computation of the attributes named by the chain. In this particular set of chain computations, the chain holds the definition table key of the last procedure name resolved in the colon separated list.
Reference: [38] <author> Uwe Kastens. </author> <title> An attribute grammar system in a compiler construction environment. </title> <booktitle> In Proceedings of the International Summer School on Attribute Grammars, Application and Systems, volume 545 of Lecture Notes on Computer Science, </booktitle> <pages> pages 380-400. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year> <month> 78 </month>
Reference-contexts: Computations over trees in Eli are supported by the Liga attribute grammar evaluation system <ref> [38] </ref> and the interface to the definition table is described by a property definition language, called PDL. Eli also provides specification languages to describe command line processing, operator identification, and output generation, as well as a large collection of modules for many common translation tasks including name and type analysis.
Reference: [39] <author> Uwe Kastens. </author> <title> Generating interpreters from compiler specifications. </title> <type> Technical Report TR-RI-94-143, </type> <institution> University of Paderborn, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: While better solutions may be achieved by using the tools in more limited circumstances, it results in more of the input processing having to be hand-coded. Techniques for generating interpreters using attribute grammars is discussed in <ref> [39] </ref>. An alternative to interpreting debugging requests is to dynamically generate code in the same way the translator does and then to execute the generated code. VCODE [19] is an example of a system for dynamic code generation and [42] describes how to execute generated code.
Reference: [40] <author> Uwe Kastens and William M. Waite. </author> <title> An abstract data type for name analysis. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 539-558, </pages> <year> 1991. </year>
Reference-contexts: For example, the lexical analysis phase will typically construct string and/or identifier tables. The name analysis phase of semantic analysis will typically construct an abstract data type to represent the scoping of identifiers. Eli has such an abstract data type, called the environment module, which is described in <ref> [40] </ref>. In addition to these, Eli provides a generic property storage module that facilitates the creation and manipulation of objects with a set of arbitrary properties of arbitrary types. Collectively, we can refer to these different kinds of information as the information store. <p> For example, the up command in the gdb debugger changes the current scope of evaluation to be the scope associated with the stack frame of the calling routine [23]. The implementation of scoping rules in Eli uses an abstract data type described by Kastens and Waite <ref> [40] </ref>, which is implemented as a tree of scopes. Each scope maintains the relationship between identifiers and definition table keys (definition table keys are described in detail in Chapter 2). Children in the tree of scopes represent nested scopes. <p> The most common commands that allow modification of the current scope are those that allow traversal up and down the dynamic call chain (e.g., gdb provides the commands up and down). Eli uses an abstract data type called the environment module (described by Kastens and Waite <ref> [40] </ref>) to hold scoping information from the translation of a particular input. The primary task in name analysis is to populate the environment module with scopes and the identifiers in those scopes.
Reference: [41] <author> Uwe Kastens and William M. Waite. </author> <title> Modularity and reusability in attribute grammars. </title> <journal> Acta Informatica, </journal> <volume> 31 </volume> <pages> 601-627, </pages> <year> 1994. </year>
Reference-contexts: In addition to the environment module, Eli provides a number of library modules that, when instantiated, implement the most common variants of name analysis. When using these modules, users need only inherit computations from the module onto symbols in their own abstract syntax tree <ref> [41] </ref>. For example, the name analysis modules export named sets of computations for the roles of identifier definitions, identifier uses, and scoping ranges. The user is insulated from the details of the computations that interact with the environment module. <p> To make it persistent (and the transitive closure of objects it refers to), the module's interface exports a computational role called SaveEnvironment for use in an attribute grammar. Computational roles are used by inheriting them to symbols in the abstract syntax as described by Kastens and Waite <ref> [41] </ref>. This particular computational role requires the user to provide the computation of an attribute called SaveEnv that represents the environment data structure to be saved.
Reference: [42] <author> David Keppel. </author> <title> A portable interface for on-the-fly instruction space modification. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 86-95. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: Techniques for generating interpreters using attribute grammars is discussed in [39]. An alternative to interpreting debugging requests is to dynamically generate code in the same way the translator does and then to execute the generated code. VCODE [19] is an example of a system for dynamic code generation and <ref> [42] </ref> describes how to execute generated code. Unfortunately, the interfaces for using such systems differ enough from the way code is generated by the translator that no significant leverage is achieved by following this approach.
Reference: [43] <author> Chris Laffra and Ashok Malhotra. </author> <title> HotWire | A visual debugger for C++. </title> <booktitle> In USENIX Association, editor, Proceedings of the 1994 USENIX C++ Conference: </booktitle> <address> April 11-14, 1994, Cambridge, MA, </address> <pages> pages 109-122, </pages> <address> Berkeley, CA, USA, </address> <month> April </month> <year> 1994. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: The simplest form of this is a command-line interface, which reads a line typed by the user and provides a method for displaying lines of output. Considerable research has recently been devoted to the exploration of more user friendly interfaces to debugging <ref> [5, 28, 43, 68] </ref>. This particular avenue of research, however, is beyond the scope of this thesis. Many of the approaches to providing more complex user interfaces for debugging demonstrate the viability of either building a wrapper around or instrumenting an existing line mode debugger.
Reference: [44] <author> John R. Levine, Tony Mason, and Doug Brown. </author> <title> Lex & Yacc. </title> <publisher> O'Reilly & Associates, </publisher> <year> 1992. </year>
Reference-contexts: An interactive processor can use this mechanism to force the parsing of the query to resume after new input has been read and the last token has been altered to be the first token of the new input. 3.4 Related Work Using compiler generation tools such as Lex and Yacc <ref> [44] </ref> when implementing interactive processors is not a new idea. Existing debuggers such as gdb [51] use Yacc to parse C expressions. These existing interactive processors typically use compiler generation tools more selectively to avoid dealing with some of the user input issues discussed in the last two sections.
Reference: [45] <author> Don Libes. </author> <title> Exploring Expect. </title> <address> O'Reilly, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: To utilize this existing functionality, it is necessary to construct an appropriate interface to an existing debugger, which can be accomplished with a combination of existing compiler generation tools and new tools. This thesis will discuss the use of a tool, called Expect <ref> [45] </ref>, that can be used to devise a suitable interface to the functionality provided by any existing line mode debugger. 1.2.4 Query Processing The query processing component of the debugger is responsible for taking input from the debugger shell and performing the appropriate debugging function. <p> A better solution is for the new debugger to interface with the existing debugger as any user would. Assuming that the existing debugger has a line-mode interface, we can use a tool like Expect <ref> [45] </ref> to manage this interface. Expect is a tool that uses the Tcl scripting language [49] to allow programmed dialogue with interactive programs such as a line-mode debugger. Section 4.1 describes in greater detail how Expect can be used to control an existing debugger. This solution is much more flexible.
Reference: [46] <author> Mark A. Linton. </author> <title> The evolution of Dbx. </title> <booktitle> In Proceedings of the USENIX Summer Conference, </booktitle> <pages> pages 211-220. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year> <title> In Anaheim, </title> <address> California. </address>
Reference-contexts: Vern Paxson provides a good survey of debugging techniques in [50], Mark Linton describes issues in the development of the commercial Dbx debugger in <ref> [46] </ref>, and a document exists that describes the internals of the GNU debugger, gdb [51]. Dynascope is a research project that undertook to provide a suite of debugging functionality with an architecture independent interface in the form of an object code library [58].
Reference: [47] <institution> Object Design, Inc. </institution> <note> ObjectStore PSE product description. Available from http://www.odi.com. </note>
Reference-contexts: The fact that SOS does not use a storage manager also makes it highly portable. Less portable approaches to generic persistence involve the use of virtual memory hardware to write and read persistent data. The Texas Persistent Object Store [55] and Ob-jectStore PSE product <ref> [47] </ref> use this approach. Both of these systems require that persistent objects are allocated with a specialized version of C++'s new operator. Using a specialized 26 new operator can require pervasive changes to an application to make objects persistent.
Reference: [48] <author> Ronald A. Olsson, Richard H. Crawford, W. Wilson Ho, and Christopher E. Wee. </author> <title> Sequential debugging at a high level of abstraction. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 27-36, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The descriptions in this chapter have focused on a scenario in which the debugging request language is modeled closely after the source language. In this way, existing translator specifications can be most fully utilized in specifying a debugger. Duel [24], Dalek <ref> [48] </ref>, and ACID [66] are examples of debuggers in which the debugging language has been extended with constructs aimed at providing greater expressibility for debugging but do not have direct analogs in the source language.
Reference: [49] <author> John Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: A better solution is for the new debugger to interface with the existing debugger as any user would. Assuming that the existing debugger has a line-mode interface, we can use a tool like Expect [45] to manage this interface. Expect is a tool that uses the Tcl scripting language <ref> [49] </ref> to allow programmed dialogue with interactive programs such as a line-mode debugger. Section 4.1 describes in greater detail how Expect can be used to control an existing debugger. This solution is much more flexible.
Reference: [50] <author> Vern Paxson. </author> <title> A survey of support for implementing debuggers. </title> <note> Available from ftp.ee.lbl.gov:papers/debugger-support.ps.Z., </note> <month> October </month> <year> 1990. </year>
Reference-contexts: Vern Paxson provides a good survey of debugging techniques in <ref> [50] </ref>, Mark Linton describes issues in the development of the commercial Dbx debugger in [46], and a document exists that describes the internals of the GNU debugger, gdb [51].
Reference: [51] <author> Robert Pizzi. </author> <title> GNU debugger internal architecture. </title> <institution> Department of Applied Science, University of California at Davis, Lawrence Livermore National Laboratory., </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Existing debuggers such as gdb <ref> [51] </ref> use Yacc to parse C expressions. These existing interactive processors typically use compiler generation tools more selectively to avoid dealing with some of the user input issues discussed in the last two sections. <p> Vern Paxson provides a good survey of debugging techniques in [50], Mark Linton describes issues in the development of the commercial Dbx debugger in [46], and a document exists that describes the internals of the GNU debugger, gdb <ref> [51] </ref>. Dynascope is a research project that undertook to provide a suite of debugging functionality with an architecture independent interface in the form of an object code library [58].
Reference: [52] <author> Michael L. Powell and Mark A. Linton. </author> <title> Database support for programming environments. </title> <type> Technical Report UCB:CSD-83-134, </type> <institution> University of California, Berkeley, </institution> <year> 1983. </year> <month> 79 </month>
Reference-contexts: Yet another approach is the use of schemas or interface definition languages (IDL's) to describe the data that is to be made persistent. Didriksen et al., discuss the use of IDL [64] as the data model for use in a programming environment database in [16]. Powell and Linton <ref> [52] </ref> describe the use of a relational database to support persistence of information in programming environments. Their approach requires specifying the persistent data types in a database schema language.
Reference: [53] <author> Norman Ramsey and Mary Fernandez. </author> <title> The New Jersey machine-code toolkit. </title> <booktitle> In Proceedings of the 1995 USENIX Technical Conference, </booktitle> <pages> pages 289-302, </pages> <address> New Or-leans, LA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Scanning and parsing are well understood tasks for which a wide variety of tools exist, while automated and portable machine code generation is not as well understood and is still the subject of considerable research <ref> [20, 53] </ref>. Existing techniques for the generation of programming support tools focus primarily on tools to generate interpreters. Examples of such systems are PSG [7] and Centaur [9]. Both use high-level specifications to generate interpreters and debuggers for the languages specified.
Reference: [54] <author> Thomas W. Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1989. </year>
Reference-contexts: For example, the PSG system [7] generates interactive environments that include a language-sensitive structure editor and interpreter from a set of specifications. The Synthesizer Generator <ref> [54, 60] </ref> and Centaur [9] both generate similar kinds of tools, but differ in the mechanisms used to produce these tools. One of the primary areas in which they differ is in the specification of dynamic semantics.
Reference: [55] <author> Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. </author> <title> Texas: An efficient, portable persistent store. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems, </booktitle> <month> September </month> <year> 1992. </year> <note> Available via anonymous ftp from cs.utexas.edu:pub/garbage. </note>
Reference-contexts: The fact that SOS does not use a storage manager also makes it highly portable. Less portable approaches to generic persistence involve the use of virtual memory hardware to write and read persistent data. The Texas Persistent Object Store <ref> [55] </ref> and Ob-jectStore PSE product [47] use this approach. Both of these systems require that persistent objects are allocated with a specialized version of C++'s new operator. Using a specialized 26 new operator can require pervasive changes to an application to make objects persistent.
Reference: [56] <author> Anthony M. Sloane. </author> <title> Execution monitoring for reusable software components. </title> <type> Technical Report CU-CS-677-93, </type> <institution> University of Colorado, </institution> <year> 1993. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: Furthermore, the run-time environment may not provide convenient methods for displaying such information, resulting in the need for additional code to be written solely for the purpose of displaying debugging information. Other approaches to debugging are event-based, in which the existing code is instrumented to generate events <ref> [56, 59] </ref>. Support can be provided for processing events for the purposes of visualization and execution control. The main drawback is the need to 2 instrument the source code with event generation code, consequently requiring recompilation when the user is interested in new information from the debugged program.
Reference: [57] <author> Anthony M. Sloane. </author> <title> An evaluation of an automatically generated compiler. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(5) </volume> <pages> 691-703, </pages> <month> Septem-ber </month> <year> 1995. </year>
Reference-contexts: Toolsets of this kind radically simplify the work of a programmer in constructing translators for new as well as existing languages. Using high-level specifications to specify components of the translator also results in more reliable and maintainable implementations without necessarily compromising performance <ref> [57] </ref>. These advantages, coupled with the proliferation of new languages and language extensions, have led to an increasing reliance on compiler generation tools, and this trend shows signs of continuing. <p> Today's compiler generation tools can significantly cut the time it takes to develop compiler implementations that can be competitive with hand-coded implementations <ref> [57] </ref>. Little attention has been paid to the generation of other components of a development environment. This thesis begins to address this void by demonstrating a framework for the rapid development of debuggers.
Reference: [58] <author> Rok Sosic. </author> <title> Design and implementation of Dynascope, a directing platform for compiled programs. </title> <journal> Computing Systems, </journal> <volume> 8(2) </volume> <pages> 107-134, </pages> <year> 1995. </year>
Reference-contexts: Dynascope is a research project that undertook to provide a suite of debugging functionality with an architecture independent interface in the form of an object code library <ref> [58] </ref>. The difficulty in using such a library for the purposes described in this thesis is that it provides a fixed set of functionality that cannot easily be extended.
Reference: [59] <author> Rok Sosic. </author> <title> A procedural interface for program directing. </title> <journal> Software-Practice and Experience, </journal> <volume> 25(7) </volume> <pages> 767-787, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Furthermore, the run-time environment may not provide convenient methods for displaying such information, resulting in the need for additional code to be written solely for the purpose of displaying debugging information. Other approaches to debugging are event-based, in which the existing code is instrumented to generate events <ref> [56, 59] </ref>. Support can be provided for processing events for the purposes of visualization and execution control. The main drawback is the need to 2 instrument the source code with event generation code, consequently requiring recompilation when the user is interested in new information from the debugged program.
Reference: [60] <author> Tim Teitelbaum and Thomas Reps. </author> <title> The Cornell Program Synthesizer: A syntax-directed programming environment. </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 563-573, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: For example, the PSG system [7] generates interactive environments that include a language-sensitive structure editor and interpreter from a set of specifications. The Synthesizer Generator <ref> [54, 60] </ref> and Centaur [9] both generate similar kinds of tools, but differ in the mechanisms used to produce these tools. One of the primary areas in which they differ is in the specification of dynamic semantics.
Reference: [61] <author> Christine L. Tsien. Maygen: </author> <title> A symbolic debugger generation system. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: The typical approach is to allow breakpoints to be set at specific nodes of the abstract syntax tree that correspond to source language constructs. Bahlke, Moritz, and Snelting [6] outline how this is done for PSG. A system called Maygen <ref> [61] </ref> provides a very different kind of support for generating debuggers. Maygen assumes the existence of components that implement a source language interface and a machine architecture interface. Using these components, Maygen manages a protocol between the two interfaces that results in a debugger.
Reference: [62] <author> William M. Waite. </author> <title> A complete specification of a simple compiler. </title> <type> Technical Report CU-CS-638-93, </type> <institution> University of Colorado, Boulder, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: The language is a subset of Pascal defined by Per Brinch Hansen [11] that I will refer to as Pascal-. One of the translations targets is an abstract stack-oriented machine defined by Brinch Hansen. A complete Eli specification for this translation can be found in <ref> [62] </ref>. The second translation targets assembly code for a Digital Alpha processor running the DEC OSF/1 operating system [17]. I wrote the Eli specification for this translation based on the specifications for the first translation.
Reference: [63] <author> William M. Waite and Basim M. Kadhim. </author> <title> A general property storage module. </title> <type> Technical Report CU-CS-786-95, </type> <institution> University of Colorado, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: for persistence in these components requires principles beyond the straightforward application of SOS described in the last section. 2.2.1 Persistence of a Definition Table The definition table interface in Eli consists of a fixed portion and one that is generated from a specification written in PDL (for Property Definition Language) <ref> [32, 63] </ref>. The fixed portion exports a type representing a definition table key, DefTableKey, an operation to create new instances of these keys, and a generic accessor function. The PDL language allows users to specify a set of properties, their types, and access operations (a default set is provided).
Reference: [64] <author> William B. Warren, Jerry Kickenson, and Richard Snodgrass. </author> <title> A tutorial introduction to using IDL. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(11) </volume> <pages> 18-34, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Yet another approach is the use of schemas or interface definition languages (IDL's) to describe the data that is to be made persistent. Didriksen et al., discuss the use of IDL <ref> [64] </ref> as the data model for use in a programming environment database in [16]. Powell and Linton [52] describe the use of a relational database to support persistence of information in programming environments. Their approach requires specifying the persistent data types in a database schema language.
Reference: [65] <author> Ross N. Williams. </author> <note> FunnelWeb User's Manual, May 1992. ftp://ftp.ross.net/clients/ross/funnelweb/funnelweb300/funnelweb 300.ps. </note>
Reference-contexts: The reason for the difference is that the translators compute some properties that are specific to a particular translation. The file persist.fw contains a variety of different Eli specification types. They can all be placed in the same file by using the FunnelWeb literate programming tool <ref> [65] </ref> that can generate any number of files from a single file. The @O directive indicates the generation of a new file whose contents are delimited by @f and @g.
Reference: [66] <author> Phil Winterbottom. </author> <title> ACID: A debugger built from a language. </title> <booktitle> In Proceedings of 80 the USENIX Winter Conference, </booktitle> <pages> pages 211-222. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1994. </year> <note> In San Francisco, </note> <institution> California. </institution>
Reference-contexts: The descriptions in this chapter have focused on a scenario in which the debugging request language is modeled closely after the source language. In this way, existing translator specifications can be most fully utilized in specifying a debugger. Duel [24], Dalek [48], and ACID <ref> [66] </ref> are examples of debuggers in which the debugging language has been extended with constructs aimed at providing greater expressibility for debugging but do not have direct analogs in the source language. The framework described by this thesis does not preclude the introduction of such constructs into the debugging language.
Reference: [67] <author> Alexander L. Wolf. </author> <title> The Persi persistent object system library. </title> <institution> University of Colorado, </institution> <note> available from author, </note> <year> 1993. </year>
Reference-contexts: the type CsmIndex is introduced for which it is possible to introduce the PDL persistence macros described in the last section that perform the index translation. 2.3 Related Work The SOS library described and used in this thesis is essentially a stripped-down version of the Persi Persistent Object System Library <ref> [67] </ref>. The complexity of the interface provided by Persi and its reliance on non-portable storage managers were the primary reasons for creating a simpler library. Features of Persi that complicate its interface include transaction management and the variety of policies it supports for object residency.
Reference: [68] <author> Andreas Zeller and Dorothea Lutkehaus. </author> <title> DDD a free graphical front-end for UNIX debuggers. </title> <journal> SIGPLAN Notices, </journal> <volume> 31(1), </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: The simplest form of this is a command-line interface, which reads a line typed by the user and provides a method for displaying lines of output. Considerable research has recently been devoted to the exploration of more user friendly interfaces to debugging <ref> [5, 28, 43, 68] </ref>. This particular avenue of research, however, is beyond the scope of this thesis. Many of the approaches to providing more complex user interfaces for debugging demonstrate the viability of either building a wrapper around or instrumenting an existing line mode debugger. <p> One is also limited to the set of platforms supported by the library. The approach taken in my framework bears some resemblance to the way debuggers like DEET [28] and DDD <ref> [68] </ref> are constructed. The goal for these debuggers is to provide a unique user interface to existing debuggers. DEET calls the code that wraps around an existing debugger, such as gdb, a "debug nub".
References-found: 68

