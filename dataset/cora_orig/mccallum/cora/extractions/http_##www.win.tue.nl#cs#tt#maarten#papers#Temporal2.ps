URL: http://www.win.tue.nl/cs/tt/maarten/papers/Temporal2.ps
Refering-URL: http://www.win.tue.nl/cs/tt/maarten/
Root-URL: http://www.win.tue.nl
Email: maarten@win.tue.nl,  
Phone: Fax +31-40-2468508  
Title: A Transaction-Based Temporal Data Model that supports prediction in Real-Time Databases  
Author: M.P. Bodlaender, P.D.V. .v.d. Stok 
Note: An implementation of a hard-realtime database that realizes these requirements is given, to show that the specified requirements are realistic.  
Address: P.O. Box 513, 5600 Eindhoven, The Netherlands  
Affiliation: Technical University Eindhoven, Fac. Mathematics Computing Science  
Abstract: We propose database support for large sets of temporal, real-time data. Prediction models are supported: transactions can write data items to the database that have been measured in the future. Therefore, it is necessary to allow multiple instances of the same data item, with different times of measurement. This requires larger storage requirements, but can also be used for interpolation of intermediate values, and extrapolation of future values. It is recognized that temporal correctness of data is a characteristic of the usage of the data item. Real-time data requirements are specified for each individual transaction, rather than for each data item. Transactions can access multiple instances of the same data item (for extrapolation purposes), and can specify separate temporal constraints for each accessed instance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Adelberg, B. Kao, and H. Garcia-Molina. </author> <title> Database support for efficiently maintained derived data. </title> <address> EDBT, </address> <year> 1996. </year>
Reference-contexts: Minimum age requirements ensure that transactions T do not act too soon, because the data read by T is too fresh. Suppose X:n 2 T:IN . For each instance x i (i 2 <ref> [1; n] </ref>), transaction T can specify that the age of x i should be in some interval [a; b]. <p> Transaction T can specify upper and lower bounds on the difference in age between instances that it reads. Suppose X : n; Y : m 2 T:IN . For each pair x i ; y j (i 2 <ref> [1; n] </ref>; j 2 [1; m]) transaction T can specify that the difference in age should lie within an interval [a; b]. <p> Transaction T can specify upper and lower bounds on the difference in age between instances that it reads. Suppose X : n; Y : m 2 T:IN . For each pair x i ; y j (i 2 [1; n]; j 2 <ref> [1; m] </ref>) transaction T can specify that the difference in age should lie within an interval [a; b]. <p> A straightforward always-fresh approach is used to ensure that all temporal requirements of all transactions can always be met. Rate-monotonic implementation and analysis is possible. (alternatively, less computation-intensive on demand approaches are possible, see <ref> [1] </ref>). Rate-monotonic scheduling ([6]) expects as input a set of requirements on the period and deadline of periodic tasks: P T + D T T : We map the temporal requirements to requirements of this form, such that the system can be scheduled with rate-monotonic scheduling.
Reference: [2] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings. </author> <title> Absolute and relative temporal constraints in hard real-time databases. </title> <booktitle> Proc. of the Fourth Euromicro Workshop on Real-time systems, </booktitle> <year> 1992. </year>
Reference-contexts: 1 Introduction & Related work Several research projects on real-time databases exist. They are motivated by the wish to handle large quantities of data, in a structural way. Important in this context is the temporal data model that is used. The temporal data model in <ref> [2] </ref> distinguishes between temporal and non-temporal data. By requiring the single-writer property, Audsley, et.al. achieve a reduction in complexity. Temporal data models of [2, 4, 10] assign Temporal validity intervals for each instance of a temporal item. Instances are only valid within their validity intervals. <p> Important in this context is the temporal data model that is used. The temporal data model in [2] distinguishes between temporal and non-temporal data. By requiring the single-writer property, Audsley, et.al. achieve a reduction in complexity. Temporal data models of <ref> [2, 4, 10] </ref> assign Temporal validity intervals for each instance of a temporal item. Instances are only valid within their validity intervals. <p> Transactions that read data can specify an import-limit on the amount of inconsistency allowed. Validity is a characteristic of transactions that access the data, rather than of the data itself. Our model does not associate the temporal requirements with data items (which has been done in <ref> [2, 4] </ref>), but associates the requirements with transactions. The model generalizes the transaction-based model from [3]. It is extended with minimum age requirements, as maximum age requirements do not suffice in systems that use prediction models.
Reference: [3] <author> M. Bodlaender, P. v.d. Stok, and S. Son. </author> <title> A transaction-based temporal data model for real-time databases. </title> <note> to appear in conference proceedings WPDRTS'97, </note> <year> 1997. </year>
Reference-contexts: Validity is a characteristic of transactions that access the data, rather than of the data itself. Our model does not associate the temporal requirements with data items (which has been done in [2, 4]), but associates the requirements with transactions. The model generalizes the transaction-based model from <ref> [3] </ref>. It is extended with minimum age requirements, as maximum age requirements do not suffice in systems that use prediction models. This leads to a whole set of adaptations, most notably the change to a multi-version database. <p> Requirement Description P M1 + D M1 100 Poll sensor P E1 + D E1 50 Extrapolation age (p) 3050 Remove old p age (f ) 6900 Remove old p 8 Conclusions and further work The model presented in this paper enhances the model from <ref> [3] </ref> such that prediction models can be supported. More general temporal constraints can be specified, which makes it possible to specify more systems using this model. The always fresh implementation that accompanies the model shows that efficient implementations of systems, specified in the model, actually exist.
Reference: [4] <author> Y.-K. Kim and S. H. Son. </author> <title> Supporting predictability in real-time database systems. </title> <booktitle> IEEE Real-Time Technology and Applications Symposium (RTAS'96), </booktitle> <pages> pp 38-48, </pages> <year> 1996. </year>
Reference-contexts: Important in this context is the temporal data model that is used. The temporal data model in [2] distinguishes between temporal and non-temporal data. By requiring the single-writer property, Audsley, et.al. achieve a reduction in complexity. Temporal data models of <ref> [2, 4, 10] </ref> assign Temporal validity intervals for each instance of a temporal item. Instances are only valid within their validity intervals. <p> Transactions that read data can specify an import-limit on the amount of inconsistency allowed. Validity is a characteristic of transactions that access the data, rather than of the data itself. Our model does not associate the temporal requirements with data items (which has been done in <ref> [2, 4] </ref>), but associates the requirements with transactions. The model generalizes the transaction-based model from [3]. It is extended with minimum age requirements, as maximum age requirements do not suffice in systems that use prediction models.
Reference: [5] <author> T.-W. Kuo and A. Mok. </author> <title> Ssp: a semantics-based protocol for real-time data access. </title> <booktitle> Proceedings 14th real-time systems symposium, </booktitle> <year> 1993. </year>
Reference-contexts: Instances are only valid within their validity intervals. When the validity expires, a new instance (with a new value) should be created. fl This work is part of STW project EIF33.3129 Kuo and Mok present view -similarity <ref> [5] </ref> as a solution to the NP-complete functional correctness scheduling problem. A similarity bound is specified for each data item. Normal serializability is replaced by a weaker variant.
Reference: [6] <author> C. Liu and J. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 20, No 1, </volume> <pages> pp 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference: [7] <author> K. Ramamritham and C. Pu. </author> <title> A formal characterization of epsilon serializability. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> vol. 7, no 6, </volume> <pages> pp 997-1007, </pages> <year> 1995. </year>
Reference-contexts: The rationale for this approach is that instances created at roughly the same time, are similar enough to be treated as the same. Epsilon serializability <ref> [7] </ref> is also directed at weakening the serializability constraint. Data items can be read, although their value is inconsistent. The amount of inconsistency is defined as the distance to a consistent state. Transactions that read data can specify an import-limit on the amount of inconsistency allowed.
Reference: [8] <author> K. Vidyasankar. </author> <title> A simple characterization of database seri-alizability. </title> <booktitle> 5th conf. on foundations of software technology and theoretical computer science, LNCS 206, </booktitle> <year> 1985. </year>
Reference-contexts: Exactly one refresh transaction has to be provided for each temporal data item (note that one refresh transaction can refresh more than one item). Since the database itself can determine when these refresh transactions are executed, serializing these transactions is easy. This removes the need for complex serializability constraints <ref> [8, 9] </ref>. We assume that there exists a global clock o now that applications use to specify their real-time requirements, and that the database can use to satisfy them. 3 A multi-version real-time database model with temporal data The database consists of a set of data items.
Reference: [9] <author> K. Vidyasankar. </author> <title> Unified theory of database serializability. </title> <note> Fundamenta Informaticae XIV, </note> <year> 1991. </year>
Reference-contexts: Exactly one refresh transaction has to be provided for each temporal data item (note that one refresh transaction can refresh more than one item). Since the database itself can determine when these refresh transactions are executed, serializing these transactions is easy. This removes the need for complex serializability constraints <ref> [8, 9] </ref>. We assume that there exists a global clock o now that applications use to specify their real-time requirements, and that the database can use to satisfy them. 3 A multi-version real-time database model with temporal data The database consists of a set of data items.
Reference: [10] <author> M. Xiong, J. Stankovic, K. Ramamritham, D. Towsley, and R. Sivasankaran. </author> <title> Maintaining temporal consistency: Issues and algorithms. </title> <booktitle> Proc. of the First International Workshop on Real-Time Databases: Issues and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: Important in this context is the temporal data model that is used. The temporal data model in [2] distinguishes between temporal and non-temporal data. By requiring the single-writer property, Audsley, et.al. achieve a reduction in complexity. Temporal data models of <ref> [2, 4, 10] </ref> assign Temporal validity intervals for each instance of a temporal item. Instances are only valid within their validity intervals.
References-found: 10

