URL: http://www.isi.edu/acal/tech-reports/1994/tr-94-01.ps.Z
Refering-URL: http://www.isi.edu/acal/tech-reports/index.html
Root-URL: http://www.isi.edu
Title: Low Power Architecture Design and Compilation Techniques forHigh-Performance Processors  
Author: Ching-Long Su, Chi-Ying Tsui, Alvin M. Despain 
Keyword: Gray Code, Low Power Design, Memory Addressing, Instruction Scheduling  
Note: 1994  
Date: February 15,  
Address: ACAL-TR-94-01  
Affiliation: Advanced Computer Architecture Laboratory  
Abstract: Reducing switching activity would significantly reduce power consumption of a processor chip. In this paper, we present two novel techniques, Gray code addressing and Cold scheduling, for reducing switching activity on high performance processors. We use Gray code which has only one-bit different in conseuctive number for addressing. Due to locality of program execution, Gray code addressing can significantly reduce the number of bit switches. Experimental results show that for typical programs running on a RISC microprocessor, using Gray code addressing reduce the switching activity at the address lines by 30~50% compared to using normal binary code addressing. Cold scheduling is a software method which schedules instructions in a way that switching activity is minimized. We carried out experiments with cold scheduling on the VLSI-BAM. Preliminary results show that switching activity in the control path is reduced by 20-30%. 
Abstract-found: 1
Intro-found: 1
Reference: [Bradlee 91] <author> D.G. Bradlee, S.J. Eggers, and R.R. Henry, </author> <title> Integrating Register Allocation and Instruction Scheduling for RISCs, </title> <booktitle> the 4th International Conference on Architectural Support for Programming Languages and Operating System, </booktitle> <year> 1991. </year>
Reference-contexts: Instruction scheduling preceding assembly may degrade the impact of reducing bit switches between instructions. However, when assembly precedes instruction scheduling, the exibility of instruction scheduling is limited. A similar problem is the phase problem between instruction scheduling and register allocation <ref> [Bradlee 91] </ref>, where instruction scheduling preceding register allocation may increase register pressure and instruction scheduling following register allocation may introduce false dependencies. A simple solution to deal with the phase problem of instruction scheduling and assembly is to derive or guess binary representations of instructions before instruction scheduling.
Reference: [Bernstein 91] <author> D. Bernstein, and M. Rodeh. </author> <title> Global Instruction Scheduling for Superscalar Machines, </title> <booktitle> Proc. of the ACM Performance degradation (%) fastqueens qsort reducer circuit semigroup nand boyer browse chat 2 4 6 8 3.7 3.6 3.7 2.0 2.7 SIGPLAN 91 Conf. on Programming Language Design and Implementation, </booktitle> <month> June. </month> <year> 1991. </year>
Reference-contexts: Cold Scheduling Traditional instruction scheduling algorithms mainly focus on reordering instructions to reduce pipeline stalls, avoid pipeline hazards, or improve resource usage. More recent instruction scheduling algorithms such as trace scheduling [Fisher 81], percolation scheduling [Nicolau 84], and global scheduling <ref> [Bernstein 91] </ref> schedule instructions across basic blocks in order to increase instruction-level parallelism. The main goal of these scheduling algorithms is to improve performance. To reduce power consumption, these instruction scheduling algorithms need to be modified to adjust to the new objective.
Reference: [Chandra 92] <author> A.P. Chandrakasan, S. Sheng and R.W. Brod-ersen, </author> <title> Low-power CMOS digital design, </title> <journal> IEEE J. Solid-State Circuits, </journal> <volume> Vol. 27, No4, </volume> <year> 1992. </year>
Reference-contexts: Many researchers have been studying low power/ low voltage design techniques. For example, research is being conducted in low power DRAM and SRAM design. Also aggressive supply voltage scaling and process optimization are used for power consumption reduction for active logic circuits <ref> [Chandra 92] </ref>,[Liu 93]. However, lowering the supply voltage may create other design problems such as reduced noise margin, increased cross talk, etc. Other researchers are exploring instruction set architectures and novel memory management schemes for low power, processor design using self-clocking, static and dynamic power management strategies, etc.
Reference: [Fisher 81] <author> J.A. Fisher. </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 30, No. 7, </volume> <year> 1981. </year>
Reference-contexts: Cold Scheduling Traditional instruction scheduling algorithms mainly focus on reordering instructions to reduce pipeline stalls, avoid pipeline hazards, or improve resource usage. More recent instruction scheduling algorithms such as trace scheduling <ref> [Fisher 81] </ref>, percolation scheduling [Nicolau 84], and global scheduling [Bernstein 91] schedule instructions across basic blocks in order to increase instruction-level parallelism. The main goal of these scheduling algorithms is to improve performance.
Reference: [Ghosh 92] <author> A. Ghosh, S. Devadas, K. Keutzer, and J. White, </author> <title> Estimation of Average Switching Activity in Combinational and Sequential Circuit, </title> <booktitle> the 29th DAC, </booktitle> <year> 1992. </year>
Reference-contexts: To support this claim, we carried out experiments on a set of combinational circuit benchmarks obtained from the ISCAS-89 and MCNC-91 benchmark set, and studied the effect on the circuit switching activities if the switching activities at the input lines are reduced. We used the estimation method in <ref> [Ghosh 92] </ref> to estimate the Combina latch A latch B Circuit tional switching activities. Switching activities are measured as the expected numbers of switching per cycle. First the switching activity of each input is set to 0.5 (Model I).
Reference: [Haygood 89] <author> Haygood, </author> <title> A Prolog Benchmark Suite for Aquarius, </title> <type> Technical Report, </type> <institution> Computer Science Department, University of California, </institution> <address> UCB/CSD 89/509, </address> <year> 1989. </year>
Reference-contexts: Benchmark programs used in this paper are shown in Table 2. The benchmarks are ranging from less than 1,000 cycles to larger than 10,000,000 cycles. These benchmark programs are selected from the Aquarius benchmark suite <ref> [Haygood 89] </ref>. Applications of these benchmark programs include list manipulation, data base query, theorem prover, and computer language parser. Benchmark programs are first compiled through the Aquarius Prolog compiler [Van Roy 92] into an intermediate code (BAM code), which is target machine independent.
Reference: [Hayes 88] <author> J.P. Hayes, </author> <title> Computer Architecture And Organization, </title> <publisher> McGraw-Hill Int. Editions, </publisher> <year> 1988. </year>
Reference-contexts: A formal definition of a Gray code sequence is described as follows <ref> [Hayes 88] </ref>, 1. G 1 = 0, 1. 2. Let G k = g 0 , g 1 ,..., g 2 k -2, g 2 k -1 .
Reference: [Holmer 90] <author> B. Holmer, B. Sano, M. Carlton, P. Van Roy, R. Haygood, W. Bush, and A. Despain. </author> <title> Fast Prolog with an Extended General Purpose Architecture, </title> <booktitle> the 17th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: To better understand the impact of instruction sequence on the switching activities in general purpose processors, we select a RISC-like processor, the VLSI-BAM <ref> [Holmer 90] </ref>, as an experimental architecture. This microprocessor is pipelined with data stationally control. There are five pipeline stages: Instruction Fetch (IF), Instruction Decode (ID), Instruction Execution (IE), Memory access (M), and Write Back (WB). <p> program counter is &lt;01001&gt; g , the target address of this branch instruction is then &lt;11111&gt; g , which is the binary addition of &lt;01001&gt; g and &lt;10110&gt; g . 3.6 Results To validate the advantage of Gray code addressing, we implement a Gray code addressing scheme on the VLSI-BAM <ref> [Holmer 90] </ref>. Table 5 summarizes the switching activity at the address bits of the processor. For instruction accesses, compared to the traditional binary code addressing scheme, Gray code addressing significantly reduces the address bits switching activities. For data accesses, switching activity resulting from both schemes are quite close.
Reference: [Hwu 92] <author> W.W. Hwu and P.P. Chang, </author> <title> Efficient Instruction Sequencing with Inlining Target Insertion, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 41, No.12, </volume> <month> Dec. </month> <year> 1992. </year>
Reference: [Jouppi 89a] <author> N.P. Jouppi, and D.W. Wall. </author> <title> Available Instruction-Level Parallelism for Superscalar and Superpipe-lined Machines, </title> <booktitle> the 3rd International Conference on Architectural Support for Programming Languages and Operating System, </booktitle> <year> 1989. </year>
Reference: [Liu 93] <author> D. Liu, and C. Svensson, </author> <title> Trading Speed for Low Power by Choice of Supply and Threshold Voltages, </title> <journal> IEEE J. of Solid State Circuits, </journal> <volume> Vol. 28, No. 1, </volume> <year> 1993. </year>
Reference: [MIPS 86] <institution> MIPS language programmers guide, MIPS Computer Systems, Inc., </institution> <year> 1986 </year>
Reference-contexts: This microprocessor is pipelined with data stationally control. There are five pipeline stages: Instruction Fetch (IF), Instruction Decode (ID), Instruction Execution (IE), Memory access (M), and Write Back (WB). The instruction set of the VLSI-BAM is similar to the MIPS-2000 <ref> [MIPS 86] </ref> with some extensions for symbolic computation. Figure 2 shows the pipeline stages and the control path of the VLSI-BAM processor. For each pipeline stage, there is an instruction register, a PLA, and a latch for control signals.
Reference: [Nicolau 84] <author> A. Nicolau, J.A. Fisher, </author> <title> Measuring the Parallelism Available for Very Long Instruction Word Architectures, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 33, No. 11, </volume> <year> 1984. </year>
Reference-contexts: Cold Scheduling Traditional instruction scheduling algorithms mainly focus on reordering instructions to reduce pipeline stalls, avoid pipeline hazards, or improve resource usage. More recent instruction scheduling algorithms such as trace scheduling [Fisher 81], percolation scheduling <ref> [Nicolau 84] </ref>, and global scheduling [Bernstein 91] schedule instructions across basic blocks in order to increase instruction-level parallelism. The main goal of these scheduling algorithms is to improve performance. To reduce power consumption, these instruction scheduling algorithms need to be modified to adjust to the new objective.
Reference: [Prasad 93] <author> S. Prasad and K. Roy, </author> <title> Circuit activity driven multilevel logic optimization for low power reliable operation, </title> <type> EDAC, </type> <month> February, </month> <year> 1993. </year>
Reference-contexts: In the logic level, algorithms to synthesize circuits with minimum switching activities has been developed. Shen et al [Shen 92] present algorithms for reducing power consumption during the technology independent phase of logic synthesis. Prasad et al. <ref> [Prasad 93] </ref> tackle the low power kernelization problem in multi-level logic minimization.
Reference: [Roy 92] <author> K. Roy and S. Parsad, SYSLOP: </author> <title> Synthesis of CMOS logic for low power application, </title> <booktitle> ICCD, </booktitle> <month> October, </month> <year> 1992. </year>
Reference: [Shen 92] <author> A. Shen, A. Ghosh and S. </author> <title> Devadas,On Average Power Dissipation and Random Pattern Testability of CMOS Combinational Logic Networks, </title> <journal> IEEE ICCAD,Nov, </journal> <year> 1993. </year>
Reference-contexts: In the logic level, algorithms to synthesize circuits with minimum switching activities has been developed. Shen et al <ref> [Shen 92] </ref> present algorithms for reducing power consumption during the technology independent phase of logic synthesis. Prasad et al. [Prasad 93] tackle the low power kernelization problem in multi-level logic minimization.
Reference: [Su 92] <author> C.L. Su, </author> <title> An instruction Scheduler and Register Allocator for Prolog Parallel Microprocessors, </title> <booktitle> International Computer Symposium, </booktitle> <year> 1992. </year>
Reference: [Tsui 93] <author> C.Y. Tsui, M. Pedram, and A.M. Despain, </author> <title> Technology Decomposition and Mapping Targeting Low Power Dissipation, </title> <booktitle> the 30th DAC, </booktitle> <year> 1993. </year>
Reference: [Vaishnav 93] <author> H. Vaishnav and M. Pedram, Pcube: </author> <title> A Performance driven placement algorithm for low power designs, </title> <publisher> EURO-DAC, September,1993. </publisher>
Reference: [Van Roy 92] <author> P. Van Roy and A. M. Despain, </author> <title> High-Performance Logic Programming with the Aquarius Prolog Compiler, </title> <booktitle> Computer, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: These benchmark programs are selected from the Aquarius benchmark suite [Haygood 89]. Applications of these benchmark programs include list manipulation, data base query, theorem prover, and computer language parser. Benchmark programs are first compiled through the Aquarius Prolog compiler <ref> [Van Roy 92] </ref> into an intermediate code (BAM code), which is target machine independent. The BAM code is then further compiled into machine code of the target machine, the VLSI-BAM. 3. Gray Code Addressing In traditional von Neumann machines, data is fetched from memory before executed.
Reference: [Weste 93] <author> Neil H.E.Weste and K. Esharaghian, </author> <title> Principles of CMOS VLSI Design, A Systems Perspective, </title> <publisher> Addison Edition 1993. </publisher>
References-found: 21

