URL: ftp://ftp.cs.umass.edu/pub/osl/papers/pldi98live.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Email: ole.agesen@sun.com, david.detlefs@sun.com  moss@cs.umass.edu  
Title: Garbage Collection and Local Variable Type-Precision and Liveness in Java TM Virtual Machines  
Author: Ole Agesen and David Detlefs J. Eliot B. Moss 
Address: 2 Elizabeth Drive Chelmsford, MA 01824, USA  Amherst, MA 01003-4610, USA  
Affiliation: Sun Microsystems Laboratories  Department of Computer Science University of Massachusetts  
Abstract: Full precision in garbage collection implies retaining only those heap allocated objects that will actually be used in the future. Since full precision is not computable in general, garbage collectors use safe (i.e., conservative) approximations such as reach-ability from a set of root references. Ambiguous roots collectors (commonly called conservative) can be overly conservative because they overestimate the root set, and thereby retain unexpectedly large amounts of garbage. We consider two more precise collection schemes for Java virtual machines (JVMs). One uses a type analysis to obtain a type-precise root set (only those variables that contain references); the other adds a live variable analysis to reduce the root set to only the live reference variables. Even with the Java programming language's strong typing, it turns out that the JVM specification has a feature that makes type-precise root sets difficult to compute. We explain the problem and ways in which it can be solved. Our experimental results include measurements of the costs of the type and liveness analyses at load time, of the incremental benefits at run time of the liveness analysis over the type analysis alone, and of various map sizes and counts. We find that the liveness analysis often produces little or no improvement in heap size, sometimes modest improvements, and occasionally the improvement is dramatic. While further study is in order, we conclude that the main benefit of the liveness analysis is preventing bad surprises. 
Abstract-found: 1
Intro-found: 1
Reference: [Aditya et al., 1994] <author> Shail Aditya, Christine Flood, and James Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In [LFP, </booktitle> <year> 1994], </year> <pages> pp. 1223. </pages>
Reference-contexts: Aditya, et al. compared, in the context of the polymorphic functional language Id, the cost of type-reconstruction-based collection and conservative collection <ref> [Aditya et al., 1994] </ref>, and found that run-time type reconstruction can have a significant impact. Tolmach [Tolmach, 1994] and Tarditi, et al. [Tarditi et al., 1996] describe schemes that represent the polymorphic type parameters more explicitly, potentially at run time, but frequently optimized away.
Reference: [Agesen & Detlefs, 1997] <author> Ole Agesen and David Detlefs. </author> <title> Finding references in Java stacks. </title> <type> Tech. Rep. </type> <institution> SML-E-97-67, Sun Microsystems Laboratories, Chelmsford, </institution> <address> MA, USA, </address> <month> Oct. </month> <year> 1997. </year> <booktitle> Presented at the OOPSLA '97 workshop on garbage collection. </booktitle>
Reference-contexts: Our contributions: From this overview of related work, we conclude that our primary contribution lies in reporting measurements of the impact of liveness analysis for a procedural object-oriented language. We previously reported in more detail on the difficulties in producing stack maps for Java bytecode <ref> [Agesen & Detlefs, 1997] </ref>, and summarize that work here, extending it with the liveness analysis. 3 Stack maps and gc points The contents of a stack slot can change during the execution of a Java method. Slots, with the exception of those occupied by arguments to the method, start uninitialized.
Reference: [Agesen et al., 1997] <author> Ole Agesen, Stephen Freund, and John C. Mitchell. </author> <title> Adding type parameterization to Java. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA-97) (New York, Oct.59 1997), </booktitle> <volume> vol. 32, </volume> <booktitle> 10 of ACM SIGPLAN Notices, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 4965. </pages>
Reference-contexts: If these were implemented with shared code bodies, then some of the same stack map generation issues would arise as do with Standard ML polymorphic functions <ref> [Agesen et al., 1997] </ref>.
Reference: [Appel, 1989] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <booktitle> Lisp and Symbolic Computation 2 (1989), </booktitle> <pages> 153162. </pages>
Reference-contexts: Tagless collection goes back at least to Branquart and Lewi's [Branquart & Lewi, 1971] and Wodon's [Wodon, 1971] collectors for Algol68 and Britton's [Britton, 1975] for Pascal. Branquart and Lewi's collector is notable in that it updated tables at run time as stack slot contents changed. More recently Appel <ref> [Appel, 1989] </ref> and Goldberg [Goldberg, 1991] considered tagless collection for Standard ML, which is complicated by the presence of polymorphic functions, where the types of their arguments vary from call to call.
Reference: [Appel, 1992] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992, </year> <journal> ch. </journal> <volume> 16, </volume> <pages> pp. </pages> <year> 205214. </year>
Reference-contexts: We are concerned only with whether references in local variables will be used again, which is a weaker property. 2 Some schemes are more similar to our liveness analysis. For ex-ample, Appel described a continuation-passing style compiler for Standard ML <ref> [Appel, 1992] </ref>, which effectively removed dead variables from closures.
Reference: [Appel & Hanson, 1988] <author> Andrew W. Appel and David R. Hanson. </author> <title> Copying garbage collection in the presence of ambiguous references. </title> <type> Tech. Rep. </type> <institution> CS-TR-162-88, Princeton University, </institution> <year> 1988. </year>
Reference: [Baker, 1990] <author> Henry G. Baker. </author> <title> Unify and conquer (garbage, updating, aliasing, </title> . . . ) <booktitle> in functional languages. In Conference Record of the 1990 ACM Symposium on Lisp and Functional Programming (Nice, </booktitle> <address> France, June 1990), </address> <publisher> ACM Press, </publisher> <pages> pp. 218226. </pages>
Reference-contexts: Baker discussed the general idea of using Hindley-Milner unification in this way a bit earlier <ref> [Baker, 1990] </ref>. A little later, Fradet [Fradet, 1994] extended this sort of collector to include a certain kind of liveness information, based on the intuitive idea that if a polymorphic function does not depend on a type parameter, then it could not actually use any data items of that type.
Reference: [Barth, 1977] <author> Jeffrey M. Barth. </author> <title> Shifting garbage collection overhead to compile time. </title> <journal> Communications of the ACM 20, </journal> <month> 7 (July </month> <year> 1977), </year> <pages> 513518. 9 </pages>
Reference: [Bartlett, 1988] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Tech. Rep. 88/2, </type> <institution> DEC Western Research Laboratory, </institution> <address> Palo Alto, CA, </address> <month> Feb. </month> <year> 1988. </year> <note> Also in Lisp Pointers 1, 6 (AprilJune 1988), pp. 212. </note>
Reference: [Bartlett, 1989] <author> Joel F. Bartlett. </author> <title> Mostly-Copying garbage collection picks up generations and C++. </title> <type> Technical note, </type> <institution> DEC Western Research Laboratory, </institution> <address> Palo Alto, CA, </address> <month> Oct. </month> <year> 1989. </year> <note> Sources available in ftp://gatekeeper.dec.com/pub/DEC/CCgc. </note>
Reference: [Boehm, 1991] <author> Hans-Juergen Boehm. </author> <title> Simple GC-safe compilation. </title> <booktitle> In OOPSLA/ECOOP '91 Workshop on Garbage Collection in Object-Oriented Systems (Oct. </booktitle> <year> 1991), </year> <editor> Paul R. Wilson and Barry Hayes, </editor> <publisher> Eds. </publisher>
Reference-contexts: They also considered how stack maps might be compressed to save space. A related topic is ensuring that compiler optimizations will not effectively hide live pointers from a collector, and has been considered by Boehm and Chase (at least), separately and together <ref> [Chase, 1988; Boehm, 1991; Boehm & Chase, 1992; Boehm, 1996] </ref>. The relatively simple and highly constrained model of references presented by the JVM avoids the optimization-induced problems these other works address, such as interior and derived pointers.
Reference: [Boehm, 1993] <author> Hans-Juergen Boehm. </author> <title> Space efficient conservative garbage collection. </title> <booktitle> In Proceedings of SIGPLAN'93 Conference on Programming Languages Design and Implementation (Albuquerque, </booktitle> <address> New Mexico, </address> <month> June </month> <year> 1993), </year> <title> vol. </title> <booktitle> 28(6) of ACM SIGPLAN Notices, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. </pages> <year> 197206. </year>
Reference-contexts: However, once one considers generating native code from Java bytecode, the optimization issues may arise. In other work, Boehm and Shao considered how to construct a useful conservative approximation of object type information at run time for a conservative collector <ref> [Boehm, 1993] </ref>. Finally, Thomas, with Jones, built routines for tracing stack frames, moving from an interpretive to a compiled model for stack maps [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995].
Reference: [Boehm, 1996] <author> Hans-Juergen Boehm. </author> <title> Simple garbage-collector safety. </title> <booktitle> In [PLDI, </booktitle> <year> 1996], </year> <pages> pp. 8998. </pages>
Reference-contexts: They also considered how stack maps might be compressed to save space. A related topic is ensuring that compiler optimizations will not effectively hide live pointers from a collector, and has been considered by Boehm and Chase (at least), separately and together <ref> [Chase, 1988; Boehm, 1991; Boehm & Chase, 1992; Boehm, 1996] </ref>. The relatively simple and highly constrained model of references presented by the JVM avoids the optimization-induced problems these other works address, such as interior and derived pointers.
Reference: [Boehm & Chase, 1992] <author> Hans-Juergen Boehm and David R. Chase. </author> <title> A proposal for garbage-collector-safe C compilation. </title> <journal> Journal of C Language Translation (1992), </journal> <volume> 126141. </volume>
Reference-contexts: They also considered how stack maps might be compressed to save space. A related topic is ensuring that compiler optimizations will not effectively hide live pointers from a collector, and has been considered by Boehm and Chase (at least), separately and together <ref> [Chase, 1988; Boehm, 1991; Boehm & Chase, 1992; Boehm, 1996] </ref>. The relatively simple and highly constrained model of references presented by the JVM avoids the optimization-induced problems these other works address, such as interior and derived pointers.
Reference: [Boehm & Shao, 1993] <author> Hans-Juergen Boehm and Zhong Shao. </author> <title> Inferring type maps during garbage collection. In OOPSLA/ECOOP '93 Workshop on Garbage Collection in Object-Oriented Systems (Oct. </title> <note> 1993), </note> <author> Eliot Moss, Paul R. Wilson, and Benjamin Zorn, </author> <title> Eds. </title>
Reference: [Boehm & Weiser, 1988] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience 18, </journal> <volume> 9 (1988), </volume> <pages> 807820. </pages>
Reference: [Branquart & Lewi, 1971] <author> P. Branquart and J. Lewi. </author> <title> A scheme of storage allocation and garbage collection for Algol68. </title> <editor> In [Peck, </editor> <year> 1971], </year> <pages> pp. </pages> <year> 198238. </year>
Reference-contexts: Tagless collection goes back at least to Branquart and Lewi's <ref> [Branquart & Lewi, 1971] </ref> and Wodon's [Wodon, 1971] collectors for Algol68 and Britton's [Britton, 1975] for Pascal. Branquart and Lewi's collector is notable in that it updated tables at run time as stack slot contents changed.
Reference: [Britton, 1975] <author> Dianne Ellen Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: Tagless collection goes back at least to Branquart and Lewi's [Branquart & Lewi, 1971] and Wodon's [Wodon, 1971] collectors for Algol68 and Britton's <ref> [Britton, 1975] </ref> for Pascal. Branquart and Lewi's collector is notable in that it updated tables at run time as stack slot contents changed.
Reference: [Bruynooghe, 1987] <author> Maurice Bruynooghe. </author> <title> Compile-time garbage collection or How to transform programs in an assignment-free language into code with assignments. In Program specification and transformation. </title> <booktitle> The IFIP TC2/WG 2.1 Working Conference, </booktitle> <address> Bad Tolz, </address> <publisher> Germany, </publisher> <editor> L. G. L. T. Meertens, Ed. </editor> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <month> April 1517, </month> <year> 1986 1987, </year> <pages> pp. 113129. </pages>
Reference: [Chase, 1997] <author> David Chase, </author> <month> Nov. </month> <year> 1997. </year> <type> Personal communication. </type>
Reference-contexts: Again, we do not claim that the idea of using liveness information is new. However, we found no reports of its use for procedural or object-oriented languages (other than an indication that Chase has built a collector similar to ours for a JVM <ref> [Chase, 1997] </ref>). On the other hand, it has likely been done before but simply not reported. Most significantly, we have found no previous measurement of the impact of live variable analysis, only anecdotal discussions in the context of functional languages, which leads us to the topic of experimental results.
Reference: [Chase, 1987] <author> David R. Chase. </author> <title> Garbage collection and other optimizations. </title> <type> Tech. rep., </type> <institution> Rice University, </institution> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: The 12 David Chase brought this to our attention; he mentions the possibility in passing in his dissertation <ref> [Chase, 1987] </ref>. programs we measured are a collection of benchmarks under consideration for a SPEC suite to measure Java platforms. 13 We had to exclude four of the programs because thread-library issues prevented us from running them correctly; we excluded two more because they allocated too little storage to be interesting
Reference: [Chase, 1988] <author> David R. Chase. </author> <title> Safety considerations for storage allocation optimizations. </title> <journal> ACM SIGPLAN Notices 23, </journal> <volume> 7 (1988), </volume> <pages> 110. </pages>
Reference-contexts: They also considered how stack maps might be compressed to save space. A related topic is ensuring that compiler optimizations will not effectively hide live pointers from a collector, and has been considered by Boehm and Chase (at least), separately and together <ref> [Chase, 1988; Boehm, 1991; Boehm & Chase, 1992; Boehm, 1996] </ref>. The relatively simple and highly constrained model of references presented by the JVM avoids the optimization-induced problems these other works address, such as interior and derived pointers.
Reference: [Chase et al., 1990] <author> David R. Chase, Wegman, and Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> ACM SIGPLAN Notices 25, </journal> <month> 6 </month> <year> (1990). </year>
Reference: [Deutsch, 1990] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages (San Francisco, </booktitle> <address> CA, </address> <month> Jan. </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices, ACM Press, </journal> <pages> pp. 157 168. </pages>
Reference: [Diwan et al., 1992] <author> Amer Diwan, J. Eliot B. Moss, and Richard L. Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In Proceedings of SIGPLAN'92 Conference on Programming Languages Design and Implementation (San Francisco, </booktitle> <address> CA, </address> <month> June </month> <year> 1992), </year> <title> vol. </title> <booktitle> 27 of ACM SIGPLAN Notices, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 273282. </pages>
Reference-contexts: They also handle callee-save registers, which require traversing the stack to find callers' register information in order to type a register saved by a callee; we also encountered that issue in implementing the scheme laid out by Diwan, et al. <ref> [Diwan et al., 1992] </ref>. We need not do that in a bytecode inter pretation implementation of the JVM, but if we produced optimized native code, the issue would arise. <p> In the area of procedural and object-oriented languages, Diwan, et al., described a scheme for building stack maps for Modula-3 <ref> [Diwan et al., 1992] </ref>, which deals with reconstructing pointers to heap objects from offsets and other optimized representations, which come about at least in part from the ability to pass object fields by reference in calls. They also considered how stack maps might be compressed to save space. <p> In particular, integer, floating point, and reference handling instructions are distinct and type checked. * The simple static data flow analysis suffices to show that no uninitialized variable is ever used. Following Diwan, et al. <ref> [Diwan et al., 1992] </ref>, we do not generate stack maps for every instruction. Rather, we restrict the VM implementation so that collection can occur only at certain gc points. These must include the allocation bytecodes.
Reference: [Foster & Winsborough, 1991] <author> Ian Foster and William Winsborough. </author> <title> Copy avoidance through compile-time analysis and local reuse. </title> <booktitle> In Proceedings of International Logic Programming Sympsium (1991), </booktitle> <pages> pp. 455469. </pages>
Reference: [Fradet, 1994] <author> Pascal Fradet. </author> <title> Collecting more garbage. </title> <booktitle> In [LFP, </booktitle> <year> 1994], </year> <pages> pp. 2433. </pages>
Reference-contexts: Baker discussed the general idea of using Hindley-Milner unification in this way a bit earlier [Baker, 1990]. A little later, Fradet <ref> [Fradet, 1994] </ref> extended this sort of collector to include a certain kind of liveness information, based on the intuitive idea that if a polymorphic function does not depend on a type parameter, then it could not actually use any data items of that type.
Reference: [Goldberg, 1991] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <journal> ACM SIGPLAN Notices 26, </journal> <volume> 6 (1991), </volume> <pages> 165176. </pages>
Reference-contexts: Branquart and Lewi's collector is notable in that it updated tables at run time as stack slot contents changed. More recently Appel [Appel, 1989] and Goldberg <ref> [Goldberg, 1991] </ref> considered tagless collection for Standard ML, which is complicated by the presence of polymorphic functions, where the types of their arguments vary from call to call.
Reference: [Goldberg & Gloger, 1992] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In Conference Record of the 1992 ACM Symposium on Lisp and Functional Programming (San Francisco, </booktitle> <address> CA, June 1992), </address> <publisher> ACM Press, </publisher> <pages> pp. 5365. </pages>
Reference-contexts: More recently Appel [Appel, 1989] and Goldberg [Goldberg, 1991] considered tagless collection for Standard ML, which is complicated by the presence of polymorphic functions, where the types of their arguments vary from call to call. In a followup paper <ref> [Goldberg & Gloger, 1992] </ref>, Goldberg and Gloger presented a system that uses type unifications to derive types at gc time.
Reference: [Gosling, 1995] <author> James Gosling. </author> <title> Java intermediate bytecodes. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Intermediate Representations (IR '95) (Jan. </booktitle> <year> 1995), </year> <pages> pp. </pages> <note> 111118. Published as ACM SIGPLAN Notices 30(3), </note> <month> March </month> <year> 1995. </year>
Reference-contexts: Thus we are concerned not so much with the Java programming language specification [Gosling et al., 1996] as with the Java virtual machine specification [Lind-holm & Yellin, 1996]. (The instruction set also has been described separately by Gosling <ref> [Gosling, 1995] </ref>.) Java bytecode must pass well-formedness tests performed by a run-time bytecode verifier; we assume that we deal only with such well-formed Java bytecode methods. <p> This implies that types may depend on program point, but not on the path by which the program point is reached. We call this the Gosling property below, since it was first stated explicitly by Gosling <ref> [Gosling, 1995] </ref>. 3 * The types of the operands for each instruction will satisfy the instruction's type constraints. In particular, integer, floating point, and reference handling instructions are distinct and type checked. * The simple static data flow analysis suffices to show that no uninitialized variable is ever used.
Reference: [Gosling et al., 1996] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: At this juncture, we stress that we are concerned with processing Java bytecode, loaded at run time. Thus we are concerned not so much with the Java programming language specification <ref> [Gosling et al., 1996] </ref> as with the Java virtual machine specification [Lind-holm & Yellin, 1996]. (The instruction set also has been described separately by Gosling [Gosling, 1995].) Java bytecode must pass well-formedness tests performed by a run-time bytecode verifier; we assume that we deal only with such well-formed Java bytecode methods.
Reference: [Hamilton, 1993] <author> G. W. Hamilton. </author> <title> Compile-Time Optimisation of Store Usage in Lazy Funtional Programs. </title> <type> PhD thesis, </type> <institution> University of Stirling, </institution> <year> 1993. </year>
Reference: [Hamilton, 1995] <author> G. W. Hamilton. </author> <title> Compile-time garbage collection for lazy functional languages. </title> <booktitle> In Proceedings of International Workshop on Memory Management (Dept. </booktitle> <institution> of Computer Science, Keele University, </institution> <month> Sept. </month> <year> 1995), </year> <editor> Henry Baker, Ed., </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: [Hamilton & Jones, 1991] <author> G. W. Hamilton and Simon B. Jones. </author> <title> Compile-time garbage collection by necessity analysis. </title> <editor> In [Peyton Jones et al., </editor> <year> 1991], </year> <pages> pp. 6670. </pages>
Reference: [Hederman, 1988] <author> Lucy Hederman. </author> <title> Compile-time garbage collection using reference count analysis. </title> <type> Master's thesis, </type> <institution> Rice University, </institution> <month> Aug. 10 </month> <year> 1988. </year> <note> Also Rice University Technical Report TR8875 but, according to Rice University's technical report list, this report is no longer available for distribution. </note>
Reference: [Hicks, 1993] <author> James Hicks. </author> <title> Experiences with compiler-directed storage reclamation. </title> <booktitle> In Record of the 1993 Conference on Functional Programming and Computer Architecture (Motorola Cambridge Research Center, </booktitle> <month> June </month> <year> 1993), </year> <editor> R. John M. Hughes, Ed., </editor> <volume> vol. </volume> <booktitle> 523 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: [Hudak, 1986] <author> Paul R. Hudak. </author> <title> A semantic model of reference counting and its abstraction (detailed summary). </title> <booktitle> In Conference Record of the 1986 ACM Symposium on Lisp and Functional Programming (Cambridge, </booktitle> <address> MA, </address> <month> Aug. </month> <year> 1986), </year> <journal> ACM SIGPLAN Notices, ACM Press, </journal> <pages> pp. 351363. </pages>
Reference: [Hudak, 1987] <author> Paul R. Hudak. </author> <title> A semantic model of reference counting and its abstraction. In Abstract Interpretation of Declarative Languages, </title> <editor> Samson Abramsky and Chris Hankin, Eds. Ellis Horward, </editor> <year> 1987, </year> <pages> pp. 4562. </pages>
Reference: [Hughes, 1992] <author> Simon Hughes. </author> <title> Compile-time garbage collection for higher-order functional languages. </title> <journal> Journal of Logic and Computation 2, </journal> <month> 4 (Aug. </month> <year> 1992), </year> <note> 483509. Special Issue on Abstract Interpretation. </note>
Reference: [Inoue et al., 1988] <author> Katsuro Inoue, Hiroyuki Seki, and Hikaru Yagi. </author> <title> Analysis of functional programs to detect run-time garbage cells. </title> <journal> ACM Transactions on Programming Languages and Systems 10, </journal> <month> 4 (Oct. </month> <year> 1988), </year> <month> 555578. </month>
Reference: [Jensen & Mogensen, 1990] <author> Thomas P. Jensen and Torben Mogensen. </author> <title> A backwards analysis for compile-time garbage collection. </title> <booktitle> In ESOP'90 3rd European Symposium on Programming, </booktitle> <address> Copenhagen, Denmark, </address> <month> May </month> <year> 1990. </year> <note> (Lecture Notes in Computer Science, vol. 432) (1990), </note> <editor> Neil D. Jones, Ed., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 227239. </pages>
Reference: [Jones, 1995] <author> Simon B. Jones. </author> <title> An experiment in compile time garbage collection. </title> <type> Tech. Rep. 84, </type> <institution> Programming Methodology Group, Goteborg University and Chalmers University of Technology, </institution> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Most significantly, we have found no previous measurement of the impact of live variable analysis, only anecdotal discussions in the context of functional languages, which leads us to the topic of experimental results. Overall, the improvements obtained with compile-time gc for functional languages have been minor. For example, Jones <ref> [Jones, 1995] </ref> obtained an 8% reduction in bytes allocated for Haskell, reducing overall execution time by 4.5%. Likewise, Wentworth found that conservative gc generally did well [Wentworth, 1990].
Reference: [Jones & le Metayer, 1989] <author> Simon B. Jones and D. le Metayer. </author> <title> Compile-time garbage collection by sharing analysis. </title> <booktitle> In Record of the 1989 Conference on Functional Programming and Computer Architecture (Imperial College, </booktitle> <address> London, Aug. 1989), </address> <publisher> ACM Press, </publisher> <pages> pp. 5474. </pages>
Reference: [Jones & Tyas, 1993] <author> Simon B. Jones and Andrew S. Tyas. </author> <title> The implementer's dilemma: A mathematical model of compile-time garbage collection. </title> <booktitle> In Sixth Annual Glasgow Workshop on Functional Programming (1993), Workshops in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 139144. </pages>
Reference: [Jones & White, 1991] <author> Simon B. Jones and M. White. </author> <title> Is compile time garbage collection worth the effort. </title> <editor> In [Peyton Jones et al., </editor> <year> 1991], </year> <pages> pp. 172176. </pages>
Reference: [LFP, 1994] <institution> Conference Record of the 1994 ACM Symposium on Lisp and Functional Programming (June 1994), </institution> <note> ACM Press. </note>
Reference: [Lindholm & Yellin, 1996] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Here we are concerned with how to generate stack maps for code presented as bytecodes used in the Java Virtual Machine (JVM) <ref> [Lindholm & Yellin, 1996] </ref>, hereafter referred to as Java bytecode, and thus to implement type-precise collection. We are also concerned with the impact of refining type-precision to live-precision. We describe the problems in generating stack maps for Java byte-code and how to solve the problems. <p> The JVM specification for verification of jsr subroutines contains an explicit exception to the Gosling property <ref> [Lindholm & Yellin, 1996, p. 136] </ref>: the bytecode verifier permits any local variable v that is neither read nor written in a jsr subroutine to retain its type across a jsr to that subroutine. This seemingly reasonable weakening of the Gosling property causes serious difficulty for precise garbage collection.
Reference: [Mohnen, 1995] <author> Markus Mohnen. </author> <title> Efficient compile-time garbage collection for arbitrary data structures. </title> <type> Tech. Rep. 9508, </type> <institution> University of Aachen, </institution> <month> May </month> <year> 1995. </year> <booktitle> Also in Seventh International Symposium on Programming Languages, Implementations, Logics and Programs, </booktitle> <address> PLILP95. </address>
Reference: [Mulkers, 1993] <author> Anne Mulkers. </author> <title> Live Data Structures in Logic Programs. No. </title> <booktitle> 675 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Mulkers et al., 1994] <author> Anne Mulkers, William Winsborough, and Maurice Bruynooghe. </author> <title> Live-structure analysis for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems 16, </journal> <month> 2 (Mar. </month> <year> 1994). </year>
Reference: [Peck, 1971] <author> J. E. L. Peck, Ed. </author> <title> Algol68 implementation. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1971. </year>
Reference: [Peyton Jones et al., 1991] <editor> Simon L. Peyton Jones, G. Hutton, and C. K. Hols, Eds. </editor> <booktitle> Third Annual Glasgow Workshop on Functional Programming (1991), </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: [PLDI, 1996] <institution> Proceedings of SIGPLAN'96 Conference on Programming Languages Design and Implementation (1996), ACM SIGPLAN Notices, </institution> <note> ACM Press. </note>
Reference: [Shao & Appel, 1994] <author> Zhong Shao and Andrew W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In [LFP, </booktitle> <year> 1994], </year> <pages> pp. 150161. </pages>
Reference: [Tarditi et al., 1996] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In [PLDI, </booktitle> <year> 1996]. </year>
Reference-contexts: Aditya, et al. compared, in the context of the polymorphic functional language Id, the cost of type-reconstruction-based collection and conservative collection [Aditya et al., 1994], and found that run-time type reconstruction can have a significant impact. Tolmach [Tolmach, 1994] and Tarditi, et al. <ref> [Tarditi et al., 1996] </ref> describe schemes that represent the polymorphic type parameters more explicitly, potentially at run time, but frequently optimized away. The Tarditi, et al., object and stack information is similar to ours, and they use liveness information at gc points (but do not report any experience with it).
Reference: [Thomas, 1995] <author> Stephen Thomas. </author> <title> Garbage collection in shared-environment closure reducers: Space-efficient depth first copying using a tailored approach. </title> <journal> Information Processing Letters 56, </journal> <month> 1 (Oct. </month> <year> 1995), </year> <month> 17. </month>
Reference-contexts: In other work, Boehm and Shao considered how to construct a useful conservative approximation of object type information at run time for a conservative collector [Boehm, 1993]. Finally, Thomas, with Jones, built routines for tracing stack frames, moving from an interpretive to a compiled model for stack maps <ref> [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995] </ref>. Clearly the notion of tagless collection is now fairly well developed; we certainly do not claim that building stack maps for Java bytecode is a novel idea or even that the difficulties peculiar to this context require deep new approaches. <p> Shao and Appel devised an arguably better scheme, based on control and data flow analyses, that shares closures heavily but still guarantees that dead variables are unreachable [Shao & Ap-pel, 1994]. Thomas's compiler-generated tracing routines <ref> [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995] </ref> take liveness into account for closures, and a given closure may be traced more than once, with different livenesses for the variables, to trace all live references. Again, we do not claim that the idea of using liveness information is new.
Reference: [Thomas, 1993] <author> Stephen P. Thomas. </author> <title> The Pragmatics of Closure Reduction. </title> <type> PhD thesis, </type> <institution> The Computing Laboratory, University of Kent at Canterbury, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: In other work, Boehm and Shao considered how to construct a useful conservative approximation of object type information at run time for a conservative collector [Boehm, 1993]. Finally, Thomas, with Jones, built routines for tracing stack frames, moving from an interpretive to a compiled model for stack maps <ref> [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995] </ref>. Clearly the notion of tagless collection is now fairly well developed; we certainly do not claim that building stack maps for Java bytecode is a novel idea or even that the difficulties peculiar to this context require deep new approaches. <p> Shao and Appel devised an arguably better scheme, based on control and data flow analyses, that shares closures heavily but still guarantees that dead variables are unreachable [Shao & Ap-pel, 1994]. Thomas's compiler-generated tracing routines <ref> [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995] </ref> take liveness into account for closures, and a given closure may be traced more than once, with different livenesses for the variables, to trace all live references. Again, we do not claim that the idea of using liveness information is new.
Reference: [Thomas & Jones, 1994] <author> Stephen P. Thomas and Richard E. Jones. </author> <title> Garbage collection for shared environment closure reducers. </title> <type> Tech. rep., </type> <institution> University of Kent and University of Nottingham, </institution> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: In other work, Boehm and Shao considered how to construct a useful conservative approximation of object type information at run time for a conservative collector [Boehm, 1993]. Finally, Thomas, with Jones, built routines for tracing stack frames, moving from an interpretive to a compiled model for stack maps <ref> [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995] </ref>. Clearly the notion of tagless collection is now fairly well developed; we certainly do not claim that building stack maps for Java bytecode is a novel idea or even that the difficulties peculiar to this context require deep new approaches. <p> Shao and Appel devised an arguably better scheme, based on control and data flow analyses, that shares closures heavily but still guarantees that dead variables are unreachable [Shao & Ap-pel, 1994]. Thomas's compiler-generated tracing routines <ref> [Thomas, 1993; Thomas & Jones, 1994; Thomas, 1995] </ref> take liveness into account for closures, and a given closure may be traced more than once, with different livenesses for the variables, to trace all live references. Again, we do not claim that the idea of using liveness information is new.
Reference: [Tolmach, 1994] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Languages Design and Implementation (Orlando, </booktitle> <address> Florida, </address> <month> June </month> <year> 1994), </year> <title> vol. </title> <booktitle> 29 of ACM SIGPLAN Notices, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. </pages> <note> 111. Also Lisp Pointers VIII 3, JulySeptember 1994. </note>
Reference-contexts: Aditya, et al. compared, in the context of the polymorphic functional language Id, the cost of type-reconstruction-based collection and conservative collection [Aditya et al., 1994], and found that run-time type reconstruction can have a significant impact. Tolmach <ref> [Tolmach, 1994] </ref> and Tarditi, et al. [Tarditi et al., 1996] describe schemes that represent the polymorphic type parameters more explicitly, potentially at run time, but frequently optimized away.
Reference: [Wadler, 1984] <author> Philip L. Wadler. </author> <title> Listlessness is better than laziness: Lazy evaluation and garbage collection at compile time. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming (Austin, </booktitle> <address> Texas, </address> <month> Aug. </month> <year> 1984), </year> <editor> Guy L. Steele, Ed., </editor> <publisher> ACM Press, </publisher> <pages> pp. 4552. </pages>
Reference: [Wentworth, 1990] <author> E. P. Wentworth. </author> <title> Pitfalls of conservative garbage collection. </title> <journal> Software Practice and Experience 20, </journal> <volume> 7 (1990), </volume> <pages> 719727. </pages>
Reference-contexts: Overall, the improvements obtained with compile-time gc for functional languages have been minor. For example, Jones [Jones, 1995] obtained an 8% reduction in bytes allocated for Haskell, reducing overall execution time by 4.5%. Likewise, Wentworth found that conservative gc generally did well <ref> [Wentworth, 1990] </ref>. On the other hand, he made a telling observation: sometimes conservatism makes a big difference. 2 Similarly, it appears that the primary benefit of liveness analyses is in reducing the likelihood of surprising space retention.
Reference: [Wodon, 1971] <author> P. L. Wodon. </author> <title> Methods of garbage collection for Algol68. </title> <editor> In [Peck, </editor> <year> 1971], </year> <pages> pp. 245262. 11 </pages>
Reference-contexts: Tagless collection goes back at least to Branquart and Lewi's [Branquart & Lewi, 1971] and Wodon's <ref> [Wodon, 1971] </ref> collectors for Algol68 and Britton's [Britton, 1975] for Pascal. Branquart and Lewi's collector is notable in that it updated tables at run time as stack slot contents changed.
References-found: 62

