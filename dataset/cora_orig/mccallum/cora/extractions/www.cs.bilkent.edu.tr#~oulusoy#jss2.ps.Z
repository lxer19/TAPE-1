URL: www.cs.bilkent.edu.tr/~oulusoy/jss2.ps.Z
Refering-URL: 
Root-URL: 
Phone: 2  3  
Title: OBJECTIVE: A Benchmark for Object-Oriented Active Database Systems  
Author: U~gur C etintemel Jurgen Zimmermann Ozgur Ulusoy and Alejandro Buchmann 
Address: College Park, Maryland, U.S.A.  Germany  Turkey  
Affiliation: 1 Department of Computer Science, University of Maryland,  Department of Computer Science, University of Darmstadt, Darmstadt,  Department of Computer Engr. and Information Sci., Bilkent University, Ankara,  
Abstract: Although much work in the area of Active Database Management Systems (ADBMSs) has been done, it is not yet clear how the performance of an active DBMS can be evaluated systematically. In this paper, we describe the OBJECTIVE Benchmark for object-oriented ADBMSs, and present experimental results from its implementation in an active database system prototype. OBJECTIVE can be used to identify performance bottlenecks and active functionalities of an ADBMS, and to compare the performance of multiple ADBMSs. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Agrawal R. and Gehani N. H., </author> <title> ODE (object database and environment): The language and the data model, </title> <booktitle> in Proc. of the 1989 SIGMOD Conference, </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS (Collet et al, 1994), Ode <ref> (Agrawal and Gehani, 1989) </ref>, REACH (Buchmann et al., 1995), SAMOS (Gatziu et al., 1994), SENTINEL (Chakravarthy et al., 1994)).
Reference: <author> Berndtsson M., ACOOD: </author> <title> An Approach to an Active Object Oriented DBMS, </title> <type> Master's Thesis, </type> <institution> University of Skovde, Skovde, Sweden, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction An Active Database Management System (ADBMS) detects certain situations and performs corresponding user defined actions in the form of Event-Condition-Action (ECA) rules (Dayal et al., 1988a). ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD <ref> (Berndtsson, 1991) </ref>, NAOS (Collet et al, 1994), Ode (Agrawal and Gehani, 1989), REACH (Buchmann et al., 1995), SAMOS (Gatziu et al., 1994), SENTINEL (Chakravarthy et al., 1994)).
Reference: <author> Boral H. and DeWitt D. J., </author> <title> A methodology for database system performance evaluation, </title> <booktitle> in Proc. of the 1984 SIGMOD Conference, </booktitle> <address> Boston, </address> <year> 1984. </year>
Reference-contexts: There has been much work in the area of database benchmarking; e.g., the Wisconsin Benchmark <ref> (Boral and DeWitt, 1984) </ref>, the OO1 Benchmark (Catell 1 and Skeen, 1992), and the OO7 Benchmark (Carey et al., 1993).
Reference: <author> Brant D. A. and Miranker D. P., </author> <title> Index support for rule activation, </title> <booktitle> in 1993 SIGMOD Conference, </booktitle> <address> Washington D.C., </address> <year> 1993. </year>
Reference-contexts: Actually, these are not devoted performance evaluation works; rather, they present a rule (sub)system and then evaluate its performance. For instance <ref> (Brant and Miranker, 1993) </ref> mainly addresses the problem of handling large rule sets. It argues that the techniques used in current active database prototypes are not appropriate for handling large rulebases.
Reference: <author> Buchmann A. P., Zimmermann J., Blakeley J., and Wells D. L., </author> <title> Building an integrated active OODBMS: requirements, architecture and design decisions, </title> <booktitle> in Proc. of the 1995 Data Engineering Conference, </booktitle> <address> Taipeh, </address> <year> 1995. </year>
Reference-contexts: ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS (Collet et al, 1994), Ode (Agrawal and Gehani, 1989), REACH <ref> (Buchmann et al., 1995) </ref>, SAMOS (Gatziu et al., 1994), SENTINEL (Chakravarthy et al., 1994)). <p> The OBJECTIVE Benchmark comprises a number of operations that evaluate the issues stated above, and those operations were first run on REACH <ref> (Buchmann et al., 1995) </ref>. REACH is a full-fledged operational object-oriented ADBMS which is tightly integrated in Texas Instruments' Open OODB (Wells et al., 1992). The results reported in this paper reveal that REACH combines advanced features of current ADBMS proposals from the functionality point of view. <p> Another technique, method wrapping, is to replace the original method with a method wrapper that contains an explicit event raise operation and a call to the original method <ref> (Buchmann et al., 1995) </ref>. When a method for which an event is defined is called, actually its wrapper is invoked (i.e, the wrapper gets the name of the original method, and original method is renamed). <p> The definition of a time interval is mandatory for negation, and optional for history and closure. Composite events can further be grouped into aggregating composite events and non-aggregating composite events <ref> (Zimmermann and Buchmann, 1995) </ref>. The former group contains composite events that are constructed with the operators sequence, disjunction, and conjunction, whereas the latter group comprises composite events constructed with history, negation, and closure. <p> The OBJECTIVE Benchmark addresses the following issues <ref> (Zimmermann and Buchmann, 1995) </ref> by the operations which are described briefly in Table 1: 1. <p> The way event parameters are handled, thus, has a great impact on the performance of the system. 5. Garbage collection of semi-composed events The problem of garbage collection exists for some composite events that are not fully composed, and whose extents have expired <ref> (Buchmann et al., 1995) </ref>. If no garbage collection is done for such semi-composed events, the database size will increase unnecessarily which will lead to a further increase in response time. So, an efficient mechanism for garbage collection of semi-composed events must be employed from the performance point of view. 6.
Reference: <author> Carey M. J., DeWitt D. J., and Naughton J. F., </author> <title> The 007 benchmark, </title> <booktitle> in Proc. of the 1993 SIG 19 MOD Conference, </booktitle> <address> Washington D.C., </address> <year> 1993. </year>
Reference-contexts: There has been much work in the area of database benchmarking; e.g., the Wisconsin Benchmark (Boral and DeWitt, 1984), the OO1 Benchmark (Catell 1 and Skeen, 1992), and the OO7 Benchmark <ref> (Carey et al., 1993) </ref>. However, there have been only a few attempts to evaluate the performance of ADBMSs, the most important of which are the BEAST Benchmark (Geppert et al., 1995), and the ACT-1 Benchmark (Zimmermann et al., 1995). <p> It was presented as a designer's benchmark; i.e., the designers of an ADBMS can use it to determine performance bottlenecks of their systems. It uses the database and schema of the OO7 Benchmark <ref> (Carey et al., 1993) </ref>. The BEAST Benchmark runs a series of tests to determine the functionality of each component. It consists of: * Tests for event detection concentrate on the time to detect particular events. A set of primitive and composite events are tested.
Reference: <author> Catell R. and Skeen J., </author> <title> Object Operations Benchmark, </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 1-31, </pages> <year> 1992. </year>
Reference-contexts: There has been much work in the area of database benchmarking; e.g., the Wisconsin Benchmark (Boral and DeWitt, 1984), the OO1 Benchmark <ref> (Catell 1 and Skeen, 1992) </ref>, and the OO7 Benchmark (Carey et al., 1993). However, there have been only a few attempts to evaluate the performance of ADBMSs, the most important of which are the BEAST Benchmark (Geppert et al., 1995), and the ACT-1 Benchmark (Zimmermann et al., 1995).
Reference: <author> Cetintemel U., Zimmermann J., Ulusoy O., and Buchmann A., </author> <title> OBJECTIVE: A Benchmark for Object-Oriented Active Database Systems, </title> <type> Technical Report BU-CEIS-9610, </type> <institution> Bilkent University, Ankara, Turkey, </institution> <year> 1996. </year>
Reference-contexts: GC1f decl EPP3 flobj; decl ; double d1; event 1000 times ABSTRACT (GC1) in double d2; BOT ('GC1') , event obj-&gt;setData (d1,d2); COMMIT ('GC1') cond dep d1 &lt; d2; cond FALSE; action obj-&gt;setMinData (); action ; g; g; 3. perform cold and hot time measurements, and 4. close the database. <ref> (Cetintemel et al., 1996) </ref> presents simplified codes that illustrate the implementation of the OBJEC TIVE operations. The environment in which we benchmark REACH is a SUN-SPARC 10/512 with 112 MB of RAM under Solaris 2.5, Open OODB 0.2.1, and the EXODUS Storage Manager 7 2.2. <p> Each operation has been run about 50 times for the same setting of database parameters. Table 3 depicts the mean values of the REACH results. All results along with 90% confidence intervals and standard deviations are presented in <ref> (Cetintemel et al., 1996) </ref>. 4.4.1 Method Wrapping The purpose of operation MW1 is to asses the cost of the useless overhead generated by the invocation of a method which is wrapped to provide active functionality whenever required. In operation MW1, a method is invoked which does not generate any event. <p> However, it is also evident (from the dependency of the results on database configuration) that this update is implemented inefficiently. In addition, it can be inferred from the large standard deviations of PED3 results (see <ref> (Cetintemel et al., 1996) </ref>) that, duration of the event history maintenance task (thus duration of the commit operation) depends on the size of the event history which increases at each run of the benchmark operations.
Reference: <author> Chakravarthy S. and Mishra D., SNOOP: </author> <title> An Expressive Event Specification Language for Active Databases, </title> <type> Technical Report UF-CIS-TR-93-007, </type> <institution> University of Florida, Florida, </institution> <year> 1993. </year>
Reference: <author> Chakravarthy S., Krishnaprasad V., Abwar E., and Kim S. K., </author> <title> Anatomy of a Composite Event Detector. </title> <type> Technical Report UF-CIS-TR-93-039, </type> <institution> University of Florida, Florida, </institution> <year> 1993. </year>
Reference: <author> Chakravarthy S., Tamizuddin Z., Krishnaprasad V., and Badani R. H., </author> <title> ECA Rule Integration into an OODBMS: Architecture and Implementation, </title> <type> Technical Report UF-CIS-94-023, </type> <institution> University of Florida, Florida, </institution> <year> 1994. </year>
Reference-contexts: ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS (Collet et al, 1994), Ode (Agrawal and Gehani, 1989), REACH (Buchmann et al., 1995), SAMOS (Gatziu et al., 1994), SENTINEL <ref> (Chakravarthy et al., 1994) </ref>).
Reference: <author> Collet C., Coupaye T., and Svensen T., NAOS: </author> <title> Efficient and modular reactive capabilities in an object-oriented database system, </title> <booktitle> in Proc. of the 20th VLDB, </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction An Active Database Management System (ADBMS) detects certain situations and performs corresponding user defined actions in the form of Event-Condition-Action (ECA) rules (Dayal et al., 1988a). ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS <ref> (Collet et al, 1994) </ref>, Ode (Agrawal and Gehani, 1989), REACH (Buchmann et al., 1995), SAMOS (Gatziu et al., 1994), SENTINEL (Chakravarthy et al., 1994)).
Reference: <author> Dayal U., Blaustein B., Buchmann A., Chakravarthy S., Hsu M., Ladin R., McCarthy D., and Rosen-thal A., </author> <title> The HiPAC Project: Combining Active Databases and Timing Constraints, </title> <journal> ACM SIGMOD Record, </journal> <volume> 17(1) </volume> <pages> 51-70, </pages> <year> 1988. </year>
Reference-contexts: The Event-Condition (EC) and Condition-Action (CA) coupling modes, respectively, determine when the rule's condition is evaluated with respect to the triggering event, and when the rule's action is executed with respect to the condition evaluation. Three basic coupling modes are introduced in <ref> (Dayal, 1988) </ref>: immediate, deferred , and decoupled .
Reference: <author> Dayal U., </author> <title> Active database management systems, </title> <booktitle> in Proc. of the 3rd International Conference on Data and Knowledge Bases, </booktitle> <address> Jerusalem, </address> <year> 1988. </year>
Reference-contexts: The Event-Condition (EC) and Condition-Action (CA) coupling modes, respectively, determine when the rule's condition is evaluated with respect to the triggering event, and when the rule's action is executed with respect to the condition evaluation. Three basic coupling modes are introduced in <ref> (Dayal, 1988) </ref>: immediate, deferred , and decoupled .
Reference: <author> Deutsch A., </author> <title> Detection of Method and Composite Events in the Active DBMS REACH, </title> <type> Master's Thesis, </type> <institution> Technical University Darmstadt, Darmstadt, Germany, </institution> <year> 1994. </year>
Reference: <author> Eriksson J., CEDE: </author> <title> Composite Event Detector in an Active Object-Oriented Database, </title> <type> Master's Thesis, </type> <institution> University of Skovde, Skovde, Sweden, </institution> <year> 1993. </year>
Reference-contexts: Several different approaches are used for composite event detection including syntax graphs (Deutsch, 1994; Chakravarthy et al., 1993), Petri nets (Gatziu and Dittrich, 1994), finite state automata (Gehani et al., 1992), and arrays <ref> (Eriksson, 1993) </ref>. 2.2 Conditions The condition part of a rule is usually a boolean expression, a predicate, or a set of queries, and it is satisfied if the expression evaluates to true, or all the queries return non-empty results, respectively.
Reference: <author> Gatziu S. and Dittrich K. R., </author> <title> Events in an active object-oriented database system., </title> <booktitle> in Proc. of the 1st International Workshop on Rules in Database Systems, </booktitle> <editor> (N.W. Paton, H.W. Williams, eds.), </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS (Collet et al, 1994), Ode (Agrawal and Gehani, 1989), REACH (Buchmann et al., 1995), SAMOS <ref> (Gatziu et al., 1994) </ref>, SENTINEL (Chakravarthy et al., 1994)). <p> The former group contains composite events that are constructed with the operators sequence, disjunction, and conjunction, whereas the latter group comprises composite events constructed with history, negation, and closure. Several different approaches are used for composite event detection including syntax graphs (Deutsch, 1994; Chakravarthy et al., 1993), Petri nets <ref> (Gatziu and Dittrich, 1994) </ref>, finite state automata (Gehani et al., 1992), and arrays (Eriksson, 1993). 2.2 Conditions The condition part of a rule is usually a boolean expression, a predicate, or a set of queries, and it is satisfied if the expression evaluates to true, or all the queries return non-empty
Reference: <author> Gatziu S. and Dittrich K. R., </author> <title> Detecting composite events in active database systems using Petri nets, </title> <booktitle> in Proc. of the 4th IEEE RIDE, </booktitle> <address> Houston, Texas, </address> <year> 1994. </year>
Reference-contexts: ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS (Collet et al, 1994), Ode (Agrawal and Gehani, 1989), REACH (Buchmann et al., 1995), SAMOS <ref> (Gatziu et al., 1994) </ref>, SENTINEL (Chakravarthy et al., 1994)). <p> The former group contains composite events that are constructed with the operators sequence, disjunction, and conjunction, whereas the latter group comprises composite events constructed with history, negation, and closure. Several different approaches are used for composite event detection including syntax graphs (Deutsch, 1994; Chakravarthy et al., 1993), Petri nets <ref> (Gatziu and Dittrich, 1994) </ref>, finite state automata (Gehani et al., 1992), and arrays (Eriksson, 1993). 2.2 Conditions The condition part of a rule is usually a boolean expression, a predicate, or a set of queries, and it is satisfied if the expression evaluates to true, or all the queries return non-empty
Reference: <author> Gatziu S., Geppert A., and Dittrich K. R., </author> <title> The SAMOS Active DBMS Prototype, </title> <type> Technical Report CS 94.16, </type> <institution> University of Zurich, Zurich, Switzerland, </institution> <note> 1994. </note> <author> 20 Gehani N., Jagadish H. V., and Shumeli O., </author> <title> Composite event specification in active databases: Model and implementation, </title> <booktitle> in Proc. of the 18th VLDB, </booktitle> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: ADBMSs have received great attention lately, and several prototypes of object-oriented ADBMSs are already available (e.g., ACOOD (Berndtsson, 1991), NAOS (Collet et al, 1994), Ode (Agrawal and Gehani, 1989), REACH (Buchmann et al., 1995), SAMOS <ref> (Gatziu et al., 1994) </ref>, SENTINEL (Chakravarthy et al., 1994)). <p> The former group contains composite events that are constructed with the operators sequence, disjunction, and conjunction, whereas the latter group comprises composite events constructed with history, negation, and closure. Several different approaches are used for composite event detection including syntax graphs (Deutsch, 1994; Chakravarthy et al., 1993), Petri nets <ref> (Gatziu and Dittrich, 1994) </ref>, finite state automata (Gehani et al., 1992), and arrays (Eriksson, 1993). 2.2 Conditions The condition part of a rule is usually a boolean expression, a predicate, or a set of queries, and it is satisfied if the expression evaluates to true, or all the queries return non-empty
Reference: <author> Geppert A., Gatziu S., and Dittrich K. R., </author> <title> A Designer's Benchmark for Active Database Management Systems: 007 Meets the BEAST, </title> <type> Technical Report CS 95.18, </type> <institution> University of Zurich, </institution> <address> Zurich, Switzer-land, </address> <year> 1995. </year>
Reference-contexts: However, there have been only a few attempts to evaluate the performance of ADBMSs, the most important of which are the BEAST Benchmark <ref> (Geppert et al., 1995) </ref>, and the ACT-1 Benchmark (Zimmermann et al., 1995). In this paper, we describe the OBJECTIVE 1 Benchmark which is a simple but comprehensive test of active functionalities provided by an object-oriented ADBMS, and give performance results of its implementation in an ADBMS prototype. <p> In this section, we discuss these efforts in some detail. 3.1 The BEAST Benchmark The BEAST is the first benchmark proposed for testing the performance of object-oriented ADBMSs <ref> (Geppert et al., 1995) </ref>. It was presented as a designer's benchmark; i.e., the designers of an ADBMS can use it to determine performance bottlenecks of their systems. It uses the database and schema of the OO7 Benchmark (Carey et al., 1993).
Reference: <author> Geppert A., Berndtsson M., Lieuwen D., and Zimmermann J., </author> <title> Performance Evaluation of Active Database Management Systems using the BEAST benchmark, </title> <type> Technical Report CS 96.01, </type> <institution> University of Zurich, </institution> <address> Zurich, Switzerland, </address> <year> 1996. </year>
Reference-contexts: To date, BEAST has been run on four object-oriented ADBMS prototypes, and the performance results are presented in <ref> (Geppert et al., 1996) </ref>. 3.2 The ACT-1 Benchmark The ACT-1 Benchmark (Zimmermann et al., 1995) concentrates on the minimal features of object-oriented ADBMSs. Four basic issues are addressed in this benchmark: 1. Method wrapping penalty measures the useless overhead of method wrapping for the detection of method events. 6 2.
Reference: <author> Gray J., </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing, </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference: <author> Wells D. L., Blakeley J. A., and Thompson C. W., </author> <title> Architecture of an Open Object-Oriented Database Management System, </title> <journal> IEEE Computer, </journal> <volume> 25(10) </volume> <pages> 74-81, </pages> <year> 1992. </year>
Reference-contexts: The OBJECTIVE Benchmark comprises a number of operations that evaluate the issues stated above, and those operations were first run on REACH (Buchmann et al., 1995). REACH is a full-fledged operational object-oriented ADBMS which is tightly integrated in Texas Instruments' Open OODB <ref> (Wells et al., 1992) </ref>. The results reported in this paper reveal that REACH combines advanced features of current ADBMS proposals from the functionality point of view. As for its performance, a single bottleneck operation is identified. The remainder of the paper is organized as follows.
Reference: <author> Zimmermann J. and Buchmann A. P., </author> <title> Benchmarking active database systems: A requirements analysis, in OOPSLA'95 Workshop on Object Database Behavior, Benchmarks and Performance, </title> <address> Austin, Texas, </address> <year> 1995. </year>
Reference-contexts: However, there have been only a few attempts to evaluate the performance of ADBMSs, the most important of which are the BEAST Benchmark (Geppert et al., 1995), and the ACT-1 Benchmark <ref> (Zimmermann et al., 1995) </ref>. In this paper, we describe the OBJECTIVE 1 Benchmark which is a simple but comprehensive test of active functionalities provided by an object-oriented ADBMS, and give performance results of its implementation in an ADBMS prototype. <p> The definition of a time interval is mandatory for negation, and optional for history and closure. Composite events can further be grouped into aggregating composite events and non-aggregating composite events <ref> (Zimmermann and Buchmann, 1995) </ref>. The former group contains composite events that are constructed with the operators sequence, disjunction, and conjunction, whereas the latter group comprises composite events constructed with history, negation, and closure. <p> To date, BEAST has been run on four object-oriented ADBMS prototypes, and the performance results are presented in (Geppert et al., 1996). 3.2 The ACT-1 Benchmark The ACT-1 Benchmark <ref> (Zimmermann et al., 1995) </ref> concentrates on the minimal features of object-oriented ADBMSs. Four basic issues are addressed in this benchmark: 1. Method wrapping penalty measures the useless overhead of method wrapping for the detection of method events. 6 2. <p> The OBJECTIVE Benchmark addresses the following issues <ref> (Zimmermann and Buchmann, 1995) </ref> by the operations which are described briefly in Table 1: 1.
Reference: <author> Zimmermann J., Branding H., Buchmann A. P., Deutsch A., and Geppert A., </author> <title> Design, implementation and management of rules in an active database system, </title> <booktitle> in Proc. of the 7th DEXA, </booktitle> <address> Zurich, Switzerland, </address> <year> 1996. </year> <month> 21 </month>
Reference-contexts: Several events and rules are defined (Figure 2 and Figure 3) to be used in benchmark operations. The rules are defined in the rule programming language REAL 3 (REAch rule Language) <ref> (Zimmermann et al., 1996) </ref>. The events, however, are defined in a hypothetical language based on the event definition notation of REAL 4 . These events and rules are discussed in detail in Section 4.4 where we describe the implementation of the benchmark operations. <p> In all these operations, the relevant rules are kept very simple in order to focus on the efficiency of the provided rule administration facility. All of the rule administration operations are implemented using the rule management commands of REACH from its command line interface <ref> (Zimmermann et al., 1996) </ref>. The implementation of operation RA1 in REACH consists of the creation of a rule and compilation of the shared library containing the condition/action parts of rules in the form of two C functions by using the REACH command rl_cc.
References-found: 25

