URL: http://www.cs.utah.edu/~cs686/Previous/a97/isca-95-partial-pred.ps
Refering-URL: http://www.cs.utah.edu/~cs686/Previous/a97/
Root-URL: 
Title: A Comparison of Full and Partial Predicated Execution Support for ILP Processors  
Author: Scott A. Mahlke Richard E. Hank James E. McCormick David I. August Wen-mei W. Hwu 
Address: IL 61801  
Affiliation: Center for Reliable and High-Performance Computing University of Illinois Urbana-Champaign,  
Date: Jun 1995 1  
Note: To appear ISCA-22,  
Abstract: One can effectively utilize predicated execution to improve branch handling in instruction-level parallel processors. Although the potential benefits of predicated execution are high, the tradeoffs involved in the design of an instruction set to support predicated execution can be difficult. On one end of the design spectrum, architectural support for full predicated execution requires increasing the number of source operands for all instructions. Full predicate support provides for the most flexibility and the largest potential performance improvements. On the other end, partial predicated execution support, such as conditional moves, requires very little change to existing architectures. This paper presents a preliminary study to qualitatively and quantitatively address the benefit of full and partial predicated execution support. With our current compiler technology, we show that the compiler can use both partial and full predication to achieve speedup in large control-intensive programs. Some details of the code generation techniques are shown to provide insight into the benefit of going from partial to full predication. Preliminary experimental results are very encouraging: partial predication provides an average of 33% performance improvement for an 8-issue processor with no predicate support while full predication provides an additional 30% improvement. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. E. Smith, </author> <title> "A study of branch prediction strategies," </title> <booktitle> in Proceedings of the 8th International Symposium on Computer Architecture, </booktitle> <pages> pp. 135-148, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: Branch prediction fl Scott Mahlke is now with Hewlett Packard Laboratories, Palo Alto, CA. 0 in conjunction with speculative execution is typically utilized by the compiler and/or hardware to remove control dependences and expose ILP in superscalar and VLIW processors <ref> [1] </ref> [2] [3]. However, misprediction of these branches can result in severe performance penalties. Recent studies have reported a performance reduction of two to more than ten when realistic instead of perfect branch prediction is utilized [4] [5] [6].
Reference: [2] <author> J. Lee and A. J. Smith, </author> <title> "Branch prediction strategies and branch target buffer design," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 6-22, </pages> <month> Jan-uary </month> <year> 1984. </year>
Reference-contexts: Branch prediction fl Scott Mahlke is now with Hewlett Packard Laboratories, Palo Alto, CA. 0 in conjunction with speculative execution is typically utilized by the compiler and/or hardware to remove control dependences and expose ILP in superscalar and VLIW processors [1] <ref> [2] </ref> [3]. However, misprediction of these branches can result in severe performance penalties. Recent studies have reported a performance reduction of two to more than ten when realistic instead of perfect branch prediction is utilized [4] [5] [6].
Reference: [3] <author> T. Y. Yeh and Y. N. Patt, </author> <title> "A comparison of dynamic branch predictors that use two levels of branch history," </title> <booktitle> in Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 257-266, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Branch prediction fl Scott Mahlke is now with Hewlett Packard Laboratories, Palo Alto, CA. 0 in conjunction with speculative execution is typically utilized by the compiler and/or hardware to remove control dependences and expose ILP in superscalar and VLIW processors [1] [2] <ref> [3] </ref>. However, misprediction of these branches can result in severe performance penalties. Recent studies have reported a performance reduction of two to more than ten when realistic instead of perfect branch prediction is utilized [4] [5] [6]. The second limitation is that processor resources to handle branches are often restricted.
Reference: [4] <author> M. D. Smith, M. Johnson, and M. A. Horowitz, </author> <title> "Limits on multiple instruction issue," </title> <booktitle> in Proceedings of the 3rd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 290-302, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: However, misprediction of these branches can result in severe performance penalties. Recent studies have reported a performance reduction of two to more than ten when realistic instead of perfect branch prediction is utilized <ref> [4] </ref> [5] [6]. The second limitation is that processor resources to handle branches are often restricted. As a result, for control intensive applications, an artificial upper bound on performance will be imposed by the branch resource constraints.
Reference: [5] <author> D. W. Wall, </author> <title> "Limits of instruction-level parallelism," </title> <booktitle> in Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 176-188, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: However, misprediction of these branches can result in severe performance penalties. Recent studies have reported a performance reduction of two to more than ten when realistic instead of perfect branch prediction is utilized [4] <ref> [5] </ref> [6]. The second limitation is that processor resources to handle branches are often restricted. As a result, for control intensive applications, an artificial upper bound on performance will be imposed by the branch resource constraints.
Reference: [6] <author> M. Butler, T. Yeh, Y. Patt, M. Alsup, H. Scales, and M. She-banow, </author> <title> "Single instruction stream parallelism is greater than two," </title> <booktitle> in Proceedings of the 18th International Symposium on Computer Architecture, </booktitle> <pages> pp. 276-286, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: However, misprediction of these branches can result in severe performance penalties. Recent studies have reported a performance reduction of two to more than ten when realistic instead of perfect branch prediction is utilized [4] [5] <ref> [6] </ref>. The second limitation is that processor resources to handle branches are often restricted. As a result, for control intensive applications, an artificial upper bound on performance will be imposed by the branch resource constraints.
Reference: [7] <author> P. Y. Hsu and E. S. Davidson, </author> <title> "Highly concurrent scalar processing," </title> <booktitle> in Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <pages> pp. 386-395, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Predicated execution support provides an effective means to eliminate branches from an instruction stream. Predicated or guarded execution refers to the conditional execution of an instruction based on the value of a boolean source operand, referred to as the predicate <ref> [7] </ref> [8]. This architectural support allows the compiler to employ an if-conversion algorithm to convert conditional branches into predicate defining instructions, and instructions along alternative paths of each branch into predicated instructions [9] [10] [11]. Predicated instructions are fetched regardless of their predicate value.
Reference: [8] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. A. Towle, </author> <title> "The Cydra 5 departmental supercomputer," </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 12-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Predicated execution support provides an effective means to eliminate branches from an instruction stream. Predicated or guarded execution refers to the conditional execution of an instruction based on the value of a boolean source operand, referred to as the predicate [7] <ref> [8] </ref>. This architectural support allows the compiler to employ an if-conversion algorithm to convert conditional branches into predicate defining instructions, and instructions along alternative paths of each branch into predicated instructions [9] [10] [11]. Predicated instructions are fetched regardless of their predicate value. <p> In this manner, every instruction may be a predicated. Additionally, a set of predicate defining opcodes are added to efficiently manipulate predicate values. This approach was most notably utilized in the Cydra 5 min-isupercomputer <ref> [8] </ref> [13]. Full predicate execution support provides the most flexibility and the largest potential performance improvements. The other approach is to provide partial predicate support. With partial predicate support, a small number of instructions are provided which conditionally execute, such as a conditional move. <p> this To appear - ISCA-22, Jun 1995 3 P out P in Comparison U U OR OR AND AN D 0 0 0 0 - 1 0 0 1 - 1 0 - Table 1: Predicate definition truth table. suppression model is the predicate support provided by the Cydra 5 <ref> [8] </ref>. Suppression at the decode/issue stage is also assumed in our simulation model. Expression of Condition. A set of new instructions is needed to set the predicate registers based upon conditional expressions. These instructions can be classified as those that define, clear, set, load, or store predicate registers.
Reference: [9] <author> J. R. Allen, K. Kennedy, C. Porterfield, and J. Warren, </author> <title> "Conversion of control dependence to data dependence," </title> <booktitle> in Proceedings of the 10th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 177-189, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: This architectural support allows the compiler to employ an if-conversion algorithm to convert conditional branches into predicate defining instructions, and instructions along alternative paths of each branch into predicated instructions <ref> [9] </ref> [10] [11]. Predicated instructions are fetched regardless of their predicate value. Instructions whose predicate is true are executed normally. Conversely, instructions whose predicate is false are nullified, and thus are prevented from modifying the processor state. Predicated execution provides the opportunity to significantly improve branch handling in ILP processors. <p> This will be discussed in more detail in the next section. The Multiflow Trace 300 series machines supported partial predicated execution with select instructions [19]. 3 Compiler Support The compiler eliminates branch instructions by introducing conditional instructions. The basic transformation is known as if-conversion <ref> [9] </ref> [10]. In our approach, full predicate support is assumed in the intermediate representation (IR) regardless of the the actual architectural support in the target processor. A set of compilation techniques based on the hyperblock structure are employed to effectively exploit predicate support in the IR [11].
Reference: [10] <author> J. C. Park and M. S. Schlansker, </author> <title> "On predicated execution," </title> <type> Tech. Rep. </type> <institution> HPL-91-58, Hewlett Packard Laboratories, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: This architectural support allows the compiler to employ an if-conversion algorithm to convert conditional branches into predicate defining instructions, and instructions along alternative paths of each branch into predicated instructions [9] <ref> [10] </ref> [11]. Predicated instructions are fetched regardless of their predicate value. Instructions whose predicate is true are executed normally. Conversely, instructions whose predicate is false are nullified, and thus are prevented from modifying the processor state. Predicated execution provides the opportunity to significantly improve branch handling in ILP processors. <p> Code Example. Figure 1 contains a simple example illustrating the concept of predicated execution. The source code in Figure 1 (a) is compiled into the code shown in Figure 1 (b). Using if-conversion <ref> [10] </ref>, the code is then transformed into the code shown in Figure 1 (c). The use of predicate registers is initiated by a pred clear in order to insure that all predicate registers are cleared. The first two conditional branches in (b) are translated into two pred eq instructions. <p> This will be discussed in more detail in the next section. The Multiflow Trace 300 series machines supported partial predicated execution with select instructions [19]. 3 Compiler Support The compiler eliminates branch instructions by introducing conditional instructions. The basic transformation is known as if-conversion [9] <ref> [10] </ref>. In our approach, full predicate support is assumed in the intermediate representation (IR) regardless of the the actual architectural support in the target processor. A set of compilation techniques based on the hyperblock structure are employed to effectively exploit predicate support in the IR [11].
Reference: [11] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann, </author> <title> "Effective compiler support for predicated execution using the hyperblock," </title> <booktitle> in Proceedings of the 25th International Symposium on Microarchitecture, </booktitle> <pages> pp. 45-54, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: This architectural support allows the compiler to employ an if-conversion algorithm to convert conditional branches into predicate defining instructions, and instructions along alternative paths of each branch into predicated instructions [9] [10] <ref> [11] </ref>. Predicated instructions are fetched regardless of their predicate value. Instructions whose predicate is true are executed normally. Conversely, instructions whose predicate is false are nullified, and thus are prevented from modifying the processor state. Predicated execution provides the opportunity to significantly improve branch handling in ILP processors. <p> In our approach, full predicate support is assumed in the intermediate representation (IR) regardless of the the actual architectural support in the target processor. A set of compilation techniques based on the hyperblock structure are employed to effectively exploit predicate support in the IR <ref> [11] </ref>. For target processors that only have partial predicate support, unsupported predicated instructions are broken down into sequences of equivalent instructions that are representable. Since the transformation may introduce inefficiencies, a comprehensive set of peephole optimizations is applied to code both before and after conversion. <p> examples from the benchmark programs studied are presented to compare and contrast the effectiveness of full and partial predicate support using the these compilation techniques. 3.1 Compiler Support for Full Predication The compilation techniques utilized in this paper to exploit predicated execution are based on a structure called a hy-perblock <ref> [11] </ref>. A hyperblock is a collection of connected basic blocks in which control may only enter at the first block, designated as the entry block. Control flow may leave from one or more blocks in the hyperblock. All control flow between basic blocks in a hyperblock is eliminated via if-conversion. <p> This code expansion is obviously reduced if there are fewer predicated instructions that must be converted. Predicate promotion refers to removing the predicate from a predicated instruction <ref> [11] </ref>. As a result, the instruction is unconditionally executed. By performing predicate promotion, fewer predicated instructions remain in the IR that must be converted. An example to illustrate the effectiveness of predicate promotion is presented in Figure 2.
Reference: [12] <author> S. A. Mahlke, R. E. Hank, R. A. Bringmann, J. C. Gyl-lenhaal, D. M. Gallagher, and W. W. Hwu, </author> <title> "Characterizing the impact of predicated execution on branch prediction," </title> <booktitle> in Proceedings of the 27th International Symposium on Mi-croarchitecture, </booktitle> <pages> pp. 217-227, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The most obvious benefit is that decreasing the number of branches reduces the need to sustain multiple branches per cycle. Therefore, the artificial performance bounds imposed by limited branch resources can be alleviated. Eliminating frequently mispredicted branches also leads to a substantial reduction in branch prediction misses <ref> [12] </ref>. As a result, the performance penalties associated with mispredictions of the eliminated branches are removed. Finally, predicated execution provides an efficient interface for the compiler to expose multiple execution paths to the hardware. Without compiler support, the cost of maintaining multiple execution paths in hardware grows exponentially.
Reference: [13] <author> G. R. Beck, D. W. Yen, and T. L. Anderson, </author> <title> "The Cydra 5 minisupercomputer: Architecture and implementation," </title> <journal> The Journal of Supercomputing, </journal> <volume> vol. 7, </volume> <pages> pp. 143-180, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: In this manner, every instruction may be a predicated. Additionally, a set of predicate defining opcodes are added to efficiently manipulate predicate values. This approach was most notably utilized in the Cydra 5 min-isupercomputer [8] <ref> [13] </ref>. Full predicate execution support provides the most flexibility and the largest potential performance improvements. The other approach is to provide partial predicate support. With partial predicate support, a small number of instructions are provided which conditionally execute, such as a conditional move.
Reference: [14] <author> D. N. Pnevmatikatos and G. S. Sohi, </author> <title> "Guarded execution and branch prediction in dynamic ILP processors," </title> <booktitle> in Proceedings of the 21st International Symposium on Computer Architecture, </booktitle> <pages> pp. 120-129, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Varying levels of partial predicate support provide options for extending an existing ISA. For example, introducing guard instructions which hold the predicate specifiers of subsequent instructions may be utilized <ref> [14] </ref>. 2 ISA Extensions In this section, a set of extensions to the instruction set architecture for both full and partial predicate support are presented. The baseline architecture assumed is generic ILP processor (either VLIW or superscalar) with in-order issue and register interlocking.
Reference: [15] <author> V. Kathail, M. S. Schlansker, and B. R. Rau, </author> <title> "HPL play-doh architecture specification: Version 1.0," </title> <type> Tech. Rep. </type> <institution> HPL-93-80, Hewlett-Packard Laboratories, </institution> <address> Palo Alto, CA 94303, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: These instructions can be classified as those that define, clear, set, load, or store predicate registers. Predicate register values may be set using predicate define instructions. The predicate define semantics used are those of the HPL Playdoh architecture <ref> [15] </ref>. There is a predicate define instruction for each comparison opcode in the original instruction set. The major difference with conventional comparison instructions is that these predicate defines have up to two destination registers and that their destination registers are predicate registers.
Reference: [16] <author> M. Schlansker, V. Kathail, and S. Anik, </author> <title> "Height reduction of control recurrences for ILP processors," </title> <booktitle> in Proceedings of the 27th International Symposium on Microarchitecture, </booktitle> <pages> pp. 40-51, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: AN D type destination predicate registers are cleared if P in is 1 and the result of the comparison is 0 (1 for AN D), otherwise the destination predicate register is unchanged. The AN D type predicate is particularly useful for transformations such as control height reduction <ref> [16] </ref>. Although it is possible to individually set each predicate register to zero or one through the use of the aforementioned predicate define instructions, in some cases individually setting each predicate can be costly.
Reference: [17] <author> Hewlett-Packard Company, </author> <title> Cupertino, CA, PA-RISC 1.1 Architecture and Instruction Set Reference Manual, </title> <year> 1990. </year>
Reference-contexts: These are analogous in operation to conditional moves, except they perform the move when cond is false, as opposed to when cond is true. The Sparc V9 instruction set specification and the DEC Alpha provide conditional move instructions for both integer and floating point registers. The HP Precision Architecture <ref> [17] </ref> provides all branch, arithmetic, and logic instructions the capability to conditionally nullify the subsequent instruction. Currently the generation of conditional move instructions is very limited in most compilers. One exception is the DEC GEM compiler that can efficiently generate conditional moves for simple control constructs [18]. Select. <p> Predicate Emulation. Emulation is achieved by performing a second phase of register allocation and generating PA-RISC assembly code. The emulation of the varying levels of predicate support, as well as speculation of load instructions is done using the bit manipulation and conditional nullification capabilities of the PA-RISC instruction set <ref> [17] </ref>. Predicates are emulated by reserving n of the callee-saved registers and accessing them as 32 fi n 1-bit registers. The instruction sequence required to emulate a predicate define instruction is dependent upon the predicate types of the destination predicate registers.
Reference: [18] <author> D. S. Blickstein et al., </author> <title> "The GEM optimizing compiler system," </title> <journal> Digital Technical Journal, </journal> <volume> vol. 4, </volume> <pages> pp. 121-136, </pages> <year> 1992. </year>
Reference-contexts: Currently the generation of conditional move instructions is very limited in most compilers. One exception is the DEC GEM compiler that can efficiently generate conditional moves for simple control constructs <ref> [18] </ref>. Select. The select instruction provides more flexibility than the conditional move instruction at the expense of pipeline implementation. The added flexibility and increased difficulty of implementation is caused by the addition of a third source operand.
Reference: [19] <author> P. G. Lowney et al., </author> <title> "The Multiflow trace scheduling compiler," </title> <journal> The Journal of Supercomputing, </journal> <volume> vol. 7, </volume> <pages> pp. 51-142, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: As a result, select instructions enable more efficient transformations by the compiler. This will be discussed in more detail in the next section. The Multiflow Trace 300 series machines supported partial predicated execution with select instructions <ref> [19] </ref>. 3 Compiler Support The compiler eliminates branch instructions by introducing conditional instructions. The basic transformation is known as if-conversion [9] [10]. In our approach, full predicate support is assumed in the intermediate representation (IR) regardless of the the actual architectural support in the target processor.
Reference: [20] <author> W. W. Hwu et al., </author> <title> "The Superblock: An effective technique for VLIW and superscalar compilation," </title> <journal> The Journal of Supercomputing, </journal> <volume> vol. 7, </volume> <pages> pp. 229-248, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Figure 6 shows the assembly code for the most important loop segment from the benchmark grep. The base processor model, which does not support any predicated execution, employs speculative execution in conjunction with superblock ILP compilation techniques to achieve the schedule shown in Figure 6 (a) <ref> [20] </ref>. Each of the conditional branches in the figure are very infrequently taken, thus the sequence of instructions iterates very frequently. Overall, grep is dominated by an extremely high frequency of branches. <p> The baseline processor does not support any form of predicated execution. However, it includes non-excepting or silent versions of all instructions to fully support speculative execution. Superblock ILP compilation techniques are utilized to support the baseline processor <ref> [20] </ref>. The baseline processor is referred to as Superblock in all graphs and tables. For partial predicate support, the baseline processor is extended to support conditional move instructions.
References-found: 20

