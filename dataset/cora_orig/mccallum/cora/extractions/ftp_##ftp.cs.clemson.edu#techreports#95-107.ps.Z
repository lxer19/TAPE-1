URL: ftp://ftp.cs.clemson.edu/techreports/95-107.ps.Z
Refering-URL: http://www.cs.clemson.edu/html/research/techrpt.shtml
Root-URL: http://www.cs.clemson.edu
Email: steve@cs.clemson.edu  
Phone: (803)-656-5880  
Title: The Constructive Foundations of the System eb  
Author: D. E. Stevenson 
Address: Clemson SC 29634-1906  
Affiliation: Department of Computer Science Clemson University  
Abstract: We report on the programming system eb that supports computational science and engineering. eb has the constructive philosophy begun by Bishop. This philosophy is explained in enough detail to show how this view is acceptable to, but different from, -calculus and Martin-Lof theories. eb raises a theoretical question of semantics: how to guarantee that the language as implemented works as intended by the constructive reals model? The eb system is currently in "bootstrap" mode. We discuss the implementation of this bootstrap as well as plans for the future. This implementation is a source to source translator to C. Primitive types in eb are mul-tiprecision integers and floating point. As innovations, eb supports both functional and relational models, is nondeterministic, and uses failure as a control mechanism. Keywords Numerical programming (computational science and engineering), functional logic programming. Word Count 4999. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hassan At-Kaci. </author> <title> Warren's Abstract Machine: a tutorial reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year> <month> 6 </month>
Reference-contexts: The strong nature of the "fail" concept in constructive thinking is reminiscent of Prolog and Snobol. We therefore choose the Warren Abstract Machine <ref> [1] </ref> as the sequence control virtual machine. There are, of course, other machine models and a number of Prolog compiling systems: SICStus Prolog, BIM Prolog, PDC Prolog, and Wamcc to name just a few.
Reference: [2] <author> David H. Bailey. </author> <title> A portable high performance mul--tiprecision package. </title> <type> Technical Report RNR-90-022, </type> <institution> NASA Ames Laboratory, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: The underlying data operational model for the bootstrap is multiprecision integers and rationals as provided by [19] and multiprecision Wilkinson sets as provided by <ref> [2] </ref>. The system is compilable using the current version of gcc and bison. Language Syntax. The language syntax is strongly influenced by current functional languages such as haskell but with major differences: * Type syntax is not yet set.
Reference: [3] <author> H. P. Barendregt. </author> <title> Lambda Calculus: Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North Holland, </publisher> <year> 1981. </year>
Reference-contexts: Therefore, subject to that review, the underlying operational ideas seem consistent with our view. There are certain pre-theoretical issues: the concept of improper functions or abstractors. The idea of the -calculus is bound up in the abstraction/conversion rules <ref> [3] </ref>. However, the definition of such abstractors is two operations: substitution and rewriting. The use of -expressions in the functional languages makes use of only one pair. But we will want at least two modes of computing (relational and functional); we have two abstractors: for functional and for relational. <p> There is no harm in thinking Lisp and Prolog respectively. Part of our language is thus a -calculus and a -calculus. 3 Concepts of Abstraction-MetaProgramming. In com-puter science, there seems to be two meanings to the word abstraction. The first is the -calculus with - abstraction coupled with fi-conversion <ref> [3] </ref>. The second meaning of abstraction is usually meant data abstraction. But there is a third, more subtle meaning. Consider writing a program to heap sort integers. For this program to run, there can be no unspecified details. Assume we have perfect knowledge of semantics.
Reference: [4] <author> J. Bates and R. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1), </volume> <year> 1985. </year>
Reference-contexts: Types. Although there is some argument for just accepting a Hindley-Milner type system and be done with it, this seems counter to the strong constructivist basis of the system. There is plenty to investigate. There are several systems, such as Nuprl <ref> [4, 13] </ref> and Larch [21], that include intentional information concerning types. Larch is not constructive but Nuprl is. Again, the dualistic nature of constructionism causes us to pause and determine where we should go from here. But even to bootstrap, some initial decisions must be made. Elementary Data Types.
Reference: [5] <author> M. J. Beeson. </author> <title> Formalizing constructive mathematics: Why and how? In F. Richman, editor, Constructive Mathematics: Proceedings of the New Mexico State University Conference Held at Las Cruces, </title> <address> New Mexico, </address> <month> August 11-15, </month> <title> 1980. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: MT is the proposals of Per Martin-Lof, also familiar to this readership. MT is close to RA and B, differing in the details. Bishop's view [10, 11] is that every theorem should have numerical content and computational meaning. In Beeson's original paper <ref> [5] </ref>, there are lengthy comparisons of the various viewpoints. Bishop's desire was to have a system that could be useful to any and all mathematicians, from his own followers to the classical. We concentrate here on B and our support through a new system eb.
Reference: [6] <author> Michael J. Beeson. </author> <title> Foundations of Constructive Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Finally, we provide a comprehensive review in Section 5. 2 The Constructive Approach There are two major approaches to understanding computing: logistic and constructive. There are two standard logistic schools of programming: Floyd-Hoare and Dijkstra. There are seven schools of constructive mathematics as outlined in <ref> [6] </ref>. Any of these would probably serve as a basis for programming languages. The schools of interest are recursive analysis RA, Martin-Lof theories MT, and Bishop constructivism B. RA is recursive functions, -calculus, and classical logic oriented. MT is the proposals of Per Martin-Lof, also familiar to this readership. <p> Notions play an important role in constructive logics. 2.2 Our Program The goal is to constructively attach programs to constructive real number as outlined in Bishop-Bridges [11]. The organization of our effort, shown in Table 1, is due to Beeson <ref> [6] </ref>, to which we have added epistemology. The job during the ontology phase is to uncover the fundamental objects of M and the fundamental relations of these objects. <p> The axiomatic method is a desirable attack on any body of knowledge. The obvious task during ax-iomitization is to isolate facts (pretheoretical concepts) and state these facts in terms of the fundamentals. For insights on the development of an area by the axiomatic method, see <ref> [6, 39, 41] </ref>. The axiomatic method tries to take a body of informal activities (read Mathematics) M and produce a theory (or maybe even theories) T that explain M . The advantages of this method are (i) conceptual clarity, (ii) rigor, and (iii) generality. <p> Data/Name Control. The situation here is undefined. Again, the problem is the change in focus. Conventional moduless may or not be useful. Problem organizations and extended procedural concepts as in Maple are under consideration. 5 Summary Pragmatics. Successful language systems are dynamic entities, each with an intended domain <ref> [6, p. 34] </ref>. Successful languages have a certain naturalness of expression within its domain and should identify itself with the pragmatics of the using population. Everyday mathematical practice is our guide. For example, higher order functions are quite common in mathematics but can have annoying implementations.
Reference: [7] <author> C. Bischof, A. Carle, G. Corliss, A. Griewank, and P. Hovland. ADIFOR: </author> <title> Generating derivative codes from Fortran programs. </title> <booktitle> Scientific Programming, </booktitle> <month> Summer </month> <year> 1992. </year>
Reference-contexts: We have a natural need for partial evaluation [26]. But precision considerations should not be a reason for two programs. And should not the compiler know about Horner's rule or be able to differentiate a program <ref> [7] </ref>? Dualistic Nature. The declarative (model theoretic) and operational (proof theoretic) nature seems worth preserving. We want to make symmetric use of these capabilities. The ` ' and ` e ' are a formalization of this. This symmetric language needs uniformity of notation.
Reference: [8] <author> Errett Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Our view is that since we cannot construct an object satisfying 0 = 1 we should fail in the same sense that Prolog fails. This makes clear the relational nature of BBB. 3.2 The Numbers In Bishop <ref> [8] </ref>, a real number is taken as a regular sequence of rational numbers. A sequence x is regular if jx m x n j m + n : Due to our mathematical training, programmers want to make floating point synonymous with real numbers as in [30].
Reference: [9] <author> Errett A. Bishop. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year>
Reference-contexts: Perhaps the most eloquent proponent of the Brouwer's view was Heyting [24] who created much of the formal logic structure for construc-tivity. Kleene played a large role [28] by developing RA. Bishop's ideas are appealing because they hold the fewest number of assumptions. Errett Bishop <ref> [9] </ref> was no fan of the overly formalized Heyting approach. Bishop's idea of "proof" was "any completely convincing argument." However, proof is not an end in itself: working scientists and mathematicians are looking for insight as to why things are as they are.
Reference: [10] <author> Errett A. Bishop. </author> <title> Mathematics as a numerical language. </title> <editor> In A. Kino, J. Myhill, and R. E. Vesley, editors, </editor> <booktitle> Intuitionism and Proof Theory, </booktitle> <pages> pages 53-71. </pages> <publisher> North Holland, </publisher> <year> 1967. </year>
Reference-contexts: The schools of interest are recursive analysis RA, Martin-Lof theories MT, and Bishop constructivism B. RA is recursive functions, -calculus, and classical logic oriented. MT is the proposals of Per Martin-Lof, also familiar to this readership. MT is close to RA and B, differing in the details. Bishop's view <ref> [10, 11] </ref> is that every theorem should have numerical content and computational meaning. In Beeson's original paper [5], there are lengthy comparisons of the various viewpoints. Bishop's desire was to have a system that could be useful to any and all mathematicians, from his own followers to the classical.
Reference: [11] <author> Errett J. Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: For this A 3 structure to have coherence, we must have an unbroken trail from the scientist to the programmer and back. In keeping with [36], we view our world constructively in the Errett Bishop sense <ref> [11] </ref>. Models are usually based on classical analysis; numerical analysis is a bridge between classical analysis and rational numbers. Numerical methods rely on a very finite subset of numbers. By their very nature, numerical methods must be constructive. <p> The schools of interest are recursive analysis RA, Martin-Lof theories MT, and Bishop constructivism B. RA is recursive functions, -calculus, and classical logic oriented. MT is the proposals of Per Martin-Lof, also familiar to this readership. MT is close to RA and B, differing in the details. Bishop's view <ref> [10, 11] </ref> is that every theorem should have numerical content and computational meaning. In Beeson's original paper [5], there are lengthy comparisons of the various viewpoints. Bishop's desire was to have a system that could be useful to any and all mathematicians, from his own followers to the classical. <p> The reliance on (CT) places great emphasis on decidability. Following [43], we call a notion A a decidable property of predicate A. Notions play an important role in constructive logics. 2.2 Our Program The goal is to constructively attach programs to constructive real number as outlined in Bishop-Bridges <ref> [11] </ref>. The organization of our effort, shown in Table 1, is due to Beeson [6], to which we have added epistemology. The job during the ontology phase is to uncover the fundamental objects of M and the fundamental relations of these objects.
Reference: [12] <author> L. E. J. Brouwer. Collected Works I. North Hol-land, </author> <year> 1975. </year>
Reference-contexts: It was Kant's position that only counting mattered. In the nineteenth century, the constructive view was held by many, including Gauss, Dedekind, Kronecker, and Brouwer. Brouwer <ref> [12] </ref> disagreed with Hilbert.[25]. The argument started over the set paradoxes. Perhaps the most eloquent proponent of the Brouwer's view was Heyting [24] who created much of the formal logic structure for construc-tivity. Kleene played a large role [28] by developing RA.
Reference: [13] <author> R. L. Constable. </author> <title> Implementing mathematics with the Nuprl proof development system. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: There are a number of functional/logical programming systems: Alf, Babel, Escher, Godel, Pro-log, and Life as well as functional and logic programming languages. Our focus is totally on numerical programming. We are therefore also influenced by systems like Maple and Mathematica. To our knowledge, only NuPRL <ref> [13] </ref> has the same view of constructivity as we. We begin by outlining the logistic and constructive concepts necessary to understand constructive analysis. We outline our program in 2.2. Section 3 discusses the implications of the program, discussing each element in detail. <p> Types. Although there is some argument for just accepting a Hindley-Milner type system and be done with it, this seems counter to the strong constructivist basis of the system. There is plenty to investigate. There are several systems, such as Nuprl <ref> [4, 13] </ref> and Larch [21], that include intentional information concerning types. Larch is not constructive but Nuprl is. Again, the dualistic nature of constructionism causes us to pause and determine where we should go from here. But even to bootstrap, some initial decisions must be made. Elementary Data Types.
Reference: [14] <author> Herbert. B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: If R satisfies a set of axioms, R is called a model of those axioms. Models serve as bases of interpretation of formal languages <ref> [29, 14, 45] </ref>. We must have a less strict view of model because we want to have a relational structure F that approximates R, the reals. 3.4 Formal and Informal Proofs Proofs in constructive theories are more complicated than those in classical theories.
Reference: [15] <author> S. Feferman. </author> <title> Constructive theories of functions and classes. </title> <editor> In M. Boffa, D. van Dalen, and K. McAloon, editors, </editor> <booktitle> Logic Colloquia 1978 Mons, number 97 in Stud. Logic Found Math., </booktitle> <pages> pages 159-224. </pages> <publisher> North Holland, </publisher> <year> 1979. </year>
Reference-contexts: Informal Axiomatics 3. Epistemology Table 1: The Bishop-Bridges-Beeson (BBB) Program 1. Correctness. 2. Complexity. 3. Non-determinism. 4. Total/partial. 5. Representation. 6. Proof Theory. Table 2: Categorical Attributes in Algorithms. Feferman <ref> [15] </ref> defines two concepts with respect to meaningfulness: [A theory] T is an adequate formalization of [a body of of informal mathematics] M if every concept, argument and result of M may be represented by a (basic or defined) concept, proof, and theorem, respectively, of T . [A theory] T is
Reference: [16] <author> James H. </author> <title> Fetzer. Program verification: the very idea. </title> <journal> CACM, </journal> <volume> 31(9), </volume> <year> 1988. </year>
Reference-contexts: What is the purpose of loop-invariants? To capture semantic information from the problem and translate this information into logical constraints. In this way, a program becomes associated with the problem the program is to solve. Consider, now, Fetzer's conclusion <ref> [16] </ref>: "Algorithms, as logical structures, are appropriate subjects for deductive verification. Programs, as causal models of those structures, are not." Total semantics represents the logical structure when machine level semantics are abstracted into the intentional part and are therefore capable of deductive verification.
Reference: [17] <author> G. E. Forsythe and C. B. Moler. </author> <title> Computer Solutions of Linear Algebraic Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1967. </year>
Reference-contexts: Since they use constructive techniques, 4 followers of Bishop will not be able to blindly follow classically defined work like [30]. As programmers, we instead think about the set of numbers of the form mfib s in the Wilkinson set <ref> [44, 17] </ref>: m fi b 2 W (b; t; e min ; e max ): These numbers are canonical elements in the sense of [31]. This is the set of rational numbers that can be formed using b-base arithmetic, with the mantissa m normalized with t b-units.
Reference: [18] <author> Nicholas D. Goodman. </author> <title> Reflections on Bishop's philosophy of mathematics. In Constructive mathematics : proceedings of the New Mexico State University conference held at Las Cruces, </title> <address> New Mexico, </address> <month> August 11-15, </month> <year> 1980, 1981. </year>
Reference-contexts: But even the constructionists differ on the question of existence. As an example, consider Euclid's proof of the existence of an infinite number of primes. The proof is constructive (gives a procedure) but goes on "forever." Does a countably infinite number of steps constitute a legal algorithm? Goodman <ref> [18] </ref> holds to the view that the question is one feasibility rather than the number of steps. Induction often commits us to nonconstructive steps and the use of classical logic.
Reference: [19] <author> Torbjorn Granlund. </author> <title> The GNU Multiprecision Arithmetic Library. Free Software Foundation, </title> <address> gmp 1.3.2 edition, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: There are, of course, other machine models and a number of Prolog compiling systems: SICStus Prolog, BIM Prolog, PDC Prolog, and Wamcc to name just a few. The underlying data operational model for the bootstrap is multiprecision integers and rationals as provided by <ref> [19] </ref> and multiprecision Wilkinson sets as provided by [2]. The system is compilable using the current version of gcc and bison. Language Syntax. The language syntax is strongly influenced by current functional languages such as haskell but with major differences: * Type syntax is not yet set.
Reference: [20] <author> Newcomb Greenleaf. </author> <title> Liberal constructive set theory. In Constructive mathematics : proceedings of the New Mexico State University conference held at Las Cruces, </title> <address> New Mexico, </address> <month> August 11-15, </month> <year> 1980, 1981. </year>
Reference-contexts: But how long and how much space is needed for a construction? Sedlin [35] introduces the concept of semiconstructive to describe "computations" of countably infinite length. To Bishop, the question was "what must one do to construct" an object <ref> [20] </ref>. Sets in B, for example, are developed in three stages: (1) describe a process to construct an arbitrary object; (2) describe a process for testing equality; and (3) verify that the equality relation so defined is indeed an equivalence relation. A (classical) set without equality is called a preset. <p> A (classical) set without equality is called a preset. There are two interpretations of sets: the Cantorian view that the elements come first; the Fregian view is that the set is a "framework" within which elements can be created <ref> [20, p. 221] </ref>. Bishop follows the Fregian framework. Propositions are presets whose elements are proofs. A proposition of a statement A is constructed by describing what must be done to construct a proof of A in a completely convincing manner [20, p. 218]. <p> Bishop follows the Fregian framework. Propositions are presets whose elements are proofs. A proposition of a statement A is constructed by describing what must be done to construct a proof of A in a completely convincing manner <ref> [20, p. 218] </ref>. A proposition is meaningful in that they supply a completely genuine description. The constructivist view is that certain formal propositions in classical mathematics are not meaningful; hence, classical proof-theoretic derivability can be deficient in meaning. 2 1.
Reference: [21] <author> John Guttag. </author> <title> Larch: languages and tools for formal specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Types. Although there is some argument for just accepting a Hindley-Milner type system and be done with it, this seems counter to the strong constructivist basis of the system. There is plenty to investigate. There are several systems, such as Nuprl [4, 13] and Larch <ref> [21] </ref>, that include intentional information concerning types. Larch is not constructive but Nuprl is. Again, the dualistic nature of constructionism causes us to pause and determine where we should go from here. But even to bootstrap, some initial decisions must be made. Elementary Data Types.
Reference: [22] <author> Fred Hennie. </author> <title> Introduction to Computability. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: However, we must make some crucial early decisions. In general, we want to adhere as closely as we can to the standard models of computation. We therefore want to reconsider the basic outline of Rogers [33, pp. 1-5] and Hennie <ref> [22] </ref>. While most of the points in the cited Rogers work seem acceptable, there may be hidden classical logic constraints. Therefore, subject to that review, the underlying operational ideas seem consistent with our view. There are certain pre-theoretical issues: the concept of improper functions or abstractors.
Reference: [23] <author> Wim H. Hesselink. </author> <title> Programs, Recursion and Unbounded Choice. </title> <booktitle> Number 27 in Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Language Syntax. The language syntax is strongly influenced by current functional languages such as haskell but with major differences: * Type syntax is not yet set. See below. * The language uses Dijkstra's guarded commands as described in <ref> [23] </ref>. * Multiple abstractor types: for functional opera tion and for relational operation. Types. Although there is some argument for just accepting a Hindley-Milner type system and be done with it, this seems counter to the strong constructivist basis of the system. There is plenty to investigate.
Reference: [24] <author> Arend Heyting. </author> <title> Intuitionism: an introduction. </title> <publisher> North-Holland, </publisher> <address> 3 edition, </address> <year> 1971. </year>
Reference-contexts: It was Kant's position that only counting mattered. In the nineteenth century, the constructive view was held by many, including Gauss, Dedekind, Kronecker, and Brouwer. Brouwer [12] disagreed with Hilbert.[25]. The argument started over the set paradoxes. Perhaps the most eloquent proponent of the Brouwer's view was Heyting <ref> [24] </ref> who created much of the formal logic structure for construc-tivity. Kleene played a large role [28] by developing RA. Bishop's ideas are appealing because they hold the fewest number of assumptions. Errett Bishop [9] was no fan of the overly formalized Heyting approach.
Reference: [25] <author> David Hilbert. </author> <title> Mathematical problems. Bull. </title> <editor> A. M. S., </editor> <volume> 8 </volume> <pages> 437-479, </pages> <year> 1902. </year> <title> Original; also published in Archiv der Mathematik und Physik, </title> <booktitle> 3rd series, </booktitle> <volume> vol 1, </volume> <year> 1901, </year> <note> pp 44-63 and 213- 237. </note>
Reference: [26] <author> Neil D. Jones, Carsten K. Gomard, and Peter Ses-toft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Maple is actually more of an exemplar than Fortran. We must be careful, however, not to fall into the trap of software bloat in numerical codes [27]. We have a natural need for partial evaluation <ref> [26] </ref>. But precision considerations should not be a reason for two programs. And should not the compiler know about Horner's rule or be able to differentiate a program [7]? Dualistic Nature. The declarative (model theoretic) and operational (proof theoretic) nature seems worth preserving.
Reference: [27] <author> W. Kahan. </author> <title> Analysis and refutation of the LCAS. </title> <journal> SIGPlan Notices, </journal> <volume> 27(1) </volume> <pages> 61-74, </pages> <year> 1992. </year>
Reference-contexts: In our domain, partial functions are a way of life since finite numerical approximations are often wildly discontinuous functions. Maple is actually more of an exemplar than Fortran. We must be careful, however, not to fall into the trap of software bloat in numerical codes <ref> [27] </ref>. We have a natural need for partial evaluation [26]. But precision considerations should not be a reason for two programs. And should not the compiler know about Horner's rule or be able to differentiate a program [7]? Dualistic Nature.
Reference: [28] <author> S. C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> North Holland Publishing Company, </publisher> <year> 1971. </year> <note> Original 1952. </note>
Reference-contexts: Brouwer [12] disagreed with Hilbert.[25]. The argument started over the set paradoxes. Perhaps the most eloquent proponent of the Brouwer's view was Heyting [24] who created much of the formal logic structure for construc-tivity. Kleene played a large role <ref> [28] </ref> by developing RA. Bishop's ideas are appealing because they hold the fewest number of assumptions. Errett Bishop [9] was no fan of the overly formalized Heyting approach.
Reference: [29] <author> Jacques Loeckx and Kurt Sieber. </author> <title> The Foundations of Program Verification. </title> <publisher> Wiley Teubner Series in Computer Science. Wiley, </publisher> <year> 1984. </year>
Reference-contexts: If R satisfies a set of axioms, R is called a model of those axioms. Models serve as bases of interpretation of formal languages <ref> [29, 14, 45] </ref>. We must have a less strict view of model because we want to have a relational structure F that approximates R, the reals. 3.4 Formal and Informal Proofs Proofs in constructive theories are more complicated than those in classical theories.
Reference: [30] <author> Saunders MacLane and Garrett Birkhoff. </author> <title> Algebra. </title> <publisher> The MacMillan Company, </publisher> <year> 1967. </year>
Reference-contexts: A sequence x is regular if jx m x n j m + n : Due to our mathematical training, programmers want to make floating point synonymous with real numbers as in <ref> [30] </ref>. Since they use constructive techniques, 4 followers of Bishop will not be able to blindly follow classically defined work like [30]. <p> is regular if jx m x n j m + n : Due to our mathematical training, programmers want to make floating point synonymous with real numbers as in <ref> [30] </ref>. Since they use constructive techniques, 4 followers of Bishop will not be able to blindly follow classically defined work like [30]. As programmers, we instead think about the set of numbers of the form mfib s in the Wilkinson set [44, 17]: m fi b 2 W (b; t; e min ; e max ): These numbers are canonical elements in the sense of [31].
Reference: [31] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <editor> In L. J. Cohen, editor, </editor> <booktitle> Logic, Methodology, and Philosophy of Science VI, </booktitle> <pages> pages 153-179. </pages> <publisher> North-Holland Publishing Co, </publisher> <year> 1982. </year>
Reference-contexts: As programmers, we instead think about the set of numbers of the form mfib s in the Wilkinson set [44, 17]: m fi b 2 W (b; t; e min ; e max ): These numbers are canonical elements in the sense of <ref> [31] </ref>. This is the set of rational numbers that can be formed using b-base arithmetic, with the mantissa m normalized with t b-units. Such numbers have their scale values e min s e max . An example is the Sun's single-precision IEEE set (2; 24; 125; 128).
Reference: [32] <author> Nils Nilsson. </author> <booktitle> Problem-Solving Methods in Artificial Intelligence. </booktitle> <publisher> McGraw-Hill, </publisher> <year> 1971. </year>
Reference: [33] <author> H. R. Rogers. </author> <title> Theory of recursive functions and effective computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year>
Reference-contexts: However, we must make some crucial early decisions. In general, we want to adhere as closely as we can to the standard models of computation. We therefore want to reconsider the basic outline of Rogers <ref> [33, pp. 1-5] </ref> and Hennie [22]. While most of the points in the cited Rogers work seem acceptable, there may be hidden classical logic constraints. Therefore, subject to that review, the underlying operational ideas seem consistent with our view.
Reference: [34] <author> Dan Sahlin, Torkel Franzen, and Seif Haridi. </author> <title> An intuitionistic predicate logic theorem prover. </title> <type> Technical Report R89001/ISSN 0283-3638, </type> <institution> Swedish Institute of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: We also lose some old favorites like part of contraposition and DeMorgan's laws. It is not our purpose here to derive a constructive logic. There are constructive theorem provers <ref> [34] </ref> so manipulating such logics is well within the realm of possibility. 4 Bootstrap Version The eb system is currently in "bootstrap" mode. The compiler for the language converts eb statements to C. However, the work on the theoretical model is just be ginning. We briefly outline the current implementation.
Reference: [35] <author> Jonathin P. Seldin. </author> <title> A constructive approach to classical mathematics. In Constructive mathematics : proceedings of the New Mexico State University conference held at Las Cruces, </title> <address> New Mexico, </address> <month> August 11-15, </month> <year> 1980, 1981. </year> <month> 7 </month>
Reference-contexts: See also [40]. Construction should not be seen as a two step process of (1) creating a object by construction c and (2) proving c is a proper construction of an object in a set X. But how long and how much space is needed for a construction? Sedlin <ref> [35] </ref> introduces the concept of semiconstructive to describe "computations" of countably infinite length. To Bishop, the question was "what must one do to construct" an object [20].
Reference: [36] <author> D. E. Stevenson. </author> <title> Science, computational science, and computer science: At a crossroads. </title> <journal> Comm. ACM, </journal> <volume> 37(12) </volume> <pages> 85-96, </pages> <year> 1994. </year>
Reference-contexts: Thirty years ago, the idea of programming was supposed to be a natural one: a program is what a program does. My, how things change. Although not timed to coincide with the dubious milestone, the author <ref> [36, 37] </ref> has presented a case for computational science and engineering. Included in [36] are specific criticisms of computer science aimed at the lack of foundations taking a philosophy of mathematics stand. <p> Thirty years ago, the idea of programming was supposed to be a natural one: a program is what a program does. My, how things change. Although not timed to coincide with the dubious milestone, the author [36, 37] has presented a case for computational science and engineering. Included in <ref> [36] </ref> are specific criticisms of computer science aimed at the lack of foundations taking a philosophy of mathematics stand. Even though computer science seems to aspire to be like mathematics, it lacks the introspection on foundations necessary to achieve that goal. Last updated: July 12, 1995. <p> The focus of such a system must be on correctness and not speed since wrong answers arrived at quickly are worse than useless. Correctness has several aspects <ref> [36] </ref>: (i) application correctness as established by model verification and validation, (ii) alogorithmic correctness in the numerical analysis sense, and (iii) hardware and software architecture correctness. For this A 3 structure to have coherence, we must have an unbroken trail from the scientist to the programmer and back. <p> For this A 3 structure to have coherence, we must have an unbroken trail from the scientist to the programmer and back. In keeping with <ref> [36] </ref>, we view our world constructively in the Errett Bishop sense [11]. Models are usually based on classical analysis; numerical analysis is a bridge between classical analysis and rational numbers. Numerical methods rely on a very finite subset of numbers. By their very nature, numerical methods must be constructive. <p> Consider now a concrete program representing a model. Let's assume that the model is of billiard balls on a billiard table. Where are the objects (balls and cues)? Do they physically exist inside the computer? Objects are represented by structures, making their representation a question of modeling <ref> [36] </ref>. These structures are not the same as the objects and are not meaningful until interpreted.
Reference: [37] <author> D. E. Stevenson. </author> <booktitle> Software engineering frontiers in computational science and engineering. In Proc. 33d Annual Southeast Conference, </booktitle> <address> Clemson, SC, </address> <month> 17-18 March </month> <year> 1995, </year> <pages> pages 120-127, </pages> <year> 1995. </year>
Reference-contexts: Thirty years ago, the idea of programming was supposed to be a natural one: a program is what a program does. My, how things change. Although not timed to coincide with the dubious milestone, the author <ref> [36, 37] </ref> has presented a case for computational science and engineering. Included in [36] are specific criticisms of computer science aimed at the lack of foundations taking a philosophy of mathematics stand.
Reference: [38] <author> D. E. Stevenson. W2C: </author> <title> A WAM to C assembler. </title> <journal> J. Logic Programming, </journal> <note> 1995. submitted. </note>
Reference-contexts: The numbers and such objects as matrices are handled as atoms, but we need lots of space to share with UNIX. We have extended the concept of atom to be a pointer into high memory. This allows us to keep the size of the WAM area down. See <ref> [38] </ref>. Data/Name Control. The situation here is undefined. Again, the problem is the change in focus. Conventional moduless may or not be useful. Problem organizations and extended procedural concepts as in Maple are under consideration. 5 Summary Pragmatics.
Reference: [39] <author> Robert R. Stoll. </author> <title> Sets, Logic, and Axiomatic Theories. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <year> 1961. </year>
Reference-contexts: The axiomatic method is a desirable attack on any body of knowledge. The obvious task during ax-iomitization is to isolate facts (pretheoretical concepts) and state these facts in terms of the fundamentals. For insights on the development of an area by the axiomatic method, see <ref> [6, 39, 41] </ref>. The axiomatic method tries to take a body of informal activities (read Mathematics) M and produce a theory (or maybe even theories) T that explain M . The advantages of this method are (i) conceptual clarity, (ii) rigor, and (iii) generality.
Reference: [40] <author> G. Stolzenberg. </author> <title> Can an inquiry into the foundations of mathematics tell us anything interesting about mind? In Psychology and Biology of Language and Thought. </title> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: The question of "Is an object different than its construction" is often debated but should be seen as simply two different ways of talking about the same thing. "Objective language is more concise; operation language is more precise"[20, p. 223]. See also <ref> [40] </ref>. Construction should not be seen as a two step process of (1) creating a object by construction c and (2) proving c is a proper construction of an object in a set X.
Reference: [41] <author> Patrick Suppes. </author> <title> Introduction to Logic. </title> <editor> Van Nos-trand, </editor> <year> 1971. </year>
Reference-contexts: The axiomatic method is a desirable attack on any body of knowledge. The obvious task during ax-iomitization is to isolate facts (pretheoretical concepts) and state these facts in terms of the fundamentals. For insights on the development of an area by the axiomatic method, see <ref> [6, 39, 41] </ref>. The axiomatic method tries to take a body of informal activities (read Mathematics) M and produce a theory (or maybe even theories) T that explain M . The advantages of this method are (i) conceptual clarity, (ii) rigor, and (iii) generality.
Reference: [42] <author> David A. Sykes. Objectculture: </author> <title> Achieving Efficient Implmentation and Effective Interactions in Object-Orient Programs. </title> <type> PhD thesis, </type> <institution> Clemson University, </institution> <year> 1995. </year>
Reference-contexts: The "metalevel" of programming can be related to the idea of an oracle <ref> [42] </ref>: unfortunately, oracles imply omniscience. From earlier, we have the idea that Annotation + Construction = Algorithm: The following are all metaconcepts: machine organization (e.g., MIMD); passing method; fixed, interval or floating point computation; and inheritance. Therefore, any real development must identify all pre-theoretical ideas.
Reference: [43] <author> A. S. </author> <title> Troelstra. </title> <booktitle> Principles of Intuitionism. Number 95 in Lecture Notes in Mathematics. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1969. </year>
Reference-contexts: One interpretation of CT is that every object must have a concrete description or itself be concrete. In terms of classical logic, rules as universal instantiation must be accompanied by the substitution of a concrete object. The reliance on (CT) places great emphasis on decidability. Following <ref> [43] </ref>, we call a notion A a decidable property of predicate A. Notions play an important role in constructive logics. 2.2 Our Program The goal is to constructively attach programs to constructive real number as outlined in Bishop-Bridges [11].
Reference: [44] <author> J. H. Wilkinson. </author> <title> Rounding Errors in Algebraic Processes. </title> <publisher> Wiley, </publisher> <year> 1963. </year>
Reference-contexts: Since they use constructive techniques, 4 followers of Bishop will not be able to blindly follow classically defined work like [30]. As programmers, we instead think about the set of numbers of the form mfib s in the Wilkinson set <ref> [44, 17] </ref>: m fi b 2 W (b; t; e min ; e max ): These numbers are canonical elements in the sense of [31]. This is the set of rational numbers that can be formed using b-base arithmetic, with the mantissa m normalized with t b-units.
Reference: [45] <author> Ann Yasuhara. </author> <title> Recursive Function Theory and Logic. </title> <publisher> Academic Press, </publisher> <year> 1971. </year> <month> 8 </month>
Reference-contexts: If R satisfies a set of axioms, R is called a model of those axioms. Models serve as bases of interpretation of formal languages <ref> [29, 14, 45] </ref>. We must have a less strict view of model because we want to have a relational structure F that approximates R, the reals. 3.4 Formal and Informal Proofs Proofs in constructive theories are more complicated than those in classical theories.
References-found: 45

