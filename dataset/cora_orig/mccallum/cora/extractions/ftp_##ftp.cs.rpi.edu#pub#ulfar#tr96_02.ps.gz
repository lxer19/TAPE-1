URL: ftp://ftp.cs.rpi.edu/pub/ulfar/tr96_02.ps.gz
Refering-URL: http://www.cs.rpi.edu/~ulfar/edgs.html
Root-URL: http://www.cs.rpi.edu
Title: Generic Gram-Schmidt Orthogonalization by Exact Division  
Author: Ulfar Erlingsson Erich Kaltofen David Musser 
Abstract: Given a vector space basis with integral domain coefficients, a variant of the Gram-Schmidt process produces an orthogonal basis using exact divisions, so that all arithmetic is within the integral domain. Zero-division is avoided by the assumption that in the domain a sum of squares of nonzero elements is always nonzero. In this paper we fully develop this method and use it to illustrate and compare a variety of means for implementing generic algorithms. Previous generic programming methods have been limited to one of compile-time, link-time, or run-time instantiation of type parameters, such as the integral domain of this algorithm, but we show how to express generic algorithms in C ++ so that all three possibilities are available using a single source code. Finally, we take advantage of the genericness to test and time the algorithm using different arithmetics, including three huge-integer arithmetic packages.
Abstract-found: 1
Intro-found: 1
Reference: [Bar68] <author> E. H. Bareiss. </author> <title> Sylvester's identity and multistep integers preserving Gaussian elimination. </title> <journal> Math. Comp., </journal> <volume> 22 </volume> <pages> 565-578, </pages> <year> 1968. </year>
Reference-contexts: If the Gram-Schmidt process were performed without exact division on bases with such parametric entries, reductions by polynomial GCD computations would be performed on the intermediate rational function entries. Exact divisions can avoid the costly 1 GCD computations, as in the more classical examples by Bareiss for Gaussian elimination <ref> [Bar68] </ref> and by Brown and Traub in the subresultant PRS algorithm [Knu81]. We also consider how the exact-division Gram-Schmidt orthogonalization can be programmed generically with different techniques of instantiation of the integral domain. These techniques can be briefly characterized as compile-time, run-time, or link-time instantiation.
Reference: [GVL89] <author> Golub, G. H., Van Loan, C. F. </author> <title> Matrix Computations, 2nd Edition, </title> <publisher> The Johns Hopkins University Press, </publisher> <address> Baltimore, Maryland, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Given a basis B = fb 1 ; : : : ; b n g for R n the Gram-Schmidt orthogonalization process, as described in e.g. <ref> [GVL89] </ref>, computes an orthogonal basis B fl = fb fl n g for R n such that (b fl i ; b j ) = 0 for 1 j &lt; i n using the ordinary inner product.
Reference: [GNU93] <author> GMP 1.3.2, </author> <title> The GNU Multiple Precision Arithmetic Library, </title> <note> Torbjorn Granlund, FTP: prep.ai.mit.edu:/pub/gnu/, </note> <year> 1993. </year>
Reference-contexts: We chose three of the most popular freely available long-integer arithmetic packages and two simple arithmetics for our trials. The long-integer packages are: Lenstra's LIP package [Len89], GNU's GMP package <ref> [GNU93] </ref>, and the I arithmetic of the LiDIA project [LiD95]. The simple arithmetics were normal C ++ double floating-point arithmetic, and null arithmetic, which only counts the number of calls to each operation. We compiled the long-integer packages using GNU's gcc 2.7 C compiler, using full optimizations.
Reference: [Kal95] <author> E. Kaltofen. </author> <title> Effective Noether irreducibility forms and applications. </title> <journal> J. Comput. System Sci., </journal> <volume> 50(2) </volume> <pages> 274-295, </pages> <year> 1995. </year>
Reference-contexts: The bit complexity can then be estimated within polynomial bounds because of the lemmas stated in section 2. A similar, but more difficult analysis has been carried out for a generic factorization algorithm <ref> [Kal95] </ref>. We will also provide some test cases where the input basis contain polynomial entries.
Reference: [KL96] <author> E. Kaltofen and A. Lobo. </author> <title> Distributed matrix-free solution of large sparse linear systems over finite fields. In Proc. High Performance Computing '96, </title> <note> to appear. </note>
Reference-contexts: On the other hand the code is faster than with run-time instantiation because there is no run-time indirection in function calling. A similar approach was taken by Austin Lobo in his generic implementation of the block Wiedemann algorithm <ref> [KL96] </ref>. To the best of our knowledge, all previous discussions of generic programming have considered these methods mutually exclusive.
Reference: [Knu81] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 2, </volume> <booktitle> Seminu-merical Algorithms, </booktitle> <editor> Ed. </editor> <volume> 2. </volume> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: Exact divisions can avoid the costly 1 GCD computations, as in the more classical examples by Bareiss for Gaussian elimination [Bar68] and by Brown and Traub in the subresultant PRS algorithm <ref> [Knu81] </ref>. We also consider how the exact-division Gram-Schmidt orthogonalization can be programmed generically with different techniques of instantiation of the integral domain. These techniques can be briefly characterized as compile-time, run-time, or link-time instantiation. <p> Third and last, the actual element representation must be canonical with respect to the arithmetic operations. Otherwise, one may encounter the famous phenomenon of obtaining exponentially sized elements by keeping the occurring fractions unreduced, as in polynomial GCD computations <ref> [Knu81] </ref>, p. 414, eq. (27). The bit complexity can then be estimated within polynomial bounds because of the lemmas stated in section 2. A similar, but more difficult analysis has been carried out for a generic factorization algorithm [Kal95].
Reference: [Len89] <author> FreeLIP 1.0, </author> <title> A Free Long Integer Package, </title> <editor> Lenstra, A. K. </editor> <address> FTP: ftp.ox.ac.uk:/pub/math/freelip/, </address> <year> 1989. </year>
Reference-contexts: We chose three of the most popular freely available long-integer arithmetic packages and two simple arithmetics for our trials. The long-integer packages are: Lenstra's LIP package <ref> [Len89] </ref>, GNU's GMP package [GNU93], and the I arithmetic of the LiDIA project [LiD95]. The simple arithmetics were normal C ++ double floating-point arithmetic, and null arithmetic, which only counts the number of calls to each operation.
Reference: [LiD95] <author> LiDIA 1.1, </author> <title> A library for computational number theory, </title> <institution> LiDIA-Group, Universitat des Saarlandes, </institution> <note> FTP: crypt1.cs.uni-sb.de: /pub/systems/LiDIA, 1995. 8 </note>
Reference-contexts: We chose three of the most popular freely available long-integer arithmetic packages and two simple arithmetics for our trials. The long-integer packages are: Lenstra's LIP package [Len89], GNU's GMP package [GNU93], and the I arithmetic of the LiDIA project <ref> [LiD95] </ref>. The simple arithmetics were normal C ++ double floating-point arithmetic, and null arithmetic, which only counts the number of calls to each operation. We compiled the long-integer packages using GNU's gcc 2.7 C compiler, using full optimizations.
Reference: [LLL82] <author> Lenstra, A. K., Lenstra Jr., H. W., Lovasz, L. </author> <title> Factoring Polynomials with Rational Coefficients, </title> <journal> Mathematische Annalen, </journal> <volume> vol 261, </volume> <year> 1982. </year>
Reference-contexts: For simplicity, we shall restrict ourselves to n-dimensional spaces; all our algorithms are easily transferred to work on lower-dimensional subspaces. In <ref> [LLL82] </ref>, statement following proof of (1.28) on p. 523, the authors hint at a method for computing B fl from B using exact division in the case where B spans a subspace of D n . <p> We timed the generated code on three platforms: SUN SparcStation 2, SUN SparcStation 20, and the IBM PowerStation 320H. The two SUN platforms have different architectures for normal integer multiplication. The inputs to the long-integer executables were lattices from the factoring algorithm of <ref> [LLL82] </ref>. The input to the floating-point executable was a random matrix of single decimal digits. The results of the timed runs can be seen in the tables of figure 2.
Reference: [STL95] <author> Stepanov, A., Lee, M.. </author> <title> The Standard Template Library, </title> <institution> Hewlett-Packard Laboratories Technical Report HPL-94-34, Palo Alto, Cal-ifornia, </institution> <month> April </month> <year> 1994, </year> <note> revised October 31, </note> <year> 1995. </year>
Reference-contexts: Compile-time instantiation uses a programming language feature such as templates (in C ++ ) or generic units (in Ada). Different instances produce separate copies of the code in the executable, each tailored to the particular instance. This is the method used exclusively in the C ++ Standard Template Library <ref> [STL95] </ref>. Since functions can be inlined and optimized, compile-time instantiation generally produces the fastest code but has the disadvantages of (1) requiring recompilation of the full code for any changes and (2) "code bloat" from the repetition of the code when more than one instance is required. <p> If we are compiling for compile-time instan-tiation the bodies of the generic functions are included in the source, otherwise they are compiled separately and linked in. We then create function objects (see <ref> [STL95] </ref>) for the generic functions and use them to instantiate the arithmetic type IDE, which in turn provides the required overloaded operators.
References-found: 10

