URL: ftp://ftp.cs.utexas.edu/pub/predator/icde-11.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: fddas,batoryg@cs.utexas.edu  
Title: Prairie: A Rule Specification Framework for Query Optimizers  
Author: Dinesh Das Don Batory 
Address: Austin, Texas 78712-1188  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Date: March 1995  
Note: In Proceedings 11th International Conference on Data Engineering, pages 201-210, Taipei,  
Abstract: From our experience, current rule-based query optimizers do not provide a very intuitive and well-defined framework to define rules and actions. To remedy this situation, we propose an extensible and structured algebraic framework called Prairie for specifying rules. Prairie facilitates rule-writing by enabling a user to write rules and actions more quickly, correctly and in an easy-to-understand and easy-to debug manner. Query optimizers consist of three major parts: a search space, a cost model and a search strategy. The approach we take is only to develop the algebra which defines the search space and the cost model and use the Volcano optimizer-generator as our search engine. Using Prairie as a front-end, we translate Prairie rules to Volcano to validate our claim that Prairie makes it easier to write rules. We describe our algebra and present experimental results which show that using a high-level framework like Prairie to design large-scale optimizers does not sacrifice efficiency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. S. Batory. </author> <title> Building blocks of database management systems. </title> <type> Technical Report TR-87-23, </type> <institution> The University of Texas at Austin, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: This simply reflects the fact that traditional database systems are themselves monolithic: the algorithms used for storing and retrieving data are hardwired and are rather difficult to change. The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis <ref> [1] </ref>, EXODUS [9], Starburst [10], and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility [6, 7, 9, 10].
Reference: [2] <author> Jose A. Blakeley, William J. McKenna, and Goetz Graefe. </author> <title> Experiences building the Open OODB query optimizer. </title> <booktitle> In Proceedings 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 287-296, </pages> <address> Washington, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The query optimizer in the Open OODB <ref> [2] </ref> is generated using Volcano. It is written as a set of trans rules and impl rules that define the algebra of an object-oriented database system.
Reference: [3] <author> Dean Daniels, Patricia Selinger, Laura Haas, Bruce Lindsay, C. Mohan, Adrian Walker, and Paul Wilms. </author> <booktitle> An introduction to distributed query compilation in R fl . In Proceedings 2nd International Conference on Distributed Databases, </booktitle> <pages> pages 291-309, </pages> <address> Berlin, </address> <month> Septem-ber </month> <year> 1982. </year>
Reference-contexts: A top-down query optimizer optimizes the parents of a node prior to optimizing the node itself. A bottom-up optimizer optimizes the children of a node prior to optimizing the node. The earliest optimizers (System R [11] and R fl <ref> [3] </ref>) employed the bottom-up approach. Our research concentrates on a top-down optimization of operator trees. We have chosen this approach because we intend to translate Prairie rules into the format required by the Volcano query optimizer generator [7] which is based on a top-down strategy. <p> It was a cost-based centralized relational query optimizer and introduced a variety of key concepts like interesting expressions, cardi-nality estimation using selectivity factors and dynamic programming with pruning of search space. These concepts continue to be important in query optimizer research. The query optimizer in R fl <ref> [3] </ref> works in essentially the same way as that of System R, except that R fl is a distributed database system which introduces some subtle complica (a) Query 1 (b) Query 2 (c) Query 3 (d) Query 4 (e) Query 5 (f) Query 6 (g) Query 7 (h) Query 8 tions
Reference: [4] <author> Dinesh Das and Don Batory. Prairie: </author> <title> An algebraic framework for rule specification in query optimiz-ers. </title> <booktitle> In Proceedings of the Workshop on Database Query Optimizer Generators and Rule-Based Optimiz-ers, </booktitle> <pages> pages 139-154, </pages> <address> Dallas, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Our experiments consist of specifying rule-based optimizers using Prairie and generating optimiz-ers using the P2V pre-processor and the optimizer-generator paradigm of Figure 5. In <ref> [4] </ref>, we presented an implementation of a centralized relational query optimizer using Prairie. Using the P2V translator, we translated this to Volcano format and optimized several queries using the resultant optimizer. For comparison, we hand-coded the same optimizer directly in Volcano.
Reference: [5] <author> Dinesh Das and Don Batory. Prairie: </author> <title> A rule specification framework for query optimizers. </title> <type> Technical Report TR 94-16, </type> <institution> The University of Texas at Austin, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: This Prairie optimizer-generator paradigm is shown schematically in Figure 5. The pre-processor itself is 4500 lines of flex and bison code. In this section, we briefly describe the pre-processor steps and explain why the Prairie-to-Volcano transformation is non-trivial. A more detailed description of the pre-processor is given in <ref> [5] </ref>. The specification of an optimizer in Volcano consists of a set of transformation rules (called trans rules) and implementation rules (called impl rules), a set of properties, and some support functions.
Reference: [6] <author> Johann Christoph Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS [9], Starburst [10], and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility <ref> [6, 7, 9, 10] </ref>. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. In this paper, we describe an algebraic framework called Prairie for specifying rules in a rule-based query optimizer. <p> The plan optimization phase selects algorithms for each operator in the operator tree that is obtained after rewriting. The disadvantage of separating the query rewrite and the optimization phases is that pruning of the search space is not possible during query rewrite, since the rewrite phase is non-cost-based. Freytag <ref> [6] </ref> describes a rule-based query optimizer similar to Starburst. The rules are based on LISP-like representations of access plans. The rules themselves are recursively defined on smaller expressions (operator trees). Although several expressions can contain a common sub-expression, Freytag doesn't consider the possibility of sharing.
Reference: [7] <author> Goetz Graefe. Volcano, </author> <title> an extensible and parallel query evaluation system. </title> <type> Technical Report CU-CS-481-90, </type> <institution> University of Colorado at Boulder, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS [9], Starburst [10], and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility <ref> [6, 7, 9, 10] </ref>. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. In this paper, we describe an algebraic framework called Prairie for specifying rules in a rule-based query optimizer. <p> In this paper, we describe an algebraic framework called Prairie for specifying rules in a rule-based query optimizer. Prairie is similar to other rule specification languages like Starburst [10] and Volcano <ref> [7] </ref>, and indeed, we have based our work on Volcano to capture most of the advantages of rule-based optimizers. However, Prairie attempts to provide some key features that, we have found, simplify the effort in writing rules: 1. <p> The earliest optimizers (System R [11] and R fl [3]) employed the bottom-up approach. Our research concentrates on a top-down optimization of operator trees. We have chosen this approach because we intend to translate Prairie rules into the format required by the Volcano query optimizer generator <ref> [7] </ref> which is based on a top-down strategy. Given an appropriate search engine, Prairie can potentially also be used with a bottom-up optimization strategy; however, we will not discuss this ap proach in this paper. <p> Unlike Freytag, the optimizer generator for EXODUS allows for C code along with definitions of new rules. This allows the database implementor the freedom to associate any action with a particular rule. Operator trees in EXODUS are constructed bottom-up from previously constructed trees. The Volcano optimizer generator project <ref> [7] </ref> evolved from the EXODUS project. It is different from all the above op-timizers in one significant way: it is a top-down optimizer compared with the bottom-up strategy of the others. Operator trees are optimized starting from the root while sub-trees are not yet optimized.
Reference: [8] <author> Goetz Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Query optimization <ref> [8] </ref> is a fundamental part of database systems. It is the process of generating an efficient access plan for a database query.
Reference: [9] <author> Goetz Graefe and David J. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proceedings 1987 ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pages 387-394, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS <ref> [9] </ref>, Starburst [10], and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility [6, 7, 9, 10]. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. <p> The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS [9], Starburst [10], and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility <ref> [6, 7, 9, 10] </ref>. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. In this paper, we describe an algebraic framework called Prairie for specifying rules in a rule-based query optimizer. <p> Expressions are evaluated each time they are encountered. This is obviously inefficient. In addition, as in Starburst, he doesn't consider the cost transformations inherent in any query op timizer; rules are syntactic transformation rules. EXODUS <ref> [9] </ref> provides an optimizer generator which accepts a rule-based specification of the data model as input. The optimizer generator compiles these rules, together with pre-defined rules, to generate an optimizer for the particular data model and set of operators.
Reference: [10] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pi-rahesh. </author> <title> Extensible query processing in Starburst. </title> <type> Research Report RJ 6610, </type> <institution> IBM Almaden Research Center, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS [9], Starburst <ref> [10] </ref>, and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility [6, 7, 9, 10]. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. <p> The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS [9], Starburst [10], and Postgres [12]. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility <ref> [6, 7, 9, 10] </ref>. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. In this paper, we describe an algebraic framework called Prairie for specifying rules in a rule-based query optimizer. <p> The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm. In this paper, we describe an algebraic framework called Prairie for specifying rules in a rule-based query optimizer. Prairie is similar to other rule specification languages like Starburst <ref> [10] </ref> and Volcano [7], and indeed, we have based our work on Volcano to capture most of the advantages of rule-based optimizers. However, Prairie attempts to provide some key features that, we have found, simplify the effort in writing rules: 1. <p> The Starburst query optimizer <ref> [10] </ref> uses rules for all decisions that need to be taken by the query optimizer. The rules are functional in nature and transform a given operator tree into another. The rules are commonly those that reflect relational calculus facts.
Reference: [11] <author> P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings 1979 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, </address> <month> May </month> <year> 1979. </year>
Reference-contexts: A top-down query optimizer optimizes the parents of a node prior to optimizing the node itself. A bottom-up optimizer optimizes the children of a node prior to optimizing the node. The earliest optimizers (System R <ref> [11] </ref> and R fl [3]) employed the bottom-up approach. Our research concentrates on a top-down optimization of operator trees. We have chosen this approach because we intend to translate Prairie rules into the format required by the Volcano query optimizer generator [7] which is based on a top-down strategy. <p> The results presented in this section show that Prairie opti mizers need not sacrifice efficiency for clarity, even for large rule sets. More research and validation is necessary to verify that Prairie is an efficient tool for optimizer specification. 5 Related research The System R optimizer <ref> [11] </ref> was the most important development in query optimization research. It was a cost-based centralized relational query optimizer and introduced a variety of key concepts like interesting expressions, cardi-nality estimation using selectivity factors and dynamic programming with pruning of search space.
Reference: [12] <author> Michael Stonebraker and Lawrence A. Rowe. </author> <title> The design of Postgres. </title> <booktitle> In Proceedings 1986 ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pages 340-355, </pages> <address> Washington, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimiz-ers, has long been recognized in systems like Genesis [1], EXODUS [9], Starburst [10], and Postgres <ref> [12] </ref>. Rule-based query optimizers are among the major conceptual advances that have been proposed to deal with query optimizer extensibility [6, 7, 9, 10]. The extensibility translates into the ability to incorporate new operators, algorithms, cost models, or search strategies without changing the optimization algorithm.
References-found: 12

