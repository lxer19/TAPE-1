URL: ftp://ftp.eecs.umich.edu/groups/gasm/wamcase.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: schellhorn@informatik.uni-ulm.de)  ahrendt@ira.uka.de)  
Title: Reasoning about Abstract State Machines: The WAM Case Study  
Author: Gerhard Schellhorn Wolfgang Ahrendt 
Address: 89069 Ulm, Germany  76128 Karlsruhe, Germany  
Affiliation: (Abt. Programmiermethodik, Universitat Ulm,  (Institut fur Logik, Komplexitat und Deduktionssysteme Universitat Karlsruhe,  
Abstract: This paper describes the first half of the formal verification of a Prolog compiler with the KIV ("Karlsruhe Interactive Verifier") system. Our work is based on [BR95], where an operational Prolog semantics is defined using the formalism of Gurevich Abstract State Machines, and then refined in several steps to the Warren Abstract Machine (WAM). We define a general translation of sequential Abstract State Machines to Dynamic Logic, which formalizes correctness of such refinement steps as a deduction problem. A proof technique for verification is presented, which corresponds to the informal use of proof maps. 6 of the 12 given refinement steps were verified. We found that the proof sketches given in [BR95] hide a lot of implicit assumptions. We report on our experiences in uncovering these assumptions incrementally during formal verification, and the support KIV offers for such `evolutionary' correctness proofs. 
Abstract-found: 1
Intro-found: 1
Reference: [Ahr95] <author> Wolfgang Ahrendt. </author> <title> Von PROLOG zur WAM | Verifikation der Proze-durubersetzung mit KIV. </title> <institution> Diplomarbeit, Fakultat fur Informatik, Universitat Karlsruhe, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: Proving the refinement correct has about the same complexity as the verification of the first refinement. It was done by the second author in about a month. The most interesting point in the verification was, how the compiler assumption must be transferred to properties in the invariant (see <ref> [Ahr95] </ref>). 404 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... Verification uncovered two problems in [BR95]. The first problem was found during formalization of the l-chain function which is used in the compiler assumption.
Reference: [AK91] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine. A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: This call had to be added to the interpreter code given in Appendix 2 of [BR95]. We note that the call to the backtracking routine is present in the rules of the WAM as given in <ref> [AK91] </ref> for switch on struct and switch on const, but only implicitly assumed for the switch on term instruction. 406 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... <p> Let us remark that this code layout is not optimal (for a systematic treatment of the variants "one-level" and "two-level" switching see <ref> [AK91] </ref>). It is given only for demonstration purposes. <p> We have adopted the latter solution, which according to <ref> [AK91] </ref> is the standard one. - [BR95] does not distinguish between ASM5 and ASM6, since they have the same set of rules (except that ASM6 requires a solution to the restore cutpoint problem) and differ only in the restriction on the layout of code (l-chain vs. n-chain).
Reference: [BM79] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference: [BR94] <author> Egon Borger and Dean Rosenzweig. </author> <title> A mathematical definition of full PRO-LOG. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference: [BR95] <author> Egon Borger and Dean Rosenzweig. </author> <title> The WAM|definition and compiler correctness. </title> <editor> In Christoph Beierle and Lutz Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, volume 11 of Studies in Computer Science and Artificial Intelligence. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction The Warren Abstract Machine (WAM, [War83]) today is the most popular target of Prolog compilers. Recently, a mathematical analysis of Prolog semantics and compiler correctness has become available with the work of Borger and Rosenzweig ([BR94], <ref> [BR95] </ref>). The analysis in [BR95] starts by defining an operational semantics for Prolog in the formalism of (Gurevich) Abstract State Machines (ASMs, [Gur95]). We assume the reader to be familiar with this formalism as well as with the basic notions of Prolog (clauses with ! (cut), true and fail ). <p> 1 Introduction The Warren Abstract Machine (WAM, [War83]) today is the most popular target of Prolog compilers. Recently, a mathematical analysis of Prolog semantics and compiler correctness has become available with the work of Borger and Rosenzweig ([BR94], <ref> [BR95] </ref>). The analysis in [BR95] starts by defining an operational semantics for Prolog in the formalism of (Gurevich) Abstract State Machines (ASMs, [Gur95]). We assume the reader to be familiar with this formalism as well as with the basic notions of Prolog (clauses with ! (cut), true and fail ). <p> The compilation steps are not given as a concrete program, but specified by compiler assumptions. This still leaves some freedom for the implementation of a compiler, in particular several variants of the final WAM are still possible. Based on the analysis of <ref> [BR95] </ref> and the proof sketched in [Sch94], this paper reports on our first steps towards the formal, machine-checked verification of compiler correctness with the KIV system. <p> We want to show that Dynamic Logic (DL) as it is used in the KIV system can serve as a suitable starting point for the verification of Abstract State Machine refinements. In particular, the proof technique of commuting diagrams of Proof Maps, used informally in <ref> [BR95] </ref>, can be formalized in DL. Finally, the requirements a system for the development of correct software must cope with are only discovered in ambitious case studies. Solving these requirements always leads to significant system improvements. <p> An example will be given to explain the rules of the interpreters. We will closely follow <ref> [BR95] </ref> and 378 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... deviate only in some notations. This will set up the verification task and enable us to discuss the problems we encountered in solving it (Sect. 5). The reader who knows [Sections 1.1, 1.2] from [BR95] may <p> follow <ref> [BR95] </ref> and 378 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... deviate only in some notations. This will set up the verification task and enable us to discuss the problems we encountered in solving it (Sect. 5). The reader who knows [Sections 1.1, 1.2] from [BR95] may skip this section, and refer to it only for notational issues. 2.1 The First Interpreter: Search Trees The two most important data structures needed to represent a Prolog computation state are the sequence of Prolog literals still to be executed and the current substitution. <p> Since the father of E is the root node ?, execution would finally stop with stop = halt and subst = failure. 2.2 The Second Interpreter: Stacks of Choicepoints Here we summarize the first refinement of the ASM described above towards the Warren Abstract Machine (WAM), following <ref> [BR95] </ref>, [Section 1.2]. There are three main differences between the first and the second ASM: First, function father is renamed to b. This change indicates that b now points backwards in a chain of nodes, which form a stack. <p> This causes problems for verification (see Sect. 5). The tuple of values decglseq (n), sub (n), cll (n) and b (n) attached to a stack node n is usually called a choicepoint. Finally, it should be remarked that our compiler assumption (1) is weaker than the one given in <ref> [BR95] </ref>, which (to avoid a compilation step) identifies databases, assuming that clauses were already grouped according to different predicates on the first level, and requires procdef (act,db) = clls (procdef'(act,db),db) (2) But assumption (2) can not be fulfilled for definitions of the procdef function, which are more specific than looking only <p> To fix this problem in partial first-order logic ([Wir90], on which the recursive definitions in <ref> [BR95] </ref> are based) an explicit characterization of the domain of the least fixpoint would be required. In Dynamic Logic there is an easier way to handle the problem, since we can explicitly talk about least fixpoints. <p> Variable 389Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... val is used to store the common result value of both interpreters (this variable is not modified by ASM1# and ASM2#). The notions of Correctness and Completeness from <ref> [BR95] </ref> directly correspond to the implication from right to left and from left to right. Proof maps F are defined in [BR95] to map static algebras of a `concrete' ASM to algebras of an `abstract' ASM. They are used to sketch correctness proofs for the equivalence of two ASMs. <p> The notions of Correctness and Completeness from <ref> [BR95] </ref> directly correspond to the implication from right to left and from left to right. Proof maps F are defined in [BR95] to map static algebras of a `concrete' ASM to algebras of an `abstract' ASM. They are used to sketch correctness proofs for the equivalence of two ASMs. <p> Only the consideration of these details leads to the detection of hidden assumptions, which ultimately guarantee the correctness of the refinement. The reader who is not interested in the details may just have a look at the 9 initial properties, as they were given in <ref> [BR95] </ref> at the beginning of the following subsection, and compare them to final coupling invariant shown at the end of subsection 5.2.4. <p> Some rough indication how such an invariant might look like is already given in <ref> [BR95] </ref>, p.17f. <p> Our coupling invariant then asserts the existence of a suitable function F for every two corresponding interpreter states. F then gets updated by instantiation. Based on this dynamic function the properties listed on p.17f of <ref> [BR95] </ref> translate to the following conjuncts in our invariant (in ambiguous cases the variables of the second interpreter are primed): 9 F: 1 decglseq ^ currnode = decglseqreg 2 sub ^ currnode = subreg 3a mapcl (map (cll, cands ^ currnode),db) = mapcl (clls (cllreg,db'),db') 3b every (father,cands ^ currnode, currnode) <p> improvements of KIV saved about 1/3 of the necessary interactions (now 246). 398 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... 6 Verification of Other Refinement Steps This section summarizes our work on the verification of the refinement steps from ASM2 to ASM7 as described in <ref> [BR95] </ref>, which we have proven correct so far. We will use the abbreviation i/j to mean the refinement from ASMi to ASMj. Subsection 6.1 gives the optimizations made in the refinements from ASM2 to ASM4. <p> Verification of the first compilation step uncovered an error, which is present in the rules of all ASMs from ASM3 on. Subsection 6.3 sketches some of the problems in verifying the full compilation of backtracking structure including switching instructions. <ref> [BR95] </ref> gives this refinement in two steps, introducing ASM6 and ASM7. Unfortunately, from the verification of 5/6 we learned that splitting verification into two parts complicates the work instead of simplifying it. Therefore the equivalence proof between ASM5 and ASM7 had to be given directly. <p> Therefore we only sketch the main compilation idea and line out the main correctness arguments. For the rule set of ASM7, and to understand some of the technical remarks on the verifications problems we must refer the reader to <ref> [BR95] </ref>. The two main results of verifying 5/7 were the addition of backtracking to the switching instructions, and a precise definition of the s-chain-function which is used in the compiler assumption, given at the end of the section. <p> Verification of the refinements from ASM2 to ASM4 is easier (done in 3 weeks) than the verification of 1/2 and 4/5 done before, since coupling invariants sufficient for a correctness proof are much easier to find. Although some additional properties to the ones given in <ref> [BR95] </ref> are still necessary, (e.g. the 401Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... nodes mentioned in them have to be restricted to stack nodes), they provide a good starting point. <p> A general solution, which guarantees that correctness and completeness can be shown in one proof, will be described elsewhere. In the verification of the refinement from 3/4 we (like <ref> [BR95] </ref> too) use a coupling invariant, which relates computation states that have the same useful choicepoints with nonempty clause list. Unfortunately, with this coupling invariant proof obligation PO3 from section 4.3 (goal 9), which states that both interpreters must terminate at the same time, is not provable. <p> The most interesting point in the verification was, how the compiler assumption must be transferred to properties in the invariant (see [Ahr95]). 404 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... Verification uncovered two problems in <ref> [BR95] </ref>. The first problem was found during formalization of the l-chain function which is used in the compiler assumption. <p> L5: trust_me p (g (X)) :- body4. (24) Address T would contain a list with the single element (g,1,L7). failcode is a special code-value, which should point to the backtracking routine. This call had to be added to the interpreter code given in Appendix 2 of <ref> [BR95] </ref>. <p> Note that the compiler assumptions do not prescribe some concrete switching scheme (variants of the WAM use different ones), but only restrict the possible code layouts to reasonable ones. At this point we like to make some remarks on small deviations from <ref> [BR95] </ref>: With the introduction of subchains executing one query-literal will no longer create (at most) one choicepoint. ctreg is no longer sufficient to have the right cutpt available in enter rule. Two solutions for this restore cutpoint problem are indicated in [BR95]: Either retry and trust instructions have to be marked <p> like to make some remarks on small deviations from <ref> [BR95] </ref>: With the introduction of subchains executing one query-literal will no longer create (at most) one choicepoint. ctreg is no longer sufficient to have the right cutpt available in enter rule. Two solutions for this restore cutpoint problem are indicated in [BR95]: Either retry and trust instructions have to be marked with the depth of the corresponding subchain (indicating the depth in the stack where the correct cutpt is to be found) or ctreg has to be saved and restored as part of choicepoints. <p> We have adopted the latter solution, which according to [AK91] is the standard one. - <ref> [BR95] </ref> does not distinguish between ASM5 and ASM6, since they have the same set of rules (except that ASM6 requires a solution to the restore cutpoint problem) and differ only in the restriction on the layout of code (l-chain vs. n-chain). <p> In retrospective this was a good decision, since ASM6 does not occur in the final verification work (see below). - pcreg and pc are called p, partial functions l-chain, n-chain and s-chain are uniformly called chain in <ref> [BR95] </ref>. An informal argument for the equivalence of ASM5, ASM6 and ASM7 is that they all "execute the same candidate clauses". More precisely, they invoke the enter rule with the same activators act, and the same candidate clauses stored at pcreg. <p> In most of the proof attempts only the coupling invariant was modified. Several modifications had to be done to the s-chain-function which characterizes nested chains with switching. Our final definition of the partial s-chain-function given in the notation of p. 28 in <ref> [BR95] </ref> is as follows (abort means nontermination, the arguments db 7 and act which are actually present in our recursive program have been dropped for better readability): s-chain (Ptr) = if code (Ptr) = failcode then [] else s-ch-rec (Ptr) 409Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM <p> trust me then s-ch-rec (Ptr+) else abort s-ch-retry (Ptr) = if code (Ptr) = retry (N) then append (s-ch-rec (N),s-ch-retry (N)) else if code (Ptr) = trust (N) then s-ch-rec (N) else abort Two changes were made to the actual interpreter compared to the one shown in [Appendix 2] of <ref> [BR95] </ref>. The first one was to add backtracking to the switching instructions as already mentioned. This was done before verification. The second was, that we replaced the test, whether code (procdef (pred (act),db)) = nil in call rule of ASM7 by procdef (pred (act),db) = failcode. <p> to the use of an asymmetric proof technique using proof maps, which requires two separate large proofs for correctness and completeness for each refinement step instead of one symmetric proof. 8 Conclusion We have presented a framework for the formal verification of the Prolog to WAM compilation as given in <ref> [BR95] </ref>. The framework is based on the translation of sequential Abstract State Machines to imperative programs over algebraic specifications. With this translation correctness and completeness of the refinement between two ASMs is expressible as program equivalence in Dynamic Logic. <p> Therefore, besides the pure power of the theorem prover, the `proof engineering' support offered by the verification system (explicit proof trees, correctness management, reuse of proofs etc.) is crucial for the feasibility of the case study. Verification showed that <ref> [BR95] </ref> is indeed an excellent analysis of the compilation problem from Prolog to WAM. Nevertheless an unintended indeterminism in one of the ASMs had to be removed (6.2), and minor corrections were also necessary on the formalization of the compiler assumptions. <p> Let us conclude with an outlook on the continuing work on this case study. The next two of the remaining 6 refinement steps are concerned with the compilation of single clauses ([Section 3] in <ref> [BR95] </ref>). Their correctness should be easy to show and require no new proof techniques. New problems will have to be overcome to verify that Prolog-Terms can be represented by pointer structures (the final [Section 4] in [BR95]). <p> 6 refinement steps are concerned with the compilation of single clauses ([Section 3] in <ref> [BR95] </ref>). Their correctness should be easy to show and require no new proof techniques. New problems will have to be overcome to verify that Prolog-Terms can be represented by pointer structures (the final [Section 4] in [BR95]). Finally it would remain to verify a compiler built on the basis of the compiler assumptions.
Reference: [Gol82] <author> R. </author> <title> Goldblatt. </title> <booktitle> Axiomatising the Logic of Computer Programming. </booktitle> <publisher> Springer LNCS 130, </publisher> <year> 1982. </year>
Reference-contexts: The informal meaning of this formula: "ff terminates and ' holds afterwards" should be sufficient for the purpose of this paper. A formal definition of DL can be found in [Har84], <ref> [Gol82] </ref>. DL can be used to express total correctness of a program ff with precondition ' and postcondition as ' ! hffi . ' ! : hffi : expresses partial correctness.
Reference: [Gra96] <author> P. Graf. </author> <title> Term Indexing. </title> <publisher> Springer LNCS 1053, </publisher> <year> 1996. </year>
Reference: [Gur95] <author> M. Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Recently, a mathematical analysis of Prolog semantics and compiler correctness has become available with the work of Borger and Rosenzweig ([BR94], [BR95]). The analysis in [BR95] starts by defining an operational semantics for Prolog in the formalism of (Gurevich) Abstract State Machines (ASMs, <ref> [Gur95] </ref>). We assume the reader to be familiar with this formalism as well as with the basic notions of Prolog (clauses with ! (cut), true and fail ). The ASM is then refined in altogether 12 systematic steps to an ASM which executes WAM machine code. <p> But our correctness proofs revealed that fail rule does not invalidate its own guard, so it may be executed again, leading to an infinite loop. The rule system is therefore indeterministic (or following the terminology of <ref> [Gur95] </ref>, inconsistent), and does no longer correctly implement a Prolog interpreter.
Reference: [Har84] <author> D. Harel. </author> <title> Dynamic logic. </title> <editor> In D. Gabbay and F. Guenther, editors, </editor> <booktitle> Handbook of Philosophical Logic, </booktitle> <volume> volume 2, </volume> <pages> pages 496-604. </pages> <publisher> Reidel, </publisher> <year> 1984. </year>
Reference-contexts: The informal meaning of this formula: "ff terminates and ' holds afterwards" should be sufficient for the purpose of this paper. A formal definition of DL can be found in <ref> [Har84] </ref>, [Gol82]. DL can be used to express total correctness of a program ff with precondition ' and postcondition as ' ! hffi . ' ! : hffi : expresses partial correctness.
Reference: [Kap87] <author> S. Kaplan. </author> <title> A compiler for conditional term rewriting systems. </title> <booktitle> In 2nd Conf. on Rewriting Techniques anf Applications. Proceedings. </booktitle> <address> Bordeaux, France, </address> <publisher> Springer LNCS 256, </publisher> <year> 1987. </year>
Reference: [Moo88] <author> J Moore. Piton: </author> <title> A Verified Assembly Level Language. </title> <type> Technical report 22, </type> <institution> Computational Logic Inc., </institution> <year> 1988. </year> <note> available at the URL: http://www.cli.com. </note>
Reference: [Pus96] <author> Cornelia Pusch. </author> <title> Verification of Compiler Correctness for the WAM. </title> <booktitle> In Proc. of the 1996 Intern. Conf. on Theorem Proving in Higher Order Logics, </booktitle> <publisher> Springer LNCS, </publisher> <year> 1996. </year>
Reference-contexts: The verification effort for the four refinement steps as given in <ref> [Pus96] </ref> was 6 person months and 3500 interactions. These numbers are about two times the numbers we got for the verification of the three refinements to reach ASM4.
Reference: [Rei95] <author> W. Reif. </author> <title> The KIV-approach to Software Verification. </title> <editor> In M. Broy and S. Jahnichen, editors, KORSO: </editor> <title> Methods, Languages, and Tools for the Construction of Correct Software Final Report. </title> <publisher> Springer LNCS 1009, </publisher> <year> 1995. </year>
Reference: [RS95] <author> W. Reif and K. Stenzel. </author> <title> Reuse of Proofs in Software Verification. </title> <editor> In J. Kohler, editor, </editor> <title> Workshop on Formal Approaches to the Reuse of Plans, Proofs, and Programs. </title> <address> Montreal, Quebec, </address> <year> 1995. </year>
Reference: [RSS95] <author> W. Reif, G. Schellhorn, and K. Stenzel. </author> <title> Interactive Correctness Proofs for Software Modules Using KIV. </title> <booktitle> In Tenth Annual Conference on Computer Assurance, </booktitle> <publisher> IEEE press. NIST, </publisher> <address> Gaithersburg (MD), USA, </address> <year> 1995. </year>
Reference-contexts: In this case even our liberalized compiler assumption requires duplication of Prolog code (code will be shared again, when switching instructions are introduced). 3 KIV The KIV system ([Rei95], <ref> [RSS95] </ref>, [RS95],[RSS97]) is an advanced tool for engineering high assurance systems. It supports the entire design process from formal, algebraic specifications to executable verified code. <p> The proof strategy is based on induction, symbolic evaluation of programs and on simplification for first-order theories. With these "tactics", goals of the underlying sequent calculus are reduced to simpler ones until axioms are reached. To automate proofs, KIV offers a number of heuristics, see <ref> [RSS95] </ref>. These can be chosen freely, and changed any time during the proof. Heuristics may be adapted to specific applications without changing the implementation. Usually, the heuristics manage to find 80 - 100 % of the required proof steps automatically.
Reference: [RSS97] <author> W. Reif, G. Schellhorn, and K. Stenzel. </author> <title> Proving System Correctness with KIV 3.0. </title> <booktitle> In 14th International Conference on Automated Deduction. Proceedings, </booktitle> <publisher> LNCS. </publisher> <address> Townsville, Australia, </address> <publisher> Springer, </publisher> <year> 1997. </year> <note> to appear. </note>
Reference-contexts: stack ^ ?62 stack ^ n 6= ? ^ n 62 stack ^ F ^ ? = ? ! F d (F + n / n', decglseqreg) = F d (F, decglseqreg) (19) After the work on this refinement, the KIV system was improved from the experiences we learned (see <ref> [RSS97] </ref>). Most notable improvements were to the heuristics for unfolding procedures, for loops, and for quantifier instantiation. Also an additional heuristic for the elimination of selectors similar to the one in NQTHM ([BM79]) was added. Efficiency of rewriting was improved by using compiled discrimination nets (see [Kap87],[Gra96]).
Reference: [Sch94] <author> Peter H. Schmitt. </author> <title> Proving WAM compiler correctness. </title> <type> Interner Bericht 33/94, </type> <institution> Universitat Karlsruhe, Fakultat fur Informatik, </institution> <year> 1994. </year>
Reference-contexts: The compilation steps are not given as a concrete program, but specified by compiler assumptions. This still leaves some freedom for the implementation of a compiler, in particular several variants of the final WAM are still possible. Based on the analysis of [BR95] and the proof sketched in <ref> [Sch94] </ref>, this paper reports on our first steps towards the formal, machine-checked verification of compiler correctness with the KIV system. <p> There an auxiliary function F is suggested, which maps the nodes in the stack (built by the second ASM) to corresponding nodes in the tree (built by the first ASM) (see Fig. 12.). 392 Schellhorn G., Ahrendt W.: Reasoning about Abstract State Machines: The WAM ... <ref> [Sch94] </ref> pointed out that F cannot be given statically, but has to be defined by induction on the number of rule applications. That is, in terms of our ASM1# procedure mentioned above, induction on the number of loop iterations. <p> In <ref> [Sch94] </ref> this was added to the coupling invariant together with the equations: 10 stop = stop' ^ mode = mode' ^ vi = vi' Formulas 1 - 10 formed the first version of the coupling invariant INV (x,x') when we began verification with the KIV system.
Reference: [SW83] <author> D. T. Sanella and M. Wirsing. </author> <title> A kernel language for algebraic specification and implementation. </title> <booktitle> In Coll. on Foundations of Computation Theory, </booktitle> <publisher> Springer LNCS 158. </publisher> <address> Linkoping, Sweden, </address> <year> 1983. </year>
Reference-contexts: It supports the entire design process from formal, algebraic specifications to executable verified code. KIV relies on first-order algebraic specifications to describe hierarchically structured systems in the style of ASL, <ref> [SW83] </ref>: Specifications are built up from elementary first-order specifications with the operations enrichment, union, renaming, parameterization and actualization. Their semantics is the class of all models (loose semantics). Generation principles (also called reachability constraints) like "nat generated by 0, succ" restrict the semantics to term-generated models.
Reference: [War83] <author> D.H.D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical note 309, </type> <institution> Artificial Intelligence Center, SRI International, </institution> <year> 1983. </year>
Reference-contexts: 1 Introduction The Warren Abstract Machine (WAM, <ref> [War83] </ref>) today is the most popular target of Prolog compilers. Recently, a mathematical analysis of Prolog semantics and compiler correctness has become available with the work of Borger and Rosenzweig ([BR94], [BR95]).
Reference: [Wir90] <author> M. Wirsing. </author> <title> Algebraic Specification, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, chapter 13, </booktitle> <pages> pages 675 - 788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference: [You88] <author> W. D. Young. </author> <title> A Verified Code Generator for a Subset of Gypsy. </title> <type> Technical report 33, </type> <institution> Computational Logic Inc., </institution> <year> 1988. </year> <note> available at the URL: http://www.cli.com. 413Schellhorn G., </note> <author> Ahrendt W.: </author> <title> Reasoning about Abstract State Machines: The WAM </title> ... 
Reference-contexts: From the work on formal system-supported verification of compilers we exemplarily want to mention the work with NQTHM on the formal verification of a compiler for an imperative language ([Moo88], <ref> [You88] </ref>). This work is based on the notion of "interpreter equivalence" which is quite similar to our notion of equivalence of ASMs. It also contains a lot of references to related work.
References-found: 21

