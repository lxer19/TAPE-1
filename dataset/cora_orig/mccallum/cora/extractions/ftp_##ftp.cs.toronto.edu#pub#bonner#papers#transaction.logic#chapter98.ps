URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/chapter98.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Title: 1 A LOGIC FOR PROGRAMMING DATABASE TRANSACTIONS  
Author: Anthony J. Bonner and Michael Kifer 
Abstract: We propose an extension of classical predicate calculus, called Transaction Logic, which provides a logical foundation for the phenomenon of state changes in logic programs and databases. Transaction Logic comes with a natural model theory and a sound and complete proof theory. The proof theory not only verifies programs, but also executes them, which makes this logic an ideal tool for declarative programming of database transactions and state-modifying logic programs. The semantics of Transaction Logic leads naturally to features whose amalgamation in a single logic has proved elusive in the past. These features include hypothetical and committed updates, dynamic constraints on transaction execution, non-determinism, and bulk updates. Finally, Transaction Logic holds promise as a logical model of hitherto non-logical phenomena, including so-called procedural knowledge in AI, and the behavior of object-oriented databases, especially methods with side effects. This paper presents the semantics of Transaction Logic and a sound and complete SLD-style proof theory for a Horn-like subset of the logic. 
Abstract-found: 1
Intro-found: 1
Reference: [Abi88] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Intl. Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference-contexts: Furthermore, the calculus itself is very limited as a programming language, since it has no mechanism for defining recursion or subroutines. Abiteboul-Vianu's Update Languages. Abiteboul and Vianu developed a family of Datalog-style update languages <ref> [AV91; Abi88] </ref>, including comprehensive results on complexity and expressibility. Unlike Transaction Logic, these languages are not part of a full logic: arbitrary logical formulas cannot be constructed, and although there is an operational semantics, there is no corresponding model theory and no logical inference system.
Reference: [ABW88] <author> K.R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kauf-mann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: This is possible because, like classical Horn rules, a set of serial-Horn rules has a unique minimal Herbrand model. In fact, much of the theory of negation in classical logic programs carries over to Transaction logic programs in a straightforward way, including familiar notions like stratification <ref> [ABW88] </ref> and local stratification [Prz88]. However, negation is not the subject of this paper, and the interested reader is referred to [BK94; BK95] for details. Although serial-Horn T R is a very expressive logic, some useful programs are non-Horn. Programs with negated premises are just one example.
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Through its oracle mechanism, T R can use the theory to specify the semantics of database states and elementary actions. Horn T R can then combine these actions into complex programs, and full T R can reason about them. However, from the perspective of database theory <ref> [AHV95; Ull88] </ref>, Reiter's theory of database evolution is quite unusual. For instance, a database state is usually modeled as set of relations or logical formulas; but in Reiter's theory, a state is identified with a sequence of actions.
Reference: [All84] <author> J.F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: The repertoire of executional constraints expressible in T R is very large. It is easy to specify that transactions must overlap, start or end simultaneously, one should terminate after the other, etc. In [BK95] we show that the full set of temporal relationships of Allen's logic of time intervals <ref> [All84] </ref> has a simple and natural representation in T R.
Reference: [AU79] <author> A.V. Aho and J.D. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-120, </pages> <year> 1979. </year>
Reference-contexts: Unfortunately, this means that much of the familiar database and logic programming methodology does not apply. For instance, although transitive closure is trivial to express in a deductive database, it cannot be expressed by the databases of Reiter's theory, since transitive closure is not first-order definable <ref> [AU79] </ref>. The lack of a minimal-model semantics also complicates the representation of relational databases. Instead of representing them as sets of ground atomic formulas in the usual way, the theory uses Clark's completion [Llo87; Rei84], which, in the case of databases, requires very large first-order formulas.
Reference: [AV90] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> Second, they do not support subtransactions, save-points, or partial abort and rollback. Third, there is no facility for constraining program execution, and program output is the only concern. Fourth, there is no support for subroutines. This can be seen most clearly in the procedural languages defined in <ref> [AV90] </ref>. This lack of subroutines is reflected in the PSPACE data complexity of some of the languages, since subroutines would lead to alternating PSPACE, that is, EXPTIME [Bon]. 1.7.2 Logics for Reasoning about Programs Dynamic Logic and Process Logic.
Reference: [AV91] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, the calculus itself is very limited as a programming language, since it has no mechanism for defining recursion or subroutines. Abiteboul-Vianu's Update Languages. Abiteboul and Vianu developed a family of Datalog-style update languages <ref> [AV91; Abi88] </ref>, including comprehensive results on complexity and expressibility. Unlike Transaction Logic, these languages are not part of a full logic: arbitrary logical formulas cannot be constructed, and although there is an operational semantics, there is no corresponding model theory and no logical inference system.
Reference: [Ban86] <author> F. Bancilhon. </author> <title> A logic-programming/Object-oriented cocktail. </title> <journal> SIG-MOD Record, </journal> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates either in databases or in logic program LOGIC FOR TRANSACTIONS 3 ming <ref> [Bee92; Ban86; PDR91] </ref>. In particular, database transaction languages are not founded on action logics, the way that query languages are founded on classical logic. The main reason, we believe, is that reasoning about action is not the same thing as declarative programming, especially in a database context.
Reference: [Bee92] <author> C. Beeri. </author> <title> New data models and languages|The challenge. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> New York, </address> <month> June </month> <year> 1992. </year> <note> ACM. 46 LOGICS FOR DATABASES AND INFORMATION SYSTEMS </note>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates either in databases or in logic program LOGIC FOR TRANSACTIONS 3 ming <ref> [Bee92; Ban86; PDR91] </ref>. In particular, database transaction languages are not founded on action logics, the way that query languages are founded on classical logic. The main reason, we believe, is that reasoning about action is not the same thing as declarative programming, especially in a database context.
Reference: [BK] <author> A.J. Bonner and M. Kifer. </author> <title> Reasoning about action in transaction logic. In preparation. Presented at the Dagstuhl Seminar on Logic Databases and the Meaning of Change, </title> <month> September 23-27 </month> <year> 1996, </year> <booktitle> International Conference and Research Center for Computer Science, </booktitle> <address> Schloss Dagstuhl, Wadern, Germany. </address>
Reference-contexts: The solution actually consists of two parts: (i) a general logic of state change, and (ii) a Horn-like fragment that supports logic programming. In the Horn fragment, users specify and execute transaction programs; and in the full logic, users can express properties of programs and reason about them <ref> [BK] </ref>. This paper first develops the syntax and semantics of the full logic. The rest of the paper then develops the Horn fragment, and shows that it provides a logic-programming language with updates. <p> A logical axiomatization of elementary operations is needed only for reasoning about the properties of actions, not for programming and executing them. Such axiomatizations can be carried out in full T R <ref> [BK] </ref>, but are not considered in this paper because they are not needed for logic programming. <p> In contrast, the frame problem is a central issue in the situation calculus [MH69; Rei91]. The frame problem is also an issue in full T R when it is used to reason about the properties of actions, a context in which frame axioms are unavoidable <ref> [BK] </ref>. Reiter's Theory of Database Evolution. Although the "main stream" of AI was treating the situation calculus as a mere curiosity for almost 30 years, it has recently received renewed development by Reiter.
Reference: [BK94] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The reader is referred to <ref> [BK95; BK94] </ref> for further discussion. <p> In fact, much of the theory of negation in classical logic programs carries over to Transaction logic programs in a straightforward way, including familiar notions like stratification [ABW88] and local stratification [Prz88]. However, negation is not the subject of this paper, and the interested reader is referred to <ref> [BK94; BK95] </ref> for details. Although serial-Horn T R is a very expressive logic, some useful programs are non-Horn. Programs with negated premises are just one example. Other examples involve dynamic constraints applied to programs that are serial-Horn (see Section 1.2.4).
Reference: [BK95] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http:// www.cs.toronto.edu/~bonner/transaction-logic.html. </note>
Reference-contexts: Transaction Logic (or T R for short) is a general logic of state change that accounts for database updates and transactions and for important related phenomena, such as the order of update operations, transaction abort and rollback, savepoints, and dynamic constraints <ref> [BK95; Bon97c] </ref>. T R has applications in many areas, including databases, logic programming, workflow management, and artificial intelligence. These applications, both practical and theoretical, are discussed in detail in [BK95; Bon97c]. <p> transactions and for important related phenomena, such as the order of update operations, transaction abort and rollback, savepoints, and dynamic constraints <ref> [BK95; Bon97c] </ref>. T R has applications in many areas, including databases, logic programming, workflow management, and artificial intelligence. These applications, both practical and theoretical, are discussed in detail in [BK95; Bon97c]. For instance, in logic programming, T R provides a clean, logical alternative to the assert and retract operators of Prolog. In relational databases, T R provides a logical language for programming transactions, for updating database views, and for specifying active rules. <p> Due to lack of space, many interesting applications cannot be described here. Likewise, that part of the logic that deals with hypothetical actions is omitted, together with the corresponding applications, such as counterfactuals. The interested reader is referred to <ref> [BK95; BKC94] </ref> for a development of these aspects of T R. Extensions of T R for dealing with concurrency and communication are described in [BK96; Bon97c], and complexity results are given in [Bon]. 2 1.2 OVERVIEW AND INTRODUCTORY EXAMPLES Specifying and executing T R programs is similar to using Prolog. <p> For instance, databases could be deductive, object-oriented, disjunctive, or a collection of scientific objects, such as matrices or DNA sequences. Likewise, database operations could include SQL-style bulk updates <ref> [BK95] </ref>, or the insertion and deletion of rules, or complex scientific calculations, such as the Fourier transform and matrix inversion. 1.2.1 Simple Transactions In T R, all transactions are a combination of queries and updates. Queries do not change the database, and can be expressed in classical logic. <p> All other atoms are updates. 2 12 LOGICS FOR DATABASES AND INFORMATION SYSTEMS The next example uses robot actions to illustrate non-deterministic rules. Planning of robot actions is discussed in detail in <ref> [BK95] </ref>. Example 1.2.5 (Non-deterministic, Recursive Robot Actions) The following transaction base simulates the movements of a robot arm in a world of toy blocks. <p> Formally, the following is true: 7 P; D; D 0 j= (lost.ins _ found.ins) ^ (lost.ins _ won.ins) iff D 0 = D + flostg In this way, classical conjunction reduces non-determinism and, in this particular example, yields a completely deterministic transaction. 2 In <ref> [BK95] </ref>, we explore the potential of T R for expressing constraints. Much of this expressiveness comes from serial conjunction, especially when combined with negation. <p> For example, the last formula can be rewritten as : . The repertoire of executional constraints expressible in T R is very large. It is easy to specify that transactions must overlap, start or end simultaneously, one should terminate after the other, etc. In <ref> [BK95] </ref> we show that the full set of temporal relationships of Allen's logic of time intervals [All84] has a simple and natural representation in T R. <p> Likewise, p.del (x) 2 O t (D 1 ; D 2 ) iff D 2 = D 1 fp (x)g. SQL-style bulk updates can also be defined by the transition oracle <ref> [BK95; BKC94] </ref>, as can primitives for creating new constant symbols. Scientific Oracles. A state is a set of square matrices. <p> The reader is referred to <ref> [BK95; BK94] </ref> for further discussion. <p> This section defines the serial-Horn subset of T R and develops its proof theory. Unlike classical logic programming, the proof procedure presented in this section computes new database states as well as query answers. A detailed development along with a proof of soundness and completeness can be found in <ref> [BK95] </ref>. Serial-Horn programs are based on the idea of a serial goal. A serial goal is a transaction formula of the form a 1 a 2 ::: a n , where each a i is an atomic formula and n 0. <p> In fact, much of the theory of negation in classical logic programs carries over to Transaction logic programs in a straightforward way, including familiar notions like stratification [ABW88] and local stratification [Prz88]. However, negation is not the subject of this paper, and the interested reader is referred to <ref> [BK94; BK95] </ref> for details. Although serial-Horn T R is a very expressive logic, some useful programs are non-Horn. Programs with negated premises are just one example. Other examples involve dynamic constraints applied to programs that are serial-Horn (see Section 1.2.4). <p> Observe that in addition to serial conjunction, this formula involves classical conjunction, disjunction and negation. These kinds of dynamic constraints are described in detail in <ref> [BK95] </ref>. 1.6.1 Inference We now describe an inference system, called = I , for checking statements of the form P; D 0 --- j= (9) , i.e., that a transaction, (9) , can successfully execute starting from state D 0 . <p> We shall see that certain inference strategies generate the execution path in a way that corresponds to the intuitive notion of transaction execution. In particular, top-down inference corresponds to forward execution (the normal kind), and bottom-up inference corresponds to reverse execution (as described later). In <ref> [BK95] </ref>, we also introduce a dual system, = II , which is useful for bottom-up transaction execution. Additionally, when hypothetical transactions are allowed, [BK95] describes = 3 |a uniform inference system that amalgamates = I and = II , and is complete even in the presence of hypothetical modal operators. <p> In particular, top-down inference corresponds to forward execution (the normal kind), and bottom-up inference corresponds to reverse execution (as described later). In <ref> [BK95] </ref>, we also introduce a dual system, = II , which is useful for bottom-up transaction execution. Additionally, when hypothetical transactions are allowed, [BK95] describes = 3 |a uniform inference system that amalgamates = I and = II , and is complete even in the presence of hypothetical modal operators. These systems are all formulated as natural deduction systems. However, it is also possible to formulate them as refutation systems. <p> Likewise, by constructing the deduction from the bottom, up, the database is systematically updated from D n to D n1 : : : to D 0 . We call this reverse execution. The process of constructing deductions and executing transactions is developed in detail in <ref> [BK95] </ref>. 34 LOGICS FOR DATABASES AND INFORMATION SYSTEMS 1.6.3 Example: Inference with Unification As in Prolog, our inference system returns a substitution. The substitution specifies values of the free variables for which the transaction succeeds. <p> This section examines a selection of closely related works. A more comprehensive comparison can be found in <ref> [BK95] </ref>. For convenience, we divide the formalisms into two classes: those aimed at specifying database transactions, and those aimed at reasoning about programs. <p> Furthermore, an execution path in Dynamic Prolog consists of the initial and the final state only, and it does not record the intermediate states. As a consequence, it is impossible to express constraints on transaction execution, such as those needed for advanced applications in AI, workflow management, etc. <ref> [BK95; DKRR97] </ref>. LDL. Naqvi and Krishnamurthy [NK88] extended Datalog with update operators, which were later incorporated in the LDL language [NT89]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [NK88; NT89] is somewhat limited. <p> The main motivation here is that parallel actions make bulk updates easy to express, which is LOGIC FOR TRANSACTIONS 37 an important database feature. However, there are several disadvantages in the way this is achieved. First, the calculus cannot express the kind of dynamic constraints that T R can <ref> [BK95] </ref>, while T R expresses bulk updates through other means [BKC94; BK95]. Second, parallel actions greatly complicate the semantics, since they require a minimality principle, which makes the algebra non-monotonic even in the absence of negation. Third, the syntax is not closed. <p> However, there are several disadvantages in the way this is achieved. First, the calculus cannot express the kind of dynamic constraints that T R can [BK95], while T R expresses bulk updates through other means <ref> [BKC94; BK95] </ref>. Second, parallel actions greatly complicate the semantics, since they require a minimality principle, which makes the algebra non-monotonic even in the absence of negation. Third, the syntax is not closed. For instance, negation can be applied to some formulas but not to others.
Reference: [BK96] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The interested reader is referred to [BK95; BKC94] for a development of these aspects of T R. Extensions of T R for dealing with concurrency and communication are described in <ref> [BK96; Bon97c] </ref>, and complexity results are given in [Bon]. 2 1.2 OVERVIEW AND INTRODUCTORY EXAMPLES Specifying and executing T R programs is similar to using Prolog. To specify programs, the user writes a set of logical formulas. These formulas define transactions, including queries, updates, or a combination of both.
Reference: [BKC94] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: Due to lack of space, many interesting applications cannot be described here. Likewise, that part of the logic that deals with hypothetical actions is omitted, together with the corresponding applications, such as counterfactuals. The interested reader is referred to <ref> [BK95; BKC94] </ref> for a development of these aspects of T R. Extensions of T R for dealing with concurrency and communication are described in [BK96; Bon97c], and complexity results are given in [Bon]. 2 1.2 OVERVIEW AND INTRODUCTORY EXAMPLES Specifying and executing T R programs is similar to using Prolog. <p> Likewise, p.del (x) 2 O t (D 1 ; D 2 ) iff D 2 = D 1 fp (x)g. SQL-style bulk updates can also be defined by the transition oracle <ref> [BK95; BKC94] </ref>, as can primitives for creating new constant symbols. Scientific Oracles. A state is a set of square matrices. <p> However, there are several disadvantages in the way this is achieved. First, the calculus cannot express the kind of dynamic constraints that T R can [BK95], while T R expresses bulk updates through other means <ref> [BKC94; BK95] </ref>. Second, parallel actions greatly complicate the semantics, since they require a minimality principle, which makes the algebra non-monotonic even in the absence of negation. Third, the syntax is not closed. For instance, negation can be applied to some formulas but not to others.
Reference: [Bon] <author> A.J. Bonner. </author> <title> The power of cooperating transactions. </title> <note> Submitted for publication. </note>
Reference-contexts: The interested reader is referred to [BK95; BKC94] for a development of these aspects of T R. Extensions of T R for dealing with concurrency and communication are described in [BK96; Bon97c], and complexity results are given in <ref> [Bon] </ref>. 2 1.2 OVERVIEW AND INTRODUCTORY EXAMPLES Specifying and executing T R programs is similar to using Prolog. To specify programs, the user writes a set of logical formulas. These formulas define transactions, including queries, updates, or a combination of both. <p> Fourth, there is no support for subroutines. This can be seen most clearly in the procedural languages defined in [AV90]. This lack of subroutines is reflected in the PSPACE data complexity of some of the languages, since subroutines would lead to alternating PSPACE, that is, EXPTIME <ref> [Bon] </ref>. 1.7.2 Logics for Reasoning about Programs Dynamic Logic and Process Logic. Dynamic Logic [Har79] and Process Logic [HKP82] allow a user to express properties of procedural programs and to reason about them. 13 Dynamic Logic reasons about the initial and final states of program execution.
Reference: [Bon97a] <author> A.J. Bonner. </author> <title> Intuitionistic deductive databases and the polynomial time hierarchy. </title> <journal> Journal of Logic Programming, </journal> <volume> 33(1) </volume> <pages> 1-47, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results.
Reference: [Bon97b] <author> A.J. Bonner. </author> <title> A logical semantics for hypothetical rulebases with deletion. </title> <journal> Journal of Logic Programming, </journal> <volume> 32(2) </volume> <pages> 119-170, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results.
Reference: [Bon97c] <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Estes Park, Colorado, </address> <month> August </month> <year> 1997. </year> <note> Springer Verlag. Long version available at http://www.cs.toronto.edu/~bonner/papers.html #transaction-logic. </note>
Reference-contexts: Transaction Logic (or T R for short) is a general logic of state change that accounts for database updates and transactions and for important related phenomena, such as the order of update operations, transaction abort and rollback, savepoints, and dynamic constraints <ref> [BK95; Bon97c] </ref>. T R has applications in many areas, including databases, logic programming, workflow management, and artificial intelligence. These applications, both practical and theoretical, are discussed in detail in [BK95; Bon97c]. <p> transactions and for important related phenomena, such as the order of update operations, transaction abort and rollback, savepoints, and dynamic constraints <ref> [BK95; Bon97c] </ref>. T R has applications in many areas, including databases, logic programming, workflow management, and artificial intelligence. These applications, both practical and theoretical, are discussed in detail in [BK95; Bon97c]. For instance, in logic programming, T R provides a clean, logical alternative to the assert and retract operators of Prolog. In relational databases, T R provides a logical language for programming transactions, for updating database views, and for specifying active rules. <p> The interested reader is referred to [BK95; BKC94] for a development of these aspects of T R. Extensions of T R for dealing with concurrency and communication are described in <ref> [BK96; Bon97c] </ref>, and complexity results are given in [Bon]. 2 1.2 OVERVIEW AND INTRODUCTORY EXAMPLES Specifying and executing T R programs is similar to using Prolog. To specify programs, the user writes a set of logical formulas. These formulas define transactions, including queries, updates, or a combination of both. <p> This system executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Other transactional features such as abort, rollback, and savepoints are also handled by the theorem prover <ref> [Bon97c] </ref>. This section provides simple examples showing how this kind of behavior can be carried out within a completely logical framework. The examples also illustrate several dimensions of T R's capabilities. One of these capabilities should be mentioned at the outset: nondeterministic transactions.
Reference: [BSR96] <author> A. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput workflow management. </title> <booktitle> In Intl. Conference on Extending Database Technology, number 1057 in Lec REFERENCES 47 ture Notes in Computer Science, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, March 25-29 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In database applications, SQL statements are the basic building blocks. In scientific and engineering programs, basic operations include Fourier transforms, matrix inversion, least-squares fitting, and operations on DNA sequences [GRS94; MBDH83]. In workflow management systems, elementary operations can include any number of application programs and legacy systems <ref> [BSR96] </ref>. In all cases, the elementary operations are building blocks from which larger programs and software systems are built. Although elementary operations can vary dramatically, the logic for combining them does not. In fact, the same control features arise over-and-over again.
Reference: [CH80] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Golog. Levesque et al have recently developed Golog, a procedural language for programming complex actions, including database transactions [LRL + 97]. Syntactically, Golog is similar to the procedural database language QL developed by Chandra and Harel <ref> [CH80] </ref> extended with subroutines and nondeterministic choice. Semantically, however, Golog is much more complex, since the meaning of elementary actions is specified in the situation calculus, and the meaning of larger programs is specified by formulas of second-order logic.
Reference: [Che91] <author> W. Chen. </author> <title> Declarative specification and evaluation of database updates. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases, volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> Chen's Calculus. Chen developed a calculus and an equivalent algebra for constructing transactions <ref> [Che91] </ref>. Like T R, this calculus uses logical operators to construct database transactions from elementary updates. There are several differences however. First, the calculus is not part of a full logic. Second, it assumes that databases are relational. Third, it has a very different semantics for conjunction. <p> Because of his interest in deontic concepts, McCarty defines two notions of satisfaction. In one notion, called "strict satisfaction," the conjunction ^ corresponds to parallel action, as it does in Chen's work <ref> [Che91] </ref>. In the other notion, called "satisfaction," the same symbol corresponds to constraints, as it does in T R. However, since the focus of this work was on strict satisfaction, the development of dynamic constraints was never considered.
Reference: [DKRR97] <author> H. Davulcu, M. Kifer, C.R. Ramakrishnan, and I.V. Ramakrishnan. </author> <title> Logic based modelling and analysis of workflows. </title> <note> in preparation, </note> <month> October </month> <year> 1997. </year>
Reference-contexts: Furthermore, an execution path in Dynamic Prolog consists of the initial and the final state only, and it does not record the intermediate states. As a consequence, it is impossible to express constraints on transaction execution, such as those needed for advanced applications in AI, workflow management, etc. <ref> [BK95; DKRR97] </ref>. LDL. Naqvi and Krishnamurthy [NK88] extended Datalog with update operators, which were later incorporated in the LDL language [NT89]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [NK88; NT89] is somewhat limited.
Reference: [End72] <author> H.B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: The notion of executional entailment provides a logical account of execution, and is described in more detail in Section 1.6.2. 1.5.1 Path Structures and Models This section makes the preceding discussion precise. The formal definition of path structures relies on the familiar notion of classical first-order semantic structures <ref> [End72] </ref>. The symbol j= c denotes satisfaction in these structures, i:e:, classical satisfaction. For our purposes, it is convenient to augment these classical structures with a special, abstract structure, denoted &gt;. We define &gt; to satisfy every first-order formula.
Reference: [Fin86] <author> J. </author> <title> Finger. Exploiting Constraints in Design Synthesis. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1986. </year>
Reference-contexts: Of course, this dictum is completely contrary to the idea of database views, in which virtual data depends on base data and can change as an indirect effect of database updates. In AI terminology, this is an example of the ramification problem <ref> [Fin86; Rei95] </ref>. To account for views, Reiter treats view definitions as integrity constraints that must be maintained by the transaction system. In this approach, views are not defined by Horn rules. Instead, the axioms of the transaction system are modified to treat views as stored data.
Reference: [GL88] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Logic Programming: Proceedings of the Fifth Conference and Symposium, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: For one thing, stating that a database state is a first-order formula does not determine the set of truths about that state. This is because in databases and logic programming, one usually assigns a non-standard semantics to database states, e.g., Clark's completion, a perfect-model, or a well-founded model semantics <ref> [Llo87; VRS91; GL88] </ref>. Because of this, we have chosen to insulate the dynamic aspects of transaction execution from the static aspects pertaining to the truth at database states. <p> The transition oracle provides primitives for adding and deleting clauses to/from states. Generalized-Horn Oracles. A state id D is a set of generalized-Horn rules and O d (D) is a classical Herbrand model of D. Such oracles can represent Horn rule-bases, stratified rule-bases, locally-stratified rule-bases, rule-bases with stable-model semantics <ref> [GL88] </ref>, and any rule-base whose meaning is given by a classical Herbrand model. Again, one may want to augment O d (D) with the rules in D.
Reference: [GM95] <author> G. Grahne and A.O. Mendelzon. </author> <title> Updates and subjunctive queries. </title> <journal> Information and Computation, </journal> <volume> 116(2) </volume> <pages> 241-252, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Unfortunately, there is no general solution to the practical problem of how oracles can best be implemented. For the classical oracle described above, the problem has been partly solved by Grahne, Mendelzon, and Winslett <ref> [GM95; Win88] </ref>. Winslett showed that, in general, the problem of updating propositional formulas is NP-hard. Subsequently, though, Grahne and Mendelzon proved that updating sets of ground atoms with arbitrary propositional formulas can be done in polynomial time.
Reference: [GRS94] <author> Nathan Goodman, Steve Rozen, and Lincoln Stein. </author> <title> Requirements for a deductive query language in the MapBase genome-mapping database. </title> <editor> In Raghu Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases, </booktitle> <pages> pages 259-278. </pages> <publisher> Kluwer, </publisher> <year> 1994. </year> <note> ftp:// genome.wi.mit.edu/pub/papers/Y1994/requirements.ps. </note>
Reference-contexts: In Prolog, asserting or retracting a clause is elementary. In database applications, SQL statements are the basic building blocks. In scientific and engineering programs, basic operations include Fourier transforms, matrix inversion, least-squares fitting, and operations on DNA sequences <ref> [GRS94; MBDH83] </ref>. In workflow management systems, elementary operations can include any number of application programs and legacy systems [BSR96]. In all cases, the elementary operations are building blocks from which larger programs and software systems are built. Although elementary operations can vary dramatically, the logic for combining them does not.
Reference: [Har79] <author> D. Harel. </author> <title> First-Order Dynamic Logic, </title> <booktitle> volume 68 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: This philosophy is quite different from the situation calculus [MH69] and from approaches based on dynamic and process logics <ref> [Har79; HKP82] </ref>, where queries and updates are represented by different classes of syntactic objects (e.g., predicates vs. function terms vs. modal operators). The rest of this section illustrates our notation and the capabilities of T R through a number of simple examples. <p> This lack of subroutines is reflected in the PSPACE data complexity of some of the languages, since subroutines would lead to alternating PSPACE, that is, EXPTIME [Bon]. 1.7.2 Logics for Reasoning about Programs Dynamic Logic and Process Logic. Dynamic Logic <ref> [Har79] </ref> and Process Logic [HKP82] allow a user to express properties of procedural programs and to reason about them. 13 Dynamic Logic reasons about the initial and final states of program execution.
Reference: [HKP82] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidability, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: This philosophy is quite different from the situation calculus [MH69] and from approaches based on dynamic and process logics <ref> [Har79; HKP82] </ref>, where queries and updates are represented by different classes of syntactic objects (e.g., predicates vs. function terms vs. modal operators). The rest of this section illustrates our notation and the capabilities of T R through a number of simple examples. <p> This lack of subroutines is reflected in the PSPACE data complexity of some of the languages, since subroutines would lead to alternating PSPACE, that is, EXPTIME [Bon]. 1.7.2 Logics for Reasoning about Programs Dynamic Logic and Process Logic. Dynamic Logic [Har79] and Process Logic <ref> [HKP82] </ref> allow a user to express properties of procedural programs and to reason about them. 13 Dynamic Logic reasons about the initial and final states of program execution. <p> Note that in the case of Horn databases, which is the main focus of this paper, inconsistency is not possible, so &gt; does not make any difference. 13. A number of different process logics have been proposed in the literature, beginning with Pratt's original work [Pra79]. The version in <ref> [HKP82] </ref> is closer to T R than any other incarnation of Process Logic we are aware of. 14. Here we use the syntax of T R, which can be translated into the original syntax of [MvdM92]. 15.
Reference: [Kif95] <author> M. Kifer. </author> <title> Deductive and object-oriented data languages: A quest for integration. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases, Lecture Notes in Computer Science, </booktitle> <pages> pages 187-212, </pages> <address> Sin-gapore, </address> <month> December </month> <year> 1995. </year> <title> Springer-Verlag. Keynote address at the 3d Intl. </title> <booktitle> Conference on Deductive and Object-Oriented databases. </booktitle>
Reference-contexts: In object-oriented databases, T R can be combined with object-oriented logics, such as F-logic [KLW95], to provide a logical account of methods|procedures hidden inside objects that manipulate these objects' internal states <ref> [Kif95] </ref>. In AI, T R suggests a logical account of procedural knowledge and planning, and of subjunctive queries and counterfactuals. Other Logics. <p> This approach provides a flexible framework within which users can make many kinds of distinctions, if they wish. For instance, a uniform treatment of queries and updates is needed in the object-oriented domain, because object-oriented systems do not sharply distinguish between state-changing and information-retrieving methods <ref> [Kif95] </ref>. On the other hand, if a syntactic dis 8 LOGICS FOR DATABASES AND INFORMATION SYSTEMS tinction is desired, then two sorts of predicates could be used, one for queries, and one for updating transactions.
Reference: [KL92] <author> M. Kifer and E.L. Lozinskii. </author> <title> A logic for reasoning with inconsistency. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(2) </volume> <pages> 179-215, </pages> <month> November </month> <year> 1992. </year> <note> 48 LOGICS FOR DATABASES AND INFORMATION SYSTEMS </note>
Reference-contexts: Having &gt; is convenient because it provides a degree of tolerance to inconsistency that may exist between database states and views over them. 12 It is also a simple adaptation of techniques used in paraconsistent logics (e:g:, <ref> [KL92] </ref>), which analyze the knowledge contained in inconsistent states. The reader is referred to [BK95; BK94] for further discussion.
Reference: [KLW95] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <pages> pages 741-843, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: In relational databases, T R provides a logical language for programming transactions, for updating database views, and for specifying active rules. In object-oriented databases, T R can be combined with object-oriented logics, such as F-logic <ref> [KLW95] </ref>, to provide a logical account of methods|procedures hidden inside objects that manipulate these objects' internal states [Kif95]. In AI, T R suggests a logical account of procedural knowledge and planning, and of subjunctive queries and counterfactuals. Other Logics.
Reference: [KM92] <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowledge base and revising it. </title> <editor> In P. Gardenfors, editor, </editor> <title> Belief Revision, </title> <booktitle> volume 29 of Cambridge Tracts in Theoretical Computer Science, </booktitle> <pages> pages 183-203. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This is sufficient for relational databases, which are sets of ground atomic formulas. For more complex databases, insertion and deletion are more complex operations <ref> [KM92] </ref>. Note, however, that insertion and deletion are not built into the semantics of T R. In fact, T R is not committed to any particular set of elementary updates. Thus, there is no intrinsic connection between the names p, p.ins and p.del. <p> especially if :b itself is not explicitly present in the database? Or, is insertion of fqg into fp :qg the same as the insertion into fq :pg? There is no "one true answer" to this question, and many 18 LOGICS FOR DATABASES AND INFORMATION SYSTEMS solutions have been proposed (see <ref> [KM92] </ref> for a comprehensive discussion). Furthermore, Katsuno and Mendelzon [KM92] pointed out that, generally, state transitions belong to two major categories|updates and revisions|and, even within each category, several different flavours of such transitions are worth looking at. <p> the database? Or, is insertion of fqg into fp :qg the same as the insertion into fq :pg? There is no "one true answer" to this question, and many 18 LOGICS FOR DATABASES AND INFORMATION SYSTEMS solutions have been proposed (see <ref> [KM92] </ref> for a comprehensive discussion). Furthermore, Katsuno and Mendelzon [KM92] pointed out that, generally, state transitions belong to two major categories|updates and revisions|and, even within each category, several different flavours of such transitions are worth looking at. Thus, there appears to be no small, single set of elementary state transitions that is best for all purposes. <p> The transition oracle defines primitives for adding and removing formulas from the database, resolving any conflicts between the new formulas and existing formulas. Such conflicts can be resolved in numerous ways, as shown by Katsuno and Mendelzon <ref> [KM92] </ref>. For instance, for each first-order formula, , the transition oracle could define four predicates, update [], erase [], revise [] and contract [] for doing updates, erasure, revision, and contraction as defined in [KM92]. Well-Founded Oracle. <p> Such conflicts can be resolved in numerous ways, as shown by Katsuno and Mendelzon <ref> [KM92] </ref>. For instance, for each first-order formula, , the transition oracle could define four predicates, update [], erase [], revise [] and contract [] for doing updates, erasure, revision, and contraction as defined in [KM92]. Well-Founded Oracle. A state id D is a set of generalized-Horn rules, 11 and O d (D) is the set of literals (both positive and negative) in the well-founded model of D [VRS91].
Reference: [Kow92] <author> R.A. Kowalski. </author> <title> Database updates in event calculus. </title> <journal> Journal of Logic Programming, </journal> 12(1&2):121-146, January 1992. 
Reference-contexts: The second author was supported in part by NSF grant IRI9404629. Support from the Computer Systems Research Institute of University of Toronto is also gratefully acknowledged. Notes 1. As opposed to using the Event Calculus to simulate updates <ref> [Kow92] </ref>. 2. Additional information on T R, including a prototype implementation, a tutorial, and benchmark tests, is available at www.cs.toronto.edu/~bonner/transaction-logic.html 3.
Reference: [LHL95] <author> B. Ludascher, U. Hamann, and G. Lausen. </author> <title> A logical framework for active rules. </title> <booktitle> In Proceedings of the 7th Intl. Conference on Management of Data, </booktitle> <address> Pune, India, </address> <month> December </month> <year> 1995. </year> <note> Tata McGrow-Hill. </note>
Reference-contexts: Likewise, there are many kinds of updates that Golog cannot represent, including the insertion of rules into deductive databases, and the insertion of disjunctions into disjunctive databases. Datalog with State. A number of researchers have worked on adding a notion of state to Datalog programs <ref> [Zan93; LHL95] </ref>. In these works, states are represented through a special, distinct argument, which is added to each updatable predicate. Updates are then modeled as state transitions. This approach can be viewed as an adaptation of the situation calculus to Dat-alog. <p> This approach can be viewed as an adaptation of the situation calculus to Dat-alog. As such, it has several important differences with Reiter's theory of database evolution and with Golog. First, unlike Reiter's theory, Datalog with state uses a form of closed-world semantics (XY-stratification [Zan93] or state-stratification <ref> [LHL95] </ref>), which is closer to the database tradition. Moreover, unlike Reiter's theory, Datalog with state has no problem in representing database views, recursive or otherwise. Second, actions in Datalog with state are limited to the insertion and deletion of ground atomic formulas.
Reference: [LLL + 94] <author> Y. Lesperance, H. Levesque, F. Lin, D. Marcu, and R. Reiter. </author> <title> A logical approach to high-level robot programming-a progress report. In Control of the Physical World by Intelligent Systems, </title> <booktitle> Working Notes of the 1994 AAAI Fall Symposium. </booktitle> <publisher> AAAI Press, </publisher> <address> New Or-leans, LA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Since database logs are typically large (perhaps millions of transaction records long), reasoning backwards through them is unacceptably expensive. Recognizing this problem, Reiter and his colleagues have looked at ways of materializing the current database state <ref> [Rei95; LR94; LLL + 94] </ref>. However, no theory has LOGIC FOR TRANSACTIONS 41 been presented showing how the materialization can be carried out within a logical framework. Finally, Reiter's theory does not apply to logic programs and deductive databases. There are two reasons for this.
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming (Second Edition). </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: For one thing, stating that a database state is a first-order formula does not determine the set of truths about that state. This is because in databases and logic programming, one usually assigns a non-standard semantics to database states, e.g., Clark's completion, a perfect-model, or a well-founded model semantics <ref> [Llo87; VRS91; GL88] </ref>. Because of this, we have chosen to insulate the dynamic aspects of transaction execution from the static aspects pertaining to the truth at database states. <p> The lack of a minimal-model semantics also complicates the representation of relational databases. Instead of representing them as sets of ground atomic formulas in the usual way, the theory uses Clark's completion <ref> [Llo87; Rei84] </ref>, which, in the case of databases, requires very large first-order formulas. In AI terminology, these complications arise because Reiter's theory is about open worlds, whereas databases are closed worlds.
Reference: [LR94] <author> F. Lin and R. Reiter. </author> <title> How to progress a database (and why) I. Logical foundations. </title> <editor> In Jon Doyle, Erik Sandewall, and Pietro Torasso, editors, </editor> <booktitle> Proceedings of the International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 425-436, </pages> <year> 1994. </year>
Reference-contexts: Since database logs are typically large (perhaps millions of transaction records long), reasoning backwards through them is unacceptably expensive. Recognizing this problem, Reiter and his colleagues have looked at ways of materializing the current database state <ref> [Rei95; LR94; LLL + 94] </ref>. However, no theory has LOGIC FOR TRANSACTIONS 41 been presented showing how the materialization can be carried out within a logical framework. Finally, Reiter's theory does not apply to logic programs and deductive databases. There are two reasons for this. <p> In AI terminology, these complications arise because Reiter's theory is about open worlds, whereas databases are closed worlds. Unfortunately, updating open worlds is an intractable problem in general, since the result of an update may not have a finite representation in first-order logic <ref> [LR94] </ref>. Second, the theory does not protect deductive rules from database updates. In particular, updates can damage and destroy rules. For example, suppose that a deductive database consists of the single rule p (X) q (X), and suppose that the atom q (b) is inserted into this database.
Reference: [LRL + 97] <author> H.J. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. Scherl. Golog: </author> <title> A logic programming language for dynamic domains. </title> <journal> Journal of Logic Programming, </journal> <note> 1997. To appear. </note>
Reference-contexts: Consequently, the theory does not provide a logical account of how to query or update such databases. Golog. Levesque et al have recently developed Golog, a procedural language for programming complex actions, including database transactions <ref> [LRL + 97] </ref>. Syntactically, Golog is similar to the procedural database language QL developed by Chandra and Harel [CH80] extended with subroutines and nondeterministic choice. <p> Transitive closure can be defined in Golog, but not by deductive rules. Instead, the user must write an Algol-like procedure, as illustrated in <ref> [LRL + 97] </ref>. In this way, Golog sacrifices the declarativeness of deductive databases for the procedurality of Algol. For the same reason, Golog has difficulty in specifying database views, especially recursive views [Rei95]. These difficulties all arise because Golog abandons the logic-programming paradigm. <p> Golog has numerous other differences with T R as well. For instance, Golog subroutines are not logical entities, but are macros specified outside the logic. Thus, one cannot refer to them in the logic, and in particular, one cannot quantify over them or reason about them <ref> [LRL + 97] </ref>. In addition, like other logics of action, updates in Golog are hypothetical, not real. This is because Golog uses the situation calculus to reason about what would be true if an action took place. The actual execution of actions requires a separate run-time system, outside of Golog.
Reference: [MBDH83] <author> J.N. Maksym, A.J. Bonner, C.A. Dent, and G.L. Hemphill. </author> <title> Machine Analysis of Acoustical Signals. </title> <journal> Pattern Recognition, </journal> <volume> 16(6) </volume> <pages> 615-625, </pages> <year> 1983. </year> <booktitle> Also appears in Proceedings of the Workshop on Issues in Acoustic Signal/Image Processing and Recognition, </booktitle> <address> San Miniato, Italy, </address> <month> August 5-9 </month> <year> 1982. </year>
Reference-contexts: In Prolog, asserting or retracting a clause is elementary. In database applications, SQL statements are the basic building blocks. In scientific and engineering programs, basic operations include Fourier transforms, matrix inversion, least-squares fitting, and operations on DNA sequences <ref> [GRS94; MBDH83] </ref>. In workflow management systems, elementary operations can include any number of application programs and legacy systems [BSR96]. In all cases, the elementary operations are building blocks from which larger programs and software systems are built. Although elementary operations can vary dramatically, the logic for combining them does not.
Reference: [McC63] <author> J. McCarthy. </author> <title> Situations, actions, and clausal laws, memo 2. </title> <journal> Stan-ford Artificial Intelligence Project, </journal> <year> 1963. </year>
Reference-contexts: Situation Calculus. The situation calculus is a methodology for specifying the effects of elementary actions in first-order classical logic. It was introduced by McCarthy <ref> [McC63] </ref> and then further developed by McCarthy and Hayes [MH69]. From a database perspective, transactions specified in the situation calculus can insert and delete atomic formulas, but not arbitrary logical formulas. <p> In particular, Reiter has developed an approach to the frame problem that does not suffer from the usual blow-up in the number of frame axioms [Rei91]. Also, unlike the original situation calculus, which was entirely first-order <ref> [McC63; MH69] </ref>, Re-iter's development includes an induction axiom specified in second-order logic, for reasoning about action sequences [Rei93]. Applying this approach, Reiter has developed a logical theory of database evolution [Rei95]. This theory is perfectly compatible with T R.
Reference: [McC83] <author> L.T. McCarty. </author> <title> Permissions and obligations. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 287-294, </pages> <address> San Francisco, CA, 1983. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> The basic theory in [MvdM92] is also very different from that of T R, as it is based on circumscription and second-order intuitionistic logic. LOGIC FOR TRANSACTIONS 39 In earlier work, McCarty outlined a logic of action as part of a larger proposal for reasoning about deontic concepts <ref> [McC83] </ref>. His proposal contains three distinct layers, each with its own logic: first-order predicate logic, a logic of action, and a logic of permission and obligation.
Reference: [MH69] <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, </editor> <title> REFERENCES 49 editors, </title> <journal> Machine Intelligence, </journal> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher>
Reference-contexts: This is contrary to the idea of logic programming, in which the logical proof theory acts as the runtime system, so that programs are executed by proving theorems. (iv) Many logics of action get bogged down by the so-called frame problem <ref> [MH69; Rei91] </ref>, the problem of logically specifying what an action does not do. For instance, when a robot picks up a block, many things do not change, such as the color of the block, the weight of the block, the number of blocks, etc. <p> On the other hand, if a syntactic dis 8 LOGICS FOR DATABASES AND INFORMATION SYSTEMS tinction is desired, then two sorts of predicates could be used, one for queries, and one for updating transactions. This philosophy is quite different from the situation calculus <ref> [MH69] </ref> and from approaches based on dynamic and process logics [Har79; HKP82], where queries and updates are represented by different classes of syntactic objects (e.g., predicates vs. function terms vs. modal operators). <p> Situation Calculus. The situation calculus is a methodology for specifying the effects of elementary actions in first-order classical logic. It was introduced by McCarthy [McC63] and then further developed by McCarthy and Hayes <ref> [MH69] </ref>. From a database perspective, transactions specified in the situation calculus can insert and delete atomic formulas, but not arbitrary logical formulas. <p> In fact, the frame problem has not been an issue in any of the theory or any of the examples presented in this paper. In contrast, the frame problem is a central issue in the situation calculus <ref> [MH69; Rei91] </ref>. The frame problem is also an issue in full T R when it is used to reason about the properties of actions, a context in which frame axioms are unavoidable [BK]. Reiter's Theory of Database Evolution. <p> In particular, Reiter has developed an approach to the frame problem that does not suffer from the usual blow-up in the number of frame axioms [Rei91]. Also, unlike the original situation calculus, which was entirely first-order <ref> [McC63; MH69] </ref>, Re-iter's development includes an induction axiom specified in second-order logic, for reasoning about action sequences [Rei93]. Applying this approach, Reiter has developed a logical theory of database evolution [Rei95]. This theory is perfectly compatible with T R.
Reference: [MvdM92] <author> L.T. McCarty and R. van der Meyden. </author> <title> Reasoning about indefinite actions. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 59-70, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Fourth, Process Logic and Dynamic Logic were not designed for database programming. For instance, they do not have the notions of a database or a query, and they do not support named procedures, such as subroutines and views. McCarty and Van der Meyden. In <ref> [MvdM92] </ref>, McCarty and Van der Meyden develop a theory for reasoning about "indefinite" actions. This work is orthogonal to T R. The main similarity is that both works are concerned with defining complex actions in terms of simpler ones, and in both works, the actions may be non-deterministic (or "indefinite"). <p> This work is orthogonal to T R. The main similarity is that both works are concerned with defining complex actions in terms of simpler ones, and in both works, the actions may be non-deterministic (or "indefinite"). However, unlike T R, <ref> [MvdM92] </ref> does not address action execution or the updating of databases. To give an idea of what [MvdM92] is about, consider a T R transaction base consisting of exactly the following two rules: 14 a c1 c2 c3 b c2 c3 The main point is that a and b are complex <p> However, unlike T R, <ref> [MvdM92] </ref> does not address action execution or the updating of databases. To give an idea of what [MvdM92] is about, consider a T R transaction base consisting of exactly the following two rules: 14 a c1 c2 c3 b c2 c3 The main point is that a and b are complex actions defined in terms of the elementary actions c1; c2; c3. <p> In T R, the effects of the elementary actions are specified by an oracle, which is invoked to execute them. In contrast, <ref> [MvdM92] </ref> has no mechanism for specifying the effects of elementary actions. <p> Thus, an occurrence of action a implies an occurrence of action b. There are also technical differences between T R and <ref> [MvdM92] </ref>. For instance, [MvdM92] does not allow function symbols in the rules that define complex actions (and even so, most of their reasoning problems are undecidable and/or outside of re). In addition, [MvdM92] is committed to a particular model of states. The basic theory in [MvdM92] is also very different from <p> Thus, an occurrence of action a implies an occurrence of action b. There are also technical differences between T R and <ref> [MvdM92] </ref>. For instance, [MvdM92] does not allow function symbols in the rules that define complex actions (and even so, most of their reasoning problems are undecidable and/or outside of re). In addition, [MvdM92] is committed to a particular model of states. The basic theory in [MvdM92] is also very different from that of T <p> There are also technical differences between T R and <ref> [MvdM92] </ref>. For instance, [MvdM92] does not allow function symbols in the rules that define complex actions (and even so, most of their reasoning problems are undecidable and/or outside of re). In addition, [MvdM92] is committed to a particular model of states. The basic theory in [MvdM92] is also very different from that of T R, as it is based on circumscription and second-order intuitionistic logic. <p> differences between T R and <ref> [MvdM92] </ref>. For instance, [MvdM92] does not allow function symbols in the rules that define complex actions (and even so, most of their reasoning problems are undecidable and/or outside of re). In addition, [MvdM92] is committed to a particular model of states. The basic theory in [MvdM92] is also very different from that of T R, as it is based on circumscription and second-order intuitionistic logic. LOGIC FOR TRANSACTIONS 39 In earlier work, McCarty outlined a logic of action as part of a larger proposal for reasoning about deontic concepts [McC83]. <p> The version in [HKP82] is closer to T R than any other incarnation of Process Logic we are aware of. 14. Here we use the syntax of T R, which can be translated into the original syntax of <ref> [MvdM92] </ref>. 15. In both the initial and final database, we have suppressed the so-called "situation argument." Situation arguments identify a database state in the situation calculus, but are unnecessary for describing the formulas that are true in a state.
Reference: [MW88] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> Many other formalisms are not database-oriented at all, but come from the tradition of procedural programming languages. Typically, they assume that a state is a set of program variables, and that an update changes a variable's value. 1.7.1 Declarative Languages for Database Transactions Dynamic Prolog. Manchanda and Warren <ref> [MW88] </ref> developed Dynamic Pro-log, a logic programming language for database transactions. This language is by far the most similar to T R. For instance, T R and Dynamic Prolog are the only logic programming languages that account not just for updates, but for transaction abort and rollback as well.
Reference: [NK88] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: To get a better grasp of the idea of an oracle-as-database-state, Section 1.4.3 provides some typical examples. 1.4.2 State Transition Oracles The next step is to specify elementary changes to the database. One way to define such changes is to build them into the semantics, as in <ref> [MW88; NK88; Bon97b; Bon97a; Che91; AV90; McC83] </ref>. The problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails a revamping of the entire theory, including the need to reprove soundness and completeness results. <p> As a consequence, it is impossible to express constraints on transaction execution, such as those needed for advanced applications in AI, workflow management, etc. [BK95; DKRR97]. LDL. Naqvi and Krishnamurthy <ref> [NK88] </ref> extended Datalog with update operators, which were later incorporated in the LDL language [NT89]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [NK88; NT89] is somewhat limited. <p> LDL. Naqvi and Krishnamurthy [NK88] extended Datalog with update operators, which were later incorporated in the LDL language [NT89]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in <ref> [NK88; NT89] </ref> is somewhat limited. First, it matches the execution model of LDL only in the propositional case, and so it does not cover bulk updates. Second, it is only defined for update-programs in which commutativ-ity of elementary updates can be assumed. <p> Second, it is only defined for update-programs in which commutativ-ity of elementary updates can be assumed. For sequences of updates in which this does not hold, the semantics turns out to be rather tricky and certainly does not qualify as "model theoretic." Third, the definition of "legal" programs in <ref> [NK88; NT89] </ref> is highly restrictive, making it difficult to build complex transactions out of simpler ones. Chen's Calculus. Chen developed a calculus and an equivalent algebra for constructing transactions [Che91]. Like T R, this calculus uses logical operators to construct database transactions from elementary updates. There are several differences however.
Reference: [NT89] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: As a consequence, it is impossible to express constraints on transaction execution, such as those needed for advanced applications in AI, workflow management, etc. [BK95; DKRR97]. LDL. Naqvi and Krishnamurthy [NK88] extended Datalog with update operators, which were later incorporated in the LDL language <ref> [NT89] </ref>. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [NK88; NT89] is somewhat limited. <p> LDL. Naqvi and Krishnamurthy [NK88] extended Datalog with update operators, which were later incorporated in the LDL language [NT89]. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in <ref> [NK88; NT89] </ref> is somewhat limited. First, it matches the execution model of LDL only in the propositional case, and so it does not cover bulk updates. Second, it is only defined for update-programs in which commutativ-ity of elementary updates can be assumed. <p> Second, it is only defined for update-programs in which commutativ-ity of elementary updates can be assumed. For sequences of updates in which this does not hold, the semantics turns out to be rather tricky and certainly does not qualify as "model theoretic." Third, the definition of "legal" programs in <ref> [NK88; NT89] </ref> is highly restrictive, making it difficult to build complex transactions out of simpler ones. Chen's Calculus. Chen developed a calculus and an equivalent algebra for constructing transactions [Che91]. Like T R, this calculus uses logical operators to construct database transactions from elementary updates. There are several differences however.
Reference: [PDR91] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates either in databases or in logic program LOGIC FOR TRANSACTIONS 3 ming <ref> [Bee92; Ban86; PDR91] </ref>. In particular, database transaction languages are not founded on action logics, the way that query languages are founded on classical logic. The main reason, we believe, is that reasoning about action is not the same thing as declarative programming, especially in a database context.
Reference: [Pra79] <author> V.R. Pratt. </author> <title> Process logic. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-100, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Note that in the case of Horn databases, which is the main focus of this paper, inconsistency is not possible, so &gt; does not make any difference. 13. A number of different process logics have been proposed in the literature, beginning with Pratt's original work <ref> [Pra79] </ref>. The version in [HKP82] is closer to T R than any other incarnation of Process Logic we are aware of. 14. Here we use the syntax of T R, which can be translated into the original syntax of [MvdM92]. 15.
Reference: [Prz88] <author> T.C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Mor-gan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: In fact, much of the theory of negation in classical logic programs carries over to Transaction logic programs in a straightforward way, including familiar notions like stratification [ABW88] and local stratification <ref> [Prz88] </ref>. However, negation is not the subject of this paper, and the interested reader is referred to [BK94; BK95] for details. Although serial-Horn T R is a very expressive logic, some useful programs are non-Horn. Programs with negated premises are just one example.
Reference: [Rei84] <author> R. Reiter. </author> <title> Towards a logical reconstruction of relational database theory. In M.L. </title> <editor> Brodie, J. Mylopoulos, and J. Schmidt, editors, </editor> <booktitle> On Conceptual Modelling: Perspectives from Artificial Intelligence, Databases and Programming Languages, </booktitle> <pages> pages 191-233. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: The lack of a minimal-model semantics also complicates the representation of relational databases. Instead of representing them as sets of ground atomic formulas in the usual way, the theory uses Clark's completion <ref> [Llo87; Rei84] </ref>, which, in the case of databases, requires very large first-order formulas. In AI terminology, these complications arise because Reiter's theory is about open worlds, whereas databases are closed worlds.
Reference: [Rei91] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Aritifial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarty, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: This is contrary to the idea of logic programming, in which the logical proof theory acts as the runtime system, so that programs are executed by proving theorems. (iv) Many logics of action get bogged down by the so-called frame problem <ref> [MH69; Rei91] </ref>, the problem of logically specifying what an action does not do. For instance, when a robot picks up a block, many things do not change, such as the color of the block, the weight of the block, the number of blocks, etc. <p> In fact, the frame problem has not been an issue in any of the theory or any of the examples presented in this paper. In contrast, the frame problem is a central issue in the situation calculus <ref> [MH69; Rei91] </ref>. The frame problem is also an issue in full T R when it is used to reason about the properties of actions, a context in which frame axioms are unavoidable [BK]. Reiter's Theory of Database Evolution. <p> In particular, Reiter has developed an approach to the frame problem that does not suffer from the usual blow-up in the number of frame axioms <ref> [Rei91] </ref>. Also, unlike the original situation calculus, which was entirely first-order [McC63; MH69], Re-iter's development includes an induction axiom specified in second-order logic, for reasoning about action sequences [Rei93]. Applying this approach, Reiter has developed a logical theory of database evolution [Rei95]. This theory is perfectly compatible with T R. <p> This change is a direct result of Reiter's approach to the frame problem <ref> [Rei91] </ref>, which intuitively says that except for atoms that are explicitly inserted or deleted, all atoms must retain their old truth values.
Reference: [Rei93] <author> R. Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 64 </volume> <pages> 337-351, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Also, unlike the original situation calculus, which was entirely first-order [McC63; MH69], Re-iter's development includes an induction axiom specified in second-order logic, for reasoning about action sequences <ref> [Rei93] </ref>. Applying this approach, Reiter has developed a logical theory of database evolution [Rei95]. This theory is perfectly compatible with T R. Through its oracle mechanism, T R can use the theory to specify the semantics of database states and elementary actions.
Reference: [Rei95] <author> R. Reiter. </author> <title> On specifying database updates. </title> <journal> Journal of Logic Programming, </journal> <volume> 25(1) </volume> <pages> 53-91, </pages> <month> October </month> <year> 1995. </year> <note> 50 LOGICS FOR DATABASES AND INFORMATION SYSTEMS </note>
Reference-contexts: Also, unlike the original situation calculus, which was entirely first-order [McC63; MH69], Re-iter's development includes an induction axiom specified in second-order logic, for reasoning about action sequences [Rei93]. Applying this approach, Reiter has developed a logical theory of database evolution <ref> [Rei95] </ref>. This theory is perfectly compatible with T R. Through its oracle mechanism, T R can use the theory to specify the semantics of database states and elementary actions. Horn T R can then combine these actions into complex programs, and full T R can reason about them. <p> Thus, the current database state is not materialized, but is virtual. In this framework, queries to the current state are answered by querying the log and reasoning backwards through it to the initial state <ref> [Rei95] </ref>. Unfortunately, this means that simple operations, like retrieving a single tuple from the database, become long and complicated reasoning processes. Since database logs are typically large (perhaps millions of transaction records long), reasoning backwards through them is unacceptably expensive. <p> Since database logs are typically large (perhaps millions of transaction records long), reasoning backwards through them is unacceptably expensive. Recognizing this problem, Reiter and his colleagues have looked at ways of materializing the current database state <ref> [Rei95; LR94; LLL + 94] </ref>. However, no theory has LOGIC FOR TRANSACTIONS 41 been presented showing how the materialization can be carried out within a logical framework. Finally, Reiter's theory does not apply to logic programs and deductive databases. There are two reasons for this. <p> Of course, this dictum is completely contrary to the idea of database views, in which virtual data depends on base data and can change as an indirect effect of database updates. In AI terminology, this is an example of the ramification problem <ref> [Fin86; Rei95] </ref>. To account for views, Reiter treats view definitions as integrity constraints that must be maintained by the transaction system. In this approach, views are not defined by Horn rules. Instead, the axioms of the transaction system are modified to treat views as stored data. <p> For instance, in the above example, 42 LOGICS FOR DATABASES AND INFORMATION SYSTEMS whenever a transaction inserts (or deletes) the atom q (b) from the database, the modified axioms would insert (or delete) the atom p (b) as well <ref> [Rei95] </ref>. In this way, the system behaves as if the database contained the deductive rule p (X) q (X) (with a minimal model semantics). Unfortunately, in this approach, view definitions depend on transaction definitions. <p> Instead, the user must write an Algol-like procedure, as illustrated in [LRL + 97]. In this way, Golog sacrifices the declarativeness of deductive databases for the procedurality of Algol. For the same reason, Golog has difficulty in specifying database views, especially recursive views <ref> [Rei95] </ref>. These difficulties all arise because Golog abandons the logic-programming paradigm. Golog has numerous other differences with T R as well. For instance, Golog subroutines are not logical entities, but are macros specified outside the logic.
Reference: [Ull88] <author> J.F. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1988. </year>
Reference-contexts: Through its oracle mechanism, T R can use the theory to specify the semantics of database states and elementary actions. Horn T R can then combine these actions into complex programs, and full T R can reason about them. However, from the perspective of database theory <ref> [AHV95; Ull88] </ref>, Reiter's theory of database evolution is quite unusual. For instance, a database state is usually modeled as set of relations or logical formulas; but in Reiter's theory, a state is identified with a sequence of actions.
Reference: [VRS91] <author> A. Van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: For one thing, stating that a database state is a first-order formula does not determine the set of truths about that state. This is because in databases and logic programming, one usually assigns a non-standard semantics to database states, e.g., Clark's completion, a perfect-model, or a well-founded model semantics <ref> [Llo87; VRS91; GL88] </ref>. Because of this, we have chosen to insulate the dynamic aspects of transaction execution from the static aspects pertaining to the truth at database states. <p> Well-Founded Oracle. A state id D is a set of generalized-Horn rules, 11 and O d (D) is the set of literals (both positive and negative) in the well-founded model of D <ref> [VRS91] </ref>. Such oracles can represent any rule-base with well 20 LOGICS FOR DATABASES AND INFORMATION SYSTEMS founded semantics, which includes Horn rule-bases, stratified rule-bases, and locally-stratified rule-bases. For advanced applications, one may want to augment O d (D) with the rules in D.
Reference: [Win88] <author> M. Winslett. </author> <title> A model based approach to updating databases with incomplete information. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(2) </volume> <pages> 167-196, </pages> <year> 1988. </year>
Reference-contexts: Unfortunately, there is no general solution to the practical problem of how oracles can best be implemented. For the classical oracle described above, the problem has been partly solved by Grahne, Mendelzon, and Winslett <ref> [GM95; Win88] </ref>. Winslett showed that, in general, the problem of updating propositional formulas is NP-hard. Subsequently, though, Grahne and Mendelzon proved that updating sets of ground atoms with arbitrary propositional formulas can be done in polynomial time.
Reference: [Zan93] <author> Carlo Zaniolo. </author> <title> A unified semantics for active and deductive databases. </title> <booktitle> In Proceedings of the Workshop on Rules in Database Systems, Workshops in Computing. </booktitle> <publisher> Springer-Verlag, Edinburgh, </publisher> <address> U.K., </address> <year> 1993. </year>
Reference-contexts: Likewise, there are many kinds of updates that Golog cannot represent, including the insertion of rules into deductive databases, and the insertion of disjunctions into disjunctive databases. Datalog with State. A number of researchers have worked on adding a notion of state to Datalog programs <ref> [Zan93; LHL95] </ref>. In these works, states are represented through a special, distinct argument, which is added to each updatable predicate. Updates are then modeled as state transitions. This approach can be viewed as an adaptation of the situation calculus to Dat-alog. <p> This approach can be viewed as an adaptation of the situation calculus to Dat-alog. As such, it has several important differences with Reiter's theory of database evolution and with Golog. First, unlike Reiter's theory, Datalog with state uses a form of closed-world semantics (XY-stratification <ref> [Zan93] </ref> or state-stratification [LHL95]), which is closer to the database tradition. Moreover, unlike Reiter's theory, Datalog with state has no problem in representing database views, recursive or otherwise. Second, actions in Datalog with state are limited to the insertion and deletion of ground atomic formulas.
References-found: 58

