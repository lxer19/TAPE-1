URL: http://www.csl.sri.com/reports/postscript/fse97.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Subtypes for Specifications  
Author: John Rushby 
Note: "predicate subtyping" and illustrate its utility as mechanized in PVS.  
Address: Menlo Park, CA 94025, USA  
Affiliation: Computer Science Laboratory, SRI International,  
Abstract: Revised version of an invited paper presented at the Fifth ACM SIGSOFT Symposium on the Foundations of Software Engineering and Sixth European Software Engineering Conference, Zurich, Switzerland, September 1997. Springer-Verlag Lecture Notes in Computer Science, volume 1301, pages 4-19. Abstract. Specification languages are best used in environments that provide effective theorem proving. Having such support available, it is feasible to contemplate forms of typechecking that can use the services of a theorem prover. This allows interesting extensions to the type systems provided for specification languages. I describe one such extension called 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Papers by SRI authors are generally available from http://www.csl.sri.com/fm.html. </institution>
Reference: [1] <editor> Rajeev Alur and Thomas A. Henzinger, editors. </editor> <booktitle> Computer-Aided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [2] <author> H. Barringer, J. H. Cheng, and C. B. Jones. </author> <title> A logic covering undefinedness in program proofs. </title> <journal> Acta Informatica, </journal> <volume> 21 </volume> <pages> 251-269, </pages> <year> 1984. </year>
Reference-contexts: One way out of the difficulty is introduce some artificial value for undefined terms such as x=0, but this is clumsy and has to be done carefully to avoid inconsistencies. Another approach introduces "undefined" as a truth value <ref> [2] </ref>; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms [3]; Parnas [19] and Farmer [10] have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [3] <author> Michael J. Beeson. </author> <title> Foundations of Constructive Mathematics. Ergebnisse der Mathematik und ihrer Grenzgebiete; 3. Folge Band 6. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 16 </month>
Reference-contexts: Another approach introduces "undefined" as a truth value [2]; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms <ref> [3] </ref>; Parnas [19] and Farmer [10] have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [4] <author> Luca Cardelli. </author> <title> Type systems. </title> <booktitle> In Handbook of Computer Science and Engi neering, chapter 103, </booktitle> <pages> pages 2208-2236. </pages> <publisher> CRC Press, </publisher> <year> 1997. </year> <note> Available at http: //www.research.digital.com/SRC. </note>
Reference-contexts: 1 Introduction For programming languages, type systems and their associated typecheckers are intended to ensure the absence of certain undesirable behaviors during program execution <ref> [4] </ref>. The undesired behaviors generally include untrapped errors such as adding a boolean to an integer, and may (e.g., in Java) encompass security violations. If the language is "type safe," then all programs that can exhibit these undesired behaviors will be rejected during typechecking. <p> Subtypes of a different, "structural," kind are sometimes used in type systems for programming languages to account for issues arising in object-oriented programs <ref> [4] </ref>. In particular, a record type A that contains fields in addition to those of a record type B is regarded as a subtype of B. The intuition behind this kind of subtyping is rather different than the "subtypes as subsets" intuition.
Reference: [5] <author> J. H. Cheng and C. B. Jones. </author> <title> On the usability of logics which handle partial func tions. </title> <editor> In Carroll Morgan and J. C. P. Woodcock, editors, </editor> <booktitle> Proceedings of the Third Refinement Workshop, </booktitle> <pages> pages 51-69. </pages> <publisher> Springer-Verlag Workshops in Computing, </publisher> <year> 1990. </year>
Reference-contexts: Another example of a partial function is the subp "challenge" from Cheng and Jones <ref> [5] </ref>. This function on integers is given by subp (i; j) = if i = j then 0 else subp (i; j + 1) + 1 endif and is undefined if i &lt; j (when i j; subp (i; j) = i j).
Reference: [6] <author> A. Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: The first systematic type system (now known as the "Ramified Theory of Types") was developed by Russell [23] to avoid the inconsistencies in nave set theory, and a simplified form of this system (the "Simple Theory of Types," due to Ram-sey [20] and Church <ref> [6] </ref>) provides the foundation for most specification languages based on higher-order logic. If a specification uses no axioms (beyond those of the logic itself), then typechecking with respect to such a type system guarantees consistency.
Reference: [7] <author> R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: However, datatype invariants are part of VDM's mechanisms for specifying operations in terms of pre- and post-conditions on a state, rather than part of the type system for its logic. To my knowledge, predicate subtypes are fully supported as part of a specification logic only by the Nuprl <ref> [7] </ref> and PVS [18] verification systems.
Reference: [8] <author> David Cyrluk, Patrick Lincoln, and N. Shankar. </author> <title> On Shostak's decision procedure for combinations of theories. </title> <editor> In M. A. McRobbie and J. K. Slaney, editors, </editor> <booktitle> Automated Deduction|CADE-13, volume 1104 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 463-477, </pages> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: There are strong advantages in theorem proving from adopting the first approach: it allows use of congruence closure as a decision procedure for equality over uninterpreted function symbols, which is essential for effective automation <ref> [8] </ref>. On the other hand, there are functions, such as division, that seem inherently partial and cause difficulty to this approach.
Reference: [9] <author> David L. Detlefs. </author> <title> An overview of the Extended Static Checking system. </title> <booktitle> In First Workshop on Formal Methods in Software Practice (FMSP '96), </booktitle> <pages> pages 1-9, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1996. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: subtypes described in this section, but lacks the more general benefits of predicate subtyping.) 7 Comparison with Subtypes in Programming Languages I know of no programming language that provides predicate subtypes, although the annotations provided for "extended static checking" (proving the absence of runtime errors such as array bound violations) <ref> [9] </ref> have some similarities. Bringing the benefits of predicate subtyping to programming languages seems a worthwhile research endeavor that might generalize the benefits of extended static checking, while also providing information that could be useful to an optimizing compiler.
Reference: [10] <author> William M. Farmer. </author> <title> A partial functions version of Church's simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 55(3) </volume> <pages> 1269-1291, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Another approach introduces "undefined" as a truth value [2]; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms [3]; Parnas [19] and Farmer <ref> [10] </ref> have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [11] <author> William M. Farmer, Joshua D. Guttman, and F. Javier Thayer. IMPS: </author> <title> An interac tive mathematical proof system. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11(2) </volume> <pages> 213-248, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Predicate subtypes provide the tool necessary to specify domains with suitable precision. 10 Farmer's logic is used in the IMPS system <ref> [11] </ref>. IMPS generates proof obligations to ensure definedness during proofs that are similar to PVS's TCCs.
Reference: [12] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall In ternational Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Similar ideas are also seen in formalized specification notations where, for example, the datatype invariants of VDM <ref> [12, Chapter 5] </ref> have much in common with predicate subtypes. However, datatype invariants are part of VDM's mechanisms for specifying operations in terms of pre- and post-conditions on a state, rather than part of the type system for its logic.
Reference: [13] <author> Richard A. Kemmerer. </author> <title> Verification assessment study final report. </title> <type> Technical Re port C3-CR01-86, </type> <institution> National Computer Security Center, </institution> <address> Ft. Meade, MD, </address> <year> 1986. </year> <title> 5 Volumes (Overview, Gypsy, Affirm, FDM, and Ehdm). US distribution only. </title>
Reference-contexts: In the absence of such automation, we would have to formulate the appropriate proof obligations manually (a tedious and error-prone process), or construct a proof-obligation generator for this one special purpose (the FDM system of the early 1980s had such a proof-obligation generator as its core element <ref> [13] </ref>). In the following section, I show how the same mechanism can alleviate difficulties caused by partial functions. 6 Avoiding Partial Functions With Predicate Subtypes Functions are primitive and total in higher-order logic, whereas in set theory they are constructed as sets of pairs and are generally partial.
Reference: [14] <author> Leslie Lamport and Lawrence C. Paulson. </author> <title> Should your specification language be typed? SRC Research Report 147, </title> <institution> Digital Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1997. </year> <note> Available at http://www.research.digital.com/SRC. </note>
Reference-contexts: Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties. These problems have led some to argue that the discipline of types can be too onerous in a specification language, and that untyped set theory is a better choice <ref> [14] </ref>. Predicate subtypes offer another approach that I find preferable to the alternatives. Many partial functions become total if their domains are specified with sufficient precision; applying a function outside its domain then becomes a type error, rather than something that has to be dealt with in the logic.
Reference: [15] <author> David C. Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe. ANNA: </author> <title> A Language for Annotating Ada Programs, </title> <booktitle> volume 260 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: To my knowledge, predicate subtypes are fully supported as part of a specification logic only by the Nuprl [7] and PVS [18] verification systems. Predicate subtypes arose independently in these two systems (in PVS they came from its predecessor, Ehdm, whence they were introduced from the ANNA notation <ref> [15] </ref> by Friedrich von Henke, who was involved in the design of both), and there are differences in their uses and mechanization.
Reference: [16] <author> S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M.K. Srivas. PVS: </author> <title> Combining specification, proof checking, and model checking. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 411-414. </pages>
Reference-contexts: PVS system includes an interactive theorem prover that can be customized with user-written "strategies" (similar to tactics and tacticals in LCF-style provers), and that provides rather powerful automation in the form of decision procedures (e.g., for ground equality and linear arithmetic over both integers and reals) integrated with a rewriter <ref> [16, 22] </ref>. As noted, some constructions involving predicate 3 subtypes generate TCCs (proof obligations); often, these can be discharged automatically using strategies provided for that purpose but, in other cases, the user must develop suitable proofs interactively.
Reference: [17] <author> Sam Owre, John Rushby, and N. Shankar. </author> <title> Integration in PVS: Tables, types, and model checking. </title> <editor> In Ed Brinksma, editor, </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems (TACAS '97), volume 1217 of Lecture Notes in Computer Science, </booktitle> <pages> pages 366-383, </pages> <address> Enschede, The Netherlands, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For example, instead of 8 (i, j: int): i 0 and j 0 i+j i 8 (i, j: nat): i+j i 2 Another is consistency checking for tabular specifications <ref> [17] </ref>. 2 because i 0 and j 0 are recorded in the type nat for i and j. Theorem proving can be required in typechecking some constructions involving predicate subtypes.
Reference: [18] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: To my knowledge, predicate subtypes are fully supported as part of a specification logic only by the Nuprl [7] and PVS <ref> [18] </ref> verification systems. Predicate subtypes arose independently in these two systems (in PVS they came from its predecessor, Ehdm, whence they were introduced from the ANNA notation [15] by Friedrich von Henke, who was involved in the design of both), and there are differences in their uses and mechanization.
Reference: [19] <author> David Lorge Parnas. </author> <title> Predicate logic for software engineering. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(9) </volume> <pages> 856-862, </pages> <month> September </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: Another approach introduces "undefined" as a truth value [2]; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms [3]; Parnas <ref> [19] </ref> and Farmer [10] have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [20] <author> F. P. Ramsey. </author> <title> The foundations of mathematics. </title> <editor> In D. H. Mellor, editor, Philo sophical Papers of F. P. Ramsey, </editor> <volume> chapter 8, </volume> <pages> pages 164-224. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1990. </year> <booktitle> Originally published in Proceedings of the London Mathematical Society, </booktitle> <volume> 25, </volume> <pages> pp. 338-384, </pages> <year> 1925. </year>
Reference-contexts: The first systematic type system (now known as the "Ramified Theory of Types") was developed by Russell [23] to avoid the inconsistencies in nave set theory, and a simplified form of this system (the "Simple Theory of Types," due to Ram-sey <ref> [20] </ref> and Church [6]) provides the foundation for most specification languages based on higher-order logic. If a specification uses no axioms (beyond those of the logic itself), then typechecking with respect to such a type system guarantees consistency.
Reference: [21] <author> Piotr Rudnicki. </author> <title> An overview of the MIZAR project. </title> <booktitle> In Proceedings of the 1992 Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 311-330, </pages> <address> B-astad, Sweden, </address> <month> June </month> <year> 1992. </year> <note> The complete proccedings are available at http://www.cs.chalmers. se/pub/cs-reports/baastad.92/; this particular paper is also available separately at http://web.cs.ualberta.ca/~piotr/Mizar/MizarOverview.ps. </note>
Reference-contexts: In this treatment (found, for example, in Mizar <ref> [21] </ref>) the natural numbers are a subtype of the integers, but there is nothing bound to the subtyping relation that characterizes those integers that are natural numbers. Predicate subtypes provide such a tightly bound characterization by associating a predicate or property with the subtype.
Reference: [22] <author> John Rushby. </author> <title> Automated deduction and formal methods. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 169-183. </pages>
Reference-contexts: PVS system includes an interactive theorem prover that can be customized with user-written "strategies" (similar to tactics and tacticals in LCF-style provers), and that provides rather powerful automation in the form of decision procedures (e.g., for ground equality and linear arithmetic over both integers and reals) integrated with a rewriter <ref> [16, 22] </ref>. As noted, some constructions involving predicate 3 subtypes generate TCCs (proof obligations); often, these can be discharged automatically using strategies provided for that purpose but, in other cases, the user must develop suitable proofs interactively.
Reference: [23] <author> Bertrand Russell. </author> <title> Mathematical logic as based on the theory of types. </title> <editor> In Jean van Heijenoort, editor, </editor> <booktitle> From Frege to Godel, </booktitle> <pages> pages 150-182. </pages> <publisher> Harvard University Press, </publisher> <address> Cambridge, MA, </address> <year> 1967. </year> <note> First published 1908. </note>
Reference-contexts: The first systematic type system (now known as the "Ramified Theory of Types") was developed by Russell <ref> [23] </ref> to avoid the inconsistencies in nave set theory, and a simplified form of this system (the "Simple Theory of Types," due to Ram-sey [20] and Church [6]) provides the foundation for most specification languages based on higher-order logic.
Reference: [24] <author> Mark Saaltink. </author> <title> The Z/EVES system. </title> <booktitle> In ZUM '97: The Z Formal Specification Notation; 10th International Conference of Z Users, volume 1212 of Lecture Notes in Computer Science, </booktitle> <pages> pages 72-85, </pages> <address> Reading, UK, </address> <month> April </month> <year> 1997. </year> <title> Springer-Verlag. The views and conclusions contained herein are those of the author and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Air Force Office of Scientific Research or the U.S. Government. This article was processed using the L A T E X macro package with LLNCS style 18 </title>
Reference-contexts: These are also discharged automatically by the PVS decision procedures. In my experience, use of predicate subtypes to render functions total is not onerous, and contributes clarity and precision to a specification; it also provides potent error detection. Regarding the latter, the Z/EVES system <ref> [24] </ref> provides "domain checking" for Z specifications and has reportedly found errors in every Z specification examined in this way. (Domain checking is similar to the use of predicate subtypes described in this section, but lacks the more general benefits of predicate subtyping.) 7 Comparison with Subtypes in Programming Languages I
References-found: 25

