URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR482.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Detecting Global Predicates in Distributed Systems with Clocks  
Author: Scott D. Stoller 
Keyword: global predicate detection, consistent global states, partially-synchronous systems, dis tributed debugging, real-time monitoring  
Date: 29 June 1997  
Address: Bloomington, IN 47405, USA  
Affiliation: Dept. of Computer Science, Indiana University,  
Abstract: This paper proposes a framework for predicate detection in systems of processes with approximately-synchronized real-time clocks. Timestamps from these clocks are used to define two orderings on events: "definitely occurred before" and "possibly occurred before". These orderings lead naturally to definitions of 3 distinct detection modalities, i.e., 3 meanings of "predicate held during a computation", namely: Poss T (" possibly held"), Def T (" definitely held"), and Inst (" definitely held at a specific instant"). This paper defines these modalities and gives efficient algorithms for detecting them; the algorithms are based on algorithms of Cooper and Marzullo, Garg and Waldecker, and Fromentin and Raynal. 
Abstract-found: 1
Intro-found: 1
Reference: [BM93] <author> Ozalp Babaoglu and Keith Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <volume> chapter 5, </volume> <pages> pages 97-145. </pages> <publisher> Addison Wesley, </publisher> <address> 2nd edition, </address> <year> 1993. </year>
Reference-contexts: with an immediately succeeding event e 0 on the same process, C 1 (e) C 1 (e 0 ) and C 2 (e) C 2 (e 0 ). 3 Generic Theory of Consistent Global States Predicate detection in asynchronous systems is based on the notion of consistent global states (CGSs) <ref> [BM93] </ref>. Informally, a global state is consistent if it could have occurred during the computation. Recall that an ideal of a partial order hS; i is a set I S such that (8x 2 I : 8y 2 S : y x ) y 2 I). <p> Ideals of hEv (c); e ! hb i are usually called consistent cuts. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [DJR93]. Furthermore, the lattice of CGSs ordered by G is isomorphic to the lattice of consistent cuts <ref> [SM94, BM93] </ref>. This isomorphism has an important consequence for detection algorithms; specifically, it implies that a minimal increase with respect to G corresponds to advancing one process by one event, and hence that the lattice of CGSs can be explored by repeatedly advancing one process by one event. <p> Theorem 1. For any process-wise-total partial ordering e ,! on Ev (c), the partial order hCGS e is a lattice and is isomorphic to the lattice of ideals of hEv (c); e Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [SM94, BM93, DJR93] </ref>. The proof is straightforward. The following corollary underlies the detection algorithms in Sections 4 and 5. Corollary 2. <p> A detection algorithm based on happened-before could be used instead, if the system can be modified to maintain vector clocks (or is unusual and maintains them already). However, if the coherence protocol uses timers|for example, if leases are used instead of locks|then time acts as a hidden channel <ref> [BM93] </ref> (i.e., a means of communication other than messages), so detection based on happened-before might yield less precise results.
Reference: [CBDGF95] <author> Bernadette Charron-Bost, Carole Delporte-Gallet, and Hugues Fauconnier. </author> <title> Local and temporal predicates in distributed systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 157-179, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 In this paper, all partial orderings are irreflexive unless specified otherwise. 1 Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens.
Reference: [CLR90] <author> Thomas Cormen, Charles Leiserson, and Ronald Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: Recall that the operations on a priority queue p include getMin (p), which returns a record hk; di with key k and satellite data d such that k is the minimal value of the key, and extractMin (p), which removes and returns such a record <ref> [CLR90] </ref>. We also use priority queues with operations based on maximal key values. Thus, (7) is equivalent to key (getMin (p 2 )) key (getMax (p 1 )); (8) where key (hk; di) = k.
Reference: [CM91] <author> Robert Cooper and Keith Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, 1991. Appeared as ACM SIGPLAN Notices 26(12) </booktitle> <pages> 167-174, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Therefore, no process can determine unambiguously the sequence of global states through which the system passed. This leads to an obvious difficulty for detecting whether a global state predicate (hereafter simply called a "predicate"). Cooper and Marzullo proposed a solution for asynchronous distributed systems <ref> [CM91] </ref>. Their solution involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely"). These modalities are based on logical time [Lam78] as embodied in the happened-before relation e a partial ordering 1 of events that reflects causal dependencies. <p> We obtain algorithms for detecting Poss T and Def T by adapting (and, as we do so, optimizing) algorithms of Cooper and Marzullo <ref> [CM91] </ref> and Garg and Waldecker [GW94, GW96]. Modalities based on e ! are quite different, because e ! (unlike e e ) is not a partial ordering. In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo <ref> [CM91] </ref> and Garg and Waldecker [GW94, GW96]. <p> We consider first general algorithms for Poss T and Def T and then more efficient algorithms that work only for predicates of a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore the lattice hCGS e (c); G i by (roughly) replacing each condition of the form e e ! hb e 0 with e e e 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of <p> a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore the lattice hCGS e (c); G i by (roughly) replacing each condition of the form e e ! hb e 0 with e e e 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of CGSs at a time. The level of a global state g is i=1 L (S (g (i))). Level ` of the lattice of CGSs contains the CGSs with level `.
Reference: [DJR93] <author> Claire Diehl, Claude Jard, and Jean-Xavier Rampon. </author> <title> Reachability analysis on distributed executions. </title> <editor> In J.-P. Jouannaud and M.-C. Gaudel, editors, </editor> <booktitle> TAPSOFT '93: Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 629-643. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 In this paper, all partial orderings are irreflexive unless specified otherwise. 1 Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens. <p> Ideals of hEv (c); e ! hb i are usually called consistent cuts. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice <ref> [DJR93] </ref>. Furthermore, the lattice of CGSs ordered by G is isomorphic to the lattice of consistent cuts [SM94, BM93]. <p> Theorem 1. For any process-wise-total partial ordering e ,! on Ev (c), the partial order hCGS e is a lattice and is isomorphic to the lattice of ideals of hEv (c); e Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [SM94, BM93, DJR93] </ref>. The proof is straightforward. The following corollary underlies the detection algorithms in Sections 4 and 5. Corollary 2.
Reference: [FR94] <author> Eddy Fromentin and Michel Raynal. </author> <title> Inevitable global states: a concept to detect unstable properties of distributed computations in an observer independent way. </title> <booktitle> In Proc. Sixth IEEE Symposium on Parallel and Distributed Processing, </booktitle> <year> 1994. </year>
Reference-contexts: In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. We show that this single modality, which we denote by Inst, is closely related to Fromentin and Raynal's concept of Properly <ref> [FR94, FR95] </ref>, and we adapt for detecting Inst an algorithm of theirs for detecting Properly. Our detection framework is applicable to a wide range of systems, since it does not require that clocks be synchronized to within a fixed bound. <p> Our algorithm for detecting Inst is based on Fromentin and Raynal's algorithm for detecting Properly (read "properly") in asynchronous systems <ref> [FR94, FR95] </ref>. The definition of Properly, generalized to an arbitrary ordering on events, is: Properly: A computation c satisfies Properly e ,! iff there is a global state satisfying and contained in every path of hCGS e Theorem 6. Properly e is equivalent to Inst. Proof. See Appendix.
Reference: [FR95] <author> Eddy Fromentin and Michel Raynal. </author> <title> Characterizing and detecting the set of global states seen by all observers of a distributed computation. </title> <booktitle> In Proc. IEEE 15th International Conference on Distributed Computing Systems (ICDCS, </booktitle> <year> 1995. </year>
Reference-contexts: In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. We show that this single modality, which we denote by Inst, is closely related to Fromentin and Raynal's concept of Properly <ref> [FR94, FR95] </ref>, and we adapt for detecting Inst an algorithm of theirs for detecting Properly. Our detection framework is applicable to a wide range of systems, since it does not require that clocks be synchronized to within a fixed bound. <p> Our algorithm for detecting Inst is based on Fromentin and Raynal's algorithm for detecting Properly (read "properly") in asynchronous systems <ref> [FR94, FR95] </ref>. The definition of Properly, generalized to an arbitrary ordering on events, is: Properly: A computation c satisfies Properly e ,! iff there is a global state satisfying and contained in every path of hCGS e Theorem 6. Properly e is equivalent to Inst. Proof. See Appendix.
Reference: [GW94] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3) </volume> <pages> 299-307, </pages> <year> 1994. </year>
Reference-contexts: Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 In this paper, all partial orderings are irreflexive unless specified otherwise. 1 Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens. <p> We obtain algorithms for detecting Poss T and Def T by adapting (and, as we do so, optimizing) algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. Modalities based on e ! are quite different, because e ! (unlike e e ) is not a partial ordering. In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. <p> both cases, the worst-case time complexity is linear in E, which is normally much larger than N ; in contrast, the worst-case time complexity of general algorithms for detecting Poss and Def is (E N ). 4.2 Algorithms for Poss T and Def T for Restricted Predicates Garg and Waldecker <ref> [GW94, GW96] </ref> have developed efficient algorithms for detecting Poss and Def for conjunctive predicates . A predicate is conjunctive if it is a conjunction of predicates that each depend on the local state of one process.
Reference: [GW96] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of strong unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 7(12) </volume> <pages> 1323-1333, </pages> <year> 1996. </year>
Reference-contexts: Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 In this paper, all partial orderings are irreflexive unless specified otherwise. 1 Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens. <p> We obtain algorithms for detecting Poss T and Def T by adapting (and, as we do so, optimizing) algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. Modalities based on e ! are quite different, because e ! (unlike e e ) is not a partial ordering. In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. <p> both cases, the worst-case time complexity is linear in E, which is normally much larger than N ; in contrast, the worst-case time complexity of general algorithms for detecting Poss and Def is (E N ). 4.2 Algorithms for Poss T and Def T for Restricted Predicates Garg and Waldecker <ref> [GW94, GW96] </ref> have developed efficient algorithms for detecting Poss and Def for conjunctive predicates . A predicate is conjunctive if it is a conjunction of predicates that each depend on the local state of one process. <p> Note that the time complexity is independent of the rate of events and the quality of clock synchronization. The algorithm in <ref> [GW96] </ref> for detecting Def for conjunctive can be adapted in a similar way to detect Def T for such predicates. 8 On receiving x from process i: append (q i ; x); if head (q i ) = x then add records for i to p 1 and p 2 ;
Reference: [JMN95] <author> R. Jegou, R. Medina, and L. Nourine. </author> <title> Linear space algorithm for on-line detection of global predicates. </title> <editor> In J. Desel, editor, </editor> <booktitle> Proc. International Workshop on Structures in Concurrency Theory (STRICT '95), Workshops in Computing. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 In this paper, all partial orderings are irreflexive unless specified otherwise. 1 Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year>
Reference-contexts: Cooper and Marzullo proposed a solution for asynchronous distributed systems [CM91]. Their solution involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely"). These modalities are based on logical time <ref> [Lam78] </ref> as embodied in the happened-before relation e a partial ordering 1 of events that reflects causal dependencies. Happened-before is not a total order, so it does not uniquely determine the history, but it does restrict the possibilities.
Reference: [Mil91] <author> David L. Mills. </author> <title> Internet time synchronization: the Network Time Protocol. </title> <journal> IEEE Trans. Communications, </journal> <volume> 39(10) </volume> <pages> 1482-1493, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds [Mil95]. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds <ref> [Mil91, Mil95] </ref>.
Reference: [Mil95] <author> David L. Mills. </author> <title> Improved algorithms for synchronizing computer network clocks. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(3) </volume> <pages> 245-254, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Implementing such timestamps is straightforward assuming the underlying clock synchronization mechanism provides bounds on the offsets between clocks. 2 For example, such information can be obtained from NTP <ref> [Mil95] </ref> or the Distributed Time Service in OSF DCE [Tan95]. The quality of clock synchronization affects the event orderings described above and therefore the results of detection. For example, consider Inst . <p> We expect the above condition on the bounds on the offsets to hold in many systems. In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds <ref> [Mil95] </ref>. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds [Mil91, Mil95]. <p> In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds [Mil95]. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds <ref> [Mil91, Mil95] </ref>.
Reference: [MN91] <author> Keith Marzullo and Gil Neiger. </author> <title> Detection of global state predicates. </title> <booktitle> In Proc. 5th International Workshop on Distributed Algorithms (WDAG '91), volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We consider first general algorithms for Poss T and Def T and then more efficient algorithms that work only for predicates of a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore the lattice hCGS e (c); G i by (roughly) replacing each condition of the form e e ! hb e 0 with e e e 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of <p> a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore the lattice hCGS e (c); G i by (roughly) replacing each condition of the form e e ! hb e 0 with e e e 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of CGSs at a time. The level of a global state g is i=1 L (S (g (i))). Level ` of the lattice of CGSs contains the CGSs with level `. <p> Another approach (described in <ref> [MN91] </ref>) requires knowledge of a 5 Several straightforward optimizations are possible. For example, each message might describe only the differences between consecutive reported local states, rather than repeating the entire local state. <p> For example, expiration of a lease and granting of another lease to a different machine need not be related by happened-before, so Poss :cohrnt may be detected, even though coherence was maintained and Poss T :cohrnt would not be detected. 7 Related and Future Work Marzullo and Neiger <ref> [MN91] </ref> define two detection modalities for partially-synchronous systems. <p> In the notation of this paper, those modalities are Poss e ! MN and Def ! MN , where e ! MN e 0 e e Combining logical and real-time orderings in this way exploits more information about the computation but requires that the system maintain vector clocks. In <ref> [MN91] </ref>, there is no discussion of an event ordering analogous to e ! or a modality analogous to Inst. Also, [MN91] considers only systems in which all clocks are always synchronized within a fixed offset *, while our framework accommodates varying quality of synchronization. <p> In <ref> [MN91] </ref>, there is no discussion of an event ordering analogous to e ! or a modality analogous to Inst. Also, [MN91] considers only systems in which all clocks are always synchronized within a fixed offset *, while our framework accommodates varying quality of synchronization.
Reference: [SM94] <author> Reinhard Schwarz and Friedemann Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7(3) </volume> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Ideals of hEv (c); e ! hb i are usually called consistent cuts. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [DJR93]. Furthermore, the lattice of CGSs ordered by G is isomorphic to the lattice of consistent cuts <ref> [SM94, BM93] </ref>. This isomorphism has an important consequence for detection algorithms; specifically, it implies that a minimal increase with respect to G corresponds to advancing one process by one event, and hence that the lattice of CGSs can be explored by repeatedly advancing one process by one event. <p> Theorem 1. For any process-wise-total partial ordering e ,! on Ev (c), the partial order hCGS e is a lattice and is isomorphic to the lattice of ideals of hEv (c); e Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [SM94, BM93, DJR93] </ref>. The proof is straightforward. The following corollary underlies the detection algorithms in Sections 4 and 5. Corollary 2.
Reference: [SS95] <author> Scott D. Stoller and Fred B. Schneider. </author> <title> Faster possibility detection by combining two approaches. </title> <editor> In Jean-Michel Helary and Michel Raynal, editors, </editor> <booktitle> Proc. 9th International Workshop on Distributed Algorithms (WDAG '95), volume 972 of Lecture Notes in Computer Science, </booktitle> <pages> pages 318-332. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 In this paper, all partial orderings are irreflexive unless specified otherwise. 1 Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens.
Reference: [Tan95] <author> Andrew S. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: Implementing such timestamps is straightforward assuming the underlying clock synchronization mechanism provides bounds on the offsets between clocks. 2 For example, such information can be obtained from NTP [Mil95] or the Distributed Time Service in OSF DCE <ref> [Tan95] </ref>. The quality of clock synchronization affects the event orderings described above and therefore the results of detection. For example, consider Inst .
Reference: [Ver93] <author> Paulo Verssimo. </author> <title> Real-time communication. In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <volume> chapter 17, </volume> <pages> pages 447-490. </pages> <publisher> Addison Wesley, </publisher> <address> 2nd edition, </address> <year> 1993. </year> <month> 13 </month>
Reference-contexts: In [MN91], there is no discussion of an event ordering analogous to e ! or a modality analogous to Inst. Also, [MN91] considers only systems in which all clocks are always synchronized within a fixed offset *, while our framework accommodates varying quality of synchronization. Verssimo <ref> [Ver93] </ref> discusses the uncertainty in event orderings caused by the granularity 6 and imperfect synchronization of digital real-time clocks, analyzes the conditions under which this uncertainty is significant for an application, and describes a synchronization technique, suitable for certain applications, that masks this uncertainty. However, [Ver93] does not aim for a <p> Verssimo <ref> [Ver93] </ref> discusses the uncertainty in event orderings caused by the granularity 6 and imperfect synchronization of digital real-time clocks, analyzes the conditions under which this uncertainty is significant for an application, and describes a synchronization technique, suitable for certain applications, that masks this uncertainty. However, [Ver93] does not aim for a general approach to detecting global predicates in the presence of this uncertainty. This paper proposes a foundation for detection of global predicate in systems with approximately-synchronized real-time clocks. One direction for future work is to implement and gain experience with the detection algorithms.
References-found: 18

