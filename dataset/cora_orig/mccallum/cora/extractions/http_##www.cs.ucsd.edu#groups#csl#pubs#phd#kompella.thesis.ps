URL: http://www.cs.ucsd.edu/groups/csl/pubs/phd/kompella.thesis.ps
Refering-URL: http://www.cs.ucsd.edu/groups/csl/pubs/author.html
Root-URL: http://www.cs.ucsd.edu
Title: Multicast Routing Algorithms for Multimedia Traffic  
Author: Professor Joseph C. Pasquale, Co-Chairperson Professor George C. Polyzos, Co-Chairperson Professor Christos H. Papadimitriou 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree Doctor of Philosophy in Computer Science and Engineering by Vachaspathi Peter Kompella Committee in charge:  Professor Samuel Buss Professor Rene Cruz  
Date: 1993  
Affiliation: UNIVERSITY OF CALIFORNIA, SAN DIEGO  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Hopper, </author> <title> "Pandora The design and use of a multimedia system," </title> <booktitle> IEE Colloquium on `Multimedia Communications and Applications', </booktitle> <pages> pp. 2/1-3, </pages> <month> Feb. </month> <year> 1991. </year> <booktitle> IEE Colloquium on `Multimedia Communications and Applications' (Digest No.031), </booktitle> <address> London, UK, </address> <month> 7 Feb. </month> <year> 1991. </year>
Reference-contexts: For example, the concept of the videophone is a very old one, a familiar sight in science fiction. We see instances now of the videophone, both commercial and non-commercial <ref> [1, 2] </ref>. The natural extension to the videophone is the conference application [3], possibly a very important product for the business world, if it is designed right. Much other work goes on to import multimedia into applications. <p> int i, xlen, ylen; for (i = 0; i &lt; nnodes; i++) - xlen = Node [i].x - x; ylen = Node [i].y - y; if ((xlen*xlen+ylen*ylen) &lt;= 36) - if (Node [i].status == Unselected) - Node [i].status = Selected_member; SelectedNodes [i] = 1; FillNode (Win [0], i); FillNode (Win <ref> [1] </ref>, i); newnodes++; - else if (Node [i].status == Selected_member) - Node [i].status = Unselected; SelectedNodes [i] = 0; FillNode (Win [0], i); FillNode (Win [1], i); newnodes--; - else DisplayError (SOURCE_SET); 93 return -1; - return 1; - /* Draws an edge */ DrawEdge (win, i) Window win; int i; <p> if ((xlen*xlen+ylen*ylen) &lt;= 36) - if (Node [i].status == Unselected) - Node [i].status = Selected_member; SelectedNodes [i] = 1; FillNode (Win [0], i); FillNode (Win <ref> [1] </ref>, i); newnodes++; - else if (Node [i].status == Selected_member) - Node [i].status = Unselected; SelectedNodes [i] = 0; FillNode (Win [0], i); FillNode (Win [1], i); newnodes--; - else DisplayError (SOURCE_SET); 93 return -1; - return 1; - /* Draws an edge */ DrawEdge (win, i) Window win; int i; GC gc; if (Edge [i].status == Selected) gc = Thickline_gc; else - gc = Main_gc; XDrawLine (display, win, Thicklinefg_gc, Node [Edge [i].s].x, Node [Edge [i].s].y, <p> &lt; nnodes; i++) - xlen = Node [i].x - x; ylen = Node [i].y - y; 94 if ((xlen*xlen+ylen*ylen) &lt;= 36) - if (Node [i].status == Unselected && !Source_selected) - Node [i].status = Selected; SelectedNodes [i] = 1; Source_selected = 1; source = i; FillNode (Win [0], i); FillNode (Win <ref> [1] </ref>, i); newnodes++; if (A) - ShortestPaths (); max = 0; for (i = 0; i &lt; nnodes; i++) if (NewDelay [source][i] &gt; max) max = NewDelay [source][i]; D = 2*max; DisplayStats (Win [0]); CSP (); - else if (Node [i].status == Selected_source) - Source_selected = 0; SelectedNodes [i] = 0; <p> 0; i &lt; nnodes; i++) if (NewDelay [source][i] &gt; max) max = NewDelay [source][i]; D = 2*max; DisplayStats (Win [0]); CSP (); - else if (Node [i].status == Selected_source) - Source_selected = 0; SelectedNodes [i] = 0; source = -1; Node [i].status = Unselected; FillNode (Win [0], i); FillNode (Win <ref> [1] </ref>, i); newnodes--; - else DisplayError (SOURCE_SET); return -1; - for (i = 0; i &lt; nedges; i++) - startx = Node [Edge [i].s].x; endx = Node [Edge [i].e].x; starty = Node [Edge [i].s].y; endy = Node [Edge [i].e].y; if ((startx &lt;= x && endx &gt;= x) || (startx &gt;= x <p> if (newy &lt; 0) newy = -newy; if ((-5 &lt;= newx && newx &lt;= 5) && (0 &lt;= newy && newy &lt;= len)) - if (Edge [i].status != Selected) - Edge [i].status = Selected; DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - else - Edge [i].status = Unselected; 95 DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win [1], i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - return i; <p> newy = -newy; if ((-5 &lt;= newx && newx &lt;= 5) && (0 &lt;= newy && newy &lt;= len)) - if (Edge [i].status != Selected) - Edge [i].status = Selected; DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - else - Edge [i].status = Unselected; 95 DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win [1], i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - return i; - - for (i <p> &lt;= newx && newx &lt;= 5) && (0 &lt;= newy && newy &lt;= len)) - if (Edge [i].status != Selected) - Edge [i].status = Selected; DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - else - Edge [i].status = Unselected; 95 DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win [1], i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - return i; - - for (i = 0; i &lt; 2; <p> [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - else - Edge [i].status = Unselected; 95 DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win [1], i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - return i; - - for (i = 0; i &lt; 2; i++) if (x-Box [i].x &lt; WIDTH && x-Box [i].x &gt;= 0 && y-Box [i].y &lt; WIDTH && y-Box [i].y &gt;= 0) break; if (i &lt; 2) - <p> [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - else - Edge [i].status = Unselected; 95 DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win [1], i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - return i; - - for (i = 0; i &lt; 2; i++) if (x-Box [i].x &lt; WIDTH && x-Box [i].x &gt;= 0 && y-Box [i].y &lt; WIDTH && y-Box [i].y &gt;= 0) break; if (i &lt; 2) - D--; else D++; D <p> [0], Edge [i].e); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - else - Edge [i].status = Unselected; 95 DrawEdge (Win [0], i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); DrawEdge (Win [1], i); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - return i; - - for (i = 0; i &lt; 2; i++) if (x-Box [i].x &lt; WIDTH && x-Box [i].x &gt;= 0 && y-Box [i].y &lt; WIDTH && y-Box [i].y &gt;= 0) break; if (i &lt; 2) - D--; else D++; D = 1; if (D &gt; <p> - double theta; int x, y, xmid, ymid; char ch [3], str [NUMLEN]; XGetWindowAttributes (display, win, &Main_xwa); XClearWindow (display, win); XDrawLine (display, win, Main_gc, 0, Main_xwa.height-DISPLAY_WINDOW_HEIGHT, Main_xwa.width, Main_xwa.height - DISPLAY_WINDOW_HEIGHT); theta = (double) 2*PI/nnodes; for (i = 0; i &lt; nedges; i++) - DrawEdge (win, i); if (win == Win <ref> [1] </ref>) - itoa (Delay [Edge [i].s][Edge [i].e], str); xmid = (Node [Edge [i].s].x + Node [Edge [i].e].x)/2; ymid = (Node [Edge [i].s].y + Node [Edge [i].e].y)/2; XDrawString (display, win, Main_gc, xmid-20, ymid, str, strlen (str)); - else - itoa (Cost [Edge [i].s][Edge [i].e], str); xmid = (Node [Edge [i].s].x + Node <p> (display, win, Main_bgc, x, y, str, strlen (str)); - DisplayStats (win); - /* redisplays total tree capacity if it has changed */ RecomputeWeights (selected_edge) int selected_edge; - if (Edge [selected_edge].status == Selected) TotalCapacity += Cost [Edge [selected_edge].s][Edge [selected_edge].e]; else TotalCapacity -= Cost [Edge [selected_edge].s][Edge [selected_edge].e]; DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); - /* display error in selection of edge or node */ DisplayError (id) int id; if (!interactive) return; XBell (display, 0); XClearArea (display, Win [0], 0, ErrMessage_y, Main_xwa.width-60, fy_increment, False); 102 XDrawString (display, Win [0], Main_gc, Message_x, ErrMessage_y, ErrMsgs [id], strlen (ErrMsgs [id])); - /* display total tree capacity, and <p> (stderr, "Error in graph: alg %d"n", alg); for (i = 0; i &lt; nedges; i++) - if (Adj [Edge [i].s][Edge [i].e] == 2) - Adj [Edge [i].s][Edge [i].e] = 1; Adj [Edge [i].e][Edge [i].s] = 1; - Edge [i].status = Unselected; - if (interactive) - RedrawMainWindow (Win [0]); RedrawMainWindow (Win <ref> [1] </ref>); - SaveGraph (); return 0; - TotalCapacity = 0; tree_edges = 0; LongestDelay = 0; for (i = 0; i &lt; nnodes; i++) if (Node [i].status != Unselected && SPP [i] &gt; LongestDelay) LongestDelay = SPP [i]; for (i = 0; i &lt; nedges; i++) - if (Adj [Edge [i].s][Edge <p> - if (Adj [Edge [i].s][Edge [i].e] == 2) - Adj [Edge [i].s][Edge [i].e] = 1; Adj [Edge [i].e][Edge [i].s] = 1; Edge [i].status = Selected; 104 tree_edges++; TotalCapacity += Cost [Edge [i].s][Edge [i].e]; - else Edge [i].status = Unselected; #ifdef OPENWIN if (interactive) - DrawEdge (Win [0], i); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - #endif - #ifdef OPENWIN /* * Check for events, and handle them. <p> 1; Adj [Edge [i].e][Edge [i].s] = 1; Edge [i].status = Selected; 104 tree_edges++; TotalCapacity += Cost [Edge [i].s][Edge [i].e]; - else Edge [i].status = Unselected; #ifdef OPENWIN if (interactive) - DrawEdge (Win [0], i); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - #endif - #ifdef OPENWIN /* * Check for events, and handle them. <p> = 1; Edge [i].status = Selected; 104 tree_edges++; TotalCapacity += Cost [Edge [i].s][Edge [i].e]; - else Edge [i].status = Unselected; #ifdef OPENWIN if (interactive) - DrawEdge (Win [0], i); DrawEdge (Win <ref> [1] </ref>, i); FillNode (Win [0], Edge [i].s); FillNode (Win [0], Edge [i].e); FillNode (Win [1], Edge [i].s); FillNode (Win [1], Edge [i].e); - #endif - #ifdef OPENWIN /* * Check for events, and handle them. <p> EventType, line; /* event-processing loop */ while (1) - /* wait for event */ XNextEvent (display, &Event); EventWindow = Event.xany.window; EventType = Event.type; switch (EventType) - case Expose: /* wait for all exposes to finish */ if (Event.xexpose.count == 0) - if (EventWindow == Win [0] || EventWindow == Win <ref> [1] </ref>) RedrawMainWindow (EventWindow); else MenuEvent (&Event); - break; case ButtonPress: if (EventWindow == Win [0] || EventWindow == Win [1]) - if (Event.xbutton.button == Button3 && Menu_open == -1) OpenMenu (); else if (Event.xbutton.button == Button3 && Menu_open == 0) - Menu_open = 1; XMapWindow (display, Menu_window); XFlush (display); - else <p> Event.xany.window; EventType = Event.type; switch (EventType) - case Expose: /* wait for all exposes to finish */ if (Event.xexpose.count == 0) - if (EventWindow == Win [0] || EventWindow == Win <ref> [1] </ref>) RedrawMainWindow (EventWindow); else MenuEvent (&Event); - break; case ButtonPress: if (EventWindow == Win [0] || EventWindow == Win [1]) - if (Event.xbutton.button == Button3 && Menu_open == -1) OpenMenu (); else if (Event.xbutton.button == Button3 && Menu_open == 0) - Menu_open = 1; XMapWindow (display, Menu_window); XFlush (display); - else if (Event.xbutton.button == Button1) - /* check if button is on a line and highlight it */ if ((line <p> (pane) Window pane; - if (pane == Pane [QUIT]) - XFreeGC (display, Menu_gc); XFreeGC (display, Bold_gc); XFreeGC (display, RV_gc); for (i = 0; i &lt; MAXCHOICE; i++) XDestroyWindow (display, Pane [i]); XDestroyWindow (display, Menu_window); XDestroyWindow (display, Main_window); XCloseDisplay (display); exit (0); - XUnmapWindow (display, Menu_window); RedrawMainWindow (Win [0]); RedrawMainWindow (Win <ref> [1] </ref>); Menu_open = 0; for (i = 0; i &lt; MAXCHOICE; i++) if (Pane [i] == pane) break; switch (i) - case LOAD: LoadGraph (); CSP (); RedrawMainWindow (Win [0]); RedrawMainWindow (Win [1]); break; case SAVE: SaveGraph (); break; case NEWGRAPH: if (debug) - printf ("source: %d"n", source); printf ("Destinations: "); <p> (display, Menu_window); XDestroyWindow (display, Main_window); XCloseDisplay (display); exit (0); - XUnmapWindow (display, Menu_window); RedrawMainWindow (Win [0]); RedrawMainWindow (Win <ref> [1] </ref>); Menu_open = 0; for (i = 0; i &lt; MAXCHOICE; i++) if (Pane [i] == pane) break; switch (i) - case LOAD: LoadGraph (); CSP (); RedrawMainWindow (Win [0]); RedrawMainWindow (Win [1]); break; case SAVE: SaveGraph (); break; case NEWGRAPH: if (debug) - printf ("source: %d"n", source); printf ("Destinations: "); for (i = 0; i &lt; nnodes; i++) if (Node [i].status == Selected_member) printf ("%3d ", i); printf (""n"); printf ("Delay and Cost"n "); for (i = 0; i &lt; nnodes-1; i++) <p> (j = i; j &lt; nnodes; j++) printf (" "); printf ("(%3d)", i); for (j = 0; j &lt; i; j++) printf ("%3d ", Cost [i][j]); else printf (" * "); printf (""n"); - loaded = 0; while (!MakeGraph ()); break; case RANDOM: TotallyRandom (); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case OPTTREE: AllTrees (0); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case SHORTEST_PATH: ShortestPaths (); DisplaySP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case <p> ("(%3d)", i); for (j = 0; j &lt; i; j++) printf ("%3d ", Cost [i][j]); else printf (" * "); printf (""n"); - loaded = 0; while (!MakeGraph ()); break; case RANDOM: TotallyRandom (); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case OPTTREE: AllTrees (0); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case SHORTEST_PATH: ShortestPaths (); DisplaySP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case <p> Cost [i][j]); else printf (" * "); printf (""n"); - loaded = 0; while (!MakeGraph ()); break; case RANDOM: TotallyRandom (); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case OPTTREE: AllTrees (0); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case SHORTEST_PATH: ShortestPaths (); DisplaySP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 <p> while (!MakeGraph ()); break; case RANDOM: TotallyRandom (); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case OPTTREE: AllTrees (0); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case SHORTEST_PATH: ShortestPaths (); DisplaySP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats <p> DisplayStats (Win <ref> [1] </ref>); break; case OPTTREE: AllTrees (0); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case SHORTEST_PATH: ShortestPaths (); DisplaySP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats <p> DisplayStats (Win <ref> [1] </ref>); break; case SHORTEST_PATH: ShortestPaths (); DisplaySP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); <p> (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case CON_SHORTEST_PATH: CSP (); DisplayCSP (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); <p> (); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case MULTICAST1_TREE_1: Multicast1 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CLEAR_SELECTIONS: for (i <p> (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case MULTICAST1_TREE_2: Multicast1 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CLEAR_SELECTIONS: for (i = 0; i &lt; nnodes; i++) Node [i].status = Unselected; for <p> (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case MULTICAST1_TREE_3: Multicast1 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CLEAR_SELECTIONS: for (i = 0; i &lt; nnodes; i++) Node [i].status = Unselected; for (i = 0; i &lt; nedges; i++) Edge [i].status = Unselected; <p> DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case MULTICAST1_TREE_4: Multicast1 (CriticalMeasure4); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CLEAR_SELECTIONS: for (i = 0; i &lt; nnodes; i++) Node [i].status = Unselected; for (i = 0; i &lt; nedges; i++) Edge [i].status = Unselected; Source_selected = 0; newnodes = 0; RedrawMainWindow (Win [0]); RedrawMainWindow (Win [1]); <p> DisplayStats (Win [0]); DisplayStats (Win <ref> [1] </ref>); break; case MULTICAST2_TREE_1: Multicast2 (); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_1: Multicast3 (CriticalMeasure1); DisplayStats (Win [0]); DisplayStats (Win [1]); 123 break; case MULTICAST3_TREE_2: Multicast3 (CriticalMeasure2); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CLEAR_SELECTIONS: for (i = 0; i &lt; nnodes; i++) Node [i].status = Unselected; for (i = 0; i &lt; nedges; i++) Edge [i].status = Unselected; Source_selected = 0; newnodes = 0; RedrawMainWindow (Win [0]); RedrawMainWindow (Win [1]); break; default: break; - /* highlight the selected pane */ Highlight <p> <ref> [1] </ref>); break; case MULTICAST3_TREE_3: Multicast3 (CriticalMeasure3); DisplayStats (Win [0]); DisplayStats (Win [1]); break; case CLEAR_SELECTIONS: for (i = 0; i &lt; nnodes; i++) Node [i].status = Unselected; for (i = 0; i &lt; nedges; i++) Edge [i].status = Unselected; Source_selected = 0; newnodes = 0; RedrawMainWindow (Win [0]); RedrawMainWindow (Win [1]); break; default: break; - /* highlight the selected pane */ Highlight (pane, hl) Window pane; int hl; int i; int color; for (i = 1; i &lt; MAXCHOICE; i++) if (Pane [i] == pane) - if (hl) - color = foreground; - else - gc = Menu_gc; color = background;
Reference: [2] <author> S. Early, A. Kuzma, and E. Dorsey, </author> <title> "The Videophone 2500 Video telephony on the public switched telephone network," </title> <journal> AT&T Technical Journal, </journal> <volume> vol. 72, </volume> <pages> pp. 22-32, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: For example, the concept of the videophone is a very old one, a familiar sight in science fiction. We see instances now of the videophone, both commercial and non-commercial <ref> [1, 2] </ref>. The natural extension to the videophone is the conference application [3], possibly a very important product for the business world, if it is designed right. Much other work goes on to import multimedia into applications. <p> i &lt; tree_edges; i++) - Adj [SaveSPT [i].i][SaveSPT [i].j] = 2; Adj [SaveSPT [i].j][SaveSPT [i].i] = 2; - 89 * geom.c * ************** #include "mainwin.h" #include &lt;math.h&gt; /* Global declarations */ int Degree [MAX_NODES]; const_init = 0; /* extern declarations */ #ifdef OPENWIN extern Display *display; extern Window Main_window, Win <ref> [2] </ref>; extern GC Main_gc, Thickline_gc, Thicklinefg_gc; extern XGCValues Main_gcv; extern int foreground, background; #endif extern NODE Node [MAX_NODES]; extern int SelectedNodes [MAX_NODES]; extern int Adj [MAX_NODES][MAX_NODES]; extern int Delay [MAX_NODES][MAX_NODES]; extern int Cost [MAX_NODES][MAX_NODES]; extern int PathExists [MAX_NODES][MAX_NODES][MAX_DELAY]; extern int PathCost [MAX_NODES][MAX_NODES][MAX_DELAY]; extern int SPPath [MAX_NODES][MAX_NODES][MAX_DELAY]; extern int NewDelay [MAX_NODES][MAX_NODES]; extern <p> [5][4] = 3; Delay [5][5] = 0; Node [0].status = 1; Node [4].status = 2; Node [5].status = 2; source = 0; D = 15; Source_selected = 1; newnodes = 3; - 98 * mainwin.c * ************** #include "mainwin.h" #ifdef OPENWIN /* Global declarations */ Display *display; Window Main_window, Win <ref> [2] </ref>; GC Main_gc, Main_bgc, Thickline_gc, Thicklinefg_gc; XGCValues Main_gcv, Main_bgcv, Thickline_gcv, Thicklinefg_gcv; XWindowAttributes Main_xwa; XSizeHints Main_xsh; XWMHints Main_xwmh; XSetWindowAttributes Main_xswa; XFontStruct *ffontstruct, *bfontstruct; Pixmap icon_pixmap; int fx_increment, fy_increment, font_start; int foreground, background, borderwidth; Cursor cursor; struct box Box [] = - 360, 485, 380, 485 -; #endif /* extern data structures */ <p> Pane_bw; Window Pane [MAXCHOICE]; char *Menu_Label [] = - "Menu", "Load Graph", "Save Graph", "New Graph", "Random", "Optimal Tree", "Shortest Delay", "Constrained SP", "MCT G, C/(D-P)", "MCT G, C", "MCT G, C/(D-P-D (e)) II", "MCT L, C/(D-P-D (e)) I", "Clear Selections", "Quit", -; extern Display *display; extern Window Main_window, Win <ref> [2] </ref>; extern XFontStruct *ffontstruct, *bfontstruct; extern int fy_increment, font_start; extern int foreground, background, borderwidth; #endif extern NODE Node [MAX_NODES]; extern int Adj [MAX_NODES][MAX_NODES]; extern int Delay [MAX_NODES][MAX_NODES]; extern int Cost [MAX_NODES][MAX_NODES]; extern int newnodes; extern int nnodes; extern int nedges; 119 extern int debug; extern int loaded; extern int source; extern
Reference: [3] <author> S. Losee, </author> <title> "Videoconferencing gets cheaper," </title> <journal> Fortune, </journal> <volume> vol. 123, </volume> <editor> p. </editor> <volume> 76, </volume> <month> Mar. </month> <year> 1991. </year>
Reference-contexts: For example, the concept of the videophone is a very old one, a familiar sight in science fiction. We see instances now of the videophone, both commercial and non-commercial [1, 2]. The natural extension to the videophone is the conference application <ref> [3] </ref>, possibly a very important product for the business world, if it is designed right. Much other work goes on to import multimedia into applications. In the medical world, the work at [4] is an experiment to use multimedia communications to more efficiently diagnose patients. <p> ExposureMask); for (i = 0; i &lt; 2; i++) XSelectInput (display, Win [i], (ExposureMask|ButtonPressMask)); /* Map window */ XMapWindow (display, Main_window); XMapSubwindows (display, Main_window); XFlush (display); - /* refresh main windows after exposes, etc. */ RedrawMainWindow (win) 101 Window win; - double theta; int x, y, xmid, ymid; char ch <ref> [3] </ref>, str [NUMLEN]; XGetWindowAttributes (display, win, &Main_xwa); XClearWindow (display, win); XDrawLine (display, win, Main_gc, 0, Main_xwa.height-DISPLAY_WINDOW_HEIGHT, Main_xwa.width, Main_xwa.height - DISPLAY_WINDOW_HEIGHT); theta = (double) 2*PI/nnodes; for (i = 0; i &lt; nedges; i++) - DrawEdge (win, i); if (win == Win [1]) - itoa (Delay [Edge [i].s][Edge [i].e], str); xmid = (Node
Reference: [4] <author> T. Clemmer and R. Gardner, </author> <title> "Medical informatics in the intensive care unit - state of the art 1991," </title> <journal> International Journal of Clinical Monitoring and Computing, </journal> <volume> vol. 8, no. 4, </volume> <pages> pp. 237-250, </pages> <year> 1991. </year>
Reference-contexts: The natural extension to the videophone is the conference application [3], possibly a very important product for the business world, if it is designed right. Much other work goes on to import multimedia into applications. In the medical world, the work at <ref> [4] </ref> is an experiment to use multimedia communications to more efficiently diagnose patients. Education is another field that benefits substantially from multimedia technology, since it is much easier to learn with visual and aural stimuli.
Reference: [5] <author> M. Stonebraker, </author> <title> "An overview of the Sequoia 2000 project," </title> <booktitle> in S2K-General [6], </booktitle> <pages> pp. 383-388. </pages> <booktitle> COMPCON Spring 1992, </booktitle> <address> Los Alamitos, CA, </address> <publisher> USA IEEE Comput. Soc. Press. </publisher>
Reference-contexts: Project Sequoia 2000, a collaborative effort between earth scientists and computer scientists at five campuses of the University of California, attempts to provide multimedia architectures that will allow global change research to be carried out more effectively <ref> [5] </ref>. The aim is to provide a database capable of storage and retrieval of large amounts of data that represent topological, climatic, atmospheric, and vegetative information of the earth [6]. The architecture allows for visualization of the data, and for communication between these scientists located far away from each other.
Reference: [6] <author> S. Guptill and M. Stonebraker, </author> <title> "The Sequoia 2000 approach to managing large spatial object databases," </title> <booktitle> Proceedings of the 5th International Symposium on Spatial Data Handling, </booktitle> <volume> vol. 2, </volume> <pages> pp. 642-651, </pages> <month> 3-7 Aug. </month> <year> 1992. </year> <booktitle> Proceedings. 5th International Symposium on Spatial Data Handling, </booktitle> <address> Charleston, SC, USA, 3-7 Aug. </address> <year> 1992). </year> <title> Edited by: </title> <editor> Bresnahan, P.; Corwin, E.; Cowen, D.; </editor> <address> Columbia, SC, USA: </address> <institution> Univ. South Carolina. </institution>
Reference-contexts: The aim is to provide a database capable of storage and retrieval of large amounts of data that represent topological, climatic, atmospheric, and vegetative information of the earth <ref> [6] </ref>. The architecture allows for visualization of the data, and for communication between these scientists located far away from each other. Each application presents a different kind of demand on the network, and has its peculiar expectations. <p> There is work in storage technologies to allow large data objects to be stored and retrieved at high rates <ref> [6] </ref>. Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12].
Reference: [7] <author> S. Brofferio, </author> <title> "An object-background image model for predictive video coding," </title> <journal> IEEE Transactions on Communications, </journal> <volume> vol. 37, </volume> <pages> pp. 1391-1394, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: We see many signs of this scientific method of developing models or trial applications, and validating them, or learning from their faults. For example, there is the development of models to characterize video and audio <ref> [7, 8, 9] </ref>. There is much activity in the area of compression that takes into account the redundancy of audio and video data, and permits the transmission of multimedia on lower bandwidth channels [10, 11].
Reference: [8] <author> D. Mitrakos, </author> <title> "Queueing model for integrated video and data communication systems," </title> <journal> International Journal of Electronics, </journal> <volume> vol. 69, </volume> <pages> pp. 487-500, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: We see many signs of this scientific method of developing models or trial applications, and validating them, or learning from their faults. For example, there is the development of models to characterize video and audio <ref> [7, 8, 9] </ref>. There is much activity in the area of compression that takes into account the redundancy of audio and video data, and permits the transmission of multimedia on lower bandwidth channels [10, 11].
Reference: [9] <author> P. Skelly, S. Dixit, and M. Schwartz, </author> <title> "A histogram-based model for video traffic behavior in an ATM network node with an application to congestion control," </title> <booktitle> IEEE INFOCOMM '92, </booktitle> <pages> pp. 95-104, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: We see many signs of this scientific method of developing models or trial applications, and validating them, or learning from their faults. For example, there is the development of models to characterize video and audio <ref> [7, 8, 9] </ref>. There is much activity in the area of compression that takes into account the redundancy of audio and video data, and permits the transmission of multimedia on lower bandwidth channels [10, 11].
Reference: [10] <author> G. Wallace, </author> <title> "The JPEG still picture compression standard," </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, </volume> <pages> pp. 30-44, </pages> <month> Apr. </month> <year> 1991. </year> <pages> 151 152 </pages>
Reference-contexts: For example, there is the development of models to characterize video and audio [7, 8, 9]. There is much activity in the area of compression that takes into account the redundancy of audio and video data, and permits the transmission of multimedia on lower bandwidth channels <ref> [10, 11] </ref>. There is work in storage technologies to allow large data objects to be stored and retrieved at high rates [6]. Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12].
Reference: [11] <author> D. Legall, </author> <title> "MPEG a video compression standard for multimedia applications," </title> <booktitle> in MPEG [10], </booktitle> <pages> pp. 46-58. </pages>
Reference-contexts: For example, there is the development of models to characterize video and audio [7, 8, 9]. There is much activity in the area of compression that takes into account the redundancy of audio and video data, and permits the transmission of multimedia on lower bandwidth channels <ref> [10, 11] </ref>. There is work in storage technologies to allow large data objects to be stored and retrieved at high rates [6]. Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12].
Reference: [12] <author> R. Govindan and D. Anderson, </author> <title> "Scheduling and IPC mechanisms for continuous media," </title> <booktitle> 13th ACM Symposium on Operating System Principles, </booktitle> <volume> vol. 25, </volume> <pages> pp. 68-80, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: There is work in storage technologies to allow large data objects to be stored and retrieved at high rates [6]. Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications <ref> [12] </ref>. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. <p> strcpy (&capstring [27], str); XDrawString (display, win, Main_gc, Message_x, Message_y, capstring, strlen (capstring)); itoa (tree_edges, str); strcpy (&Edgestring [15], str); XDrawString (display, win, Main_gc, Message_x, Message_y+fy_increment, Edgestring, strlen (Edgestring)); itoa (LongestDelay, str); strcpy (&Delaystring [16], str); XDrawString (display, win, Main_gc, Message_x, Message_y+2*fy_increment, Delaystring, strlen (Delaystring)); itoa (D, str); strcpy (&Tolerancestring <ref> [12] </ref>, str); XDrawString (display, win, Main_gc, Message_x, Message_y+3*fy_increment, Tolerancestring, strlen (Tolerancestring)); for (i = 0; i &lt; 2; i++) XDrawRectangle (display, win, Main_gc, Box [i].x, Box [i].y, WIDTH, WIDTH); XDrawString (display, win, Main_bgc, Box [0].x+1, Box [0].y+10, "-", 1); XDrawString (display, win, Main_bgc, Box [1].x+2, Box [1].y+9, "+", 1); - else
Reference: [13] <author> Y. Oie, T. Suda, M. Murata, and H. Miyahara, </author> <title> "Survey of switching techniques in high-speed networks and their performance," </title> <journal> International Journal of Satellite Communications, </journal> <volume> vol. 9, </volume> <pages> pp. 285-303, </pages> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control <ref> [13, 14, 15] </ref>, routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW). <p> In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures <ref> [23, 13, 24, 25, 26] </ref>, to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [14] <author> R. Cruz, </author> <title> "A calculus for network delay 1: Network elements in isolation," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> vol. 37, </volume> <pages> pp. 114-131, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control <ref> [13, 14, 15] </ref>, routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [15] <author> R. Cruz, </author> <title> "A calculus for network delay 2: Network Analysis," </title> <booktitle> in Admission-control [14], </booktitle> <pages> pp. 132-141. </pages>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control <ref> [13, 14, 15] </ref>, routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW). <p> i, dir, a, d, k; XCharStruct overall; XGetWindowAttributes (display, win, &Main_xwa); XClearArea (display, win, 0, Main_xwa.height - DISPLAY_WINDOW_HEIGHT + 5, Main_xwa.width, DISPLAY_WINDOW_HEIGHT, False); if (win == Win [0]) - itoa (TotalCapacity, str); strcpy (&capstring [27], str); XDrawString (display, win, Main_gc, Message_x, Message_y, capstring, strlen (capstring)); itoa (tree_edges, str); strcpy (&Edgestring <ref> [15] </ref>, str); XDrawString (display, win, Main_gc, Message_x, Message_y+fy_increment, Edgestring, strlen (Edgestring)); itoa (LongestDelay, str); strcpy (&Delaystring [16], str); XDrawString (display, win, Main_gc, Message_x, Message_y+2*fy_increment, Delaystring, strlen (Delaystring)); itoa (D, str); strcpy (&Tolerancestring [12], str); XDrawString (display, win, Main_gc, Message_x, Message_y+3*fy_increment, Tolerancestring, strlen (Tolerancestring)); for (i = 0; i &lt; 2; i++)
Reference: [16] <author> N. Shacham, </author> <title> "Multipoint communication by hierarchically encoded data," </title> <journal> IEEE INFOCOM '92, </journal> <volume> vol. 3, </volume> <pages> pp. 2107-2114, </pages> <month> 4-8 May </month> <year> 1992. </year> <booktitle> IEEE INFOCOM '92: Conference on Computer Communications. Eleventh Annual Joint Conference of the IEEE Computer and Communications Societies, </booktitle> <address> Florence, Italy. </address>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing <ref> [16, 17] </ref>, resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW). <p> - DISPLAY_WINDOW_HEIGHT + 5, Main_xwa.width, DISPLAY_WINDOW_HEIGHT, False); if (win == Win [0]) - itoa (TotalCapacity, str); strcpy (&capstring [27], str); XDrawString (display, win, Main_gc, Message_x, Message_y, capstring, strlen (capstring)); itoa (tree_edges, str); strcpy (&Edgestring [15], str); XDrawString (display, win, Main_gc, Message_x, Message_y+fy_increment, Edgestring, strlen (Edgestring)); itoa (LongestDelay, str); strcpy (&Delaystring <ref> [16] </ref>, str); XDrawString (display, win, Main_gc, Message_x, Message_y+2*fy_increment, Delaystring, strlen (Delaystring)); itoa (D, str); strcpy (&Tolerancestring [12], str); XDrawString (display, win, Main_gc, Message_x, Message_y+3*fy_increment, Tolerancestring, strlen (Tolerancestring)); for (i = 0; i &lt; 2; i++) XDrawRectangle (display, win, Main_gc, Box [i].x, Box [i].y, WIDTH, WIDTH); XDrawString (display, win, Main_bgc, Box [0].x+1,
Reference: [17] <author> S. Deering, </author> <title> "RFC 1112: Host Extensions for IP multicasting," </title> <type> RFC 1112, </type> <institution> Stan-ford University, </institution> <month> Aug. </month> <year> 1989. </year> <note> Obsoletes RFC 988, RFC 1054. </note>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing <ref> [16, 17] </ref>, resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW). <p> A large effort by the Internet Engineering Task Force is underway to provide multicast services to the Internet community <ref> [17, 30] </ref>. Applications are under test to see how subscribers appreciate multicast services, and how useful they are, as well as to test the ideas behind the design of these applications, like lightweight sessions. <p> The receiving server unpacks the delivered data, determines that it is a multicast packet, and delivers a copy to each local host. This procedure is used because many nodes on the Internet do not yet follow the IGMP protocol and do not understand multicast addresses. [30] and <ref> [17] </ref> describe the IP multicast facility. The principal change that would be needed to effect multicast routing using the algorithms we have described would be to implement CM CT C , replace the mrouted algorithm, and ensure that link-state information is delivered to each mul-ticast server.
Reference: [18] <author> D. Ferrari and D. Verma, </author> <title> "Real-time communication in a packet-switching network," Protocols for High-Speed Networks, </title> <booktitle> II, </booktitle> <pages> pp. 333-349, </pages> <month> 27-29 Nov. </month> <year> 1990. </year> <booktitle> Proceedings of the IFIP WG 6.1/WG 6.4 Second International Workshop Palo Alto, </booktitle> <address> CA, USA, </address> <note> Edited by: </note> <editor> Johnson, M.J., </editor> <address> Amsterdam, Netherlands: </address> <publisher> North-Holland. </publisher>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation <ref> [18, 19] </ref>, packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [19] <author> L. Zhang, </author> <title> "VirtualClock Anew traffic control algorithm for packet-switched networks," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, </volume> <pages> pp. 101-124, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation <ref> [18, 19] </ref>, packet scheduling [20, 21], protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [20] <author> D. Clark, S. Shenker, and L. Zhang, </author> <title> "Supporting real-time applications in an integrated services packet network: architecture and mechanism," </title> <booktitle> Proceedings of ACM SIGCOMM '92, </booktitle> <volume> vol. 22, </volume> <pages> pp. 14-26, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling <ref> [20, 21] </ref>, protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [21] <author> S. Keshav, </author> <title> "On the efficient implementation of fair queueing," </title> <journal> Journal of Inter-networking, </journal> <volume> vol. 2, </volume> <pages> pp. 157-173, </pages> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: Some work has been done to develop the right scheduling models for the operating system to support real-time video and audio applications [12]. In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling <ref> [20, 21] </ref>, protocols [22], and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [22] <author> C. Topolcic, </author> <title> "ST II," First International Workshop on Network and Operating System Support for Audio and Video, </title> <editor> p. </editor> <volume> 5, </volume> <month> 8-9 Nov. </month> <year> 1990. </year> <institution> Berkeley, CA, USA Int. Comput. Sci. Inst. </institution>
Reference-contexts: In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols <ref> [22] </ref>, and network architectures [23, 13, 24, 25, 26], to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [23] <author> R. Bubenik and J. Turner, </author> <title> "Performance of a broadcast packet switch," </title> <journal> IEEE Trans. on Comm., </journal> <volume> vol. 37, no. 1, </volume> <pages> pp. 60-69, </pages> <year> 1989. </year> <month> 153 </month>
Reference-contexts: In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures <ref> [23, 13, 24, 25, 26] </ref>, to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW). <p> Switches are being designed to accommodate this additional feature of copying to multiple output ports on the fly <ref> [23] </ref>. This would enable high-speed support of data delivery. 75 VII.E Interplay of Routing with Network Soft ware In order to effect multicast delivery, we see that we need several fairly substantial questions to be resolved.
Reference: [24] <author> J. Giacopelli, J. Hickey, W. Marcus, W. Sincoskie, and et al, </author> <title> "Sunshine A high-performance self-routing broadband packet switch architecture," </title> <booktitle> in ATM [25], </booktitle> <pages> pp. 1289-1298. </pages>
Reference-contexts: In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures <ref> [23, 13, 24, 25, 26] </ref>, to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [25] <author> I. Cidon, I. Gopal, and R. Guerin, </author> <title> "Bandwidth management and congestion control in plaNET," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 29, </volume> <pages> pp. 54-64, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures <ref> [23, 13, 24, 25, 26] </ref>, to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [26] <author> M. Karol and R. Gitlin, </author> <title> "High-performance optical local and metropolitan area networks enhancements of FDDI and IEEE 802.6 DQDB," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 8, </volume> <pages> pp. 1439-1448, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: In the area of computer networks, there is work in many areas, admission control [13, 14, 15], routing [16, 17], resource reservation [18, 19], packet scheduling [20, 21], protocols [22], and network architectures <ref> [23, 13, 24, 25, 26] </ref>, to name a few. I.B Group Communication An area receiving much attention nowadays is the field of computer supported cooperative work (CSCW).
Reference: [27] <author> W. Leung, T. Baumgartner, Y. Hwang, M. Morgan, and et al, </author> <title> "A Software architecture for workstations supporting multimedia conferencing in packet switching networks.," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 8, </volume> <pages> pp. 380-390, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: If people are unable to see each other, then the communications support system should be able to simulate the virtual presence of the collaborators. Without an effective communications system, the group effort is stilted. 4 There are efforts to develop programming methodologies <ref> [27, 28] </ref>, and there is work going on to discover the important pieces that make up a groupware application [29]. A large effort by the Internet Engineering Task Force is underway to provide multicast services to the Internet community [17, 30]. <p> delays to each node from source */ DisplayStats (win) Window win; - char str [NUMLEN]; int i, dir, a, d, k; XCharStruct overall; XGetWindowAttributes (display, win, &Main_xwa); XClearArea (display, win, 0, Main_xwa.height - DISPLAY_WINDOW_HEIGHT + 5, Main_xwa.width, DISPLAY_WINDOW_HEIGHT, False); if (win == Win [0]) - itoa (TotalCapacity, str); strcpy (&capstring <ref> [27] </ref>, str); XDrawString (display, win, Main_gc, Message_x, Message_y, capstring, strlen (capstring)); itoa (tree_edges, str); strcpy (&Edgestring [15], str); XDrawString (display, win, Main_gc, Message_x, Message_y+fy_increment, Edgestring, strlen (Edgestring)); itoa (LongestDelay, str); strcpy (&Delaystring [16], str); XDrawString (display, win, Main_gc, Message_x, Message_y+2*fy_increment, Delaystring, strlen (Delaystring)); itoa (D, str); strcpy (&Tolerancestring [12], str); XDrawString
Reference: [28] <author> J. Pasquale, G. Polyzos, E. Anderson, and V. Kompella, </author> <title> "The Multimedia Multi-cast Channel," </title> <booktitle> Third International Workshop on Network and Operating Systems Support for Digital Audio and Video, </booktitle> <address> Nov. 1992. San Diego, CA. </address>
Reference-contexts: If people are unable to see each other, then the communications support system should be able to simulate the virtual presence of the collaborators. Without an effective communications system, the group effort is stilted. 4 There are efforts to develop programming methodologies <ref> [27, 28] </ref>, and there is work going on to discover the important pieces that make up a groupware application [29]. A large effort by the Internet Engineering Task Force is underway to provide multicast services to the Internet community [17, 30].
Reference: [29] <author> S. Ahuja and J. </author> <title> Ensor, "Coordination and control of multimedia conferencing," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 30, </volume> <pages> pp. 38-43, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Without an effective communications system, the group effort is stilted. 4 There are efforts to develop programming methodologies [27, 28], and there is work going on to discover the important pieces that make up a groupware application <ref> [29] </ref>. A large effort by the Internet Engineering Task Force is underway to provide multicast services to the Internet community [17, 30].
Reference: [30] <author> D. Waitzman, C. Partridge, and S. Deering, </author> <title> "RFC 1075: Distance Vector Mul-ticast Routing Protocol," </title> <type> RFC 1075, </type> <institution> Stanford University and BBN, </institution> <month> Nov. </month> <year> 1988. </year> <note> Obsoletes RFC 988, RFC 1054. </note>
Reference-contexts: A large effort by the Internet Engineering Task Force is underway to provide multicast services to the Internet community <ref> [17, 30] </ref>. Applications are under test to see how subscribers appreciate multicast services, and how useful they are, as well as to test the ideas behind the design of these applications, like lightweight sessions. <p> The receiving server unpacks the delivered data, determines that it is a multicast packet, and delivers a copy to each local host. This procedure is used because many nodes on the Internet do not yet follow the IGMP protocol and do not understand multicast addresses. <ref> [30] </ref> and [17] describe the IP multicast facility. The principal change that would be needed to effect multicast routing using the algorithms we have described would be to implement CM CT C , replace the mrouted algorithm, and ensure that link-state information is delivered to each mul-ticast server.
Reference: [31] <author> S. Deering and D. Cheriton, </author> <title> "Multicast routing in datagram internetworks and extended LANs," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 8, </volume> <pages> pp. 85-110, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: This problem has been investigated since the 1970's, but in different contexts than the ones in which it is envisioned today. Some of the reasons why multicasting was deemed a good facility were: * distributing queries to servers <ref> [31] </ref> * updating replicated databases [32, 33] * sending intermediate results of a computation to various elements in a parallel processor [34] * disseminating information to participants of a distributed computation * locating servers and resources [35] The two traditional modes of communication, unicasting and broadcasting, are really degenerate forms of <p> For example, RIP (Routing Information Protocol)[37] and OSPF (Open Shortest Path First)[38] are two such algorithms. The shortest delay approach is also used in the experimental multicast facility on the Internet due to Deering <ref> [31] </ref>. Another way to characterize the shortest delay multicast solution is given by Kadaba and Jaffe [39]. The objective is to determine the shortest average path delay to the destinations.
Reference: [32] <author> J. Chang and N. Maxemchuk, </author> <title> "Simplifying distributed database design by using a broadcast network," </title> <booktitle> Proceedings of ACM SIGMOD '84, </booktitle> <pages> pp. 223-233, </pages> <month> Jun. </month> <year> 1984. </year>
Reference-contexts: This problem has been investigated since the 1970's, but in different contexts than the ones in which it is envisioned today. Some of the reasons why multicasting was deemed a good facility were: * distributing queries to servers [31] * updating replicated databases <ref> [32, 33] </ref> * sending intermediate results of a computation to various elements in a parallel processor [34] * disseminating information to participants of a distributed computation * locating servers and resources [35] The two traditional modes of communication, unicasting and broadcasting, are really degenerate forms of the more general facility, multicasting:
Reference: [33] <author> K. Birman, A. Schiper, and P. Stephenson, </author> <title> "Lightweight causal and atomic group multicast," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, </volume> <pages> pp. 272-314, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: This problem has been investigated since the 1970's, but in different contexts than the ones in which it is envisioned today. Some of the reasons why multicasting was deemed a good facility were: * distributing queries to servers [31] * updating replicated databases <ref> [32, 33] </ref> * sending intermediate results of a computation to various elements in a parallel processor [34] * disseminating information to participants of a distributed computation * locating servers and resources [35] The two traditional modes of communication, unicasting and broadcasting, are really degenerate forms of the more general facility, multicasting:
Reference: [34] <author> P. McKinley and J. Liu, </author> <title> "Multicast tree construction in bus-based networks," </title> <journal> Communications of the ACM, </journal> <volume> vol. 33, </volume> <pages> pp. 29-42, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Some of the reasons why multicasting was deemed a good facility were: * distributing queries to servers [31] * updating replicated databases [32, 33] * sending intermediate results of a computation to various elements in a parallel processor <ref> [34] </ref> * disseminating information to participants of a distributed computation * locating servers and resources [35] The two traditional modes of communication, unicasting and broadcasting, are really degenerate forms of the more general facility, multicasting: 6 7 Figure II.1: An example showing how broadcasting can be used to perform a multi-cast.
Reference: [35] <author> M. Ahamad, M. Ammer, J. Bernabeu-Auban, and M. Khalidi, </author> <title> "Using multicast communication to locate resources in a LAN-based distributed system," </title> <booktitle> Proceedings of the 13th Conference on Local Computer Networks, </booktitle> <pages> pp. 193-202, </pages> <month> Oct. </month> <year> 1988. </year> <month> 154 </month>
Reference-contexts: reasons why multicasting was deemed a good facility were: * distributing queries to servers [31] * updating replicated databases [32, 33] * sending intermediate results of a computation to various elements in a parallel processor [34] * disseminating information to participants of a distributed computation * locating servers and resources <ref> [35] </ref> The two traditional modes of communication, unicasting and broadcasting, are really degenerate forms of the more general facility, multicasting: 6 7 Figure II.1: An example showing how broadcasting can be used to perform a multi-cast. * Unicast: the transmission of data from one source to one destination * Broadcast: the
Reference: [36] <author> E. Dijkstra, </author> <title> "A note on two problems in connexion with graphs," </title> <journal> Numerische Mathematik, </journal> <volume> vol. 1, </volume> <pages> pp. 269-271, </pages> <year> 1959. </year>
Reference-contexts: In terms of the above notation, we want to minimize the path delay from source s to destination v, P D (s; v), along the path P (s; v): 8 v 2 S; P D (s; v) = min X D (e) 11 Dijkstra's shortest path algorithm <ref> [36] </ref> finds the minimum delay path from the source to each node in the graph in O (jEj) time, where jEj is the number of edges in the graph. The algorithm yields a tree of the shortest paths from the root to all the nodes in the graph. <p> Thus, there could be some cycles in the expanded tree. These can be cleared away by running a shortest delay algorithm <ref> [36] </ref> on the expanded tree. Note that, in contrast to the KMB algorithm, the cycle elimination is done by shortest delay rather than minimum spanning tree, in order not to violate the delay bounds. An example of a graph that needs cycle removal is given in Fig. IV.6.
Reference: [37] <author> C. Hedrick, </author> <title> "RFC 1058: Routing Information Protocol," </title> <type> RFC 1058, </type> <institution> Rutgers University, </institution> <month> Jun. </month> <year> 1988. </year>
Reference-contexts: The Bellman-Ford algorithm is called a distance-vector algorithm, because the link status information is not sent to all the nodes in the network, but incremental information is passed along. The Routing Information Protocol (RIP) is an existing protocol that uses the distance-vector approach <ref> [37] </ref>. VII.B Metrics The determination of the metrics used by the routing algorithm is a hard problem. There is a lot of work going on to characterize the offered load on a network, and to determine network status information such as link delay, data loss probability, or jitter.
Reference: [38] <author> J. Moy, </author> <type> "RFC 1247: OSPF version 2," RFC 1247, </type> <institution> Proteon, Inc., </institution> <month> Jul. </month> <year> 1991. </year> <note> Obsoletes RFC 1131. </note>
Reference-contexts: In this way, the state information would travel over a fixed route, and would not flood the network. [62] describes the use of a spanning tree to support a link-state routing algorithms. The Open Shortest Path First (OSPF) routing protocol uses the link-state approach <ref> [38] </ref>. VII.A.2 The Distributed Heuristics The distributed heuristics do not need up-to-date information of the entire network status. However, they do need the shortest delay path to each node. This 72 information can be obtained using the Bellman-Ford distributed shortest path algorithm [63, 54].
Reference: [39] <author> B. Kadaba and J. Jaffe, </author> <title> "Routing to multiple destinations in computer networks," </title> <journal> IEEE Trans. on Comm., </journal> <volume> vol. COM-31, </volume> <pages> pp. 343-351, </pages> <month> Mar. </month> <year> 1983. </year>
Reference-contexts: The shortest delay approach is also used in the experimental multicast facility on the Internet due to Deering [31]. Another way to characterize the shortest delay multicast solution is given by Kadaba and Jaffe <ref> [39] </ref>. The objective is to determine the shortest average path delay to the destinations. Thus, in effect we would like to minimize the function, D avg : D avg = k v2S e2P (s;v) where k is the number of destinations to be reached. <p> On the other hand, if the cost represents the bandwidth used up in performing the multicast, then the service provider would be interested in efficient bandwidth utilization, primarily to permit more multicasts with the available bandwidth. Multicast routing algorithms with the objective of low cost are described in <ref> [40, 39, 41] </ref>. 12 For example, if the cost of a link was a measure of the amount of bandwidth on that link that was utilized for the multicast, then by using a higher cost multicast tree, we would be using up more network resources. <p> Some obvious enumeration schemes can assist in reducing the actual number of trees examined, but the problem still remains intractable [47]. Many approximate solutions to the Steiner tree problem have been devised <ref> [48, 49, 39, 50, 51] </ref>. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost [52]. <p> An integer programming approach to generating approximate Steiner trees is presented in [53]. The integer programming problem is then solved using a hill-climbing heuristic that converges fairly quickly to good solutions. 13 II.D Low Cost and Delay Trees The work of Kadaba and Jaffe <ref> [39] </ref> deals with the problem of how to effectively attain both low cost and low average path delays in the tree. <p> An interesting feature of our problem is that it is far more general than the problem definition in <ref> [39] </ref>, and subsumes that version. In fact, if our problem is restricted to provide a solution to Kadaba and Jaffe's compromise tree, then our approximate solutions do just as well (or as badly) as they prove a compromise tree could be. Chapter III Multicasting Is ...
Reference: [40] <author> B. Waxman, </author> <title> "Routing of multipoint connections," </title> <journal> IEEE J. on Selected Areas in Comm., </journal> <volume> vol. 6, </volume> <pages> pp. 1617-1622, </pages> <month> Dec </month> <year> 1988. </year>
Reference-contexts: On the other hand, if the cost represents the bandwidth used up in performing the multicast, then the service provider would be interested in efficient bandwidth utilization, primarily to permit more multicasts with the available bandwidth. Multicast routing algorithms with the objective of low cost are described in <ref> [40, 39, 41] </ref>. 12 For example, if the cost of a link was a measure of the amount of bandwidth on that link that was utilized for the multicast, then by using a higher cost multicast tree, we would be using up more network resources.
Reference: [41] <author> D. Wall, </author> <title> Mechanisms for Broadcast and Selective Broadcast. </title> <type> PhD thesis, </type> <institution> Elect. Engg. Dept., Stanford University, </institution> <month> Jun </month> <year> 1980. </year>
Reference-contexts: On the other hand, if the cost represents the bandwidth used up in performing the multicast, then the service provider would be interested in efficient bandwidth utilization, primarily to permit more multicasts with the available bandwidth. Multicast routing algorithms with the objective of low cost are described in <ref> [40, 39, 41] </ref>. 12 For example, if the cost of a link was a measure of the amount of bandwidth on that link that was utilized for the multicast, then by using a higher cost multicast tree, we would be using up more network resources. <p> Occasionally, the expanded solution is not a tree, but a graph with some loops. These loops can be eliminated by running a minimum spanning tree on this graph. Wall describes how this algorithm can be more carefully executed to avoid the final loop step <ref> [41] </ref>. An example of the working of the KMB algorithm can be seen in Fig. IV.1. In this example, the Steiner tree on the graph in Fig. IV.1 (a) has to cover the nodes A, B, and D. The closure graph is shown in Fig. <p> This would greatly reduce the amount of state information that must be maintained if each source has its own tree. Wall first proposed using center-based trees <ref> [41] </ref>, and [76, 77] describe the approach to using a few core-based trees to perform the routing. A core-based tree is a tree in which there is a single node, the core, out of which emanate branches to a number of destinations.
Reference: [42] <author> S. Hakimi, </author> <title> "Steiner's problem in graphs and its implications," </title> <journal> Networks, </journal> <volume> vol. 1, </volume> <pages> pp. 113-133, </pages> <year> 1971. </year>
Reference-contexts: In this situation, the low cost multicast tree would be more desirable than the low delay tree. The problem of minimum cost trees spanning a subset of nodes in the graph is a well-known problem in graph theory. It is known as the Steiner tree problem <ref> [42] </ref> and is known to be NP-complete [43]. Several intractable variants of the problem exist, e.g., when the network has some regular form, like a rectilinear grid, or when the cost on each edge is unity [44]. Furthermore, Steiner trees are very useful to VLSI chip design.
Reference: [43] <author> R. Karp, </author> <title> "Reducibility among combinatorial problems," in Complexity of Computer Computations (R. </title> <editor> Miller and J. Thatcher, </editor> <booktitle> eds.), </booktitle> <pages> pp. 85-103, </pages> <address> New York: </address> <publisher> Plenum Press, </publisher> <year> 1972. </year>
Reference-contexts: The problem of minimum cost trees spanning a subset of nodes in the graph is a well-known problem in graph theory. It is known as the Steiner tree problem [42] and is known to be NP-complete <ref> [43] </ref>. Several intractable variants of the problem exist, e.g., when the network has some regular form, like a rectilinear grid, or when the cost on each edge is unity [44]. Furthermore, Steiner trees are very useful to VLSI chip design.
Reference: [44] <author> M. Garey and D. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <address> New York: </address> <publisher> W.H. Freeman and Co., </publisher> <year> 1979. </year>
Reference-contexts: It is known as the Steiner tree problem [42] and is known to be NP-complete [43]. Several intractable variants of the problem exist, e.g., when the network has some regular form, like a rectilinear grid, or when the cost on each edge is unity <ref> [44] </ref>. Furthermore, Steiner trees are very useful to VLSI chip design.
Reference: [45] <author> M. Sarrafzadeh and C. Wong, </author> <title> "Hierarchical Steiner tree construction in uniform orientations," </title> <journal> IEEE Transactions on Computer-aided Design of Integrated Circuits and Systems, </journal> <volume> vol. 11, </volume> <pages> pp. 1095-1103, </pages> <month> Sep. </month> <year> 1992. </year>
Reference-contexts: Furthermore, Steiner trees are very useful to VLSI chip design. If the cost of a link is the length of wire that connects two terminals, then to distribute signals to multiple devices through wire interconnects, we would like to use the smallest total length of wire <ref> [45] </ref> or the fewest number of junctions [46]. Essentially, the intractability of the Steiner tree problem arises from the existence of an exponential number of spanning trees, and the typical exact solution can be obtained by some enumeration of these trees.
Reference: [46] <author> K. Makki and N. Pissinou, </author> <title> "The Steiner tree problem with minimum number of vertices in graphs," </title> <booktitle> Proceedings of the Second Great Lakes Symposium on VLSI, </booktitle> <pages> pp. 204-206, </pages> <month> 28-29 Feb. </month> <year> 1992. </year> <title> Kalamazoo, MI, USA Edited by: </title> <editor> Sherwani, N. </editor> <publisher> Los Alamitos, </publisher> <address> CA, USA. </address>
Reference-contexts: If the cost of a link is the length of wire that connects two terminals, then to distribute signals to multiple devices through wire interconnects, we would like to use the smallest total length of wire [45] or the fewest number of junctions <ref> [46] </ref>. Essentially, the intractability of the Steiner tree problem arises from the existence of an exponential number of spanning trees, and the typical exact solution can be obtained by some enumeration of these trees.
Reference: [47] <author> S. Dreyfus and R. Wagner, </author> <title> "The Steiner problem in graphs," </title> <journal> Networks, </journal> <volume> no. 1, </volume> <pages> pp. 195-207, </pages> <year> 1972. </year>
Reference-contexts: Some obvious enumeration schemes can assist in reducing the actual number of trees examined, but the problem still remains intractable <ref> [47] </ref>. Many approximate solutions to the Steiner tree problem have been devised [48, 49, 39, 50, 51]. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost [52].
Reference: [48] <author> L. Kou, G. Markowsky, and L. Berman, </author> <title> "A fast algorithm for Steiner trees," </title> <journal> Acta Informatica, </journal> <volume> no. 15, </volume> <pages> pp. 141-145, </pages> <year> 1981. </year>
Reference-contexts: Some obvious enumeration schemes can assist in reducing the actual number of trees examined, but the problem still remains intractable [47]. Many approximate solutions to the Steiner tree problem have been devised <ref> [48, 49, 39, 50, 51] </ref>. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost [52].
Reference: [49] <author> H. Takahashi and A. </author> <title> Matsuyama, "An approximate solution for the Steiner problem in graphs," </title> <journal> Math. Japonica, </journal> <volume> vol. 6, </volume> <pages> pp. 573-577, </pages> <year> 1980. </year>
Reference-contexts: Some obvious enumeration schemes can assist in reducing the actual number of trees examined, but the problem still remains intractable [47]. Many approximate solutions to the Steiner tree problem have been devised <ref> [48, 49, 39, 50, 51] </ref>. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost [52].
Reference: [50] <author> V. Rayward-Smith, </author> <title> "The computation of nearly minimal Steiner trees in graphs," </title> <journal> Intl. J. Math. Educ. Sci. Tech., </journal> <volume> vol. 14, no. 1, </volume> <pages> pp. 15-23, </pages> <year> 1983. </year> <month> 155 </month>
Reference-contexts: Some obvious enumeration schemes can assist in reducing the actual number of trees examined, but the problem still remains intractable [47]. Many approximate solutions to the Steiner tree problem have been devised <ref> [48, 49, 39, 50, 51] </ref>. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost [52].
Reference: [51] <author> A. Zelikovsky, </author> <title> "A faster approximation algorithm for the Steiner tree problem in graphs," </title> <journal> Information Processing Letters, </journal> <volume> vol. 46, </volume> <pages> pp. 79-83, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Some obvious enumeration schemes can assist in reducing the actual number of trees examined, but the problem still remains intractable [47]. Many approximate solutions to the Steiner tree problem have been devised <ref> [48, 49, 39, 50, 51] </ref>. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost [52].
Reference: [52] <author> C. Papadimitriou and M. Yannakakis, </author> <title> "Optimization, approximation and complexity classes," </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 43, </volume> <pages> pp. 425-440, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Many approximate solutions to the Steiner tree problem have been devised [48, 49, 39, 50, 51]. The Steiner tree has a nice property in that it is possible to find an approximate solution that lies within a constant factor of the optimal cost <ref> [52] </ref>. All the approximation algorithms cited above produce solutions that come within a factor of two of the optimal cost. An integer programming approach to generating approximate Steiner trees is presented in [53].
Reference: [53] <author> J. Beasley, </author> <title> "An sst-based algorithm for the steiner problem on graphs," </title> <journal> Networks, </journal> <volume> vol. 19, </volume> <pages> pp. 1-16, </pages> <year> 1989. </year>
Reference-contexts: All the approximation algorithms cited above produce solutions that come within a factor of two of the optimal cost. An integer programming approach to generating approximate Steiner trees is presented in <ref> [53] </ref>.
Reference: [54] <author> L. Ford and D. Fulkerson, </author> <title> Flows in Networks. </title> <publisher> Princeton, </publisher> <address> NJ: </address> <publisher> Princeton University Press, </publisher> <year> 1962. </year>
Reference-contexts: On the other hand, if the CD route were first set up, then both the hosts would be able to transmit. In essence, this is a flow problem that can be solved 16 Figure III.1: Call blocking because of bad scheduling. using a capacity assignment algorithm <ref> [54] </ref>, if the flows and the costs are known a priori. In reality, it is not possible to prepare for all possible combinations of flows, so it is not unreasonable to make local optimizations, and hope for the best. <p> VII.A.2 The Distributed Heuristics The distributed heuristics do not need up-to-date information of the entire network status. However, they do need the shortest delay path to each node. This 72 information can be obtained using the Bellman-Ford distributed shortest path algorithm <ref> [63, 54] </ref>. The Bellman-Ford algorithm is called a distance-vector algorithm, because the link status information is not sent to all the nodes in the network, but incremental information is passed along. The Routing Information Protocol (RIP) is an existing protocol that uses the distance-vector approach [37].
Reference: [55] <author> M. Inoue, I. Yoroizawa, and S. Okubo, </author> <title> "Human factors oriented design objectives for video teleconferencing systems," </title> <booktitle> Proceedings of the International Teleconference Symposium '84, </booktitle> <pages> pp. 66-73, </pages> <month> Apr. </month> <year> 1984. </year>
Reference-contexts: We note here that delay is a fuzzy notion, and delay in some applications is less tolerable than in others. For example, some researchers have found that a discussion cannot be held comfortably with large round-trip delays, with the dissatisfaction rising very quickly as the delay increases <ref> [55] </ref>. This study is not meant to determine a magic number that defines precisely how late a data object can arrive before it is thrown away. Rather, it is to be used more as a guideline in route construction.
Reference: [56] <author> G. Trewitt. </author> <type> Personal communication, </type> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Furthermore, in some instances, e.g., a teleconference in which less heated exchanges were taking place, delay bounds would tend to be less stringent than in a situation where, say, stock quotations were being multicast live to brokers <ref> [56] </ref>. III.C The Constrained Steiner Tree We propose that a constrained Steiner tree (CST) provides a multicast route that is appropriate for multicasting multimedia data. In particular, in a multicast tree, we are looking for a tree that covers the given destination set, such that the tree satisfies some properties.
Reference: [57] <author> L. Beineke and R. Wilson, eds., </author> <title> Applications of Graph Theory, </title> <type> ch. 12. </type> <address> London: </address> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: If this is done carefully, a number of spanning trees can be eliminated that are either too expensive, or that violate the delay bounds. This method is derived from Kirchoff's method of enumerating all the spanning trees in a graph <ref> [57] </ref>. In a spanning tree, each edge of the graph is either in the tree, or not in it. We can recursively generate subgraphs of the original graph, one with a particular edge e, and one without it, and consider spanning trees on these subgraphs.
Reference: [58] <author> R. Floyd, </author> <title> "Algorithm 97: Shortest Paths," </title> <journal> Comm. of the ACM, </journal> <volume> vol. 5, </volume> <editor> p. </editor> <volume> 345, </volume> <month> Jun. </month> <year> 1962. </year>
Reference-contexts: We can compute this constrained cheapest path between two nodes using a dynamic programming approach similar to the Floyd-Warshall all-pairs shortest paths algorithm <ref> [58, 59] </ref>. Let C d (u; v) be the cost of the cheapest path between u and v that has a delay exactly equal to d. We can find C d (u; v) as follows.
Reference: [59] <author> S. Warshall, </author> <title> "A theorem on boolean matrices," </title> <journal> Journal of the ACM, </journal> <volume> vol. 9, </volume> <pages> pp. 11-12, </pages> <month> Jan. </month> <year> 1962. </year>
Reference-contexts: We can compute this constrained cheapest path between two nodes using a dynamic programming approach similar to the Floyd-Warshall all-pairs shortest paths algorithm <ref> [58, 59] </ref>. Let C d (u; v) be the cost of the cheapest path between u and v that has a delay exactly equal to d. We can find C d (u; v) as follows.
Reference: [60] <author> R. Prim, </author> <title> "Shortest connection networks and some generalizations," </title> <journal> Bell Systems Tech. J., </journal> <volume> vol. 36, </volume> <pages> pp. 1389-1401, </pages> <year> 1957. </year>
Reference-contexts: We can build this tree using an approach similar to Prim's MST algorithm <ref> [60] </ref>. The basic idea is to start at the source, and mark it as Seen, and mark all the other nodes as Unseen. The main loop of the algorithm picks the best edge that connects some Seen node to some Unseen node, which is then marked Seen.
Reference: [61] <author> S. Casner, </author> <title> "Frequently Asked Questions on the Multicast Backbone (MBONE)." </title> <note> Available by anonymous ftp from ftp.isi.edu, </note> <month> May </month> <year> 1993. </year>
Reference-contexts: Multicasting has become fairly popular on the Internet in the context of audiocasts and videocasts on the MBONE <ref> [61] </ref>. The implementation strategy used there has been to introduce multicasting with little or no impact on existing users of the Internet. For example, unless a particular site was interested in experimenting with the multicast services, it did not have to change its mode of operation.
Reference: [62] <author> Y. Dalal and R. Metcalfe, </author> <title> "Reverse path forwarding of broadcast packets," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, </volume> <pages> pp. 1040-1048, </pages> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: The best way to carry out the link-state approach would be to construct a spanning tree along which to broadcast the information to each node. In this way, the state information would travel over a fixed route, and would not flood the network. <ref> [62] </ref> describes the use of a spanning tree to support a link-state routing algorithms. The Open Shortest Path First (OSPF) routing protocol uses the link-state approach [38]. VII.A.2 The Distributed Heuristics The distributed heuristics do not need up-to-date information of the entire network status.
Reference: [63] <author> R. Bellman, </author> <title> "On a routing problem," </title> <journal> Quarterly of Applied Mathematics, </journal> <volume> vol. 16, no. 1, </volume> <pages> pp. 87-90, </pages> <year> 1958. </year>
Reference-contexts: VII.A.2 The Distributed Heuristics The distributed heuristics do not need up-to-date information of the entire network status. However, they do need the shortest delay path to each node. This 72 information can be obtained using the Bellman-Ford distributed shortest path algorithm <ref> [63, 54] </ref>. The Bellman-Ford algorithm is called a distance-vector algorithm, because the link status information is not sent to all the nodes in the network, but incremental information is passed along. The Routing Information Protocol (RIP) is an existing protocol that uses the distance-vector approach [37].
Reference: [64] <author> J. McQuillan and et al, </author> <title> "The new routing algorithm for the ARPANET," </title> <journal> IEEE Transactions on Communications, </journal> <volume> vol. COM-28, </volume> <pages> pp. 711-719, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: In the ARPANET, the delay value was initially determined by timing the round-trip delay along a link. However, this led to erratic delay values, because of bursty traffic. The alternative was to use some time-averaged value of the delay, which was employed successfully in the improved ARPANET routing algorithm <ref> [64] </ref>, and in TYMNET [65]. Finally, the delay can be determined by probabilistic analysis. The approach taken in [66] is a good example of how delays are computed by analyzing the expected offered loads from different sources on a link, and arriving at expected delay values.
Reference: [65] <author> L. Tymes, </author> <title> "Routing and flow control in TYMNET," </title> <journal> IEEE Transactions on Communications, </journal> <volume> vol. </volume> <pages> COM-29, pp. 392-398, </pages> <month> Apr. </month> <year> 1981. </year> <month> 156 </month>
Reference-contexts: However, this led to erratic delay values, because of bursty traffic. The alternative was to use some time-averaged value of the delay, which was employed successfully in the improved ARPANET routing algorithm [64], and in TYMNET <ref> [65] </ref>. Finally, the delay can be determined by probabilistic analysis. The approach taken in [66] is a good example of how delays are computed by analyzing the expected offered loads from different sources on a link, and arriving at expected delay values.
Reference: [66] <author> D. Ferrari and D. Verma, </author> <title> "A scheme for real-time channel establishment in wide-area networks," </title> <booktitle> in Reservation [18], </booktitle> <pages> pp. 368-379. </pages> <booktitle> Proceedings of the IFIP WG 6.1/WG 6.4 Second International Workshop Palo Alto, </booktitle> <address> CA, USA, </address> <note> Edited by: </note> <editor> Johnson, M.J., </editor> <address> Amsterdam, Netherlands: </address> <publisher> North-Holland. </publisher>
Reference-contexts: The alternative was to use some time-averaged value of the delay, which was employed successfully in the improved ARPANET routing algorithm [64], and in TYMNET [65]. Finally, the delay can be determined by probabilistic analysis. The approach taken in <ref> [66] </ref> is a good example of how delays are computed by analyzing the expected offered loads from different sources on a link, and arriving at expected delay values. As far as cost is concerned, there are again a number of means of defining the metric.
Reference: [67] <author> H. Braun. </author> <type> Personal communication, </type> <year> 1991. </year>
Reference-contexts: As far as cost is concerned, there are again a number of means of defining the metric. For example, the NSFNET backbone uses static cost values to define the desirability of one link over another <ref> [67] </ref>. The problem with this approach is that it causes routing to take more or less fixed paths, regardless of congestion. Another tactic is to assign cost depending on the bandwidth that is demanded.
Reference: [68] <author> G. Ash, J.-S. Chen, A. Frey, and B. Huang, </author> <title> "Real-time network routing in the AT&T network Improved service quality at lower cost," </title> <booktitle> Proceedings of GLOBE-COM '92, </booktitle> <volume> vol. 2, </volume> <pages> pp. 802-809, </pages> <address> Dec. 1992. Orlando, FL. </address>
Reference-contexts: A drawback here is that regardless of the congestion on a link, the charge for using bandwidth is static. The AT&T telephone network <ref> [68] </ref> uses a different strategy to distribute the load over other links, so that no one link is overloaded. This strategy can be implemented by using a cost function that is dependent on the bandwidth already being used by existing users of the link.
Reference: [69] <author> D. </author> <title> Comer, </title> <journal> Internetworking with TCP/IP, </journal> <volume> vol. </volume> <pages> 1. </pages> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, 2 ed., </publisher> <year> 1991. </year>
Reference-contexts: Thus, a router would not have to know the exact location of a host, but rather, only the network that it resides on. However, IP multicast addresses do not conform to this hierarchy <ref> [69] </ref>. A multicast address is really a meta-address, that denotes a group of hosts, which could each be in a different level and branch of the IP addressing system.
Reference: [70] <author> Xerox, </author> <title> Digital, and Intel, "The Ethernet Version 1.0," </title> <journal> ACM Computer Communications Review, </journal> <volume> vol. 11, </volume> <pages> pp. 17-65, </pages> <month> Jul. </month> <year> 1981. </year>
Reference-contexts: This makes it impossible for this one address to be used to both identify a multicast group, and provide routing hints for delivery to hosts in that group. Typically, multicast addresses come from a flat space. This is true of Ethernet multicast addresses <ref> [70] </ref> as well as IP addresses. The important question to determine here is whether the address of a multicast group needs to do more than just identify the group. For example, suppose a multicast is done hierarchically.
Reference: [71] <author> K. Sato, S. Ohta, and I. Tokizawa, </author> <title> "Broad-band ATM network architecture based on virtual paths," </title> <journal> IEEE Transactions on Communications, </journal> <volume> vol. 38, </volume> <pages> pp. 1212-1222, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: In fact, in some cases, the two endpoints involved in the unicast communication may always use the same VPI, so that management of VPIs is made simple <ref> [71, 72] </ref>. This is not a bad idea because the number of endpoint pairs is small. However, the same approach cannot be carried over to multicast trees, because the number of groups is exponential.
Reference: [72] <author> J. Burgin, </author> <title> "Broadband ISDN resource management," </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> vol. 20, </volume> <pages> pp. 323-31, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: In fact, in some cases, the two endpoints involved in the unicast communication may always use the same VPI, so that management of VPIs is made simple <ref> [71, 72] </ref>. This is not a bad idea because the number of endpoint pairs is small. However, the same approach cannot be carried over to multicast trees, because the number of groups is exponential.
Reference: [73] <author> R. Karp, </author> <title> "On-line algorithms versus off-line algorithms: how much is it worth to know the future?," </title> <journal> IFIP Transactions A (Computer Science and Technology), </journal> <volume> vol. A-12, </volume> <pages> pp. 416-429, </pages> <month> Sep. </month> <year> 1992. </year> <institution> Madrid, Spain. </institution>
Reference-contexts: In a live situation, we would like to be able to dynamically extend the multicast tree as new nodes join, and prune it to remove nodes that leave the multicast group. This problem is similar in nature to other "online" problems <ref> [73] </ref>. Typically, the solution strategy is evaluated in terms of how well it performs against an adversary that knows the strategy.
Reference: [74] <author> D. Coppersmith and P. Raghavan, </author> <title> "Multidimensional on-line bin packing: algorithms and worst-case analysis," </title> <journal> Operations Research Letters, </journal> <volume> vol. 8, </volume> <pages> pp. 17-20, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: See <ref> [74] </ref> for a more detailed description of the online bin-packing problem. For the dynamic multicast group problem, a adversary presents a sequence of "join" and "leave" requests that causes the resultant tree to be highly sub-optimal.
Reference: [75] <author> N. Belkeir and M. Ahamad, </author> <title> "Low cost algorithms for message delivery in dynamic multicast groups," </title> <booktitle> Proceedings of the 9th International Conference on Distributed Computer Systems, </booktitle> <pages> pp. 110-117, </pages> <month> Jun. </month> <year> 1989. </year>
Reference-contexts: Instead, we would need to compare the online strategy's tree after any membership change with the corresponding tree that the adversary comes up with. Some work on dynamic multicast groups has been done in <ref> [75] </ref>. VIII.E.3 Supporting Different QoS at the Destinations In a heterogeneous environment, not all receiving stations will have the same capabilities.
Reference: [76] <author> A. Ballardie, P. Tsuchiya, and J. Crowcroft, </author> <title> "Core Based Trees (CBT): An Architecture for Scalable Inter-Domain Multicast Routing," Internet Draft draft-ballardie-cbt-02.txt, </title> <institution> University College, London and Bellcore, </institution> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: This would greatly reduce the amount of state information that must be maintained if each source has its own tree. Wall first proposed using center-based trees [41], and <ref> [76, 77] </ref> describe the approach to using a few core-based trees to perform the routing. A core-based tree is a tree in which there is a single node, the core, out of which emanate branches to a number of destinations.
Reference: [77] <author> A. Ballardie, P. Francis, and J. Crowcroft, </author> <title> "Core based trees," </title> <booktitle> Proceedings of SIGCOMM '93, Sep. 1993. </booktitle> <address> San Francisco, CA. </address>
Reference-contexts: This would greatly reduce the amount of state information that must be maintained if each source has its own tree. Wall first proposed using center-based trees [41], and <ref> [76, 77] </ref> describe the approach to using a few core-based trees to perform the routing. A core-based tree is a tree in which there is a single node, the core, out of which emanate branches to a number of destinations.
References-found: 77

