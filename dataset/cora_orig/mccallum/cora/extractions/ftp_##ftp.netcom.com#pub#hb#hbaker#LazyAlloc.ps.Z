URL: ftp://ftp.netcom.com/pub/hb/hbaker/LazyAlloc.ps.Z
Refering-URL: ftp://ftp.netcom.com/pub/hb/hbaker/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: CONS Should not CONS its Arguments, or, a Lazy Alloc is a Smart Alloc The
Author: Henry G. Baker 
Keyword: 1.Introduction.  
Address: 16231 Meadow Ridge Way, Encino, CA 91436,  
Affiliation: Nimble Computer Corporation,  
Note: ACM Sigplan Notices  Copyright 1988,1990,1991 Nimble Computer Corporation 1  This work was supported in part by the U.S. Department of Energy Contract No. DE-AC03-88ER80663  2.Stack Allocation is an Implementation Issue, not a Language Issue  
Phone: (818) 501-4956(818) 986-1360 (FAX)  
Date: 27,3 (March 1992),24-34.  November, 1988; revised April and December, 1990, November, 1991.  
Abstract: Lazy allocation is a model for allocating objects on the execution stack of a high-level language which does not create dangling references. Our model provides safe transportation into the heap for objects that may survive the deallocation of the surrounding stack frame. Space for objects that do not survive the deallocation of the surrounding stack frame is reclaimed without additional effort when the stack is popped. Lazy allocation thus performs a first-level garbage collection, and if the language supports garbage collection of the heap, then our model can reduce the amortized cost of allocation in such a heap by filtering out the short-lived objects that can be more efficiently managed in LIFO order. A runtime mechanism called result expectation further filters out unneeded results from functions called only for their effects. In a shared-memory multiprocessor environment, this filtering reduces contention for the allocation and management of global memory. Our model performs simple local operations, and is therefore suitable for an interpreter or a hardware implementation. Its overheads for functional data are associated only with assignments, making lazy allocation attractive for mostly functional programming styles. Many existing stack allocation optimizations can be seen as instances of this generic model, in which some portion of these local operations have been optimized away through static analysis techniques. Important applications of our model include the efficient allocation of temporary data structures that are passed as arguments to anonymous procedures which may or may not use these data structures in a stack-like fashion. The most important of these objects are functional arguments (funargs), which require some runtime allocation to preserve the local environment. Since a funarg is sometimes returned as a first-class value, its lifetime can survive the stack frame in which it was created. Arguments which are evaluated in a lazy fashion (Scheme delays or "suspensions") are similarly handled. Variable-length argument "lists" themselves can be allocated in this fashion, allowing these objects to become "first-class". Finally, lazy allocation correctly handles the allocation of a Scheme control stack, allowing Scheme continuations to become first-class values. Stack allocation of objects in higher level programming languages is desired because it is elegant, efficient, and can handle the great majority of short-lived object allocations. Traditional higher-level languages such as Algol, Pascal and Ada have preferred to perform all automatic storage management by using a stack, while non-stack allocation remains the responsibility of the programmer. However, the limitations of stack allocation are semantically confining, because a strict last-in, first-out, (LIFO) allocation/deallocation ordering does not allow for important classes of program behavior such as that of returning a functional argument as a result. Therefore, the programmer is forced to use complex and error-prone techniques to simulate this behavior himself, even though the abstract programming language may be capable of expressing the behavior more elegantly and directly using, for example, functional arguments as results. Modern higher level languages such as Lisp, Smalltalk, Mesa, Modula-3, ML, and Eiffel, seek to escape these LIFO restrictions to gain in expressive power while retaining elegance and simplicity in the language. Insofar as they succeed, they can greatly improve engineering productivity and software quality. A cost must be paid for this flexibility through the increased use of heap allocation for objects in the language. Yet the vast majority of objects obey a straightforward last-in, first-out (LIFO) allocation semantics, and could profitably utilize stack allocation. One would therefore like to provide stack allocation for these objects, while reserving the more expensive heap allocation for those objects that require it. In other words, one would like an implementation which retains the efficiency of stack allocation for most objects, and therefore does not saddle every program with the cost for the increased flexibilitywhether the program uses that flexibility or not. The problem in providing such an implementation is in determining which objects obey LIFO allocation semantics and which do not. Much research has been done on determining these objects at compile time using various static methods which are specific to the particular type of object whose allocation is being optimized. Unfortunately, these techniques are limited, complex and expensive. We present a technique which acts more like a cache or a virtual memory, in the sense that no attempt is made to predict usage at compile time, but the usage is determined at run time. In other words, the system learns about the usage of objects "on-the-fly". The major contribution of this paper is the recognition that a wide variety of stack-allocation optimizations are all instances of the same underlying mechanismlazy allocation. Using this insight, we can simplify hardware architecture and language implementations by factoring the problem into two abstraction layerslanguage implementation using generic storage allocation, and the implementation of generic storage allocation using lazy allocation. Safety is also enhanced by the elimination of "dangling references" due to objects escaping a stack-allocated scope. While lazy allocation already provides for stack-allocation of arguments and temporaries, a programmer can extract even better performance by utilizing "continuation-passing style" to stack-allocate function results. The stack allocation of variables and contexts in higher-level compiled languages such as C, Pascal and Ada has been a fact of life for so many years since its introduction in Algol-60 that most programmers today assume that stack allocation is a language, rather than an implementation, issue. Stack allocation cannot be a language issue, however, since the most direct mapping of the nested lexical variable scopes in these languages is a tree, not a stack. Rather, stack allocation was a conscious decision on the part of these language designers to provide the implementation efficiency of a stack as a storage allocation mechanism even though this choice substantially compromised language elegance. We have also since learned that stack allocation of variables and contexts severely limits the expressiveness of a programming language. Indeed, many of the advances in programming languages after Algol-60 can be characterized as attempts to ameliorate the restrictions of stack allocation. For example, most of the functionality of Simula-67 could have been achieved in Algol-60 through the dropping of the stack allocation requirement along with the syntactic restrictions on procedure arguments and returned values. The stack allocation of Algol-60 provided a major advance over Fortran's static allocation. Functions could be arbitrarily nested, and recursion became possible. So long as the basic values being manipulated were numbers and individual characters, stack allocation proved remarkably expressive. With the advent of dynamic strings of characters and larger dynamic objects such as arrays, stack allocation started to break down. PL/I used pointers and explicit allocation/deallocation to avoid the limits of stack allocation. Substantial arguments in the 1970's raged about the allocation of function-calling and variable-allocation contexts"retention" (non-stack allocation) versus "deletion" (normal stack allocation) [Berry71] [Fischer72]. Non-stack-allocation has become steadily more important as the sophistication and complexity of programs have increased. For example, in modern "object-oriented" programming style, most objects are heap-allocated rather than stack-allocated. Unfortunately, heap-allocation is substantially less efficient than stack-allocation. As a result, programmers constantly seek to utilize stack allocation whenever possible. This change requires much work, because the source code changes required to change from one sort of allocation to another are substantial, even when the logic of the program has not changed. Most importantly, the programmer is required to use heap-allocation for entire classes of objects, even when the vast majority of these objects can be safely stack-allocated. This results from the difficulty in determining at design or compile time which of the objects can be safely stack-allocated, because it depends on a particular pattern of function calls, which in turn depends on the input data. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Aho, </author> <title> A.V. "Nested stack automata". JACM 16,3 (July 1969),383-406. ANSI-C. Draft Proposed American National Standard Programming Language C. ANSI, </title> <address> New York, NY, </address> <year> 1988. </year>
Reference: <author> Appel, Andrew W. </author> <title> "Garbage Collection Can Be Faster Than Stack Allocation". </title> <journal> Info. Proc. Let. </journal> <volume> 25 (1987),275-279. </volume>
Reference: <author> Appel, A.; MacQueen, </author> <title> D.B. "A Standard ML Compiler". </title> <journal> ACM Conf. Funct. Prog. & Comp. Arch., Sept.1987. </journal>
Reference: <author> Appel, Andrew W.; Ellis, John R.; and Li, Kai. </author> <title> "Real-time concurrent garbage collection on stock multiprocessors". </title> <journal> ACM Prog. Lang. </journal> <note> Des. and Impl., June1988,11-20. </note>
Reference: <author> Appel, Andrew W. </author> <title> "Simple Generational Garbage Collection and Fast Allocation". </title> <journal> SW Prac. & Exper. 19,2 (Feb.1989),171-183. </journal>
Reference: <author> Baker, Henry G. </author> <title> "List Processing in Real Time on a Serial Computer". </title> <journal> CACM 21,4 (April1978), </journal> <pages> 280-294. </pages>
Reference: <author> Baker, Henry G. </author> <title> "Shallow Binding in Lisp 1.5". </title> <journal> CACM 21, </journal> <volume> 7 (July1978),565-569. </volume>
Reference: <author> Baker, Henry G. </author> <title> "Unify and Conquer (Garbage, Updating, Aliasing, </title> ...) <booktitle> in Functional Languages". Proc. 1990 ACM Conf. on Lisp and Functional Progr., </booktitle> <address> June1990,218-226. </address>
Reference: <author> Baker, Henry G. </author> <title> "Equal Rights for Functional Objects". </title> <journal> ACM OOPS Messenger 4,4 (Oct.1993), </journal> <pages> 2-27. </pages>
Reference: <author> Barth, J. </author> <title> "Shifting garbage collection overhead to compile time". </title> <journal> CACM 20,7 (July1977),513-518. </journal>
Reference: <author> Bartley, D.H., Jensen, </author> <title> J.C. "The Implementation of PC Scheme". </title> <journal> ACM Lisp & Funct. Prog., </journal> <volume> Aug.1986, </volume> <pages> 86-93. </pages>
Reference: <author> Berry, </author> <title> D.M. "Block Structure: Retention vs. Deletion". </title> <booktitle> Proc. 3rd Sigact Symp. Th. of Comp., </booktitle> <address> Shaker Hgts., OH, </address> <year> 1971. </year>
Reference: <author> Berry, D.M., et al. </author> <title> "Time Required for Reference Count Management in Retention BlockStructured Languages, </title> <booktitle> Part 1". Int'l. </booktitle> <institution> J. Computer & Info. Sci. 7,1 (1978),11-64. </institution>
Reference: <author> Berry, D.M., et al. </author> <title> "Time Required for Reference Count Management in Retention BlockStructured Languages, </title> <booktitle> Part 2". Int'l. </booktitle> <institution> J. Computer & Info. Sci. 7,2 (1978),91-119. </institution>
Reference: <author> Berry, D.M., and Sorkin, A. </author> <title> "Time Required for Garbage Collection in Retention BlockStructured Languages". </title> <booktitle> Int'l. </booktitle> <institution> J. Computer & Info. Sci. 7,4 (1978),361-404. </institution>
Reference: <author> Bishop, P.B. </author> <title> Computer Systems with a very large address space and garbage collection. </title> <type> Ph.D. Thesis, </type> <institution> TR-178, MIT Lab. for Comp. Sci., Camb., </institution> <address> MA, May1977. </address>
Reference: <author> Blair, J.R., Kearns, P., and Soffa, </author> <title> M.L. "An Optimistic Implementation of the Stack-Heap". </title> <journal> J. Sys. & Soft. </journal> <volume> 5 (1985),193-202. </volume>
Reference: <author> Bobrow, D.G., and Wegbreit, B. </author> <title> "A Model and Stack Implementation of Multiple Environments". </title> <journal> CACM 16,10 (Oct.1973),591-603. </journal>
Reference: <author> Bobrow, et al. </author> <title> "Common Lisp Object System Specification X3J13", </title> <journal> A C M SIGPLAN Notices, </journal> <volume> v.23, </volume> <month> Sept. </month> <title> 1988; also X3J13 Document 88-002R, </title> <journal> June1988. ACM Sigplan Notices 27,3 (March 1992),24-34. </journal> <note> Copyright 1988,1990,1991 Nimble Computer Corporation 10 Boehm, </note> <author> H.-J., Demers, A. </author> <title> "Implementing Russell". </title> <booktitle> Proc. Sigplan '86 Symp. on Compiler Constr., Sigplan Not. </booktitle> <address> 21,7 (July1986),186-195. </address>
Reference: <editor> Brooks, R.A., et al. </editor> <title> "An Optimizing Compiler for Lexically Scoped LISP". </title> <journal> ACM Lisp & Funct. Prog. 1982,261-275. </journal>
Reference: <author> Brooks, R.A. </author> <title> "Trading Data Space for Reduced Time and Code Space in Real-Time Garbage Collection on Stock Hardware". </title> <booktitle> ACM Lisp & Funct. </booktitle> <address> Progr. 1984,256-262. </address>
Reference: <author> Chase, David. </author> <title> "Garbage Collection and Other Optimizations". </title> <type> PhD Thesis, </type> <institution> Rice U. Comp. Sci. Dept., Nov.1987. </institution>
Reference: <author> Cioni, G., Kreczmar, A. </author> <title> "Programmed Deallocation without Dangling Reference". </title> <note> IPL 18, 4 (May1984),179-187. </note>
Reference: <author> Clinger, W.D., Hartheimer, A.H., and Ost, </author> <title> E.M. "Implementation Strategies for Continuations". </title> <booktitle> ACM Conf. on Lisp and Funct. Prog., </booktitle> <address> July1988,124-131. </address>
Reference: <author> CLtL:Steele, Guy L., Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference: <author> Danvy, O. </author> <title> "Memory Allocation and Higher-Order Functions". </title> <booktitle> Proc. Sigplan '87 Symp. on Interpreters and Interpretive Techniques, ACM Sigplan Notices 22,7 (July1987),241-252. </booktitle>
Reference: <author> Dybvig, R.K. </author> <title> "Three Implementation Models for Scheme". </title> <type> Ph.D. Thesis, </type> <institution> Univ. </institution>
Reference: <institution> N. Carolina at Chapel Hill Dept. of Comp. Sci., </institution> <note> also TR#87-011, April1987,180p. </note>
Reference: <author> Dybvig, R.K. </author> <title> "A Variable-Arity Procedural Interface". </title> <booktitle> ACM Lisp and Functional Prog. </booktitle> <address> (July1988),106-115. </address>
Reference: <author> Fischer, M.J. </author> <title> "Lambda Calculus Schemata". </title> <booktitle> Proc. ACM Conf. on Proving Asserts. re Progs., Sigplan Not. </booktitle> <address> 7,1 (Jan.1972). </address>
Reference: <author> Fisher, D.A. </author> <title> "Bounded Workspace Garbage Collection in an Address-Order Preserving List Processing Environment". </title> <note> I nf .Pro c.Le tt . 3, 1 (July1974),29-32. </note>
Reference: <author> Friedman, </author> <title> D.P., and Wise, D.S. "CONS Should not Evaluate its Arguments". </title>
Reference: <editor> In S. Michaelson and R. </editor> <title> Milner (e d s .), Automata, Languages and Programming, </title> <publisher> Edinburgh U. Press., Edinburgh, </publisher> <address> Scotland, 1976,257-284. </address>
Reference: <author> Goldberg, B., and Park, Y.G. </author> <title> "Higher Order Escape Analysis: Optimizing Stack Allocation in Functional Program Implementations". </title> <booktitle> Proc. </booktitle> <address> ESOP'90, </address> <publisher> Springer-Verlag, May1990. </publisher>
Reference: <editor> Greenblatt, R., et al. </editor> <booktitle> "The Lisp Machine". AI WP 79, </booktitle> <publisher> MIT, Camb., </publisher> <address> MA, </address> <month> Nov. </month> <year> 1974, </year> <note> rev. vers. in Winston, </note> <author> P.H., and Brown, </author> <title> R.H., e d s . A r t i f i c i a l Intelligence, an MIT Perspective: Vol. II. </title> <publisher> MIT Press, Camb., </publisher> <address> MA, </address> <year> 1979. </year>
Reference: <author> Harbison, S.P., and Steele, G.L., Jr. </author> <title> C: A Reference Manual, 2nd Ed. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference: <author> Harrington, Steven J. </author> <title> "Space efficient copying storage recovery". </title> <journal> Computer J. 24,4 (1981),316-319. </journal>
Reference: <author> Hederman, Lucy. </author> <title> "Compile Time Garbage Collection". </title> <type> MS Thesis, </type> <institution> Rice U. Computer Science Dept., Sept.1988. </institution>
Reference: <author> Hieb, R., Dybvig, R.K., and Bruggeman, Carl. </author> <title> "Representing Control in the Presence of First-Class Continuations". </title> <booktitle> ACM Sigplan '90 Conf. Prog. Lang. Design & Impl., </booktitle> <address> June1990,66-77. </address> <month> IEEE-Scheme. </month> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> IEEE-1178-1990, IEEE, </publisher> <address> NY, </address> <month> Dec. </month> <year> 1990. </year>
Reference: <author> Johnston, J.B. </author> <title> "The Contour Model of Block Structured Processes". </title> <journal> Sigplan Notices (Feb. </journal> <year> 1971). </year>
Reference: <author> Jouppi, </author> <title> N.P. "Improving Direct-Mapped Cache Performance by the Addition of a Small Fully-Associative Cache and Prefetch Buffers". </title> <booktitle> Proc. 17th Int'l. Symp. on Computer Arch., ACM Computer Arch. </booktitle> <address> News 18,2 (June1990). </address>
Reference: <author> Kownacki, R., and Taft, S.T. </author> <title> "Portable and Efficient Dynamic Storage Management in Ada". </title> <booktitle> Proc. ACM SigAda Int'l. Conf. "Using Ada", </booktitle> <address> Dec.1987,190-198. </address>
Reference: <author> Kranz, D., et al. </author> <title> "ORBIT: An Optimizing Compiler for Scheme". </title> <booktitle> Proc. Sigplan '86 Symp. on Compiler Constr., Sigplan Notices 21,7 (July1986),219-233. </booktitle>
Reference: <author> Kranz, David A. </author> <title> ORBIT: An Optimizing Compiler for Scheme". </title> <type> Ph.D. Thesis, </type> <institution> Yale Univ., </institution> <note> also YALEU/DCS/RR-632, Feb.1988,138p. </note>
Reference: <author> Lieberman, H., Hewitt, C. </author> <title> "A Real-Time Garbage Collector Based on the Lifetimes of Objects". </title> <journal> CACM 26, </journal> <volume> 6 (June1983),419-429. </volume>
Reference: <author> McCarthy, J., et al. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, Camb., </publisher> <address> MA, </address> <year> 1965. </year>
Reference: <author> McDermott, D. </author> <title> "An Efficient Environment Allocation Scheme in an Interpreter for a Lexically-scoped LISP". </title> <booktitle> 1980 Lisp Conf., </booktitle> <address> Stanford, CA, Aug.1980,154-162. </address>
Reference: <author> Mellender, F, et al. </author> <title> "Optimizing Smalltalk Message Performance". </title> <editor> In Kim, W., and Lochovsky, F.H., eds., </editor> <booktitle> ObjectOriented Concepts, Databases and Applications. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, 1989,423-450.. </address>
Reference: <author> Moon, D. </author> <title> "Garbage Collection in a Large Lisp System". </title> <booktitle> ACM Symp. on Lisp & Funct. Prog., </booktitle> <year> 1984, </year> <pages> 235-246. </pages>
Reference: <author> Moore, Charles H. </author> <title> "The Evolution of FORTH, an Unusual Language". </title> <journal> Byte Magazine 5,8 (special issue on the Forth Programming Language) (Aug.1980),76-92. </journal>
Reference: <author> Morrison, Donald F, and Griss, Martin, L. </author> <title> "An Efficient A-list-like Binding Scheme". </title> <type> Unpublished manuscript, </type> <institution> Dept. of Computer Science, U. of Utah, Jan.1982,12p. </institution>
Reference: <author> Moses, J. </author> <title> "The function of FUNCTION in Lisp". </title> <type> Memo 199, </type> <institution> MIT AI Lab., Camb., </institution> <address> MA, June1970. </address>
Reference: <author> Moss, J.E.B. </author> <title> "Managing Stack Frames in Smalltalk". </title> <booktitle> SIGPLAN '87 Symp. on Interpreters and Interpretive Techniques, in Sigplan Notices 22, </booktitle> <volume> 7 (July1987), </volume> <pages> 229-240. </pages>
Reference: <author> Queinnec, Christian. </author> <title> "Dynamic Extent Objects". Lisp Pointers 2, </title> <address> 1 (July-Sept.1988),11-21. </address>
Reference: <author> Randell, B., and Russell, L.J. </author> <title> ALGOL 60 Implementation. </title> <publisher> Acad. Press, </publisher> <address> London and NY, </address> <year> 1964. </year>
Reference: <editor> Rees, J. and Clinger, W., et al. </editor> <title> "Revised Report on the Algorithmic Language Scheme". Sigplan Not. </title> <publisher> 21,12 (Dec.1986),37-79. </publisher>
Reference: <author> Richards, M., Evans, A., and Mabee, </author> <title> R.R. "The BCPL Reference Manual". </title> <publisher> MIT MACTR-141, Dec.1974,53p. </publisher>
Reference: <author> Ruggieri, C.; Murtagh, </author> <title> T.P. "Lifetime analysis of dynamically allocated objects". </title> <booktitle> ACM POPL '88,285-293. </booktitle>
Reference: <author> Samples, A.D., Ungar, D, and Hilfinger, P. </author> <title> "SOAR: Smalltalk without Bytecodes". </title> <booktitle> OOPSLA '86 Proc., Sigplan Not. </booktitle> <volume> 21, 11 (Nov.1986),107-118. </volume>
Reference: <author> Sandewall, E. </author> <title> "A Proposed Solution to the FUNARG Problem". 6.894 Class Notes, </title> <institution> MIT AI Lab., </institution> <month> Sept. </month> <year> 1974,42p. </year>
Reference: <author> Shaw, Robert A. </author> <title> "Improving Garbage Collector Performance in Virtual Memory". </title> <publisher> Stanford CSL-TR-87-323, March1987. </publisher>
Reference: <author> Sherman, Mark, et al. </author> <title> "An ADA Code Generator for VAX 11/780 with UNIX". </title> <booktitle> ACM SIGPLAN ADA Conf., SIGPLAN Notices 15,11 (Nov.1980),91-100. </booktitle>
Reference: <author> Stallman, Richard M. </author> <title> "Phantom Stacks: If you look too hard, they aren't there". </title> <type> AI Memo 556, </type> <institution> MIT AI Lab., </institution> <year> 1980. </year>
Reference: <author> Stanley, T.J., and Wedig, R.G. </author> <title> "A Performance Analysis of Automatically Managed Top of Stack Buffers". </title> <booktitle> Proc. 14th Int'l. Symp. on Computer Arch., ACM Computer Arch. </booktitle> <address> News 15,2 (June1987),272-281. </address>
Reference: <author> Steele, Guy L., Jr. </author> <title> "Fast Arithmetic in Maclisp". Proc. 1977 Macsyma User's C o n f e r e n c e , NASA Sci. and Tech. Info. Off. </title> <address> (Wash., DC, July1977),215-224. </address> <note> Also AI Memo 421, </note> <institution> MIT AI Lab., Camb. </institution> <address> Mass. </address>
Reference: <author> Steele, Guy L., Jr. Rabbit: </author> <title> A Compiler for SCHEME (A Study in Compiler Optimization). </title> <booktitle> AI-TR-474, Artificial Intelligence Laboratory, </booktitle> <publisher> MIT, May1978. </publisher>
Reference: <author> Steele, Guy L., Jr., and Sussman, Gerald J. </author> <title> "Design of LISP-Based Processors or SCHEME: A Dielectric LISP or, Finite Memories Considered Harmful or, LAMBDA: The Ultimate Opcode". MIT AI Memo 514, March1979. STEELMAN. Dept. of Defense Requirements for High Order Computer Programming Languages. </title> <publisher> June1978. </publisher>
Reference: <author> Taft, S. Tucker, et al. </author> <title> Ada-9X Draft Mapping Document. </title> <institution> Wright Lab., AFSC, Eglin AFB, </institution> <address> FL, Feb.1991. </address>
Reference: <author> Terashima, M., and Goto, E. </author> <title> "Genetic Order and Compactifying Garbage Collectors". </title> <journal> IPL 7,1 (Jan.1978),27-32. </journal>
Reference: <author> Unger, D. </author> <title> "Generation Scavenging: A nondisruptive, high performance storage reclamation algorithm". </title> <journal> ACM Soft. Eng. Symp. on Prac. Software Dev. Envs., Sigplan Notices 19,6 (June1984),157-167. </journal>
Reference: <author> Warren, David H.D. </author> <title> Applied LogicIts Use and Implementation as a Programming Tool. </title> <type> Ph.D. Thesis, </type> <institution> U. of Edinburgh, </institution> <year> 1977, </year> <note> also Tech. Note 290, </note> <institution> SRI Int'l., </institution> <address> Menlo Park, CA, 1983,230p. </address>
Reference: <author> Wise, D.S., and Friedman, </author> <title> D.P. "The One-Bit Reference Count". </title> <note> BIT 17 (1977),351-359. </note>
References-found: 72

