URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-995/CS-TR-91-995.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-995/
Root-URL: http://www.cs.wisc.edu
Email: netzer@cs.wisc.edu  bart@cs.wisc.edu  
Title: Improving the Accuracy of Data Race Detection  
Author: Robert H. B. Netzer Barton P. Miller 
Date: April 1991.  
Note: Research supported in part by National Science Foundation grant CCR-8815928, Office of Naval Research grant N00014-89-J-1222, and a Digital Equipment Corporation External Research Grant. To appear in Proc. of the Third ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming,  
Address: 1210 W. Dayton Street Madison, Wisconsin 53706  Williamsburg, VA,  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: For shared-memory parallel programs that use explicit synchronization, data race detection is an important part of debugging. A data race exists when concurrently executing sections of code access common shared variables. In programs intended to be data race free, they are sources of nondeterminism usually considered bugs. Previous methods for detecting data races in executions of parallel programs can determine when races occurred, but can report many data races that are artifacts of others and not direct manifestations of program bugs. Artifacts exist because some races can cause others and can also make false races appear real. Such artifacts can overwhelm the programmer with information irrelevant for debugging. This paper presents results showing how to identify non-artifact data races by validation and ordering. Data race validation attempts to determine which races involve events that either did execute concurrently or could have (called feasible data races). We show how each detected race can either be guaranteed feasible, or when insufficient information is available, sets of races can be identified within which at least one is guaranteed feasible. Data race ordering attempts to identify races that did not occur only as a result of others. Data races can be partitioned so that it is known whether a race in one partition may have affected a race in another. The first partitions are guaranteed to contain at least one feasible data race that is not an artifact of any kind. By combining validation and ordering, the programmer can be directed to those data races that should be investigated first for debugging. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allen, T. R. and D. A. Padua, </author> <title> ``Debugging Fortran on a Shared Memory Machine,'' </title> <booktitle> Proc. of Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 721-727 St. Charles, IL, </address> <month> (Aug. </month> <year> 1987). </year>
Reference-contexts: We show how to locate those data races that are direct manifestations of program bugs, instead of artifacts of other data races. Data race reports generated by most existing methods <ref> [1, 3, 4, 6, 8] </ref> can include potentially many artifacts, which can overwhelm the programmer with irrelevant information. Such data race artifacts stem from two sources. <p> One proposed method addresses the need to locate first data races [2]; we postpone discussing this method until the end of Section 5, after our terminology and results have been presented. Existing data race detection methods <ref> [1, 3, 4, 6, 8] </ref> operate by first instrumenting the program so that information about its execution is recorded, and then executing the program and analyzing the collected information. <p> This example shows that a and d could have executed concurrently even though the shared-data dependence from a to b would then no longer occur. We finally mention that our event-control dependences are similar to the hides relation used by Allen and Padua <ref> [1] </ref>, and the semantic dependences defined by Podgurski and Clarke [9]. The hides relation is defined to show when the data computed by an event in one data race may have been used by an event in another race to determine either control flow or the shared locations accessed.
Reference: [2] <author> Choi, J.-D. and S. L. Min, </author> <title> ``Race Frontier: Reproducing Data Races in Parallel Program Debugging,'' </title> <booktitle> Proc. of Symp. on Principles and Practice of Parallel Prog., </booktitle> <address> Williamsburg, VA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: Existing Data Race Detection Methods To illustrate the need for data race validation and ordering, we show how most existing methods for dynamic data race detection operate on an example program execution. One proposed method addresses the need to locate first data races <ref> [2] </ref>; we postpone discussing this method until the end of Section 5, after our terminology and results have been presented. <p> Nonetheless, simple algorithms exist to identify and order the partitions; they are the topic of a future paper. 5.3. Related Work One proposed method for detecting data races does address the need for locating first races. Choi and Min <ref> [2] </ref> present an on-the-fly approach for executions of programs intended to be deterministic. Their goal is to locate a set of data races, called the Race Frontier (containing at most one race in each process), up to which re-execution of the program is guaranteed to be deterministic.
Reference: [3] <author> Dinning, A. and E. Schonberg, </author> <title> ``An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection,'' </title> <booktitle> Proc. of Symp. on Principles and Practice of Parallel Prog., </booktitle> <pages> pp. </pages> <address> 1-10 Seattle, WA, </address> <month> (Mar. </month> <year> 1990). </year>
Reference-contexts: We show how to locate those data races that are direct manifestations of program bugs, instead of artifacts of other data races. Data race reports generated by most existing methods <ref> [1, 3, 4, 6, 8] </ref> can include potentially many artifacts, which can overwhelm the programmer with irrelevant information. Such data race artifacts stem from two sources. <p> One proposed method addresses the need to locate first data races [2]; we postpone discussing this method until the end of Section 5, after our terminology and results have been presented. Existing data race detection methods <ref> [1, 3, 4, 6, 8] </ref> operate by first instrumenting the program so that information about its execution is recorded, and then executing the program and analyzing the collected information. <p> To determine if two events could have executed concurrently, all existing methods analyze the ordering graph, and assume that two events could have executed concurrently if no path hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Some methods represent computation events by the intra-process edges, instead of constructing a separate node <ref> [3, 6] </ref>. 2 January 25, 1991 connects the two events. Data races are therefore reported between any events that accessed common shared variables and that have no connecting path. However, this approach can report potentially many data race artifacts.
Reference: [4] <author> Hood, R., K. Kennedy, and J. Mellor-Crummey, </author> <title> ``Parallel Program Debugging with On-the-fly Anomaly Detection,'' </title> <booktitle> Supercomputing '90, </booktitle> <address> New York, NY, </address> <month> (Nov. </month> <year> 1990). </year>
Reference-contexts: We show how to locate those data races that are direct manifestations of program bugs, instead of artifacts of other data races. Data race reports generated by most existing methods <ref> [1, 3, 4, 6, 8] </ref> can include potentially many artifacts, which can overwhelm the programmer with irrelevant information. Such data race artifacts stem from two sources. <p> One proposed method addresses the need to locate first data races [2]; we postpone discussing this method until the end of Section 5, after our terminology and results have been presented. Existing data race detection methods <ref> [1, 3, 4, 6, 8] </ref> operate by first instrumenting the program so that information about its execution is recorded, and then executing the program and analyzing the collected information.
Reference: [5] <author> Lamport, L., </author> <title> ``The Mutual Exclusion Problem: Part I A Theory of Interprocess Communication,'' </title> <journal> JACM 33(2)(Apr. </journal> <year> 1986). </year>
Reference-contexts: Program Execution Model We provide only a brief overview of our model, which was first presented in an earlier paper [7]. Our model is based on Lamport's theory of concurrent systems <ref> [5] </ref>, which provides a formalism for reasoning about concurrent systems that does not assume the existence of atomic operations. We consider executions of programs, on sequentially consistent processors, that use fork/join and counting semaphores.
Reference: [6] <author> Miller, B. P. and J.-D. Choi, </author> <title> ``A Mechanism for Efficient Debugging of Parallel Programs,'' </title> <booktitle> Proc. of Conf. on Prog. Lang. Design and Impl., </booktitle> <pages> pp. </pages> <address> 135-144 Atlanta, GA, </address> <month> (June </month> <year> 1988). </year> <note> Also SIGPLAN Notices 23(7) (July 1988). </note>
Reference-contexts: We show how to locate those data races that are direct manifestations of program bugs, instead of artifacts of other data races. Data race reports generated by most existing methods <ref> [1, 3, 4, 6, 8] </ref> can include potentially many artifacts, which can overwhelm the programmer with irrelevant information. Such data race artifacts stem from two sources. <p> One proposed method addresses the need to locate first data races [2]; we postpone discussing this method until the end of Section 5, after our terminology and results have been presented. Existing data race detection methods <ref> [1, 3, 4, 6, 8] </ref> operate by first instrumenting the program so that information about its execution is recorded, and then executing the program and analyzing the collected information. <p> To determine if two events could have executed concurrently, all existing methods analyze the ordering graph, and assume that two events could have executed concurrently if no path hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Some methods represent computation events by the intra-process edges, instead of constructing a separate node <ref> [3, 6] </ref>. 2 January 25, 1991 connects the two events. Data races are therefore reported between any events that accessed common shared variables and that have no connecting path. However, this approach can report potentially many data race artifacts.
Reference: [7] <author> Netzer, R. H. B. and B. P. Miller, </author> <title> ``Detecting Data Races in Parallel Program Executions,'' in Languages and Compilers for Parallel Computing, </title> <editor> ed. D. Gelernter, T. Gross, A. Nicolau, and D. Pa-dua, </editor> <title> MIT Press (1991). </title> <booktitle> Also Proc. of the 3rd Workshop on Prog. Langs. and Compilers for Parallel Computing, </booktitle> <address> Irvine, CA, </address> <month> (Aug. </month> <year> 1990). </year>
Reference-contexts: In this paper we present results that show how to locate data races that are not artifacts of others. To address the first cause of data race artifacts, we extend our previous work <ref> [7] </ref> on validating the data races detected by existing methods. <p> We later use the model to speculate on behavior that the execution could have exhibited (such as alternate event orderings) due to nondeterministic timing variations. 3.1. Program Execution Model We provide only a brief overview of our model, which was first presented in an earlier paper <ref> [7] </ref>. Our model is based on Lamport's theory of concurrent systems [5], which provides a formalism for reasoning about concurrent systems that does not assume the existence of atomic operations. We consider executions of programs, on sequentially consistent processors, that use fork/join and counting semaphores. <p> These analyses involve speculating on behaviors that the program had the potential of exhibiting. In this section, we speculate on alternate temporal orderings that could have potentially occurred. We extend our previous work <ref> [7] </ref> by first considering a type of shared-data dependence, called an event-control dependence, which describes how events affect each other in the actual program execution P. Using these dependences, the effects that alternate orderings might have had on the performed events can be determined. <p> For example, if the program is nondeterministic, it may have had the potential of performing different events than P. In addition, the execution may have also had the potential of performing the same events as P but under a different ordering. We have shown <ref> [7] </ref> that any ordering that could have allowed the same shared-data dependences as those exhibited by P to occur could have also caused the same events to be performed (if interactions with the external environment are modeled as shared-data dependences). <p> We have proven that any other program execution, obeying axioms (A1)-(A6), and possessing the same D relation as P, describes an execution performing ex actly the same events as P, and is thus feasible <ref> [7] </ref>. Showing that Theorem 4.1 holds at a higher-level is analogous to this proof, and we omit the details here. a b is excluded from the prefix, e must also be excluded because b E e, but c can remain (even though b D because b / E c. <p> Such a path al ready exists when a T b, so edges are only added between events unordered by G. Figure 3 (a) shows an example G D (``S'' and ``F'' label the start and finish nodes). In a previous paper <ref> [7] </ref>, we showed how some apparent data races can be validated by analyzing G D . Intuitively, the edges added to construct G D reflect the possible orderings caused by shared-data dependences, similar to the way in which the edges in G reflect orderings caused by the execution's explicit synchronization. <p> To prove this theorem, we must reason about the portions of a and b that executed non-atomically. Since in our model computation events can be defined to comprise any amount of computation performed in between synchronization operations, we can view a and b as comprising lower-level events <ref> [7] </ref>. Let a atom and b atom be the initial por tions of a and b that executed atomically, and let a natom and b natom be the remainder. <p> view of a program execution, P S = E S , T S , in which each computation event is defined to comprise at most one shared-memory access, in the sense that each event e E can be thought of as containing a set of lower-level events from E S <ref> [7] </ref>. The single-access view P S contains information regarding the relative order in which individual shared-memory accesses were performed.
Reference: [8] <author> Nudler, I. and L. Rudolph, </author> <title> ``Tools for the Efficient Development of Efficient Parallel Programs,'' </title> <booktitle> Proc. of 1st Israeli Conf. on Computer System Eng., </booktitle> <year> (1988). </year>
Reference-contexts: We show how to locate those data races that are direct manifestations of program bugs, instead of artifacts of other data races. Data race reports generated by most existing methods <ref> [1, 3, 4, 6, 8] </ref> can include potentially many artifacts, which can overwhelm the programmer with irrelevant information. Such data race artifacts stem from two sources. <p> One proposed method addresses the need to locate first data races [2]; we postpone discussing this method until the end of Section 5, after our terminology and results have been presented. Existing data race detection methods <ref> [1, 3, 4, 6, 8] </ref> operate by first instrumenting the program so that information about its execution is recorded, and then executing the program and analyzing the collected information.
Reference: [9] <author> Podgurski, A. and L. A. Clarke, </author> <title> ``A Formal Model of Program Dependences and Its Implications for Software Testing, Debugging, and Maintenance,'' </title> <journal> IEEE Trans. on Software Engineering 16(9) pp. </journal> <month> 965-979 (Sep. </month> <year> 1990). </year> <month> 12 </month>
Reference-contexts: We finally mention that our event-control dependences are similar to the hides relation used by Allen and Padua [1], and the semantic dependences defined by Podgurski and Clarke <ref> [9] </ref>. The hides relation is defined to show when the data computed by an event in one data race may have been used by an event in another race to determine either control flow or the shared locations accessed.
References-found: 9

