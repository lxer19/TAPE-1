URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/watanabe.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/Thesis/thesis.html
Root-URL: http://www.cs.berkeley.edu
Title: LOGIC OPTIMIZATION OF INTERACTING COMPONENTS IN SYNCHRONOUS DIGITAL SYSTEMS  
Author: by Yosinori Watanabe 
Degree: Master of Science (University of California at Berkeley) 1991 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Engineering-Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor Alberto Sangiovanni-Vincentelli Professor Shmuel Oren  
Date: 1988  1994  
Address: Tokyo, Japan)  
Affiliation: Bachelor of Engineering (Waseda University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Avedillo, J. Quintana, and L. Huertas. </author> <title> Efficient State Reduction Methods for PLA-based Sequential Circuits. </title> <journal> IEE Proceedings-E, </journal> <volume> 139(6) </volume> <pages> 491-499, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 110 The problem is analogous to the state minimization of deterministic finite state machines, which finds a minimum-state deterministic machine whose behavior is contained in a given deterministic finite state machine <ref> [1, 23, 24, 40, 44] </ref>. Our problem is more general in that a given machine is non-deterministic. We also need to take into account the implementability of a behavior. As shown in Section 4.6, the E-machine has a special type of non-deterministic finite state machine called a pseudo non-deterministic machine. <p> Specifically, it is a subproblem of the case where a given machine is a general non-deterministic machine, and is a generalization of the case where a given machine is deterministic. The research for the deterministic case has been done extensively <ref> [1, 23, 24, 40, 44] </ref>, while little has been done for the non-deterministic case. In the following section, we present a theoretical analysis of the state minimization of pseudo non-deterministic machines, in which we show how the basic concepts developed for the deterministic case can be generalized for the problem. <p> The basic paradigm is similar to ESPRESSO [8] except that IRREDUNDANT is called even after REDUCE. It is also similar to the procedure proposed CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 137 in <ref> [1] </ref> for the state minimization of incompletely specified deterministic machines, except that the detailed techniques of the proposed procedures are completely different. 5.6.3 REDUCE REDUCE takes as input a feasible set C and processes one element of C at a time replacing it by its smallest subset, while maintaining feasibility.
Reference: [2] <author> T. Bartee, I. Lebow, and I. Reed. </author> <title> Theory and Design of Digital Machines. </title> <publisher> McGraw-Hill Book Company, Inc., </publisher> <year> 1962. </year>
Reference-contexts: We then find, in the second step, an optimum behavior in the set according to a given cost function. The type of systems we consider in this thesis is digital systems. We follow the conventional definition of digital systems <ref> [2, 4] </ref>, i.e. one in which each component can be modeled so that it handles information in a discrete manner. By behavior, we mean logic behavior. Specifically, we consider two types of behaviors.
Reference: [3] <author> K. Bartlett, R. K. Brayton, G. D. Hachtel, R. Jacoby, C. Morrison, R. Rudell, A. Sangiovanni-Vincentelli, and A. Wang. </author> <title> Multi-level Logic Minimization using Implicit Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-7, </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: Specifically, each chapter is organized as follows. Chapter 2 deals with the case where each component implements a Boolean function with multiple inputs and multiple outputs. Although extensive research has been made for the problem of finding permissible behaviors for combinational logic with a single output <ref> [3, 39, 50] </ref>, little has been done for the case of multiple outputs. In this chapter, we first discuss the problem of finding the maximum set of permissible behaviors for a given component.
Reference: [4] <author> A. Booth and K. Booth. </author> <title> Automatic Digital Calculators. </title> <publisher> Butterworth Scientific Publications, </publisher> <year> 1953. </year>
Reference-contexts: We then find, in the second step, an optimum behavior in the set according to a given cost function. The type of systems we consider in this thesis is digital systems. We follow the conventional definition of digital systems <ref> [2, 4] </ref>, i.e. one in which each component can be modeled so that it handles information in a discrete manner. By behavior, we mean logic behavior. Specifically, we consider two types of behaviors.
Reference: [5] <author> E. Braun. </author> <title> Digital Computer Design Logic, Circuitry, and Synthesis. </title> <publisher> Academic Press Inc., </publisher> <year> 1963. </year>
Reference-contexts: Among digital systems, we restrict our attention only to synchronous systems in this thesis. In a synchronous system, the operations of all the components of the system are synchronized by a global timing controller, or a clock, and each operation requires an integer number of clock intervals <ref> [5, 19] </ref>. For combinational logic behaviors, we assume that signals arrive at all the inputs of the system at the same time and it takes no time for each component to compute the corresponding output signals.
Reference: [6] <author> R. K. Brayton. </author> <title> New Directions in Logic Synthesis. </title> <booktitle> In Proceedings of the Synthesis and Simulation Meeting and International Interchange, </booktitle> <address> Kyoto, Japan, </address> <year> 1990. </year>
Reference-contexts: This aspect will be detailed later in Section 3.3. Also, a Boolean relation is a special case of the type of relations considered here, and thus our problem subsumes the problem of minimizing Boolean relations. Multiple-valued relations arise in many contexts <ref> [6, 11, 32] </ref>, besides the local optimizations of multi-level combinational logic circuits considered in Chapter 2.
Reference: [7] <author> R. K. Brayton. </author> <title> private communication, </title> <year> 1994. </year>
Reference-contexts: Note also that the theorem above is claimed under the assumption that both U and V are Boolean variables. It is known that for symbolic variables, there exist cases where cyclic dependency observed for symbolic variables can be broken in an actual implementation by carefully encoding the variables <ref> [7] </ref>. 4.7.2 Unimplementable Machines in the E-machine In general, not all machines contained in the E-machine are implementable.
Reference: [8] <author> R. K. Brayton, G. D. Hachtel, C. McMullen, and A. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1984. </year>
Reference-contexts: This problem is called the minimization of relations , and is a generalization of the minimization of functions, which has been fully investigated <ref> [8, 25, 34] </ref>. In this chapter, we consider the general case where an input variable of a function may assume more than two values. We present a heuristic procedure for the problem, which is analogous to Espresso [8], a well-developed heuristic approach for minimizing functions. <p> In this chapter, we consider the general case where an input variable of a function may assume more than two values. We present a heuristic procedure for the problem, which is analogous to Espresso <ref> [8] </ref>, a well-developed heuristic approach for minimizing functions. We make a contrast between relations and functions by showing some special properties associated with relations not found in functions. These properties are carefully accounted for in the proposed heuristic procedure to effectively achieve high quality results. <p> Research in logic minimization has been active over the past 40 years. Initial research was directed towards developing techniques to produce an optimum sum-of-products expression of a Boolean function under don't care conditions [34], and has evolved toward heuristic approaches for designing programmable logic arrays (PLA's) <ref> [8, 25] </ref>. A Boolean function with don't care conditions is called an incompletely specified Boolean function, and the problem above is sometimes referred to as the two-level minimization of incompletely specified Boolean functions. <p> Ghosh et al. [22] proposed and implemented an approach for Boolean relations which makes use of test pattern generation techniques and heuristically finds a sum-of-products expression. The method is similar to two-level minimizers for Boolean functions (e.g. <ref> [8] </ref>) in the sense that procedures analogous to expand, irredundant, and reduce are repeatedly applied as long as the cost decreases. <p> CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 38 3.2 Preliminaries We describe the relationship among functions and relations, and see when a procedure is needed for minimizing relations directly. 3.2.1 Terminology We follow references <ref> [8, 11, 45] </ref> for most of the terminology used throughout this chapter. Definition: Multiple-Valued Relation A multiple-valued relation R is a subset of D fi B m . <p> Definition: Candidate Prime (c-prime) For a given relation R, a cube c is a candidate prime (or a c-prime) if there exists a function compatible with R in which c is a prime implicant <ref> [8] </ref>. <p> IRREDUNDANT makes the representation F so that it consists only of irredundant cubes. Specifically, one cube c 2 F is processed at a time, and is removed if and only if F fcg is compatible. Unlike the irredundant procedure of Espresso <ref> [8] </ref>, which computes a minimum subset of the current representation for a Boolean function based on the concept of partially redundant cubes, our procedure is dependent on the order that the cubes are processed. <p> Although the results varied slightly with different orderings, none was always better than another. As in the case of the minimization of functions [45], the final results seemed to be independent of the ordering strategies in general. Thus we order the cubes with the same strategy employed in Espresso <ref> [8] </ref>, in which the largest cube is processed first and the rest are sorted in increasing order of the number of mismatches (distance) of each cube against the largest one. 3.5.5 EXPAND The objective of EXPAND is to remove as many cubes as possible from a given compatible representation. <p> The proposed procedure takes as input the transition relation of a pseudo non-deterministic finite state machine T . After a feasible set C is found as an initial set, the procedure iteratively applies EXPAND and REDUCE, invoking IRREDUNDANT after each procedure. The basic paradigm is similar to ESPRESSO <ref> [8] </ref> except that IRREDUNDANT is called even after REDUCE. It is also similar to the procedure proposed CHAPTER 5.
Reference: [9] <author> R. K. Brayton, G. D. Hachtel, and A. Sangiovanni-Vincentelli. </author> <title> Multilevel Logic Synthesis. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> Vol. 78(No. 2), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: CHAPTER 2. PERMISSIBLE LOGIC FUNCTIONS FOR MULTI-OUTPUT COMPONENTS 6 Conventionally, a multi-level combinational logic circuit is abstracted in a more restrictive way by using a model called a Boolean network, and the problem above has been extensively studied for this model <ref> [9] </ref>. A Boolean network is also a directed acyclic graph, where the Boolean function associated with each node must have a single output. <p> of experiment, where the effectiveness of the proposed procedure was examined in a context common in practice for optimizing multi-level combinational logic circuits, i.e. local optimization techniques, such as the one discussed in this chapter, are applied in conjunction with global optimization techniques such as a factorization or a decomposition <ref> [9] </ref>. The objective of the experiment is to see the effectiveness of optimizing a set of nodes at a time in a clustered Boolean network. <p> We describe our view for each type of behavior. For combinational behaviors, intensive research has been done on the problem addressed in Chapter 2 for the case where each component has exactly one output <ref> [9] </ref>. As mentioned in Chapter 2, our experimental results do not provide significant effectiveness of the method for multiple outputs over the existing methods for single outputs. However, we think it is still too early to conclude that for practical applications, it is sufficient to only use single output methods.
Reference: [10] <author> R. K. Brayton, R. Rudell, A. Sangiovanni-Vincentelli, and A. Wang. </author> <title> MIS: Multiple-Level Logic Optimization System. </title> <journal> IEEE Transaction on Computer Aided Design of Integrated Circuits and Systems, </journal> <volume> Vol. CAD-6(No. 6):1062 - 1081, </volume> <month> November </month> <year> 1987. </year> <note> BIBLIOGRAPHY 153 </note>
Reference-contexts: Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . As we will see later, the minimization of functions is a simpler problem than the minimization of relations. Furthermore, a number of methods for function minimization exist (e.g. <ref> [10, 16, 25, 34, 45, 47] </ref>). Therefore, if this is the case, we invoke one of the conventional procedures for minimizing functions to obtain a minimal implementation of the given relation R.
Reference: [11] <author> R. K. Brayton and F. Somenzi. </author> <title> Boolean Relations and the Incomplete Specification of Logic Networks. </title> <booktitle> In International Conference on Very Large Scale Integration, </booktitle> <address> Munich, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: A behavior here is a Boolean function with multiple outputs. Brayton and Somenzi showed in <ref> [11] </ref> that the complete set can be represented by a Boolean relation, a relation between the Boolean spaces spanned by the inputs and the outputs of the component respectively. Namely, a CHAPTER 1. <p> Specifically, fixing the Boolean functions associated with the rest of the nodes as they are, one wants to compute the maximum set of Boolean functions that can be realized at the node while preserving the functionality of the entire network. Brayton and Somenzi showed in <ref> [11] </ref> that in case of multiple-output functions, such a set cannot be represented by a Boolean function with don't cares, and introduced a theory of Boolean relations. <p> Brayton and Somenzi showed that the maximum set of permissible functions at a given cluster can be computed and represented by a single Boolean relation <ref> [11] </ref>. <p> More recently, as seen in Chapter 2, it was shown that don't cares of the traditional kind are inadequate to capture the complete freedom for optimizing multiple output functions, and a theory of Boolean relations was introduced <ref> [11] </ref>. In parallel with this activity has been the minimization of multiple-valued functions [31, 47], in which variables can assume more than two discrete values. The significance of this problem is in its applications in areas such as PLA optimization [45] and state assignment for finite CHAPTER 3. <p> This aspect will be detailed later in Section 3.3. Also, a Boolean relation is a special case of the type of relations considered here, and thus our problem subsumes the problem of minimizing Boolean relations. Multiple-valued relations arise in many contexts <ref> [6, 11, 32] </ref>, besides the local optimizations of multi-level combinational logic circuits considered in Chapter 2. <p> For the cost function, we use the number of product terms required in a sum-of-products expression representing a function in the set given by the relation. Conventionally, a function in the set represented by a given relation is called a compatible function <ref> [11] </ref>. Then the problem is that for a given multiple-valued relation, find a sum-of-products expression with the minimum number of product terms for a function compatible with the relation. <p> CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 38 3.2 Preliminaries We describe the relationship among functions and relations, and see when a procedure is needed for minimizing relations directly. 3.2.1 Terminology We follow references <ref> [8, 11, 45] </ref> for most of the terminology used throughout this chapter. Definition: Multiple-Valued Relation A multiple-valued relation R is a subset of D fi B m . <p> MINIMIZATION OF MULTIPLE-VALUED RELATIONS 42 mapping, and provides the complete family of functions compatible with R. If, in addition, r (x) can be represented as a single cube for every x 2 D, then r can be expressed as an incompletely specified function <ref> [11] </ref>. Thus for each output of r, the set D can be divided into the On-set, the Off-set, and the Don't-care set. Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . <p> Namely, our objective is to minimize the multiple-valued relation F . If the number of symbolic product terms is the cost function used, then the problem is reduced to the relation minimization focused in this chapter. Other applications of multiple-valued as well as Boolean relations can be found in <ref> [11, 32] </ref>. Example 3.2.2 The case where the use of equivalent states results in a representation with less cost is illustrated in the following example. Suppose that a completely specified deterministic finite state machine is given as shown in Figure 3.2. <p> We demonstrated that the complete set of permissible Boolean functions can be represented by a single Boolean relation, first shown by Brayton and Somenzi in <ref> [11] </ref>. Also, the problem of finding compatible sets of permissible functions was addressed.
Reference: [12] <author> R. E. Bryant. </author> <title> Graph Based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-35(No. </volume> 8):677-691, August 1986. 
Reference-contexts: A formal proof of this claim is found in Theorem 2.4.3. In the actual computation of F v above, each of the operands is represented by a binary CHAPTER 2. PERMISSIBLE LOGIC FUNCTIONS FOR MULTI-OUTPUT COMPONENTS19 decision diagram (BDD) <ref> [12] </ref>, and the operations are performed on BDD's. A BDD is a data structure to represent a single-output Boolean function, and thus the characteristic function of the relation H or M can be directly represented by BDD's. <p> In the implementation, we represent a characteristic function by using an MDD (Multi-valued Decision Diagram) [54]. An MDD is a data structure to represent a function with multiple-valued input variables and a single binary output, which employs a BDD <ref> [12] </ref> as the internal data structure. In the sequel, we make no distinction between a relation and its characteristic function. <p> The current implementation is limited to the case that the global machine M is deterministic, and thus a state of the E-machine corresponds to a subset of pairs of states of M 2 and M . Binary decision diagrams (BDD's) <ref> [12] </ref> are used to represent the transition relations of M 2 and M , where a set of states of each machine is represented by binary variables using log-based encodings. All set operations, such as intersection, union, complement, set comparisons, as well as quantifications, are performed on BDD's.
Reference: [13] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of Sequential Machines Based on Symbolic Execution. In Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, </title> <address> Grenoble, France, </address> <year> 1989. </year>
Reference-contexts: Such a set is computed by a BDD operation similar to the one known as generalized cofactor <ref> [13] </ref>, and a detailed description is found in [52]. During the computation, we need to see if a given pair of states ( s 2 ; s) 2 S 2 fi S is a member of S p .
Reference: [14] <author> M. Damiani. </author> <title> Nondeterministic Finite-State Machines and Sequential Don't Cares. </title> <booktitle> In European Conference on Design Automation, </booktitle> <year> 1994. </year>
Reference-contexts: For the exact method of finding an optimum contained behavior given in Section 5.4.1, we are not concerned with implementability. Thus we don't need to associate an output function with a subset of states. This was first indicated by Damiani in <ref> [14] </ref>.
Reference: [15] <author> M. Damiani and G. De Micheli. </author> <title> Derivation of Don't Care Conditions by Perturbation Analysis of Combinational Multiple-Level Logic Circuits. </title> <booktitle> In International Workshop on Logic Synthesis, </booktitle> <year> 1991. </year>
Reference-contexts: Hence the existential property holds for the updated relation H. CHAPTER 2. PERMISSIBLE LOGIC FUNCTIONS FOR MULTI-OUTPUT COMPONENTS22 2.4.3 An Example We illustrate how the proposed procedure works using the example shown in Figure 2.4. This example was introduced in <ref> [15] </ref> as a counterexample for which the method of computing compatible sets of permissible functions proposed in [49] fails to compute maximal sets. Suppose the clusters have been composed so that every cluster consists of exactly one gate, i.e. there are three clusters u, v, and w.
Reference: [16] <author> J. Darringer, W. Joyner, L. Berman, and L. Trevillyan. </author> <title> Logic Synthesis through Local Transformations. </title> <journal> IBM J. Res. Develop., </journal> <pages> pages 272-280, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . As we will see later, the minimization of functions is a simpler problem than the minimization of relations. Furthermore, a number of methods for function minimization exist (e.g. <ref> [10, 16, 25, 34, 45, 47] </ref>). Therefore, if this is the case, we invoke one of the conventional procedures for minimizing functions to obtain a minimal implementation of the given relation R.
Reference: [17] <author> G. De Micheli, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Optimal State Assignment for Finite State Machines. </title> <journal> IEEE Transaction on Computer Aided Design of Integrated Circuits and Systems, </journal> <volume> CAD-4:269 - 285, </volume> <month> July </month> <year> 1985. </year>
Reference-contexts: The significance of this problem is in its applications in areas such as PLA optimization [45] and state assignment for finite CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 36 state machines <ref> [17] </ref>. In this chapter, we assume that a given relation is in general a multiple-valued relation, in the sense that the input variables can take multiple (more than two) values.
Reference: [18] <author> S. Devadas. </author> <title> Approaches to Multi-Level Sequential Logic Synthesis. </title> <booktitle> In 26th ACM/IEEE Design Automation Conference, </booktitle> <year> 1989. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 4 Chapter 4 considers the problem of finding the maximum set of permissible behaviors at a given component. The definition of the set is same as the combinational case, except that a behavior here is now sequential. Although extensive research has been done for the problem <ref> [18, 29, 43, 56] </ref>, no method is known on how to capture the complete degree of freedom. We claim that the complete set of permissible sequential behaviors of a given component can be computed and represented by a single non-deterministic finite state machine, which we call the E-machine. <p> This is the central problem of factorization and decomposition of finite state machines, and is similar to the rectification problem above. 4.1.3 Related Work The problem of finding a set of permissible behaviors for interacting finite state machines has been studied previously <ref> [18, 29, 43, 56, 59] </ref>. Most results, following analogies from the combinational logic case, are based on don't care sequences. For example, input don't care sequences are sequences of inputs of M 1 which never occur. <p> work either makes an assumption on the topology of M 1 and M 2 , such as cascaded machines where M 2 is independent of M 1 , restricts to computing only a subset of don't care sequences, or computes input don't care sequences and output don't care sequences separately <ref> [18, 29, 43, 59] </ref>. Furthermore, due to complexity, often the sequences are only partially considered, up to a certain, typically small, length.
Reference: [19] <author> J. Eckert, Jr. </author> <title> Types of Circuits General. In Theory and Techniques for Design of Electronic Computers. Lectures given at the Moore School, </title> <month> 8 July </month> <year> 1946-31 </year> <month> August </month> <year> 1946. </year> <institution> University of Pennsylvania, </institution> <year> 1947. </year> <title> Also in The Moore School Lectures, </title> <booktitle> Vol. 9 in the Charles Babbage Institute Reprint Series for the History of Computing. </booktitle> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Among digital systems, we restrict our attention only to synchronous systems in this thesis. In a synchronous system, the operations of all the components of the system are synchronized by a global timing controller, or a clock, and each operation requires an integer number of clock intervals <ref> [5, 19] </ref>. For combinational logic behaviors, we assume that signals arrive at all the inputs of the system at the same time and it takes no time for each component to compute the corresponding output signals.
Reference: [20] <author> M. Fujita. </author> <title> Methods for Automatic Design Error Correction in Sequential Circuits. </title> <booktitle> In The European Conference on Design Automation with The European Event in ASIC Design, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: This is illustrated in Figure 4.2-(b). Such a problem arises in rectification problems <ref> [20, 60] </ref>, where the designer wants to change the functionality of a design, perhaps because of an engineering change, by attaching a small block of logic (M 2 ) external to the original circuitry. Another related problem is a supervisory control problem for discrete event processes [42].
Reference: [21] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability A Guide to the Theory and NP-Completeness. W.H. </title> <publisher> Freeman And Company, </publisher> <year> 1979. </year> <note> BIBLIOGRAPHY 154 </note>
Reference-contexts: This is the problem we are concerned with in this chapter. Note the difference of this problem from a problem known as reduction of nondeterministic finite automata, which finds a minimum-state automaton with the same language for a given non-deterministic finite automaton <ref> [21] </ref>. Our problem does not require the behaviors of the original finite state machine to be preserved during the minimization. CHAPTER 5.
Reference: [22] <author> A. Ghosh, S. Devadas, and A. R. </author> <title> Newton. Heuristic Minimization of Boolean Relations using Testing Techniques. </title> <booktitle> In IEEE International Conference on Computer Design, </booktitle> <address> Cambridge, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: However, since the method is exact, it is expensive both in CPU time and memory space, so that only small examples can be handled. CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 37 Our focus in this chapter is on heuristic minimizations. Ghosh et al. <ref> [22] </ref> proposed and implemented an approach for Boolean relations which makes use of test pattern generation techniques and heuristically finds a sum-of-products expression. <p> However, unlike the most effective two-level minimizers that consider multiple variables to be expanded or reduced simultaneously, the method is greedy and only one variable is examined at a time. Thus the minimizer of <ref> [22] </ref> is more likely to get stuck at a bad solution. This drawback is fatal for extending the method since the simultaneous expansion of multiple variables implies the use of multiple faults, which could be very expensive to detect with ATPG techniques. <p> In the EXPAND procedure, employing the techniques introduced in [45], we have implemented the proposed algorithm by directly using a representation F instead of a covering matrix. For comparison with existing techniques, several examples of Boolean relations were tried. The results are compared with the other two approaches <ref> [22, 53] </ref> developed for Boolean relations, where the programs for both procedures were provided to the authors. Table 3.7 shows the number of the product terms and CPU time (seconds) measured on a DECstation 5000/240 for all three methods. <p> Table 3.7 shows the number of the product terms and CPU time (seconds) measured on a DECstation 5000/240 for all three methods. Exact is the exact procedure [53], Herb is a heuristic approach proposed in <ref> [22] </ref>. GYOCRO is the proposed approach. GYOCRO performs quite well both in CPU time and results. In fact, among the 18 examples for which the exact minimizer worked, the proposed procedure achieved optimum solutions for 13 examples. In order to speed up the proposed method, we tried a modification.
Reference: [23] <author> S. Ginsburg. </author> <title> Synthesis of Minimal-State Machines. </title> <journal> IRE Transactions on Electronic Computers, </journal> <pages> pages 441-419, </pages> <month> December </month> <year> 1959. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 110 The problem is analogous to the state minimization of deterministic finite state machines, which finds a minimum-state deterministic machine whose behavior is contained in a given deterministic finite state machine <ref> [1, 23, 24, 40, 44] </ref>. Our problem is more general in that a given machine is non-deterministic. We also need to take into account the implementability of a behavior. As shown in Section 4.6, the E-machine has a special type of non-deterministic finite state machine called a pseudo non-deterministic machine. <p> Specifically, it is a subproblem of the case where a given machine is a general non-deterministic machine, and is a generalization of the case where a given machine is deterministic. The research for the deterministic case has been done extensively <ref> [1, 23, 24, 40, 44] </ref>, while little has been done for the non-deterministic case. In the following section, we present a theoretical analysis of the state minimization of pseudo non-deterministic machines, in which we show how the basic concepts developed for the deterministic case can be generalized for the problem.
Reference: [24] <author> A. Grasselli and F. Luccio. </author> <title> A Method for Minimizing the Number of Internal States in Incompletely Specified Sequential Networks. </title> <journal> IEEE Transactions on Electronic Computers, </journal> <pages> pages 350-359, </pages> <month> June </month> <year> 1965. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 110 The problem is analogous to the state minimization of deterministic finite state machines, which finds a minimum-state deterministic machine whose behavior is contained in a given deterministic finite state machine <ref> [1, 23, 24, 40, 44] </ref>. Our problem is more general in that a given machine is non-deterministic. We also need to take into account the implementability of a behavior. As shown in Section 4.6, the E-machine has a special type of non-deterministic finite state machine called a pseudo non-deterministic machine. <p> Specifically, it is a subproblem of the case where a given machine is a general non-deterministic machine, and is a generalization of the case where a given machine is deterministic. The research for the deterministic case has been done extensively <ref> [1, 23, 24, 40, 44] </ref>, while little has been done for the non-deterministic case. In the following section, we present a theoretical analysis of the state minimization of pseudo non-deterministic machines, in which we show how the basic concepts developed for the deterministic case can be generalized for the problem. <p> This problem is a 0-1 integer linear programming problem. Note the similarities of this formulation with the conventional approaches for the state minimization of deterministic machines <ref> [24] </ref>. The second condition above corresponds to the closure constraint, i.e. if an element c i is chosen, then at least one element implied by c i must also be chosen for each input u.
Reference: [25] <author> S. J. Hong, R. G. Cain, and D. L. Ostapko. </author> <title> MINI: A Heuristic Approach for Logic Minimization. </title> <journal> IBM J. Res. Develop., </journal> <pages> pages 443-458, </pages> <month> September </month> <year> 1974. </year>
Reference-contexts: This problem is called the minimization of relations , and is a generalization of the minimization of functions, which has been fully investigated <ref> [8, 25, 34] </ref>. In this chapter, we consider the general case where an input variable of a function may assume more than two values. We present a heuristic procedure for the problem, which is analogous to Espresso [8], a well-developed heuristic approach for minimizing functions. <p> Research in logic minimization has been active over the past 40 years. Initial research was directed towards developing techniques to produce an optimum sum-of-products expression of a Boolean function under don't care conditions [34], and has evolved toward heuristic approaches for designing programmable logic arrays (PLA's) <ref> [8, 25] </ref>. A Boolean function with don't care conditions is called an incompletely specified Boolean function, and the problem above is sometimes referred to as the two-level minimization of incompletely specified Boolean functions. <p> Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . As we will see later, the minimization of functions is a simpler problem than the minimization of relations. Furthermore, a number of methods for function minimization exist (e.g. <ref> [10, 16, 25, 34, 45, 47] </ref>). Therefore, if this is the case, we invoke one of the conventional procedures for minimizing functions to obtain a minimal implementation of the given relation R.
Reference: [26] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: only if S D n = f& n 2 S N j 9& p 2 S D p : T N (& p ; u; v; & n ) = 1g and 62 S D n (4.2) This construction is the subset construction, or determinization, of a non-deterministic finite automaton <ref> [26] </ref>, where the state is the unique non-accepting state, meaning that a string which can lead the automaton to is not accepted. Only subsets, generated in the subset construction, which do not contain are allowed next-state subsets.
Reference: [27] <author> D. Huffman. </author> <title> The Synthesis of Sequential Switching Circuits. </title> <journal> Journal of Franklin Institute, </journal> <volume> Vol. 257 </volume> <pages> 161-190, 275-303, </pages> <year> 1954. </year> <note> Also in E. </note> <editor> Moore, editor, </editor> <title> Sequential Machines selected papers. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1964. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> For a given initial state, a set of equivalent states can be computed as a function E : S fi S ! B such that E (n; n) = 1 if and only if n and n are equivalent <ref> [27, 38] </ref>. Since a state can be mapped to any of the equivalent states of the next state, we have the possibility of implementing a more compact machine using the equivalent states. <p> Lemma 5.3.2 For a completely specified deterministic finite state machine M , suppose that there is no equivalent pair of distinct states in M . Then the number of states of M is minimum over all machines representing the behavior given by M . Proof: See <ref> [27] </ref>, [38], or [30]. CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 121 Lemma 5.3.3 For any behavior B contained in a given pseudo non-deterministic finite state machine T , there exists a feasible machine whose number of states is minimum among all machines representing B.
Reference: [28] <author> T. Kam, T. Villa, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A Fully Implicit Algorithm for Exact State Minimization. </title> <booktitle> In 31st ACM/IEEE Design Automation Conference, </booktitle> <year> 1994. </year>
Reference-contexts: As stated in Section 5.4.3, the problem is reduced to a class of 0-1 integer linear programming problems, and the current implementation solves it using a method proposed in <ref> [28] </ref>. We applied the exact procedure for the same examples and compared CHAPTER 5.
Reference: [29] <author> J. Kim and M. Newborn. </author> <title> The Simplification of Sequential Machines with Input Restrictions. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-21:1440-1443, </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 4 Chapter 4 considers the problem of finding the maximum set of permissible behaviors at a given component. The definition of the set is same as the combinational case, except that a behavior here is now sequential. Although extensive research has been done for the problem <ref> [18, 29, 43, 56] </ref>, no method is known on how to capture the complete degree of freedom. We claim that the complete set of permissible sequential behaviors of a given component can be computed and represented by a single non-deterministic finite state machine, which we call the E-machine. <p> This is the central problem of factorization and decomposition of finite state machines, and is similar to the rectification problem above. 4.1.3 Related Work The problem of finding a set of permissible behaviors for interacting finite state machines has been studied previously <ref> [18, 29, 43, 56, 59] </ref>. Most results, following analogies from the combinational logic case, are based on don't care sequences. For example, input don't care sequences are sequences of inputs of M 1 which never occur. <p> work either makes an assumption on the topology of M 1 and M 2 , such as cascaded machines where M 2 is independent of M 1 , restricts to computing only a subset of don't care sequences, or computes input don't care sequences and output don't care sequences separately <ref> [18, 29, 43, 59] </ref>. Furthermore, due to complexity, often the sequences are only partially considered, up to a certain, typically small, length.
Reference: [30] <author> Z. Kohavi. </author> <title> Switching and Finite Automata Theory. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, </address> <year> 1970. </year>
Reference-contexts: Lemma 5.3.2 For a completely specified deterministic finite state machine M , suppose that there is no equivalent pair of distinct states in M . Then the number of states of M is minimum over all machines representing the behavior given by M . Proof: See [27], [38], or <ref> [30] </ref>. CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 121 Lemma 5.3.3 For any behavior B contained in a given pseudo non-deterministic finite state machine T , there exists a feasible machine whose number of states is minimum among all machines representing B.
Reference: [31] <author> L. Lavagno, S. Malik, R. K. Brayton, and A. Sangiovanni-Vincentelli. MIS-MV: </author> <title> Optimization of Multi-level Logic with Multiple-valued Inputs. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <year> 1990. </year>
Reference-contexts: In parallel with this activity has been the minimization of multiple-valued functions <ref> [31, 47] </ref>, in which variables can assume more than two discrete values. The significance of this problem is in its applications in areas such as PLA optimization [45] and state assignment for finite CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 36 state machines [17].
Reference: [32] <author> B. Lin and F. Somenzi. </author> <title> Minimization of Symbolic Relations. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: This aspect will be detailed later in Section 3.3. Also, a Boolean relation is a special case of the type of relations considered here, and thus our problem subsumes the problem of minimizing Boolean relations. Multiple-valued relations arise in many contexts <ref> [6, 11, 32] </ref>, besides the local optimizations of multi-level combinational logic circuits considered in Chapter 2. <p> Namely, our objective is to minimize the multiple-valued relation F . If the number of symbolic product terms is the cost function used, then the problem is reduced to the relation minimization focused in this chapter. Other applications of multiple-valued as well as Boolean relations can be found in <ref> [11, 32] </ref>. Example 3.2.2 The case where the use of equivalent states results in a representation with less cost is illustrated in the following example. Suppose that a completely specified deterministic finite state machine is given as shown in Figure 3.2. <p> Once h (y) is computed, a maximally reduced cube with the minimum number of 1's is obtained efficiently. In fact, the following theorem is analogous to a result of a BDD based approach for a covering problem <ref> [32] </ref>. <p> It is known that such a minterm is given by a shortest path from the root of the BDD representing L to a terminal node with a label 1 in the BDD <ref> [32] </ref>, where a weight of 1 (a unit weight) is assigned to every edge with a label 1 while the edges with label 0 have no weight. A shortest path of a BDD can be computed in linear time in the number of nodes of the BDD.
Reference: [33] <author> H. Mathony. </author> <title> Universal Logic Design Algorithm and its Application to the Synthesis of Two-level Switching Circuits. </title> <booktitle> IEE Proceedings, </booktitle> <volume> 136 Pt. E(3), </volume> <month> May </month> <year> 1989. </year> <note> BIBLIOGRAPHY 155 </note>
Reference-contexts: This problem is known as a covering problem, and our procedure finds a solution using a method proposed in <ref> [33] </ref>.
Reference: [34] <author> E. J. McCluskey Jr. </author> <title> Minimization of Boolean Functions. </title> <journal> Bell System Technical Journal, </journal> <volume> Vol. 35 </volume> <pages> 1417-1444, </pages> <month> November </month> <year> 1956. </year>
Reference-contexts: This problem is called the minimization of relations , and is a generalization of the minimization of functions, which has been fully investigated <ref> [8, 25, 34] </ref>. In this chapter, we consider the general case where an input variable of a function may assume more than two values. We present a heuristic procedure for the problem, which is analogous to Espresso [8], a well-developed heuristic approach for minimizing functions. <p> This problem is generally referred to as logic minimization. Research in logic minimization has been active over the past 40 years. Initial research was directed towards developing techniques to produce an optimum sum-of-products expression of a Boolean function under don't care conditions <ref> [34] </ref>, and has evolved toward heuristic approaches for designing programmable logic arrays (PLA's) [8, 25]. A Boolean function with don't care conditions is called an incompletely specified Boolean function, and the problem above is sometimes referred to as the two-level minimization of incompletely specified Boolean functions. <p> Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . As we will see later, the minimization of functions is a simpler problem than the minimization of relations. Furthermore, a number of methods for function minimization exist (e.g. <ref> [10, 16, 25, 34, 45, 47] </ref>). Therefore, if this is the case, we invoke one of the conventional procedures for minimizing functions to obtain a minimal implementation of the given relation R.
Reference: [35] <author> G. Mealy. </author> <title> A Method for Synthesizing Sequential Circuits. </title> <type> Technical Report J. 34, </type> <institution> Bell System Tech., </institution> <year> 1955. </year>
Reference-contexts: Each component of the system now implements a sequential logic behavior, i.e. a function between the input sequences and the output sequences of the component. Under the assumption of synchronous systems, the behavior can be represented by a finite state machine <ref> [35] </ref>. Therefore, the entire system can be regarded as one in which a number of finite state machines are mutually interacting. CHAPTER 1. INTRODUCTION 4 Chapter 4 considers the problem of finding the maximum set of permissible behaviors at a given component. <p> Otherwise, it is called a Mealy machine <ref> [35] </ref>. Note that the function of a Moore machine depends only on the states S and not on the inputs B jIj . A finite state machine that is not deterministic is said to be non-deterministic .
Reference: [36] <editor> Merrian Webster's Collegiate Dictionary. Merrian-Webster, </editor> <publisher> Inc., </publisher> <address> tenth edition, </address> <year> 1993. </year>
Reference-contexts: Introduction 1.1 Optimization of Interacting Components A system is a regularly interacting or interdependent group of items forming a unified whole <ref> [36] </ref>. It is common that each item, or component, has some flexibility in its function. Namely, one may alter the function of the component while preserving the behavior of the entire system. Such flexibility, associated with internal components, is the subject of this thesis.
Reference: [37] <author> J. Millman. </author> <title> Microelectronics: Digital and Analog Circuits and Systems. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1979. </year>
Reference-contexts: Although a circuit with a combinational loop might be acceptable, it is known that such a circuit could cause an unexpected problem called race-around condition <ref> [37] </ref>, and thus it is still very rare to find such a circuit in practical synchronous digital designs. Therefore, we exclude this situation and consider only the machines that can be implemented at M 1 without introducing combinational loops. Specifically, we define implementable machines as follows.
Reference: [38] <author> E. Moore. </author> <title> Gedanken-experiments on Sequential Machines. </title> <editor> In C. Shannon and J. McCarthy, editors, </editor> <title> Automata Studies. </title> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> For a given initial state, a set of equivalent states can be computed as a function E : S fi S ! B such that E (n; n) = 1 if and only if n and n are equivalent <ref> [27, 38] </ref>. Since a state can be mapped to any of the equivalent states of the next state, we have the possibility of implementing a more compact machine using the equivalent states. <p> Note that at each state, the output sequence and the state transition defined at the state by a given input sequence are unique for a completely specified deterministic machine. A deterministic finite state machine (I ; O; S; ; ffi; r) is called a Moore machine <ref> [38] </ref> if for each state s p 2 S, there exists a unique o 2 f0; 1; flg jOj such that for all i 2 B jIj , (s p ; i) = o. Otherwise, it is called a Mealy machine [35]. <p> We also propose a heuristic approach for the state minimization of pseudo nondeterministic finite state machines. This procedure has been implemented with a restriction that we focus only on Moore behaviors <ref> [38] </ref>, behaviors where the outputs depend only on the internal states of machines, and not on the inputs. The restriction was made in order to guarantee that the resulting behavior is implementable. <p> Lemma 5.3.2 For a completely specified deterministic finite state machine M , suppose that there is no equivalent pair of distinct states in M . Then the number of states of M is minimum over all machines representing the behavior given by M . Proof: See [27], <ref> [38] </ref>, or [30]. CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 121 Lemma 5.3.3 For any behavior B contained in a given pseudo non-deterministic finite state machine T , there exists a feasible machine whose number of states is minimum among all machines representing B. <p> One compromise to avoid this additional difficulty on the implementability is to restrict attention to Moore behaviors only. Recall that for Moore behaviors, the outputs depend only on the internal states and not on the inputs <ref> [38] </ref>. Therefore, it is possible to implement a Moore behavior so that there is no combinational path from the inputs to the outputs. <p> As stated earlier, we use a BDD to represent the transition relation of a given pseudo non-deterministic machine T , where a single Boolean variable is used for each state. The implementation is restricted so that it only finds a behavior that can be represented by a Moore machine <ref> [38] </ref>, i.e. the output function of the machine depends only on the present states of the machine and not on the inputs. There are two reasons for this restriction.
Reference: [39] <author> S. Muroga, Y. Kambayashi, C. H. Lai, and J. N. Culliney. </author> <title> The Transduction Method Design of Logic Networks based on Permissible Functions. </title> <journal> IEEE Transactions of Computers, </journal> <year> 1989. </year>
Reference-contexts: Specifically, each chapter is organized as follows. Chapter 2 deals with the case where each component implements a Boolean function with multiple inputs and multiple outputs. Although extensive research has been made for the problem of finding permissible behaviors for combinational logic with a single output <ref> [3, 39, 50] </ref>, little has been done for the case of multiple outputs. In this chapter, we first discuss the problem of finding the maximum set of permissible behaviors for a given component. <p> A procedure for computing such a set was proposed by Savoj [48]. We first review the work, and then focus on another kind of permissible behaviors called a compatible set of permissible behaviors <ref> [39] </ref>. Unlike the maximum set, a compatible set of permissible behaviors is computed for every component of the system, and has the property that an arbitrary combination of behaviors of the sets over the components results in a desired behavior on the entire system. <p> The notion of compatible sets was first introduced by Muroga et. al <ref> [39] </ref> for the case where each node of the network implements a single-output NOR gate, along with a procedure to compute such sets. Savoj proposed a method for a more general case where, instead of a NOR gate, a node may implement an arbitrary single-output Boolean function [49].
Reference: [40] <author> M. Paull and S. Unger. </author> <title> Minimizing the Number of States in Incompletely Specified Sequential Switching Functions. </title> <journal> IRE Transactions on Electronic Computers, </journal> <pages> pages 356-367, </pages> <month> September </month> <year> 1959. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 110 The problem is analogous to the state minimization of deterministic finite state machines, which finds a minimum-state deterministic machine whose behavior is contained in a given deterministic finite state machine <ref> [1, 23, 24, 40, 44] </ref>. Our problem is more general in that a given machine is non-deterministic. We also need to take into account the implementability of a behavior. As shown in Section 4.6, the E-machine has a special type of non-deterministic finite state machine called a pseudo non-deterministic machine. <p> Specifically, it is a subproblem of the case where a given machine is a general non-deterministic machine, and is a generalization of the case where a given machine is deterministic. The research for the deterministic case has been done extensively <ref> [1, 23, 24, 40, 44] </ref>, while little has been done for the non-deterministic case. In the following section, we present a theoretical analysis of the state minimization of pseudo non-deterministic machines, in which we show how the basic concepts developed for the deterministic case can be generalized for the problem. <p> This condition is analogous to the closure constraint defined for the deterministic case <ref> [40] </ref>. CHAPTER 5. <p> The notion of compatible sets are defined for pseudo non-deterministic machines, which is analogous to the notion of compatible sets introduced for deterministic machines <ref> [40] </ref>. 5.4.1 Finding an Optimum Contained Behavior The problem we address in this section is the state minimization of a pseudo nondeterministic machine T , i.e. find a behavior represented by a completely specified deterministic finite state machine with the minimum number of states over all the behaviors contained in T
Reference: [41] <author> R. Puri and J. Gu. </author> <title> An Efficient Algorithm to Search for Minimal Closed Covers in Sequential Machines. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <pages> pages 737-745, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized.
Reference: [42] <author> P. Ramadge and W. Wonham. </author> <title> Supervisory Control of a Class of Discrete Event Processes. </title> <journal> SIAM Journal of Control and Optimization, </journal> <volume> Vol. 25(No. </volume> 1):206-230, January 1987. 
Reference-contexts: Another related problem is a supervisory control problem for discrete event processes <ref> [42] </ref>. The problem is that for a given generator of discrete events (M 1 ) and a specification on the generated events (M ), we observe the events provided by the generator and control them (M 2 ) by feeding CHAPTER 4.
Reference: [43] <author> J. Rho, G. D. Hachtel, and F. Somenzi. </author> <title> Don't Care Sequences and the Optimization of Interacting Finite State Machines. </title> <booktitle> In International Workshop on Logic Synthesis, </booktitle> <year> 1991. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 4 Chapter 4 considers the problem of finding the maximum set of permissible behaviors at a given component. The definition of the set is same as the combinational case, except that a behavior here is now sequential. Although extensive research has been done for the problem <ref> [18, 29, 43, 56] </ref>, no method is known on how to capture the complete degree of freedom. We claim that the complete set of permissible sequential behaviors of a given component can be computed and represented by a single non-deterministic finite state machine, which we call the E-machine. <p> This is the central problem of factorization and decomposition of finite state machines, and is similar to the rectification problem above. 4.1.3 Related Work The problem of finding a set of permissible behaviors for interacting finite state machines has been studied previously <ref> [18, 29, 43, 56, 59] </ref>. Most results, following analogies from the combinational logic case, are based on don't care sequences. For example, input don't care sequences are sequences of inputs of M 1 which never occur. <p> work either makes an assumption on the topology of M 1 and M 2 , such as cascaded machines where M 2 is independent of M 1 , restricts to computing only a subset of don't care sequences, or computes input don't care sequences and output don't care sequences separately <ref> [18, 29, 43, 59] </ref>. Furthermore, due to complexity, often the sequences are only partially considered, up to a certain, typically small, length.
Reference: [44] <author> J. Rho, G. D. Hachtel, F. Somenzi, and R. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Machines. </title> <booktitle> In European Conference on Design Automation, </booktitle> <year> 1991. </year>
Reference-contexts: This is a generalization of the problem known as the state minimization, or the state reduction, of deterministic finite state machines, for which the research is well-matured <ref> [1, 23, 24, 27, 38, 40, 41, 44] </ref>. The chapter first presents a theoretical analysis, where we consider how the conventional concepts developed for deterministic machines can be generalized. <p> CHAPTER 5. MINIMIZATION OF PSEUDO NON-DETERMINISTIC FSM'S 110 The problem is analogous to the state minimization of deterministic finite state machines, which finds a minimum-state deterministic machine whose behavior is contained in a given deterministic finite state machine <ref> [1, 23, 24, 40, 44] </ref>. Our problem is more general in that a given machine is non-deterministic. We also need to take into account the implementability of a behavior. As shown in Section 4.6, the E-machine has a special type of non-deterministic finite state machine called a pseudo non-deterministic machine. <p> Specifically, it is a subproblem of the case where a given machine is a general non-deterministic machine, and is a generalization of the case where a given machine is deterministic. The research for the deterministic case has been done extensively <ref> [1, 23, 24, 40, 44] </ref>, while little has been done for the non-deterministic case. In the following section, we present a theoretical analysis of the state minimization of pseudo non-deterministic machines, in which we show how the basic concepts developed for the deterministic case can be generalized for the problem. <p> Namely, in Figure 5.1, we chose two finite state machines, one for M 1 and the other for M 2 . These are completely specified deterministic machines. We minimized M 1 in the number of states using an exact method for deterministic machines, similar to the one proposed in <ref> [44] </ref>. Thus, M 1 was originally made optimum in terms of the number of states without taking into account the interaction with M 2 . Therefore, the number of states of M 1 is the optimum number of states required to represent the behavior given by M 1 .
Reference: [45] <author> R. L. Rudell and A. Sangiovanni-Vincentelli. </author> <title> Multiple-Valued Minimization for PLA Optimization. </title> <journal> IEEE Transaction on Computer Aided Design of Integrated Circuits and Systems, </journal> <volume> Vol. CAD-6(No. 6):727 - 750, </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: In parallel with this activity has been the minimization of multiple-valued functions [31, 47], in which variables can assume more than two discrete values. The significance of this problem is in its applications in areas such as PLA optimization <ref> [45] </ref> and state assignment for finite CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 36 state machines [17]. In this chapter, we assume that a given relation is in general a multiple-valued relation, in the sense that the input variables can take multiple (more than two) values. <p> CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 38 3.2 Preliminaries We describe the relationship among functions and relations, and see when a procedure is needed for minimizing relations directly. 3.2.1 Terminology We follow references <ref> [8, 11, 45] </ref> for most of the terminology used throughout this chapter. Definition: Multiple-Valued Relation A multiple-valued relation R is a subset of D fi B m . <p> Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . As we will see later, the minimization of functions is a simpler problem than the minimization of relations. Furthermore, a number of methods for function minimization exist (e.g. <ref> [10, 16, 25, 34, 45, 47] </ref>). Therefore, if this is the case, we invoke one of the conventional procedures for minimizing functions to obtain a minimal implementation of the given relation R. <p> If the relation is an incompletely specified function, we convert the F (j) 's, P (j) 's, and D (j) 's to some required form, e.g. sum-of-products form, and invoke a conventional minimizer for ordinary logic functions, e.g. ESPRESSO-MV <ref> [45] </ref>. <p> Experiments were performed with several ordering strategies. Although the results varied slightly with different orderings, none was always better than another. As in the case of the minimization of functions <ref> [45] </ref>, the final results seemed to be independent of the ordering strategies in general. <p> An expansion is an operation which takes a cube c and returns a cube c c. The expansion is valid if the replacement of c with c results in a compatible representation. The result of the procedure is order dependent and we sort the cubes, as in ESPRESSO-MV <ref> [45] </ref>, in increasing order of the weights, where the weight of a cube is defined as the number of parts at which the cube has 1. CHAPTER 3. <p> The smallest cube containing both c and p, denoted as c, is obtained by taking the part-wise union between c and p <ref> [45] </ref>. <p> The system computes an initial representation if not given externally. Once the initial representation is verified to be compatible, the proposed procedure is applied. We use the same data structure as ESPRESSO-MV <ref> [45] </ref> to represent sum-of-products expressions. In the EXPAND procedure, employing the techniques introduced in [45], we have implemented the proposed algorithm by directly using a representation F instead of a covering matrix. For comparison with existing techniques, several examples of Boolean relations were tried. <p> The system computes an initial representation if not given externally. Once the initial representation is verified to be compatible, the proposed procedure is applied. We use the same data structure as ESPRESSO-MV <ref> [45] </ref> to represent sum-of-products expressions. In the EXPAND procedure, employing the techniques introduced in [45], we have implemented the proposed algorithm by directly using a representation F instead of a covering matrix. For comparison with existing techniques, several examples of Boolean relations were tried.
Reference: [46] <author> T. Sasao. </author> <title> An Application of Multiple-Valued Logic to a Design of Programmable Logic Arrays. </title> <booktitle> In International Symposium on Multiple Valued Logic, </booktitle> <year> 1978. </year> <note> BIBLIOGRAPHY 156 </note>
Reference-contexts: 0, 1), (0, 1, 0, 0)g 01 f (1, 2), (1, 3)g 01 f (0, 0, 0, 1), (0, 0, 1, 0), (0, 0, 1, 1)g Table 3.4: The Log-Based Encoding of a Relation with Multiple-Valued Outputs 3.3.2 Transformation of Multiple Outputs to a Multiple-Valued Input It is shown in <ref> [46] </ref> that the two-level minimization problem for an incompletely specified function with multiple-valued inputs and binary-valued outputs can be equivalently handled as the problem of minimizing an incompletely specified function with a single binary output by treating the output part of the original function as 1-hot encoded variables for a single
Reference: [47] <author> T. Sasao. </author> <title> Input Variable Assignment and Output Phase Optimization of PLA's. </title> <booktitle> In IEEE Transaction on Computers, </booktitle> <month> October </month> <year> 1984. </year>
Reference-contexts: In parallel with this activity has been the minimization of multiple-valued functions <ref> [31, 47] </ref>, in which variables can assume more than two discrete values. The significance of this problem is in its applications in areas such as PLA optimization [45] and state assignment for finite CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 36 state machines [17]. <p> Once these three sets are obtained, the problem is reduced to the conventional minimization for incompletely specified functions . As we will see later, the minimization of functions is a simpler problem than the minimization of relations. Furthermore, a number of methods for function minimization exist (e.g. <ref> [10, 16, 25, 34, 45, 47] </ref>). Therefore, if this is the case, we invoke one of the conventional procedures for minimizing functions to obtain a minimal implementation of the given relation R.
Reference: [48] <author> H. Savoj. </author> <title> Don't Cares in Multi-Level Network Optimization. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Namely, a CHAPTER 1. INTRODUCTION 3 function f is in the set if and only if for all elements x of the input domain, the pair (x; f (x)) is a member of the relation. A procedure for computing such a set was proposed by Savoj <ref> [48] </ref>. We first review the work, and then focus on another kind of permissible behaviors called a compatible set of permissible behaviors [39]. <p> The claim is that the maximum set can be computed and represented by a Boolean relation, where the relation consists of all possible pairs of input and output values allowed to be realized at the node. A procedure to compute such a relation was presented by Savoj in <ref> [48] </ref>. We first review how a set of functions can be represented by a relation as well as why a relation is necessary to represent such a set. We then consider another type of set of permissible functions called compatible sets.
Reference: [49] <author> H. Savoj and R. K. Brayton. </author> <title> The Use of Observability and External Don't Cares for the Simplification of Multi-Level Networks. </title> <booktitle> In 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Savoj proposed a method for a more general case where, instead of a NOR gate, a node may implement an arbitrary single-output Boolean function <ref> [49] </ref>. Introduced also in [49] is a notion of maximally compatible sets of permissible functions, where compatible sets are maximal if there is no function that can be newly added to any one of the sets without destroying the property of compatibility. <p> Savoj proposed a method for a more general case where, instead of a NOR gate, a node may implement an arbitrary single-output Boolean function <ref> [49] </ref>. Introduced also in [49] is a notion of maximally compatible sets of permissible functions, where compatible sets are maximal if there is no function that can be newly added to any one of the sets without destroying the property of compatibility. <p> CHAPTER 2. PERMISSIBLE LOGIC FUNCTIONS FOR MULTI-OUTPUT COMPONENTS22 2.4.3 An Example We illustrate how the proposed procedure works using the example shown in Figure 2.4. This example was introduced in [15] as a counterexample for which the method of computing compatible sets of permissible functions proposed in <ref> [49] </ref> fails to compute maximal sets. Suppose the clusters have been composed so that every cluster consists of exactly one gate, i.e. there are three clusters u, v, and w. The order of the clusters is given as w &lt; v &lt; u.
Reference: [50] <author> H. Savoj, R. K. Brayton, and H. Touati. </author> <title> Extracting Local Don't Cares for Network Optimization. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: Specifically, each chapter is organized as follows. Chapter 2 deals with the case where each component implements a Boolean function with multiple inputs and multiple outputs. Although extensive research has been made for the problem of finding permissible behaviors for combinational logic with a single output <ref> [3, 39, 50] </ref>, little has been done for the case of multiple outputs. In this chapter, we first discuss the problem of finding the maximum set of permissible behaviors for a given component. <p> Therefore, we compared the results with a method implemented in SIS for computing sets of permissible functions for Boolean networks, where each node has exactly one output and an optimization is made for one node at a time. The method was proposed in <ref> [50] </ref>, and is referred to as full simplify, its command name in SIS.
Reference: [51] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Sequential Circuit Design Using Synthesis and Optimization. </title> <booktitle> In IEEE International Conference on Computer Design, </booktitle> <year> 1992. </year>
Reference-contexts: of s in C creates a cycle if and only if there exists a fanout (or fanin, respectively) of s, say t, such that t is not in C and is a transitive fanin (respectively, transitive fanout) of C. 2.6 Experimental Results The proposed procedure has been implemented in SIS <ref> [51] </ref>, a logic synthesis system for sequential circuits. The procedure takes as input a Boolean network, composes a clustered Boolean network, and computes a set of permissible functions for each cluster.
Reference: [52] <author> T. R. Shiple, R. Hojati, A. Sangiovanni-Vincentelli, and R. K. Brayton. </author> <title> Heuristic Minimization of BDDs Using Don't Cares. </title> <booktitle> In 31st ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Such a set is computed by a BDD operation similar to the one known as generalized cofactor [13], and a detailed description is found in <ref> [52] </ref>. During the computation, we need to see if a given pair of states ( s 2 ; s) 2 S 2 fi S is a member of S p .
Reference: [53] <author> F. Somenzi and R. K. Brayton. </author> <title> An Exact Minimizer for Boolean Relations. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1989. </year>
Reference-contexts: We make a contrast between relations and functions by showing some special properties associated with relations not found in functions. These properties are carefully accounted for in the proposed heuristic procedure to effectively achieve high quality results. The results are compared against the exact method given in <ref> [53] </ref>. Chapter 4 and Chapter 5 perform an analogous investigation for sequential logic behaviors. Each component of the system now implements a sequential logic behavior, i.e. a function between the input sequences and the output sequences of the component. <p> Somenzi and Brayton proposed and implemented an exact minimization procedure for Boolean relations, with which an optimum sum-of-products representation is obtained <ref> [53] </ref>. However, since the method is exact, it is expensive both in CPU time and memory space, so that only small examples can be handled. CHAPTER 3. MINIMIZATION OF MULTIPLE-VALUED RELATIONS 37 Our focus in this chapter is on heuristic minimizations. <p> In the EXPAND procedure, employing the techniques introduced in [45], we have implemented the proposed algorithm by directly using a representation F instead of a covering matrix. For comparison with existing techniques, several examples of Boolean relations were tried. The results are compared with the other two approaches <ref> [22, 53] </ref> developed for Boolean relations, where the programs for both procedures were provided to the authors. Table 3.7 shows the number of the product terms and CPU time (seconds) measured on a DECstation 5000/240 for all three methods. <p> Table 3.7 shows the number of the product terms and CPU time (seconds) measured on a DECstation 5000/240 for all three methods. Exact is the exact procedure <ref> [53] </ref>, Herb is a heuristic approach proposed in [22]. GYOCRO is the proposed approach. GYOCRO performs quite well both in CPU time and results. In fact, among the 18 examples for which the exact minimizer worked, the proposed procedure achieved optimum solutions for 13 examples.
Reference: [54] <author> A. Srinivasan, T. Kam, S. Malik, and R. K. Brayton. </author> <title> Algorithms for Discrete Function Manipulation. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 92-95, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: We represent a relation R by its characteristic function R : D fi B m ! B such that R (x; y) = 1 if and only if (x; y) 2 R. In the implementation, we represent a characteristic function by using an MDD (Multi-valued Decision Diagram) <ref> [54] </ref>. An MDD is a data structure to represent a function with multiple-valued input variables and a single binary output, which employs a BDD [12] as the internal data structure. In the sequel, we make no distinction between a relation and its characteristic function. <p> For some applications, it is useful to define the encodings so that the Boolean union of the product terms over all the values of E j is the universe of the Boolean space spanned by the encoding variables <ref> [54] </ref>. A minterm of E corresponds to the Boolean product of the product terms for the values of the variables of E in . Example 3.3.2 Consider the same relation G used in Example 3.3.1.
Reference: [55] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithm. </title> <booktitle> Society for Industrial and Applied Mathematics, CBMS-NSF Regional Conference Series in Applied Mathematics, </booktitle> <year> 1983. </year>
Reference-contexts: Thus the cycle c exists in G, which conflicts with the fact that G is acyclic. Since the cyclicity of a directed bipartite graph can be checked in polynomial time in the size of the graph <ref> [55] </ref>, we can efficiently check the implementability of M 1 . Note that if either M 1 or M 2 is of Moore type, then G is always acyclic, and M 1 is implementable.
Reference: [56] <author> S. Unger. </author> <title> Flow Table Simplification some useful aids. </title> <journal> IEEE Transactions on Electronic Computers, </journal> <month> June </month> <year> 1965. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 4 Chapter 4 considers the problem of finding the maximum set of permissible behaviors at a given component. The definition of the set is same as the combinational case, except that a behavior here is now sequential. Although extensive research has been done for the problem <ref> [18, 29, 43, 56] </ref>, no method is known on how to capture the complete degree of freedom. We claim that the complete set of permissible sequential behaviors of a given component can be computed and represented by a single non-deterministic finite state machine, which we call the E-machine. <p> This is the central problem of factorization and decomposition of finite state machines, and is similar to the rectification problem above. 4.1.3 Related Work The problem of finding a set of permissible behaviors for interacting finite state machines has been studied previously <ref> [18, 29, 43, 56, 59] </ref>. Most results, following analogies from the combinational logic case, are based on don't care sequences. For example, input don't care sequences are sequences of inputs of M 1 which never occur.
Reference: [57] <author> R. van Glabbeek. </author> <title> The Linear Time Branching Time Spectrum. </title> <editor> In Baeten J. and Klop J., editors, </editor> <booktitle> CONCUR '90, Theories of Concurrency: Unification and Extension, </booktitle> <pages> pages 278-297. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1990. </year> <booktitle> Volume 458 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: However, there is no feasible machine which represents the behavior. 1 In terms of the trace equivalence, this corresponds to the fact that trace equivalence does not coincide with simulation equivalence for non-deterministic finite automata <ref> [57] </ref>. CHAPTER 5.
Reference: [58] <author> J. Vasudevamurthy and J Rajski. </author> <title> A Method for Concurrent Decomposition and Factorization of Boolean Expressions. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <year> 1990. </year> <note> BIBLIOGRAPHY 157 </note>
Reference-contexts: The method was proposed in [50], and is referred to as full simplify, its command name in SIS. The script of the optimization procedures applied for each example is shown in Figure 2.6, where resub -a is an algebraic resubstitution, fx is a procedure <ref> [58] </ref> for extracting kernels, while sweep and eliminate -1 remove constant nodes and nodes with single fanouts. The command br simplify is the proposed procedure, where the option -M specifies the upper bound k on the number of nodes in a single cluster.
Reference: [59] <author> H.-Y. Wang and R. K. Brayton. </author> <title> Input Don't Care Sequences in FSM Networks. </title> <booktitle> In IEEE International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: This is the central problem of factorization and decomposition of finite state machines, and is similar to the rectification problem above. 4.1.3 Related Work The problem of finding a set of permissible behaviors for interacting finite state machines has been studied previously <ref> [18, 29, 43, 56, 59] </ref>. Most results, following analogies from the combinational logic case, are based on don't care sequences. For example, input don't care sequences are sequences of inputs of M 1 which never occur. <p> work either makes an assumption on the topology of M 1 and M 2 , such as cascaded machines where M 2 is independent of M 1 , restricts to computing only a subset of don't care sequences, or computes input don't care sequences and output don't care sequences separately <ref> [18, 29, 43, 59] </ref>. Furthermore, due to complexity, often the sequences are only partially considered, up to a certain, typically small, length.

References-found: 59

