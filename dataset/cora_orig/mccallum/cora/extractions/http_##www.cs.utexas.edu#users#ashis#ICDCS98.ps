URL: http://www.cs.utexas.edu/users/ashis/ICDCS98.ps
Refering-URL: http://www.cs.utexas.edu/users/ashis/papers.html
Root-URL: http://www.cs.utexas.edu
Email: (ashis@cs.utexas.edu) (garg@ece.utexas.edu)  
Title: Addressing False Causality while Detecting Predicates in Distributed Programs  
Author: Ashis Tarafdar Vijay K. Garg 
Address: Austin, TX 78712 Austin, TX 78712  
Affiliation: Dept. of Computer Sciences Dept. of Electrical and Computer Engg. University of Texas at Austin University of Texas at Austin  
Abstract: The partial-order model of distributed computations based on the happened before relation has been criticized for allowing false causality between events. Our strong causality model addresses this problem by allowing multiple local threads of control. This paper addresses the predicate detection problem for the class of weak conjunctive predicates in the strong causality model. We show that, in general, the problem is NP-complete. However, an efficient solution is demonstrated for a useful sub-case. Further, this solution can be used to achieve an exponential reduction in time for solving the general problem. Our predicate detection algorithms can be applied to distributed debugging when processes have independent events, as in multi-threaded processes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: fundamental concepts and mechanisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 4. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction A fundamental problem in distributed systems is that of predicate detection <ref> [1, 6] </ref> detecting whether a global condition occurs while running a distributed program. Its main application is in the testing, debugging and monitoring of distributed programs. <p> Our work builds on the happened-before model [8] by extending the same idea to allow concurrency or independence between events within a local process. We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem <ref> [1, 6] </ref>. Approaches to solving predicate detection are divided into three categories: global snapshot based [2], lattice construction based [4], and predicate restriction based [7] approaches. <p> Our focus will be on an important class of global predicates called conjunctive predicates. These are predicates of the form c = c 1 ^c 2 ^ : : : c n with the usual semantics (i.e., c (G) = c 1 (G <ref> [1] </ref>) ^ c 2 (G [2]) ^ : : : c n (G [n])). <p> Each S k+i for 1 i l contains two states s k+i [j]; (1 j 2), where s k+i <ref> [1] </ref> corresponds to the literal i and s k+1 [2] corresponds to the literal i. Let &lt; s = ;. Define ; as follows. (s i [y]; s j [z]) 2 ;; (i 6= j) iff i [y] = and j [z] = for some variable -.
Reference: [2] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1):63 - 75, </volume> <month> February </month> <year> 1985. </year>
Reference-contexts: We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem [1, 6]. Approaches to solving predicate detection are divided into three categories: global snapshot based <ref> [2] </ref>, lattice construction based [4], and predicate restriction based [7] approaches. The first approach can detect only stable predicates (which remain true once they become true), and the second approach uses the interleaving model of concurrency and, therefore, suffers from the above-mentioned combinatorial explosion. <p> Our focus will be on an important class of global predicates called conjunctive predicates. These are predicates of the form c = c 1 ^c 2 ^ : : : c n with the usual semantics (i.e., c (G) = c 1 (G [1]) ^ c 2 (G <ref> [2] </ref>) ^ : : : c n (G [n])). <p> Each S k+i for 1 i l contains two states s k+i [j]; (1 j 2), where s k+i [1] corresponds to the literal i and s k+1 <ref> [2] </ref> corresponds to the literal i. Let &lt; s = ;. Define ; as follows. (s i [y]; s j [z]) 2 ;; (i 6= j) iff i [y] = and j [z] = for some variable -.
Reference: [3] <author> D. R. Cheriton and D. Skeen. </author> <title> Understanding the limitations of causally and totally ordered communication. </title> <booktitle> In Proc. of the 11th Symp. on Operating System Principles, </booktitle> <pages> pages 44 - 57. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: Predicate detection is usually specified in a model of distributed computation based on a happened-before relation [8], which models the independence of concurrent events on different processes. However, it has been criticized for allowing false causality between events <ref> [3, 11] </ref>. This paper addresses this issue by extending the model and shows how to solve predicate detection in the extended model. Consider running a distributed mutual-exclusion program. The happened-before model of the resulting distributed computation is shown in Figure 1 (i).
Reference: [4] <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 163 - 173, </pages> <address> Santa Cruz, Califor-nia, </address> <year> 1991. </year>
Reference-contexts: We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem [1, 6]. Approaches to solving predicate detection are divided into three categories: global snapshot based [2], lattice construction based <ref> [4] </ref>, and predicate restriction based [7] approaches. The first approach can detect only stable predicates (which remain true once they become true), and the second approach uses the interleaving model of concurrency and, therefore, suffers from the above-mentioned combinatorial explosion.
Reference: [5] <author> C. Fidge. </author> <title> Logical time in distributed computing systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8):28 - 33, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Two states can then be easily checked for their ! relationship by comparing their vector clocks. Since we allow partial orders on each of the processes, we must extend the vector clocks to a vector of partially ordered logical clocks <ref> [5] </ref>. Each such clock value would be an unbounded set in the general case. However, since, in practice, we can place a predefined bound on the number of concurrent threads, we can represent each partially ordered logical clock as a fixed-size vector. <p> The &lt; s relation is a little more involved because we have to decide when two states are independent. In multi-threaded processes, we can keep track of all fork and join points and inter-thread communications through shared memory as described in <ref> [5] </ref>. Although multi-threaded processes are the most direct application of strong causality diagrams, there are other types of independent events that may be identified in processes.
Reference: [6] <author> V. K. Garg. </author> <title> Observation of global properties in distributed systems. </title> <booktitle> In Proceedings of the IEEE International Conference on Software and Knowledge Engineering, </booktitle> <pages> pages 418 - 425, </pages> <address> Lake Tahoe, Nevada, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction A fundamental problem in distributed systems is that of predicate detection <ref> [1, 6] </ref> detecting whether a global condition occurs while running a distributed program. Its main application is in the testing, debugging and monitoring of distributed programs. <p> Our work builds on the happened-before model [8] by extending the same idea to allow concurrency or independence between events within a local process. We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem <ref> [1, 6] </ref>. Approaches to solving predicate detection are divided into three categories: global snapshot based [2], lattice construction based [4], and predicate restriction based [7] approaches.
Reference: [7] <author> V. K. Garg and B. Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3):299 - 307, </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: Next, we present results in solving predicate detection in the strong causality model. We focus on the important class of weak conjunctive predicates which express a large number of important global properties, and which can be solved efficiently in the happened-before model <ref> [7] </ref>. We demonstrate that for general strong causality diagrams, the problem is NP-complete. However, for certain restricted, but useful, classes of strong causality diagrams, the problem may be solved efficiently. <p> We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem [1, 6]. Approaches to solving predicate detection are divided into three categories: global snapshot based [2], lattice construction based [4], and predicate restriction based <ref> [7] </ref> approaches. The first approach can detect only stable predicates (which remain true once they become true), and the second approach uses the interleaving model of concurrency and, therefore, suffers from the above-mentioned combinatorial explosion. <p> We follow the last approach that uses the partial order model and limits itself to classes of predicates which can be detected efficiently. We focus on the important class of weak conjunctive predicates for which an optimal solution was provided for the happened-before model of computation <ref> [7] </ref>. Our work extends this solution to the proposed strong causality model of computation. 3 Model and Problem Definition The usual model of a distributed computation is based on the happened-before relation. <p> that c (G) holds. 4 Solving Conjunctive Predicate De tection in Strong Causality Dia grams The problem of weak conjunctive predicate detection was efficiently (in O (mn 2 ) time, where m is a bound on the number of states in a process) and optimally solved for happened-before diagrams in <ref> [7] </ref>. However, in strong causality diagrams, the problem becomes expectedly harder. In fact, we have: Theorem 1: CPG is NP-complete. <p> The main idea of the algorithm is similar to that used in <ref> [7] </ref> to optimally solve the problem for happened-before diagrams. We start with the lowest global state and move upwards. <p> Two naive exponential solutions are possible. Let m be a bound on jS i j.The first solution enlists every global state and checks if it is consistent, a process which takes O (m n n 2 ) time. The second applies a predicate detection algorithm (such as in <ref> [7] </ref>) to every local linearization of the strong causality diagram, which takes O (m mn mn 2 ) time. However, these solutions do not perform any better for strong causality diagrams which are "close" to being send-ordered or receive-ordered. <p> Further, any global predicate that is only satisfied by a finite set of global states may be expressed (though inefficiently) as a boolean expression of local predicates <ref> [7] </ref>. An example of a global predicate would be detecting if functions on two processes are entered at the same time, violating a required mutual-exclusion property.
Reference: [8] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558 - 565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: Its main application is in the testing, debugging and monitoring of distributed programs. Predicate detection is usually specified in a model of distributed computation based on a happened-before relation <ref> [8] </ref>, which models the independence of concurrent events on different processes. However, it has been criticized for allowing false causality between events [3, 11]. This paper addresses this issue by extending the model and shows how to solve predicate detection in the extended model. Consider running a distributed mutual-exclusion program. <p> This fact has led to a number of studies of such partial order models <ref> [8, 10] </ref>. Our work builds on the happened-before model [8] by extending the same idea to allow concurrency or independence between events within a local process. We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem [1, 6]. <p> This fact has led to a number of studies of such partial order models [8, 10]. Our work builds on the happened-before model <ref> [8] </ref> by extending the same idea to allow concurrency or independence between events within a local process. We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem [1, 6].
Reference: [9] <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <booktitle> In Parallel and Distributed Algorithms: Proc. of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 215 - 226. </pages> <publisher> Elsevier Science Publishers B. V. (North Hol-land), </publisher> <year> 1989. </year>
Reference-contexts: Our extension to the strong causality model allows us to debug distributed programs with multi-threaded processes. The usual practical representation of the happened-before or causally precedes relation, !, has been using vector clocks <ref> [9] </ref>. Two states can then be easily checked for their ! relationship by comparing their vector clocks. Since we allow partial orders on each of the processes, we must extend the vector clocks to a vector of partially ordered logical clocks [5].
Reference: [10] <author> V. Pratt. </author> <title> Modelling concurrency with partial orders. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 15(1):33 - 71, </volume> <year> 1986. </year>
Reference-contexts: This fact has led to a number of studies of such partial order models <ref> [8, 10] </ref>. Our work builds on the happened-before model [8] by extending the same idea to allow concurrency or independence between events within a local process. We are aware of no other study of such an extended happened-before model. Predicate detection is a widely-studied problem [1, 6].
Reference: [11] <author> S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and T. Anderson. Eraser: </author> <title> A dynamic data race detector for multi-threaded programs. </title> <booktitle> In Proc. of the 16th Symp. on Operating System Principles. ACM, </booktitle> <month> October </month> <year> 1997. </year> <note> (To be published). </note>
Reference-contexts: Predicate detection is usually specified in a model of distributed computation based on a happened-before relation [8], which models the independence of concurrent events on different processes. However, it has been criticized for allowing false causality between events <ref> [3, 11] </ref>. This paper addresses this issue by extending the model and shows how to solve predicate detection in the extended model. Consider running a distributed mutual-exclusion program. The happened-before model of the resulting distributed computation is shown in Figure 1 (i).
References-found: 11

