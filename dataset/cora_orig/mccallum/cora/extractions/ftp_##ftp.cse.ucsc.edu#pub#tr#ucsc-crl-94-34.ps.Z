URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-94-34.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: A taxonomy of race conditions.  
Author: D. P. Helmbold, C. E. McDowell 
Note: This work was partially supported by the National Science Foundation grant CCR-9102635.  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California, Santa Cruz  
Date: September 28, 1994  
Pubnum: UCSC-CRL-94-34  
Abstract: Parallel programs are frequently non-deterministic, meaning they can give different results when provided the same input. These different results arise because variations in the timing of the multiple threads cause the threads to access shared resources in different orders. The phenomena that cause the non-deterministic behavior have been (and continue to be) variously referred to as access anomalies, race conditions or just races. In a recent paper, Netzer and Miller made an important contribution to formalizing and standardizing adjectives that can be applied to "races." In this paper we continue this effort by presenting a refined taxonomy for races in parallel programs. The terminology we suggest is not always consistent with that used previously and we describe why we believe our terminology is more descriptive. Categories and Subject Descriptors: D.1.3 [Programming Techniques]: Concurrent Programming, D.2.5 [Software Engineering]: Testing and Debugging Debugging Aids, Tracing Additional Keywords and Phrases: trace analysis, race detection, event ordering 
Abstract-found: 1
Intro-found: 1
Reference: [EP88] <author> P. A. Emrath and D. A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: We currently identify two severity levels, critical and benign. A benign race has no external effect on the results of the program (Padua and Emrath <ref> [EP88] </ref> call this internal non-determinism), while the outcome of a critical race can affect the program's result. Protecting a critical section with locks (mutual exclusion) does not prevent a race, but can make races benign.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> CACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: For our purposes an execution of the program is any ordered list of event beginnings and endings that adheres to the program semantics. Note that different observers might see different execution orders when examining the same run of the program (see <ref> [Lam78] </ref>). This is not a problem as we are primarily interested in the set of all possible executions rather than identifying a single execution associated with a particular run of the program. <p> Two events, e 1 and e 2 , are semi-ordered if e 1 is semi-ordered before e 2 or e 2 is semi-ordered before e 1 . 3 This is a strictly temporal relation and should not be confused with Lamport's causal "happened before" relation <ref> [Lam78] </ref>. 4 3. Ordering properties of Races Definition 7: Two events are unordered if they are neither ordered nor semi-ordered. Definition 8: Two simple statements conflict if they both access the same shared resource and one (or both) of the accesses modifies the resource.
Reference: [NM91] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <journal> SIGPLAN Notices (Proc. PPOPP), </journal> <volume> 26(7) </volume> <pages> 133-144, </pages> <year> 1991. </year>
Reference-contexts: Our general races are similar to unordered races except that they indicate a total lack of synchronization rather than the presence of mutual exclusion. We have borrowed the term "artifact race" from Netzer and Miller <ref> [NM91] </ref>, these races result from other races in the program. In their later paper [NM92] they do not mention artifact races and their definition of general and data races does not include what we now define as artifact races. <p> Although not identical to their earlier definition of "artifact," our definition is intuitively similar and hence our decision to use the same term. An artifact race can never be in the group of "first" races (as defined in <ref> [NM91] </ref>). In particular, an artifact race has the property that the result of some "earlier" race affects the flow of control, preventing an event from being executed.
Reference: [NM92] <author> Robert H.B. Netzer and Barton P. Miller. </author> <title> What are race conditions? Some issues and formalizations. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <pages> pages 74-88, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Netzer and Miller <ref> [NM92] </ref> developed a formal model of races that served as a starting point for our development. Their model includes two orthogonal attributes of races: with attributes general and data on one axis and feasible, apparent, and actual on the other axis. <p> Thus if these are the only assignments to x, then the event "x:=1; test x; y:=0;" must occur concurrently with the event "x:=0; y:=1;" in the other thread. Netzer and Miller's <ref> [NM92] </ref> "data race" is equivalent to the union of both our concurrent races and general races. Specifically they use data race to describe any race where the events do overlap in some execution. Our classification is more specific (i.e. it separates their data 6 4. <p> Our general races are similar to unordered races except that they indicate a total lack of synchronization rather than the presence of mutual exclusion. We have borrowed the term "artifact race" from Netzer and Miller [NM91], these races result from other races in the program. In their later paper <ref> [NM92] </ref> they do not mention artifact races and their definition of general and data races does not include what we now define as artifact races. Although not identical to their earlier definition of "artifact," our definition is intuitively similar and hence our decision to use the same term. <p> The goal of at least one tool [Ste93] is to ignore the unordered races and report only concurrent and/or general races. 4.3 Feasibility Finally we note that previous work in race detection has distinguished between feasible and infeasible races <ref> [NM92] </ref>. This is really a characteristic of the race detection system which results from the need for approximate solutions.
Reference: [Ste93] <author> N. Sterling. </author> <title> WARLOCK a static data race analysis tool. </title> <booktitle> In Proc. Winter Usenix, </booktitle> <pages> pages 97-106, </pages> <year> 1993. </year> <title> End of paper. Total pages = 13. </title>
Reference-contexts: This might not be the case if the two assignment statements were able to execute concurrently (so that both read the original value of x). Unordered races are often benign when they are caused by commutative 4 updates to a shared variable. The goal of at least one tool <ref> [Ste93] </ref> is to ignore the unordered races and report only concurrent and/or general races. 4.3 Feasibility Finally we note that previous work in race detection has distinguished between feasible and infeasible races [NM92].
References-found: 5

