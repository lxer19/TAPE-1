URL: http://www.cs.pitt.edu/~berson/papers/TR95-06.ps
Refering-URL: http://www.cs.pitt.edu/~berson/papers.html
Root-URL: 
Phone: Fax: (412) 624-5249  
Title: A Hierarchical Allocator for Registers in Multiple Issue Architectures  
Author: David A. Berson Rajiv Gupta Mary Lou Soffa 
Date: February 1995  
Address: Pittsburgh Pittsburgh, Pa. 15260  
Affiliation: Computer Science Department University of  
Note: HARE:  
Abstract: Technical Report 95-06 
Abstract-found: 1
Intro-found: 1
Reference: [AEBK94] <author> Wolfgang Ambrosch, M. Anton Ertl, Felix Beer, and Andreas Krall. </author> <title> Dependence-conscious global register allocation. </title> <editor> In Jurg Gutknecht, editor, </editor> <booktitle> Programming Languages and Systems Architecture, </booktitle> <pages> pages 125-136, </pages> <address> Zurich, April 1994. </address> <publisher> Springer LNCS 782. </publisher>
Reference-contexts: Norris and Pollock use a similar interference graph and attempts to reduce register pressure by making some scheduling decisions during register allocation [NP93]. Ambrosch et al. also use a similar interference graph and attempt to select colors to minimize increases in the critical path length due to antidependencies <ref> [AEBK94] </ref>. None of these techniques addresses the selection of values for spilling to minimize the spill code's impact on the program's execution time. We have previously developed URSA as method for simultaneous local register allocation and instruction scheduling in large basic blocks, such as traces [BGS93].
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proc. of Sigplan '89 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <year> 1989. </year>
Reference-contexts: Several enhancements to the basic coloring process have been proposed to reduce the number of spills generated by the coloring process. Briggs suggests several heuristics for simplifying the interference graph to increase the likelihood of coloring the graph without resorting to spilling <ref> [BCKT89] </ref>. Bernstein et al. use a combination of three different priority functions to select values for spilling that will remove the most interferences from the graph [BGM + 89].
Reference: [BCT92] <author> Preston Briggs, Keith D. Cooper, and Linda Torczon. </author> <title> Rematerialization. </title> <booktitle> In Proc. of Sigplan '92 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 311-321, </pages> <year> 1992. </year> <month> 18 </month>
Reference-contexts: Besides spilling values to reduce register demands, HARE also considers rematerialization of values. In addition to the traditional candidates for rematerialization, such as loading constant values and computations using system registers and constants <ref> [BCT92] </ref>, HARE examines the selected instructions and the data dependence graph to identify values that can be recomputed from other values already in registers. As an example, consider the program DAG in Figure 6 (a) and assume that the architecture has three functional units and five registers.
Reference: [BEH91] <author> David G. Bradlee, Susan J. Eggers, and Robert R. Henry. </author> <title> Integrating register allocation and instruction scheduling for RISCs. </title> <booktitle> In Proc. of 4th International Conf. on ASPLOS, </booktitle> <pages> pages 122-131, </pages> <year> 1991. </year>
Reference-contexts: HARE addresses the first problem by using execution counts of regions and the second by performing recursive allocation. The RASE compiler attempts to balance the use of registers by local and global values by computing a cost function for each basic block <ref> [BEH91] </ref>. The cost function estimates the increase in the block's critical path length for a given number of registers. The cost includes a factor of the execution frequency of the block.
Reference: [Ber95] <author> David A. Berson. </author> <title> Integration of Register Allocation, Instruction Scheduling, and Parallelizing Transformations for Fine Grain Parallel Architectures. </title> <type> PhD thesis, </type> <institution> University of Pittsburgh, </institution> <year> 1995. </year> <note> (in preparation). </note>
Reference-contexts: There are several possible methods for estimating the impact of a reduction transformation on the length of the critical path. Due to space constraints, in this paper we present only a simple estimation technique. More advanced techniques are described elsewhere <ref> [Ber95] </ref>. The estimation technique determines the execution time of all spill code introduced and compares it to the total time of the availability of the functional units used to perform the spilling or rematerialization. An outline of the estimation algorithm is shown in Figure 8. <p> In this way the spill code may be distributed in all regions that have available functional units. More advanced estimation techniques consider the functional unit holes usable by each instruction, instead of assuming all holes in the region can be used by any instruction <ref> [Ber95] </ref>. Consider region 1 in Figure 5 (a) and the corresponding code in Figure 7 (a).
Reference: [BGM + 89] <author> David Bernstein, Martin C. Golumbic, Yashay Mansour, Ron Y. Pinter, Dina Q. Goldin, Hugo Krawczyk, and Itai Nahshon. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <booktitle> In Proc. of Sigplan '89 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 258-263, </pages> <year> 1989. </year>
Reference-contexts: Briggs suggests several heuristics for simplifying the interference graph to increase the likelihood of coloring the graph without resorting to spilling [BCKT89]. Bernstein et al. use a combination of three different priority functions to select values for spilling that will remove the most interferences from the graph <ref> [BGM + 89] </ref>. Although the original proposed priority function included an execution estimate factor in the computation of the cost of a spill, most subsequent methods have favored a factor using the loop nesting depth instead.
Reference: [BGS93] <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. </author> <title> URSA: A Unified ReSource Allocator for registers and functional units in VLIW architectures. </title> <booktitle> In Proc. of IFIP WG 10.3 Working Conference on Architectures and Compliation Techniques for Fine and Medium Grain Parallelism, </booktitle> <pages> pages 243-254, </pages> <year> 1993. </year> <note> (also available as University of Pittsburgh Computer Science Department Technical Report 92-21). </note>
Reference-contexts: The result is the register allocator may make poor choices in determining what values should be spilled. HARE is a part of a fully integrated register allocator and instruction scheduler, URSA, for multiple issue load/store architectures <ref> [BGS93] </ref>. URSA allocates registers and functional units simultaneously to avoid interactions between register allocation and instruction scheduling that negatively impact the execution time. In addition, URSA performs global code motion that takes the availability of all required resources into account [BGS94]. <p> None of these techniques addresses the selection of values for spilling to minimize the spill code's impact on the program's execution time. We have previously developed URSA as method for simultaneous local register allocation and instruction scheduling in large basic blocks, such as traces <ref> [BGS93] </ref>. URSA measures a block's requirements for each resource and then reduces the locations that require more resources than the architecture provides. Resource Spackling improved the reductions used and integrated a local register allocator with global code motions [BGS94]. <p> The allocation phase is a hierarchical application of the previously developed Measure and Reduce paradigm <ref> [BGS93] </ref>. The primary task of the allocation phase is placement of spill code to minimize the execution time of the program. The assignment phase hierarchically assigns registers to the values computed. In addition, the assignment phase inserts register copy instructions. <p> The allocation chains are used to identify the excessive sets and resource holes. The reduction of resource demands exceeding the level provided by the architecture is accomplished by moving instructions from excessive sets to resource holes. Details of this process are described in previous work <ref> [BGS93, BGS94] </ref>. As an example, consider the code segment in Figure 2 (a). Figures 2 (b) and 2 (c) display the data and control dependence graphs, respectively. The Reuse DAG and schedule for the functional units in region 1 are shown in Figures 3 (a) and 3 (b).
Reference: [BGS94] <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Resource Spackling: A framework for integrating register allocation in local and global schedulers. </title> <booktitle> In Proc. of IFIP WG 10.3 Working Conference on Parallel Architectures and Compilation Techniques, </booktitle> <pages> pages 135-146, </pages> <year> 1994. </year> <note> (also available as University of Pittsburgh Computer Science Department Technical Report 94-09). </note>
Reference-contexts: URSA allocates registers and functional units simultaneously to avoid interactions between register allocation and instruction scheduling that negatively impact the execution time. In addition, URSA performs global code motion that takes the availability of all required resources into account <ref> [BGS94] </ref>. In this paper we present the global allocation and assignment of registers in URSA. HARE uses the Global Unified Resource Requirements Representation (GURRR), an extension of the PDG that identifies areas where resources such as registers and functional units are over-utilized and under-utilized [BGS95]. <p> URSA measures a block's requirements for each resource and then reduces the locations that require more resources than the architecture provides. Resource Spackling improved the reductions used and integrated a local register allocator with global code motions <ref> [BGS94] </ref>. In GURRR the resource requirements information is combined with a PDG to enable techniques such as HARE, as well as the integration of resource allocation with parallelizing transformations. 4 3 Overview of HARE HARE consists of separate phases for the allocation and assignment of registers. <p> The allocation chains are used to identify the excessive sets and resource holes. The reduction of resource demands exceeding the level provided by the architecture is accomplished by moving instructions from excessive sets to resource holes. Details of this process are described in previous work <ref> [BGS93, BGS94] </ref>. As an example, consider the code segment in Figure 2 (a). Figures 2 (b) and 2 (c) display the data and control dependence graphs, respectively. The Reuse DAG and schedule for the functional units in region 1 are shown in Figures 3 (a) and 3 (b).
Reference: [BGS95] <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. GURRR: </author> <title> A global unified resource requirements representation. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations, Sigplan Notices, </booktitle> <volume> volume 30, </volume> <pages> pages 23-34, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: In this paper we present the global allocation and assignment of registers in URSA. HARE uses the Global Unified Resource Requirements Representation (GURRR), an extension of the PDG that identifies areas where resources such as registers and functional units are over-utilized and under-utilized <ref> [BGS95] </ref>. Candidates for spilling are identified by examining the locations where registers are over-utilized. <p> The ability to measure resource requirements is provided by the Global Unified Resource Requirements Representation (GURRR) <ref> [BGS95] </ref>. GURRR is an extended form of the program dependence graph (PDG) that provides resource usage information. The resource usage information includes identification of locations where resources are over-utilized or under-utilized, called excessive sets and resource holes, respectively.
Reference: [CAC + 81] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6(1) </volume> <pages> 47-58, </pages> <year> 1981. </year>
Reference-contexts: Section 3 provides an overview of HARE. Sections 4 and 5 describe the details of the allocation and assignment phases. We summarize the work and make concluding remarks in Section 6. 2 Related Work Traditionally, register allocation is performed by coloring an interference graph <ref> [CAC + 81, Cha82] </ref>. This process assigns colors representing registers to live ranges. When there are insufficient registers available a live range is spilled to memory. Such a live range must be loaded into a register before each use and written back to memory after each definition. <p> The result is that values in loops have a better chance of remaining in registers. This results in spilling pass-thru values, those values that are alive at entry and exit and are not used in a block <ref> [CAC + 81] </ref>. More recently, hierarchical allocation has been extended to PDGs [NP94]. These hierarchical approaches suffer from two problems. First, they only consider one case of placing spills in less frequently executed locations, i.e., outside of loops.
Reference: [CH90] <author> F. Chow and J. Hennessy. </author> <title> Register allocation by priority-based coloring. </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <year> 1990. </year>
Reference-contexts: The motivation is the same as avoiding nested loops, i.e., to place 2 spill code in the least frequently executed locations. Live range splitting was introduced in an effort to reduce the cost of spilling <ref> [CH90, KH93] </ref>. When spilling is required the live range selected for spilling is split into several smaller live ranges. The smaller live ranges are then treated as separate values requiring registers.
Reference: [Cha82] <author> G.J. Chaitin. </author> <title> Register allocation & spilling via graph coloring. </title> <booktitle> In Proc. of ACM Sigplan '82 Symp. on Compiler Construction, </booktitle> <pages> pages 201-207, </pages> <year> 1982. </year>
Reference-contexts: Section 3 provides an overview of HARE. Sections 4 and 5 describe the details of the allocation and assignment phases. We summarize the work and make concluding remarks in Section 6. 2 Related Work Traditionally, register allocation is performed by coloring an interference graph <ref> [CAC + 81, Cha82] </ref>. This process assigns colors representing registers to live ranges. When there are insufficient registers available a live range is spilled to memory. Such a live range must be loaded into a register before each use and written back to memory after each definition.
Reference: [CK91] <author> David Callahan and Brain Koblenz. </author> <title> Register allocation via heirachical graph coloring. </title> <booktitle> In Proc. of Sigplan '91 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <year> 1991. </year>
Reference-contexts: Hierarchical register allocation has been introduced as a method for reducing the number of dynamic memory references <ref> [CK91] </ref>. This technique creates tiles corresponding to basic blocks in the control flow graph. The tiles are colored from the inside out with respect to the nesting of control structures. The result is that values in loops have a better chance of remaining in registers.
Reference: [KH93] <author> Priyadarshan Kolte and Mary Jean Harrold. </author> <title> Load/store range analysis for global register allocation. </title> <booktitle> In Proc. of Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The motivation is the same as avoiding nested loops, i.e., to place 2 spill code in the least frequently executed locations. Live range splitting was introduced in an effort to reduce the cost of spilling <ref> [CH90, KH93] </ref>. When spilling is required the live range selected for spilling is split into several smaller live ranges. The smaller live ranges are then treated as separate values requiring registers.
Reference: [NP93] <author> Cindy Norris and Lori Pollock. </author> <title> A scheduler-sensitive global register allocator. </title> <booktitle> In Proc. of Supercomputing '93, </booktitle> <pages> pages 804-813, </pages> <year> 1993. </year>
Reference-contexts: Pinter has developed the parallel interference graph to represent the additional interferences between live ranges that occur when instructions can be reordered and issued in parallel [Pin93]. Norris and Pollock use a similar interference graph and attempts to reduce register pressure by making some scheduling decisions during register allocation <ref> [NP93] </ref>. Ambrosch et al. also use a similar interference graph and attempt to select colors to minimize increases in the critical path length due to antidependencies [AEBK94]. None of these techniques addresses the selection of values for spilling to minimize the spill code's impact on the program's execution time.
Reference: [NP94] <author> Cindy Norris and Lori L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proc. of Sigplan '94 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 266-277, </pages> <year> 1994. </year>
Reference-contexts: The result is that values in loops have a better chance of remaining in registers. This results in spilling pass-thru values, those values that are alive at entry and exit and are not used in a block [CAC + 81]. More recently, hierarchical allocation has been extended to PDGs <ref> [NP94] </ref>. These hierarchical approaches suffer from two problems. First, they only consider one case of placing spills in less frequently executed locations, i.e., outside of loops. They do not try to place more spills in conditionally executed code and fewer spills in unconditionally executed code.
Reference: [PF92] <author> Todd A. Proebsting and Charles N. Fischer. </author> <title> Probablistic register allocation. </title> <booktitle> In Proc. of Sigplan '92 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 300-310, </pages> <year> 1992. </year>
Reference-contexts: By taking a control dependence based hierarchical view of the program, HARE is able to consider the number of registers desired by entire control structures when deciding how many registers to allocate to a region. 3 Probablistic register allocation takes a different approach to register allocation <ref> [PF92] </ref>. This technique is based on the principle that the probability that a value is still in a register when an instruction needs to use it is roughly inversely proportional to the distance from its definition or last use to the current use.
Reference: [Pin93] <author> Shlomit S. Pinter. </author> <title> Register allocation with instruction scheduling: A new approach. </title> <booktitle> In Proc. of Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 248-257, </pages> <year> 1993. </year> <month> 19 </month>
Reference-contexts: Two recent techniques have considered the impact of multiple issue architectures on the interference graph. Pinter has developed the parallel interference graph to represent the additional interferences between live ranges that occur when instructions can be reordered and issued in parallel <ref> [Pin93] </ref>. Norris and Pollock use a similar interference graph and attempts to reduce register pressure by making some scheduling decisions during register allocation [NP93]. Ambrosch et al. also use a similar interference graph and attempt to select colors to minimize increases in the critical path length due to antidependencies [AEBK94].
References-found: 18

