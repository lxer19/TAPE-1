URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-93-64.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Retargetable Integrated Code Improver  
Author: Manuel E. Benitez Jack W. Davidson 
Abstract: Computer Science Report No. CS-93-64 November 15, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [BD88] <author> M. E. Benitez and J. W. Davidson, </author> <title> A Portable Global Optimizer and Linker, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Symposium on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988, </year> <pages> 329-338. </pages>
Reference-contexts: Alternatively, a well-designed low-level intermediate representation based on register transfer lists (RTL) [DF80] can be manipulated using machine-independent algorithms to perform machine-specific optimizations such as peephole optimization and instruction scheduling effectively. These representations have made highly-retargetable, high-quality code generation a reality, as evidenced by the fact that both vpo <ref> [BD88] </ref>, which has been targeted to more than a dozen different architectures, and the GNU C compiler [Sta89], which has been targeted to more than 20, produce code whose quality meets or exceeds that of many machine-specific optimizing compilers. <p> ... ... r [8]=HI [a]; r [10]=r [10]&lt;<2; loop r [8]=M [r [10]+LO [a]]; PC=loop; ... ... r [1]=M [r [6]+i]&lt;<2; loop r [0]=M [a+r [1]]; PC=loop; ... ... (a) (b) (e) (f) - 4 - the vpo compiler, we reduced the impact of phase ordering problems through phase iteration <ref> [BD88] </ref>. While this technique was partially successful, it cannot guarantee that the registers will be used to perform the transformations that yield the maximum benefits.
Reference: [CFR+91] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. W. Wegman and F. K. Zadeck, </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13, 4, </volume> <month> October </month> <year> 1991, </year> <pages> 451-490. </pages>
Reference-contexts: - 7 - To connect definitions and uses across basic blocks, f functions, which join merging values, and m functions, which represent diverging values, are placed at the entry and exit points of some basic blocks. f functions are the con-uence operators used in the static single assignment (SSA) form <ref> [CFR+91] </ref>. m functions, which we developed specifically to allow the web to quickly find all of the possible uses of an assignment, are essentially f functions for the inverted CFG, where the functions exit block becomes its entry block and all control ow paths are reversed.
Reference: [CH84] <author> F. C. Chow and John Hennessy, </author> <title> Register Allocation by Priority-based Coloring, </title> <booktitle> Proceedings of the ACM SIGPLAN 84 Symposium on Programming Language Design and Implementation, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1984, </year> <pages> 222-232. </pages>
Reference-contexts: 1 Introduction Many retargetable optimizing compilers perform code improvements on fixed, high-level intermediate representations [TSK+83] <ref> [CH84] </ref>. While these representations promote retargetability by allowing much of the optimizer to be machine-independent, they make it difficult to exploit the unique architectural features of each target machine. <p> Thus, the full potential of low-level intermediate representations will not be realized until techniques that give the optimizer more control over register allocation and phase ordering are developed. How does a common register allocation strategy such as priority-based coloring <ref> [CH84] </ref> undermine the ability of a machine-level optimizer to use cost and benefit information? Priority-based register coloring schemes initially allocate values to memory and promote them to registers after all code improvement transformations have been applied. Consider the machine-level code shown in Figure 1 (a), which contains a redundant computation.
Reference: [DF80] <author> J. W. Davidson and C. W. Fraser, </author> <title> The Design and Application of a Retargetable Peephole Optimizer, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2, 2, </volume> <month> April </month> <year> 1980, </year> <pages> 191-202. </pages>
Reference-contexts: While these representations promote retargetability by allowing much of the optimizer to be machine-independent, they make it difficult to exploit the unique architectural features of each target machine. Alternatively, a well-designed low-level intermediate representation based on register transfer lists (RTL) <ref> [DF80] </ref> can be manipulated using machine-independent algorithms to perform machine-specific optimizations such as peephole optimization and instruction scheduling effectively.
Reference: [DF84] <author> J. W. Davidson and C. W. Fraser, </author> <title> Code Selection through Object Code Optimization, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, 4, </volume> <month> October </month> <year> 1984, </year> <pages> 505-526. </pages>
Reference-contexts: Each register and dereference node whose aliases are completely known is connected to the node containing previous set or use of the item and to the node containing the next set or use of the item. Web links replace combiner links in the instruction selection process <ref> [DF84] </ref> and are used to substitute the expression assigned to a register item in place of its first use. If the combination represents an actual instruction on the target machine, it replaces the instructions that formed it.
Reference: [Dav86] <author> J. W. Davidson, </author> <title> A Retargetable Instruction Reorganizer, </title> <booktitle> Proceedings of the ACM SIGPLAN 86 Symposium on Programming Language Design and Implementation, </booktitle> <address> Palo Alto, CA, </address> <month> June </month> <year> 1986, </year> <pages> 234-241. </pages>
Reference-contexts: The subsequent instruction selection phase eliminates the naive code sequences caused by performing code generation via macro expansion of a low-level intermediate language without the benefit of case analysis. The third phase performs global dead variable elimination. Evaluation order determination, also performed at the machine level <ref> [Dav86] </ref>, reduces the number of hardware register needed to assign the pseudo-registers used by the code expander. Instead of transforming the code, the common subexpression elimination, local variable promotion, loop-invariant code motion and induction variable elimination phases describe potential transformations in a transformation directory.
Reference: [KR78] <author> B. W. Kernighan and D. M. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1978. </year>
Reference-contexts: This is done in the vpcc/ntro compiler using the framework illustrated in Figure 3. The machine-independent vpcc front-end translates traditional C source code <ref> [KR78] </ref> into CVM, a high-level intermediate stack-based representation. A code expander performs macro expansion on each CVM opcode to produce target machine code in RTL from. Pseudo-registers are used to hold temporary expression values while all of the local user variables declared in the source code initially reside in memory.
Reference: [Sta89] <author> R. M. Stallman, </author> <title> Using and Porting GNU CC, Free Software Foundation, </title> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: These representations have made highly-retargetable, high-quality code generation a reality, as evidenced by the fact that both vpo [BD88], which has been targeted to more than a dozen different architectures, and the GNU C compiler <ref> [Sta89] </ref>, which has been targeted to more than 20, produce code whose quality meets or exceeds that of many machine-specific optimizing compilers. Low-level intermediate representations make it feasible to operate exclusively at the machine-level, where the cost and benefits of each transformation can be accurately gauged.
Reference: [TSK+83] <author> A. S. Tanenbaum, H. van Staveren, E. G. Keizer and J. W. Stevenson, </author> <title> A Practical Tool Kit for Making Portable Compilers, </title> <journal> Communications of the ACM, </journal> <volume> 26, 9, </volume> <month> September </month> <year> 1983, </year> <pages> 654-660. </pages>
Reference-contexts: 1 Introduction Many retargetable optimizing compilers perform code improvements on fixed, high-level intermediate representations <ref> [TSK+83] </ref> [CH84]. While these representations promote retargetability by allowing much of the optimizer to be machine-independent, they make it difficult to exploit the unique architectural features of each target machine.
References-found: 9

