URL: http://www.cs.indiana.edu/l/www/ftp/pierce/exists.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Bounded Existentials and Minimal Typing  
Author: Giorgio Ghelli Benjamin Pierce 
Date: July 9, 1996  
Abstract: We study an extension of the second-order calculus of bounded quantification, System F , with bounded existential types. Surprisingly, the most natural formulation of this extension lacks the important minimal typing property of F , which ensures that the set of types possessed by a typeable term can be characterized by a single least element. We consider alternative formulations and give an algorithm computing minimal types for the slightly weaker Kernel Fun variant of F .
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Albano, L. Cardelli, and R. Orsini. </author> <title> Galileo: A strongly typed, interactive conceptual language. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(2) </volume> <pages> 230-260, </pages> <year> 1985. </year>
Reference-contexts: This is similar to the treatment of if-then-else in languages with subsumption 8 and with a Top type, such as the Galileo language <ref> [1] </ref>. According to the abstract presentation of the language, the expression if true then 3 else false belongs to the Top type, since both 3 and false are in Top by subsumption.
Reference: [2] <author> Luca Cardelli. </author> <title> An implementation of F &lt;: </title> . <type> Research report 97, </type> <institution> DEC Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Yet another step towards synthesis algorithms that attempt only to be "complete enough" is provided by Cardelli's implementation of F with partial type reconstruction based on mixed-prefix unification <ref> [2] </ref>. Ultimately, this process can go too far, resulting in type systems whose best definition is the behavior of an incomprehensible algorithm. But a large centerground remains to be explored.
Reference: [3] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference-contexts: 1 Introduction F is a typed lambda-calculus combining subtyping and second-order bounded quantification <ref> [4, 5, 7, 3] </ref>. Besides its utility as a vehicle for theoretical investigations, it has come to be seen as a good basis for the design of programming languages incorporating subtyping and polymorphism. <p> This convention allows us to ignore the type and environment formation rules that would otherwise be needed to assure that every type variable in a judgement is bound and that no variable appears twice in the environment. See <ref> [5, 3] </ref> for more detailed presentations of the system. The usual presentation of F is not syntax-directed: given a typing or subtyping statement, there may be different proofs of its validity, and given a term and an environment, there can be proofs of different typings.
Reference: [4] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: 1 Introduction F is a typed lambda-calculus combining subtyping and second-order bounded quantification <ref> [4, 5, 7, 3] </ref>. Besides its utility as a vehicle for theoretical investigations, it has come to be seen as a good basis for the design of programming languages incorporating subtyping and polymorphism. <p> Alternatively, bounded existential types can be provided as a primitive syntactic form <ref> [4] </ref> by extending the grammar of types and terms with the Some, pack, and open constructs, and adding typing and subtyping rules for existentials to those in Appendix B. <p> question we have left open here is whether every term of F with bounded existentials has a finite set of minimal types, and (if so) whether there is a reasonably efficient algorithm for synthesizing these sets. 3 Bounded Existentials in Kernel Fun Cardelli and Wegner's original formulation of bounded quantification <ref> [4] </ref>, actually used a simpler rule for deriving subtyping judgements involving bounded quantifiers: ; AS ` T U (All-Sub-KFun) Although this "equal-bounds rule" seems semantically less natural than the one used in subsequent presentations of F , it yields a system with much simpler syntactic properties, including decidable subtyping [8].
Reference: [5] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: 1 Introduction F is a typed lambda-calculus combining subtyping and second-order bounded quantification <ref> [4, 5, 7, 3] </ref>. Besides its utility as a vehicle for theoretical investigations, it has come to be seen as a good basis for the design of programming languages incorporating subtyping and polymorphism. <p> This convention allows us to ignore the type and environment formation rules that would otherwise be needed to assure that every type variable in a judgement is bound and that no variable appears twice in the environment. See <ref> [5, 3] </ref> for more detailed presentations of the system. The usual presentation of F is not syntax-directed: given a typing or subtyping statement, there may be different proofs of its validity, and given a term and an environment, there can be proofs of different typings. <p> There is a syntax-directed algorithm (summarized by the rules in Appendix C) that discovers the minimal type for any typeable F term by constructing its normal-form derivation <ref> [5] </ref>. <p> If ` A W (where A is a type variable) and W 6= A, then ` (A) W . 6. If ` S T S, then S = T . Proof: The completeness of the syntax-directed subtyping rules for pure F is proved in <ref> [5] </ref>. The extension of this result to the system with existential subtyping is straightforward, since the only new rule, Some-Sub, is syntax-directed on both sides of the . The lemma then follows from the fact that the syntax-directed rules are complete for F sub-typing. <p> If lower (T ) is defined, then ` lower (T ) T . Proof sketch: Routine induction on T . 2 3.1.4 Lemma [Completeness]: The syntax-directed subtyping rules given in Appendix C are complete for Kernel Fun subtyping. Proof sketch: Either by adapting the proof given for F in <ref> [5] </ref>, or by induction on a Kernel Fun proof of ` T U , the interesting case being when the last applied rule is transitivity. 2 3.1.5 Remark: Since the syntax-directed rules are complete for subtyping, we use the notation ` A B for both syntax-directed and ordinary subtyping judgements. 3.1.6 <p> Case Subsumption: ` e : U ` U T By the induction hypothesis, 0 ` e ) U 0 , where ` U 0 U . By Trans, ` U 0 T . 2 3.2 Discussion This proof of completeness is much easier than the one given in <ref> [5] </ref> to show existence of a minimum type and of a set of syntax-directed rules for F . The proof in [5] was based on the definition of a confluent and normalizing rewriting system of F subtyping and typing proofs. <p> By Trans, ` U 0 T . 2 3.2 Discussion This proof of completeness is much easier than the one given in <ref> [5] </ref> to show existence of a minimum type and of a set of syntax-directed rules for F . The proof in [5] was based on the definition of a confluent and normalizing rewriting system of F subtyping and typing proofs. We were able to adopt a simpler approach here for two reasons: 1. In [5] the term rewriting approach allows solving the coherence problem by proving that a semantic interpretation is coherent <p> The proof in <ref> [5] </ref> was based on the definition of a confluent and normalizing rewriting system of F subtyping and typing proofs. We were able to adopt a simpler approach here for two reasons: 1. In [5] the term rewriting approach allows solving the coherence problem by proving that a semantic interpretation is coherent iff it satisfies the equations underlying the rewrite rule; here we are not attempting to address this problem. 15 2. In [5] the main technical problem to be solved was completeness of the <p> In <ref> [5] </ref> the term rewriting approach allows solving the coherence problem by proving that a semantic interpretation is coherent iff it satisfies the equations underlying the rewrite rule; here we are not attempting to address this problem. 15 2. In [5] the main technical problem to be solved was completeness of the subtyping rules. Since the addition of bounded existentials does not complicate the subtype relation in any essential way, we are able here to appeal to [5] for the necessary results about subtyping and concentrate on the much easier problem <p> In <ref> [5] </ref> the main technical problem to be solved was completeness of the subtyping rules. Since the addition of bounded existentials does not complicate the subtype relation in any essential way, we are able here to appeal to [5] for the necessary results about subtyping and concentrate on the much easier problem of analyzing the typing relation.
Reference: [6] <author> G. Ghelli. </author> <title> Recursive types are not conservative over F . In M. </title> <editor> Bezen and J.F. Groote, editors, </editor> <booktitle> Proceedings of thethe International Conference on Typed Lambda Calculi and Applications (TLCA), Utrecht, The Netherlands, number 664 in Lecture Notes in Computer Science, </booktitle> <pages> pages 146-162, </pages> <address> Berlin, March 1993. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: | that Kernel Fun enriched with the "terse formulation" of existential types does not lose the minimum type property | further extends the set of properties enjoyed by Kernel Fun but not by F . (The most important among these is the decidability of subtyping and typing, but see also <ref> [6] </ref>.) Acknowledgements We are grateful for discussions with Mariangiola Dezani, Bob Harper, and the Edinburgh LFCS ML Club. The careful reading of two anonymous referees improved the paper in many places.
Reference: [7] <author> Giorgio Ghelli. </author> <title> Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. </title> <type> PhD thesis, </type> <institution> Universita di Pisa, </institution> <month> March </month> <year> 1990. </year> <type> Technical report TD-6/90, </type> <institution> Dipartimento di Informatica, Universita di Pisa. </institution>
Reference-contexts: 1 Introduction F is a typed lambda-calculus combining subtyping and second-order bounded quantification <ref> [4, 5, 7, 3] </ref>. Besides its utility as a vehicle for theoretical investigations, it has come to be seen as a good basis for the design of programming languages incorporating subtyping and polymorphism. <p> in general, a minimum result type, i.e. a minimum type U such that b U e 1 e 2 is well typed in , and this is a direct consequence of the fact that not every pair of types with a common supertype has a minimum common supertype F (see <ref> [7] </ref>). By contrast, in Kernel Fun every pair of types with a common supertype has a minimum common supertype, and this property implies that, given a typable if b then e 1 else e 2 expression, it is possible to infer its minimum type.
Reference: [8] <author> Giorgio Ghelli. </author> <title> Divergence of F type checking. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 139(1,2):131-162, </address> <year> 1995. </year>
Reference-contexts: There is a syntax-directed algorithm (summarized by the rules in Appendix C) that discovers the minimal type for any typeable F term by constructing its normal-form derivation [5]. Although it fails to terminate on some pathological ill-typed terms <ref> [8, 11] </ref>, the algorithm is easy to implement and has been found to behave well in practice. 2.2 Encoded and Primitive Existentials in F The simplest way to add existential quantifiers to F is to regard them as syntactic sugar for combinations of universal quantifiers, using the standard encoding: Some (AS <p> quantification [4], actually used a simpler rule for deriving subtyping judgements involving bounded quantifiers: ; AS ` T U (All-Sub-KFun) Although this "equal-bounds rule" seems semantically less natural than the one used in subsequent presentations of F , it yields a system with much simpler syntactic properties, including decidable subtyping <ref> [8] </ref>.
Reference: [9] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: to the primitive subtyping rule ` T 1 S 1 ; AT 1 ` S 2 T 2 (All-Sub) for bounded universals | the difference being that the bounds are compared covariantly rather than contravariantly | and that Der-Some-I and Der-Some-E straightforwardly generalize the usual typing rules for unbounded existentials <ref> [9, 10] </ref>. Alternatively, bounded existential types can be provided as a primitive syntactic form [4] by extending the grammar of types and terms with the Some, pack, and open constructs, and adding typing and subtyping rules for existentials to those in Appendix B.
Reference: [10] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: to the primitive subtyping rule ` T 1 S 1 ; AT 1 ` S 2 T 2 (All-Sub) for bounded universals | the difference being that the bounds are compared covariantly rather than contravariantly | and that Der-Some-I and Der-Some-E straightforwardly generalize the usual typing rules for unbounded existentials <ref> [9, 10] </ref>. Alternatively, bounded existential types can be provided as a primitive syntactic form [4] by extending the grammar of types and terms with the Some, pack, and open constructs, and adding typing and subtyping rules for existentials to those in Appendix B.
Reference: [11] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <volume> 112(1) </volume> <pages> 131-165, </pages> <month> July </month> <year> 1994. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year> <note> A preliminary version appeared in POPL '92. 22 </note>
Reference-contexts: There is a syntax-directed algorithm (summarized by the rules in Appendix C) that discovers the minimal type for any typeable F term by constructing its normal-form derivation [5]. Although it fails to terminate on some pathological ill-typed terms <ref> [8, 11] </ref>, the algorithm is easy to implement and has been found to behave well in practice. 2.2 Encoded and Primitive Existentials in F The simplest way to add existential quantifiers to F is to regard them as syntactic sugar for combinations of universal quantifiers, using the standard encoding: Some (AS <p> The problem is undecidable, given the undecidability of subtyping for F <ref> [11] </ref>: when S 2 is A, a T such that T S 1 and U [T =A]S 2 esists if and only if U S 1 .
References-found: 11

