URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers/recclos/hoots97.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Title: Typed Closure Conversion for Recursively-Defined Functions (Extended Abstract)  
Author: Greg Morrisett Robert Harper 
Affiliation: Cornell University  Carnegie Mellon University  
Abstract: Much recent work on the compilation of statically typed languages such as ML relies on the propagation of type information from source to object code in order to increase the reliability and maintainabilty of the compiler itself and to improve the efficiency and verifiability of generated code. To achieve this the program transformations performed by a compiler must be cast as type-preserving translations between typed intermediate languages. In earlier work with Minamide we studied one important compiler transformation, closure conversion, for the case of pure simply-typed and polymorphic -calculus. Here we extend the treatment of simply-typed closure conversion to account for recursively-defined functions such as are found in ML. We consider three main approaches, one based on a recursive code construct, one based on a self-referential data structure, and one based on recursive types. We discuss their relative advantages and disadvantages, and sketch correctness proofs for these transformations based on the method of logical relations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Closure-passing does have its drawbacks: it requires recursive types (not just monotonic types) which seriously complicates the semantics of the target language, and to reap the allocation benefits, requires some rather ad hoc data structures (e.g ., pointers into the middle of tuples <ref> [1] </ref>.)
Reference: [2] <author> A. W. Appel and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: It is worth remarking that this is the closure-passing style that Appel and Jim proposed in an untyped setting <ref> [2] </ref>, and was used until recently in the SML/NJ compiler [3].
Reference: [3] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: the target language expression let z code = [e; z]:( 2 e) + ( 1 e) + z y code = [e; y]:hz code ; hy; 1 e; ii x code = [e; x]:hy code ; hxii f = hx code ; hii f 0 = ( 1 f ) <ref> [ 2 f; 3] </ref> in end The function f becomes a pair of the code x code and an empty environment. The definition of f 0 invokes f by calling the code of f (x code ), passing to it its environment and the argument 3. <p> It is worth remarking that this is the closure-passing style that Appel and Jim proposed in an untyped setting [2], and was used until recently in the SML/NJ compiler <ref> [3] </ref>. Closure-passing does have its drawbacks: it requires recursive types (not just monotonic types) which seriously complicates the semantics of the target language, and to reap the allocation benefits, requires some rather ad hoc data structures (e.g ., pointers into the middle of tuples [1].)
Reference: [4] <author> L. Birkedal and R. Harper. </author> <title> Relational interpretations of recursive types in an operational setting (summary). </title> <booktitle> In Theoretical Aspects of Computer Science, Sendai, </booktitle> <address> Japan, </address> <month> September </month> <year> 1997. </year> <note> (To appear.). </note>
Reference: [5] <author> I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> From operational semantics to domain theory. </title> <journal> Information and Computation, </journal> <volume> 128(1) </volume> <pages> 26-47, </pages> <year> 1996. </year>
Reference: [6] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Hence, within the definition of z code , e is bound to h4; 3i and z is bound to 5. The body of this code computes the value 3 + 4 + 5 = 12. In earlier work with Minamide <ref> [6] </ref> we considered the question of how to perform closure conversion in a typed setting. We sought to relate the type of a program after closure conversion to its type prior to closure conversion.
Reference: [7] <author> J. C. Mitchell and G. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year> <month> 11 </month>
Reference-contexts: The issue is that, at the source level, int ! int hides the type of the environment, but at the target level, the type of the environment is exposed in the type of the closure. This problem of representation exposure may be avoided by using an existential type <ref> [7] </ref> to hide the type of the environment. This ensures that all closures arising from a given source language type have the same type after closure conversion.
Reference: [8] <author> B. C. Pierce and D. N. Turner. </author> <title> Object-oriented programming without recursive types. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, SC, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Specifically, source functions of type t 1 ! t 2 are translated to target closures with type 9ff:h ([ff; t 1 ] ! t 2 ) fi ffi. This translation is closely related to Pierce and Turner's type system for objects <ref> [8] </ref> | a function is interpreted as an object with one method (the code) and one instance variable (the environment) using their existential type discipline for simple objects. The present work is concerned with the extension of our previous work to account for recursively-defined functions.
Reference: [9] <author> A. M. Pitts. </author> <title> Relational properties of domains. </title> <journal> Information and Computation, </journal> <volume> 127(2) </volume> <pages> 66-90, </pages> <month> June </month> <year> 1996. </year> <month> 12 </month>
References-found: 9

