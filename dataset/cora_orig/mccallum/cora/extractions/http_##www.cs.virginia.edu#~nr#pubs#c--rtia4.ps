URL: http://www.cs.virginia.edu/~nr/pubs/c--rtia4.ps
Refering-URL: http://www.cs.virginia.edu/~nr/pubs/c--rti-abstract.html
Root-URL: http://www.cs.virginia.edu
Title: Machine-Independent Support for Garbage Collection, Debugging, Exception Handling, and Concurrency (Draft) of open problems remain.
Author: Simon Peyton Jones Norman Ramsey 
Note: A number  
Date: August 7, 1998  
Affiliation: University of Glasgow  University of Virginia  
Abstract: For a compiler writer, generating good machine code for a variety of platforms is hard work. One might try to reuse a retargetable code generator from another compiler, but code generators are complex and difficult to use, and they limit one's choice of implementation language. One might try to use C as a portable assembly language, but C limits the compiler writer's flexibility and the performance of the resulting code. The wide use of C, despite these drawbacks, argues for a portable assembly language. C-- is a new language designed expressly as a portable assembly language. C-- eliminates some of the performance problems associated with C, but in its originally-proposed form it does not provide adequate support for garbage collection, exception handling, and debugging. The problem is that neither the high-level compiler nor the C-- compiler has all of the information needed to support these run-time features. This paper proposes a three-part solution: new language constructs for C--, run-time support for C--, and restrictions on optimization of C-- programs. The new C-- language constructs enable a high-level compiler to associate initialized data with spans of C-- source ranges and to specify "alternate continuations" for calls to procedures that might raise exceptions. The run-time support is an interface (specified in C) that the garbage collector, exception mechanism, and debugger can use to get access to both high-level and low-level information, provided that the C-- program is suspended at a safe point. High- and low-level information is coordinated by means of the C-- spans and a common numbering for variables. Finally, the C-- optimizer operates under the constraints that the debugger or garbage collector can change the values of local variables while execution is suspended, and that a procedure call with alternate continuations can return to more than one location. This three-part solution also provides adequate support for concurrency, so the paper illustrates the problem and the proposed solution with examples from garbage collection, exception handling, debugging, and threads. The paper also includes a model of the dataflow behavior of C-- calls. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Alpern, Bowen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <year> 1988 </year> <month> (January). </month> <title> Detecting equalities of variables in programs. </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <address> San Diego, California. </address>
Reference: <author> Appel, Andrew W. </author> <year> 1989 </year> <month> (February). </month> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software|Practice & Experience, </journal> <volume> 19(2) </volume> <pages> 171-183. </pages> . <year> 1990. </year> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3 </volume> <pages> 343-380. </pages> . <year> 1998 </year> <month> (April). </month> <title> SSA is functional programming. </title> <journal> SIGPLAN Notices, </journal> 33(4):17-20. 
Reference: <author> Atkinson, Russ, Alan Demers, Carl Hauser, Chnristian Jacobi, Peter Kessler, and Mark Weiser. </author> <year> 1989 </year> <month> (July). </month> <title> Experiences creating a portable Cedar. </title> <booktitle> Proceedings of the '89 SIGPLAN Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> 24(7) </volume> <pages> 322-329. </pages>
Reference: <author> Bailey, Mark W. and Jack W. Davidson. </author> <year> 1995 </year> <month> (January). </month> <title> A formal model and specification language for procedure calling conventions. </title> <booktitle> In Conference Record of the 22nd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 298-310, </pages> <address> San Francisco, CA. </address>
Reference-contexts: The last two columns show what happens to values that are passed (parameters or results). The Convention specifies rules for placing values in locations (i.e., in registers or memory). Finite automata may be useful for this purpose <ref> (Bailey and Davidson 1995) </ref>. Typical conventions pass some values in registers, but each machine has only finitely many registers. The Overflow column shows where values go when they won't fit in registers. For example, a frame containing continuation must reserve enough space to hold any overflow parameters used by invoke.
Reference: <author> Bartlett, Joel F. </author> <year> 1988 </year> <month> (February). </month> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <address> DEC WRL, 100 Hamilton Avenue, Palo Alto, California 94301. </address> . <year> 1989a </year> <month> (October). </month>
Reference: <editor> Mostly-copying garbage collection picks up generations and C++. </editor> <title> Technical Report TN-12, DEC WRL, 100 Hamilton Avenue, Palo Alto, California 94301. SCHEME to C: A portable Scheme-to-C compiler. </title> <type> Technical Report RR 89/1, </type> <month> DEC WRL. </month>
Reference: <author> Benitez, Manuel E. and Jack W. Davidson. </author> <year> 1988 </year> <month> (July). </month> <title> A portable global optimizer and linker. </title> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 23(7) </volume> <pages> 329-338. </pages> <note> 48 REFERENCES Boehm, </note> <author> Hans-Juergen and Mark Weiser. </author> <year> 1988 </year> <month> (September). </month> <title> Garbage collection in an uncooperative environment. </title> <journal> Software|Practice & Experience, </journal> 18(9):807-820. 
Reference-contexts: Curiously, despite the huge amount of research in this area, only three retargetable, optimizing code generators are freely available: VPO <ref> (Benitez and Davidson 1988) </ref>, ML-RISC (George 1996), and the gcc back end (Stallman 1992). Each of these impressive systems has a rich, complex, and ill-documented interface. <p> the Gnu C "tree" interface is not documented, but the "RTL" interface assumes that its input was generated from Gnu C "trees." * SUIF (Hall et al. 1996) offers many optimizations, including parallizing optimiza tions, but it has only one native-code back end; otherwise, it compiles to C. * Vpo <ref> (Benitez and Davidson 1988) </ref> has been used with a few different front ends, but it enforces C's calling conventions, does not optimize tail calls, and does not provide hooks for supporting garbage collection. * ML-RISC (George 1996) is a promising new code generator, but it is still under development, and its
Reference: <author> Briggs, Preston, Keith D. Cooper, and Linda Torczon. </author> <year> 1994 </year> <month> (May). </month> <title> Improvements to graph coloring register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 428-455. </pages>
Reference: <author> Cardelli, Luca, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <year> 1992 </year> <month> (August). </month> <title> Modula-3 language definition. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-42. </pages>
Reference-contexts: C-- does not enforce a particular model of or semantics for exceptions; instead, C-- provides hooks that enable different front-end run-time systems to implement different high-level exception semantics. These hooks do not impose undue overhead on the normal case. (The designers of Modula-3 <ref> (Cardelli et al. 1992) </ref> urge implementors to spend 10,000 instructions in the exceptional case to save 1 instruction in the normal case.) We illustrate the idea of using a single set of hooks to implement various high-level exception semantics by sketching how one might implement exception dispatchers for Modula-3, Eiffel, and
Reference: <author> Chase, David. </author> <year> 1994a </year> <month> (June). </month>
Reference-contexts: ExecuteToNextSafePoint (t) Runs thread t until it reaches a safe point. Table 1: The C-- run-time interface 5.1 Implementing spans The span mappings of Section 4.2 take their inspiration from table mappings for exception handling, and they can be implemented in similar ways <ref> (Chase 1994a) </ref>. The most common way is to use tables sorted by program counter. If suitable linker support is available, tables for different tokens can go in different sections, and they will automatically be concatenated at link time.
Reference: <author> Implementation of exception handling, </author> <title> Part I. </title> <journal> The Journal of C Language Translation, </journal> <volume> 5(4) </volume> <pages> 229-240. </pages> . <year> 1994b </year> <month> (September). </month> <title> Implementation of exception handling, Part II: Calling conventions, asynchrony, optimizers, and debuggers. </title> <journal> The Journal of C Language Translation, </journal> 6(1):20-32. 
Reference: <author> Clausen, L. R. and Olivier Danvy. </author> <year> 1998 </year> <month> (April). </month> <title> Compiling proper tail recursion and first-class continuations: Scheme on the Java virtual machine. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, BRICS. </institution>
Reference: <author> Drew, Steven J. and K. John Gough. </author> <year> 1994 </year> <month> (May). </month> <title> Exception handling: expecting the unexpected. </title> <journal> Computer Languages, </journal> <volume> 20(2) </volume> <pages> 69-87. </pages>
Reference: <author> Franz, Michael and Thomas Kistler. </author> <year> 1997 </year> <month> (December). </month> <title> Slim binaries. </title> <journal> Communications of the ACM, </journal> <volume> 40(12) </volume> <pages> 87-94. </pages>
Reference-contexts: The resulting implementations run like a mangy, badly injured dog (Clausen and Danvy 1998; Wakeling 1998). * Like Java, the Juice system <ref> (Franz 1997) </ref> supports machine-independent mobile code, but it is not a virtual machine. Instead, it is based on slim binaries, which are specially compressed abstract syntax trees from the Zurich Oberon compiler (Franz and Kistler 1997). <p> Instead, it is based on slim binaries, which are specially compressed abstract syntax trees from the Zurich Oberon compiler <ref> (Franz and Kistler 1997) </ref>.
Reference: <author> Franz, Michael. </author> <year> 1997 </year> <month> (October). </month> <title> Beyond Java: An infrastructure for high-performance mobile code on the World Wide Web. </title> <editor> In Lobodzinski, S. and I. Tomek, editors, </editor> <booktitle> Proceedings of WebNet'97, World Conference of the WWW, Internet, and Intranet, </booktitle> <pages> pages 33-38. </pages> <booktitle> Association for the Advancement of Computing in Education. </booktitle>
Reference-contexts: The resulting implementations run like a mangy, badly injured dog (Clausen and Danvy 1998; Wakeling 1998). * Like Java, the Juice system <ref> (Franz 1997) </ref> supports machine-independent mobile code, but it is not a virtual machine. Instead, it is based on slim binaries, which are specially compressed abstract syntax trees from the Zurich Oberon compiler (Franz and Kistler 1997). <p> Instead, it is based on slim binaries, which are specially compressed abstract syntax trees from the Zurich Oberon compiler <ref> (Franz and Kistler 1997) </ref>.
Reference: <author> Fraser, Christopher W. and David R. Hanson. </author> <year> 1991 </year> <month> (September). </month>
Reference-contexts: In the introduction, we mentioned that such code generators are complex, language-specific, and often poorly documented. They are also surprisingly few: * The simplest and best documented such code generator is the lcc code generator <ref> (Fraser and Hanson 1991) </ref>, but it implements no global optimizations. * Gnu C (Stallman 1992) has been used the most successfully with different front ends, but folklore suggests that the cost is disproportionate.
Reference: <editor> A code generation interface for ANSI C. </editor> <booktitle> Software|Practice & Experience, </booktitle> <volume> 21(9) </volume> <pages> 963-988. </pages>
Reference: <author> Gehani, Narain H. </author> <year> 1992 </year> <month> (October). </month> <title> Exceptional C or C with exceptions. </title> <journal> Software|Practice & Experience, </journal> <volume> 22(10) </volume> <pages> 827-848. </pages>
Reference-contexts: The new element is the retry, which can be implemented in C-- by a simple branch (goto) to the beginning of the routine. Propagating the exception requires re-invoking the run-time exception dispatcher, which is also possible in Modula-3. 6.3 Debugging 29 6.2.3 Exceptional C exceptions Exceptional C <ref> (Gehani 1992) </ref> offers a limited form of asynchronous exceptions with resumption. In Exceptional C, handlers for asynchronous exceptions do not have access to the local variables of the functions in which they appear; such handlers have access only to global variables.
Reference: <author> George, Lal and Andrew W. Appel. </author> <year> 1996 </year> <month> (May). </month> <title> Iterated register coalescing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(3) </volume> <pages> 300-324. </pages>
Reference-contexts: Curiously, despite the huge amount of research in this area, only three retargetable, optimizing code generators are freely available: VPO (Benitez and Davidson 1988), ML-RISC <ref> (George 1996) </ref>, and the gcc back end (Stallman 1992). Each of these impressive systems has a rich, complex, and ill-documented interface. Of course, these interfaces are quite different from one another, so once you start to use one, you will be unable to switch easily to another. <p> but it has only one native-code back end; otherwise, it compiles to C. * Vpo (Benitez and Davidson 1988) has been used with a few different front ends, but it enforces C's calling conventions, does not optimize tail calls, and does not provide hooks for supporting garbage collection. * ML-RISC <ref> (George 1996) </ref> is a promising new code generator, but it is still under development, and its interfaces still appear complex. 34 7 DISCUSSION AND RELATED WORK An alternative to using existing code generators is to use existing virtual machines. * The Java Virtual Machine (Lindholm and Yellin 1997) is machine-independent and <p> This is the approach taken by ML-RISC <ref> (George 1996) </ref>. At present, however, every such interface is highly specific to its particular back end; ML-RISC provides ML-RISC's interface (and requires that the front end be written in ML), gcc's tree language is very specific to gcc, and so on.
Reference: <author> George, Lal. </author> <year> 1996. </year> <title> MLRISC: Customizable and reusable code generators. </title> <note> Unpublished report available from http://www.cs.bell-labs.com/~george/. REFERENCES 49 Goodenough, </note> <author> John B. </author> <year> 1975 </year> <month> (December). </month> <title> Exception handling: Issues and a proposed notation. </title> <journal> Communications of the ACM, </journal> <volume> 18(12) </volume> <pages> 683-696. </pages>
Reference-contexts: Curiously, despite the huge amount of research in this area, only three retargetable, optimizing code generators are freely available: VPO (Benitez and Davidson 1988), ML-RISC <ref> (George 1996) </ref>, and the gcc back end (Stallman 1992). Each of these impressive systems has a rich, complex, and ill-documented interface. Of course, these interfaces are quite different from one another, so once you start to use one, you will be unable to switch easily to another. <p> but it has only one native-code back end; otherwise, it compiles to C. * Vpo (Benitez and Davidson 1988) has been used with a few different front ends, but it enforces C's calling conventions, does not optimize tail calls, and does not provide hooks for supporting garbage collection. * ML-RISC <ref> (George 1996) </ref> is a promising new code generator, but it is still under development, and its interfaces still appear complex. 34 7 DISCUSSION AND RELATED WORK An alternative to using existing code generators is to use existing virtual machines. * The Java Virtual Machine (Lindholm and Yellin 1997) is machine-independent and <p> This is the approach taken by ML-RISC <ref> (George 1996) </ref>. At present, however, every such interface is highly specific to its particular back end; ML-RISC provides ML-RISC's interface (and requires that the front end be written in ML), gcc's tree language is very specific to gcc, and so on.
Reference: <author> Hall, Mary W., Jennifer M. Anderson, Saman P. Amarasinghe, Brian R. Murphy, Shih-Wei Liao, Edouard Bugnion, and Monica S. Lam. </author> <year> 1996 </year> <month> (December). </month> <title> Maximizing multiprocessor performance with the SUIF compiler. </title> <publisher> Computer, 29(12):84. </publisher>
Reference-contexts: One known problem is that the Gnu C "tree" interface is not documented, but the "RTL" interface assumes that its input was generated from Gnu C "trees." * SUIF <ref> (Hall et al. 1996) </ref> offers many optimizations, including parallizing optimiza tions, but it has only one native-code back end; otherwise, it compiles to C. * Vpo (Benitez and Davidson 1988) has been used with a few different front ends, but it enforces C's calling conventions, does not optimize tail calls, and
Reference: <author> Hanson, D. R. and M. Raghavachari. </author> <year> 1996 </year> <month> (November). </month> <title> A machine-independent debugger. </title> <journal> Software|Practice & Experience, </journal> <volume> 26(11) </volume> <pages> 1277-1299. </pages>
Reference: <author> Hauser, John R. </author> <year> 1996 </year> <month> (March). </month> <title> Handling floating-point exceptions in numeric programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(2) </volume> <pages> 139-174. </pages>
Reference: <author> Henderson, Fergus, Thomas Conway, and Zoltan Somogyi. </author> <year> 1995. </year> <title> Compiling logic programs to C using GNU C as a portable assembler. </title> <booktitle> In ILPS'95 Postconference Workshop on Sequential Implementation Technologies for Logic Programming, </booktitle> <pages> pages 1-15, </pages> <address> Portland, Or. </address>
Reference: <author> Hennessy, John. </author> <year> 1981 </year> <month> (January). </month> <title> Program optimization and exception handling. </title> <booktitle> In Conference Record of the 8th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 200-206, </pages> <address> Williamsburg, Virginia. </address>
Reference-contexts: In effect, also aborts introduces a flow edge from the call site to the procedure exit node, so that the optimizer does not eliminate assignments before the call that might otherwise be considered dead <ref> (Hennessy 1981) </ref>. Any call site in a procedure P that could raise an exception not handled in P should be annotated with also aborts. How are these multiple continuations used? A return statement causes execution to transfer to the "main" continuation in the caller.
Reference: <author> Hieb, R., R. K. Dybvig, and A. C. Bruggeman. </author> <year> 1991 </year> <month> (June). </month> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation. </booktitle>
Reference: <author> Lindholm, Tim and Frank Yellin. </author> <year> 1997 </year> <month> (January). </month> <title> The Java Virtual Machine Specification. The Java Series. </title> <address> Reading, MA, USA: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: for supporting garbage collection. * ML-RISC (George 1996) is a promising new code generator, but it is still under development, and its interfaces still appear complex. 34 7 DISCUSSION AND RELATED WORK An alternative to using existing code generators is to use existing virtual machines. * The Java Virtual Machine <ref> (Lindholm and Yellin 1997) </ref> is machine-independent and can be expected to be widely implemented, but even the most heavily optimized JVM compiler is unlikely to approach the performance possible with a custom code generator, or with C--.
Reference: <author> Linton, Mark A. </author> <year> 1990 </year> <month> (June). </month> <title> The evolution of Dbx. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 211-220, </pages> <address> Anaheim, CA. </address>
Reference: <author> Liskov, Barbara H. and Alan Snyder. </author> <year> 1979 </year> <month> (November). </month> <title> Exception handling in CLU. </title> <journal> IEEE Transactions on Software Engineering, SE-5(6):546-558. </journal>
Reference: <author> Liskov, Barbara, Dorothy Curtis, Paul Johnson, and Robert Scheifler. </author> <year> 1987 </year> <month> (11). </month> <title> Implementation of Argus. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 111-122. </pages> <note> Published in ACM Operating Systems Review Vol.21, No.5. </note>
Reference-contexts: Front ends can ensure atomicity by keeping safe points out of critical sections. A similar strategy was used with Argus, made cheaper by forcing safe points to coincide with stack-limit checks <ref> (Liskov et al. 1987) </ref>. This style of concurrency is very cheap. The operating system is not involved, no protection boundaries are crossed, and shared data structures can be manipulated without OS-level synchronization.
Reference: <author> Meyer, Bertrand. </author> <year> 1992. </year> <title> Eiffel: The Language. </title> <publisher> London: Prentice Hall International. </publisher>
Reference-contexts: The dispatcher included with DEC SRC Modula-3 even includes performance optimizations, such as efficient finalization of locks. 6.2.2 Eiffel exceptions The Eiffel language <ref> (Meyer 1992) </ref> provides a somewhat different exception model, but one that can be implemented using the same C-- mechanisms. In Eiffel, exception handlers may not be attached to arbitrary sequences of statements, but only to whole procedures (called routines).
Reference: <author> Pettersson, M. </author> <year> 1995. </year>
Reference: <author> Simulating tail calls in C. </author> <type> Technical report, </type> <institution> Department of Computer Science, Linkoping University. </institution> <note> 50 REFERENCES Peyton Jones, </note> <author> Simon L., A. J. Gordon, and S. O. Finne. </author> <year> 1996. </year> <title> Concurrent Haskell. </title> <booktitle> In Conference Record of the 23rd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 295-308. </pages>
Reference: <author> Peyton Jones, Simon L., Dino Oliva, and T. Nordin. </author> <year> 1998. </year> <title> C--: A portable assembly language. </title> <booktitle> In Proceedings of the 1997 Workshop on Implementing Functional Languages. </booktitle> <publisher> Springer Verlag LNCS. </publisher>
Reference-contexts: C locks the implementation into a particular calling convention, makes it impossible to compute targets of jumps, and provides no support for garbage collection, exceptions, or debugging, except such debugging support as may be provided by a particular C compiler. An earlier paper discusses C's shortcomings in more detail <ref> (Peyton Jones, Oliva, and Nordin 1998) </ref>. The obvious way forward is to design a language specifically as a compiler target language. Such a language should serve as the interface between a compiler for a high-level language (the front end ) and a retargetable code generator (the back end ). <p> The front end communicates with the back end by emitting programs in a portable assembly language called C--. The front-end run-time system communicates with the back-end run-time system through a run-time interface (specified in C) called the C-- run-time interface. This paper builds on the existing design of C-- <ref> (Peyton Jones, Oliva, and Nordin 1998) </ref>. The new material, which enables C-- to support garbage collection, exception handling, and debugging, is in three parts: new language constructs for C--, run-time support for C--, and restrictions on optimization of C-- programs. <p> Some paragraphs may bear marginal notes discussing unresolved issues. Particularly sticky issues may be marked as "caveats," as is this paragraph. Caveats may not be intelligible unless you've read the whole paper. 2 The main features of C-- An earlier paper describes the basic design of C-- <ref> (Peyton Jones, Oliva, and Nordin 1998) </ref>. We sketch the design here, with emphasis on those aspects that are relevant for understanding run-time support. Figure 1 gives examples of some C-- procedures that give a flavour of the language.
Reference: <author> Peyton Jones, Simon L. </author> <year> 1992 </year> <month> (April). </month> <title> Implementing lazy functional languages on stock hardware: </title> <journal> The spineless tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202. </pages>
Reference: <author> Ramsey, Norman and David R. Hanson. </author> <year> 1992 </year> <month> (July). </month> <title> A retargetable debugger. </title> <booktitle> ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 27(7) </volume> <pages> 22-31. </pages>
Reference-contexts: The exact format of this data is a private matter between the front end and the debugger; we note in passing that this format need not be machine-dependent <ref> (Ramsey and Hanson 1992) </ref>. As an example of supporting a debugger using C--, this paper sketches a scheme derived from Ramsey (1992), Chapter 4.
Reference: <author> Ramsey, Norman. </author> <year> 1992 </year> <month> (December). </month>
Reference-contexts: The exact format of this data is a private matter between the front end and the debugger; we note in passing that this format need not be machine-dependent <ref> (Ramsey and Hanson 1992) </ref>. As an example of supporting a debugger using C--, this paper sketches a scheme derived from Ramsey (1992), Chapter 4.
References-found: 37

