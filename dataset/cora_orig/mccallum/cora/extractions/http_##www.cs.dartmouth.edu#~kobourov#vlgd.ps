URL: http://www.cs.dartmouth.edu/~kobourov/vlgd.ps
Refering-URL: http://www.cs.dartmouth.edu/~kobourov/
Root-URL: http://www.cs.dartmouth.edu
Email: goodrich@cs.jhu.edu  kobourov@cs.jhu.edu  
Title: VLGD, Algorithm for Drawing Very Large Graphs  
Author: Michael Goodrich Stephen G. Kobourov 
Date: August 21, 1997  
Affiliation: Dept. of Computer Science Johns Hopkins University  Dept. of Computer Science Johns Hopkins University  
Abstract: Given a large planar graph we want to display it in a meaningful fashion. We present VLGD: a new, straightforward and fast algorithm for automatic display of very large planar graphs. We recursively divide the graph in pieces of roughly equal size. As a result we get a collection of O(log n) layers, where n is the number of vertices in the graph. Each succeeding layer represents the graph in an increasing level of detail. Each layer is a graph drawn with straight lines and without crossings on the n fi n grid. VLGD does not rely on any specific properties of the graph other than planarity. The overall running time of the algorithm is O(n log n).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Di Battista, Eades, Tamassia, Tollis. </author> <title> Algorithms for Drawing Graphs: An annotated bibliography. </title> <journal> CGTA: Computational Geometry: Theory and Applications, </journal> <volume> Vol. 4, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Graph drawing algorithms are needed in many different areas of computer science. Graphical user interfaces of software systems, VLSI design, and software visualization are just some examples. In the past decade hundreds of graph drawing algorithms have been developed <ref> [1] </ref> and we can group them broadly into two general categories. In the first category fall algorithms that display the complete graph, with all the vertices and all the edges. Such drawings have the advantage of showing the global structure of the graph. <p> (G 2 ) = fe 2 E (G) : e l x &gt; x cutg else find G 1 and G 2 in a similar fashion return (G 1 ; G 2 ) LS (A; V (G); ff) cut size; cut index; v cnt 0 bucket sort A in B <ref> [1; n] </ref> for i = 1 to n for all end 2 fi th bucket of Bg do if (L (end)) then cut size + + if (R (end)) then cut size if (end is a new vertex) then v cnt + + if ((v cnt (1 ff)jV (G)j) and (v <p> Recall that A contains all the endpoints of G and so jAj = 2jE (G)j = O (n G ). We also know that all entries a 2 A are in the range <ref> [1; n] </ref>, where n is the number of vertices in the original graph. We scan A and store its elements in a bucket array B with linked lists containing elements with the same index.
Reference: [2] <author> Juraj Bosak. </author> <title> Decomposition of Graphs. </title> <journal> Mathematics and its Applications, </journal> <volume> vol. </volume> <publisher> 47 Kluwer, Holland, </publisher> <year> 1990. </year>
Reference-contexts: Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) [20, 16, 14]. This problem is related to graph partitioning <ref> [2] </ref>. Once the clustering has been determined, the graph layers are generated. The number of layers is determined by the depth of the clustering hierarchy. As a result, the graph is represented by a sequence of drawings of increasing detail.
Reference: [3] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press/McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: Finally, we return G 1 and G 2 . 3.5 The LS routine In the line sweep procedure, LS, we first bucket sort the array of endpoints. For more details on bucket sorting in linear time see <ref> [3] </ref>. We also find the minimum cut in G by scanning B and maintaining the best cut which satisfies the balance requirements. Once we scan more than (1 ff)jV (G)j unique vertices of G, we start keeping track of the minimum cut size and index. <p> We scan A and store its elements in a bucket array B with linked lists containing elements with the same index. This process takes only linear time as we do not need comparisons to perform the sorting <ref> [3] </ref>. The scanning of B also takes linear time as we examine each entry only once and perform constant time operations. We have thus shown that CUT runs in O (n) time. Lemma 5 Procedure PHASE1 produces all the clusters and runs O (n log n) time.
Reference: [4] <author> I. Fary. </author> <title> On straight lines representation of planar graphs. </title> <journal> In Acta Sci. Math. Szeged. </journal> <volume> 11, </volume> <pages> pages 229-233, </pages> <year> 1948 </year>
Reference-contexts: In addition, all the faces of H are triangles, including the exterior face. We can construct H in linear time in the number of vertices of G [15] One of the classic graph drawing results independently shown by Fary <ref> [4] </ref>, Stein [19], and Wagner [21] states that any planar graph admits a drawing in the plane using straight lines and without crossings.
Reference: [5] <author> Quing-Wen Feng, Robert F. Cohen, and Peter Eades. </author> <title> How to draw a planar clustered graph. </title> <booktitle> In COCOON'95, vol. 959 Lecture Notes in Computer Science, </booktitle> <pages> pages 21-31, </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Another, altogether different, approach calls for successive division of the graph into clusters. By grouping vertices together into clusters we can recursively divide a given graph into layers of increasing detail. If clusters can be given as the input along with the graph <ref> [5, 6, 7, 8, 13] </ref> then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) [20, 16, 14]. This problem is related to graph partitioning [2].
Reference: [6] <author> Quing-Wen Feng, Robert F. Cohen, and Peter Eades. </author> <title> Planarity for clustered graphs In ESA'95, </title> <booktitle> vol. 979 Lecture Notes in Computer Science, </booktitle> <pages> pages 213-226, </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Another, altogether different, approach calls for successive division of the graph into clusters. By grouping vertices together into clusters we can recursively divide a given graph into layers of increasing detail. If clusters can be given as the input along with the graph <ref> [5, 6, 7, 8, 13] </ref> then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) [20, 16, 14]. This problem is related to graph partitioning [2].
Reference: [7] <author> Quing-Wen Feng and Peter Eades. </author> <title> Multilevel Visualization of Clustered Graphs In GD'96, </title> <booktitle> vol. 1190 Lecture Notes in Computer Science, </booktitle> <pages> pages 101-112, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996 </year>
Reference-contexts: Another, altogether different, approach calls for successive division of the graph into clusters. By grouping vertices together into clusters we can recursively divide a given graph into layers of increasing detail. If clusters can be given as the input along with the graph <ref> [5, 6, 7, 8, 13] </ref> then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) [20, 16, 14]. This problem is related to graph partitioning [2]. <p> The number of layers is determined by the depth of the clustering hierarchy. As a result, the graph is represented by a sequence of drawings of increasing detail. An example of the resulting multi-level visualization is presented by Eades and Feng <ref> [7] </ref>. There is a conspicuous lack of simple and fast algorithms that can display very large graphs. Most existing algorithms rely on specific graph properties, or apply only to special classes of graphs, or require a priori knowledge of the number of clusters to partition into.
Reference: [8] <author> Quing-Wen Feng and Peter Eades. </author> <title> Straight-Line Drawing Algorithms for Hierarchical Graphs and Clusterd Graphs In GD'96, </title> <booktitle> vol. 1190 Lecture Notes in Computer Science, </booktitle> <pages> pages 113-128, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996 </year>
Reference-contexts: Another, altogether different, approach calls for successive division of the graph into clusters. By grouping vertices together into clusters we can recursively divide a given graph into layers of increasing detail. If clusters can be given as the input along with the graph <ref> [5, 6, 7, 8, 13] </ref> then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) [20, 16, 14]. This problem is related to graph partitioning [2].
Reference: [9] <author> H. de Fraysseix, J. Pach, and R. Pollack. </author> <title> Small Sets Supporting Fary Embeddings of Planar Graphs. </title> <booktitle> In Proceedings of the 20th Annual Symposium on Theory of Computing, </booktitle> <pages> pages 426-433, </pages> <year> 1988 </year>
Reference-contexts: Fraysseix, Pach, and Pollack <ref> [9] </ref> and Schnyder [18] refine the result further by embedding the graph on an n fi n grid using straight lines and without crossings.
Reference: [10] <author> G. W. Furnas. </author> <booktitle> Generalized Fisheye Views SIGCHI'86, </booktitle> <pages> pages 16-23, </pages> <year> 1986. </year>
Reference-contexts: Clearly, a simple graph drawing algorithm will fall short of displaying such a graph. Two different approaches might be adopted to successfully display very large graphs. The first one, known as the fish-eye view <ref> [17, 10] </ref> shows an area of interest quite large and with detail and shows other areas successively smaller and in less detail. Fish-eye view graphs combine the advantages of the complete graph drawing 1 algorithms and the scrolling drawing algorithms.
Reference: [11] <author> Richard J. Lipton and Robert E. </author> <title> Tarjan A Separator Theorem for Planar Graphs SIAM Journal of Applied Mathematics, </title> <journal> vol. </journal> <volume> 36, no. 2, </volume> <pages> pages 177-189, </pages> <month> April </month> <year> 1979 </year>
Reference-contexts: It is easy to see that all of the five possible cases imply that G itself contains a generalized Kuratowski graph which contradicts the assumption that G is planar. For more details see Lemma 1 of Lipton and Tarjan, <ref> [11] </ref>. Lemma 3 Algorithm VLGD produces convex clusters and a drawing of the cluster-graph M fl , such that all the layers are drawn on the n fi n grid with straight lines and without crossings. <p> It is an open question whether it is possible to determine the optimal embedding, one that yields the minimum ff-balanced cuts. Another open question is related to the seaprator theorems of Lipton and Tarjan <ref> [11] </ref> and Miller [12].
Reference: [12] <author> Gary L. Miller. </author> <title> Finding Small Simple Cycle Separators for 2-Connected Planar Graphs Journal of Computer and Systems Sciences, </title> <journal> vol. </journal> <volume> 32, no. </volume> <pages> 3 pages 265-279, </pages> <month> June </month> <year> 1986 </year>
Reference-contexts: It is an open question whether it is possible to determine the optimal embedding, one that yields the minimum ff-balanced cuts. Another open question is related to the seaprator theorems of Lipton and Tarjan [11] and Miller <ref> [12] </ref>.
Reference: [13] <author> Stephen North. </author> <title> Drawing Ranked Graphs with Recursive Clusters ALCOM Workshop on Graph Drawing '93, </title> <month> pages ?-?, September </month> <year> 1993. </year>
Reference-contexts: Another, altogether different, approach calls for successive division of the graph into clusters. By grouping vertices together into clusters we can recursively divide a given graph into layers of increasing detail. If clusters can be given as the input along with the graph <ref> [5, 6, 7, 8, 13] </ref> then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) [20, 16, 14]. This problem is related to graph partitioning [2].
Reference: [14] <author> F. N. Paulisch. </author> <title> Edge Concentration: </title> <booktitle> A Method for Clustering Graphs 2nd International Workshop on Software Configuration Management, </booktitle> <pages> pages 76-85, </pages> <year> 1989. </year>
Reference-contexts: If clusters can be given as the input along with the graph [5, 6, 7, 8, 13] then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) <ref> [20, 16, 14] </ref>. This problem is related to graph partitioning [2]. Once the clustering has been determined, the graph layers are generated. The number of layers is determined by the depth of the clustering hierarchy. As a result, the graph is represented by a sequence of drawings of increasing detail.
Reference: [15] <author> R. C. </author> <title> Read. A New Method for Drawing a Planar Graph Given the Cyclic Order of the Edges at Each Vertex Congressus Numerantium vol. </title> <booktitle> 56, </booktitle> <pages> pages 31-44, </pages> <year> 1987. </year>
Reference-contexts: In addition, all the faces of H are triangles, including the exterior face. We can construct H in linear time in the number of vertices of G <ref> [15] </ref> One of the classic graph drawing results independently shown by Fary [4], Stein [19], and Wagner [21] states that any planar graph admits a drawing in the plane using straight lines and without crossings.
Reference: [16] <author> Reinhard Sablowski and Arne Frick. </author> <title> Automatic Graph Clustering In GD'96, </title> <booktitle> vol. 1190 Lecture Notes in Computer Science, </booktitle> <pages> pages 395-400, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996 </year> <month> 14 </month>
Reference-contexts: If clusters can be given as the input along with the graph [5, 6, 7, 8, 13] then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) <ref> [20, 16, 14] </ref>. This problem is related to graph partitioning [2]. Once the clustering has been determined, the graph layers are generated. The number of layers is determined by the depth of the clustering hierarchy. As a result, the graph is represented by a sequence of drawings of increasing detail.
Reference: [17] <author> M. Sakar and M. </author> <title> Brown. </title> <journal> Graphical Fisheye Views Communications of the ACM, </journal> <volume> vol. 37 no. 12, </volume> <pages> pages 73-84, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Clearly, a simple graph drawing algorithm will fall short of displaying such a graph. Two different approaches might be adopted to successfully display very large graphs. The first one, known as the fish-eye view <ref> [17, 10] </ref> shows an area of interest quite large and with detail and shows other areas successively smaller and in less detail. Fish-eye view graphs combine the advantages of the complete graph drawing 1 algorithms and the scrolling drawing algorithms.
Reference: [18] <author> Walter Schyder. </author> <booktitle> Embedding Planar Graphs on the Grid In 1th Annual Symposium on Discrete Algorithms, </booktitle> <pages> pages 138-148, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Fraysseix, Pach, and Pollack [9] and Schnyder <ref> [18] </ref> refine the result further by embedding the graph on an n fi n grid using straight lines and without crossings. The input to 2 Schnyder's algorithm is a fully triangulated planar graph and the output is the coordinates of the vertices on the n fi n grid.
Reference: [19] <author> S. K. </author> <title> Stein. </title> <journal> Convex Maps Proceedings American Mathematical Society, </journal> <volume> vol. 2, </volume> <pages> pages 464-466, </pages> <year> 1951 </year>
Reference-contexts: In addition, all the faces of H are triangles, including the exterior face. We can construct H in linear time in the number of vertices of G [15] One of the classic graph drawing results independently shown by Fary [4], Stein <ref> [19] </ref>, and Wagner [21] states that any planar graph admits a drawing in the plane using straight lines and without crossings. Fraysseix, Pach, and Pollack [9] and Schnyder [18] refine the result further by embedding the graph on an n fi n grid using straight lines and without crossings.
Reference: [20] <author> K. Sugiyama and K. Misue. </author> <title> Visualization of structural information: Automatic drawing of compound digraphs. </title> <journal> In IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> vol. 21, no. 4, </volume> <pages> pages 876-892, </pages> <year> 1991. </year>
Reference-contexts: If clusters can be given as the input along with the graph [5, 6, 7, 8, 13] then the problem becomes one of finding a nice way to draw them. Otherwise, clusters can be produced based on the graph structure (connectivity, cluster size, geometric proximity, statistical techniques, etc.) <ref> [20, 16, 14] </ref>. This problem is related to graph partitioning [2]. Once the clustering has been determined, the graph layers are generated. The number of layers is determined by the depth of the clustering hierarchy. As a result, the graph is represented by a sequence of drawings of increasing detail.
Reference: [21] <editor> K. Wagner. Bemerkungen zum vierfarbenproblem In Jber. Deutsch. Math.-Verein, </editor> <volume> vol. 46, </volume> <pages> pages 26-32, </pages> <year> 1936. </year> <month> 15 </month>
Reference-contexts: In addition, all the faces of H are triangles, including the exterior face. We can construct H in linear time in the number of vertices of G [15] One of the classic graph drawing results independently shown by Fary [4], Stein [19], and Wagner <ref> [21] </ref> states that any planar graph admits a drawing in the plane using straight lines and without crossings. Fraysseix, Pach, and Pollack [9] and Schnyder [18] refine the result further by embedding the graph on an n fi n grid using straight lines and without crossings.
References-found: 21

