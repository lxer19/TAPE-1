URL: ftp://ftp.cs.purdue.edu/pub/hosking/papers/UM-CS-1991-025.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/hosking/papers.html
Root-URL: http://www.cs.purdue.edu
Title: Compiler Support for Persistent Programming  
Author: Antony L. Hosking J. Eliot B. Moss 
Note: This project is supported by National Science Foundation Grants CCR-8658074 and DCR-8500332, and by Digital Equipment Corporation, GTE Laboratories, and the Eastman Kodak Company.  
Address: Amherst, MA 01003  
Affiliation: Object Oriented Systems Laboratory Department of Computer and Information Science University of Massachusetts  
Abstract: COINS Technical Report 91-25 March 1991 Abstract We present the design and implementation of Persistent Modula-3, a compiled, optimized, persistent programming language. The design allows the evaluation of performance aspects of persistent programming languages, while the implementation supports the development of compile-time mechanisms for optimizing persistent programs. We present several optimizations in detail, and outline further optimization opportunities. 
Abstract-found: 1
Intro-found: 1
Reference: [Atkinson et al., 1983] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal 26, </journal> <volume> 4 (Nov. </volume> <year> 1983), </year> <pages> 360-365. </pages>
Reference-contexts: Recently we have seen the emergence of persistent programming languages, that treat persistence as an important property of data. The designers of PS-Algol outlined a spectrum of persistence ranging up to and including data items that outlive the programs that create them <ref> [Atkinson et al., 1983; Atkinson and Morrison, 1985] </ref>. They sought to make the longevity of a data item independent of the way it is manipulated, and conversely, the way programs are expressed independent of the longevity of the data they manipulate.
Reference: [Atkinson and Morrison, 1985] <author> Malcolm P. Atkinson and Ronald Morrison. </author> <title> Procedures as persistent data objects. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 7, </volume> <month> 4 (Oct. </month> <year> 1985), </year> <pages> 539-559. </pages>
Reference-contexts: Recently we have seen the emergence of persistent programming languages, that treat persistence as an important property of data. The designers of PS-Algol outlined a spectrum of persistence ranging up to and including data items that outlive the programs that create them <ref> [Atkinson et al., 1983; Atkinson and Morrison, 1985] </ref>. They sought to make the longevity of a data item independent of the way it is manipulated, and conversely, the way programs are expressed independent of the longevity of the data they manipulate.
Reference: [Benzaken, 1990] <author> Veronique Benzaken. </author> <title> An evaluation model for clustering strategies in the O 2 object-oriented database system. </title> <type> Tech. Rep. </type> <pages> 49-90, </pages> <address> Altar, BP105, 78153 Le Chesnay Cedex, France, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: However, the other optimizations we have described are not performed in E. Importantly, an E object is always accessed via a level of indirection. Our object faulting techniques and co-residency optimization eliminate such indirection. 13 Some progress has been made towards understanding clustering issues in persistent object stores <ref> [Benzaken, 1990; Benzaken and Delobel, 1990; Shannon and Snodgrass, 1990] </ref>. However, none of this work considers using clustering information at compile time to generate programs that run efficiently against the persistent store.
Reference: [Benzaken and Delobel, 1990] <author> Veronique Benzaken and Claude Delobel. </author> <title> Enhancing performance in a persistent object store: Clustering strategies in O 2 . In [Dearle et al., </title> <year> 1990]. </year>
Reference-contexts: However, the other optimizations we have described are not performed in E. Importantly, an E object is always accessed via a level of indirection. Our object faulting techniques and co-residency optimization eliminate such indirection. 13 Some progress has been made towards understanding clustering issues in persistent object stores <ref> [Benzaken, 1990; Benzaken and Delobel, 1990; Shannon and Snodgrass, 1990] </ref>. However, none of this work considers using clustering information at compile time to generate programs that run efficiently against the persistent store.
Reference: [Cardelli et al., 1989] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report (revised). Tech. Rep. </type> <institution> DEC SRC 52, DEC Systems Research Center/Olivetti Research Center, </institution> <address> Palo Alto/Menlo Park, CA, </address> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: Following this introduction to the language, we sketch its straightforward implementation using a technique we call object faulting. Finally, we present approaches to optimizing persistent programs so as to improve their performance. 2 Persistent Modula-3 Persistent Modula-3 is an extension of Modula-3 as defined by DEC/Olivetti <ref> [Cardelli et al., 1989] </ref>. We have chosen Modula-3 as a vehicle for exploring optimization of persistent programs because it is strongly typed, compiled, and representative of a class of familiar languages, including Pascal [Jensen and Wirth, 1974] and Modula-2 [Wirth, 1983].
Reference: [Carey et al., 1986] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson, and E. J. Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Data Bases (Kyoto, </booktitle> <address> Japan, Aug. 1986), </address> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 91-100. </pages>
Reference-contexts: We use the Mneme persistent object store [Moss, 1990a], but we could just as easily use some other storage system such as the EXODUS storage manager <ref> [Carey et al., 1986; Carey et al., 1989] </ref>.
Reference: [Carey et al., 1989] <author> Michael J. Carey, David J. DeWitt, Joel E. Richardson, and Eugene J. Shekita. </author> <title> Storage management for objects in EXODUS. In Object-Oriented Concepts, Databases, and Applications, </title> <editor> Won Kim and Frederick H. Lochovsky, Eds. </editor> <booktitle> ACM Press/Addison-Wesley, </booktitle> <address> New York, New York, </address> <year> 1989, </year> <journal> ch. </journal> <volume> 14, </volume> <pages> pp. 341-369. </pages>
Reference-contexts: We use the Mneme persistent object store [Moss, 1990a], but we could just as easily use some other storage system such as the EXODUS storage manager <ref> [Carey et al., 1986; Carey et al., 1989] </ref>.
Reference: [Dearle et al., 1990] <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, Eds. </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice. Fourth International Workshop on Persistent Object Systems: Design, Implementation, and Use (Martha's Vineyard, </booktitle> <address> Massachusetts, Sept. 1990), </address> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year> <month> 14 </month>
Reference: [Jensen and Wirth, 1974] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal User Manual and Report, second ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: We have chosen Modula-3 as a vehicle for exploring optimization of persistent programs because it is strongly typed, compiled, and representative of a class of familiar languages, including Pascal <ref> [Jensen and Wirth, 1974] </ref> and Modula-2 [Wirth, 1983]. We are interested in exploring persistence in such a setting.
Reference: [Kaehler and Krasner, 1983] <author> Ted Kaehler and Glenn Krasner. </author> <title> LOOMlarge object-oriented memory for Smalltalk-80 systems. In Smalltalk-80: Bits of History, Words of Advice, </title> <editor> Glenn Krasner, Ed. </editor> <publisher> Addison-Wesley, </publisher> <year> 1983, </year> <journal> ch. </journal> <volume> 14, </volume> <pages> pp. 251-270. </pages>
Reference-contexts: An object fault causes the object to be retrieved from the persistent store, converted as needed, and made available to the running program in virtual memory. Our approach to object faulting is similar to that used in LOOM <ref> [Kaehler and Krasner, 1983] </ref>. Specially marked resident pseudo-objects called fault blocks stand in for non-resident objects. Every memory reference to a non-resident object is actually a pointer to a fault block.
Reference: [Moss, 1990a] <author> J. Eliot B. Moss. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Trans. Inf. Syst. </journal> <volume> 8, </volume> <month> 2 (Apr. </month> <year> 1990), </year> <pages> 103-139. </pages>
Reference-contexts: We use the Mneme persistent object store <ref> [Moss, 1990a] </ref>, but we could just as easily use some other storage system such as the EXODUS storage manager [Carey et al., 1986; Carey et al., 1989].
Reference: [Moss, 1990b] <author> J. Eliot B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <type> COINS Technical Report 90-38, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> May </month> <year> 1990. </year> <note> Submitted for publication. </note>
Reference-contexts: As we shall describe, the extra indirection imposed by the indirect block allows us to reclaim the space that was used by the swizzled copies, after the indirect blocks have been bypassed (Figure 3 (c)). 3 For a performance evaluation of this and other swizzling techniques see <ref> [Moss, 1990b] </ref> 7 3.5 Managing the Persistent Area We have mentioned that persistent objects are copy swizzled into a separately managed persistent area of the heap, separate from the volatile area in which all new objects, both transient and persistent, are allocated.
Reference: [Richardson, 1989] <author> Joel Edward Richardson. E: </author> <title> A Persistent Systems Implementation Language. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> Aug. </month> <year> 1989. </year> <note> Available as Computer Sciences Technical Report #868. </note>
Reference-contexts: we will also be able to obtain an appreciation for the gains that compilation provides for swizzling, unswizzling, and profiling. 5 Related Work The only other work of which we are aware on optimizing persistent programs at compile time is that undertaken by Richardson in his database programming language E <ref> [Richardson, 1989] </ref>. He performs an optimization much like the redundant residency check elimination we have described. However, the other optimizations we have described are not performed in E. Importantly, an E object is always accessed via a level of indirection.
Reference: [Richardson and Carey, 1987] <author> Joel E. Richardson and Michael J. Carey. </author> <title> Programming constructs for database system implementations in EXODUS. </title> <booktitle> In Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data (San Francisco, </booktitle> <address> California, </address> <month> May </month> <year> 1987), </year> <booktitle> ACM SIGMOD Rec. </booktitle> <volume> 16, </volume> <month> 3 (Dec. </month> <year> 1987), </year> <pages> pp. 208-219. </pages>
Reference-contexts: This implementation approach is illustrated in Figure 1. 2.2 Extensions for persistence To incorporate persistence in Modula-3 we have extended its type system with another class of reference types: persistent references, similar to the db types of the E database programming language <ref> [Richardson and Carey, 1987] </ref>. A persistent reference type is indicated by the keyword persistent. A persistent reference indicates a specific data item, but that item may or may not be resident in memory.
Reference: [Shannon and Snodgrass, 1990] <author> Karen Shannon and Richard Snodgrass. </author> <title> Semantic clustering. </title> <editor> In [Dearle et al., </editor> <year> 1990]. </year>
Reference-contexts: However, the other optimizations we have described are not performed in E. Importantly, an E object is always accessed via a level of indirection. Our object faulting techniques and co-residency optimization eliminate such indirection. 13 Some progress has been made towards understanding clustering issues in persistent object stores <ref> [Benzaken, 1990; Benzaken and Delobel, 1990; Shannon and Snodgrass, 1990] </ref>. However, none of this work considers using clustering information at compile time to generate programs that run efficiently against the persistent store.
Reference: [Ungar, 1984] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Pittsburgh, </booktitle> <address> Pennsylvania, </address> <month> Apr. </month> <year> 1984), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984), </year> <pages> pp. 157-167. </pages>
Reference-contexts: We could scan the entire heap updating all pointers that refer to indirect blocks in evacuated chunks. To avoid scanning the entire heap we can keep track of all pointers into a chunk; for details of such an approach see <ref> [Ungar, 1984] </ref>. 4 Optimizing Persistent Programs The previous section indicated a straightforward implementation of persistence for Modula-3. In this section we look at improving the performance of persistent programs using compile-time optimization techniques.
Reference: [Wirth, 1983] <author> Niklaus Wirth. </author> <title> Programming in Modula-2, second, corrected ed. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: We have chosen Modula-3 as a vehicle for exploring optimization of persistent programs because it is strongly typed, compiled, and representative of a class of familiar languages, including Pascal [Jensen and Wirth, 1974] and Modula-2 <ref> [Wirth, 1983] </ref>. We are interested in exploring persistence in such a setting.
References-found: 17

