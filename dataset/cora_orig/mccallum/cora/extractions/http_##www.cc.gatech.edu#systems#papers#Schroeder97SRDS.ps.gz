URL: http://www.cc.gatech.edu/systems/papers/Schroeder97SRDS.ps.gz
Refering-URL: http://www.cs.gatech.edu/people/home/beth/
Root-URL: 
Email: sudhir@cs.binghamton.edu fbeths,schwang@cc.gatech.edu  
Title: Software Approach to Hazard Detection Using On-line Analysis of Safety Constraints  
Author: Beth Schroeder Sudhir Aggarwal Karsten Schwan 
Address: NY 13902 Atlanta, GA 30332  
Affiliation: State Univ. of New York College of Computing at Binghamton Georgia Institute of Technology Binghamton,  
Abstract: Hazard situations in safety-critical systems are typically complex, so there is a need for means to detect complex hazards and react in a timely and meaningful way. This paper addresses the problem of hazard detection through the development of an on-line analysis tool. The approach allows the user to specify complex multi-source hazards using a query-like language, uses both synchronous and asynchronous on-line checking approaches to balance efficiency and expressiveness, accommodates dynamic applications through dynamic constraint addition, and supports distributed and parallel applications running in heterogeneous environments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Tucker Balch and Ronald Arkin. </author> <title> Communication in reactive multiagent robot systems. </title> <booktitle> Autonomous Robots, </booktitle> <address> 1(1):2752, </address> <year> 1994. </year>
Reference-contexts: Related work is discussed in Section 5. We conclude in Section 6 with a discussion of current status and future work. 2 Autonomous Robots Example The application used in our work is a multiagent reactive robotic system simulation by Balch and Arkin <ref> [1] </ref> in their work on the Autonomous Robot Architecture (AuRA) at the Georgia Institute of Technology. The work was undertaken to investigate the importance of communication in robotic societies. The authors tested their strategy through an iteration of simulation and instantiation on real systems.
Reference: [2] <author> Monica Brockmeyer, Farnam Jahanian, Connie Heit--meyer, and Bruce Labaw. </author> <title> An approach to monitoring and assertion-checking of real time specifications in modechart. </title> <booktitle> In Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: The work is important to us though in that it defines a class of constraints specifiable and monitorable by our tool. The Monitoring and Assertion tool (MAC) <ref> [2] </ref> is a formal analysis technique for monitoring symbolic execution traces generated by the Modechart Toolset [3]. It provides a mechanism for evaluating properties of the system on a particular execution trace.
Reference: [3] <author> P. C. Clements, C. L. Heitmeyer, B. G. Labaw, and A. T. Rose. </author> <title> MT: A toolset for specifying and analyzing real-time systems. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: The work is important to us though in that it defines a class of constraints specifiable and monitorable by our tool. The Monitoring and Assertion tool (MAC) [2] is a formal analysis technique for monitoring symbolic execution traces generated by the Modechart Toolset <ref> [3] </ref>. It provides a mechanism for evaluating properties of the system on a particular execution trace. Leveson's work in the early 1980's [13] is early recognition of the need for run-time checking for hazard prevention. Her synchronous approach, though, requires embedding constraints in the application. On-line Application of Query Languages.
Reference: [4] <author> Ingeman J. Cox and Narian H. Gehani. </author> <title> Exception handling in robotics. </title> <booktitle> Computer, </booktitle> <address> 22(3):4349, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: To obviate the problem, the DISABLE clause is provided as a means for the user to manage the conflict. The enable and disable clauses are also useful for loosely hierarchical error recovery <ref> [4] </ref>. For example, when a robot encounters an obstacle in its path, its first response could be to wait some amount of time in the hope that the obstacle will move.
Reference: [5] <author> Greg Eisenhauer, Beth Schroeder, Karsten Schwan, Vernard Martin, and Jeffrey Vetter. DataExchange: </author> <title> High performance communication in distributed laboratories. </title> <booktitle> In Accepted for publication in 9th Int'l Conference on Parallel and Distributed Computing and Systems, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: More complex hazard descriptions also require a more general language, such as a query language, to distinguish events from mulitple sources and describe complex relationships between events in a natural way. To achieve efficient communication between multiple sources and the analysis tool, we employ a communication infrastructure, DataExchange <ref> [5] </ref>, developed at Georgia Tech. DataExchange provides for binary IO of event data between the multiple sources and the analysis tool.
Reference: [6] <author> Richard Gerber, Seongsoo Hong, and Manas Saksena. </author> <title> Guaranteeing end-to-end timing constraints by calibrating intermediate processes. </title> <booktitle> In Proceedings 15th Real Time Systems Symposium, pages 192203. IEEE, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: Assertion Checking in Real-Time Systems. Gerber's work <ref> [6] </ref> on guaranteeing end-to-end timing constraints is an automated design methodology that generates a solution for a set of tasks that keeps consistent a set of end-to-end timing constraints.
Reference: [7] <author> W. Hammer. </author> <title> Handbook of system and product safety. </title> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: But the goal of an intrinsically safe system is difficult to achieve for some of today's complex, dynamic applications running in parallel or distributed environments. Adopting guidelines established by system safety engineers <ref> [7] </ref>, if one cannot guarantee an fl This work was funded in part by NSF equipment grants CDA-9501637, CDA-9422033, and ECS-9411846. intrinsically safe system, the next preferred approach is a technique that prevents, minimizes, or detects the presence of hazards.
Reference: [8] <author> M. P. E. Heimdahl and Nancy G. Leveson. </author> <title> Completeness and consistency checking of software requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6), </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: A safe system is one that is free from accidents or unacceptable losses [17]. There is important research and development being done in providing intrinsically safe systems <ref> [8, 15, 16, 20, 21] </ref>, systems incapable of evolving into a state that could lead to injury or loss of life. But the goal of an intrinsically safe system is difficult to achieve for some of today's complex, dynamic applications running in parallel or distributed environments.
Reference: [9] <author> Carol Kilpatrick, Karsten Schwan, and David Ogle. </author> <title> Using languages for capture, analysis and display of performance information for parallel and distributed applications. </title> <booktitle> In Proceedings 1990 Int'l Conference on Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: It has been shown that the relational model is an appropriate formalism for the information processed by the monitor though earlier applications of this formalism to monitoring were primarily for performance evaluation <ref> [9, 23] </ref>. In addition, prior approaches to monitoring were static, that is, they required that all constraints be known at compile time.
Reference: [10] <author> Joh Kuhl, Douglas Evans, Yiannis Papelis, Richard Romano, and Ginger Watson. </author> <title> The Iowa Driving Simulator: An immersive research environment. </title> <booktitle> Computer, </booktitle> <address> 28(7):3541, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: We have applied our detection approach to a set of autonomous robots that can navigate toward a goal across unmapped terrain, `reacting' to stimuli in the environment. Envisioning more relaxed definitions of hazards, our detection approach is useful in many environments. For instance, in the Iowa Driving Simulator (IDS) <ref> [10] </ref> a fully immersive ground-vehicle simulator can place a driver in a highly realistic driving environment. Hazard conditions in such an environment are the same as in real-life but without the attendant risk of harm or loss.
Reference: [11] <author> Nancy Leveson. </author> <title> An investigation of the Therac-25 accidents. </title> <booktitle> Computer, </booktitle> <address> 26(7):1841, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: One of the more tragic examples involved the Therac-25, a therapeutic linear accelerator. Six people either died or suffered serious injuries from massive overdoses of radiation between 1985 and 1987 before the problems were acknowledged and corrected <ref> [11] </ref>. A safe system is one that is free from accidents or unacceptable losses [17]. There is important research and development being done in providing intrinsically safe systems [8, 15, 16, 20, 21], systems incapable of evolving into a state that could lead to injury or loss of life.
Reference: [12] <author> Nancy G. Leveson. </author> <title> Software safety in embedded computer systems. </title> <journal> Communications of the ACM, </journal> <pages> pages 3446, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Automatic pressure relief valves, lockins, lockouts, and interlocks are common hardware hazard prevention approaches. An example of a software approach is a trip computer in a nuclear power plant that initiates procedures to shutdown the plant when operating conditions are hazardous <ref> [12] </ref>. The research here addresses the problem of enhancing software safety through hazard detection. The premise of our work is that hazard situations can and do occur, and are often complex, involving multiple sources. <p> a virtual reality driving simulator, allowing developers to play what-if scenarios by iteratively adjusting speed and environmental conditions to determine what combination of conditions will be classified a hazard to which the simulator will react. 1.1 Problem and Solution Strategy Hazard detection is a viable approach to improving software safety <ref> [12] </ref> and, in some cases, is the only approach. <p> Linking queries takes place when a node registers itself with the dispatcher. 4.2 Multi-Source Hazards Multisource hazards, hazards which can be described as consisting of events from multiple sources, make up an important and substantial subset of hazard descriptions <ref> [12] </ref>. Implementing detection of such hazards requires making tradeoffs between latency, perturbation, and ease of use. Latency is far more of an issue in external approaches to hazard detection than it is, for example, when constraints are embedded directly in the application code.
Reference: [13] <author> Nancy G. Leveson and Timothy J. Shimeall. </author> <title> Safety assertions for process-control systems. </title> <booktitle> In Proceedings 13th Int'l Symposium on Fault Tolerant Computing, </booktitle> <pages> pages 236240, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: The Monitoring and Assertion tool (MAC) [2] is a formal analysis technique for monitoring symbolic execution traces generated by the Modechart Toolset [3]. It provides a mechanism for evaluating properties of the system on a particular execution trace. Leveson's work in the early 1980's <ref> [13] </ref> is early recognition of the need for run-time checking for hazard prevention. Her synchronous approach, though, requires embedding constraints in the application. On-line Application of Query Languages.
Reference: [14] <author> Ling Liu, Calton Pu, Roger Barga, and Tong Zhou. </author> <title> Differential evaluation of continual queries. </title> <type> Technical Report TR95-17, </type> <institution> Department of Computer Science, University of Alberta, </institution> <year> 1996. </year>
Reference-contexts: Leveson's work in the early 1980's [13] is early recognition of the need for run-time checking for hazard prevention. Her synchronous approach, though, requires embedding constraints in the application. On-line Application of Query Languages. In Liu and Pu's work on continual queries <ref> [14] </ref>, a client specifies continual queries over information stored in a distributed inter-operable environment such as the Internet. The objective is to compute the query and return the entire resulting relation upon the first triggering only. On subsequent triggerings, only the add, modify, and delete change information is returned.
Reference: [15] <author> Robyn R. Lutz. </author> <title> Targeting safety related errors during software requirements analysis. </title> <booktitle> In Proceedings 1st ACM SIGSOFT Symposium on Foundations of Software Engineering. ACM, </booktitle> <year> 1993. </year>
Reference-contexts: A safe system is one that is free from accidents or unacceptable losses [17]. There is important research and development being done in providing intrinsically safe systems <ref> [8, 15, 16, 20, 21] </ref>, systems incapable of evolving into a state that could lead to injury or loss of life. But the goal of an intrinsically safe system is difficult to achieve for some of today's complex, dynamic applications running in parallel or distributed environments.
Reference: [16] <author> Louise E. Moser and P.M. Melliar-Smith. </author> <title> Formal verification of safety-critical systems. </title> <journal> Software Practice and Experience, </journal> <volume> 20(8):799821, </volume> <month> August </month> <year> 1990. </year> <note> [17] title = Nancy G. Leveson, editor. </note>
Reference-contexts: A safe system is one that is free from accidents or unacceptable losses [17]. There is important research and development being done in providing intrinsically safe systems <ref> [8, 15, 16, 20, 21] </ref>, systems incapable of evolving into a state that could lead to injury or loss of life. But the goal of an intrinsically safe system is difficult to achieve for some of today's complex, dynamic applications running in parallel or distributed environments.
Reference: [18] <author> Peter G. Neumann. </author> <title> Computer Related Risks. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: For example, the confluence of events that caused the 1990 AT&T system runaway (a combination of heavy load, software errors, and neighboring switches) caused a 9 hour nationwide blockade that was not anticipated despite extensive testing of the involved 114 electronic switching systems <ref> [18] </ref>. Multiple cause failures such as this can be most easily mitigated with detection oriented approaches. Our goal is to provide such a detection approach through on-line hazard analysis.
Reference: [19] <author> John Ousterhout. </author> <title> Tcl and the Tk toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: From a sensor specification it generates sensor definitions that are used to instrument the application code. Information about sensor definitions is also used in calls to the library. The safety constraint specifications are compiled into a sequence of Tcl <ref> [19] </ref> commands which are executed by the Tcl interpreter resident in the executable. The interpreter is used initially when the graph is being created and thereafter only when a constraint is dynamically added to Cnet, so the performance impact generally associated with interpreters is minimized.
Reference: [20] <author> Vivek Ratan, Kurt Partridge, Jon Reese, and Nancy G. Leveson. </author> <title> Safety analysis tools for requirements specifications. </title> <booktitle> In Proceedings Compass96, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: A safe system is one that is free from accidents or unacceptable losses [17]. There is important research and development being done in providing intrinsically safe systems <ref> [8, 15, 16, 20, 21] </ref>, systems incapable of evolving into a state that could lead to injury or loss of life. But the goal of an intrinsically safe system is difficult to achieve for some of today's complex, dynamic applications running in parallel or distributed environments.
Reference: [21] <author> Joh Damon Reese and Nancy G. Leveson. </author> <title> Software deviation analysis: A safeware technique. </title> <type> Technical report, </type> <institution> University of Washington, </institution> <year> 1996. </year>
Reference-contexts: A safe system is one that is free from accidents or unacceptable losses [17]. There is important research and development being done in providing intrinsically safe systems <ref> [8, 15, 16, 20, 21] </ref>, systems incapable of evolving into a state that could lead to injury or loss of life. But the goal of an intrinsically safe system is difficult to achieve for some of today's complex, dynamic applications running in parallel or distributed environments.
Reference: [22] <author> Beth Schroeder, Sudhir Aggarwal, and Karsten Schwan. </author> <title> Hazard detection using on-line analysis of safety constraints. </title> <type> Technical Report GIT-CC-97-01, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1997. </year> <note> http://www.cc.gatech.edu/tech reports. </note>
Reference-contexts: The rule compiler parses a constraint, and converts it to a relational algebraic expression in conjunctive normal form. From the relational algebraic expression an abstract syntax tree is constructed and it is from this that the optimizer performs compile-time optimization before generating a sequence of Tcl commands <ref> [22] </ref>. So roughly for every select, project, and cartesian product operation in the relational algebraic expression, there is a corresponding Tcl command in the script file.
Reference: [23] <author> Richard Snodgrass. </author> <title> A relational approach to monitoring complex systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 6(2):156196, </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: Snodgrass has shown that a relational database query language can be used beneficially to specify queries that are evaluated against event streams such as are generated with on-line monitoring <ref> [23] </ref>. The significant difference between evaluating queries against a database and evaluating them against an event stream is that in the latter constraints must be evaluated against a conceptual database rather than an actual database. That is, no database per se exists. <p> It has been shown that the relational model is an appropriate formalism for the information processed by the monitor though earlier applications of this formalism to monitoring were primarily for performance evaluation <ref> [9, 23] </ref>. In addition, prior approaches to monitoring were static, that is, they required that all constraints be known at compile time.
Reference: [24] <author> Richard T. Snodgrass, </author> <title> editor. The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: The if clause specifies the rule's condition. The condition is the constraint that is checked when the rule is triggered by an incoming event. Our language uses the temporal query language ATSQL2 for specifying the condition. ATSQL2 is a variant of TSQL2 <ref> [24] </ref> and is currently being proposed for incorporation into SQL3 [25]. The condition can be any valid ATSQL2 query. The then clause specifies the rule's actions. An action is executed when the rule is triggered and its condition is true. Actions are discussed in Section 3.2.
Reference: [25] <author> Richard T. Snodgrass, Michael H. Bohlen, Christian S. Jensen, and Andreas Steiner. </author> <title> Adding valid time to SQL/temporal. </title> <editor> In ISO/IEC JTC1/SC21/WG3 DBL MAD-146r2, </editor> <month> November </month> <year> 1996. </year>
Reference-contexts: The condition is the constraint that is checked when the rule is triggered by an incoming event. Our language uses the temporal query language ATSQL2 for specifying the condition. ATSQL2 is a variant of TSQL2 [24] and is currently being proposed for incorporation into SQL3 <ref> [25] </ref>. The condition can be any valid ATSQL2 query. The then clause specifies the rule's actions. An action is executed when the rule is triggered and its condition is true. Actions are discussed in Section 3.2.
Reference: [26] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings 14th SOSP, </booktitle> <pages> pages 175188, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Predictable performance guarantees can be made because of the DAG restriction on the constraint graph. Low perturbation is achieved through the use of a separate thread to perform monitoring and synchronous constraint checking. Perturbation could be further reduced by employing a technique used in software fault isolation <ref> [26] </ref> of embedding monitoring related instructions in open slots in the instruction stream. A multi-source hazard is a hazard that occurs when a combination of conditions exist: a failed valve indicator, condensate pump out of order, and a relief valve failing to close, for example.
Reference: [27] <author> Jennifer Widom and Stefano Ceri, </author> <title> editors. Active Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: A query language, on the other hand, given its declarative style and ease of use, is suitable. The language we have adopted for our use is based on the active database rule definition language of the Starburst system <ref> [27] </ref>. The language consists of five commands: create rule, alter rule, drop rule, activate rule, and deactivate rule. The create rule is used to define a new constraint.
References-found: 26

