URL: ftp://ftp.cs.umass.edu/pub/osl/papers/crl-92-07.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Transactional Memory: Architectural Support for Lock-Free Data Structures  
Author: Maurice Herlihy J. Eliot B. Moss 
Date: CRL 92/07 December 1, 1992  
Affiliation: Digital Equipment Corporation Cambridge Research Lab  
Abstract: A shared data structure is lock-free if its operations do not require mutual exclusion. If one process is interrupted in the middle of an operation, other processes will not be prevented from operating on that object. In highly concurrent systems, lock-free data structures avoid common problems associated with conventional locking techniques, including priority inversion, convoying, and difficulty of avoiding deadlock. This paper introduces transactional memory, a new multiprocessor architecture that supports lock-free implementations of complex data structures in a simple and efficient way. Transactional memory allows programmers to define customized read-modify-write operations that apply to multiple, independently-chosen words of memory. It is implemented by straightforward extensions to any ownership-based multiprocessor cache-coherence protocol. Simulation results show that transactional memory outperforms the best known locking techniques for simple benchmarks, even in the absence of priority inversion, convoying, and deadlock. c flDigital Equipment Corporation and J.E.B. Moss 1992. All rights reserved.
Abstract-found: 1
Intro-found: 1
Reference: [Agarwal et al., 1991] <author> A. Agarwal et al. </author> <title> The MIT Alewife machine: A large-scale distributed-memory multiprocessor. </title> <type> Tech. Rep. </type> <institution> TM-454, MIT Lab for Computer Science, 545 Technology Square, </institution> <address> Cambridge MA 02139, </address> <month> Mar. </month> <year> 1991. </year> <note> Extended version submitted for publication. </note>
Reference-contexts: Proteus does not capture the effects of instruction caches or local caches. We implemented both the extended version of Goodman's snoopy protocol, on a 32-processor bus-based architecture, and the extended version of the Chaiken directory protocol, on a 32-processor (simulated) Alewife <ref> [Agarwal et al., 1991] </ref>. In both simulations, the regular cache is a direct-mapped cache with 2048 lines of size 8 bytes, and the transactional cache has 64 8-byte lines.
Reference: [Anderson, 1990] <author> T.E. Anderson. </author> <title> The performance of spin lock alternatives for shared-memory multipro cessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 1 (Jan. </month> <year> 1990), </year> <pages> 6-16. </pages>
Reference-contexts: If either the VALIDATE or the COMMIT fails, the process returns to Step (1). For objects where contention is high, programmers are advised to apply some kind of adaptive backoff <ref> [Anderson, 1990; Metcalfe and Boggs, 1976] </ref> before retrying. A more complex transaction, such as one that chains down a linked list, would alternate LT and VALIDATE instructions. 3 Implementing Transactional Memory In this section, we give an overview of an architecture that supports transactional memory. <p> We originally considered incorporating a backoff strategy in the cache coherence protocol itself. Our simulations, however, show that backoff schemes need to be tuned to perform well, and so hardware backoff seems overly inflexible. Anderson <ref> [Anderson, 1990] </ref> reports a similar experience in alleviating contention for spin locks: exponential backoff works well, but the parameters must be chosen carefully. <p> We constructed three simple benchmarks, and ran them with four different synchronization mechanisms: (1) transactional memory with user-level exponential backoff, (2) test-and-test-and-set (TTS) [Rudolph, 1983] spin locks with exponential backoff <ref> [Anderson, 1990; Metcalfe and Boggs, 1976] </ref> (Figure 21), (3) LOAD LINKED/STORE COND (LL/SC) spin locks with exponential backoff, and (4) queue locks [Anderson, 1990; Graunke and Thakkar, 1990; Mellor-Crummey and Scott, 1991]. For a single-word counter benchmark, we also ran a LL/SC implementation directly on the shared variable. <p> three simple benchmarks, and ran them with four different synchronization mechanisms: (1) transactional memory with user-level exponential backoff, (2) test-and-test-and-set (TTS) [Rudolph, 1983] spin locks with exponential backoff [Anderson, 1990; Metcalfe and Boggs, 1976] (Figure 21), (3) LOAD LINKED/STORE COND (LL/SC) spin locks with exponential backoff, and (4) queue locks <ref> [Anderson, 1990; Graunke and Thakkar, 1990; Mellor-Crummey and Scott, 1991] </ref>. For a single-word counter benchmark, we also ran a LL/SC implementation directly on the shared variable. All the locking implementations perform synchronization in-line, and all schemes that use exponential backoff use the same fixed minimum and maximum backoff durations. <p> We now give a brief review of the three locking techniques. A spin lock is perhaps the simplest way to implement mutual exclusion. Each processor repeatedly applies a test-and-set operation until it succeeds in acquiring the lock. As discussed in more detail by Anderson <ref> [Anderson, 1990] </ref>, this nave technique performs poorly because it consumes excessive amounts of processor-to-memory bandwidth. <p> Even better performance is achieved by introducing an exponential delay after each unsuccessful attempt to acquire a lock <ref> [Anderson, 1990; Mellor-Crummey and Scott, 1991] </ref>. Because Anderson and Mellor-Crummey et al. have shown that TTS locks with exponential backoff substantially outperform conventional TTS locks on small-scale machines, it is a natural choice for our experiments. The LL operation copies the value of a shared variable to a local variable. <p> The process waits until the indexed value in the array becomes True, and then enters the critical section. When it leaves the critical section, it informs the process with the next higher index by setting its array value to True. Variations of queue locks have been proposed by Anderson <ref> [Anderson, 1990] </ref>, by Mellor-Crummey and Scott [Mellor-Crummey and Scott, 1991], and by Graunke and Thakkar [Graunke and Thakkar, 1990]. This technique produces low memory contention, since processes spin on different cached locations, and has been observed to perform well on small-scale bus-based architectures. <p> Note that despite superficial similarities in terminology, the synchronization mechanisms provided by transactional memory and by the 801 are intended for entirely different purposes, and use entirely different techniques. Our approach to performance issues has been heavily influenced by recent work on locking in multiprocessors, including work of Anderson <ref> [Anderson, 1990] </ref>, Bershad [Bershad, 1991], Graunke and Thakkar 8 DISCUSSION AND RELATED WORK 37 [Graunke and Thakkar, 1990], and Mellor-Crummey and Scott [Mellor-Crummey and Scott, 1991]. REFERENCES 38
Reference: [Bershad, 1991] <author> B.N. Bershad. </author> <title> Practical considerations for lock-free concurrent objects. </title> <type> Tech. Rep. </type> <institution> CMU CS-91-183, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Our approach to performance issues has been heavily influenced by recent work on locking in multiprocessors, including work of Anderson [Anderson, 1990], Bershad <ref> [Bershad, 1991] </ref>, Graunke and Thakkar 8 DISCUSSION AND RELATED WORK 37 [Graunke and Thakkar, 1990], and Mellor-Crummey and Scott [Mellor-Crummey and Scott, 1991]. REFERENCES 38
Reference: [Brewer et al., 1991] <author> E. A. Brewer, C. N. Dellarocas, A. Colbrook, and W. E. Weihl. PROTEUS: </author> <title> A high performance parallel architecture simulator. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-516, Massachusetts Institute of Technology, </institution> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Such a change would incur a cost, however, because an orphan transaction might sometimes have to read the variable's value from memory or another processor's cache. 7 Simulation Results To gain some insight into the performance of transactional memory, we modified a copy of the Proteus simulator <ref> [Brewer et al., 1991] </ref> to support transactional memory. Proteus is an execution-driven simulator system for multiprocessors developed by Eric Brewer and Chris Dellarocas of MIT. The program to be simulated is written in a superset of C.
Reference: [Chaiken, 1990] <author> D.L. Chaiken. </author> <title> Cache coherence protocols for large-scale multiprocessors. </title> <type> Tech. Rep. </type> <institution> MIT/LCS/TR-489, MIT LCS, </institution> <type> 545 Tech Square, </type> <address> Cambridge MA 02139, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: A hybrid approach is an attractive way to eliminate priority inversion completely: higher-priority transactions can (optimistically) revoke ownership from lower-priority transactions, but not vice-versa. 5 A DIRECTORY-BASED PROTOCOL 16 5 A Directory-Based Protocol In this section we show how to modify Chaiken's directory-based protocol <ref> [Chaiken, 1990; Chaiken et al., 1991] </ref> to support transactional memory. The regular cache runs Chaiken's protocol without modification, using the same states, messages, and transitions. The cache line states, shown in Figure 12, are the same as in Chaiken's protocol.
Reference: [Chaiken et al., 1991] <author> D. Chaiken, J. Kubiatowicz, and A. Agarwal. </author> <title> LimitLESS directories: a scalable cache coherence scheme. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Langauges and Operating Systems (Apr. 1991), ACM, </booktitle> <pages> pp. 224-234. </pages>
Reference-contexts: The size of the transactional cache must be at least the minimal transaction size guaranteed by the architecture. An alternative approach is suggested by the LimitLESS directory-based cache consistency scheme of Chaiken, Kubiatowicz, and Agarwal <ref> [Chaiken et al., 1991] </ref>. This scheme uses a fast, fixed-size hardware implementation for directories. If a directory overflows, the protocol traps into software, and the software emulates a larger directory. A similar approach might be used to respond to transactional 4 A BUS-BASED PROTOCOL 6 cache overflow. <p> A hybrid approach is an attractive way to eliminate priority inversion completely: higher-priority transactions can (optimistically) revoke ownership from lower-priority transactions, but not vice-versa. 5 A DIRECTORY-BASED PROTOCOL 16 5 A Directory-Based Protocol In this section we show how to modify Chaiken's directory-based protocol <ref> [Chaiken, 1990; Chaiken et al., 1991] </ref> to support transactional memory. The regular cache runs Chaiken's protocol without modification, using the same states, messages, and transitions. The cache line states, shown in Figure 12, are the same as in Chaiken's protocol.
Reference: [Chang and Mergen, 1988] <author> A. Chang and M.F. Mergen. </author> <title> 801 storage: Architecture and programming. </title> <journal> ACM Transactions on Computer Systems 6, </journal> <month> 1 (Feb. </month> <year> 1988), </year> <pages> 28-50. </pages>
Reference-contexts: Other researchers who have investigated architectural support for multi-word synchronization include Knight [Knight, 1986], who suggests using cache consistency protocols to add parallelism to mostly functional LISP programs, and the IBM 801 <ref> [Chang and Mergen, 1988] </ref>, which provides support for database-style locking in hardware. Note that despite superficial similarities in terminology, the synchronization mechanisms provided by transactional memory and by the 801 are intended for entirely different purposes, and use entirely different techniques.
Reference: [Digital Equipment Corporation] <author> Digital Equipment Corporation. </author> <title> Alpha system reference manual. </title>
Reference-contexts: If the operation does not succeed, it leaves the shared variable unchanged. The LL/SC operations are the principal synchronization primitives provided by the MIPS R4000 [Kane, 1989] and Digital's Alpha <ref> [Digital Equipment Corporation] </ref>. On a cache-coherent architecture, these operations are implemented as single-word transactions a SC succeeds if the processor retains exclusive ownership of the entry read by the LL. <p> and dequeues to overlap. 8 DISCUSSION AND RELATED WORK 34 8 Discussion and Related Work Transactional memory is a direct generalization of the load-linked (LL) and store-conditional (SC) instructions proposed by Jensen et al. [Jensen et al., 1987], and since incorporated into the MIPS R4000 [Kane, 1989] and Digital's Alpha <ref> [Digital Equipment Corporation] </ref>. The LL instruction is essentially the same as LTX, and SC is a combination of ST and COMMIT. The LL/SC can implement any read-modify-write operation, but it is restricted to a single word. Transactional memory has the same flexibility, but can operate on multiple, independently-chosen words.
Reference: [Dubois and Scheurich, 1990] <author> Michel Dubois and Christoph Scheurich. </author> <title> Memory access dependencies in shared-memory multiprocessors. </title> <journal> IEEE Transactions on Software Engineering 16, </journal> <month> 6 (June </month> <year> 1990), </year> <pages> 660-673. </pages>
Reference-contexts: Transactional memory provides more powerful support for this lock-free style of programming. The literature includes a variety of memory consistency models, including sequential consistency [Lamport, 1979], processor consistency [Goodman, 1989], weak consistency <ref> [Dubois et al., 1986; Dubois and Scheurich, 1990] </ref>, and release consistency [Gharachorloo et al., 1990] 3 . Of these, transactional memory most closely resembles release consistency. LT, LTX, and ST are similar to ACQUIRE, and COMMIT is similar to RELEASE.
Reference: [Dubois et al., 1986] <author> Michel Dubois, Christoph Scheurich, and Fay e Briggs. </author> <title> Memory access buffering in multiprocessors. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture (June 1986), </booktitle> <pages> pp. 434-442. </pages>
Reference-contexts: Transactional memory provides more powerful support for this lock-free style of programming. The literature includes a variety of memory consistency models, including sequential consistency [Lamport, 1979], processor consistency [Goodman, 1989], weak consistency <ref> [Dubois et al., 1986; Dubois and Scheurich, 1990] </ref>, and release consistency [Gharachorloo et al., 1990] 3 . Of these, transactional memory most closely resembles release consistency. LT, LTX, and ST are similar to ACQUIRE, and COMMIT is similar to RELEASE.
Reference: [Gharachorloo et al., 1991] <author> Kourosh Gharachorloo, Anoop Gupta, and John Hennessy. </author> <title> Performance eval uation of memory consistency models for shared-memory multiprocessors. </title> <booktitle> In Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (Apr. </booktitle> <year> 1991), </year> <pages> pp. 245-257. REFERENCES 39 </pages>
Reference-contexts: LT, LTX, and ST are similar to ACQUIRE, and COMMIT is similar to RELEASE. Perhaps the most significant difference is that transactions can abort, and do so consistently and cleanly. We distinguish transactional and non-transactional memory operations, and private memory 3 See Gharachorloo et al. <ref> [Gharachorloo et al., 1991] </ref> for concise descriptions of these models as well as performance comparisons. 8 DISCUSSION AND RELATED WORK 35 typedef struct list_elem struct list_elem *next; /* next to dequeue */ struct list_elem *prev; /* previously enqueued */ int value; entry; shared entry *Head, *Tail; void list_enq (entry* new) entry
Reference: [Gharachorloo et al., 1990] <author> Kourosh Gharachorloo, Dan Lenoski, James Laudon, Phillip Gibbons, Anoop Gupta, and John Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture (June 1990), </booktitle> <pages> pp. 15-26. </pages>
Reference-contexts: Transactional memory provides more powerful support for this lock-free style of programming. The literature includes a variety of memory consistency models, including sequential consistency [Lamport, 1979], processor consistency [Goodman, 1989], weak consistency [Dubois et al., 1986; Dubois and Scheurich, 1990], and release consistency <ref> [Gharachorloo et al., 1990] </ref> 3 . Of these, transactional memory most closely resembles release consistency. LT, LTX, and ST are similar to ACQUIRE, and COMMIT is similar to RELEASE. Perhaps the most significant difference is that transactions can abort, and do so consistently and cleanly.
Reference: [Goodman, 1983] <author> J.R. Goodman. </author> <title> Using cache memory to reduce processor-memory traffic. </title> <booktitle> In Proceedings of the 12th International Symposium on Computer Architecture (June 1983), IEEE, </booktitle> <pages> pp. 124-131. </pages>
Reference-contexts: Finally, the use of custom logic to reset transactional tags in parallel ensures that commit and abort operations are fast. 4 A Bus-Based Protocol We show here how to modify the simplest ownership-based protocol, Goodman's snoopy protocol for a shared bus <ref> [Goodman, 1983] </ref>. (In a later section, we apply the same techniques to a directory-based protocol.) The regular cache runs Goodman's protocol without modification, using the same states, bus cycles, and transitions. Each line in both the regular and transactional cache has a state, as summarized in Figure 2.
Reference: [Goodman, 1989] <author> James R. Goodman. </author> <title> Cache consistency and sequential consistency. </title> <type> Technical Report 61, </type> <institution> SCI Committee, </institution> <month> Mar. </month> <year> 1989. </year>
Reference-contexts: This instruction was used by Massalin and Pu [Massalin and Pu, 1991] for lock-free list manipulation in an operating system kernel. Transactional memory provides more powerful support for this lock-free style of programming. The literature includes a variety of memory consistency models, including sequential consistency [Lamport, 1979], processor consistency <ref> [Goodman, 1989] </ref>, weak consistency [Dubois et al., 1986; Dubois and Scheurich, 1990], and release consistency [Gharachorloo et al., 1990] 3 . Of these, transactional memory most closely resembles release consistency. LT, LTX, and ST are similar to ACQUIRE, and COMMIT is similar to RELEASE.
Reference: [Graunke and Thakkar, 1990] <author> G. Graunke and S. Thakkar. </author> <title> Synchronization algorithms for shared-memory multiprocessors. </title> <booktitle> IEEE Computer 23, </booktitle> <month> 6 (June </month> <year> 1990), </year> <pages> 60-70. </pages>
Reference-contexts: three simple benchmarks, and ran them with four different synchronization mechanisms: (1) transactional memory with user-level exponential backoff, (2) test-and-test-and-set (TTS) [Rudolph, 1983] spin locks with exponential backoff [Anderson, 1990; Metcalfe and Boggs, 1976] (Figure 21), (3) LOAD LINKED/STORE COND (LL/SC) spin locks with exponential backoff, and (4) queue locks <ref> [Anderson, 1990; Graunke and Thakkar, 1990; Mellor-Crummey and Scott, 1991] </ref>. For a single-word counter benchmark, we also ran a LL/SC implementation directly on the shared variable. All the locking implementations perform synchronization in-line, and all schemes that use exponential backoff use the same fixed minimum and maximum backoff durations. <p> When it leaves the critical section, it informs the process with the next higher index by setting its array value to True. Variations of queue locks have been proposed by Anderson [Anderson, 1990], by Mellor-Crummey and Scott [Mellor-Crummey and Scott, 1991], and by Graunke and Thakkar <ref> [Graunke and Thakkar, 1990] </ref>. This technique produces low memory contention, since processes spin on different cached locations, and has been observed to perform well on small-scale bus-based architectures. <p> Our approach to performance issues has been heavily influenced by recent work on locking in multiprocessors, including work of Anderson [Anderson, 1990], Bershad [Bershad, 1991], Graunke and Thakkar 8 DISCUSSION AND RELATED WORK 37 <ref> [Graunke and Thakkar, 1990] </ref>, and Mellor-Crummey and Scott [Mellor-Crummey and Scott, 1991]. REFERENCES 38
Reference: [Gray, 1978] <editor> J.N. Gray. </editor> <booktitle> Notes on Database Operating Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1978, </year> <pages> pp. 393-481. </pages>
Reference-contexts: When the transaction completes, it either commits, making its changes visible to other processes (effectively) instantaneously, or it aborts, causing its changes to be discarded. The notion of a transaction originated in the database literature (viz. <ref> [Gray, 1978] </ref>). Our transactions satisfy the same formal serializability and atomicity properties, but they are implemented using different techniques, and they have different intended applications. Unlike database transactions, our transactions are intended to be short-lived activities that access a relatively small number of memory locations in primary memory.
Reference: [Herlihy, 1990] <author> M.P. Herlihy. </author> <title> A methodology for implementing highly concurrent data structures. </title> <booktitle> In Pro ceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (Mar. </booktitle> <year> 1990), </year> <pages> pp. 197-206. </pages>
Reference: [Jensen et al., 1987] <author> E.H. Jensen, G.W. Hagensen, and J.M. Broughton. </author> <title> A new approach to exclusive data access in shared memory multiprocessors. </title> <type> Tech. Rep. </type> <institution> UCRL-97663, Lawrence Livermore National Laboratory, </institution> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: The locking implementations have substantially lower throughput, primarily because they because never allow enqueues and dequeues to overlap. 8 DISCUSSION AND RELATED WORK 34 8 Discussion and Related Work Transactional memory is a direct generalization of the load-linked (LL) and store-conditional (SC) instructions proposed by Jensen et al. <ref> [Jensen et al., 1987] </ref>, and since incorporated into the MIPS R4000 [Kane, 1989] and Digital's Alpha [Digital Equipment Corporation]. The LL instruction is essentially the same as LTX, and SC is a combination of ST and COMMIT.
Reference: [Jouppi, 1990] <author> N. Jouppi. </author> <title> Improving direct mapped cache performance by the addition of a small fully associative cache and prefetch buffers. </title> <booktitle> In 17th Annual Internationall Symposium on Computer Architecture (June 1990), ACM SIGARCH, </booktitle> <address> p. </address> <month> 364. </month>
Reference-contexts: If a transactional cache has that entry, it will provide the TC NORMAL or TC COMMIT value. As a further optimization, if one provides a fast data path between a processor's regular and transactional caches, then the regular cache could use the transactional cache as a victim cache <ref> [Jouppi, 1990] </ref>, where entries evicted from the normal cache are moved (as TC NORMAL entries) to the nearby victim cache instead of the faraway memory. Let us review the design considerations given above. Non-transactional operations interact exclusively with conventional caches executing conventional cache consistency protocols.
Reference: [Kane, 1989] <author> G. Kane. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: A subsequent SC to that variable will succeed in changing its value only if no other process has modified that variable in the interim. If the operation does not succeed, it leaves the shared variable unchanged. The LL/SC operations are the principal synchronization primitives provided by the MIPS R4000 <ref> [Kane, 1989] </ref> and Digital's Alpha [Digital Equipment Corporation]. On a cache-coherent architecture, these operations are implemented as single-word transactions a SC succeeds if the processor retains exclusive ownership of the entry read by the LL. <p> they because never allow enqueues and dequeues to overlap. 8 DISCUSSION AND RELATED WORK 34 8 Discussion and Related Work Transactional memory is a direct generalization of the load-linked (LL) and store-conditional (SC) instructions proposed by Jensen et al. [Jensen et al., 1987], and since incorporated into the MIPS R4000 <ref> [Kane, 1989] </ref> and Digital's Alpha [Digital Equipment Corporation]. The LL instruction is essentially the same as LTX, and SC is a combination of ST and COMMIT. The LL/SC can implement any read-modify-write operation, but it is restricted to a single word.
Reference: [Knight, 1986] <author> T. Knight. </author> <title> An achitecture for mostly functional languages. </title> <booktitle> In Conference on Lisp and Functional Programming (Aug. </booktitle> <year> 1986), </year> <pages> pp. 105-112. </pages>
Reference-contexts: The element's initialization must take effect before that transaction commits, suggesting that COMMIT and VALIDATE should perhaps implicitly perform barriers. Other researchers who have investigated architectural support for multi-word synchronization include Knight <ref> [Knight, 1986] </ref>, who suggests using cache consistency protocols to add parallelism to mostly functional LISP programs, and the IBM 801 [Chang and Mergen, 1988], which provides support for database-style locking in hardware.
Reference: [Lamport, 1979] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multi process programs. </title> <journal> IEEE Transactions on Computers C-28, </journal> <month> 9 (Sept. </month> <year> 1979), </year> <pages> 241-248. </pages>
Reference-contexts: This instruction was used by Massalin and Pu [Massalin and Pu, 1991] for lock-free list manipulation in an operating system kernel. Transactional memory provides more powerful support for this lock-free style of programming. The literature includes a variety of memory consistency models, including sequential consistency <ref> [Lamport, 1979] </ref>, processor consistency [Goodman, 1989], weak consistency [Dubois et al., 1986; Dubois and Scheurich, 1990], and release consistency [Gharachorloo et al., 1990] 3 . Of these, transactional memory most closely resembles release consistency. LT, LTX, and ST are similar to ACQUIRE, and COMMIT is similar to RELEASE.
Reference: [Massalin and Pu, 1991] <author> H. Massalin and C. Pu. </author> <title> A lock-free multiprocessor OS kernel. </title> <type> Tech. Rep. </type> <institution> CUCS 005-91, Columbia University Computer Science Dept., </institution> <year> 1991. </year>
Reference-contexts: We are not the first to observe the utility of performing atomic operations on multiple locations. For example, the Motorola 68000 provides a COMPARE&SWAP2 operation that operates on two independent locations. This instruction was used by Massalin and Pu <ref> [Massalin and Pu, 1991] </ref> for lock-free list manipulation in an operating system kernel. Transactional memory provides more powerful support for this lock-free style of programming.
Reference: [Mellor-Crummey, 1987] <author> J.M. Mellor-Crummey. </author> <title> Practical fetch-and-phi algorithms. </title> <type> Tech. Rep. Technical Report 229, </type> <institution> Computer Science Dept., University of Rochester, </institution> <month> Nov. </month> <year> 1987. </year> <note> REFERENCES 40 </note>
Reference: [Mellor-Crummey and Scott, 1991] <author> John M. Mellor-Crummey and Michael L. Scott. </author> <title> Algorithms for scal able synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 9, </volume> <month> 1 (Feb. </month> <year> 1991), </year> <pages> 21-65. </pages>
Reference-contexts: three simple benchmarks, and ran them with four different synchronization mechanisms: (1) transactional memory with user-level exponential backoff, (2) test-and-test-and-set (TTS) [Rudolph, 1983] spin locks with exponential backoff [Anderson, 1990; Metcalfe and Boggs, 1976] (Figure 21), (3) LOAD LINKED/STORE COND (LL/SC) spin locks with exponential backoff, and (4) queue locks <ref> [Anderson, 1990; Graunke and Thakkar, 1990; Mellor-Crummey and Scott, 1991] </ref>. For a single-word counter benchmark, we also ran a LL/SC implementation directly on the shared variable. All the locking implementations perform synchronization in-line, and all schemes that use exponential backoff use the same fixed minimum and maximum backoff durations. <p> Even better performance is achieved by introducing an exponential delay after each unsuccessful attempt to acquire a lock <ref> [Anderson, 1990; Mellor-Crummey and Scott, 1991] </ref>. Because Anderson and Mellor-Crummey et al. have shown that TTS locks with exponential backoff substantially outperform conventional TTS locks on small-scale machines, it is a natural choice for our experiments. The LL operation copies the value of a shared variable to a local variable. <p> When it leaves the critical section, it informs the process with the next higher index by setting its array value to True. Variations of queue locks have been proposed by Anderson [Anderson, 1990], by Mellor-Crummey and Scott <ref> [Mellor-Crummey and Scott, 1991] </ref>, and by Graunke and Thakkar [Graunke and Thakkar, 1990]. This technique produces low memory contention, since processes spin on different cached locations, and has been observed to perform well on small-scale bus-based architectures. <p> Our approach to performance issues has been heavily influenced by recent work on locking in multiprocessors, including work of Anderson [Anderson, 1990], Bershad [Bershad, 1991], Graunke and Thakkar 8 DISCUSSION AND RELATED WORK 37 [Graunke and Thakkar, 1990], and Mellor-Crummey and Scott <ref> [Mellor-Crummey and Scott, 1991] </ref>. REFERENCES 38
Reference: [Metcalfe and Boggs, 1976] <author> R. Metcalfe and D. Boggs. </author> <title> Ethernet: distributed packet switching for local computer networks. </title> <journal> Communications of the ACM 19, </journal> <month> 7 (July </month> <year> 1976), </year> <pages> 395-404. </pages>
Reference-contexts: If either the VALIDATE or the COMMIT fails, the process returns to Step (1). For objects where contention is high, programmers are advised to apply some kind of adaptive backoff <ref> [Anderson, 1990; Metcalfe and Boggs, 1976] </ref> before retrying. A more complex transaction, such as one that chains down a linked list, would alternate LT and VALIDATE instructions. 3 Implementing Transactional Memory In this section, we give an overview of an architecture that supports transactional memory. <p> We constructed three simple benchmarks, and ran them with four different synchronization mechanisms: (1) transactional memory with user-level exponential backoff, (2) test-and-test-and-set (TTS) [Rudolph, 1983] spin locks with exponential backoff <ref> [Anderson, 1990; Metcalfe and Boggs, 1976] </ref> (Figure 21), (3) LOAD LINKED/STORE COND (LL/SC) spin locks with exponential backoff, and (4) queue locks [Anderson, 1990; Graunke and Thakkar, 1990; Mellor-Crummey and Scott, 1991]. For a single-word counter benchmark, we also ran a LL/SC implementation directly on the shared variable.
Reference: [Rudolph, 1983] <author> L. Rudolph. </author> <title> Decentralized cache scheme for an MIMD parallel processor. </title> <booktitle> In 11th Annual Computing Architecture Conference (1983), </booktitle> <pages> pp. 340-347. </pages>
Reference-contexts: In both simulations, the regular cache is a direct-mapped cache with 2048 lines of size 8 bytes, and the transactional cache has 64 8-byte lines. We constructed three simple benchmarks, and ran them with four different synchronization mechanisms: (1) transactional memory with user-level exponential backoff, (2) test-and-test-and-set (TTS) <ref> [Rudolph, 1983] </ref> spin locks with exponential backoff [Anderson, 1990; Metcalfe and Boggs, 1976] (Figure 21), (3) LOAD LINKED/STORE COND (LL/SC) spin locks with exponential backoff, and (4) queue locks [Anderson, 1990; Graunke and Thakkar, 1990; Mellor-Crummey and Scott, 1991]. <p> Each processor repeatedly applies a test-and-set operation until it succeeds in acquiring the lock. As discussed in more detail by Anderson [Anderson, 1990], this nave technique performs poorly because it consumes excessive amounts of processor-to-memory bandwidth. On a cache-coherent architecture, the test-and-test-and-set <ref> [Rudolph, 1983] </ref> protocol achieves somewhat better performance by repeatedly rereading the cached value of the lock (generating no memory traffic), until it observes the lock is free, and then applying the test-and-set operation directly to the lock in memory.
Reference: [Wing and Gong, 1990] <author> J. Wing and C. Gong. </author> <title> A library of concurrent objects and their proofs of correctness. </title> <type> Tech. Rep. </type> <institution> CMU-CS-90-151, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> July </month> <year> 1990. </year>
References-found: 28

