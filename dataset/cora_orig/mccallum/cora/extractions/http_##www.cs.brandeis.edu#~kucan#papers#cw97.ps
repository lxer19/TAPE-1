URL: http://www.cs.brandeis.edu/~kucan/papers/cw97.ps
Refering-URL: http://www.cs.brandeis.edu/~kucan/bibliography.html
Root-URL: http://www.cs.brandeis.edu
Email: (kucan@theory.lcs.mit.edu)  
Title: Retraction Approach to CPS Transform  
Author: Jakov Kucan 
Address: Cambridge, MA 02139, USA  
Affiliation: Department of Mathematics Massachusetts Institute of Technology  
Abstract: We study the continuation passing style (CPS) transform and its generalization, the computational transform, in which the notion of computation is generalized from continuation passing to an arbitrary one. To establish a relation between direct style and continuation passing style interpretation of sequential call-by-value programs, we prove the Retraction Theorem which says that a lambda term can be recovered from its continuationized form via a -definable retraction. The Retraction Theorem is proved in the logic of computational lambda calculus for the simply typable terms.
Abstract-found: 1
Intro-found: 1
Reference: [App92] <author> Anrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge Uni-versisty Press, </publisher> <year> 1992. </year> <pages> 5-21 </pages>
Reference-contexts: Further research led to development of CPS denotational semantics [SW74] (see also [Sto77]), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform [Ste78] (see also <ref> [App92] </ref>).
Reference: [Bar84] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Se--mantics, </title> <booktitle> volume 103 of Studies in Logic. </booktitle> <publisher> North-Holland Publishing Co., </publisher> <address> Amsterdam, </address> <note> second edition, </note> <year> 1984. </year>
Reference-contexts: One should also investigate whether such elements exist in models that would allow interesting applications of the theorem. 2 Definitions We assume the reader is familiar with elementary concepts of a lambda calculus. For details one is referred to <ref> [Bar84] </ref>. In this section we will provide concise definitions in order to disambiguate our notation. 2.1 Lambda calculus Lambda terms are terms formed over an infinite set of variables by lambda abstraction and application.
Reference: [CP92] <author> Roy L. Crole and Andrew M. Pitts. </author> <title> New foundations for fixpoint computations: </title> <journal> FIX-hyperdoctrines and the FIX-logic. Information and Computation, </journal> <volume> 98(2) </volume> <pages> 171-210, </pages> <month> jun </month> <year> 1992. </year>
Reference-contexts: The other difficulty is determining the correct axiomatization of a fixed-point operator. It appears that the axiom (Y V ) = (V (Y V )) (fix) does not suffice. In models of c , fixed-point operator can be defined using the so called fixpoint object. Crole and Pitts <ref> [CP92] </ref> define such an object in models of c , and discuss a logical system for reasoning about fixpoint computations, which may hold the answer to above questions.
Reference: [Fil94] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Another important point is that the conclusion of our version of the Retraction Theorem is an equation provable in the logic of c , which is a call-by-value logic, unlike the results in [MW85] and <ref> [Fil94] </ref> which give similar equalities, but in a call-by-name logic. As a consequence, our results are applicable even where call-by-name reasoning is not sound. 5-20 Some open questions: In all practical applications, functional program-ming languages are equipped with some form of recursion.
Reference: [Kuc97] <author> Jakov Kucan. </author> <title> Metatheorems about Convertibility in Typed Lambda Calculi: Applications to CPS Transform and "Free Theorems". </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, U.S.A., </address> <month> February </month> <year> 1997. </year>
Reference-contexts: Then, for any closed lambda term M , c ` (r (R M )) = M: Of course, the analogous theorems hold for the other transforms as well. Here we only sketch the main idea in the proof of the above theorem. A detailed proof can be found in <ref> [Kuc97] </ref>. The recursive type system extends the simple types by adding type vari ables and type expressions of the form t:. The new inference rules are . M : ft:=tg ( I) .
Reference: [Mit88] <author> John C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference-contexts: This framework is in many ways similar to, and was inspired by, the type inference models developed in <ref> [Mit88] </ref>. <p> E S def = xs:hx; si, where init represents some initial state of the store, and define terms R S and E S using these terms instead. 3.2 Interpretations of Terms and Types The framework we develop to prove the Retraction Theorem is closely related to Mitchell's type inference models <ref> [Mit88] </ref>. As in the definition of a type inference model we define interpretations of terms and types, as well as a relation between the two.
Reference: [Mog88] <author> Eugenio Moggi. </author> <title> Computational lambda-caluclus and monads. </title> <type> Technical Report ECS-LFCS-88-86, </type> <institution> University of Edinburgh, </institution> <month> Oc-tober </month> <year> 1988. </year>
Reference-contexts: In this work we view the CPS transform as a formalization of the (continuation passing style) denotational semantics of a call-by-value programming language in the fi lambda calculus n . To model call-by-value evaluation in a programming language we choose Moggi's <ref> [Mog88] </ref> computational lambda calculus, c , for the two reasons: 1) the logic of c is sound for call-by-value reasoning, and 2) the logic of c is complete for the class of models (computational lambda models [Mog88]) in which most commonly used computational effects can be expressed. <p> To model call-by-value evaluation in a programming language we choose Moggi's <ref> [Mog88] </ref> computational lambda calculus, c , for the two reasons: 1) the logic of c is sound for call-by-value reasoning, and 2) the logic of c is complete for the class of models (computational lambda models [Mog88]) in which most commonly used computational effects can be expressed. One way of asserting the correctness of the CPS transform, as an interpretation of c in n , is the equational correspondence result due to Sabry and Felleisen [SF92]. Theorem 1.1 (Sabry-Felleisen). <p> Different extensions of a functional language with "impure" features can also be given denotational semantics using a similar transform. For example, an interpretation of programs in a language with mutable store can be given using the state passing style (SPS) transform. As shown by Moggi <ref> [Mog88] </ref>, a number of such computational effects can be described by the notion of a monad, and the CPS and the SPS transforms can be generalized to, what we call, the computational transform [Wad90, SW96]. <p> Even though we give untyped definitions of the transforms, we believe the transforms should be understood in the context of a typed language. This view is supported by the monadic framework, developed by Moggi <ref> [Mog88] </ref>, in which programs are interpreted as "computations". We leave out the details of Moggi's monadic interpretation, as well as the definitions of the typed transforms, since they are not central to our development, but rather sketch the intuitive picture to help motivate some of our definitions.
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-caluclus and monads. </title> <booktitle> In LICS, </booktitle> <year> 1989. </year>
Reference-contexts: Further research led to development of CPS denotational semantics [SW74] (see also [Sto77]), and later categorical semantics of computations <ref> [Mog89] </ref>, as well as compilers based on the CPS transform [Ste78] (see also [App92]).
Reference: [Mog91] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The equational correspondence for the computational transform holds as well [SW96], and it is natural to ask whether the Retraction Theorem (Theorem 1.2) generalizes. However, the computational transform maps lambda terms to the terms of the "monadic metalanguage", ml <ref> [Mog91] </ref>.
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> 71(1/2):95-130, October/November 1986. 
Reference-contexts: To do so, we define a metric on the space of all type sets so that the resulting metric space is complete. Then we show that each function S:JK-fS=tg is a contraction, and thus, by Banach's Fixed-point Theorem, has a unique fixed point. Mac Queen et al. <ref> [MPS86] </ref> have developed such a framework, of which our development can be viewed as a special case. Namely, our domain consists only of finite elements (typing sequents) ordered under discrete order, thus greatly simplifying general purpose structures used in [MPS86]. 4 Concluding Remarks In this work, we have established a relation <p> Mac Queen et al. <ref> [MPS86] </ref> have developed such a framework, of which our development can be viewed as a special case. Namely, our domain consists only of finite elements (typing sequents) ordered under discrete order, thus greatly simplifying general purpose structures used in [MPS86]. 4 Concluding Remarks In this work, we have established a relation between direct style and CPS terms using definable retraction functions. The Retraction Theorem shows that a term can be recovered, up to c -equivalence, from its image under the CPS transform.
Reference: [MR] <author> Albert R. Meyer and Jon G. Riecke. </author> <title> Continuations may be unreasonable. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 63-71. </pages>
Reference-contexts: More precisely, * is there a lambda term P , such that n ` (P M ) = M , and * is there a lambda term R, such that c ` (R M ) = M ? An elementary argument given in <ref> [MR] </ref> shows that the answer to the first question must be "no". In this work we give an affirmative answer to the second question. More precisely we prove the following theorem: Theorem 1.2 (Retraction, for the CPS transform).
Reference: [MW85] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda-calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs: Proceedings, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <pages> 5-22 </pages>
Reference-contexts: For any simple type there is a lambda term R , such that for all closed lambda terms M of type , c ` (R M ) = M: A version of the above Retraction Theorem was proven by Meyer and Wand <ref> [MW85] </ref>, where the conclusion of the theorem holds in the logic of n . However, as the authors themselves have pointed out to us, their result is misleading. <p> Another important point is that the conclusion of our version of the Retraction Theorem is an equation provable in the logic of c , which is a call-by-value logic, unlike the results in <ref> [MW85] </ref> and [Fil94] which give similar equalities, but in a call-by-name logic. As a consequence, our results are applicable even where call-by-name reasoning is not sound. 5-20 Some open questions: In all practical applications, functional program-ming languages are equipped with some form of recursion.
Reference: [Plo75] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(2) </volume> <pages> 125-159, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: The next transform we study is the call-by-value version of the Fischer-Reynolds CPS transform. The definition we use (as well as the overline notation) is taken from <ref> [Plo75] </ref> (see Table 4). Analogous to the CPS transform, used to give a denotational semantics of programs with mutable store, instead of control operators, is the state passing style transform (SPS). In the definition, given in Table 5, we used the pairing constructs as abbreviations.
Reference: [Rey93] <editor> John C. Reynolds. </editor> <booktitle> The discoveries of continutions. Lisp and Symbolic Computation, </booktitle> <volume> 6(3/4), </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The notions of a continuation and a continuation passing style (CPS) transform have been introduced by a number of authors (see <ref> [Rey93] </ref> for a historical overview). The main motivation for the independent developments of these concepts seemed to be twofold: explaining the behavior of imperative features in functional languages, and compilation of programs with higher order procedures.
Reference: [RV95] <author> Jon G. Riecke and Ramesh Viswanathan. </author> <title> Isolating side effects in sequential languages. </title> <booktitle> In In Proceedings of Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: Crole and Pitts [CP92] define such an object in models of c , and discuss a logical system for reasoning about fixpoint computations, which may hold the answer to above questions. Another class of extensions is motivated by the application of the Retraction Theorem developed by Riecke and Viswanathan <ref> [RV95] </ref>, where they show how one can isolate effects of an extension of a language with assignment or control from interfering with pure functional code.
Reference: [SF92] <author> Amr Sabry and Mathias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <type> Technical Report COMP TR 92-180, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference-contexts: One way of asserting the correctness of the CPS transform, as an interpretation of c in n , is the equational correspondence result due to Sabry and Felleisen <ref> [SF92] </ref>. Theorem 1.1 (Sabry-Felleisen). For any two lambda terms M and N , c ` M = N iff n ` M = N: The left-to-right implication in this theorem says that the CPS transform preserves equality, and the right-to-left implication says that the transform also preserves distinctions.
Reference: [Ste78] <author> Guy L. Steele. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <year> 1978. </year>
Reference-contexts: Further research led to development of CPS denotational semantics [SW74] (see also [Sto77]), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform <ref> [Ste78] </ref> (see also [App92]).
Reference: [Sto77] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: The main motivation for the independent developments of these concepts seemed to be twofold: explaining the behavior of imperative features in functional languages, and compilation of programs with higher order procedures. Further research led to development of CPS denotational semantics [SW74] (see also <ref> [Sto77] </ref>), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform [Ste78] (see also [App92]).
Reference: [SW74] <author> C. Strachey and C. P. Wadsworth. </author> <title> Continuations: A mathematical semantics for handling full jumps. </title> <type> Technical Report PRG-11, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1974. </year>
Reference-contexts: The main motivation for the independent developments of these concepts seemed to be twofold: explaining the behavior of imperative features in functional languages, and compilation of programs with higher order procedures. Further research led to development of CPS denotational semantics <ref> [SW74] </ref> (see also [Sto77]), and later categorical semantics of computations [Mog89], as well as compilers based on the CPS transform [Ste78] (see also [App92]).
Reference: [SW96] <author> Amr Sabry and Philip Wadler. </author> <title> A reflection on call-by-value. </title> <booktitle> In International Conference on Functional Programing, </booktitle> <address> Philadelphia, May 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: As shown by Moggi [Mog88], a number of such computational effects can be described by the notion of a monad, and the CPS and the SPS transforms can be generalized to, what we call, the computational transform <ref> [Wad90, SW96] </ref>. The equational correspondence for the computational transform holds as well [SW96], and it is natural to ask whether the Retraction Theorem (Theorem 1.2) generalizes. However, the computational transform maps lambda terms to the terms of the "monadic metalanguage", ml [Mog91]. <p> As shown by Moggi [Mog88], a number of such computational effects can be described by the notion of a monad, and the CPS and the SPS transforms can be generalized to, what we call, the computational transform [Wad90, SW96]. The equational correspondence for the computational transform holds as well <ref> [SW96] </ref>, and it is natural to ask whether the Retraction Theorem (Theorem 1.2) generalizes. However, the computational transform maps lambda terms to the terms of the "monadic metalanguage", ml [Mog91]. <p> Therefore, the retraction approach, in fact, only provides a relation between equivalence classes of terms. To contrast our results with others that provide, perhaps even stronger relation between lambda terms and their CPS forms (e.g. <ref> [SW96] </ref>), we should emphasize that the inverse of the CPS transform we obtain is definable.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 461-493, </pages> <month> December </month> <year> 1990. </year> <pages> 5-23 </pages>
Reference-contexts: As shown by Moggi [Mog88], a number of such computational effects can be described by the notion of a monad, and the CPS and the SPS transforms can be generalized to, what we call, the computational transform <ref> [Wad90, SW96] </ref>. The equational correspondence for the computational transform holds as well [SW96], and it is natural to ask whether the Retraction Theorem (Theorem 1.2) generalizes. However, the computational transform maps lambda terms to the terms of the "monadic metalanguage", ml [Mog91].
References-found: 21

