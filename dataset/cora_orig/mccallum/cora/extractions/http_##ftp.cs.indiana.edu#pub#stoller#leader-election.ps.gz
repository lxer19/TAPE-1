URL: http://ftp.cs.indiana.edu/pub/stoller/leader-election.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Title: Leader Election in Distributed Systems with Crash Failures  
Author: Scott D. Stoller 
Keyword: leader election, synchronous, asynchronous, crash failures, failure detector  
Date: 17 July 1997  
Address: Bloomington, IN 47405, USA  
Affiliation: Dept. of Computer Science, Indiana University,  
Abstract: Leader election is an important problem in distributed computing. Garcia-Molina's Bully Algorithm is a classic solution to leader election in synchronous systems with crash failures. This paper shows that the Bully Algorithm can be easily adapted for use in asynchronous systems. First, we re-write the Bully Algorithm to use a failure detector, instead of explicit time-outs; this yields a modular solution to leader election in synchronous systems. Second, we show that minor modifications to that algorithm yield a simple and efficient solution to leader election in asynchronous systems with crash failures. We point out a flaw in Garcia-Molina's specification of leader election in asynchronous systems, propose a revised specification, and show that the modified Bully Algorithm satisfies this specification. 
Abstract-found: 1
Intro-found: 1
Reference: [Cri91] <author> Flaviu Cristian. </author> <title> Reaching agreement on processor group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4(4), </volume> <year> 1991. </year>
Reference-contexts: A slightly more complicated approach is for each node i, when it starts monitoring node j, to tell node j to periodically send "I'm alive" messages to node i. This uses fewer messages and reduces the latency of the FD. A more complicated approach, based on an attendance list <ref> [Cri91, CS95] </ref>, 1 The temporal operator 2 means "henceforth" or "always", and the temporal operator 3 means "eventually". See [MP92] for details. 3 is to construct a logical ring and periodically circulate a token around it.
Reference: [Cri96] <author> Flaviu Cristian. </author> <title> Synchronous and asynchronous group communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 88-97, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Formalizing this requirement is slightly tricky. Garcia-Molina attempts to formalize it by requiring (roughly) that if a set of nodes can all communicate with each other, then they end up in the same group. To express this more precisely, we introduce some terminology, based on <ref> [CS95, Cri96] </ref>. Two nodes are connected in a given time interval if all messages sent between them during that time interval are delivered within ffi time units, where ffi is a known constant.
Reference: [CS95] <author> Flaviu Cristian and Frank Schmuck. </author> <title> Agreeing on processor group membership in asynchronous distributed systems. </title> <type> Technical Report CSE95-428, </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1995. </year> <note> Available via http://www-cse.ucsd.edu/users/flaviu/publications.html. </note>
Reference-contexts: A slightly more complicated approach is for each node i, when it starts monitoring node j, to tell node j to periodically send "I'm alive" messages to node i. This uses fewer messages and reduces the latency of the FD. A more complicated approach, based on an attendance list <ref> [Cri91, CS95] </ref>, 1 The temporal operator 2 means "henceforth" or "always", and the temporal operator 3 means "eventually". See [MP92] for details. 3 is to construct a logical ring and periodically circulate a token around it. <p> Formalizing this requirement is slightly tricky. Garcia-Molina attempts to formalize it by requiring (roughly) that if a set of nodes can all communicate with each other, then they end up in the same group. To express this more precisely, we introduce some terminology, based on <ref> [CS95, Cri96] </ref>. Two nodes are connected in a given time interval if all messages sent between them during that time interval are delivered within ffi time units, where ffi is a known constant. <p> ALE2 is undesirably strong, because algorithms satisfying it must compute (in some way) a minimum clique cover, and the problem of finding a minimum clique cover is NP-complete [GJ79]. Note that the specifications in <ref> [CS95] </ref> assume a stronger notion of stability, namely, that connectivity is transitive when the system is stable; as a result, they avoid these difficulties.
Reference: [CT94] <author> Tushar Deepak Chandra and Sam Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <type> Technical Report TR 94-1458, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: The resulting algorithm, which we call the Asynchronous Bully Algorithm, is simple and message-efficient: in common cases, it uses half as many messages as the Invitation Algorithm. We obtain the Asynchronous Bully Algorithm in two steps. First, we re-write the Bully Algorithm to use a failure detector <ref> [CT94] </ref>, instead of explicit time-outs. A failure detector is a module that reports crashes of other nodes. Re-writing the Bully Algorithm in this way has three benefits. First, the modularity fl Email: stoller@cs.indiana.edu. Tel.: 812-855-7979. Fax: 812-855-4829. Web: http://www.cs.indiana.edu/~stoller/ 1 facilitates use of different failure detection mechanisms in different systems.
Reference: [DIM91] <author> Shlomi Dolev, Amos Israeli, and Shlomo Moran. </author> <title> Uniform dynamic self-stabilizing leader election. In Sam Toueg, </title> <editor> Paul G. Spirakis, and Lefteris Kirousis, editors, </editor> <booktitle> Proc. 5th International Workshop on Distributed Algorithms (WDAG '91), volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-180. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: There is considerable work on self-stabilizing algorithms for leader election (e.g., <ref> [DIM91, ILS95] </ref>). Those algorithms operate under weaker assumptions about failures (essentially, a failure can cause an arbitrary state transition) and provide weaker guarantees. <p> The weaker assumptions about failures force a weakening of the guarantees: if arbitrary state transitions can occur, then it is impossible to ensure that an invariant (such as SLE1 or ALE1) is preserved. Comparing synchrony assumptions, the situation is reversed: the self-stabilizing algorithms in <ref> [DIM91, ILS95] </ref> are based on synchronous communication, while we consider also unreliable asynchronous communication. We assume (cf. Section 4) that each node has a unique identifier (e.g., a network address). This assumption is appropriate for algorithms running above a network layer, such as IP. <p> This assumption is appropriate for algorithms running above a network layer, such as IP. In particular, it is appropriate for the types of applications described in Section 1. In contrast, there is considerable work on algorithms for leader election in uniform systems (e.g., <ref> [DIM91, ILS95] </ref>), in which all nodes with the same number of neighbors are identical (and therefore do not have unique identifiers).
Reference: [FLP85] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: The specification of leader election in synchronous systems says (roughly) that the system always reaches a state in which all operational nodes agree on the leader. In asynchronous systems (with crash failures), agreement problems of this kind are unsolvable <ref> [FLP85] </ref>, so a weaker specification must be used. Garcia-Molina gives such a specification, by incorporating the idea of groups: a group is a collection of nodes that agree on a leader. However, Garcia-Molina's specification is unintentionally strong, since contrary to his claim, the Invitation Algorithm does not satisfy it. <p> is the latency of the failure detector, and (as shown in the pseudo-code) o is the period with which Norm? messages are sent. 5 Specification of Leader Election in Asynchronous Systems In an asynchronous system, it is impossible to satisfy SLE1 and SLE2; this follows from the FLP impossibility result <ref> [FLP85] </ref>. Following Garcia-Molina [GM82], we weaken the safety requirement by introducing the notion of groups. Since it is impossible to ensure that all nodes agree on the leader, we consider algorithms that organize the system into disjoint groups such that all members of a group agree on the group's leader. <p> Furthermore, the system remains in that state as long as the system remains stable. 6 Failure Detectors in Asynchronous Systems In an asynchronous system, complete and accurate failure detection is impossible; this, too, follows from the FLP impossibility result <ref> [FLP85] </ref>. Thus, a FD for an asynchronous system is required to satisfy completeness requirement (1) but not accuracy requirement (2). However, we do require that when the system is stable, failure detection is accurate, with maximum latency o FD .
Reference: [FvR95] <author> Roy Friedman and Robbert van Renesse. </author> <title> Strong and weak virtual synchrony in Horus. </title> <type> Technical Report TR 95-1491, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: For example, the group communication system in Amoeba [KT91, KT92] uses Garcia-Molina's Invitation Algorithm [GM82] to reconfigure a group after crashes. As another example, the group membership algorithms in Horus <ref> [FvR95, vRBM96] </ref> and Ensemble [Hay97] can be seen as a combination of Garcia-Molina's Bully Algorithm (for handling crashes) and Invitation Algorithm (for merging partitions of a group). This paper shows that the Bully Algorithm can be easily adapted for use in asynchronous systems.
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: ALE2 0 is undesirably weak, because it is satisfied by trivial algorithms that put each node in a separate group. ALE2 is undesirably strong, because algorithms satisfying it must compute (in some way) a minimum clique cover, and the problem of finding a minimum clique cover is NP-complete <ref> [GJ79] </ref>. Note that the specifications in [CS95] assume a stronger notion of stability, namely, that connectivity is transitive when the system is stable; as a result, they avoid these difficulties.
Reference: [GM82] <author> Hector Garcia-Molina. </author> <title> Elections in a distributed computing system. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-31(1):47-59, </volume> <month> January </month> <year> 1982. </year>
Reference-contexts: 1 Introduction In a classic paper, Garcia-Molina specifies the leader election problem for synchronous and asynchronous distributed systems with crash failures and gives an elegant algorithm for each type of system; these algorithms are called the Bully Algorithm and Invitation Algorithm, respectively <ref> [GM82] </ref>. Leader election is an important problem in fault-tolerant distributed computing. It is closely related to the primary-backup approach (since choosing a primary replica is like electing a leader), an efficient form of passive replication. <p> It is also closely related to group communication [Pow96], which (among other uses) provides a powerful basis for implementing active replication. For example, the group communication system in Amoeba [KT91, KT92] uses Garcia-Molina's Invitation Algorithm <ref> [GM82] </ref> to reconfigure a group after crashes. As another example, the group membership algorithms in Horus [FvR95, vRBM96] and Ensemble [Hay97] can be seen as a combination of Garcia-Molina's Bully Algorithm (for handling crashes) and Invitation Algorithm (for merging partitions of a group). <p> Furthermore, the system remains in that state as long as no failures or recoveries occur. SLE1 and SLE2 are equivalent to Garcia-Molina's specification (Assertions 1 and 2 in <ref> [GM82] </ref>), except that we have simplified the problem slightly by omitting discussion of the re-distribution application-level tasks that might be needed following election of a new leader. <p> The expressions S x and S x denote set S with element x inserted or removed, respectively. The C-style assignment statements S = x and S = x update the value of S by adding or removing 2 In <ref> [GM82] </ref>, higher numbers correspond to higher priorities. Our convention has the (potential) benefit of allowing new nodes to be integrated without changing the leader or the priority of other nodes. 5 element x, respectively. The operator 1 returns the first component of a tuple. <p> The operator 1 returns the first component of a tuple. The significant differences between our Bully FD Algorithm and the original Bully Algorithm <ref> [GM82] </ref> are: 1. We use a failure detector, instead of explicit time-outs. <p> We include an election identifier in each message, to avoid confusion caused by messages that get delayed in the network. Outside of the FD, we do not assume a bound on message latency. 4. We omit the additional round of communication used in <ref> [GM82] </ref> to re-distribute application-level tasks. Restoring this additional round of communication is straightforward. Correctness of the algorithm is independent of the value of o and the values of the volative variables when a node recovers. <p> Correctness of the algorithm is independent of the value of o and the values of the volative variables when a node recovers. The proofs that the Bully FD Algorithm satisfies SLE1 and SLE2 are very similar to the proofs of Theorems A1 and A2 in <ref> [GM82] </ref> and are therefore omitted. Only item 2 above has a non-trivial impact on the proof, and it is easy to see from Garcia-Molina's proof that the status of the nodes in lesser (i) can be checked in any order. <p> Following Garcia-Molina <ref> [GM82] </ref>, we weaken the safety requirement by introducing the notion of groups. Since it is impossible to ensure that all nodes agree on the leader, we consider algorithms that organize the system into disjoint groups such that all members of a group agree on the group's leader. <p> if status 6= Norm then send hNotNorm; ti to j fi On hNotNorm; ti from j : if status = Norm ^ ldr = i ^ t = elid then StartStage1 () fi On recovery : incarn := incarn + 1 StartStage1 () 7 ALE1 corresponds to Assertion 3 in <ref> [GM82] </ref>. If we added the requirement that there always be at most one group, then ALE1 would be equivalent to SLE1. We allow multiple groups but require that the number of groups be as small as is reasonable. Formalizing this requirement is slightly tricky. <p> For some applications, it is desirable for a group to contain only nodes that are pairwise connected. Thus, in some cases, Assertion 4 is an undesirably strong requirement. Furthermore, as we show in 3 Garcia-Molina explicitly considers non-transitive connectivity <ref> [GM82, page 52] </ref>. 8 Appendix A, the Invitation Algorithm does not satisfy Assertion 4, despite Theorem A4 in [GM82]. We propose the following weaker requirement, to formalize the idea that there should be as few groups as possible without forcing disconnected nodes to be in the same group. <p> Thus, in some cases, Assertion 4 is an undesirably strong requirement. Furthermore, as we show in 3 Garcia-Molina explicitly considers non-transitive connectivity [GM82, page 52]. 8 Appendix A, the Invitation Algorithm does not satisfy Assertion 4, despite Theorem A4 in <ref> [GM82] </ref>. We propose the following weaker requirement, to formalize the idea that there should be as few groups as possible without forcing disconnected nodes to be in the same group. <p> In the worst case, all of the other nodes call procedure Check (or procedure StartStage2) before node n1 (or node 2), so relative to the average case, twice as many messages are sent. 12 8 Related Work The most closely related work is <ref> [GM82] </ref>, which has been discussed above. There is considerable work on self-stabilizing algorithms for leader election (e.g., [DIM91, ILS95]). Those algorithms operate under weaker assumptions about failures (essentially, a failure can cause an arbitrary state transition) and provide weaker guarantees.
Reference: [Hay97] <author> Mark Hayden. </author> <title> The Ensemble Distributed Communication System, </title> <note> 1997. Documentation available via http://www.cs.cornell.edu/Info/Projects/Ensemble/index.html. 13 </note>
Reference-contexts: For example, the group communication system in Amoeba [KT91, KT92] uses Garcia-Molina's Invitation Algorithm [GM82] to reconfigure a group after crashes. As another example, the group membership algorithms in Horus [FvR95, vRBM96] and Ensemble <ref> [Hay97] </ref> can be seen as a combination of Garcia-Molina's Bully Algorithm (for handling crashes) and Invitation Algorithm (for merging partitions of a group). This paper shows that the Bully Algorithm can be easily adapted for use in asynchronous systems.
Reference: [ILS95] <author> Gene Itkis, Chengdian Lin, and Janos Simon. </author> <title> Deterministic, constant space, self-stabilizing leader election on uniform rings. </title> <editor> In Jean-Michel Helary and Michel Raynal, editors, </editor> <booktitle> Proc. 9th International Workshop on Distributed Algorithms (WDAG '95), volume 972 of Lecture Notes in Computer Science, </booktitle> <pages> pages 288-302. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: There is considerable work on self-stabilizing algorithms for leader election (e.g., <ref> [DIM91, ILS95] </ref>). Those algorithms operate under weaker assumptions about failures (essentially, a failure can cause an arbitrary state transition) and provide weaker guarantees. <p> The weaker assumptions about failures force a weakening of the guarantees: if arbitrary state transitions can occur, then it is impossible to ensure that an invariant (such as SLE1 or ALE1) is preserved. Comparing synchrony assumptions, the situation is reversed: the self-stabilizing algorithms in <ref> [DIM91, ILS95] </ref> are based on synchronous communication, while we consider also unreliable asynchronous communication. We assume (cf. Section 4) that each node has a unique identifier (e.g., a network address). This assumption is appropriate for algorithms running above a network layer, such as IP. <p> This assumption is appropriate for algorithms running above a network layer, such as IP. In particular, it is appropriate for the types of applications described in Section 1. In contrast, there is considerable work on algorithms for leader election in uniform systems (e.g., <ref> [DIM91, ILS95] </ref>), in which all nodes with the same number of neighbors are identical (and therefore do not have unique identifiers).
Reference: [KT91] <author> M. F. Kaashoek and A. S. Tanenbaum. </author> <title> Group communication in the amoeba distributed operating system. </title> <booktitle> In Proc. IEEE 11th International Conference on Distributed Computing Systems (ICDCS), </booktitle> <pages> pages 222-230. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: It is also closely related to group communication [Pow96], which (among other uses) provides a powerful basis for implementing active replication. For example, the group communication system in Amoeba <ref> [KT91, KT92] </ref> uses Garcia-Molina's Invitation Algorithm [GM82] to reconfigure a group after crashes. As another example, the group membership algorithms in Horus [FvR95, vRBM96] and Ensemble [Hay97] can be seen as a combination of Garcia-Molina's Bully Algorithm (for handling crashes) and Invitation Algorithm (for merging partitions of a group).
Reference: [KT92] <author> M. Frans Kaashoek and Andrew S. Tanenbaum. </author> <title> Efficient reliable group communication for distributed systems. </title> <institution> Rapport IR-295 IR-295, Faculteit Wiskunde en Informatica, Vrije Universiteit, </institution> <year> 1992. </year> <note> Revised version available from ftp://ftp.cs.vu.nl/pub/papers/amoeba/group94.ps.Z. </note>
Reference-contexts: It is also closely related to group communication [Pow96], which (among other uses) provides a powerful basis for implementing active replication. For example, the group communication system in Amoeba <ref> [KT91, KT92] </ref> uses Garcia-Molina's Invitation Algorithm [GM82] to reconfigure a group after crashes. As another example, the group membership algorithms in Horus [FvR95, vRBM96] and Ensemble [Hay97] can be seen as a combination of Garcia-Molina's Bully Algorithm (for handling crashes) and Invitation Algorithm (for merging partitions of a group).
Reference: [MP92] <author> Zohar Manna and Amir Pnueli. </author> <title> The temporal logic of reactive and concurrent systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Furthermore, to ensure that the FD reports up-to-date information, we require that the client receives hDownSig; ii only if node i is down after the most recent invocation of Start FD (i). 2 We formally specify the behavior of the FD using linear-time temporal logic <ref> [MP92] </ref> with the fol- lowing predicate symbols: up i holds when node i is operational. start (i) holds when the client calls Start FD (i). stop (i) holds when the client calls Stop FD (i). downSig (i) holds when the client receives signal hDownSig; ii. <p> Accuracy means that hDownSig; ii is received only if node i was actually down after the most recent invocation of Start FD (i). This can be expressed concisely in temporal logic using the temporal operator W (read "unless") <ref> [MP92] </ref>; informally, p W q means that either p holds henceforth, or q eventually holds and p holds continuously until q holds. <p> This uses fewer messages and reduces the latency of the FD. A more complicated approach, based on an attendance list [Cri91, CS95], 1 The temporal operator 2 means "henceforth" or "always", and the temporal operator 3 means "eventually". See <ref> [MP92] </ref> for details. 3 is to construct a logical ring and periodically circulate a token around it. If a node does not see the token within the expected time, then one or more failures have occurred; "Are you alive?" messages can be used to pinpoint the failures.
Reference: [Pow96] <author> David Powell, </author> <title> guest editor. </title> <journal> Special section on group communication. Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 50-97, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Leader election is an important problem in fault-tolerant distributed computing. It is closely related to the primary-backup approach (since choosing a primary replica is like electing a leader), an efficient form of passive replication. It is also closely related to group communication <ref> [Pow96] </ref>, which (among other uses) provides a powerful basis for implementing active replication. For example, the group communication system in Amoeba [KT91, KT92] uses Garcia-Molina's Invitation Algorithm [GM82] to reconfigure a group after crashes.
Reference: [vRBM96] <author> Robbert van Renesse, Kenneth P. Birman, and Silvano Maffeis. Horus: </author> <title> A flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: For example, the group communication system in Amoeba [KT91, KT92] uses Garcia-Molina's Invitation Algorithm [GM82] to reconfigure a group after crashes. As another example, the group membership algorithms in Horus <ref> [FvR95, vRBM96] </ref> and Ensemble [Hay97] can be seen as a combination of Garcia-Molina's Bully Algorithm (for handling crashes) and Invitation Algorithm (for merging partitions of a group). This paper shows that the Bully Algorithm can be easily adapted for use in asynchronous systems.
References-found: 16

