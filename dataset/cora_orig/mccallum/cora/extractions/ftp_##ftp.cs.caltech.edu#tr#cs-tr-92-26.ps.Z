URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-92-26.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: KRML 16 -0 Extensions to an object-oriented programming language for programming fine-grain multicomputers  
Author: K. Rustan M. Leino 
Date: 4 December 1992  
Address: Pasadena, CA 91125  
Affiliation: Computer Science California Institute of Technology  
Abstract: In this note, we extend an object-oriented language to support programming fine-grain multicom-puters. The new constructs have a simple semantics and provide a nice way to write distributed programs. The semantics of the constructs are independent of how a program is distributed. We also show a set of simple conditions under which even the outcome of a program is independent of how its control and data are distributed.
Abstract-found: 1
Intro-found: 1
Reference: [0] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-42, </pages> <year> 1992. </year>
Reference-contexts: Our language extensions involve types. Here, Modula-3 provides type safety. Last but not least, for a language that provides object types and concurrency (and much more), Modula-3 is quite simple. The semantics of Modula-3 is concise and well defined. (See [6] or <ref> [0] </ref>, an exceptionally well-written report.) Since our goal is to provide something the programmer can understand, Modula-3 fits right in. An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see [1, 2]).
Reference: [1] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC++: A declarative concurrent object-oriented programming notation. </title> <type> Technical Report Caltech-CS-TR-92-01, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see <ref> [1, 2] </ref>). However, as C++ is, for one, not a simple language (see [3]), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see [11]).
Reference: [2] <author> K. Mani Chandy and Carl Kesselman. </author> <title> The CC++ language definition. </title> <type> Technical Report Caltech-CS-TR-92-02, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see <ref> [1, 2] </ref>). However, as C++ is, for one, not a simple language (see [3]), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see [11]).
Reference: [3] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990. </year>
Reference-contexts: An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see [1, 2]). However, as C++ is, for one, not a simple language (see <ref> [3] </ref>), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see [11]). These are implemented in Modula-3, and are more general than those presented here; for example, objects may be shared between different programs.
Reference: [4] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: KRML 16 -5 4 Sample Program We give a solution, written in our extended Modula-3, to a standard parallel programming problem, namely that of generating prime numbers by means of the sieve of Eratosthenes (see, for example, <ref> [4] </ref>). Before we start, we introduce a type, Buffer, that we will need. This type features put and get methods to access the buffer. Elements are read in first-in first-out order, and put and get operations are suspended if the buffer is full or empty, respectively.
Reference: [5] <author> Greg Nelson. </author> <title> Private communications. </title>
Reference: [6] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Our language extensions involve types. Here, Modula-3 provides type safety. Last but not least, for a language that provides object types and concurrency (and much more), Modula-3 is quite simple. The semantics of Modula-3 is concise and well defined. (See <ref> [6] </ref> or [0], an exceptionally well-written report.) Since our goal is to provide something the programmer can understand, Modula-3 fits right in. An alternative starting point would have been C++. This route is chosen in, for example, Compositional C++ (see [1, 2]).
Reference: [7] <author> E.A.M. Odijk. </author> <title> The DOOM system and its applications: a survey of ESPRIT 415 subproject A. </title> <booktitle> In PARLE 87, volume 258 of Lecture Notes in Computer Science, </booktitle> <pages> pages 461-479. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> KRML 16 -12 </note>
Reference-contexts: For example, more types are needed, and network objects are created differently from other objects. Yet another attempt at combining object-oriented and concurrent programming is the Parallel Object-Oriented Language, POOL (see <ref> [7] </ref>). This language does not provide inheritance, so one may argue that, in spite of its name, POOL is not really an object-oriented language. In POOL, every object corresponds to a process; here, we treat these two separately.
Reference: [8] <author> Charles L. Seitz. </author> <title> Concurrent VLSI architectures. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-33(12):1247-1265, </volume> <year> 1984. </year>
Reference: [9] <author> Charles L. Seitz. </author> <title> The cosmic cube. </title> <journal> Communications of the ACM, </journal> <volume> 28(1) </volume> <pages> 22-33, </pages> <year> 1985. </year>
Reference-contexts: Typical interprocessor communication operations provided by languages used to program such machines are send and receive. Forcing the programmer to deal with the details of each communication, these operations hinder the programmer from thinking about good and nice solutions for the problem at hand. As <ref> [9] </ref> states it, "because we have tacked these primitives onto programming languages simply as external functions, the process code is unnecessarily baroque." Instead, by providing in a programming language a different means of doing interprocessor communication, one can return the programmer's attention to the problem at hand.
Reference: [10] <author> Charles L. Seitz. </author> <title> Submicron systems architecture, </title> <type> semiannual technical report. Technical Report Caltech-CS-TR-92-17, </type> <institution> California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: When writing programs for a fine-grain multicomputer, memory management is of great concern. For example, in the Caltech Mosaic multicomputer with its designed 16 K nodes (256 of which are currently present), each node has only 64 KB RAM (see <ref> [10] </ref>). Therefore, it is convenient to have the language, rather than the programmer, assume responsibility of heap management. Modula-3 is geared to allow language implementations to feature a garbage collector. Our language extensions involve types. Here, Modula-3 provides type safety.
Reference: [11] <institution> DEC SRC. DEC SRC network objects. </institution> <note> To be published, </note> <year> 1993. </year>
Reference-contexts: This route is chosen in, for example, Compositional C++ (see [1, 2]). However, as C++ is, for one, not a simple language (see [3]), our results are not going to be simple either. A different version of network objects has been implemented at the DEC Systems Research Center (see <ref> [11] </ref>). These are implemented in Modula-3, and are more general than those presented here; for example, objects may be shared between different programs. However, the design goals and assumptions of the DEC SRC network objects differ from ours. <p> The typecode of the surrogate object is the same as for the concrete object, since the type of an object is not dependent on where it resides. (This deviates from the network objects in <ref> [11] </ref>.) However, the data record and method suite of the surrogate object differ from those of the concrete object. <p> In particular, the data record needs only contain the global identifier of the concrete object, and the entries of the method suite are procedures that will cause the methods to be executed remotely. (See <ref> [11] </ref> for a variation of these surrogates.) Creating a remote network object involves interprocessor communication between the requesting processor (called the client) and the host. The client sends a message to the host, passing an encoding of the parameters of the NEW call.
References-found: 12

