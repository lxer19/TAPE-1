URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1990/1990-24.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: The Derivation of Distributed Termination Detection Algorithms from Garbage Collection Schemes  
Author: Gerard Tel Friedemann Mattern 
Keyword: Categories and Subject Descriptors: D.1.3 [Programming Techniques]: Concurrent Programming; C.2.4 [Computer-Communication Networks]: Distributed Systems|Network Operating Systems; D.4.2 [Operating Systems]: Storage Management| Distributed Memories. General Terms: Algorithms, Design, Theory, Verification. Additional Keywords and Phrases: Distributed Algorithms, Distributed Termination Detection, Garbage Collection, Program Transformations.  
Note: Printed  The work of this author is supported by the ESPRIT II Basic Research Actions Program of the EC under contract no. 3075 (project ALCOM).  
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  Im Stadtwald 36, D 6600 Saarbrucken, Fed. Rep. Germany  
Affiliation: Department of Computer Science, University of Utrecht,  Department of Computer Science, University of Saarland,  
Email: Email: gerard@cs.ruu.nl  Email: mattern@cs.uni-sb.de  
Date: September 1990/Revised September 1991  June 27, 1994  
Abstract: It is shown that the termination detection problem for distributed computations can be modeled as an instance of the garbage collection problem. Consequently, algorithms for the termination detection problem are obtained by applying transformations to garbage collection algorithms. The transformation can be applied to collectors of the "mark-and-sweep" type as well as to reference counting garbage collectors. As examples, the scheme is used to transform the distributed reference counting protocol of Lermen and Maurer, the weighted reference counting protocol, the local reference counting protocol, and Ben-Ari's mark-and-sweep collector into termination detection algorithms. Known termination detection algorithms as well as new variants are obtained.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ben-Ari, M., </author> <title> Algorithms for On-the-fly Garbage Collection, </title> <journal> ACM Trans. on Prog. Lang. </journal> <note> and Systems 6 (1984) 333-344. </note>
Reference-contexts: To obtain an algorithm satisfying G2, usually a supplementary algorithm (typically of the mark-and-sweep type) is used to collect cyclic structures of garbage. In our application, however, cyclic structures of garbage objects do not occur, and a supplementary algorithm is not necessary. 6 Mark-and-sweep <ref> [1, 10, 29, 30] </ref>. Collectors of the second type mark all reachable objects as such, starting from the roots and recursively marking all descendants of marked objects. In this way all reachable objects become marked eventually. <p> When a h pss; g; s i message is received, ActCount [g] is decremented and ActCount [g + 1] is increased by s, the number of newly reported activations of generation g + 1. Initially a process p is either active with gen p = 1 or passive, ActCount <ref> [1] </ref> equals the number of active processes, ActCount [i] = 0 for i &gt; 1, and no messages are underway. Theorem 3.5 The Generational termination detection algorithm is a correct termination detection algorithm. 19 Proof. <p> In each cycle first all reachable objects are marked, and subsequently all unmarked objects are reclaimed. In this section it is shown how the garbage collection algorithm of Ben-Ari <ref> [1] </ref> can be transformed into a termination detection algorithm. (Actually, we use a variant of the algorithm described by Van de Snepscheut [29]). This algorithm was designed to run concurrently with a single processor mutating the references contained in memory cells. <p> No cooperation is required when the basic program deletes a reference. The correctness proof of this garbage collection scheme is quite involved; proofs were given by Ben-Ari in <ref> [1] </ref> and Van de Snepscheut [29]. 1 We use the color "gray" instead of "black" (as in the original algorithm [1, 29]) because we need "black" for a different purpose further down. 23 3.4.2 Transformation into a Termination Detection Algorithm In the scheme used to obtain a termination detection algorithm each <p> No cooperation is required when the basic program deletes a reference. The correctness proof of this garbage collection scheme is quite involved; proofs were given by Ben-Ari in [1] and Van de Snepscheut [29]. 1 We use the color "gray" instead of "black" (as in the original algorithm <ref> [1, 29] </ref>) because we need "black" for a different purpose further down. 23 3.4.2 Transformation into a Termination Detection Algorithm In the scheme used to obtain a termination detection algorithm each object can have at most one reference, which is always a Z-reference. The transformation is straightforward.
Reference: [2] <author> Bevan, D.I., </author> <title> An Efficient Reference Counting Solution to the Distributed Garbage Collection Problem, </title> <note> Parallel Computing 9 (1989) 179-192. </note>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems [7, 21]. Reference Counting <ref> [2, 14, 15, 16, 24, 36] </ref>. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account. <p> The reference count monotonically decreases, and the order in which control messages (i.e., delete messages) arrive at the object becomes irrelevant. The object can be collected when its reference count drops to zero. 3.2.1 Description of the Scheme Distributed weighted reference counting schemes have been given by Bevan <ref> [2] </ref>, Watson and Watson [36], and others. The principle was attributed to Weng [35]. In its description, see Algorithm 7, again the mechanism to create new objects is omitted. An o-reference is now a tuple (o; w), where w denotes the weight of the reference. <p> Theorem 3.3 Algorithm 7 is a correct reference counting garbage collection algorithm, that is, it satisfies G1 and G3. Proof. A correctness proof and analysis of the scheme is given by Bevan <ref> [2] </ref> and by Watson and Watson [36] and is based on invariance of the following two assertions: 16 S p : f state p = active g (* Thus p has a Z-reference (Z; w) *) send a message hM; h cop; Z; w=2 ii to q ; w := w=2
Reference: [3] <author> Chandy, K.M., L. Lamport, </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems, </title> <journal> ACM Trans. </journal> <note> on Computer Systems 3 (1985) 63-75. </note>
Reference-contexts: Third, it has been observed that the fundamental difficulties of the termination detection problem are the same as those of other important problems in distributed computing. Indeed, termination detection algorithms are related to algorithms for computing distributed snapshots <ref> [3, 19] </ref>, detecting deadlocks [5, 23], and approximating a distributed infimum [31, 20]. Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view.
Reference: [4] <author> Chandy, K.M., J. Misra, </author> <title> How Processes Learn, </title> <booktitle> Distributed Computing 1 (1986) 40-52. </booktitle>
Reference-contexts: A worst case lower bound for this overhead of one control message per basic message was proved by Chandy and Misra <ref> [4] </ref>, and this bound is achieved by the algorithm of Dijkstra and Scholten [11]. 2. FIFO Discipline on Links. For the correctness of the algorithm it is required that links deliver messages in the order they were sent. 3. Central Controller. <p> The LRC termination detection algorithm has interesting characteristics. For each basic message eventually one decrement control message is sent which means that the algorithm has optimal worst case message overhead <ref> [4] </ref>. The FIFO property of communication links is not required.
Reference: [5] <author> Chandy, K.M., J. Misra, L.M. Haas, </author> <title> Distributed Deadlock Detection, </title> <journal> ACM Trans. </journal> <note> on Computer Systems 1 (1983) 144-156. </note>
Reference-contexts: Third, it has been observed that the fundamental difficulties of the termination detection problem are the same as those of other important problems in distributed computing. Indeed, termination detection algorithms are related to algorithms for computing distributed snapshots [3, 19], detecting deadlocks <ref> [5, 23] </ref>, and approximating a distributed infimum [31, 20]. Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view. From both points of view we consider it useful to recognize general design paradigms for distributed termination detection algorithms. <p> Termination detection and garbage collection belong to a family of problems concerning the detection of stable properties in distributed systems. This family also includes deadlock detection <ref> [5] </ref> and global virtual time approximation [32]. Several transformations of the same spirit as the one described here have been given between members of this family. It was argued by Natarajan [23] that termination is a special case of communication deadlock.
Reference: [6] <author> Charron-Bost, B., G. Tel, F. Mattern, </author> <title> Synchronous and Asynchronous Communication in Distributed Computations, </title> <type> Technical Report, </type> <institution> Universite Paris 7, Paris, </institution> <year> 1991. </year>
Reference-contexts: This is possible even in a system where message communication is FIFO, because these messages may be sent from different objects. (It is not possible, however, if message communication is synchronous or causally ordered <ref> [6] </ref>.) If an h inc; o; q i message is overtaken by a h dec; o i message, RC o may temporarily drop to 0, causing o to be collected while it is reachable.
Reference: [7] <author> Collins, G.E., </author> <title> A Method for Overlapping and Erasure of Lists, </title> <journal> Comm. </journal> <note> ACM 3 (1960) 655-657. </note>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems <ref> [7, 21] </ref>. Reference Counting [2, 14, 15, 16, 24, 36]. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account.
Reference: [8] <author> Chandrasekaran, S., S. Venkatesan, </author> <title> A Message-Optimal Algorithm for Distributed Termination Detection, </title> <note> Journal of Parallel and Distributed Computation 8 (1990) 245-252. </note>
Reference-contexts: The best known example in this class is the algorithm of Dijkstra and Scholten [11]; generalizations of this algorithm were given by Shavit and Francez [28] and Chandrasekaran and Venkatesan <ref> [8] </ref>. 1.2 The Distributed Garbage Collection Problem As our approach for deriving termination detection algorithms is based on solutions to the garbage collection problem, we shall now describe this problem.
Reference: [9] <author> Dijkstra, E.W., W.H.J. Feijen, A.J.M. van Gasteren, </author> <title> Derivation of a Termination Detection Algorithm for Distributed Computations, </title> <journal> Inf. Proc. Lett. </journal> <month> 16 </month> <year> (1983) </year> <month> 217-219. </month>
Reference-contexts: The best known example in this class is the algorithm by Dijkstra et al. <ref> [9] </ref>, a general treatment is given by Tel [32]. Acknowledgement-based Solutions. In these algorithms all messages of the basic computation are acknowledged, but only after all computational activity resulting from it has ceased. That is, if an active process receives a message, it acknowledges it immediately. <p> This proves that the liveness property holds. fl 3.4.4 Discussion of the Algorithm It is interesting to compare this algorithm with the similar algorithm by Dijkstra et al. <ref> [9] </ref>. In that algorithm a process is blackened upon sending rather than upon receiving an instantaneously transmitted message. Note that the subformula "8q &gt; t : state q = passive" of P is falsified when process q &gt; t is activated by some p t . <p> A p : f state p = active g state q := active; color p := black Unfortunately, invariant P is not strong enough to exploit the advantage of blackening upon sending, like in <ref> [9] </ref>. We conclude that the transformation of Ben-Ari's garbage collection algorithm yields a termination detection algorithm which is very similar to Dijkstra's algorithm, but less efficient because it needs two control tours rather than one.
Reference: [10] <author> Dijkstra, E.W., L. Lamport, A.J. Martin, C.S. Scholten, E.F.M. Steffens, </author> <title> On-the-fly Garbage Collection: An Exercise in Cooperation, </title> <journal> Comm. </journal> <note> ACM 21 (1978) 966-975. </note>
Reference-contexts: The advantage of this model is that it abstracts from aspects which are not relevant to our purposes, such as processors, memory cells, and the difference between "local" and "remote" references. This model differs from the one used by Dijkstra et al. <ref> [10] </ref> in two important respects. First, our model is based on addition and deletion of references, giving rise to a dynamic number of references in each object. The model of [10] assumes that references are only overwritten by other references, giving rise to a constant (viz., 2) number of references per <p> This model differs from the one used by Dijkstra et al. <ref> [10] </ref> in two important respects. First, our model is based on addition and deletion of references, giving rise to a dynamic number of references in each object. The model of [10] assumes that references are only overwritten by other references, giving rise to a constant (viz., 2) number of references per object. <p> A second difference is the much coarser grain of atomicity that is assumed in our model. As the algorithm of <ref> [10] </ref> was designed for processes communicating via shared memory, a fine grain of atomicity was desirable to minimize synchronization overhead. <p> To obtain an algorithm satisfying G2, usually a supplementary algorithm (typically of the mark-and-sweep type) is used to collect cyclic structures of garbage. In our application, however, cyclic structures of garbage objects do not occur, and a supplementary algorithm is not necessary. 6 Mark-and-sweep <ref> [1, 10, 29, 30] </ref>. Collectors of the second type mark all reachable objects as such, starting from the roots and recursively marking all descendants of marked objects. In this way all reachable objects become marked eventually. <p> Here we only sketch two more transformations, the reader is invited to 27 complete the details and to apply the transformation to other garbage collection schemes (e.g., the well known algorithm by Dijkstra et al. <ref> [10] </ref>). The "classical" garbage collection scheme consists in suspending the execution of the basic program when memory becomes short and run the garbage collector (of the mark-and-sweep type) while the program is stopped.
Reference: [11] <author> Dijkstra, </author> <title> E.W., C.S. Scholten, Termination Detection for Diffusing Computations, </title> <journal> Inf. Proc. Lett. </journal> <month> 11 </month> <year> (1980) </year> <month> 1-4. </month>
Reference-contexts: The introduction of asynchronous communication complicates the problem, as somehow it must be verified that the channels are empty. This can be done using special marker messages (in a FIFO environment) as by Misra [22], acknowledgements as by Dijkstra and Scholten <ref> [11] </ref>, counting of sent and received messages as by Mattern [17], or by assuming an upper bound on message delay as by Tel [32]. 1.1.2 Solutions to the Problem Several classes of solutions to the termination detection problem are known. <p> When the initiators of the computation are passive and have received an acknowledgement for all basic messages, termination is detected. The best known example in this class is the algorithm of Dijkstra and Scholten <ref> [11] </ref>; generalizations of this algorithm were given by Shavit and Francez [28] and Chandrasekaran and Venkatesan [8]. 1.2 The Distributed Garbage Collection Problem As our approach for deriving termination detection algorithms is based on solutions to the garbage collection problem, we shall now describe this problem. <p> A worst case lower bound for this overhead of one control message per basic message was proved by Chandy and Misra [4], and this bound is achieved by the algorithm of Dijkstra and Scholten <ref> [11] </ref>. 2. FIFO Discipline on Links. For the correctness of the algorithm it is required that links deliver messages in the order they were sent. 3. Central Controller. The central object Z acts as a central controller in the Activity Counting algorithm. <p> and RD in the environment should be replaced by if LRC e = 0 then send h term i to all A p . 3.3.3 Discussion of the Algorithm The resulting termination detection algorithm is basically identical to the termination detection scheme for diffusing computations presented by Dijkstra and Scholten <ref> [11] </ref>. The authors call the h Dec i messages "signals" and keep two local counters C p (sum of the deficits of p's incoming edges) and D p (sum of the deficits of p's outgoing edges) for each process p. <p> By (SIG) Dijkstra and Scholten's scheme allows to delay the sending of a signal, but otherwise their scheme is identical to our derived algorithm. Since Dijkstra and Scholten prove the correctness of their scheme in <ref> [11] </ref>, we directly have the following theorem. 22 Theorem 3.6 The LRC termination detection algorithm is a correct termination detec-tion algorithm. The LRC termination detection algorithm has interesting characteristics. <p> Early Termination. A process p holding or having held an o-reference may detect that it is garbage itself and must be collected. Therefore the termination detection algorithm must allow processes to terminate locally even while the computation as a whole has not yet terminated. The algorithm of <ref> [11] </ref> does not have this property: an "engaged" process must remain in the system as long as any of its descendants remain active. These considerations differ from those that are usually taken into account when a termination detection algorithm is designed.
Reference: [12] <author> European Patent Office, </author> <title> Garbage Collection in a Computer System, European Patent Application no 86309082.5. </title> <type> 32 </type>
Reference-contexts: This is the case for example with the weighted reference counting scheme, which yields the Credit Recovery algorithm for termination detection, see Section 3.2. Interestingly, commercial use of the weighted reference counting scheme by Watson and Watson is protected by a patent <ref> [12] </ref> which describes the invention in "a computer system having storage means containing memory cells, at least some of which contain 31 pointers to others".
Reference: [13] <author> Francez, N., </author> <title> Distributed Termination, </title> <journal> ACM Trans. on Prog. Lang. </journal> <note> and Systems 2 (1980) 42-55. </note>
Reference-contexts: The transformation of such a garbage collection algorithm yields a "freezing" termination detection algorithm where no reactivations are possible while the algorithm checks for the termination condition. In fact, one of the first published termination detection schemes (by Francez <ref> [13] </ref>) was a freezing algorithm. Steele [30] describes a mark-and-sweep on-the-fly garbage collection algorithm. In this algorithm, when a reference from a marked to an unmarked object is installed, the marker process must visit the marked object again.
Reference: [14] <author> Goldberg, B., </author> <title> Generational Reference Counting: A Reduced-Communication Distributed Storage Reclamation Scheme, </title> <journal> ACM SIGPLAN Notices 24 (July 1989) 313-321. </journal>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems [7, 21]. Reference Counting <ref> [2, 14, 15, 16, 24, 36] </ref>. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account. <p> Generational Reference Counting. Anonther reference counting principle, called generational reference counting, has been proposed by Goldberg <ref> [14] </ref>. This scheme, like weighted reference counting, avoids h inc; o; q i messages, but uses a different strategy for this. The communication pattern is the same as for the weighted reference counting scheme: a control message is sent to o only upon deletion of an o-reference. <p> Theorem 3.5 The Generational termination detection algorithm is a correct termination detection algorithm. 19 Proof. This result follows from the correctness of the generational reference counting scheme (as demonstrated by Goldberg <ref> [14] </ref>) and Theorem 2.2. fl We present this algorithm as another illustration of our transformation, but Goldberg's remark: "it is not clear if there is any advantage to using the generational reference counting scheme instead of the weighted reference counting scheme" seems to apply equally to the resulting termination detection algorithms.
Reference: [15] <author> Ichisugi, Y., A. Yonezawa, </author> <title> Distributed Garbage Collection Using Group Reference Counting, </title> <type> Technical Report 90-014, </type> <institution> Department of Information Science, University of Tokyo, </institution> <year> 1990. </year> <title> (To be published by World Science Publishing Company: </title> <booktitle> Proc. of the Annual Workshop on Software Science and Engineering, </booktitle> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989) </year>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems [7, 21]. Reference Counting <ref> [2, 14, 15, 16, 24, 36] </ref>. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account. <p> present this algorithm as another illustration of our transformation, but Goldberg's remark: "it is not clear if there is any advantage to using the generational reference counting scheme instead of the weighted reference counting scheme" seems to apply equally to the resulting termination detection algorithms. 3.3 Local Reference Counting In <ref> [15] </ref> Ichisugi and Yonezawa present an interesting distributed garbage collection scheme they call local reference counting (LRC). Basically the same idea was found independently by Piquer [24] ("indirect reference counting") and by Rudalics [26]. <p> For our purpose it is appropriate to assume that exactly one object resides on each node (which means that we identify nodes and objects). The set of rules for garbage identification can then be stated in a slightly adapted form (compared to the rules given in <ref> [15] </ref>) as in Algorithm 11. Obviously, action DZ p can be appended to actions DR p and RD p guarded by a test "if LRC p (o) = 0 then ...".
Reference: [16] <author> Lermen, C.-W., D. Maurer, </author> <title> A Protocol for Distributed Reference Counting, </title> <booktitle> ACM Conference on Lisp and Functional Programming, </booktitle> <address> Cambridge, </address> <year> 1986, </year> <pages> pp. 343-354. </pages>
Reference-contexts: An account of various garbage collection algorithms for multiprocessors and distributed systems was given by Rudalics [25]. Different models for the problem are found in the literature, here a model based on the communicating objects paradigm is presented which is close to the model of Lermen 4 and Maurer <ref> [16] </ref>. The advantage of this model is that it abstracts from aspects which are not relevant to our purposes, such as processors, memory cells, and the difference between "local" and "remote" references. This model differs from the one used by Dijkstra et al. [10] in two important respects. <p> Both types of solutions have been known for over 30 years for classical, non-distributed systems [7, 21]. Reference Counting <ref> [2, 14, 15, 16, 24, 36] </ref>. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account. <p> In Section 3.4 the transformation is applied to a mark-and-sweep garbage collector. 3.1 Distributed Reference Counting In this section we show how the distributed reference counting algorithm of Lermen and Maurer <ref> [16] </ref> can be transformed into a termination detection algorithm. For each non-root object o a reference count RC o is maintained. <p> The correctness of the protocol, as expressed in the following theorem, was proved by Lermen and Maurer in <ref> [16] </ref>. Theorem 3.1 Algorithm 4 is a correct reference counting garbage collection algorithm, that is, it satisfies G1 and G3. 3.1.2 Transformation into a Termination Detection Algorithm In this section a termination detection algorithm is derived from the Lermen-Maurer scheme.
Reference: [17] <author> Mattern, F., </author> <title> Algorithms for Distributed Termination Detection, </title> <booktitle> Distributed Computing 2 (1987) 161-175. </booktitle>
Reference-contexts: This can be done using special marker messages (in a FIFO environment) as by Misra [22], acknowledgements as by Dijkstra and Scholten [11], counting of sent and received messages as by Mattern <ref> [17] </ref>, or by assuming an upper bound on message delay as by Tel [32]. 1.1.2 Solutions to the Problem Several classes of solutions to the termination detection problem are known. The most important ones are those based on probes and those based on acknowledgements. Probe-based Algorithms. <p> It follows that Z can signal termination when V becomes the null vector, and the RC counter is no longer necessary. Some further optimizations (e.g., batching h inc; q i and h Dec i messages) yield a centralized variant of the so-called Vector Counter termination detection algorithm proposed in <ref> [17] </ref>. This algorithm has lower message overhead than the Activity Counting algorithm, does not rely on the FIFO property, and can easily be realized in a distributed way as well. Variations of the Lermen-Maurer Scheme. Two variants of the Lermen-Maurer scheme were proposed by Rudalics [25].
Reference: [18] <author> Mattern, F., </author> <title> Global Quiescence Detection Based on Credit Distribution and Recovery, </title> <journal> Inf. Proc. Lett. </journal> <month> 30 </month> <year> (1989) </year> <month> 195-200. </month>
Reference-contexts: The resulting termination detection algorithm turns out to be an already known algorithm: it was proposed by Mattern <ref> [18] </ref>. 15 CR p : f p is reachable and holds a reference (o; w) g send h cop; o; w=2 i to q ; w := w=2 RC p : f A message h cop; o; w i has arrived g receive h cop; o; w i ; if p <p> The subscript Z is dropped. This finally results in Algorithm 9, which is known as the Credit Recovery algorithm <ref> [18] </ref>. The initial conditions for this algorithm are: W p = 0 if p is passive; W p &gt; 0 if p is active; RC = P p W p ; and no messages are in transit. Theorem 3.4 The Credit Recovery algorithm is a correct termination detection algorithm. Proof.
Reference: [19] <author> Mattern, F., </author> <title> Efficient Distributed Snapshots and Global Virtual Time Algorithms for Non-FIFO Systems, </title> <type> Tech. Rep. </type> <institution> SFB124-24/90, Kaiserslautern University, </institution> <year> 1990. </year>
Reference-contexts: Third, it has been observed that the fundamental difficulties of the termination detection problem are the same as those of other important problems in distributed computing. Indeed, termination detection algorithms are related to algorithms for computing distributed snapshots <ref> [3, 19] </ref>, detecting deadlocks [5, 23], and approximating a distributed infimum [31, 20]. Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view. <p> Communication deadlock detection is a generalization where a part of the network can be terminated [23]; distributed infimum approximation is a generalization where the "property" to be detected takes values from any partially ordered domain, rather than just passive or active <ref> [32, 19, 20] </ref>. 30 S p : (* Send basic message *) send a message (M; x p ) R p : f A basic message has arrived g receive message (M; x) ; x p := x p ^ x I p : (* Internal increase of x *) f
Reference: [20] <author> Mattern, F., H. Mehl, A.A. Schoone, and G. Tel, </author> <title> Global Virtual Time Approximation with Distributed Termination Detection Algorithms, </title> <type> Tech. Rep. </type> <institution> RUU-CS-91-32, Dept. of Computer Science, University of Utrecht, </institution> <year> 1991. </year>
Reference-contexts: Third, it has been observed that the fundamental difficulties of the termination detection problem are the same as those of other important problems in distributed computing. Indeed, termination detection algorithms are related to algorithms for computing distributed snapshots [3, 19], detecting deadlocks [5, 23], and approximating a distributed infimum <ref> [31, 20] </ref>. Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view. From both points of view we consider it useful to recognize general design paradigms for distributed termination detection algorithms. One such paradigm was described by Tel [32]. <p> It was argued by Natarajan [23] that termination is a special case of communication deadlock. It was shown by Tel [32] that termination detection is a special case of global virtual time approximation, and Mattern et al. <ref> [20] </ref> presented a derivation from termination detection algorithms to global virtual time approximation algorithms. Even though in some cases a solution to a "simple" problem is derived from a solution to a more "complicated" problem, we think transformations of this kind are useful for several reasons. 1. <p> Communication deadlock detection is a generalization where a part of the network can be terminated [23]; distributed infimum approximation is a generalization where the "property" to be detected takes values from any partially ordered domain, rather than just passive or active <ref> [32, 19, 20] </ref>. 30 S p : (* Send basic message *) send a message (M; x p ) R p : f A basic message has arrived g receive message (M; x) ; x p := x p ^ x I p : (* Internal increase of x *) f <p> It follows from the basic actions that this function is monotonically increasing. Algorithms for this problem can be derived from termination detection algorithms, as described by Schoone and Tel [31] and Mattern et al. <ref> [20] </ref>. It would be interesting if our current construction could be generalized to obtain Distributed Infimum Approximation algorithms. To this end, instead of the single object Z a directed graph G X of objects could be defined, reflecting the structure of X.
Reference: [21] <author> McCarthy, J., </author> <title> Recursive Functions of Symbolic Expressions and Their Computation by Machine, </title> <journal> Comm. </journal> <note> ACM 3 (1960) 184-195. </note>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems <ref> [7, 21] </ref>. Reference Counting [2, 14, 15, 16, 24, 36]. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account.
Reference: [22] <author> Misra, J., </author> <title> Detecting Termination of Distributed Computations Using Markers, </title> <booktitle> Proc. of the 2nd ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, </address> <year> 1983, </year> <pages> pp. 290-294. </pages>
Reference-contexts: The introduction of asynchronous communication complicates the problem, as somehow it must be verified that the channels are empty. This can be done using special marker messages (in a FIFO environment) as by Misra <ref> [22] </ref>, acknowledgements as by Dijkstra and Scholten [11], counting of sent and received messages as by Mattern [17], or by assuming an upper bound on message delay as by Tel [32]. 1.1.2 Solutions to the Problem Several classes of solutions to the termination detection problem are known.
Reference: [23] <author> Natarajan, N., </author> <title> A Distributed Scheme for Detecting Communication Deadlocks, </title> <journal> IEEE Trans. </journal> <note> on Software Engineering SE-12 (1986) 531-537. </note>
Reference-contexts: Third, it has been observed that the fundamental difficulties of the termination detection problem are the same as those of other important problems in distributed computing. Indeed, termination detection algorithms are related to algorithms for computing distributed snapshots [3, 19], detecting deadlocks <ref> [5, 23] </ref>, and approximating a distributed infimum [31, 20]. Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view. From both points of view we consider it useful to recognize general design paradigms for distributed termination detection algorithms. <p> This family also includes deadlock detection [5] and global virtual time approximation [32]. Several transformations of the same spirit as the one described here have been given between members of this family. It was argued by Natarajan <ref> [23] </ref> that termination is a special case of communication deadlock. It was shown by Tel [32] that termination detection is a special case of global virtual time approximation, and Mattern et al. [20] presented a derivation from termination detection algorithms to global virtual time approximation algorithms. <p> Communication deadlock detection is a generalization where a part of the network can be terminated <ref> [23] </ref>; distributed infimum approximation is a generalization where the "property" to be detected takes values from any partially ordered domain, rather than just passive or active [32, 19, 20]. 30 S p : (* Send basic message *) send a message (M; x p ) R p : f A basic
Reference: [24] <author> Piquer, J., </author> <title> Indirect Reference Counting: A Distributed Garbage Collection Algorithm, </title> <editor> in: E.H.L. Aarts, J. van Leeuwen, M. Rem (eds.), </editor> <booktitle> Proceedings Parallel Architectures and Languages Europe, vol. I, Lecture Notes in Computer Science 505, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 150-165. </pages>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems [7, 21]. Reference Counting <ref> [2, 14, 15, 16, 24, 36] </ref>. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account. <p> Basically the same idea was found independently by Piquer <ref> [24] </ref> ("indirect reference counting") and by Rudalics [26]. The proposed scheme assumes that objects are partitioned into groups and each group is mapped onto a distinct computing node. Thus, the model used here is slightly different from the model described at the beginning of Section 1.2. <p> In particular, a difference between "local" and "remote" objects and references is now made. An interesting feature of the LRC garbage collection scheme is that it supports the migration of objects from one node to another node very easily. The interested reader is referred to <ref> [24] </ref>. 3.3.1 Description of the Scheme For each (local or remote) object o which is referenced by a local object of node N , N has a local reference counter LRC N (o).
Reference: [25] <author> Rudalics, M., </author> <title> Multiprocessor List Memory Management, </title> <type> Technical Report RISC-88-87.0, </type> <institution> Research Institute for Symbolic Computation, J. Kepler University, Linz, </institution> <year> 1988. </year>
Reference-contexts: They are also used in the implementation of functional programming languages as these languages operate on directed graphs, represented by memory cells referencing each other through pointers. An account of various garbage collection algorithms for multiprocessors and distributed systems was given by Rudalics <ref> [25] </ref>. Different models for the problem are found in the literature, here a model based on the communicating objects paradigm is presented which is close to the model of Lermen 4 and Maurer [16]. <p> This algorithm has lower message overhead than the Activity Counting algorithm, does not rely on the FIFO property, and can easily be realized in a distributed way as well. Variations of the Lermen-Maurer Scheme. Two variants of the Lermen-Maurer scheme were proposed by Rudalics <ref> [25] </ref>. We describe informally his three message protocol, which does not rely on FIFO links.
Reference: [26] <author> Rudalics, M., </author> <title> Implementation of Distributed Reference Counts, </title> <type> Technical Report (forthcoming), </type> <institution> Research Institute for Symbolic Computation, J. Kepler University, Linz, </institution> <year> 1990. </year> <month> 33 </month>
Reference-contexts: Basically the same idea was found independently by Piquer [24] ("indirect reference counting") and by Rudalics <ref> [26] </ref>. The proposed scheme assumes that objects are partitioned into groups and each group is mapped onto a distinct computing node. Thus, the model used here is slightly different from the model described at the beginning of Section 1.2.
Reference: [27] <author> Samuelson, P., </author> <title> Should Program Algorithms be Patented?, </title> <booktitle> Comm. ACM 33 (1990), </booktitle> <pages> 23-27. </pages>
Reference-contexts: The implication a patent in such a situation can have in general is too complicated for us and we are glad to leave it as food for lawyers <ref> [27] </ref>. Acknowledgements: We want to thank Martin Rudalics and Jorg Richter for their discussions of the paper and numerous suggestions and comments. We also thank the referees, whose comments have been a great help to improve the quality of this paper.
Reference: [28] <author> Shavit, N., N. Francez, </author> <title> A New Approach to Detection of Locally Indicative Stability, </title> <editor> in: L. Kott (ed.), </editor> <booktitle> Proceedings ICALP 1986, Lecture Notes in Computer Science 226, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986, </year> <pages> pp. 334-358. </pages>
Reference-contexts: When the initiators of the computation are passive and have received an acknowledgement for all basic messages, termination is detected. The best known example in this class is the algorithm of Dijkstra and Scholten [11]; generalizations of this algorithm were given by Shavit and Francez <ref> [28] </ref> and Chandrasekaran and Venkatesan [8]. 1.2 The Distributed Garbage Collection Problem As our approach for deriving termination detection algorithms is based on solutions to the garbage collection problem, we shall now describe this problem.
Reference: [29] <author> Van de Snepscheut, J.L.A, </author> <title> "Algorithms for On-the-fly Garbage Collection" Revisited, </title> <journal> Inf. Proc. Lett. </journal> <month> 24 </month> <year> (1987) </year> <month> 211-216. </month>
Reference-contexts: To obtain an algorithm satisfying G2, usually a supplementary algorithm (typically of the mark-and-sweep type) is used to collect cyclic structures of garbage. In our application, however, cyclic structures of garbage objects do not occur, and a supplementary algorithm is not necessary. 6 Mark-and-sweep <ref> [1, 10, 29, 30] </ref>. Collectors of the second type mark all reachable objects as such, starting from the roots and recursively marking all descendants of marked objects. In this way all reachable objects become marked eventually. <p> In this section it is shown how the garbage collection algorithm of Ben-Ari [1] can be transformed into a termination detection algorithm. (Actually, we use a variant of the algorithm described by Van de Snepscheut <ref> [29] </ref>). This algorithm was designed to run concurrently with a single processor mutating the references contained in memory cells. Thus the copying of a reference is a single atomic step, where we have assumed so far that it consists of the sending and receipt of a message. <p> No cooperation is required when the basic program deletes a reference. The correctness proof of this garbage collection scheme is quite involved; proofs were given by Ben-Ari in [1] and Van de Snepscheut <ref> [29] </ref>. 1 We use the color "gray" instead of "black" (as in the original algorithm [1, 29]) because we need "black" for a different purpose further down. 23 3.4.2 Transformation into a Termination Detection Algorithm In the scheme used to obtain a termination detection algorithm each object can have at most <p> No cooperation is required when the basic program deletes a reference. The correctness proof of this garbage collection scheme is quite involved; proofs were given by Ben-Ari in [1] and Van de Snepscheut [29]. 1 We use the color "gray" instead of "black" (as in the original algorithm <ref> [1, 29] </ref>) because we need "black" for a different purpose further down. 23 3.4.2 Transformation into a Termination Detection Algorithm In the scheme used to obtain a termination detection algorithm each object can have at most one reference, which is always a Z-reference. The transformation is straightforward.
Reference: [30] <author> Steele, G.L., </author> <title> Multiprocessing Compactifying Garbage Collection, </title> <journal> Comm. </journal> <note> ACM 18 (1975) 495-508. </note>
Reference-contexts: To obtain an algorithm satisfying G2, usually a supplementary algorithm (typically of the mark-and-sweep type) is used to collect cyclic structures of garbage. In our application, however, cyclic structures of garbage objects do not occur, and a supplementary algorithm is not necessary. 6 Mark-and-sweep <ref> [1, 10, 29, 30] </ref>. Collectors of the second type mark all reachable objects as such, starting from the roots and recursively marking all descendants of marked objects. In this way all reachable objects become marked eventually. <p> The transformation of such a garbage collection algorithm yields a "freezing" termination detection algorithm where no reactivations are possible while the algorithm checks for the termination condition. In fact, one of the first published termination detection schemes (by Francez [13]) was a freezing algorithm. Steele <ref> [30] </ref> describes a mark-and-sweep on-the-fly garbage collection algorithm. In this algorithm, when a reference from a marked to an unmarked object is installed, the marker process must visit the marked object again.
Reference: [31] <author> Schoone, A.A., G. Tel, </author> <title> Transformation of a Termination Detection Algorithm and its Assertional Correctness Proof, </title> <type> Tech. Rep. </type> <institution> RUU-CS-88-40, Dept. of Computer Science, University of Utrecht, </institution> <year> 1988. </year>
Reference-contexts: Third, it has been observed that the fundamental difficulties of the termination detection problem are the same as those of other important problems in distributed computing. Indeed, termination detection algorithms are related to algorithms for computing distributed snapshots [3, 19], detecting deadlocks [5, 23], and approximating a distributed infimum <ref> [31, 20] </ref>. Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view. From both points of view we consider it useful to recognize general design paradigms for distributed termination detection algorithms. One such paradigm was described by Tel [32]. <p> It follows from the basic actions that this function is monotonically increasing. Algorithms for this problem can be derived from termination detection algorithms, as described by Schoone and Tel <ref> [31] </ref> and Mattern et al. [20]. It would be interesting if our current construction could be generalized to obtain Distributed Infimum Approximation algorithms. To this end, instead of the single object Z a directed graph G X of objects could be defined, reflecting the structure of X.
Reference: [32] <author> Tel, G., </author> <title> Distributed Infimum Approximation, </title> <type> Tech. Rep. </type> <institution> RUU-CS-86-12, Dept. of Computer Science, University of Utrecht, </institution> <year> 1986. </year>
Reference-contexts: Thus the problem is seen to be important both from a practical, algorithmical, and from a theoretical, methodological point of view. From both points of view we consider it useful to recognize general design paradigms for distributed termination detection algorithms. One such paradigm was described by Tel <ref> [32] </ref>. A new paradigm is presented in this paper: it is shown that the semantics of the termination detection problem is fully contained in the semantics of the garbage collection problem. As a result, termination detection algorithms are obtained as suitable instantiations of garbage collection algorithms. <p> This can be done using special marker messages (in a FIFO environment) as by Misra [22], acknowledgements as by Dijkstra and Scholten [11], counting of sent and received messages as by Mattern [17], or by assuming an upper bound on message delay as by Tel <ref> [32] </ref>. 1.1.2 Solutions to the Problem Several classes of solutions to the termination detection problem are known. The most important ones are those based on probes and those based on acknowledgements. Probe-based Algorithms. <p> The best known example in this class is the algorithm by Dijkstra et al. [9], a general treatment is given by Tel <ref> [32] </ref>. Acknowledgement-based Solutions. In these algorithms all messages of the basic computation are acknowledged, but only after all computational activity resulting from it has ceased. That is, if an active process receives a message, it acknowledges it immediately. <p> Termination detection and garbage collection belong to a family of problems concerning the detection of stable properties in distributed systems. This family also includes deadlock detection [5] and global virtual time approximation <ref> [32] </ref>. Several transformations of the same spirit as the one described here have been given between members of this family. It was argued by Natarajan [23] that termination is a special case of communication deadlock. It was shown by Tel [32] that termination detection is a special case of global virtual <p> also includes deadlock detection [5] and global virtual time approximation <ref> [32] </ref>. Several transformations of the same spirit as the one described here have been given between members of this family. It was argued by Natarajan [23] that termination is a special case of communication deadlock. It was shown by Tel [32] that termination detection is a special case of global virtual time approximation, and Mattern et al. [20] presented a derivation from termination detection algorithms to global virtual time approximation algorithms. <p> Communication deadlock detection is a generalization where a part of the network can be terminated [23]; distributed infimum approximation is a generalization where the "property" to be detected takes values from any partially ordered domain, rather than just passive or active <ref> [32, 19, 20] </ref>. 30 S p : (* Send basic message *) send a message (M; x p ) R p : f A basic message has arrived g receive message (M; x) ; x p := x p ^ x I p : (* Internal increase of x *) f
Reference: [33] <author> Tel, G., </author> <title> Total Algorithms, </title> <note> Algorithms Review 1 (1990) 13-42. </note>
Reference-contexts: Probe-based Algorithms. A probe is a distributed activity that "visits" all processes in the network. (It can be implemented by a token circulating on a ring, by an echo mechanism, or in many other ways, see Tel <ref> [33] </ref>.) To detect termination using probes, an attempt is made to maintain a state in which all visited processes are passive, and no message is underway to a visited process. A violation of this aim occurs when a non-visited process sends a message to a visited one.
Reference: [34] <author> Tel, G., R.B. Tan, J. van Leeuwen, </author> <title> The Derivation of Graph Marking Algorithms from Distributed Termination Detection Protocols, </title> <booktitle> Science of Computer Programming 10 (1988) 107-137. </booktitle>
Reference-contexts: The objects in the system must cooperate with the marking algorithm, e.g., by also marking objects when references are installed, copied, or removed. A possible design, presented by Tel et al. <ref> [34] </ref> consists of an algorithm for the marking proper, upon which a termination detection algorithm is superimposed. When the marking phase is terminated, a sweep through all objects is made in which all unmarked objects are collected. <p> algorithm is already known; it is the LRC termination detection scheme (Algorithm 12) derived in Section 3.3.2|A 0 plays the role of the environment e, and RC p plays the role of the local reference counter LRC p . 4.3 Reverse Transformation It was already observed by Tel et al. <ref> [34] </ref> that detecting the termination of the marking phase emerges as a natural subproblem in mark-and-sweep garbage collectors. It was shown that the choice of a particular termination detection algorithm has a major influence on the resulting garbage collection algorithm.
Reference: [35] <author> Weng, K.-S., </author> <title> An Abstract Implementation for a Generalized Dataflow Language, </title> <type> Technical Report MIT/LCS/TR-228, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1979. </year>
Reference-contexts: The object can be collected when its reference count drops to zero. 3.2.1 Description of the Scheme Distributed weighted reference counting schemes have been given by Bevan [2], Watson and Watson [36], and others. The principle was attributed to Weng <ref> [35] </ref>. In its description, see Algorithm 7, again the mechanism to create new objects is omitted. An o-reference is now a tuple (o; w), where w denotes the weight of the reference.
Reference: [36] <author> Watson, P., I. Watson, </author> <title> An Efficient Garbage Collection Scheme for Parallel Computer Architectures, </title> <editor> in: J.W. de Bakker, A.J. Nijman, P.C. Treleaven (eds.), </editor> <booktitle> Proceedings Parallel Architectures and Languages Europe, vol. II, Lecture Notes in Computer Science 259, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987, </year> <pages> pp. 432-443. 34 </pages>
Reference-contexts: Both types of solutions have been known for over 30 years for classical, non-distributed systems [7, 21]. Reference Counting <ref> [2, 14, 15, 16, 24, 36] </ref>. Collectors of the first type maintain for each non-root object a count of the number of references in existence to that object. References in other objects as well as references in messages are taken into account. <p> The object can be collected when its reference count drops to zero. 3.2.1 Description of the Scheme Distributed weighted reference counting schemes have been given by Bevan [2], Watson and Watson <ref> [36] </ref>, and others. The principle was attributed to Weng [35]. In its description, see Algorithm 7, again the mechanism to create new objects is omitted. An o-reference is now a tuple (o; w), where w denotes the weight of the reference. <p> Theorem 3.3 Algorithm 7 is a correct reference counting garbage collection algorithm, that is, it satisfies G1 and G3. Proof. A correctness proof and analysis of the scheme is given by Bevan [2] and by Watson and Watson <ref> [36] </ref> and is based on invariance of the following two assertions: 16 S p : f state p = active g (* Thus p has a Z-reference (Z; w) *) send a message hM; h cop; Z; w=2 ii to q ; w := w=2 R p : f A basic
References-found: 36

