URL: http://www.cs.purdue.edu/homes/sb/Projects/Musketeers/doc/CSD-TR-96-014.ps
Refering-URL: http://www.cs.purdue.edu/homes/sb/papers/LIST.html
Root-URL: http://www.cs.purdue.edu
Title: A Performance Monitoring Environment and its Use for the Study of Paging and I/O Activity
Author: Kuei Yu Wang and Dan C. Marinescu 
Keyword: performance measurement, monitoring tools, performance evaluation methodologies, demand paging, I/O, gang scheduling, parallel and distributed programming, MIMD systems  
Address: West Lafayette, IN 47907-1398  
Affiliation: Computer Sciences Department Purdue University  
Abstract: We present a suite of tools the Musketeers for monitoring and analysis of paging, I/O and communication activity of parallel programs. The tools support automatic instrumentation and allow the user to select the statements to be instrumented and to define the format of a trace record, and to include data from kernel structures and from the user's address space. We discuss a methodology to correlate the activity of processes running concurrently, regardless of the size of the process group. Such a correlation is necessary because I/O and paging devices, as well as the interconnection network of an MPP, are shared resources subject to the load generated by all processes running concurrently. In addition to finding the load placed upon system resources, the methodology is useful for studying means to improve the I/O throughput by buffering I/O requests directed to the same device within a certain time window and transferring large I/O data blocks from the I/O device or for studying scheduling. Finally, we present results of measurements of paging and I/O activity for several parallel programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.J.Atallah, C.Lock, D.C.Marinescu, H.J.Siegel, and T.L.Casavant, </author> <title> "Models and algorithms for co-scheduling compute-intensive tasks on a network of workstations," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> vol. 16, </volume> <pages> pp. 319-327, </pages> <year> 1992. </year>
Reference-contexts: The information we gathered from the study of the paging activity of our own programs and of the NAS benchmark suite confirms that in case of gang scheduling or co-scheduling of tasks on MPPs, <ref> [1] </ref>, it is not feasible to hide the high latency of a page fault by a context switch of the process group. A process group consists of all processes which need to be scheduled concurrently. <p> To use effectively networks of workstations for solving large problems, their operating systems need to support some form of co-scheduling <ref> [1] </ref>. At the present time MPP operating systems like the Paragon OSF support static gang scheduling with busy waiting. This means that once a page fault occurs the PE blocks until the page is brought in. This clearly affects the overall processor utilization.
Reference: [2] <author> R.A.Aydt, </author> <title> "The Pablo Self-Defining Data Format," </title> <type> Technical Report, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <address> 41 pages, </address> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: The format of the trace files is consistent with the Self Defining Data Format (SDDF), <ref> [2] </ref>. By generating trace records in SDDF we can use data processing and visualization facilities provided by Pablo, and also be able to translate the data into other formats, e.g. PICL, and then use ParaGraph for data visualization. Porthos.
Reference: [3] <author> D. Bailey, E. Barszcz, J. Barton, D. Browning, R. Carter, L. Dagum, R. Fatoohi, S. Fineberg, P. Frederickson, T. Lasinski, R. Schreiber, H. Simon, V. Venkatakrishnan and S. Weer-atunga, </author> <title> "The NAS Parallel Benchmarks," </title> <type> RNR Technical Report RNT-94-007, </type> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: In the same section, we analyze programs developed by others and widely distributed as the NAS benchmark suite <ref> [3, 4] </ref>. 2 The Musketeers Our goal in designing the Musketeers was to create simple tools for system architects and more sophisticated users of parallel machines. <p> This technique is well suited for the new generation of Paragon systems with two compute and one communication processors per node. We use the NAS Integer Sort (IS) benchmark <ref> [3, 4] </ref> to compare the approaches presented above, see Figure 1 for execution time and Table 1 for load size of IS with different trace libraries. The IS benchmark is suitable for studying the overhead of trace library because of the communication pattern among the compute nodes. <p> structures or the structure of the performance data, in case of Windows NT, provides the flexibility expected from a portable tool. 18 3 Applications We used the Musketeers tools to study the performance of programs developed by our group and by others, such as those in the NAS benchmark suite <ref> [3] </ref>. Our group is developing parallel programs for solving very large structural biology problems [8, 9], and we used the tools described in the previous sections to study the performance of these programs.
Reference: [4] <author> D.Bailey, E.Barszcz, L.Dagum, and H.Simmon, </author> <title> "NAS Parallel Benchmark Results 10-94," </title> <type> NAS Technical Report NAS-94-001, </type> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: In the same section, we analyze programs developed by others and widely distributed as the NAS benchmark suite <ref> [3, 4] </ref>. 2 The Musketeers Our goal in designing the Musketeers was to create simple tools for system architects and more sophisticated users of parallel machines. <p> This technique is well suited for the new generation of Paragon systems with two compute and one communication processors per node. We use the NAS Integer Sort (IS) benchmark <ref> [3, 4] </ref> to compare the approaches presented above, see Figure 1 for execution time and Table 1 for load size of IS with different trace libraries. The IS benchmark is suitable for studying the overhead of trace library because of the communication pattern among the compute nodes.
Reference: [5] <author> P.C.Bates, </author> <title> "Effective Instrumentation is the Key to Effective Monitoring," </title> <booktitle> Proceedings of 1991 IEEE 11th. International Conference on Distributes Computing Systems, </booktitle> <address> Arlington, TX, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The "probe effects" measure how the instrumentation alters the behavior of the original program. The "instrumentation mechanism" influences how the annotations alter the program and what they can deliver as raw information <ref> [5, 16, 23] </ref>.
Reference: [6] <author> R.Blake, </author> <title> "Optimizing Windows NT Windows NT Resource Kit," Microsoft Press, </title> <journal> vol. </journal> <volume> 4, </volume> <year> 1995. </year>
Reference-contexts: In this paper we report on Musketeers, a suite of tools designed specifically to monitor the paging, I/O and communication activity of parallel programs running on distributed memory MIMD systems. At a time when performance monitoring tools are increasingly integrated with operating systems - e.g. the NT Performance Monitor <ref> [6] </ref> and with the compilers, we have built an environment for performance monitoring that can be ported with relative ease to very different systems. <p> The virtual memory manager provides a set of services allowing processes to allocate memory, read and write virtual memory, lock pages in memory, protect pages, flush pages to the backing store, and share memory. The NT system has a Performance Monitor <ref> [6] </ref>. This tool allows a user to collect performance data pertinent to core objects like processes, threads, processor (s), memory, cache, paging file, logical and physical disk and others. Some of the objects can have multiple instances, e.g. there 17 could be multiple processes, threads, disks, processors, and so on. <p> The function of the core SDL in the NT environment is the retrieval of performance counters from the system's registry database through the registry-queuering mechanism provided by NT <ref> [6] </ref>. The SDL extracts from the NT structures only those performance counters requested by the user. Porting the Musketeers to the NT environment proved that our design philosophy was correct. Writing the tool in Tcl/Tk allows us to port it to a variety of environments with minimal effort.
Reference: [7] <author> D.C.Burger, R.S.Hyder, B.P.Miller, and D.A.Wood. </author> <title> "Paging Tradeoffs in Distributed-Shared-Memory Multiprocessors," </title> <booktitle> Proceedings of Supercomputing '94, </booktitle> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The operating system support for demand paging in MPPs and the realization that, for many applications, existing MPPs are I/O bound created the need to gather data covering the paging and I/O behavior of parallel programs. Burger et al. in <ref> [7] </ref> report on the behavior of some shared memory parallel programs on a simulated distributed shared memory machine, arguing that demand paging has limited value on current parallel machines because of the synchronization and memory reference patterns of parallel applications and the high page-fault and context switching overheads of parallel machines.
Reference: [8] <author> M.A. Cornea-Hasegan, D.C. Marinescu, and Z. Zhang, </author> <title> "Data Management for a Class of Iterative Computations on Distributed Memory MIMD Systems," </title> <journal> Concurrency: Practice and Experience, </journal> <volume> vol. 6(3), </volume> <pages> pp. 205-229, </pages> <year> 1994. </year>
Reference-contexts: Our group is developing parallel programs for solving very large structural biology problems <ref> [8, 9] </ref>, and we used the tools described in the previous sections to study the performance of these programs. We discuss below the use of the Musketeers tools to optimize two programs in the Molecular Replacement suite, envelope and fftsynth. The envelope program computes the molecular envelope of a virus. <p> The program implements a shared virtual memory and operates in two modes, the DD mode, where the shared virtual memory resides on the external storage device, and the DC mode, where the input data is distributed over the set of compute nodes. Reference <ref> [8] </ref> describes different data management strategies for implementing a shared virtual memory. The entire data set is partitioned into Data Allocation Units, DAUs. The working set of DAU j consists of all DAUs needed to carry out the computations associated with DAU j .
Reference: [9] <author> M.A. Cornea-Hasegan, Z. Zhang, Robert E. Lynch D.C. Marinescu, Andrea Hadfield, Jodi K. Muckelbauer, Sanjeev Munshi, Liang Tong, and Michael G. Rossmann, </author> <title> "Phase Refinement and Extension by Means of Non-crystallographic Symmetry Averaging using Parallel Computers," </title> <journal> Acta Crystallographica, </journal> <volume> D51, </volume> <pages> pp. 749-759, </pages> <year> 1995. </year>
Reference-contexts: Finally, it covers porting the tools to the NT environment. In Section 3, we describe a set of programs used for solving very large problems in structural biology, namely the phase refinement and extension of electron density maps of large viruses <ref> [9] </ref>, and present the result of measurements. <p> Our group is developing parallel programs for solving very large structural biology problems <ref> [8, 9] </ref>, and we used the tools described in the previous sections to study the performance of these programs. We discuss below the use of the Musketeers tools to optimize two programs in the Molecular Replacement suite, envelope and fftsynth. The envelope program computes the molecular envelope of a virus.
Reference: [10] <author> H.Custer, </author> <title> "Inside Windows NT," </title> <publisher> Microsoft Press, </publisher> <year> 1993. </year> <month> 31 </month>
Reference-contexts: The micro kernel provides low level operating system functions like thread scheduling, interrupt dispatching and synchronization, I/O, and handling of basic objects. The dynamic link library layer, DLL, insulates the kernel, called NT executive, from hardware dependencies <ref> [10] </ref>. A few comments covering I/O and virtual memory in Windows NT follow. In NT, I/O operations involve file objects.
Reference: [11] <author> G.A.Geist, M.T.Heath, B.W.Peyton, and P.H.Worley. "PICL: </author> <title> A Portable Instrumented Communication Library, C Reference manual," </title> <type> Technical Report ORNL/TM-11130, </type> <institution> Oak Ridge National Laboratory, Oak Ridge, TN, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Dynamic instrumentation allows instructions for data collection to be inserted at run time into an application. ParaGraph [12, 13] is a general-purpose graphics system for visualizing the behavior and performance of parallel programs on message-passing multi-computer architectures. ParaGraph can be combined with PICL, Portable Instrumented Communication Library <ref> [11] </ref>, which supports portability and instrumentation. AIMS, discussed in [28], is a comprehensive set of performance tools for parallel message passing programs and it supports source code instrumentation, run-time monitoring, graphical profiles and automated modeling techniques.
Reference: [12] <author> M. T. Heath and J. A. Etheridge, </author> <title> "Visualizing Performance of Parallel Programs," </title> <journal> IEEE Software, </journal> <volume> 8(5), </volume> <pages> pp. 29-39, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Paradyn [14, 17] takes a different approach, a dynamic instrumentation, to build scalable tools for studying long-running parallel programs. Dynamic instrumentation allows instructions for data collection to be inserted at run time into an application. ParaGraph <ref> [12, 13] </ref> is a general-purpose graphics system for visualizing the behavior and performance of parallel programs on message-passing multi-computer architectures. ParaGraph can be combined with PICL, Portable Instrumented Communication Library [11], which supports portability and instrumentation.
Reference: [13] <author> M. T. Heath and J. A. Etheridge. "ParaGraph: </author> <title> A Tool for Visualizing Performance of Parallel Programs," </title> <type> Technical Report, </type> <institution> Oak Ridge National Laboratory, Oak Ridge, TN, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Paradyn [14, 17] takes a different approach, a dynamic instrumentation, to build scalable tools for studying long-running parallel programs. Dynamic instrumentation allows instructions for data collection to be inserted at run time into an application. ParaGraph <ref> [12, 13] </ref> is a general-purpose graphics system for visualizing the behavior and performance of parallel programs on message-passing multi-computer architectures. ParaGraph can be combined with PICL, Portable Instrumented Communication Library [11], which supports portability and instrumentation.
Reference: [14] <author> J.K.Hollingsworth, B.P.Miller and J.Cargille, </author> <title> "Dynamic Program Instrumentation for Scalable Performance Tools," </title> <booktitle> Proceedings of the 1994 Scalable High Performance Computing Conference, </booktitle> <address> Knoxville, TN, </address> <pages> pp. 841-850, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Pablo includes software performance instrumentation, graphical performance data reduction and analysis, and support for mapping performance data to both graphics and sound. The performance tools are built from individual modules that can be interconnected and reconfigured. Paradyn <ref> [14, 17] </ref> takes a different approach, a dynamic instrumentation, to build scalable tools for studying long-running parallel programs. Dynamic instrumentation allows instructions for data collection to be inserted at run time into an application.
Reference: [15] <author> A.D. Malony, D.A. Reed, </author> <title> and D.C. Rudolph, "Integrating Performance, Data Collection, Analysis and Visualization," Performance Instrumentation and Visualization, </title> <editor> (M. Simmons, R. Koskela, eds.), </editor> <publisher> Addison Wesley, </publisher> <pages> 289 pages, </pages> <year> 1990. </year>
Reference-contexts: Pablo <ref> [15, 22] </ref> is a performance analysis environment supporting data capture, analysis, and presentation across a variety of platforms and programming languages. Pablo includes software performance instrumentation, graphical performance data reduction and analysis, and support for mapping performance data to both graphics and sound.
Reference: [16] <author> A.D. Malony, D.A. Reed, and H.A.Wijshoff, </author> <title> "Performance Measurement Intrusion and Perturbation Analysis," </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(4), </volume> <pages> pp. 433-450, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The "probe effects" measure how the instrumentation alters the behavior of the original program. The "instrumentation mechanism" influences how the annotations alter the program and what they can deliver as raw information <ref> [5, 16, 23] </ref>.
Reference: [17] <author> B.P. Miller, M.D. Gallaghan, J.M. Cargille, J.K. Hollingsworth, R.B. Irvin, K.L. Karavanic, K. Kunchitapadam, and T. Newhall, </author> <title> "The Paradyn Parallel Measurement Tool," </title> <journal> IEEE Computer, </journal> <volume> 28(11), pp.37-46, </volume> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: Pablo includes software performance instrumentation, graphical performance data reduction and analysis, and support for mapping performance data to both graphics and sound. The performance tools are built from individual modules that can be interconnected and reconfigured. Paradyn <ref> [14, 17] </ref> takes a different approach, a dynamic instrumentation, to build scalable tools for studying long-running parallel programs. Dynamic instrumentation allows instructions for data collection to be inserted at run time into an application.
Reference: [18] <author> R.E. Lynch and Z. Zhang, </author> <title> "Timing Results of a Parallel FFTSynth," </title> <type> Technical Report CSD-TR-94-054, </type> <institution> Purdue University, Department of Computer Sciences, </institution> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Both modes exploit the locality of reference and attempt to minimize the number of DAU faults by processing the DAUs assigned to each compute node to maximize the intersection of the working sets of DAUs processed in sequence. The second program, fftsynth <ref> [18] </ref>, carries out a 3-D FFT. It reads in a set of complex valued structure factors (discrete Fourier coefficients), computes the FFT and writes out the calculated electron density. A 3-D FFT is obtained by a 2-D FFT followed by a 1-D FFT in the third dimension.
Reference: [19] <author> D.C. Marinescu, J.E. Lumpp, T.L. Casavant, and H.J. Siegel, </author> <title> "Models for Monitoring and Debugging Tools for Parallel and Distributed Software," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> vol. 9, </volume> <pages> pp. 171-184, </pages> <year> 1990. </year>
Reference-contexts: Other challenges in designing performance monitoring and analysis tools for parallel and distributed system are: guiding the user in the instrumentation process, collecting data during parallel program execution with minimal intrusion <ref> [19] </ref>, data reduction and analysis, and the ability to present the results in a meaningful way. 1 A large number of performance monitoring and analysis tools exist, yet in this paper we sur-vey only a few: Pablo, a large scale effort undertaken by Reed and his co-workers at University of Illinois, <p> Sometimes a compiler may 7 support the instrumentation of a program. One of the most serious concerns when instrumenting a program is the level of intrusion of the monitoring process. Any measuring system perturbs the system being observed to some degree <ref> [19] </ref>. Hardware probes are the least intrusive but their use is limited by cost and scope of the monitoring process; usually they deliver low-level information with limited or no context. Software probes are the most intrusive but their use is widespread, sometimes in conjunction with some hardware support.
Reference: [20] <author> J.K.Ousterhout, </author> <title> "Scheduling Techniques for Concurrent Systems". </title> <booktitle> 3rd Intl. Conf. Distributed Computing Systems, </booktitle> <pages> pp. 22-30, </pages> <month> Oct. </month> <year> 1982. </year> <month> 32 </month>
Reference-contexts: Recently MPPs like the Intel Paragon or IBM SP2 running commodity operating systems and offering demand paged virtual memory have emerged. Gang scheduling is a concept introduced by Ousterhout <ref> [20] </ref>. He observed that a MIMD system performance degrades when a parallel application does not have all its interacting processes scheduled at the same time.
Reference: [21] <author> J.K.Ousterhout, </author> <title> "Tcl and the Tk Toolkit," </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: make the Musketeers flexible and easy to port, such as the use of templates to define the statements to be instrumented and to describe 2 kernel data structures, the generation of dynamic libraries to support a user defined format for the trace records, the use of the Tcl and Tk <ref> [21] </ref> for creating the GUI, can be encountered in some system designed in the past. We built the Musketeers because the learning curve of most of the existing tools is rather steep and none of them allowed us to study the paging activity of parallel programs. <p> The graphical user interface (GUI) based on the X Window system with Motif-like user interface is built using the Tcl and Tk <ref> [21] </ref> software packages. To allow manipulation of data stored on different systems and to run on heterogeneous environments, the Musketeers suite uses the Bond system.
Reference: [22] <author> D.A.Reed, R.A.Aydt, T.M.Madhyastha, R.J.Noe, K.A.Shields, and B.W.Schwartz, </author> <title> "An Overview of the Pablo Performance Analysis Environment," </title> <type> Technical Report, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <address> 39 pages, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Pablo <ref> [15, 22] </ref> is a performance analysis environment supporting data capture, analysis, and presentation across a variety of platforms and programming languages. Pablo includes software performance instrumentation, graphical performance data reduction and analysis, and support for mapping performance data to both graphics and sound.
Reference: [23] <author> S.R.Sarukkai and A.D.Malony, </author> <title> "Perturbation Analysis of High Level Instrumentation for SPMD Programs," </title> <booktitle> Proceedings of the 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <address> San Diego, CA, </address> <pages> pp. 44-53, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The "probe effects" measure how the instrumentation alters the behavior of the original program. The "instrumentation mechanism" influences how the annotations alter the program and what they can deliver as raw information <ref> [5, 16, 23] </ref>.
Reference: [24] <author> M.G.Sirbu and D.C.Marinescu, </author> <title> "Bond A Parallel Virtual Environment," To appear in: </title> <booktitle> Proceedings of HPCN Europe '96, Lecture Notes in Computer Sciences, </booktitle> <publisher> Springer Verlag 1996. </publisher>
Reference-contexts: The graphical user interface (GUI) based on the X Window system with Motif-like user interface is built using the Tcl and Tk [21] software packages. To allow manipulation of data stored on different systems and to run on heterogeneous environments, the Musketeers suite uses the Bond system. Bond <ref> [24] </ref> is a parallel virtual environment which allows the execution of parallel and sequential programs on sequential machines, clusters of workstations, and massively parallel systems.
Reference: [25] <author> K.Y.Wang and D.C.Marinescu, </author> <title> "Correlation of the Paging Activity of Individual Node Programs in the SPMD Execution Mode," </title> <journal> Proceedings of HICSS'28, IEEE Press, </journal> <volume> vol. 1, </volume> <pages> pp. 61-71, </pages> <year> 1995. </year>
Reference-contexts: For most of the parallel applications studied, the profiles for different paging activity indicators show transients of high paging activity, peaks, intermixed with longer periods of low activity, backgrounds. Thus, data reduction <ref> [25] </ref> is the first step of the analysis and consists of: peak selection, background filtering, and skyline representation for each individual trace data file. The data reduction is used to expedite the identification of activity bursts and to reduce the amount of data needed for describing the program behavior. <p> Details about 27 benchmark running on 64 nodes. The total execution time was 47.46 seconds and the time reported by the NAS benchmark was 9.89 seconds. measurements reported here can be found in <ref> [25, 26, 27] </ref>. Further measurements are necessary to establish a correlation between the paging activity, the process working set of a process group, and the communication patterns of the application.
Reference: [26] <author> K.Y.Wang, </author> <title> "A Study of Intrusion of a Software Trace System in the Execution of Parallel Programs," </title> <type> Technical Report CSD-TR-94-078, </type> <institution> Purdue University, Department of Computer Sciences, </institution> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The information 5 collected during probing can be used to reduce the amount of data collected during the program monitoring to a minimum and to guarantee the least intrusive monitoring experiment <ref> [26] </ref> capable of collecting all relevant data needed for the performance analysis. The format of the trace files is consistent with the Self Defining Data Format (SDDF), [2]. <p> The objective of the techniques described below is to overlap communication and I/O operations related to the writing of trace data with the actual execution of the original code by the compute nodes. An in depth discussion of our studies can be found in <ref> [26] </ref>. NOPT no optimization. This method is based upon a naive implementation of SDL, the system dependent trace libraries. The buffer size equals the size of the largest trace record, and a buffer is written to the external storage immediately after being filled in when an event occurs 1 . <p> Details about 27 benchmark running on 64 nodes. The total execution time was 47.46 seconds and the time reported by the NAS benchmark was 9.89 seconds. measurements reported here can be found in <ref> [25, 26, 27] </ref>. Further measurements are necessary to establish a correlation between the paging activity, the process working set of a process group, and the communication patterns of the application.
Reference: [27] <author> K.Y.Wang and D.C.Marinescu, </author> <title> "Characterization of the Paging Activity of NAS Benchmark Programs on the Intel Paragon," </title> <type> Technical Report CSD-TR-95-015, </type> <institution> Purdue University, Department of Computer Sciences, </institution> <month> Mar. </month> <year> 1995, </year> <title> also Intel Supercomputer User's Group Conference, </title> <institution> Sandia National Laboratory, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Details about 27 benchmark running on 64 nodes. The total execution time was 47.46 seconds and the time reported by the NAS benchmark was 9.89 seconds. measurements reported here can be found in <ref> [25, 26, 27] </ref>. Further measurements are necessary to establish a correlation between the paging activity, the process working set of a process group, and the communication patterns of the application.
Reference: [28] <author> J.Yan, S Sarukkai and P. Mehra, </author> <title> "Performance Measurement, Visualization and Modeling of Parallel and Distributed Programs using the AIMS Toolkits,' </title> <journal> Software, Practice and Experience, </journal> <volume> vol. 25 n. 4, </volume> <pages> p. 429-461, </pages> <month> Apr. </month> <year> 1995. </year> <month> 33 </month>
Reference-contexts: ParaGraph [12, 13] is a general-purpose graphics system for visualizing the behavior and performance of parallel programs on message-passing multi-computer architectures. ParaGraph can be combined with PICL, Portable Instrumented Communication Library [11], which supports portability and instrumentation. AIMS, discussed in <ref> [28] </ref>, is a comprehensive set of performance tools for parallel message passing programs and it supports source code instrumentation, run-time monitoring, graphical profiles and automated modeling techniques.
References-found: 28

