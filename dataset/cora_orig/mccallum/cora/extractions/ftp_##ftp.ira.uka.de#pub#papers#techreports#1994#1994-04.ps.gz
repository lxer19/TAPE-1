URL: ftp://ftp.ira.uka.de/pub/papers/techreports/1994/1994-04.ps.gz
Refering-URL: http://wwwipd.ira.uka.de/~hopp/cupit.html
Root-URL: 
Title: CuPit A Parallel Language for Neural Algorithms: Language Reference and Tutorial  
Author: Lutz Prechelt 
Address: 76128 Karlsruhe, Germany  
Affiliation: Institut fur Programmstrukturen und Datenorganisation Universitat Karlsruhe  
Pubnum: Technical Report  
Email: (prechelt@ira.uka.de)  
Phone: ++49/721/608-4068, Fax: ++49/721/694092  
Date: January 20, 1994  4/94  
Abstract: and load balancing even for irregular neural networks. The idea to achieve these goals lies in the programming model: CuPit programs are object-centered, with connections and nodes of a graph (which is the neural network) being the objects. Algorithms are based on parallel local computations in the nodes and connections and communication along the connections (plus broadcast and reduction operations). This report describes the design considerations and the resulting language definition and discusses in detail a tutorial example program. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [AR88] <editor> J.A. Anderson and E. Rosenfeld, editors. Neurocomputing: </editor> <booktitle> Foundations of Research. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference: [GHL + 92] <author> Robert W. Gray, Vincent P. Heuring, Steven P. Levi, Anthony M. Sloane, and William M. Waite. Eli: </author> <title> A complete, flexible compiler construction system. </title> <journal> Communications of the ACM, </journal> <volume> 35(2) </volume> <pages> 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: In order to fulfill purpose (c), the report contains a complete syntax specification of CuPit in the notation of the Eli <ref> [GHL + 92] </ref> compiler construction system. This specification is typeset with FunnelWeb [Wil92] and can automatically be extracted and used to generate the front-end of the CuPit compiler. 1 Purpose and scope of the language Before anything else, it is necessary to describe what the scope of CuPit is. <p> CupitProgram: CupitParts. CupitParts: /* nothing */ / CupitParts CupitPart ';'. CupitPart: TypeDef / DataObjectDef / 62 15 BASIC SYNTACTIC ELEMENTS ProcedureDef / FunctionDef / ReductionFunctionDef / WtaFunctionDef. g This macro is invoked in definition 85. All these definitions are now put into the Eli <ref> [GHL + 92] </ref> grammar specification file grammar.con: grammar.con [85] 85 f Cupit Program [84] Type Definition [31] Subroutine Definition [43] Data Object Definition [42] Statement [50] Expression [64] g This macro is attached to an output file. 15 Basic syntactic elements All keywords and operators in a CuPit program must appear <p> It is a compiler that generates MPL code for the MasPar MP-1/MP-2 massively parallel SIMD machine (16384 processors). MPL is MasPar's data parallel C variant. The compiler is fully functional and is implemented using the Eli compiler construction system <ref> [GHL + 92] </ref>. The compiler source code is written as a FunnelWeb literate programming document. This means the source code is available as a well-structured 300 page document with table of contents, global keyword index, and interspersed documentation text.
Reference: [Hoa83] <author> C. A. R. Hoare. </author> <title> Hints on programming language design. </title> <editor> In Ellis Horowitz, editor, </editor> <booktitle> Programming Languages: A Grand Tour, </booktitle> <pages> pages 31-40. </pages> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: To guide this requirements definition process we use the concept taxonomy, which is shown in figure 2, plus the following general idea: A programming language should allow to model a problem and its solution in natural terms in order to ease understanding of the program (see e.g. <ref> [Hoa83, Wir83] </ref>). Thus, a program that defines a problem-adequate solution to the backprop learning problem must explicitly map the above concepts onto program entities and should provide appropriate abstractions that allow to use these concepts in a problem-oriented way.
Reference: [KR77] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <year> 1977. </year>
Reference-contexts: to informally describe the semantics of language constructs on different levels of detail, preciseness, and "intuitiveness"; these techniques are not orthogonal: 1. natural language description 2. example application 3. case discrimination 4. equivalent CuPit program fragments 5. reference to well-known other programming languages, especially Modula-2 [Wir85], Ada [Uni81], and C <ref> [KR77] </ref> Given these techniques of description, it is impossible to guarantee that the language definition is precise enough and complete enough to be unambiguous for practical purposes. If you find any aspects of the language that are not made sufficiently clear in this report, please contact the author.
Reference: [MP43] <author> Warren McCulloch and Walter Pitts. </author> <title> A logical calculus of ideas immanent in nervous activity. </title> <journal> Bulletin of Mathematical Biophysics, </journal> <volume> 5 </volume> <pages> 115-133, </pages> <year> 1943. </year> <note> Reprinted in [AR88]. </note>
Reference-contexts: These special categories of data types also motivate the name of the language: CuPit is named after Warren McCulloch and Walter Pitts, who published the first description of a formal neuron in 1943 <ref> [MP43] </ref>. 1 Or at least: that explains most constructs and is not broken by the others 4.3 Program structure and parallelism 9 4.3 Program structure and parallelism The overall structure of a CuPit program is as follows: The main program consists of a procedure that is executed sequentially.
Reference: [RB93] <author> Martin Riedmiller and Heinrich Braun. </author> <title> A direct adaptive method for faster backpropagation learning: The RPROP algorithm. </title> <booktitle> In Proceedings of the IEEE International Conference on Neural Networks, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: The original reference to backpropagation is probably [Wer74], the most often-cited one is chapter 8 of [RM86], which also contains a quite nice mathematical derivation of the algorithm. We will extend the original algorithm by the RPROP rule for the computation of learning step sizes at each weight <ref> [RB93] </ref> and by a simple connection elimination scheme. Backprop is a so-called supervised learning algorithm. This means that it learns from examples. Each example consists of n input values and m output values, all in the range 1 : : : 1. <p> During these discussions, we step by step derive a complete CuPit program for the backpropagation task. In fact, we do not derive a program for "vanilla" backpropagation, but for the RPROP Backpropagation variant <ref> [RB93] </ref>.
Reference: [RM86] <editor> David Rumelhart and John McClelland, editors. </editor> <booktitle> Parallel Distributed Processing: Explorations in the Microstructure of Cognition, </booktitle> <volume> volume Volume 1. </volume> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: The original reference to backpropagation is probably [Wer74], the most often-cited one is chapter 8 of <ref> [RM86] </ref>, which also contains a quite nice mathematical derivation of the algorithm. We will extend the original algorithm by the RPROP rule for the computation of learning step sizes at each weight [RB93] and by a simple connection elimination scheme. Backprop is a so-called supervised learning algorithm.
Reference: [Uni81] <author> United States Department of Defense, </author> <booktitle> Springer Lecture Notes in Computer Science 106. The Programming Language Ada, </booktitle> <year> 1981. </year>
Reference-contexts: A program that contains this kind of error is called erroneous. The behavior of an erroneous program is completely undefined. This definition of error categories is similar to that used in Ada <ref> [Uni81] </ref>. 5 About this report This report does not contain any kind of complete formal description of the CuPit semantics. <p> used in order to informally describe the semantics of language constructs on different levels of detail, preciseness, and "intuitiveness"; these techniques are not orthogonal: 1. natural language description 2. example application 3. case discrimination 4. equivalent CuPit program fragments 5. reference to well-known other programming languages, especially Modula-2 [Wir85], Ada <ref> [Uni81] </ref>, and C [KR77] Given these techniques of description, it is impossible to guarantee that the language definition is precise enough and complete enough to be unambiguous for practical purposes.
Reference: [Wer74] <author> Paul Werbos. </author> <title> Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1974. </year>
Reference-contexts: The original reference to backpropagation is probably <ref> [Wer74] </ref>, the most often-cited one is chapter 8 of [RM86], which also contains a quite nice mathematical derivation of the algorithm. We will extend the original algorithm by the RPROP rule for the computation of learning step sizes at each weight [RB93] and by a simple connection elimination scheme.
Reference: [Wil92] <author> Ross N. Williams. </author> <note> FunnelWeb User's Manual, version 1.0 for funnelweb 3.0 edition, </note> <month> May </month> <year> 1992. </year>
Reference-contexts: In order to fulfill purpose (c), the report contains a complete syntax specification of CuPit in the notation of the Eli [GHL + 92] compiler construction system. This specification is typeset with FunnelWeb <ref> [Wil92] </ref> and can automatically be extracted and used to generate the front-end of the CuPit compiler. 1 Purpose and scope of the language Before anything else, it is necessary to describe what the scope of CuPit is.
Reference: [Wir83] <author> Niklaus Wirth. </author> <title> On the design of programming languages. </title> <editor> In Ellis Horowitz, editor, </editor> <booktitle> Programming Languages: A Grand Tour, </booktitle> <pages> pages 23-30. </pages> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: To guide this requirements definition process we use the concept taxonomy, which is shown in figure 2, plus the following general idea: A programming language should allow to model a problem and its solution in natural terms in order to ease understanding of the program (see e.g. <ref> [Hoa83, Wir83] </ref>). Thus, a program that defines a problem-adequate solution to the backprop learning problem must explicitly map the above concepts onto program entities and should provide appropriate abstractions that allow to use these concepts in a problem-oriented way.

References-found: 12

