URL: file://ftp.cs.wisc.edu/coral/doc/coral.impl.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Email: fraghu,divesh,praveeng@cs.wisc.edu and sudar-sha@research.att.com.  
Title: Implementation of the CORAL Deductive Database System  
Author: Raghu Ramakrishnan Divesh Srivastava S. Sudarshan Praveen Seshadri 
Note: This research was supported by a David and Lucile Packard Foundation Fellowship in Science and engineering, a Presidential Young Investigator Award, with matching grants from Digital Equipment Corporation, Tandem and Xerox, and NSF grant IRI-9011563. The addresses of the authors are  The authors email addresses are  The work of this author was performed largely while he was at the University of Wisconsin, Madison, and was partially supported by the grants listed above.  
Address: Wisconsin, Madison  Wisconsin, Madison  Murray Hill.  Wisconsin, Madison  Wisconsin, Madison, WI 53706,  600 Mountain Avenue, Murray Hill, NJ 07974, USA.  
Affiliation: University of  University of  AT&T Bell Labs,  University of  Computer Sciences Department, University of  USA, and AT&T Bell Laboratories,  
Abstract: CORAL is a deductive database system that supports a rich declarative language, provides a wide range of evaluation methods, and allows a combination of declarative and imperative programming. The data can be persistent on disk or can reside in main-memory. We describe the architecture and implementation of CORAL. There were two important goals in the design of the CORAL architecture: (1) to integrate the different evaluation strategies in a reasonable fashion, and (2) to allow users to influence the optimization techniques used so as to exploit the full power of the CORAL implementation. A CORAL declarative program can be organized as a collection of interacting modules and this modular structure is the key to satisfying both these goals. The high level module interface allows modules with different evaluation techniques to interact in a transparent fashion. Further, users can optionally tailor the execution of a program by selecting from among a wide range of control choices at the level of each module. CORAL also has an interface with C++, and users can program in a combination of declarative CORAL, and C++ extended with CORAL primitives. A high degree of extensibility is provided by allowing C++ programmers to use the class structure of C++ to enhance the CORAL implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: CORAL relations support the ability to get marks into a relation, and distinguish between facts inserted after a mark was obtained and facts inserted before the mark was obtained. This feature is important for the implementation of all variants of semi-naive evaluation <ref> [1, 20] </ref>. The implementation of this extension involves creating subsidiary relations, one corresponding to each interval between marks, and transparently providing the union of the subsidiary relations corresponding to the desired range of marks. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj <ref> [1; 2; 3] </ref>]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj <ref> [1; 2; 3] </ref>]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; [4]; <ref> [5; 1; 2; 3; 4] </ref>) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> The variants of materialization are all bottom-up fixpoint evaluation methods. Bottom-up evaluation iterates over a set of rules, repeatedly evaluating them until a fixpoint is reached. In order to perform incremental evaluation of rules across multiple iterations, CORAL uses the semi-naive evaluation technique <ref> [1, 20] </ref>.
Reference: [2] <author> M. Carey, D. DeWitt, G. Graefe, D. Haight, J. Richardson, D. Schuh, E. Shekita, and S. Vandenberg. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <booktitle> In Readings in Object-Oriented Databases. </booktitle> <address> Morgan-Kaufman, </address> <year> 1990. </year>
Reference-contexts: CORAL combines features of a database query language, such as efficient treatment of large relations, aggregate operations and declarative semantics, with those of a logic programming language, such as more powerful inference capabilities and support for structured data. Support for persistent relations is provided using the EXODUS storage manager <ref> [2] </ref>. A unique feature of CORAL is that it provides a wide range of query evaluation strategies (top-down evaluation and several variants of bottom-up evaluation) and allows users to optionally tailor execution of a program through high-level annotations. <p> Finally, we provide a retrospective discussion of the CORAL design and outline future research directions in Section 9. 2 CORAL System Architecture The architecture of the CORAL deductive system is shown in Figure 1. Persistent data is stored either in text files, or using the EXODUS storage manager <ref> [2] </ref>, which has a client-server architecture. Each CORAL single-user process is a client that can access the common persistent data from the EXODUS server. Multiple CORAL processes could interact by accessing persistent data stored using the EXODUS storage manager. <p> the term f (X; 10; Y ), where X is bound to 25 and Y is bound to Z, and Z is bound to 50 in a separate bindenv. 3.2 Representation of Relations CORAL currently supports in-memory hash-relations, as well as persistent relations (the latter using the EXODUS storage manager <ref> [2] </ref>). Multiple indices can be created on relations, and can be added to existing relations. The relation Page 3 interface is designed to make the addition of new relation implementations relatively easy. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches <ref> [Xj [1; 2; 3] </ref>]. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj <ref> [1; 2; 3] </ref>]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj <ref> [1; 2; 3] </ref>]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; [4]; <ref> [5; 1; 2; 3; 4] </ref>) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others.
Reference: [3] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: The annotations in the declarative programs provide execution hints and directives. The query evaluation system interprets the internal form of the optimized program. We also developed a compiled version of CORAL, that generated a C++ program from each user program. (This is the approach taken by LDL <ref> [13, 3] </ref>.) We found that this approach took a much longer time to compile programs (compilation in LDL is also quite slow). <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches <ref> [Xj [1; 2; 3] </ref>]. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj <ref> [1; 2; 3] </ref>]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj <ref> [1; 2; 3] </ref>]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; [4]; <ref> [5; 1; 2; 3; 4] </ref>) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> With respect to semi-naive evaluation, the optimizer is responsible for: (1) join order selection, (2) index selection, (3) deciding whether to refine the basic nested-loops join with intelligent backtracking (see, for instance, <ref> [13, 3] </ref>). These aspects are discussed in detail in the full version of the paper. The optimizer also decides on the subsumption checks to be carried out on each relation. The default is to do sub-sumption checks on all relations. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL <ref> [13, 3] </ref>, Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1.
Reference: [4] <author> B. Freitag, H. Sch-utz, and G. Specht. </author> <title> LOLA a logic language for deductive databases and its implementation. </title> <booktitle> In Proceedings of 2nd International Symposium on Database Systems for Advanced Applications (DASFAA), </booktitle> <year> 1991. </year>
Reference-contexts: Applications in which large amounts of data must be extensively analyzed are likely to benefit from this combination of features. In comparison to other deductive database systems such as Aditi [28], EKS-V1 [29], LDL [27], LOLA <ref> [4] </ref> and Nail-Glue [11], CORAL provides a more powerful language and supports a much wider range of optimization techniques. We highlight several design decisions that allowed us to integrate diverse evaluation techniques and optimizations in a nearly seamless fashion. Specifically, we consider the following issues: 1. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; <ref> [4] </ref>; [5; 1; 2; 3; 4]) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; [4]; <ref> [5; 1; 2; 3; 4] </ref>) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL [13, 3], Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA <ref> [4] </ref>. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1. CORAL supports a larger class of programs, including programs with non-ground facts, non-stratified nega tion and set-generation. 2.
Reference: [5] <author> E. Goto. </author> <title> Monocopy and associative algorithms in an extended lisp. </title> <type> Technical Report 74-03, </type> <institution> Information Science Laboratory, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> May </month> <year> 1974. </year>
Reference-contexts: Such indices are of great use when dealing with complex objects created using functors. One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; [4]; <ref> [5; 1; 2; 3; 4] </ref>) would match this pattern (see [24]). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others.
Reference: [6] <author> M. Jeusfeld and M. Staudt. </author> <title> Query optimization in deductive object bases. </title> <editor> In G. J.C. Freytag, G. Vossen and D. Maier, editors, </editor> <title> Query Processing for Advanced Database Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL [13, 3], Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE [9], ConceptBase <ref> [6] </ref> and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1. CORAL supports a larger class of programs, including programs with non-ground facts, non-stratified nega tion and set-generation. 2.
Reference: [7] <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left , and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 380-391, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Page 4 Templates [16], Supplementary Magic With GoalId Index--ing [24], and Context Factoring <ref> [14, 7] </ref>. By default, CORAL also applies Existential Query Rewriting [17], which seeks to propagate projections. 4.2 Decisions On Run-time Alternatives In addition to choosing rewriting techniques for materialized evaluation, the optimizer makes a number of decisions that affect execution.
Reference: [8] <author> G. Kiernan, C. de Maindreville, and E. Simon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Unlike Glue-NAIL! and LDL, where modules have only a compile-time meaning and no run-time meaning, modules in CORAL have important run-time semantics, in that several run-time optimizations are done at the module level. Modules with run-time semantics are also found in several production rule systems (for example, RDL1 <ref> [8] </ref>). LDL++, a successor to LDL under development at MCC Austin, is reportedly also moving in the direction taken by CORAL in many respects. It will be partially interpreted, support abstract data types, and use a local semantics for choice (Carlo Zaniolo, personal communication).
Reference: [9] <author> W. Kieling and H. Schmidt. DECLARE and SDS: </author> <title> Early efforts to commercialize deductive database technology. </title> <note> Submitted to the VLDB Journal., </note> <year> 1993. </year>
Reference-contexts: The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL [13, 3], Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE <ref> [9] </ref>, ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1. CORAL supports a larger class of programs, including programs with non-ground facts, non-stratified nega tion and set-generation. 2.
Reference: [10] <author> A. Lefebvre. </author> <title> Towards an efficient evaluation of recursive aggregates in deductive databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: CORAL is extensible | new data and relation types and index implementations can be added without mod ifying the rest of the system. EKS-V1 supports integrity constraint checking, hypothetical reasoning and provides some support for non-stratified aggregation <ref> [10] </ref>. ConceptBase supports DATALOG, along with locally stratified negation (but no set-generation), several object-oriented features, integrity constraint checking, and provides a one-way interface to C/Prolog, i.e. the imperative language can call ConceptBase, but not vice versa.
Reference: [11] <author> K. Morris, J. D. Ullman, and A. Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: Applications in which large amounts of data must be extensively analyzed are likely to benefit from this combination of features. In comparison to other deductive database systems such as Aditi [28], EKS-V1 [29], LDL [27], LOLA [4] and Nail-Glue <ref> [11] </ref>, CORAL provides a more powerful language and supports a much wider range of optimization techniques. We highlight several design decisions that allowed us to integrate diverse evaluation techniques and optimizations in a nearly seamless fashion. Specifically, we consider the following issues: 1. Data representation (e.g. constants, lists, sets). 2. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL [13, 3], Glue-NAIL! <ref> [11, 15] </ref>, Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1. CORAL supports a larger class of programs, including programs with non-ground facts, non-stratified nega tion and set-generation. 2.
Reference: [12] <author> I. S. Mumick, H. Pirahesh, and R. Ramakrishnan. </author> <title> Duplicates and aggregates in deductive databases. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: ask that a relation be treated as a multiset, with as many copies of a tuple as there are derivations for it in the original program. 3 This semantics is supported by carrying out duplicate checks only on the `magic' predicates; some version of Magic Templates must be used (see <ref> [12] </ref>). 5 Module Evaluation Strategies The evaluation of a declarative CORAL program is divided into a number of distinct sub-computations by expressing the program as a collection of modules. Each module is a unit of compilation and its evaluation strategies are independent of the rest of the program. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL [13, 3], Glue-NAIL! [11, 15], Starburst SQL <ref> [12] </ref>, DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1. CORAL supports a larger class of programs, including programs with non-ground facts, non-stratified nega tion and set-generation. 2.
Reference: [13] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: The annotations in the declarative programs provide execution hints and directives. The query evaluation system interprets the internal form of the optimized program. We also developed a compiled version of CORAL, that generated a C++ program from each user program. (This is the approach taken by LDL <ref> [13, 3] </ref>.) We found that this approach took a much longer time to compile programs (compilation in LDL is also quite slow). <p> With respect to semi-naive evaluation, the optimizer is responsible for: (1) join order selection, (2) index selection, (3) deciding whether to refine the basic nested-loops join with intelligent backtracking (see, for instance, <ref> [13, 3] </ref>). These aspects are discussed in detail in the full version of the paper. The optimizer also decides on the subsumption checks to be carried out on each relation. The default is to do sub-sumption checks on all relations. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL <ref> [13, 3] </ref>, Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1.
Reference: [14] <author> J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J. D. Ull-man. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Page 4 Templates [16], Supplementary Magic With GoalId Index--ing [24], and Context Factoring <ref> [14, 7] </ref>. By default, CORAL also applies Existential Query Rewriting [17], which seeks to propagate projections. 4.2 Decisions On Run-time Alternatives In addition to choosing rewriting techniques for materialized evaluation, the optimizer makes a number of decisions that affect execution.
Reference: [15] <author> G. Phipps, M. A. Derr, and K. A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIG-MOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference-contexts: The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 [29], LDL [13, 3], Glue-NAIL! <ref> [11, 15] </ref>, Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1. CORAL supports a larger class of programs, including programs with non-ground facts, non-stratified nega tion and set-generation. 2.
Reference: [16] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The desired selection pattern is specified using a query form, where a `bound' argument indicates that any binding in that argument position of the query is to be propagated. The default rewriting technique is Supplementary Magic Templates <ref> [16] </ref>. The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Page 4 Templates [16], Supplementary Magic With GoalId Index--ing [24], <p> rewriting technique is Supplementary Magic Templates <ref> [16] </ref>. The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Page 4 Templates [16], Supplementary Magic With GoalId Index--ing [24], and Context Factoring [14, 7]. By default, CORAL also applies Existential Query Rewriting [17], which seeks to propagate projections. 4.2 Decisions On Run-time Alternatives In addition to choosing rewriting techniques for materialized evaluation, the optimizer makes a number of decisions that affect execution.
Reference: [17] <author> R. Ramakrishnan, C. Beeri, and R. Krishnamurthy. </author> <title> Optimizing existential Datalog queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 89-102, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Page 4 Templates [16], Supplementary Magic With GoalId Index--ing [24], and Context Factoring [14, 7]. By default, CORAL also applies Existential Query Rewriting <ref> [17] </ref>, which seeks to propagate projections. 4.2 Decisions On Run-time Alternatives In addition to choosing rewriting techniques for materialized evaluation, the optimizer makes a number of decisions that affect execution. The optimizer analyzes the (rewritten) program, and identifies some evaluation and optimization choices that appear appropriate.
Reference: [18] <author> R. Ramakrishnan, P. Bothner, D. Srivastava, and S. Su-darshan. </author> <title> CORAL: A database programming language. </title> <editor> In J. Chomicki, editor, </editor> <booktitle> Proceedings of the NACLP `90 Workshop on Deductive Databases, </booktitle> <month> October </month> <year> 1990. </year> <note> Available as Report TR-CS-90-14, </note> <institution> Department of Computing and Information Sciences, Kansas State University. </institution>
Reference-contexts: As shown here, CORAL's aggregate selection mechanism can also be used to provide a version of the choice operator of LDL, but with altogether different semantics <ref> [18] </ref>. 5.6 Inter-Module Calls The interaction between modules merits some discussion. Suppose that p is a predicate defined in module M1, and p appears in the body of a rule of module M2.
Reference: [19] <author> R. Ramakrishnan, P. Seshadri, D. Srivastava, and S. Sudar-shan. </author> <title> The CORAL user manual: A tutorial introduction to CORAL. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: A summary of the virtual functions that constitute the abstract data type interface is presented in <ref> [19] </ref>. In addition to creating the abstract data type, the user can define predicates to manipulate (and possibly display in novel ways) objects belonging to the abstract data types.
Reference: [20] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <journal> IEEE Transactions on Knowledge and Data Engineering (to appear). </journal> <note> A shorter version appeared in VLDB, </note> <year> 1990. </year>
Reference-contexts: CORAL relations support the ability to get marks into a relation, and distinguish between facts inserted after a mark was obtained and facts inserted before the mark was obtained. This feature is important for the implementation of all variants of semi-naive evaluation <ref> [1, 20] </ref>. The implementation of this extension involves creating subsidiary relations, one corresponding to each interval between marks, and transparently providing the union of the subsidiary relations corresponding to the desired range of marks. <p> Pipelining guarantees a particular evaluation strategy, and order of execution. While the program is no longer truly `declarative', programmers can exploit this guarantee and use imperatively defined predicates that have side-effects. 5.2 Materialization Several variants of materialized evaluation are supported in CORAL: Basic Semi-Naive, Predicate Semi-Naive <ref> [20] </ref>, Ordered Search [21], and the non-ground fact optimizations described in [26]. The variants of materialization are all bottom-up fixpoint evaluation methods. Bottom-up evaluation iterates over a set of rules, repeatedly evaluating them until a fixpoint is reached. <p> The variants of materialization are all bottom-up fixpoint evaluation methods. Bottom-up evaluation iterates over a set of rules, repeatedly evaluating them until a fixpoint is reached. In order to perform incremental evaluation of rules across multiple iterations, CORAL uses the semi-naive evaluation technique <ref> [1, 20] </ref>.
Reference: [21] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Pipelining guarantees a particular evaluation strategy, and order of execution. While the program is no longer truly `declarative', programmers can exploit this guarantee and use imperatively defined predicates that have side-effects. 5.2 Materialization Several variants of materialized evaluation are supported in CORAL: Basic Semi-Naive, Predicate Semi-Naive [20], Ordered Search <ref> [21] </ref>, and the non-ground fact optimizations described in [26]. The variants of materialization are all bottom-up fixpoint evaluation methods. Bottom-up evaluation iterates over a set of rules, repeatedly evaluating them until a fixpoint is reached. <p> Full details of Ordered Search are not presented here, but the reader is referred to <ref> [21] </ref>. The principle of Ordered Search is that the computation is ordered by `hiding' subgoals. This is achieved by maintaining a `context' that stores subgoals in an ordered fashion, and that decides at each stage in the evaluation, which subgoal to make available for use next.
Reference: [22] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: The interface between modules is kept at a high level; evaluation techniques can be chosen on a per-module basis through (optional) annotations, and modules with different evaluation techniques can interact in a nearly transparent fashion. An overview of the CORAL declarative language is presented in <ref> [22] </ref>. The query language supports general Horn clauses with complex terms, set-grouping, aggregate operations, negation and data that contains universally quantified variables. The details of the language are outside the scope of this paper. <p> Since annotations can be expressed at a high level, they give the programmer the power to control optimization and evaluation in a relatively abstract manner. A detailed description of the annotations provided by CORAL is found in <ref> [22] </ref>; we mention some of them when discussing the query evaluation techniques. The CORAL programmer decides (on a per-module basis) whether to use one of two basic evaluation approaches, namely pipelining or materialization, which are discussed in Section 5.
Reference: [23] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Efficient bottom-up evaluation of logic programs. </title> <editor> In J. Vandewalle, editor, </editor> <booktitle> The State of the Art in Computer Systems and Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: We discuss these two major tasks of the optimizer below. 4.1 Rewriting Techniques Materialized evaluation in CORAL is essentially a fixpoint evaluation using bottom-up iteration on the program rules (see, for instance, <ref> [23] </ref>). If this is done on the original program, selections in a query are not utilized. Several program transformations have been proposed to `propagate' such selections, and many of these are implemented in CORAL.
Reference: [24] <author> R. Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: One can retrieve, for example, those tuples in relation append that have as the first argument a list that matches [Xj [1; 2; 3]]. A tuple ([5j [1; 2; 3]]; [4]; [5; 1; 2; 3; 4]) would match this pattern (see <ref> [24] </ref>). 4 Overview of Query Evaluation A number of query evaluation strategies have been developed for deductive databases, and each technique is particularly efficient for some classes of programs, but may perform relatively poorly on others. <p> The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Page 4 Templates [16], Supplementary Magic With GoalId Index--ing <ref> [24] </ref>, and Context Factoring [14, 7]. By default, CORAL also applies Existential Query Rewriting [17], which seeks to propagate projections. 4.2 Decisions On Run-time Alternatives In addition to choosing rewriting techniques for materialized evaluation, the optimizer makes a number of decisions that affect execution.
Reference: [25] <author> D. Srivastava, R. Ramakrishnan, P. Seshadri, and S. Su-darshan. </author> <title> CORAL++: Adding object-orientation to a logic database language. </title> <note> Submitted. </note>
Reference-contexts: Typing is a desirable feature, especially if the language is to be used to develop large applications. Type information can be used when compiling declarative programs, and can improve execution speed greatly. Typing is one of the issues addressed by a proposed extension to CORAL <ref> [25] </ref>. Memory Management : In an effort to make the system as efficient as possible for main-memory operations, copying of data has largely been replaced by sharing using pointers.
Reference: [26] <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Optimizations of bottom-up evaluation with non-ground terms. </title> <booktitle> In JICSLP'92 Post-Conference Workshop on Deductive Databases, </booktitle> <year> 1992. </year>
Reference-contexts: The semantics of such non-ground facts is that all variables are universally quantified in the fact. Although the basic representation of variables is fairly simple, the representation is complicated by requirements of efficiency when using non-ground facts in rules (see <ref> [26] </ref>). Suppose we want to make an inference using a rule. Variables in the rule may get bound in the course of an inference. A naive scheme would replace every reference to the variable by its binding. <p> While the program is no longer truly `declarative', programmers can exploit this guarantee and use imperatively defined predicates that have side-effects. 5.2 Materialization Several variants of materialized evaluation are supported in CORAL: Basic Semi-Naive, Predicate Semi-Naive [20], Ordered Search [21], and the non-ground fact optimizations described in <ref> [26] </ref>. The variants of materialization are all bottom-up fixpoint evaluation methods. Bottom-up evaluation iterates over a set of rules, repeatedly evaluating them until a fixpoint is reached. In order to perform incremental evaluation of rules across multiple iterations, CORAL uses the semi-naive evaluation technique [1, 20].
Reference: [27] <author> S. Tsur and C. Zaniolo. </author> <title> LDL: A logic-based data-language. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Data Bases, </booktitle> <pages> pages 33-41, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: Applications in which large amounts of data must be extensively analyzed are likely to benefit from this combination of features. In comparison to other deductive database systems such as Aditi [28], EKS-V1 [29], LDL <ref> [27] </ref>, LOLA [4] and Nail-Glue [11], CORAL provides a more powerful language and supports a much wider range of optimization techniques. We highlight several design decisions that allowed us to integrate diverse evaluation techniques and optimizations in a nearly seamless fashion. Specifically, we consider the following issues: 1.
Reference: [28] <author> J. Vaghani, K. Ramamohanarao, D. Kemp, Z. Somogyi, and P. Stuckey. </author> <title> The Aditi deductive database system. </title> <booktitle> In Proceedings of the NACLP'90 Workshop on Deductive Database Systems, </booktitle> <year> 1990. </year>
Reference-contexts: Applications in which large amounts of data must be extensively analyzed are likely to benefit from this combination of features. In comparison to other deductive database systems such as Aditi <ref> [28] </ref>, EKS-V1 [29], LDL [27], LOLA [4] and Nail-Glue [11], CORAL provides a more powerful language and supports a much wider range of optimization techniques. We highlight several design decisions that allowed us to integrate diverse evaluation techniques and optimizations in a nearly seamless fashion. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi <ref> [28] </ref>, EKS-V1 [29], LDL [13, 3], Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1.
Reference: [29] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <year> 1990. </year> <pages> Page 10 </pages>
Reference-contexts: Applications in which large amounts of data must be extensively analyzed are likely to benefit from this combination of features. In comparison to other deductive database systems such as Aditi [28], EKS-V1 <ref> [29] </ref>, LDL [27], LOLA [4] and Nail-Glue [11], CORAL provides a more powerful language and supports a much wider range of optimization techniques. We highlight several design decisions that allowed us to integrate diverse evaluation techniques and optimizations in a nearly seamless fashion. Specifically, we consider the following issues: 1. <p> The implementation of persistent relations using EXODUS illustrates the utility of such extensibility. 8 Related Systems There are many similarities between CORAL and deductive database systems such as Aditi [28], EKS-V1 <ref> [29] </ref>, LDL [13, 3], Glue-NAIL! [11, 15], Starburst SQL [12], DECLARE [9], ConceptBase [6] and LOLA [4]. However, there are several important differences, and CORAL extends all the above systems in the following ways: 1.
References-found: 29

