URL: http://www.cs.mu.oz.au/tr_db/mu_96_19.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Differential Methods in Logic Program Analysis  
Author: Mara Garca de la Banda, Kim Marriott, Peter Stuckey and Harald Stndergaard 
Address: Parkville Vic. 3052 Australia  
Affiliation: Dept. of Computer Science The University of Melbourne  
Pubnum: Technical Report 96/19  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Bruynooghe, M., </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs, </title> <journal> Journal of Logic Programming 10 (2): </journal> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: These formal frameworks are very similar, and can be instantiated to a particular analysis by giving several parametric functions over the description domain. We refer to these frameworks jointly as the goal-dependent traditional approach. The traditional goal-dependent frameworks <ref> [1, 13, 16] </ref> share the same "abstract execution" mechanism. The output of the analysis is a program annotated with the information obtained at each program point. Processing mimics normal execution of programs to a certain extent. The basic idea is to process a call to a predicate as follows. <p> We shall refer to such "best" operations as the induced operations. In the next two sections we will revise the two main approaches to abstract interpretation based analysis of (constraint) logic programs: goal-dependent analysis and goal-independent based analysis. 3 Goal-Dependent Analysis The top-down goal-dependent approach <ref> [1, 13, 16] </ref> is probably the most common approach to the analysis of (constraint) logic programs. In this section we will define a number of semantics that use this approach in terms of a general goal-dependent semantics.
Reference: [2] <author> Bueno, F., Garca de la Banda, M., and Hermenegildo, M., </author> <title> Effectiveness of Global Analysis in Strict Independence-Based Automatic Parallelization, </title> <editor> in: M. Bruynooghe (ed.), </editor> <booktitle> Logic Programming: Proc. 1994 Int. Symp., </booktitle> <pages> pp. 320-336, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog (see for example [21, 22]) and significantly improve automatic parallelisation (see for example <ref> [2] </ref>). Recently, Kelly et al. [14] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs has resulted in several generic "frameworks" for logic programming. <p> We will take advantage of this fact for improving readability: the results for the rest of analysers will only appear 3 A complete description of these benchmarks can be found, for example, in <ref> [2] </ref>. 4 SICStus 2.1, compactcode, SPARCstation 10, one processor. 24 Program spec std sdiff sfuse gi cod gigd ratio aiakl 0.29 1.08 1.64 1.77 1.57 1.51 2.32 0.84 ann 10.14 2.05 1.92 2.64 1.04 0.83 2.48 0.32 boyer 6.69 1.68 2.20 2.57 0.85 0.66 2.04 0.15 browse 0.30 1.29 1.29 1.45
Reference: [3] <author> Codish, M., Garca de la Banda, M., Bruynooghe, M., and Hermenegildo, M., </author> <title> Goal Dependent versus Goal Independent Analysis of Logic Programs, </title> <editor> in: F. Pfenning (ed.), </editor> <booktitle> Proc. Fifth Int. Conf. Logic Programming and Automated Reasoning (Lecture Notes in Artificial Intelligence 822), </booktitle> <pages> pp. 305-320, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Some empirical evaluations have been conducted to test the relative efficiency and accuracy of different domains, see for example Codish et al. <ref> [3] </ref>. We show, however, that in general the two approaches are incomparable with respect to accuracy, and in a certain sense, the traditional goal-dependent framework is inherently less precise than the two-phase goal-independent based approach. <p> For this reason, when Jacobs and Langen [11] proposed this method (referred to as condensation) they focused on defining the characteristics that the abstract domain functions should satisfy in order not to lose accuracy. Codish et al. <ref> [3] </ref> conducted empirical testing on a variant of the approach defined above. They determined the relative efficiency of the goal-independent based approach versus the specialised goal-dependent approach on three different domains. <p> The gigd semantics is loosely related to that proposed by Codish et al. <ref> [3] </ref>. Codish et al. noticed that with little additional work, the annotation phase of a goal-independent based analysis could become a simplified form of goal-dependent analysis. For each call, they used either the goal-independent or the goal-dependent information to compute the answer rather than both as in the gigd semantics. <p> have implemented the following goal-independent based semantics: * gi: implements a goal-dependent phase in which the answer to a particular call Call is computed by abstractly conjoining Call and the answer provided by the goal-independent phase. * cod: implements a goal-dependent phase based on the approach of Codish et al. <ref> [3] </ref>, that is, goal-independent information is only used for computing the answers to recursive predicates, the rest being computed using the specialised goal-dependent semantics. * gigd: implements the gigd semantics in which both goal-dependent and goal-independent information are used to find the answers to each (recursive or non-recursive) call.
Reference: [4] <author> Cousot, P. and Cousot, R., </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints, </title> <booktitle> in: Proc. Fourth Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 238-252, </pages> <publisher> ACM Press, </publisher> <year> 1977. </year>
Reference-contexts: Correctness of dataflow analysis is usually formalised in terms of abstract interpretation <ref> [4] </ref>. In this context, the concrete domain E (sets of term equations in the above example) and the description domain D (sets of variables in the example) are usually required to be complete lattices related by a pair of adjoined functions.
Reference: [5] <author> Cousot, P. and Cousot, R,. </author> <title> Systematic Design of Program Analysis Frameworks, </title> <booktitle> in: Proc. Sixth Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 269-282, </pages> <publisher> ACM Press, </publisher> <year> 1979. </year>
Reference-contexts: In effect, this definition executes both the simple differential and the specialised approaches, yielding their greatest lower bound. It is therefore guaranteed to be as accurate as both of the approaches. It may be considered as an example of a product domain <ref> [5] </ref>. Again, in an abuse of notation, when comparing a fused semantics with some other semantics we will consider the annotations of the fused semantics to be only the last component of the tuple.
Reference: [6] <author> Dumortier, V., </author> <title> Freeness and Related Analyses of Constraint Logic Programs Using Abstract Interpretation, </title> <type> PhD Thesis, </type> <institution> Catholic University of Leuven, Belgium, </institution> <year> 1994. </year>
Reference-contexts: Using this approach, analysis of the above example will give the more precise information that A and B definitely do not share. This idea is also used by Dumortier <ref> [6, 7] </ref>. Our aim is to formalise and develop this and allied approaches as general methods. Let us call the Mulkers approach the simple differential approach. We show that the simple differential approach is equivalent to the goal-independent analysis in terms of annotated information.
Reference: [7] <author> Dumortier, V., Janssens, G., Bruynooghe, M., and Codish, M., </author> <title> Freeness Analysis in the Presence of Numerical Constraints, </title> <editor> in: D. S. Warren (ed.), </editor> <booktitle> Logic Programming: Proc. Tenth Int. Conf., </booktitle> <pages> pp. 100-115, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Using this approach, analysis of the above example will give the more precise information that A and B definitely do not share. This idea is also used by Dumortier <ref> [6, 7] </ref>. Our aim is to formalise and develop this and allied approaches as general methods. Let us call the Mulkers approach the simple differential approach. We show that the simple differential approach is equivalent to the goal-independent analysis in terms of annotated information.
Reference: [8] <author> Falaschi, M., Levi, G., Martelli, M., and Palamidessi, C., </author> <title> A new declarative semantics for logic languages. </title> <editor> in: R. Kowalski and K. Bowen (eds.), </editor> <booktitle> Logic Programming: Proc. Fifth Int. Conf. Symp., </booktitle> <pages> pp. 993-1005, </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The first point to note is that the concrete goal-independent based semantics is as accurate as the collecting semantics. This is because the first phase of the semantics is exactly the S-semantics <ref> [8] </ref> which has been shown to be equivalent to the operational semantics. Theorem 4.1 For all programs P and goals G: concgi (P; G) = coll (P; G). In contrast, the concrete goal-dependent and specialised semantics are inherently imprecise.
Reference: [9] <author> Garca de la Banda, M., Hermenegildo, M., and Marriott, K., </author> <title> Independence in Constraint Logic Programs, </title> <editor> in: D. Miller (ed.), </editor> <booktitle> Logic Programming: Proc. 1993 Int. Symp., </booktitle> <pages> pp. 130-146, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In this model, two goals g 1 and g 2 can be executed in parallel, for constraint store c if every partial answer of hc; g 1 i is consistent with those of hc; g 2 i <ref> [9] </ref>. At the abstract level, let D 1 and D 2 describe the partial answers of hc; g 1 i and hc; g 2 i, respectively. Then, the condition stated above is satisfied if the abstract conjunction of D 1 and D 2 is definitely satisfiable.
Reference: [10] <author> Garca de la Banda, M., Marriott, K., and Stuckey, P., </author> <title> Efficient Analysis of Logic Programs with Dynamic Scheduling, </title> <editor> in: J. Lloyd (ed.), </editor> <booktitle> Logic Programming: Proc. 1995 Int. Symp., </booktitle> <pages> pp. 417-431, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: When we consider analysis of more sophisticated languages, or complex applications of the analysis information, the characteristics of a differential approach can become invaluable. We briefly present two examples. In the analysis of programs with dynamic scheduling <ref> [10] </ref>, the behaviour of the delayed atoms is approximated by a function from descriptions to descriptions. This function provides the connection between the variables currently being analysed and those over which delayed atoms are defined.
Reference: [11] <author> Jacobs, D. and Langen, A., </author> <title> Static Analysis of Logic Programs for Independent And-parallelism, </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 291-31, </pages> <year> 1992. </year> <month> 30 </month>
Reference-contexts: This recomputation can increase the accuracy but also reduce the efficiency of the analysis. For this reason, Jacobs and Langen <ref> [11] </ref> proposed a goal-independent method which avoids the problem. <p> It has long been part of the program analysis folklore that goal-independent analyses are more efficient but less accurate than goal-dependent analyses. So when Jacobs and Langen <ref> [11] </ref> proposed their method, they focussed on defining the characteristics that the abstract domain operations should satisfy in order not to lose accuracy. Some empirical evaluations have been conducted to test the relative efficiency and accuracy of different domains, see for example Codish et al. [3]. <p> Goal-independent based analysis avoids this problem by noticing that in the operational semantics, if E is the set of answers to the goal G, then the set of answers to e ^ G is just add (e; E) <ref> [11] </ref>. <p> For this reason, when Jacobs and Langen <ref> [11] </ref> proposed this method (referred to as condensation) they focused on defining the characteristics that the abstract domain functions should satisfy in order not to lose accuracy. Codish et al. [3] conducted empirical testing on a variant of the approach defined above. <p> Hence, as we shall shortly see, theorems relating the two approaches are easier to prove. Most importantly, because of its similar form to goal-dependent analysis it is easy to extend the differential semantics to create more accurate analysis. This will be examined in the next section. Jacobs and Langen <ref> [11] </ref> give sufficient conditions, based on the characteristics of the abstract operations, which ensure that goal-independent analysis is as accurate as the standard top-down analysis. Since their semantics uses a different set of abstract operations, comparison is difficult.
Reference: [12] <author> Jaffar, J. and Maher, M., </author> <title> Constraint Logic Programming: A Survey, </title> <journal> Journal of Logic Programming 19/20: </journal> <pages> 503-581, </pages> <year> 1994. </year>
Reference-contexts: The operational semantics, op (P; G), gives the set of answers to goal G for program P . The reader is referred to Jaffar and Maher <ref> [12] </ref> for more details. Dataflow analysis is the process of statically (at compile-time) inferring information about the properties of the variables and data structures in a program. The purpose of this process is to provide information which improves the task performed by compilers, program transformation tools, etc.
Reference: [13] <author> Jones, N. and Stndergaard, H., </author> <title> A Semantics-Based Framework for the Abstract Interpretation of Prolog, </title> <editor> in: S. Abramsky and C. Hankin (eds.), </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pp. 123-142, </pages> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: These formal frameworks are very similar, and can be instantiated to a particular analysis by giving several parametric functions over the description domain. We refer to these frameworks jointly as the goal-dependent traditional approach. The traditional goal-dependent frameworks <ref> [1, 13, 16] </ref> share the same "abstract execution" mechanism. The output of the analysis is a program annotated with the information obtained at each program point. Processing mimics normal execution of programs to a certain extent. The basic idea is to process a call to a predicate as follows. <p> We shall refer to such "best" operations as the induced operations. In the next two sections we will revise the two main approaches to abstract interpretation based analysis of (constraint) logic programs: goal-dependent analysis and goal-independent based analysis. 3 Goal-Dependent Analysis The top-down goal-dependent approach <ref> [1, 13, 16] </ref> is probably the most common approach to the analysis of (constraint) logic programs. In this section we will define a number of semantics that use this approach in terms of a general goal-dependent semantics.
Reference: [14] <author> Kelly, A., Macdonald, A., Marriott, K., Stndergaard, H., Stuckey, P., and Yap, R., </author> <title> An Optimizing Compiler for CLP(R), </title> <editor> in: U. Montanari and F. Rossi (eds.), </editor> <booktitle> Principles and Practice of Constraint Programming|CP'95 (Lecture Notes in Computer Science 976), </booktitle> <pages> pp. 222-239, </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog (see for example [21, 22]) and significantly improve automatic parallelisation (see for example [2]). Recently, Kelly et al. <ref> [14] </ref> have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs has resulted in several generic "frameworks" for logic programming. <p> In such an implementation termination is guaranteed, provided the number of constraint descriptions with a particular domain of variables is finite and the calls are treated modulo variable renaming. A number of generic abstract interpretation engines based on essentially the above semantic equations have been built, for example <ref> [19, 15, 14] </ref>. The engines provide sophisticated fixpoint algorithms and data structures. Specific analyses are obtained by defining a description domain D and providing the seven parametric functions over D. The following specialisation of the general semantics captures the usual theoretical viewpoint of goal-dependent analysis. Definition.
Reference: [15] <author> Le Charlier, B. and Van Hentenryck, P., </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog, </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (1): </booktitle> <pages> 35-101, </pages> <year> 1994. </year>
Reference-contexts: In such an implementation termination is guaranteed, provided the number of constraint descriptions with a particular domain of variables is finite and the calls are treated modulo variable renaming. A number of generic abstract interpretation engines based on essentially the above semantic equations have been built, for example <ref> [19, 15, 14] </ref>. The engines provide sophisticated fixpoint algorithms and data structures. Specific analyses are obtained by defining a description domain D and providing the seven parametric functions over D. The following specialisation of the general semantics captures the usual theoretical viewpoint of goal-dependent analysis. Definition. <p> This formalises the approach taken in some of the implementations of common domains such as Sharing (set sharing), ASub (pair sharing), and Def (definiteness dependencies), as for example, those embedded in PLAI [19] and GAIA <ref> [15] </ref>. Definition. The specialised semantics, spec D , is identical to the standard semantics except that the abstract combination comb D is replaced by comb spec D which is required to be safe.
Reference: [16] <author> Marriott, K., Stndergaard, H., and Jones, N., </author> <title> Denotational Abstract Interpretation of Logic Programs, </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (3): </booktitle> <pages> 607-648, </pages> <year> 1994. </year>
Reference-contexts: These formal frameworks are very similar, and can be instantiated to a particular analysis by giving several parametric functions over the description domain. We refer to these frameworks jointly as the goal-dependent traditional approach. The traditional goal-dependent frameworks <ref> [1, 13, 16] </ref> share the same "abstract execution" mechanism. The output of the analysis is a program annotated with the information obtained at each program point. Processing mimics normal execution of programs to a certain extent. The basic idea is to process a call to a predicate as follows. <p> We shall refer to such "best" operations as the induced operations. In the next two sections we will revise the two main approaches to abstract interpretation based analysis of (constraint) logic programs: goal-dependent analysis and goal-independent based analysis. 3 Goal-Dependent Analysis The top-down goal-dependent approach <ref> [1, 13, 16] </ref> is probably the most common approach to the analysis of (constraint) logic programs. In this section we will define a number of semantics that use this approach in terms of a general goal-dependent semantics. <p> D outrestrict D : P (V ars) fi D ! D extend D : P (V ars) fi D ! D In this way, the same set of semantic equations can be used to define a "standard" semantics, as well as a series of non-standard semantics, that is, dataflow analyses <ref> [16] </ref>. The first equation says that, given program P , the meaning of a goal G is the description obtained by treating G as a rule body. The description true D denotes ff D (ftrueg). <p> The standard semantics induced when D is P (Con) is written conc and called the concrete top-down semantics. It follows from standard results in abstract interpretation theory that for any description domain D, std D approximates the collecting semantics <ref> [16] </ref>. Proposition 3.1 If std D is induced from description domain D, then for all programs P and goals G: std D (P; G) / coll (P; G). Example 3.1 Consider the abstract domain SS for structure sharing. Descriptions are sets of pairs of variables. <p> It is straightforward to fix this problem along the lines of <ref> [16] </ref>, but we prefer not to complicate the definition further. 7 non-linear). Note that the pairs are symmetric and that true SS is the empty set. <p> The problem is that the constraints in restrict (vars (A); D) are essentially being added twice, and the conj operation is not idempotent. The following example is from Marriott et al. <ref> [16] </ref>. <p> Therefore, if these conditions are met by the induced abstract operations, the above theorem implies that the differential semantics is also more accurate than the standard semantics. These conditions are quite restrictive. The only useful domain we know of whose induced abstract operations satisfy the conditions is P os <ref> [16] </ref>. Owing to the straightforward link between the goal-dependent and differential semantics, we can provide a different, less restrictive, set of conditions that ensure that the simple differential (and hence the goal-independent) approach is uniformly more accurate than the standard goal-dependent approach.
Reference: [17] <author> Marriott, K. and Stuckey, P., </author> <title> Approximating Interaction between Linear Arithmetic Constraints, </title> <editor> in: M. Bruynooghe (ed.), </editor> <booktitle> Logic Programming: Proc. 1994 Int. Symp., </booktitle> <pages> pp. 571-585, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Note that the information about c is included only once. Example 9.1 Consider the following constraint logic program: g (X; Y; Z) 1 fl X = 3; 2 fl p (X); r (X) p (X) true r (X) true and the LSign domain introduced by Marriott and Stuckey <ref> [17] </ref>. This domain is used to describe conjunctions of linear arithmetic constraints and gives information about possible failure. In LSign a linear arithmetic constraint is abstracted by replacing coefficients in the constraint by their sign.
Reference: [18] <author> Mulkers, A., </author> <title> Live Data Structures in Logic Programs, </title> <booktitle> Lecture Notes in Computer Science 675, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Given that the goal-independent and goal-dependent approaches are incomparable, it is natural to wish to combine the accuracy of the two approaches. That is the goal of this paper. A partial solution for the case of sharing analysis is given by Mulkers with her "twofold sharing domain" <ref> [18] </ref>. In Mulkers's approach dataflow information is kept in two parts|a description of the call and a description of the new constraints which have been added while processing the atom.
Reference: [19] <author> Muthukumar, K. and Hermenegildo, M., </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation, </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 315-347, </pages> <year> 1992. </year>
Reference-contexts: In such an implementation termination is guaranteed, provided the number of constraint descriptions with a particular domain of variables is finite and the calls are treated modulo variable renaming. A number of generic abstract interpretation engines based on essentially the above semantic equations have been built, for example <ref> [19, 15, 14] </ref>. The engines provide sophisticated fixpoint algorithms and data structures. Specific analyses are obtained by defining a description domain D and providing the seven parametric functions over D. The following specialisation of the general semantics captures the usual theoretical viewpoint of goal-dependent analysis. Definition. <p> This formalises the approach taken in some of the implementations of common domains such as Sharing (set sharing), ASub (pair sharing), and Def (definiteness dependencies), as for example, those embedded in PLAI <ref> [19] </ref> and GAIA [15]. Definition. The specialised semantics, spec D , is identical to the standard semantics except that the abstract combination comb D is replaced by comb spec D which is required to be safe. <p> Finally, for each abstract domain we have implemented a fused semantics, sfuse for SS and fuse (based on diff ) for Asub. All these analysers have been integrated in the PLAI framework <ref> [19] </ref>, in which a specialised version for ASub was already available. The reliability of the comparison is based on the fact that, for each abstract domain, the different versions have been implemented in such a way that they reuse the abstract functions from the standard version.
Reference: [20] <author> Stndergaard, H., </author> <title> An Application of Abstract Interpretation of Logic Programs: Occur Check Reduction, </title> <editor> in: B. Robinet and R. Wilhelm (eds.), </editor> <booktitle> Proc. ESOP 86 (Lecture Notes in Computer Science 213), </booktitle> <pages> pp. 327-338, </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The reader is urged to refer back to this figure occasionally to put results in context. We have implemented all the methods discussed here, and we provide an empirical evaluation of them, for two analysis domains: the structure sharing domain used above and the ASub domain <ref> [20] </ref> which describes pairwise variable sharing. Our results show that differential methods can provide significantly more accurate analyses for a small extra implementation effort, without significantly compromising the efficiency of analysis, and sometimes improving it. <p> It is straightforward to fix this problem along the lines of [16], but we prefer not to complicate the definition further. 7 non-linear). Note that the pairs are symmetric and that true SS is the empty set. The structure sharing domain was introduced by Stndergaard <ref> [20] </ref> as a component of an analysis for determining when dropping the occur check in unification is safe. <p> Upon return, the description at 2 fl using the standard approach is again fXY; XA; XX; Y Y; Y Ag, while the specialised combination yields fXY g. Example 3.4 Consider the abstract domain ASub <ref> [20] </ref> which describes pairwise variable sharing. A description [G; V S] has two components, a groundness description G as in Example 2.1, and a structure sharing description V S as in the abstract domain SS.
Reference: [21] <author> Taylor, A., </author> <title> LIPS on a MIPS: Results from a Prolog Compiler for a RISC, </title> <editor> in: D. Warren and P. Szeredi (eds.), </editor> <booktitle> Logic Programming: Proc. Seventh Int. Conf., </booktitle> <pages> pp. 174-185, </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog (see for example <ref> [21, 22] </ref>) and significantly improve automatic parallelisation (see for example [2]). Recently, Kelly et al. [14] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs has resulted in several generic "frameworks" for logic programming.
Reference: [22] <author> Van Roy, P. and Despain, A., </author> <title> The Benefits of Global Dataflow Analysis for an Optimizing Prolog Compiler, </title> <editor> in: S. Debray and M. Hermenegildo (eds.), </editor> <booktitle> Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> pp. 501-515, </pages> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 31 </month>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog (see for example <ref> [21, 22] </ref>) and significantly improve automatic parallelisation (see for example [2]). Recently, Kelly et al. [14] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs has resulted in several generic "frameworks" for logic programming.
References-found: 22

