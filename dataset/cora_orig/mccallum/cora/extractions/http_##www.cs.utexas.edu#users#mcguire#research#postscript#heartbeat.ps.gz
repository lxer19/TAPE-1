URL: http://www.cs.utexas.edu/users/mcguire/research/postscript/heartbeat.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/mcguire/research/
Root-URL: 
Email: gouda@cs.utexas.edu mcguire@cs.utexas.edu  
Title: Accelerated Heartbeat Protocols  
Author: Mohamed G. Gouda Tommy M. McGuire 
Address: Austin, Texas 78712-1188 Austin, Texas 78712-1188  
Affiliation: Department of Computer Sciences Department of Computer Sciences The University of Texas at Austin The University of Texas at Austin  
Abstract: Heartbeat protocols are used by distributed programs to ensure that if a process in a program terminates or fails, then the remaining processes in the program terminate. We present a class of heartbeat protocols that tolerate message loss. In these protocols, a root process periodically sends a beat message to every other process then waits to receive a reply beat message from every other process. If the root process does not receive a reply (possibly due to message loss), the root process reduces by half the period for sending beat messages. We show that in practical situations, the parameters of these protocols can be chosen to achieve a good compromise between three contradictory objectives: reduce the rate of sending beat messages, reduce the detection delay, and still keep the probability of premature termination small. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Barborak, M., M. Malek, and A. Dahbura, </author> <title> The Consensus Problem in Fault-Tolerant Computing, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 25, No. 2, </volume> <pages> pp. 171-220, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Telephone: + Intl. 908-562-3966. col ensures that if one or more processes in a program fail or terminate, then every other process in the program terminates. Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis <ref> [1] </ref>, network protocols [2], reaching agreement [4], mobile computing [9], and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in [3, 5, 6]) in two important ways. <p> Outcome: If every process in the network continues to choose to remain active, then all processes remain active indefinitely. On the other hand, if one or more processes ever choose to become inactive, then all processes in the network eventually become inactive. Let p [0]; p <ref> [1] </ref>; :::; p [n] be the processes in the network. In order to satisfy the start condition, each process p [i] has a local boolean variable, named active, whose initial value is true. <p> In the following sections, we present a family of four heartbeat protocols. 1. The first protocol is called the binary heartbeat protocol. This protocol involves two processes, p [0] and p <ref> [1] </ref>. No process can join or leave this protocol. 2. The second protocol is called the static heartbeat protocol. This protocol involves n + 1 processes, p [0] to p [n]. No process can join or leave this protocol. 3. The third protocol is called the expanding heartbeat protocol. <p> This protocol starts with only one process, p [0]. Each of the other processes can join the protocol later. Each process that joins the protocol can leave afterwards. 3 The binary heartbeat protocol Consider the case where the network that has only two processes, p [0] and p <ref> [1] </ref>. The communication between p [0] and p [1] can be partitioned into successive time periods. In each period, process p [0] sends a beat message to process p [1] then waits to receive back a beat message from p [1]. <p> Each of the other processes can join the protocol later. Each process that joins the protocol can leave afterwards. 3 The binary heartbeat protocol Consider the case where the network that has only two processes, p [0] and p <ref> [1] </ref>. The communication between p [0] and p [1] can be partitioned into successive time periods. In each period, process p [0] sends a beat message to process p [1] then waits to receive back a beat message from p [1]. <p> afterwards. 3 The binary heartbeat protocol Consider the case where the network that has only two processes, p [0] and p <ref> [1] </ref>. The communication between p [0] and p [1] can be partitioned into successive time periods. In each period, process p [0] sends a beat message to process p [1] then waits to receive back a beat message from p [1]. The length of each period depends on the events that occurred in the preceding period according to the following three rules. 1. If in a period, p [0] sends a beat message to p [1] and receives a beat <p> network that has only two processes, p [0] and p <ref> [1] </ref>. The communication between p [0] and p [1] can be partitioned into successive time periods. In each period, process p [0] sends a beat message to process p [1] then waits to receive back a beat message from p [1]. The length of each period depends on the events that occurred in the preceding period according to the following three rules. 1. If in a period, p [0] sends a beat message to p [1] and receives a beat message from p [1], then p [0] makes the length of <p> message to process p <ref> [1] </ref> then waits to receive back a beat message from p [1]. The length of each period depends on the events that occurred in the preceding period according to the following three rules. 1. If in a period, p [0] sends a beat message to p [1] and receives a beat message from p [1], then p [0] makes the length of the next period a large value tmax (irre <br>- spective on the length of the current period). 2. If in a period, p [0] sends a beat message to p [1] but does not receive <p> receive back a beat message from p <ref> [1] </ref>. The length of each period depends on the events that occurred in the preceding period according to the following three rules. 1. If in a period, p [0] sends a beat message to p [1] and receives a beat message from p [1], then p [0] makes the length of the next period a large value tmax (irre <br>- spective on the length of the current period). 2. If in a period, p [0] sends a beat message to p [1] but does not receive a beat message from p [1], then p <p> beat message to p <ref> [1] </ref> and receives a beat message from p [1], then p [0] makes the length of the next period a large value tmax (irre <br>- spective on the length of the current period). 2. If in a period, p [0] sends a beat message to p [1] but does not receive a beat message from p [1], then p [0] makes the length of the next period half that of the current period. 3. <p> from p <ref> [1] </ref>, then p [0] makes the length of the next period a large value tmax (irre <br>- spective on the length of the current period). 2. If in a period, p [0] sends a beat message to p [1] but does not receive a beat message from p [1], then p [0] makes the length of the next period half that of the current period. 3. If the length of the next period ever becomes less than a specified value tmin, that is an upper bound on the round-trip delay between p [0] and p [1], then p [0] <p> message from p <ref> [1] </ref>, then p [0] makes the length of the next period half that of the current period. 3. If the length of the next period ever becomes less than a specified value tmin, that is an upper bound on the round-trip delay between p [0] and p [1], then p [0] becomes inactive and stops sending beat messages to p [1]. Some explanation concerning these three rules is in order. Rule 1 is adopted to ensure that when process p [0] and p [1] and the communication medium between them are all up (a typical situation), the rate <p> If the length of the next period ever becomes less than a specified value tmin, that is an upper bound on the round-trip delay between p [0] and p <ref> [1] </ref>, then p [0] becomes inactive and stops sending beat messages to p [1]. Some explanation concerning these three rules is in order. Rule 1 is adopted to ensure that when process p [0] and p [1] and the communication medium between them are all up (a typical situation), the rate of sending beat messages is kept small. <p> that is an upper bound on the round-trip delay between p [0] and p <ref> [1] </ref>, then p [0] becomes inactive and stops sending beat messages to p [1]. Some explanation concerning these three rules is in order. Rule 1 is adopted to ensure that when process p [0] and p [1] and the communication medium between them are all up (a typical situation), the rate of sending beat messages is kept small. <p> In effect, the three rules constitute our compromise between the conflicting design objectives of heartbeat protocols discussed in Section 1. From these three rules, if p [0] does not receive any beat message for a period of 2tmax, then p [0] becomes inactive. Moreover, if p <ref> [1] </ref> does not receive any beat message for a period of 3tmax tmin (and so it does not send any beat messages for the same period), then p [1] recognizes that p [0] has already become inactive and p [1] itself becomes inactive. <p> Moreover, if p <ref> [1] </ref> does not receive any beat message for a period of 3tmax tmin (and so it does not send any beat messages for the same period), then p [1] recognizes that p [0] has already become inactive and p [1] itself becomes inactive. To explain the period 3tmaxtmin, consider the following scenario. 1. p [0] sends and receives beat messages. The period is tmax. 2. The network fails; all further messages are lost. 3. <p> Moreover, if p <ref> [1] </ref> does not receive any beat message for a period of 3tmax tmin (and so it does not send any beat messages for the same period), then p [1] recognizes that p [0] has already become inactive and p [1] itself becomes inactive. To explain the period 3tmaxtmin, consider the following scenario. 1. p [0] sends and receives beat messages. The period is tmax. 2. The network fails; all further messages are lost. 3. After a period of tmax, p [0] sends a beat message. 4. <p> In this binary heartbeat protocol, process p [0] has two constants, tmin and tmax, and three variables named active, rcvd, and t. Variable active is discussed in Section 2. Variable rcvd is used to indicate whether p [0] has received a beat message from p <ref> [1] </ref> in the current period. Variable t stores the length of the current period. <p> active := false fi timeout active ^ fa time period of at least t units has passed without sending a beat messageg ! if rcvd ! t := tmax :rcvd ! t := t=2 fi; if t &lt; tmin ! active := false t tmin ! send beat to p <ref> [1] </ref>; rcvd := false fi rcv beat from p [1] ! if active ! rcvd := true :active ! skip fi Process p [0] has three actions. The first action is the activity action discussed in Section 2. <p> period of at least t units has passed without sending a beat messageg ! if rcvd ! t := tmax :rcvd ! t := t=2 fi; if t &lt; tmin ! active := false t tmin ! send beat to p <ref> [1] </ref>; rcvd := false fi rcv beat from p [1] ! if active ! rcvd := true :active ! skip fi Process p [0] has three actions. The first action is the activity action discussed in Section 2. <p> Executing this action consists of computing length t of the next period and deciding whether to start the next period (if t &gt; tmin), or become inactive (if t tmin). In the third action, p [0] receives a beat message from p <ref> [1] </ref> and assigns its variable rcvd the value true. Process p [1] in the binary heartbeat protocol can be defined as follows. process p [1] const tmin; tmax : integer f0 &lt; tmin tmaxg var active : boolean finitially trueg begin active ! if true ! skip true ! active := <p> In the third action, p [0] receives a beat message from p <ref> [1] </ref> and assigns its variable rcvd the value true. Process p [1] in the binary heartbeat protocol can be defined as follows. process p [1] const tmin; tmax : integer f0 &lt; tmin tmaxg var active : boolean finitially trueg begin active ! if true ! skip true ! active := false fi rcv beat from p [0] ! if active ! <p> In the third action, p [0] receives a beat message from p <ref> [1] </ref> and assigns its variable rcvd the value true. Process p [1] in the binary heartbeat protocol can be defined as follows. process p [1] const tmin; tmax : integer f0 &lt; tmin tmaxg var active : boolean finitially trueg begin active ! if true ! skip true ! active := false fi rcv beat from p [0] ! if active ! send beat to p [0] :active ! skip fi timeout active ^ fa <p> true ! active := false fi rcv beat from p [0] ! if active ! send beat to p [0] :active ! skip fi timeout active ^ fa time period of at least 3tmax tmin units has passed without receiving a beat messageg ! active := false end Process p <ref> [1] </ref> has three actions. The first action is the activity action discussed in Section 2. In the second action, p [1] receives a beat message from p [0] then sends a beat message to p [0] (if p [1] is still active). In the third action, p [1] recognizes that it <p> :active ! skip fi timeout active ^ fa time period of at least 3tmax tmin units has passed without receiving a beat messageg ! active := false end Process p <ref> [1] </ref> has three actions. The first action is the activity action discussed in Section 2. In the second action, p [1] receives a beat message from p [0] then sends a beat message to p [0] (if p [1] is still active). In the third action, p [1] recognizes that it is still active and that a time period of 3tmax tmin has passed without receiving any beat message. <p> without receiving a beat messageg ! active := false end Process p <ref> [1] </ref> has three actions. The first action is the activity action discussed in Section 2. In the second action, p [1] receives a beat message from p [0] then sends a beat message to p [0] (if p [1] is still active). In the third action, p [1] recognizes that it is still active and that a time period of 3tmax tmin has passed without receiving any beat message. In this case, p [1] becomes inactive. <p> end Process p <ref> [1] </ref> has three actions. The first action is the activity action discussed in Section 2. In the second action, p [1] receives a beat message from p [0] then sends a beat message to p [0] (if p [1] is still active). In the third action, p [1] recognizes that it is still active and that a time period of 3tmax tmin has passed without receiving any beat message. In this case, p [1] becomes inactive. It is instructive to compare the binary heartbeat protocol with another heartbeat protocol, called the two-phase heartbeat protocol. <p> beat message from p [0] then sends a beat message to p [0] (if p <ref> [1] </ref> is still active). In the third action, p [1] recognizes that it is still active and that a time period of 3tmax tmin has passed without receiving any beat message. In this case, p [1] becomes inactive. It is instructive to compare the binary heartbeat protocol with another heartbeat protocol, called the two-phase heartbeat protocol. In the two-phase heartbeat protocol, as long as process p [0] keeps on receiving the expected beat messages from process p [1], p [0] sends a beat message to p <p> In this case, p <ref> [1] </ref> becomes inactive. It is instructive to compare the binary heartbeat protocol with another heartbeat protocol, called the two-phase heartbeat protocol. In the two-phase heartbeat protocol, as long as process p [0] keeps on receiving the expected beat messages from process p [1], p [0] sends a beat message to p [1] every tmax time units. However, if process p [0] does not receive an expected beat message from process p [1], then p [0] starts to send a beat message to p [1] every tmin time units. <p> It is instructive to compare the binary heartbeat protocol with another heartbeat protocol, called the two-phase heartbeat protocol. In the two-phase heartbeat protocol, as long as process p [0] keeps on receiving the expected beat messages from process p <ref> [1] </ref>, p [0] sends a beat message to p [1] every tmax time units. However, if process p [0] does not receive an expected beat message from process p [1], then p [0] starts to send a beat message to p [1] every tmin time units. <p> In the two-phase heartbeat protocol, as long as process p [0] keeps on receiving the expected beat messages from process p <ref> [1] </ref>, p [0] sends a beat message to p [1] every tmax time units. However, if process p [0] does not receive an expected beat message from process p [1], then p [0] starts to send a beat message to p [1] every tmin time units. <p> on receiving the expected beat messages from process p <ref> [1] </ref>, p [0] sends a beat message to p [1] every tmax time units. However, if process p [0] does not receive an expected beat message from process p [1], then p [0] starts to send a beat message to p [1] every tmin time units. <p> It is also instructive to compare the binary heartbeat protocol with the timeout mechanism in TCP. In TCP, a process p [0] sends a sequence of data messages to another process p <ref> [1] </ref>, then waits to receive an acknowledgment from p [1] for each sent data message. If p [0] does not receive an acknowledgment for some data message, then p [0] resends the data message after some timeout period t and makes the timeout period 2t. <p> It is also instructive to compare the binary heartbeat protocol with the timeout mechanism in TCP. In TCP, a process p [0] sends a sequence of data messages to another process p <ref> [1] </ref>, then waits to receive an acknowledgment from p [1] for each sent data message. If p [0] does not receive an acknowledgment for some data message, then p [0] resends the data message after some timeout period t and makes the timeout period 2t. Thus, a data message can be resent from p [0] to p [1] after tmin, <p> from p <ref> [1] </ref> for each sent data message. If p [0] does not receive an acknowledgment for some data message, then p [0] resends the data message after some timeout period t and makes the timeout period 2t. Thus, a data message can be resent from p [0] to p [1] after tmin, then after 2tmin, then after 4tmin, ..., and finally after tmax time units. Clearly, this exponential back-off in the TCP timeout mechanism is different from the exponential speed-up in the binary heartbeat protocol. The reason for this difference is two-fold. 1. <p> Hence, only with a small probability can the same congestion cause the loss of both messages, even if this time period is shortened (by a factor of two). 4 Analysis of the binary heartbeat protocol If either process (p [0] or p <ref> [1] </ref>) in the binary heartbeat protocol executes its first action and assigns its variable active the value false, then eventually the other process times out and assigns its variable active the value false, in accordance with the outcome requirement in Section 2. <p> First, p [0] computes the length of the next period tm [i] for each process p [i], assuming a binary heartbeat protocol between p [0] and p [i]. Second, p [0] selects the smallest tm [i] to be the length t of the next period: t = min (tm <ref> [1] </ref>; tm [2]; :::; tm [n]) Process p [0] in the static heartbeat protocol can be defined as follows. (Note that the three actions in this p [0] correspond to the the three actions in p [0] of the binary heartbeat protocol.) process p [0] const tmin; tmax : integer f0 <p> BCAST :: k := 1; do k n ! send beat to p [k]; rcvd [k]; k := false; k + 1 od Each of the processes p [0]; :::; p [n] in the static heartbeat protocol is defined exactly as process p <ref> [1] </ref> in the binary heartbeat protocol. The analysis of the static heartbeat protocol is similar to that of the binary heartbeat protocol in Section 4. In particular, relations (1) and (3) of the binary heartbeat protocol are still valid for the static heartbeat protocol. <p> BCAST 0 :: k := 1; do k n ! if jnd [k] ! send beat to p [k] :jnd [k] ! skip fi; rcvd [k]; k := false; k + 1 od Processes p <ref> [1] </ref>; :::; p [n] in the expanding heartbeat protocol have one additional variable, named join, over process p [i : 1::n] in the static heartbeat protocol. Variable join in process p [i] has the value true iff p [i] has already joined the heartbeat protocol. <p> Second, when p [0] in the dynamic heartbeat protocol receives a beat (b) message from p [i], p [0] assigns both rcvd [i] and jnd [i] the value b. Processes p <ref> [1] </ref>; :::; p [n] in the dynamic heartbeat protocol can be defined as follows. process p [i : 1::n] const tmin; tmax : integer f0 &lt; tmin tmaxg var active : boolean finitially trueg join : boolean; finitially falseg leave : boolean finitially falseg begin active ! if true ! skip <p> In our protocols, we assumed that the processes are arranged in a flat spanning tree where p [0] is the parent and each of the other processes p <ref> [1] </ref>; :::; p [n] is a child. Clearly these protocols can be extended in a straightforward manner to the case where the processes are arranged in a general spanning tree.
Reference: [2] <author> Braden, R., </author> <title> editor, Requirements for Internet HostsCommunication Layers, </title> <type> RFC 1122, </type> <month> October </month> <year> 1989. </year>
Reference-contexts: Telephone: + Intl. 908-562-3966. col ensures that if one or more processes in a program fail or terminate, then every other process in the program terminates. Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols <ref> [2] </ref>, reaching agreement [4], mobile computing [9], and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in [3, 5, 6]) in two important ways. <p> Second, p [0] selects the smallest tm [i] to be the length t of the next period: t = min (tm [1]; tm <ref> [2] </ref>; :::; tm [n]) Process p [0] in the static heartbeat protocol can be defined as follows. (Note that the three actions in this p [0] correspond to the the three actions in p [0] of the binary heartbeat protocol.) process p [0] const tmin; tmax : integer f0 &lt; tmin
Reference: [3] <author> Chandy, K. M. and J. Misra, </author> <title> Termination Detection, Chapter 9 in Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols [2], reaching agreement [4], mobile computing [9], and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in <ref> [3, 5, 6] </ref>) in two important ways. First, a heartbeat protocol causes all processes to terminate when one or more processes terminate, whereas a termination detection algorithm merely detects that termination has occurred when all processes do terminate.
Reference: [4] <author> Cristian, F., </author> <title> Reaching Agreement on ProcessorGroup Membership, </title> <journal> Distributed Computing, </journal> <volume> Vol. 4, </volume> <pages> pp. 175-187, </pages> <year> 1991. </year>
Reference-contexts: Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols [2], reaching agreement <ref> [4] </ref>, mobile computing [9], and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in [3, 5, 6]) in two important ways.
Reference: [5] <author> Dijkstra, E. W. and C. S. Scholten, </author> <title> Termination Detection for Diffusing Computations, </title> <journal> Information Processing Letters, </journal> <volume> Vol. 11, No. 1, </volume> <month> August </month> <year> 1980. </year>
Reference-contexts: Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols [2], reaching agreement [4], mobile computing [9], and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in <ref> [3, 5, 6] </ref>) in two important ways. First, a heartbeat protocol causes all processes to terminate when one or more processes terminate, whereas a termination detection algorithm merely detects that termination has occurred when all processes do terminate.
Reference: [6] <author> Francez, N., </author> <title> Distributed Termination, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 2, No. 1, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols [2], reaching agreement [4], mobile computing [9], and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in <ref> [3, 5, 6] </ref>) in two important ways. First, a heartbeat protocol causes all processes to terminate when one or more processes terminate, whereas a termination detection algorithm merely detects that termination has occurred when all processes do terminate.
Reference: [7] <author> Gouda, M. G. </author> <title> Network Processes, Chapter 3 in Elements of Network Protocol Design, </title> <publisher> John Wiley and Sons, </publisher> <year> 1998. </year>
Reference-contexts: Any execution of this action either keeps the current value (true) of variable active unchanged, or assigns variable active the value false. (The Abstract Protocol notation of <ref> [7] </ref> is used in defining the processes in this paper. However, for the rest of the paper, we assume that the reader is not familiar with that notation.) To satisfy the outcome condition, the processes need to exchange beat messages according to some heartbeat protocol.
Reference: [8] <author> McGuire, T., </author> <title> Implementing Abstract Protocols in C. M. A. </title> <type> Thesis, </type> <institution> Department of Computer Sciences, the University of Texas at Austin, </institution> <year> 1994. </year> <note> Also ap-peared as a Technical Report, TR 96-31, </note> <institution> Department of Computer Sciences, the University of Texas at Austin, </institution> <year> 1996. </year>
Reference-contexts: Currently, we are implementing these heartbeat protocols on the Internet. Our implementation is based on a C library that we have developed to support fast prototyping of network protocols from their abstract specifications <ref> [8] </ref>. Acknowledgments We are thankful to Anish Arora and the anonymous referees for their helpful comments on an earlier version of this paper.
Reference: [9] <author> Pradhan, D. K. et. al., </author> <title> Recoverable Mobile Environment Design and Trade-off Analysis, </title> <address> FTCS '96, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols [2], reaching agreement [4], mobile computing <ref> [9] </ref>, and fault detection in computer networks [12]. Heartbeat protocols differ from termination detection algorithms (as discussed for example in [3, 5, 6]) in two important ways.
Reference: [10] <author> Stevens, R. W., </author> <title> TCP/IP Illustrated: The Protocols, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: The Transmission Control Protocol (or TCP for short) has an optional heartbeat feature based on the two-phase heartbeat protocol discussed above <ref> [10] </ref>. In this case, the values of tmax and tmin are chosen very large (namely, tmax = 2 hours, and tmin = 75 seconds) to compensate for the inherent inefficiency of this protocol. It is also instructive to compare the binary heartbeat protocol with the timeout mechanism in TCP.
Reference: [11] <author> Tseng, Y. C., </author> <title> Detecting Termination By Weight Throwing in a Faulty Distributed System, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 25, No. 1, </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: Second, a heartbeat protocol causes all processes to terminate when the communication medium between the processes fails, whereas the correctness of a termination detection algorithm is usually based on the assumption that the communication medium does not fail or that its failure can be detected by a heartbeat protocol <ref> [11] </ref>. In designing a heartbeat protocol, the protocol designer strives to achieve the following three objectives. 1. The rate at which beat messages are sent in the protocol should be small, in order to reduce protocol over <br>- head. 2.
Reference: [12] <author> Vogels, W., </author> <title> World Wide Failures, </title> <booktitle> ACM SIGOPS 1996 European Workshop, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: Many uses of heartbeat protocols are reported in the literature. For example, they are used in system diagnosis [1], network protocols [2], reaching agreement [4], mobile computing [9], and fault detection in computer networks <ref> [12] </ref>. Heartbeat protocols differ from termination detection algorithms (as discussed for example in [3, 5, 6]) in two important ways.
References-found: 12

