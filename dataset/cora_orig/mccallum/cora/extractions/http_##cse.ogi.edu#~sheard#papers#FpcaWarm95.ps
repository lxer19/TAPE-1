URL: http://cse.ogi.edu/~sheard/papers/FpcaWarm95.ps
Refering-URL: http://www.cse.ogi.edu/~sheard/sheard.html
Root-URL: http://www.cse.ogi.edu
Email: fjl,sheardg@cse.ogi.edu  
Title: Warm Fusion: Deriving Build-Catas from Recursive Definitions  
Author: John Launchbury Tim Sheard 
Address: P.O. Box 91000, Portland, OR 97291-1000 USA  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: Program fusion is the process whereby separate pieces of code are fused into a single piece, typically transforming a multi-pass algorithm into a single pass. Recent work has made it clear that the process is especially successful if the loops or recursions are expressed using catamorphisms (e.g.foldr) and constructor-abstraction (e.g. build). In this paper we show how to transform recursive programs into this form automatically, thus enabling the fusion transformation to be applied more easily than before. 
Abstract-found: 1
Intro-found: 1
Reference: [DB76] <author> J.Darlington and R.Burstall, </author> <title> A System which Automatically Improves Programs. </title> <journal> Acta Infor-matica, </journal> <volume> 6(1), </volume> <pages> pp 41-60, </pages> <year> 1976. </year>
Reference-contexts: this paper, we show how to preprocess recursive function definitions, turning them into a form particularly suited to enabling component fusion. 2 Background Darlington and Burstall showed how fold-unfold transformations could be used (with human help) to produce single-pass function definitions from the composition of two or more other functions <ref> [DB76] </ref>. Turchin applied similar ideas within his supercompilation process [Tur86]. The supervising-compiler performed a symbolic execution of the program, building a residual program whenever computations could not be performed. Patterns in the nesting of recursive calls of functions were spotted and a single new recursive function produced.
Reference: [FW89] <author> A.Ferguson and P.Wadler, </author> <title> When will deforestation stop?. </title> <booktitle> Proc. Glasgow workshop on Functional Programming, </booktitle> <address> Rothesay, Scotland, </address> <institution> Dept. of CS, Glasgow, </institution> <year> 1989. </year>
Reference-contexts: He then proved that compositions of treeless functions, could be deforested into a single treeless function. A termination proof followed later <ref> [FW89] </ref>. The original deforestation work was limited to first order. Attempts to extend it to higher order have met with limited success so far. In particular, it is often hard to find where to tie the recursive knot. Termination proofs also seem to be rather hard.
Reference: [GLPJ93] <author> A.Gill, J.Launchbury, and S.Peyton Jones, </author> <title> A Short-cut to Deforestation. </title> <booktitle> Proc. ACM FPCA 93, </booktitle> <address> Copenhagen, </address> <year> 1993. </year>
Reference-contexts: However, a problem arises in practice. Without some user-supplied guidance, the fusion engine attempts to fuse everything, leading to combinatorial explosion. About the same time, Gill, Launchbury and Peyton Jones explored a one-step fusion algorithm which relied on functions being written in a highly-stylized form <ref> [GLPJ93] </ref>. Functions had to consume their arguments using the catamor-phism foldr and produce their list-results by first abstracting over cons and nil, and then using a new language construct called build. <p> If build was exposed to the programmer then a corresponding "cleanliness" check would be required: the type-rule of Gill, Launchbury and Peyton Jones serves this purpose, for example <ref> [GLPJ93] </ref>. 4 Two-stage Fusion As stated earlier, our fusion process proceeds in two separate phases. First individual function definitions are preprocessed in an attempt to re-express their definition in terms of a build and a catamorphism. <p> So, for example, rather than work with the literal list: Cons (1; Cons (2; Cons (3; Nil ()))) we work with the function (n; c) : c (1; c (2; c (3; n ()))). But now the expression is no longer a list! It's a function. So (following <ref> [GLPJ93] </ref>) we introduce a construct for each data type T called build T defined by build T g = g (Constrs (T )). <p> Such is the case with append. Applying the algorithm gives the result append = x : y : build List ((n; c) : cata List (() : cata List (n; c) y; c) x) which is equivalent to the version given in <ref> [GLPJ93] </ref>. <p> The second is taken apart by explicit case-analysis. Thus, as in <ref> [GLPJ93, SF93] </ref>, zip only fuses on it's first argument. The take function is interesting since it's Q context is non-trivial, because of testing the integer argument in the original recursive definition.
Reference: [KL95] <author> D.King and J.Launchbury, </author> <title> Structuring DFS Algorithms in Haskell. </title> <booktitle> Proc. ACM POPL 95, </booktitle> <address> San Francisco, </address> <year> 1995. </year>
Reference-contexts: Another telling example is that of depth-first traversal of graphs. Many standard algorithms may be expressed very succinctly and simply as explicit manipulations of a graph's depth-first spanning forest, but in execution the literal presence of the forest is inefficient <ref> [KL95] </ref>.
Reference: [Mal89] <author> G.Malcolm. </author> <title> Homomorphisms and Promotabil-ity. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 335-347. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Catamorphisms express "regular recursion" over data structures. Generalising the datatype-specific work of Bird and Meerten's, Malcolm pop-ularised the promotion theorems from category theory which describe how to fuse catamorphisms <ref> [Mal89] </ref>. Much of this theory was turned into practice by Sheard and Fegaras [SF93]. Working with a language without general recursion but containing catamorphisms (and their gen-eralisation: homomorphisms), Sheard and Fegaras implemented a fusion algorithm based on the promotion theorems. However, a problem arises in practice. <p> The algorithm for this is based on the promotion theorem, which describes when the composition of a (strict) function g with a cata can be expressed as another cata <ref> [Mal89, MFR91] </ref>. 8C : g (f C (y 1 ; : : : ; y n )) = h C (E C (g)(y 1 ; : : : ; y n )) g (cata T f x) = cata T h x Instantiating the theorem to lists gives: g (f Nil
Reference: [MFR91] <author> E.Meijer, M.Fokkinga, and R.Paterson, </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> Proc. FPCA 91, LNCS 523, </booktitle> <month> S-V </month> <year> 1991. </year>
Reference-contexts: The algorithm for this is based on the promotion theorem, which describes when the composition of a (strict) function g with a cata can be expressed as another cata <ref> [Mal89, MFR91] </ref>. 8C : g (f C (y 1 ; : : : ; y n )) = h C (E C (g)(y 1 ; : : : ; y n )) g (cata T f x) = cata T h x Instantiating the theorem to lists gives: g (f Nil
Reference: [MH95] <author> E.Meijer and G.Hutton, </author> <title> Bananas in Space: Extending Squiggol to Function-Space Types. </title> <booktitle> Proc. FPCA 95, </booktitle>
Reference-contexts: More significantly, we also restrict ourselves to ground data types, that is, data types which are not built using function space. Recent work by Hutton and Meijer may point the way to relaxing this restriction <ref> [MH95] </ref>. In a practical context, if these data types occur, then our algorithm simply makes no attempt to fuse them. Finally, while the build form is presented as a part of the language, our intent is that it be used for internal purposes only and not exposed to a programmer.
Reference: [PJL91] <author> S.Peyton Jones and J.Launchbury, </author> <title> Unboxed Values as First Class Citizens in a Non-strict Functional Language, </title> <booktitle> Proc. FPCA 91, LNCS 523, </booktitle> <month> S-V </month> <year> 1991. </year>
Reference-contexts: The function f is a "wrapper" and f # a "worker" in the sense of Peyton Jones and Launchbury <ref> [PJL91] </ref>. Wrapper functions are freely unfolded, so we substitute the new body of f in the definition of f # . We now have a recursive function with an outer case over the first argument.
Reference: [SF93] <author> T.Sheard and L.Fegaras, </author> <title> A Fold for All Seasons. </title> <booktitle> Proc. ACM FPCA 93, </booktitle> <address> Copenhagen, </address> <year> 1993. </year>
Reference-contexts: Catamorphisms express "regular recursion" over data structures. Generalising the datatype-specific work of Bird and Meerten's, Malcolm pop-ularised the promotion theorems from category theory which describe how to fuse catamorphisms [Mal89]. Much of this theory was turned into practice by Sheard and Fegaras <ref> [SF93] </ref>. Working with a language without general recursion but containing catamorphisms (and their gen-eralisation: homomorphisms), Sheard and Fegaras implemented a fusion algorithm based on the promotion theorems. However, a problem arises in practice. Without some user-supplied guidance, the fusion engine attempts to fuse everything, leading to combinatorial explosion. <p> In order to do this we must find a set of functions h C which meet the conditions of the premise. In previous work, Sheard and Fegaras described a fusion algorithm which either computed the h C , or terminated with failure <ref> [SF93] </ref>. The challenge in computing the h C is the presence of the E C (g) term on the right-hand side of the premise (in the general case). <p> The second is taken apart by explicit case-analysis. Thus, as in <ref> [GLPJ93, SF93] </ref>, zip only fuses on it's first argument. The take function is interesting since it's Q context is non-trivial, because of testing the integer argument in the original recursive definition.
Reference: [SF93] <author> T. Sheard, L. Fegaras and T. Zhou, </author> <title> Improving Programs Which Induct Over Multiple Inductive Structures. </title> <booktitle> ACM SIGPLAN workshop on Partial Evaluation and Semantic's Based Program Manipulation, </booktitle> <address> PEPM'94. Orlando Florida. </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Catamorphisms express "regular recursion" over data structures. Generalising the datatype-specific work of Bird and Meerten's, Malcolm pop-ularised the promotion theorems from category theory which describe how to fuse catamorphisms [Mal89]. Much of this theory was turned into practice by Sheard and Fegaras <ref> [SF93] </ref>. Working with a language without general recursion but containing catamorphisms (and their gen-eralisation: homomorphisms), Sheard and Fegaras implemented a fusion algorithm based on the promotion theorems. However, a problem arises in practice. Without some user-supplied guidance, the fusion engine attempts to fuse everything, leading to combinatorial explosion. <p> In order to do this we must find a set of functions h C which meet the conditions of the premise. In previous work, Sheard and Fegaras described a fusion algorithm which either computed the h C , or terminated with failure <ref> [SF93] </ref>. The challenge in computing the h C is the presence of the E C (g) term on the right-hand side of the premise (in the general case). <p> The second is taken apart by explicit case-analysis. Thus, as in <ref> [GLPJ93, SF93] </ref>, zip only fuses on it's first argument. The take function is interesting since it's Q context is non-trivial, because of testing the integer argument in the original recursive definition.
Reference: [Tur86] <author> V.Turchin, </author> <title> The Concept of a Supercompiler. </title> <journal> ACM TOPLAS, </journal> <volume> 8, 3, </volume> <pages> pp 292-325, </pages> <year> 1986. </year>
Reference-contexts: Turchin applied similar ideas within his supercompilation process <ref> [Tur86] </ref>. The supervising-compiler performed a symbolic execution of the program, building a residual program whenever computations could not be performed. Patterns in the nesting of recursive calls of functions were spotted and a single new recursive function produced.
Reference: [Wad84] <author> P.Wadler, </author> <title> Listlessness is better than laziness: lazy evaluation and garbage collection at compile time. </title> <booktitle> Proc. ACM L&FP, </booktitle> <address> Austin, </address> <year> 1984. </year>
Reference-contexts: While the process showed a high degree of automation, the method of generalisation used to control termination was rather crude. Wadler also developed many of these same ideas in his listless transformer <ref> [Wad84] </ref>. Multi-pass programs with intermediate lists were converted into single loops in an imperative language.
Reference: [Wad90] <author> P.Wadler, </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <journal> TCS 73, </journal> <pages> pp 231-284, </pages> <publisher> North Holland 1990. </publisher>
Reference-contexts: Multi-pass programs with intermediate lists were converted into single loops in an imperative language. Later, it became clear that the method could be expressed within the functional language itself, and he further refined the idea, calling the method deforestation <ref> [Wad90] </ref>, a pun which has stuck and is now commonly used. In order to be precise about which intermediate lists were removed, Wadler defined a treeless form for function definitions in which functions were guaranteed to have no internal data structures.
References-found: 13

