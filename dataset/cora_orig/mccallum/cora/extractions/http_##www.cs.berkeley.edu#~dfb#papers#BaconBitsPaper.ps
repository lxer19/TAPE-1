URL: http://www.cs.berkeley.edu/~dfb/papers/BaconBitsPaper.ps
Refering-URL: http://www.cs.berkeley.edu/~dfb/publist.html
Root-URL: 
Title: Featherweight Monitors with Bacon Bits  
Author: David F. Bacon 
Affiliation: IBM T.J. Watson Research Center  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, T. E. </author> <title> The performance of spin lock alternatives for shared memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 1 (Jan. </month> <year> 1990), </year> <pages> 6-16. </pages> <institution> IBM Confidential 16 </institution>
Reference-contexts: If contention for objects is extremely rare, then it is acceptable for a thread to spin on a lock when it fails to acquire it <ref> [1] </ref>. In this case, no locking queues need to be maintained because the "queues" are implicit in the scheduling system. While spinning simplifies locking considerably, it violates the design criterion that locking perform well in the presence of contention. <p> He is implicitly assuming that mutual exclusion is only being used in the operating system, or that the overhead of an operating system trap is acceptable on every lock and unlock operation from user-level code. Both Anderson <ref> [1] </ref> and Mellor-Crummey and Scott [16] provide thorough discussions of synchronization algorithms for multiprocessors and include comparative performance measurements. 8 Conclusions I have described a novel algorithm for implementing language-level monitors that is highly optimized for the case when most locks are granted immediately.
Reference: [2] <author> Dijkstra, E. W. </author> <title> Solution of a problem in concurrent programming and control. </title> <journal> Commun. ACM 8, </journal> <month> 9 (Sept. </month> <year> 1965), </year> <month> 569. </month>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 11, 12, 17, 18] </ref>. These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap [8].
Reference: [3] <author> Goodman, J. R., Vernon, M. K., and Woest, P. J. </author> <title> Efficient synchronization primitives for large-scale cache-coherent multiprocessors. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems (Boston, Massachussetts, Apr. 1989), </booktitle> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 64-75. </pages>
Reference-contexts: For language-level monitors, where large numbers of uncontested locks are common, I expect that Bacon bit locks will be superior. The Bacon bit is superficially similar in function to the "syncbits" associated with the Queue On Sync Bit (QOSB) primitive proposed for the cache controllers of the Wisconsin Multicube <ref> [3] </ref>. There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations [2, 11, 12, 17, 18].
Reference: [4] <author> Gosling, J., Joy, B., and Steele, G. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachussetts, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Monitors [6] are a language-level construct for providing mutually exclusive access to shared data structures in a multi-threaded environment. However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects. Recently, their incorporation in Java <ref> [4] </ref> has led to renewed interest in monitors, because of both their prevalence and their associated performance problems. Java uses monitor semantics derived from Mesa [13].
Reference: [5] <author> Gottlieb, A., Lubachevsky, B. D., and Rudolph, L. </author> <title> Basic techniques for the efficient coordination of very large numbers of cooperating sequential processors. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 5, </volume> <month> 2 (Apr. </month> <year> 1983), </year> <pages> 164-189. </pages>
Reference-contexts: Such operations were later generalized to the Fetch-and- primitive for multiprocessors [10], and were particularly popular on machines with butterfly-type interconnects because concurrent Fetch-and- operations to the same location could be combined in the network <ref> [5] </ref>. Many microprocessors have not had compound atomic operations until relatively recently because mutual exclusion was generally considered to be the province of operating systems and parallel processors.
Reference: [6] <author> Hoare, C. A. R. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Commun. ACM 17, </journal> <month> 10 (Oct. </month> <year> 1974), </year> <pages> 549-557. </pages>
Reference-contexts: 1 Introduction Monitors <ref> [6] </ref> are a language-level construct for providing mutually exclusive access to shared data structures in a multi-threaded environment. However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects.
Reference: [7] <author> IBM. </author> <title> IBM high performance compiler for Java: An optimizing native code compiler for Java applications. </title> <note> AIXpert (1997). See also http://www.alphaWorks.ibm.com/formula. </note>
Reference-contexts: Note: data for the jgl benchmark was not collected due to disk space limitations. I have ordered a bigger disk. Java compiler (not an interpreter) developed at IBM for the AIX platform <ref> [7] </ref>. Using compiled Java is a better yardstick of the importance of locking because it does not include the overhead that is present in some current Java interpreters, including Sun's, which are still quite inefficient.
Reference: [8] <institution> IBM Corporation. IBM 370 Principles of Operation. </institution>
Reference-contexts: These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap <ref> [8] </ref>. Such operations were later generalized to the Fetch-and- primitive for multiprocessors [10], and were particularly popular on machines with butterfly-type interconnects because concurrent Fetch-and- operations to the same location could be combined in the network [5].
Reference: [9] <author> Intel. </author> <title> Pentium Processor Family Developer's Manual | Volume 3: Architecture and Programming Manual, </title> <year> 1995. </year>
Reference-contexts: The cmpAndSwap () operation can be directly implemented with the Intel CMPXCHG instruction <ref> [9] </ref> or with the Power PC load-and-reserve and store-conditional instructions [15]. The add () operation atomically adds a value to the atomic word. In general it can be implemented with compare-and-swap; on the Intel architectures it can be implemented with an immediate to memory ADD instruction.
Reference: [10] <author> Kruskal, C. P., Rudolph, L., and Snir, M. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <booktitle> In Proceedings of the Fifth Annual ACM Symposium on Principles of Distributed Computing (1986), </booktitle> <pages> pp. 218-228. </pages>
Reference-contexts: These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap [8]. Such operations were later generalized to the Fetch-and- primitive for multiprocessors <ref> [10] </ref>, and were particularly popular on machines with butterfly-type interconnects because concurrent Fetch-and- operations to the same location could be combined in the network [5].
Reference: [11] <author> Lamport, L. </author> <title> The mutual exclusion problem. </title> <journal> J. ACM 33, </journal> <month> 2 (Apr. </month> <year> 1986), </year> <pages> 313-348. </pages>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 11, 12, 17, 18] </ref>. These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap [8].
Reference: [12] <author> Lamport, L. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 5, </volume> <month> 1 (Feb. </month> <year> 1987), </year> <pages> 1-11. </pages>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 11, 12, 17, 18] </ref>. These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap [8]. <p> In 1987, Lamport stated that "if the concurrent processes are being time-shared on a single processor, then mutual exclusion is easily achieved by inhibiting hardware interrupts at crucial times" <ref> [12] </ref>. He is implicitly assuming that mutual exclusion is only being used in the operating system, or that the overhead of an operating system trap is acceptable on every lock and unlock operation from user-level code.
Reference: [13] <author> Lampson, B. W., and Redell, D. D. </author> <title> Experience with processes and monitors in Mesa. </title> <booktitle> Com-mun. ACM 23, 2 (1980), </booktitle> <pages> 105-117. </pages>
Reference-contexts: However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects. Recently, their incorporation in Java [4] has led to renewed interest in monitors, because of both their prevalence and their associated performance problems. Java uses monitor semantics derived from Mesa <ref> [13] </ref>. In Java, the methods of an object may be declared synchronized meaning that the object must be locked for the duration of the method's execution. Ideally, every Java class would be thread-safe, but because of the overhead of locking, methods are only optionally synchronized.
Reference: [14] <author> Lindholm, T., and Yellin, F. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachussetts, </address> <year> 1997. </year>
Reference-contexts: The Java Virtual Machine Specification specifies that "locking any lock conceptually flushes all variables from the thread's working memory, and unlocking any lock forces the writing out to memory of all variables that the thread has assigned" <ref> [14] </ref>. This means that, in the general case, after an object is locked the modified data in the data cache must be written back to global memory. The Pentium Pro is an example of a weakly-ordered architecture.
Reference: [15] <author> May, C., Silha, E., Simpson, R., and Warren, H., Eds. </author> <title> The PowerPC Architecture, second ed. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1994. </year>
Reference-contexts: The cmpAndSwap () operation can be directly implemented with the Intel CMPXCHG instruction [9] or with the Power PC load-and-reserve and store-conditional instructions <ref> [15] </ref>. The add () operation atomically adds a value to the atomic word. In general it can be implemented with compare-and-swap; on the Intel architectures it can be implemented with an immediate to memory ADD instruction.
Reference: [16] <author> Mellor-Crummey, J. M., and Scott, M. L. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 9, </volume> <month> 1 (Feb. </month> <year> 1991), </year> <pages> 1-20. </pages>
Reference-contexts: A similar analysis can be used to determine that the stack frame element in question is not modified to refer to a different object between the monitorenter and monitorexit bytecodes. 7 Related Work The MCS locks of <ref> [16] </ref> are similar to Bacon bit locks in that they only require a single atomic operation to lock and unlock an object in the most common case, and queues are used to minimize the memory system impacts of (non-local) spinning. <p> He is implicitly assuming that mutual exclusion is only being used in the operating system, or that the overhead of an operating system trap is acceptable on every lock and unlock operation from user-level code. Both Anderson [1] and Mellor-Crummey and Scott <ref> [16] </ref> provide thorough discussions of synchronization algorithms for multiprocessors and include comparative performance measurements. 8 Conclusions I have described a novel algorithm for implementing language-level monitors that is highly optimized for the case when most locks are granted immediately.
Reference: [17] <author> Peterson, G. L. </author> <title> A new solution to Lam-port's concurrent programming problem using small shared variables. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 5, </volume> <month> 1 (Jan. </month> <year> 1983), </year> <pages> 56-65. </pages>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 11, 12, 17, 18] </ref>. These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap [8].
Reference: [18] <author> Raynal, M. </author> <title> Algorithms for Mutual Exclusion. </title> <publisher> MIT Press Series in Scientific Computation. MIT Press, </publisher> <address> Cambridge, Massachussetts, </address> <year> 1986. </year> <title> Translated from the French by D. </title> <publisher> Beeson. </publisher>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 11, 12, 17, 18] </ref>. These solutions were rendered obsolete by the introduction of instructions that per IBM Confidential 15 formed compound atomic operations such as exchange, test-and-set, and compare-and-swap [8].
Reference: [19] <author> Serrano, M. </author> <title> Java benchmark suite, </title> <year> 1997. </year>
Reference-contexts: Table 1 describes the benchmarks used in this paper <ref> [19] </ref>. They are all medium-sized programs and are heavily skewed towards compiler-like applications. However, they do exhibit a wide variety of programming styles. Table 1 gives the size of each benchmark in terms of kilobytes class files, excluding the class files of any of the standard Java libraries used.
References-found: 19

