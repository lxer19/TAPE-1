URL: http://www.cri.ensmp.fr/doc/A-250.ps.Z
Refering-URL: http://www.cri.ensmp.fr/rapports.html
Root-URL: 
Title: A Linear Algebra Framework for Static HPF Code Distribution  
Author: Corinne Ancourt Fabien Coelho Fran~cois Irigoin Ronan Keryell 
Address: 35, rue Saint Honore, 77305 Fontainebleau cedex, France  
Affiliation: Centre de Recherche en Informatique, Ecole Nationale Superieure des Mines de Paris  
Abstract: High Performance Fortran (hpf) was developed to support data parallel programming for simd and mimd machines with distributed memory. The programmer is provided a familiar uniform logic address space and specifies the data distribution by directives. The compiler then exploits these directives to allocate arrays in the local memories, to assign computations to elementary processors and to migrate data between processors when required. We show here that linear algebra is a convenient framework to encode hpf directives and to synthesize distributed code with space-efficient array allocation, tight loop bounds and minimal communications for INDEPENDENT loops. The systematic use of an affine framework makes it easy to prove the compilation scheme correct. The generated code includes traditional optimizations such as guard elimination, message vectorization, and aggregation, overlap analysis,... 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. </author> <booktitle> Compilers Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: Many partial optimization techniques are integrated in our direct synthesis approach: message vectorization, and aggregation [19], overlap analysis [15]. A new storage management scheme is also proposed. Moreover other optimizations techniques may be applied to the generated code such as vec-torization [37], loop invariant code motion <ref> [1] </ref> and software pipelining [14, 36]. Future work includes an implementation in our hpf compiler [11], extensions to optimize sequential loops, including i/o loops, to overlap communication and computation, and to handle indirections. Acknowledgments We are thankful to Pierre Jouvelot for his careful reading and the many improvements he suggested.
Reference: [2] <author> Corinne Ancourt. </author> <title> Generation automatique de codes de transfert pour multiprocesseurs a me-moires locales. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: If regions are not precise enough because convex hulls are used to summarize multiple references, it is possible to use additional parameters to exactly express a set of references <ref> [2] </ref>. This might be useful for red-black sor. <p> When no replication occurs, elementary data communications implied by send Y and receive Y can be parametrically enumerated in basis (p 0 ; u), where u is a basis for Y, the local part of Y. send and receive are polyhedral sets and algorithms in <ref> [2] </ref> can be used. If the last component of u is allocated contiguously, vector messages can be generated. 3.5 Output SPMD code The generic output spmd code, parametric on p the local processor, is shown in Figure 3. <p> The guard is hidden in the inner loop bounds. Note that an extra-loop is generated. Y diagonal can be enumerated with only two loops and three are generated. This is due to the use of an imprecise projection algorithm but does not endanger correctness <ref> [2] </ref>. Further work is needed in this area. 5.5 Integer divide One implementation of the integer divide is finally shown. The divider is assumed strictly positive, as is the case in all call sites. It necessary because Fortran remainder is not positive for nega tive numbers.
Reference: [3] <author> Corinne Ancourt and Fran~cois Irigoin. </author> <title> Scanning Polyhedra with DO Loops. </title> <booktitle> In Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: Algorithms presented in <ref> [3] </ref> can be used to generate the loop nest enumerating the local iterations. When S is of rank jaj, optimal code is generated because no projections are required. Else, the quality of the control overhead depends on the accuracy of integer projections [29], but the correctness does not.
Reference: [4] <author> Corinne Ancourt and Fran~cois Irigoin. </author> <title> Automatic Code Distribution. </title> <booktitle> In Third Workshop on Compilers for Parallel Computers, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: This is known as overlap analysis [15]. When Y (or X, or Z,...) is referenced many times in the input loop or in the input program, these references must be clustered according to their connex-ity in the dependence graph <ref> [4] </ref>. Input dependencies are taken into account as well as usual ones (flow-, anti- and output-dependencies). If two references are independent, they access two distant regions and two different local copies should be allocated to reduce the total amount of memory allocated.
Reference: [5] <author> Fran~coise Andr e, Olivier Ch eron, and Jean-Louis Pazat. </author> <title> Compiling Sequential Programs for Distributed Memory Parallel Computers with Pan-dore II. </title> <type> Technical report, </type> <institution> IRISA, </institution> <month> May </month> <year> 1992. </year>
Reference: [6] <author> Fran~coise Andr e, Jean-Louis Pazat, and Henry Thomas. </author> <title> Pandore: A System to Manage Data Dis 14 </title>
References-found: 6

