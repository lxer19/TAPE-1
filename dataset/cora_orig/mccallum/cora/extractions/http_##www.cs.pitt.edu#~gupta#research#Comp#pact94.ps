URL: http://www.cs.pitt.edu/~gupta/research/Comp/pact94.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/scheduling.html
Root-URL: 
Title: Resource Spackling: A Framework for Integrating Register Allocation in Local and Global Schedulers  
Author: David A. Berson, Rajiv Gupta, and Mary Lou Soffa 
Keyword: Keyword Codes: D.1.3; C.1.3 Keywords: Instruction-level parallelism; Speculative code motion; VLIW, Superscalar  
Address: Pittsburgh, Pittsburgh, Pa. 15260  
Affiliation: Computer Science Department, University of  
Abstract: We present Resource Spackling, a framework for integrating register allocation and instruction scheduling that is based on a Measure and Reduce paradigm. The technique measures the resource requirements of a program and uses the measurements to distribute code for better resource allocation. The technique is applicable to the allocation of different types of resources. A program's resource requirements for both register and functional unit resources are first measured using a unified representation. These measurements are used to find areas where resources are either under or over utilized, called resource holes and excessive sets, respectively. Conditions are determined for increasing resource utilization in the resource holes. These conditions are applicable to both local and global code motion. 
Abstract-found: 1
Intro-found: 1
Reference: [AiN88] <author> A. Aiken and A. Nicolau, </author> <title> A Development Environment for Horizontal Microcode, </title> <journal> IEEE Trans. on Software Engineering 14 , 5(May 1988) pp. </journal> <pages> 584-594. </pages>
Reference-contexts: The approach we present unifies the allocation of registers and functional units in a single phase and is able to consider the impact of an allocation decision on other instructions. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> Our framework allows all idle resources in a basic block to be identified, regardless of when they are idle, and exploited when instructions are available. The framework can be used in conjunction with commonly used methods for performing code motion, such as Trace Scheduling [Fis81], Percolation Scheduling <ref> [AiN88] </ref>, and Region Scheduling [GuS90]. The Resource Spackling framework computes resource requirements for a program. A unified representation of functional unit and register uses is constructed to identify all resource uses that can temporally share the same instance of a resource. <p> Fill instructions may be found in blocks with the same control dependences and in blocks with different control conditions when the architecture supports speculative execution [SHL92] or guarded execution [HsD86], or when code duplication is performed. Next we describe how existing global code motion techniques <ref> [AiN88, Fis81, GuS90] </ref> can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [BeR91] <author> D. Bernstein and M. Rodeh, </author> <title> Global Instruction Scheduling for Superscalar Machines, </title> <booktitle> Proc. Sigplan '91 Conf. on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> June 26-28, </month> <year> 1991, </year> <pages> pp. 241-255. </pages>
Reference-contexts: The approach we present unifies the allocation of registers and functional units in a single phase and is able to consider the impact of an allocation decision on other instructions. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93].
Reference: [BGS93] <author> D. A. Berson, R. Gupta and M. L. Soffa, </author> <title> URSA: A Unified ReSource Allocator for Registers and Functional Units in VLIW Architectures, </title> <booktitle> Proc. IFIP WG 10.3 Working Conference on Architectures and Compliation Techniques for Fine and Medium Grain Parallelism, </booktitle> <address> Orlando, Florida, </address> <month> Jan. </month> <year> 1993, </year> <pages> pp. 243-254. </pages> <note> (also available as University of Pittsburgh Computer Science Department Technical Report 92-21). </note>
Reference-contexts: The technique is called Resource Spackling due to the process of identifying and filling resource holes. 2 Determining Resource Requirements using Allocation Chains This section summarizes the measurement of resource requirements used to locate excessive sets and resource holes <ref> [BGS93] </ref>. Measurement of resource demands depends on the usage characteristics of the resource. The two major types of resources considered in this work, functional units and registers, have different use properties.
Reference: [BGS94] <author> D. A. Berson, R. Gupta and M. L. Soffa, </author> <title> Representing Architecture Con--straints in URSA, </title> <type> Technical Report 94-10, </type> <institution> University of Pittsburgh, Computer Science Department, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Pipelines, resource demands that can be satisfied by several types of resources, and implicit resource demands also can be modeled in Resource Spackling <ref> [BGS94] </ref>.
Reference: [BEH91] <author> D. G. Bradlee, S. J. Eggers and R. R. Henry, </author> <title> Integrating Register Allocation and Instruction Scheduling for RISCs, </title> <booktitle> Proc. Fourth International Conf. on ASPLOS, </booktitle> <address> Santa Clara, CA, </address> <month> April 8-11, </month> <year> 1991, </year> <pages> pp. 122-131. </pages>
Reference-contexts: Integrated allocation of registers and functional units is achieved by allowing simultaneous consideration of the demand for both types of resources during scheduling. Previous work on local schedulers has treated register allocation and instruction scheduling as separate phases <ref> [BEH91, GoH88, Pin93, SwB90] </ref>. In addition, the instruction scheduling phases have been based on list scheduling.
Reference: [Dil50] <author> R. P. </author> <title> Dilworth, A Decomposition Theorem for Partially Ordered Sets, </title> <booktitle> Annuals of Mathematics 51 (1950) pp. </booktitle> <pages> 161-166. </pages>
Reference-contexts: Similarly, the Reuse Reg DAG can be minimally decomposed into the chains fA, B, Lg, fC, F, G, H, I, Kg, fDg, and fE, Jg. The maximum number of independent elements in a partial order is equal to the number of chains in a minimal decomposition <ref> [Dil50] </ref>. Since the partial order is constructed from resource reuse information, the number of chains in a minimal decomposition represents the maximum number of instructions that can execute concurrently and simultaneously live values for Reuse F U DAGs and Reuse Reg DAGs respectively.
Reference: [EbN89] <author> K. Ebcioglu and A. Nicolau, </author> <title> A global Resource-Constrained Parallelization Technique, </title> <booktitle> Proc. ACM SIGARCH ICS-89: International Conf. on Supercomputing, </booktitle> <address> Crete, Greece, </address> <month> June 2-9, </month> <year> 1989. </year>
Reference-contexts: Work on global scheduling has identified blocks to which an instruction can be moved [AiN88, BeR91, Fis81, GuS90, SHL92] by concentrating on functional unit constraints <ref> [EbN89, MGS92] </ref> in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93].
Reference: [Fis81] <author> J. A. Fisher, </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction, </title> <journal> IEEE Trans. on Computers C-30 , 7(July 1981) pp. </journal> <pages> 478-490. </pages>
Reference-contexts: The approach we present unifies the allocation of registers and functional units in a single phase and is able to consider the impact of an allocation decision on other instructions. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> Our framework allows all idle resources in a basic block to be identified, regardless of when they are idle, and exploited when instructions are available. The framework can be used in conjunction with commonly used methods for performing code motion, such as Trace Scheduling <ref> [Fis81] </ref>, Percolation Scheduling [AiN88], and Region Scheduling [GuS90]. The Resource Spackling framework computes resource requirements for a program. A unified representation of functional unit and register uses is constructed to identify all resource uses that can temporally share the same instance of a resource. <p> Fill instructions may be found in blocks with the same control dependences and in blocks with different control conditions when the architecture supports speculative execution [SHL92] or guarded execution [HsD86], or when code duplication is performed. Next we describe how existing global code motion techniques <ref> [AiN88, Fis81, GuS90] </ref> can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [FoF65] <author> L. R. Ford and D. R. Fulkerson, </author> <title> Flows in Networks, </title> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1965. </year>
Reference-contexts: Thus, the block in Figure 1 (a) requires three functional units and four registers to exploit all of its parallelism. A minimum decomposition of a partial order can be found by using a straightforward transformation to a bipartite graph matching problem <ref> [FoF65] </ref>. 3 Resource Holes Resource holes and their properties are located by analyzing the allocation chains for the resource of interest. Given a hole h, the size of h, size h , is the number of cycles for which the hole's resource is available for allocation.
Reference: [GoH88] <author> J. R. Goodman and W. Hsu, </author> <title> Code Scheduling and Register Allocation in Large Basic Blocks, </title> <booktitle> Proc. of the ACM Supercomputing Conference, </booktitle> <year> 1988, </year> <pages> pp. 442-452. </pages>
Reference-contexts: Integrated allocation of registers and functional units is achieved by allowing simultaneous consideration of the demand for both types of resources during scheduling. Previous work on local schedulers has treated register allocation and instruction scheduling as separate phases <ref> [BEH91, GoH88, Pin93, SwB90] </ref>. In addition, the instruction scheduling phases have been based on list scheduling.
Reference: [GuS90] <author> R. Gupta and M. L. Soffa, </author> <title> Region Scheduling: An Approach for Detecting and Redistributing Parallelism, </title> <journal> IEEE Trans. on Software Engineering 16 , 4(April 1990) pp. </journal> <pages> 421-431. </pages>
Reference-contexts: The approach we present unifies the allocation of registers and functional units in a single phase and is able to consider the impact of an allocation decision on other instructions. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> The framework can be used in conjunction with commonly used methods for performing code motion, such as Trace Scheduling [Fis81], Percolation Scheduling [AiN88], and Region Scheduling <ref> [GuS90] </ref>. The Resource Spackling framework computes resource requirements for a program. A unified representation of functional unit and register uses is constructed to identify all resource uses that can temporally share the same instance of a resource. <p> Fill instructions may be found in blocks with the same control dependences and in blocks with different control conditions when the architecture supports speculative execution [SHL92] or guarded execution [HsD86], or when code duplication is performed. Next we describe how existing global code motion techniques <ref> [AiN88, Fis81, GuS90] </ref> can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [HsD86] <author> P. Y. T. Hsu and E. S. Davidson, </author> <title> Highly Concurrent Scalar Processing, </title> <booktitle> Proc. 13th Annual International Symp. on Computer Architecture, </booktitle> <month> June </month> <year> 1986, </year> <pages> pp. 386-395. </pages>
Reference-contexts: The instructions moved are called fill instructions since they are inserted in holes in the destination block. Fill instructions may be found in blocks with the same control dependences and in blocks with different control conditions when the architecture supports speculative execution [SHL92] or guarded execution <ref> [HsD86] </ref>, or when code duplication is performed. Next we describe how existing global code motion techniques [AiN88, Fis81, GuS90] can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [MGS92] <author> B. Malloy, R. Gupta and M. L. Soffa, </author> <title> A Shape Matching Approach for Scheduling Fine-Grained Parallelism, </title> <booktitle> Proc. 25th Annual International Symp. on Mi-croarchitecture, </booktitle> <address> Portland, Oregon, </address> <month> Dec 1-4, </month> <year> 1992, </year> <pages> pp. 264-267. </pages>
Reference-contexts: Work on global scheduling has identified blocks to which an instruction can be moved [AiN88, BeR91, Fis81, GuS90, SHL92] by concentrating on functional unit constraints <ref> [EbN89, MGS92] </ref> in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93].
Reference: [MoE92] <author> S. Moon and K. Ebcioglu, </author> <title> An Efficient Resource-Constrained Global Scheduling Technique for Superscalar and VLIW Processors, </title> <note> Computer Science Research Report RC 17962 (#78691), </note> <institution> IBM Thomas J. Watson Research Center, </institution> <address> Yorktown Heights, NY, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Only recently has work on global scheduling begun to consider register allocation as a part of the problem <ref> [MoE92, NiG93] </ref>. Although Moon and Ebcioglu [MoE92] added register constraints, they are only able to exploit unused registers at the beginning or end of a basic block. <p> Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. Although Moon and Ebcioglu <ref> [MoE92] </ref> added register constraints, they are only able to exploit unused registers at the beginning or end of a basic block. Our framework allows all idle resources in a basic block to be identified, regardless of when they are idle, and exploited when instructions are available.
Reference: [NiG93] <author> Q. Ning and G. R. Gao, </author> <title> A Novel Framework of Register Allocation for Software Pipelining, </title> <booktitle> Conf. Rec. 20th ACM Symp. on Prin. of Programming Languages, </booktitle> <month> Jan. </month> <year> 1993, </year> <pages> pp. 29-42. </pages>
Reference-contexts: Only recently has work on global scheduling begun to consider register allocation as a part of the problem <ref> [MoE92, NiG93] </ref>. Although Moon and Ebcioglu [MoE92] added register constraints, they are only able to exploit unused registers at the beginning or end of a basic block.
Reference: [Pin93] <author> S. S. Pinter, </author> <title> Register Allocation with Instruction Scheduling: A New Approach, </title> <booktitle> Proc. Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, NM., </address> <month> June 23-25, </month> <year> 1993, </year> <pages> pp. 248-257. </pages>
Reference-contexts: Integrated allocation of registers and functional units is achieved by allowing simultaneous consideration of the demand for both types of resources during scheduling. Previous work on local schedulers has treated register allocation and instruction scheduling as separate phases <ref> [BEH91, GoH88, Pin93, SwB90] </ref>. In addition, the instruction scheduling phases have been based on list scheduling. <p> Recent work has incorporated parallel live range information into register allocation, but still separates register allocation from instruction scheduling <ref> [Pin93] </ref>. The approach we present unifies the allocation of registers and functional units in a single phase and is able to consider the impact of an allocation decision on other instructions.
Reference: [SHL92] <author> M. D. Smith, M. Horowitz and M. Lam, </author> <title> Efficient Superscalar Performance Through Boosting, </title> <booktitle> Proc. 5th International Conf. on ASPLOS, </booktitle> <address> Boston, Mas-sachusetts, </address> <month> Oct. </month> <pages> 12-15, </pages> <year> 1992, </year> <pages> pp. 248-259. </pages>
Reference-contexts: The approach we present unifies the allocation of registers and functional units in a single phase and is able to consider the impact of an allocation decision on other instructions. Work on global scheduling has identified blocks to which an instruction can be moved <ref> [AiN88, BeR91, Fis81, GuS90, SHL92] </ref> by concentrating on functional unit constraints [EbN89, MGS92] in carrying out the code motion. Only recently has work on global scheduling begun to consider register allocation as a part of the problem [MoE92, NiG93]. <p> The instructions moved are called fill instructions since they are inserted in holes in the destination block. Fill instructions may be found in blocks with the same control dependences and in blocks with different control conditions when the architecture supports speculative execution <ref> [SHL92] </ref> or guarded execution [HsD86], or when code duplication is performed. Next we describe how existing global code motion techniques [AiN88, Fis81, GuS90] can use the framework to unify functional unit and register allocation, and determine which code motions are beneficial.
Reference: [SwB90] <author> P. Sweany and S. Beaty, </author> <title> Post-Compaction Register Assignment in a Retar-getable Compiler, </title> <booktitle> Proc. of the 23rd Annual Workshop on Microprogramming and Microarchitecture, </booktitle> <month> Nov. </month> <year> 1990, </year> <pages> pp. 107-116. </pages>
Reference-contexts: Integrated allocation of registers and functional units is achieved by allowing simultaneous consideration of the demand for both types of resources during scheduling. Previous work on local schedulers has treated register allocation and instruction scheduling as separate phases <ref> [BEH91, GoH88, Pin93, SwB90] </ref>. In addition, the instruction scheduling phases have been based on list scheduling.
References-found: 18

