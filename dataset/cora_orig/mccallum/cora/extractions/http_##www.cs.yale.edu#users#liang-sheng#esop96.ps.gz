URL: http://www.cs.yale.edu/users/liang-sheng/esop96.ps.gz
Refering-URL: http://www.cs.yale.edu/users/liang-sheng.html
Root-URL: http://www.cs.yale.edu
Email: fliang-sheng, hudakg@cs.yale.edu  
Title: Modular Denotational Semantics for Compiler Construction  
Author: Sheng Liang Paul Hudak 
Address: New Haven, CT 06520-8285  
Affiliation: Yale University, Department of Computer Science  
Date: April, 1996.  
Note: To be presented at European Symposium on Programming,  
Abstract: We show the benefits of applying modular monadic semantics to compiler construction. Modular monadic semantics allows us to define a language with a rich set of features from reusable building blocks, and use program transformation and equational reasoning to improve code. Compared to denotational semantics, reasoning in monadic style offers the added benefits of highly modularized proofs and more widely applicable results. To demonstrate, we present an axiomatization of environments, and use it to prove the correctness of a well-known compilation technique. The monadic approach also facilitates generating code in various target languages with different sets of built-in features.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 193-302, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Our goals are similar to that of Action Semantics [21] and related efforts by, for example, Wand [27], Lee [16], Appel & Jim <ref> [1] </ref>, and Kelsey & Hudak [14]. None of the existing approaches are completely satisfactory in achieving the above goals. <p> Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features. Several researchers, including Kelsey and Hudak [14], Appel and Jim <ref> [1] </ref>, and others, have built efficient compilers for higher-order languages by transforming the source language into continuation-passing style (CPS). The suitability of a monadic form as an intermediate form has been observed by many researchers (including, for example, Sabry and Felleisen [22] and Hatcliff and Danvy [8]).
Reference: 2. <author> Anders Bondorf and Jens Palsberg. </author> <title> Compiling actions by partial evaluation. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 308-317, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: An interesting area of future research is to combine the nice algebraic properties in Meijer's framework with the modularity offered in ours. One application of partial evaluation [12] is to automatically generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter <ref> [2] </ref>, and similar results can be achieved with monadic interpreters [6]. Staging transformations, first proposed by Jrring and Scherlis [13], are a class of general program transformation techniques for separating a given computation into stages.
Reference: 3. <author> Deryck F. Brown, Hermano Moura, and David A. Watt. ACTRESS: </author> <title> An action semantics directed compiler generator. </title> <booktitle> In Proceedings of the 4th International Conference on Compiler Construction, </booktitle> <address> Edinburgh, U.K., </address> <pages> pages 95-109. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> Lecture Notes in Computer Science 641. </note>
Reference-contexts: Mosses's Action Semantics [21] allows modular specification of programming language semantics, from which efficient compilers can be generated. Action semantics (e.g., <ref> [3] </ref>) and a related approach by Lee [16] have been successfully used to generate efficient compilers.
Reference: 4. <author> Pietro Cenciarelli and Eugenio Moggi. </author> <title> A syntactic approach to modularity in deno-tational semantics. </title> <booktitle> In Category Theory and Computer Science '93, </booktitle> <year> 1993. </year>
Reference-contexts: Overall, we believe that modular monadic semantics is particularly suitable for compiler construction. Acknowledgement We would like to thank Rajiv Mirani and the ESOP'96 anonymous referees for useful suggestions, Zhong Shao, Satish Pai, Dan Rabin and the PEPM'95 4 More recently, Cenciarelli andMoggi <ref> [4] </ref> proposed a syntactic approach to modularity in denotational semantics. 14 anonymous referees for helpful comments on an earlier version of the paper, and Ross Paterson, Tim Sheard and John Launchbury for ideas and discussions.
Reference: 5. <author> D. Cl ement, Jo elle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 13-27, </pages> <year> 1986. </year>
Reference-contexts: We follow Wand [28], define a natural semantics which translates source language variables to lexical variables in the meta-language, and prove that it is equivalent to the standard semantics. 4.1 A Natural Semantics We adopt Wand's definition of a natural semantics (different from Kahn's <ref> [5] </ref> notion) to our functional sub-language. For any source language variable name v, we assume there is a corresponding variable name v m in the meta-language. Definition 4.
Reference: 6. <author> Olivier Danvy, J urgen Koslowski, and Karoline Malmkjr. </author> <title> Compiling monads. </title> <type> Technical Report CIS-92-3, </type> <institution> Kansas State University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: One application of partial evaluation [12] is to automatically generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter [2], and similar results can be achieved with monadic interpreters <ref> [6] </ref>. Staging transformations, first proposed by Jrring and Scherlis [13], are a class of general program transformation techniques for separating a given computation into stages. Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features.
Reference: 7. <author> David Espinosa. </author> <title> Modular denotational semantics. </title> <type> Unpublished manuscript, </type> <month> De-cember </month> <year> 1993. </year>
Reference-contexts: The above process seems trivial, but would have been impossible had we been working with traditional denotational semantics. Various features clutter up and make it hard to determine whether it is safe to remove certain interpretation overhead, and how to achieve that. Earlier work [15] <ref> [7] </ref> [17] has shown that the order of monad transformers (in particular, some cases involving ContT) has an impact on the resulting semantics. <p> This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel [11], and Espinosa <ref> [7] </ref>. Moggi [19] raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws. Hudak [9] suggested a more general framework mutable abstract data types (MADTs) to reason about states.
Reference: 8. <author> John Hatcliff and Olivier Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In 21st ACM Symposium on Principles of Programming Languages (POPL '94), Portland, Oregon, </booktitle> <pages> pages 458-471, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: The suitability of a monadic form as an intermediate form has been observed by many researchers (including, for example, Sabry and Felleisen [22] and Hatcliff and Danvy <ref> [8] </ref>). We will continue to explore along this direction in order to generate machine-level code from a monadic intermediate form. 7 Conclusions We have shown that the monadic framework provides good support for high-level extensible specifications, program transformations, reasoning about computations, and code generation in various target languages.
Reference: 9. <author> Paul Hudak. </author> <title> Mutable abstract datatypes. </title> <institution> Research Report YALEU/DCS/RR-914, Yale University Department of Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Moggi [19] raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws. Hudak <ref> [9] </ref> suggested a more general framework mutable abstract data types (MADTs) to reason about states. Meijer [18] combined the standard initial algebra semantics approach with aspects of Action Semantics to derive compilers from denotational semantics.
Reference: 10. <editor> Paul Hudak, Simon Peyton Jones, and Philip Wadler. </editor> <title> Report on the programming language Haskell: a non-strict, purely functional language, version 1.2. </title> <type> Technical Report YALEU/DCS/RR-777, </type> <institution> Yale University Department of Computer Science, </institution> <month> March </month> <year> 1992. </year> <journal> Also in ACM SIGPLAN Notices, </journal> <volume> Vol. 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: We present our results in the traditional denotational semantics style [24], augmented with a Haskell-like <ref> [10] </ref> type declaration syntax to express monads as type constructors. We use the denotation semantics notation because it is more succinct than a real programming language such as Haskell.
Reference: 11. <author> Mark P. Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <institution> Research Report YALEU/DCS/RR-1004, Yale University Department of Computer Science, </institution> <address> New Haven, Connecticut, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel <ref> [11] </ref>, and Espinosa [7]. Moggi [19] raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws. Hudak [9] suggested a more general framework mutable abstract data types (MADTs) to reason about states.
Reference: 12. <author> Neil D. Jones, Peter Sestoft, and Harald Sndergaard. </author> <title> Mix: a self-applicable partial evaluator for experiments in compiler generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: Meijer [18] combined the standard initial algebra semantics approach with aspects of Action Semantics to derive compilers from denotational semantics. An interesting area of future research is to combine the nice algebraic properties in Meijer's framework with the modularity offered in ours. One application of partial evaluation <ref> [12] </ref> is to automatically generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter [2], and similar results can be achieved with monadic interpreters [6].
Reference: 13. <author> Ulrik Jrring and William Scherlis. </author> <title> Compilers and staging transformations. </title> <booktitle> In Proceedings Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, Florida, </address> <pages> pages 86-96, </pages> <year> 1986. </year>
Reference-contexts: One application of partial evaluation [12] is to automatically generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter [2], and similar results can be achieved with monadic interpreters [6]. Staging transformations, first proposed by Jrring and Scherlis <ref> [13] </ref>, are a class of general program transformation techniques for separating a given computation into stages. Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features.
Reference: 14. <author> Richard Kelsey and Paul Hudak. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 181-192, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Our goals are similar to that of Action Semantics [21] and related efforts by, for example, Wand [27], Lee [16], Appel & Jim [1], and Kelsey & Hudak <ref> [14] </ref>. None of the existing approaches are completely satisfactory in achieving the above goals. For example, it has long been recognized that traditional deno-tational semantics [24] is not suitable for compiler generation for a number of crucial reasons [16], among which is the lack of modularity and extensibility. <p> Staging transformations, first proposed by Jrring and Scherlis [13], are a class of general program transformation techniques for separating a given computation into stages. Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features. Several researchers, including Kelsey and Hudak <ref> [14] </ref>, Appel and Jim [1], and others, have built efficient compilers for higher-order languages by transforming the source language into continuation-passing style (CPS).
Reference: 15. <author> David J. King and Philip Wadler. </author> <title> Combining monads. </title> <editor> In John Launchbury and Patrick Sansom, editors, </editor> <booktitle> Functional Programming, Glasgow 1992, </booktitle> <pages> pages 134-143, </pages> <address> New York, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The above process seems trivial, but would have been impossible had we been working with traditional denotational semantics. Various features clutter up and make it hard to determine whether it is safe to remove certain interpretation overhead, and how to achieve that. Earlier work <ref> [15] </ref> [7] [17] has shown that the order of monad transformers (in particular, some cases involving ContT) has an impact on the resulting semantics.
Reference: 16. <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year> <month> 15 </month>
Reference-contexts: Our goals are similar to that of Action Semantics [21] and related efforts by, for example, Wand [27], Lee <ref> [16] </ref>, Appel & Jim [1], and Kelsey & Hudak [14]. None of the existing approaches are completely satisfactory in achieving the above goals. For example, it has long been recognized that traditional deno-tational semantics [24] is not suitable for compiler generation for a number of crucial reasons [16], among which is <p> Wand [27], Lee <ref> [16] </ref>, Appel & Jim [1], and Kelsey & Hudak [14]. None of the existing approaches are completely satisfactory in achieving the above goals. For example, it has long been recognized that traditional deno-tational semantics [24] is not suitable for compiler generation for a number of crucial reasons [16], among which is the lack of modularity and extensibility. We take advantage of a new development in programming language theory, a monadic approach [19] to structured denotational semantics, that achieves a high level of modularity and extensibility. <p> Mosses's Action Semantics [21] allows modular specification of programming language semantics, from which efficient compilers can be generated. Action semantics (e.g., [3]) and a related approach by Lee <ref> [16] </ref> have been successfully used to generate efficient compilers.
Reference: 17. <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In 22nd ACM Symposium on Principles of Programming Languages (POPL '95), </booktitle> <address> San Francisco, California, New York, </address> <month> January </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: In our framework, depending on how much support the upper layers need, any set of primitive operations can be put together in a modular way using an abstraction mechanism called monad transformers [19] <ref> [17] </ref>. Monad transformers provide the power needed to represent the abstract notion of programming language features, but still allow us to access low-level semantic details. <p> We use the denotation semantics notation because it is more succinct than a real programming language such as Haskell. No prior knowledge of monads is assumed. 2 A Modular Monadic Semantics In this section we use some of the results from our earlier work on modular interpreters <ref> [17] </ref> to define a modular semantics for our source language. 2.1 A High-level Monadic Semantics Traditional denotational semantics maps, say, a term, an environment and a continuation to an answer. In contrast, monadic semantics maps terms to computations, where the details of the environment, store, etc. are hidden. <p> Liftings One issue remains to be addressed. The update function introduced by StateT does not work on Compute, which contains features added later by other monad transformers. In general, this is the problem of lifting operations through monad transformers. Figure 3 gives a brief summary of useful liftings (See <ref> [17] </ref> for a detailed description.) For example, in the Compute monad above, update f is: s:Ok (f s; s) when first introduced by StateT. After Compute is finally constructed, update f becomes: :k:s:k s (f s). <p> Thus the theorem as stated does not strictly correspond to Wand's result [28]. Fortunately, the naturality of liftings (see our earlier work <ref> [17] </ref> for details) guarantees that adding and removing a feature does not affect computations which do not use that particular feature. <p> The monadic code can choose to use the ML built-in ones instead of those implemented as higher-order functions. In addition, all liftings we construct satisfy an important property (called the Naturality of Liftings [19] 12 <ref> [17] </ref>): adding or deleting a monad transformer does not change the result of pro-grams which do not use its operations. <p> The above process seems trivial, but would have been impossible had we been working with traditional denotational semantics. Various features clutter up and make it hard to determine whether it is safe to remove certain interpretation overhead, and how to achieve that. Earlier work [15] [7] <ref> [17] </ref> has shown that the order of monad transformers (in particular, some cases involving ContT) has an impact on the resulting semantics. <p> Moggi [19] first used monads and monad transformers to structure denota-tional semantics. 4 Wadler [26] [25] popularized Moggi's ideas in the functional programming community by using monads in functional programs, in particular, interpreters. This paper is built upon our work on monad-based modular interpreters <ref> [17] </ref>, which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel [11], and Espinosa [7]. Moggi [19] raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws.
Reference: 18. <author> Erik Meijer. </author> <title> More advice on proving a compiler correct: Improving a correct compiler. </title> <note> Submitted to Journal of Functional Programming. </note>
Reference-contexts: Moggi [19] raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws. Hudak [9] suggested a more general framework mutable abstract data types (MADTs) to reason about states. Meijer <ref> [18] </ref> combined the standard initial algebra semantics approach with aspects of Action Semantics to derive compilers from denotational semantics. An interesting area of future research is to combine the nice algebraic properties in Meijer's framework with the modularity offered in ours.
Reference: 19. <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: For example, it has long been recognized that traditional deno-tational semantics [24] is not suitable for compiler generation for a number of crucial reasons [16], among which is the lack of modularity and extensibility. We take advantage of a new development in programming language theory, a monadic approach <ref> [19] </ref> to structured denotational semantics, that achieves a high level of modularity and extensibility. <p> In our framework, depending on how much support the upper layers need, any set of primitive operations can be put together in a modular way using an abstraction mechanism called monad transformers <ref> [19] </ref> [17]. Monad transformers provide the power needed to represent the abstract notion of programming language features, but still allow us to access low-level semantic details. <p> The monadic code can choose to use the ML built-in ones instead of those implemented as higher-order functions. In addition, all liftings we construct satisfy an important property (called the Naturality of Liftings <ref> [19] </ref> 12 [17]): adding or deleting a monad transformer does not change the result of pro-grams which do not use its operations. <p> Action semantics provided much of the inspiration for our work, which essentially attempts to formulate actions in a denotational semantics framework. 13 Monad transformers roughly correspond to facets in action semantics, although issues such as concurrency are beyond the power of our approach. Moggi <ref> [19] </ref> first used monads and monad transformers to structure denota-tional semantics. 4 Wadler [26] [25] popularized Moggi's ideas in the functional programming community by using monads in functional programs, in particular, interpreters. <p> This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel [11], and Espinosa [7]. Moggi <ref> [19] </ref> raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws. Hudak [9] suggested a more general framework mutable abstract data types (MADTs) to reason about states.
Reference: 20. <author> Peter D. Mosses. </author> <title> A basic abstract semantic algebra. </title> <editor> In Gilles Kahn, David B. Mac-Queen, and Gordon D. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, </booktitle> <pages> pages 87-107. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year> <note> LNCS 173. </note>
Reference-contexts: Axiomatization of Programming Language Features Denotational semantics captures a computation as a piece of syntax tree coupled with an environment, a store etc. On the other hand, we view computations as abstract entities with 11 a set of equations. Therefore, like Semantic Algebras <ref> [20] </ref> in action semantics, monads provide an axiomatic view of denotational semantics.
Reference: 21. <author> Peter D. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Our goals are similar to that of Action Semantics <ref> [21] </ref> and related efforts by, for example, Wand [27], Lee [16], Appel & Jim [1], and Kelsey & Hudak [14]. None of the existing approaches are completely satisfactory in achieving the above goals. <p> In practice, we need to make sure when we discard monad transformers, that the resulting change of ordering does not have unwanted effects on semantics. 6 Related work Early efforts (e.g., [27]) in semantics-directed compiler generation were based on traditional denotational semantics. Mosses's Action Semantics <ref> [21] </ref> allows modular specification of programming language semantics, from which efficient compilers can be generated. Action semantics (e.g., [3]) and a related approach by Lee [16] have been successfully used to generate efficient compilers.
Reference: 22. <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proceedings of the 1992 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 288-298. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: The suitability of a monadic form as an intermediate form has been observed by many researchers (including, for example, Sabry and Felleisen <ref> [22] </ref> and Hatcliff and Danvy [8]).
Reference: 23. <author> Guy L. Steele Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 472-492, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele <ref> [23] </ref>, Jones and Duponcheel [11], and Espinosa [7]. Moggi [19] raised the issue of reasoning in the monadic framework. Wadler [26] listed the state monad laws. Hudak [9] suggested a more general framework mutable abstract data types (MADTs) to reason about states.
Reference: 24. <author> Joseph Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: None of the existing approaches are completely satisfactory in achieving the above goals. For example, it has long been recognized that traditional deno-tational semantics <ref> [24] </ref> is not suitable for compiler generation for a number of crucial reasons [16], among which is the lack of modularity and extensibility. <p> We present our results in the traditional denotational semantics style <ref> [24] </ref>, augmented with a Haskell-like [10] type declaration syntax to express monads as type constructors. We use the denotation semantics notation because it is more succinct than a real programming language such as Haskell.
Reference: 25. <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albu-querque, New Mexico, </address> <pages> pages 1-14, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Id) k = s 0 :c s 0 then Id (s 1 ; a):k a s 1 = s 0 :let (s 1 ; a) = m s 0 in k a s 1 Note that StateT s Id is the standard state monad found, for example, in Wadler's work <ref> [25] </ref>. <p> A monad M is a type constructor, together with two operations: then : M a ! (a ! M b) ! M b return : a ! M a satisfying the following laws <ref> [25] </ref>: (return a) then k = k a (left unit) c then return = c (right unit) c 1 then v 1 :(c 2 then v 2 :c 3 ) = (c 1 then v 1 :c 2 ) then v 2 :c 3 (associativity) Intuitively, the (left and right) unit <p> Moggi [19] first used monads and monad transformers to structure denota-tional semantics. 4 Wadler [26] <ref> [25] </ref> popularized Moggi's ideas in the functional programming community by using monads in functional programs, in particular, interpreters. This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel [11], and Espinosa [7].
Reference: 26. <author> Philip L. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: We can read the store by passing update the identity function, and change the store by passing it a state transformer. Although update returns the entire state, properly defined store-manipulating functions can guarantee that the store is never duplicated (see, for example, <ref> [26] </ref>). <p> Moggi [19] first used monads and monad transformers to structure denota-tional semantics. 4 Wadler <ref> [26] </ref> [25] popularized Moggi's ideas in the functional programming community by using monads in functional programs, in particular, interpreters. This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel [11], and Espinosa [7]. <p> This paper is built upon our work on monad-based modular interpreters [17], which in turn follows a series of earlier attempts by Steele [23], Jones and Duponcheel [11], and Espinosa [7]. Moggi [19] raised the issue of reasoning in the monadic framework. Wadler <ref> [26] </ref> listed the state monad laws. Hudak [9] suggested a more general framework mutable abstract data types (MADTs) to reason about states. Meijer [18] combined the standard initial algebra semantics approach with aspects of Action Semantics to derive compilers from denotational semantics.
Reference: 27. <author> Mitchell Wand. </author> <title> A semantic prototyping system. </title> <booktitle> SIGPLAN Notices, ACM Symposium on Compiler Construction, </booktitle> <volume> 19(6) </volume> <pages> 213-221, </pages> <year> 1984. </year>
Reference-contexts: Our goals are similar to that of Action Semantics [21] and related efforts by, for example, Wand <ref> [27] </ref>, Lee [16], Appel & Jim [1], and Kelsey & Hudak [14]. None of the existing approaches are completely satisfactory in achieving the above goals. <p> In practice, we need to make sure when we discard monad transformers, that the resulting change of ordering does not have unwanted effects on semantics. 6 Related work Early efforts (e.g., <ref> [27] </ref>) in semantics-directed compiler generation were based on traditional denotational semantics. Mosses's Action Semantics [21] allows modular specification of programming language semantics, from which efficient compilers can be generated. Action semantics (e.g., [3]) and a related approach by Lee [16] have been successfully used to generate efficient compilers.

References-found: 27

