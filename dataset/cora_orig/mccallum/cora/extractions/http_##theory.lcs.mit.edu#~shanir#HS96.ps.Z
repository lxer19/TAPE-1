URL: http://theory.lcs.mit.edu/~shanir/HS96.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~shanir/
Root-URL: 
Title: The Topological Structure of Asynchronous Computability  
Author: Maurice Herlihy Nir Shavit 
Note: Supported by NSF grant DMS-9505949. Supported by NSF grant CCR-9520298.  
Date: January 27, 1996  
Address: Providence RI 02912  Tel-Aviv 69978, Israel  
Affiliation: Computer Science Department Brown University  Computer Science Department Tel-Aviv University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit. </author> <title> Atomic snapshots. </title> <booktitle> Ninth ACM Symposium On Principles Of Distributed Computing, </booktitle> <year> 1990. </year>
Reference-contexts: From these variables, in turn, one can implement an atomic snapshot memory: an array where each P i updates array element i, and any process can instantaneously scan (atomically read) the entire array (see <ref> [1, 3] </ref> for details.). <p> For brevity, we express protocols using pseudo-code, although it is straightforward to translate this notation into automaton definitions. Also, as noted above, our protocols use an atomic snapshot memory <ref> [1, 3] </ref>, which can be implemented from the atomic read/write memory described here. 2.3 Solvability We are interested in solvability of tasks by processes that are computa-tionally equivalent to Turing machines [34] and communicate via atomic read/write memory.
Reference: [2] <author> Y. Afek and G. Stupp. </author> <title> Synchronization power depends on the register size (preliminary version). </title> <booktitle> In IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1993. </year>
Reference-contexts: It is also a building block in other characterizations such as Afek and Stupp's characterization of the effect of register size on the power of multiprocessor synchronization operations <ref> [2] </ref>. Informally speaking, impossibility is demonstrated as follows. Our theorem implies that there exists a map from the protocol complex to the task complex that preserves certain topological properties. <p> We note that our main theorem and its implications carry through also for tasks that do not meet this requirement as the read/write shared memory model we build on is extensible by definition. However, extensibility is crucial for results such as <ref> [2, 12, 26, 29] </ref> that use this framework to derive lower bounds in more powerful computational models. The class of tasks our model describes includes all linearizable one-time objects, that is linearizable objects [32] that permit at most one operation per process.
Reference: [3] <author> J. Anderson. </author> <title> Composite registers. </title> <booktitle> In Proceedings Of The 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 15-30, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: From these variables, in turn, one can implement an atomic snapshot memory: an array where each P i updates array element i, and any process can instantaneously scan (atomically read) the entire array (see <ref> [1, 3] </ref> for details.). <p> For brevity, we express protocols using pseudo-code, although it is straightforward to translate this notation into automaton definitions. Also, as noted above, our protocols use an atomic snapshot memory <ref> [1, 3] </ref>, which can be implemented from the atomic read/write memory described here. 2.3 Solvability We are interested in solvability of tasks by processes that are computa-tionally equivalent to Turing machines [34] and communicate via atomic read/write memory.
Reference: [4] <author> H. Attiya, N. Lynch, and N. Shavit. </author> <booktitle> Are wait-free algorithms fast? In Proceedings Of The 31st Annual Symposium On The Foundations of Computer Science, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: The basic intuition is that solving a decision task is really a form of approximate agreement <ref> [4, 18] </ref>, in which processes start out preferring ver-texes "far apart" on the output complex, but after a process of negotiation eventually converge to the vertexes of a single output simplex. <p> Our topological approach can give insight into complexity as well as computability. The unwritten thesis underlying our main computability theorem is that solvable decision problems are those for which one can run an "approximate agreement" algorithm (in the style of <ref> [4] </ref>) on the underlying subdivided simplicial complex to converge to a single decision simplex. In the example shown in Figure 14, one level of subdivision suffices to allow a simplicial map from input to output. <p> In the corresponding algorithm, one process had to perform two reads to allow convergence to a final output. The example suggests that there is an inherent relation between the level of subdivision necessary to allow a simplicial map, and the complexity of the matching "approximate agreement" style algorithm (e.g. <ref> [4, 18] </ref>) defined by it. We believe the topological approach has a great deal of promise for the theory of distributed and concurrent computation, and that it merits further investigation.
Reference: [5] <author> H. Attiya and S. Rajsbaum. </author> <title> A combinatorial topology framework for wait-free computability. </title> <type> Preprint, </type> <year> 1995. </year>
Reference-contexts: Attiya and Rajsbaum cast our topological model in a related "combinatorial" representation <ref> [5] </ref>. Borowsky and Gafni [9, 11] have based a key part of the proof of their simulation method our proof and construction of spans.
Reference: [6] <author> Hagit Attiya, Amotz Bar-Noy, Danny Dolev, David Peleg, and Rudiger Reischuk. </author> <title> Renaming in an asynchronous environment. </title> <journal> Journal of the ACM, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: Our main theorem gives necessary and sufficient conditions for such a map to exist. Although our characterization is quite general, it has concrete applications. In particular, it yields the first impossibility results for several longstanding open problems in distributed computing, including the renaming problem of Attiya et. al. <ref> [6] </ref> with a small number of names, and the set agreement problem of Chaudhuri [13]. It is also a building block in other characterizations such as Afek and Stupp's characterization of the effect of register size on the power of multiprocessor synchronization operations [2]. <p> Although the problem subsequently received considerable attention, it proved difficult to extend such graph-theoretic approaches to encompass more than a single failure. Even the problem of fully characterizing specific tasks like renaming <ref> [6] </ref> and set agreement [13] remained unresolved. Chor and Moscovici [16] later provided a graph-theoretic characterization of tasks solvable in a system where the n + 1 processes can solve (n + 1)-process consensus (either deterministically or randomized). <p> Each participating process chooses a unique output name taken from a strictly smaller range 0; : : : ; K. This task was first studied by Attiya et. al <ref> [6] </ref>. We represent an initial (or final) state of a process as a vertex ~v labeled with a process id and a value: hP i ; v i i. The process id labeling ~v is denoted by id (~v), and the value by val (~v). <p> The proof of this theorem is almost identical to the proof of Theorem 4.1, except that it is necessary to check at each step of the span construction that the equivalence-under-recoloring property continues to hold. 7.2 The Renaming Problem In the renaming task of Attiya et al. <ref> [6] </ref>, processes are given unique input names from a large name space, and must choose unique output names taken 46 from a smaller name space. More precisely, we are given a set of N fl &gt; 2n+1 processes. <p> In any execution, however, at most n + 1 of them participate. (Formally, the relation is defined only on simplexes of dimension at most n.) These participating processes are required to choose unique names in the range 0; : : :; K. In the message-passing model, Attiya et al. <ref> [6] </ref> showed that renaming has a wait-free solution for when K 2n + 1, and none when K n + 2. Bar-Noy and Dolev [7] extended their upper bound solution to the shared read-write memory model. The protocols of Attiya et al. and of Bar-Noy and Dolev are both comparison-based.
Reference: [7] <author> A. Bar-Noy and D. Dolev. </author> <title> Shared memory vs. message passing in an asynchronous distributed environment. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 371-382, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: In the message-passing model, Attiya et al. [6] showed that renaming has a wait-free solution for when K 2n + 1, and none when K n + 2. Bar-Noy and Dolev <ref> [7] </ref> extended their upper bound solution to the shared read-write memory model. The protocols of Attiya et al. and of Bar-Noy and Dolev are both comparison-based.
Reference: [8] <author> O. Biran, S. Moran, and S. Zaks. </author> <title> A combinatorial characterization of the distributed tasks which are solvable in the presence of one faulty processor. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 263-275, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: It led to the creation of a highly active research area, the full scope of which is surveyed in recent book by Lynch [36]. A first step toward a systematic characterization of asynchronous computability was taken in 1988, when Biran, Moran, and Zaks <ref> [8] </ref> gave a graph-theoretic characterization of the tasks that could be solved by a message-passing system in the presence of a single failure. Although the problem subsequently received considerable attention, it proved difficult to extend such graph-theoretic approaches to encompass more than a single failure. <p> The first is trivially solved in the presence of an arbitrary number of failures, while the 4 second has no solution in read/write memory even if only one process can fail. Note that the model of Biran, Moran, and Zaks <ref> [8] </ref> does not include a notion of participating processes, although the same effect can be achieved by giving each process an additional "participate" bit as an input. To simplify the presentation, we henceforth restrict our attention to decision tasks where the number of possible input vectors is finite. <p> This simplicial representation gives a geometric interpretation to the notion of "similar" system states. The vertexes on the common boundary of the two simplexes are local process states that cannot distinguish between the two global states. Unlike graph-theoretic models (e.g., <ref> [8] </ref>), simplicial complexes capture in a natural way the notion of the degree of similarity between two states: it is the dimension of the intersection of the two n-simplexes. <p> More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement [29], and to unify a variety of known impossibility results in terms of the algebraic theory of chain maps and chain complexes [26]. 53 The graph theoretic characterization of <ref> [8] </ref> does more than provide im-possibility results, it also provides an effective procedure for deciding if a task has a 1-resilient message passing protocol. It is natural to ask whether a similar decision procedure exists for our topological representation of wait-free read/write protocols.
Reference: [9] <author> E. Borowski. </author> <title> Capturing the power of reseiliency and set consensus in distributed systems. </title> <type> Technical report, </type> <institution> University of California Los Angeles, </institution> <address> Los Angeles, California, </address> <year> 1995. </year>
Reference-contexts: This is exactly the participating set problem of Borowsky and Gafni [11], developed as part of their "immediate snapshot" algorithm. Their elegant wait-free solution appears in Figure 20. Borowsky <ref> [9] </ref> gives a proof of this algorithm. <p> Attiya and Rajsbaum cast our topological model in a related "combinatorial" representation [5]. Borowsky and Gafni <ref> [9, 11] </ref> have based a key part of the proof of their simulation method our proof and construction of spans.
Reference: [10] <author> E. Borowsky and E. Gafni. </author> <title> Generalized flp impossibility result for t-resilient asynchronous computations. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year> <month> 55 </month>
Reference-contexts: Chor and Moscovici [16] later provided a graph-theoretic characterization of tasks solvable in a system where the n + 1 processes can solve (n + 1)-process consensus (either deterministically or randomized). In 1993, three research teams|Borowsky and Gafni <ref> [10] </ref>, Saks and Za-haroglou [39], and the current authors [30], independently derived lower bounds for the k-set agreement problem of Chaudhuri. The proof of Borowsky and Gafni [10] is based on a powerful simulation method that allows N - process protocols to be executed by fewer processes in a resilient way. <p> In 1993, three research teams|Borowsky and Gafni <ref> [10] </ref>, Saks and Za-haroglou [39], and the current authors [30], independently derived lower bounds for the k-set agreement problem of Chaudhuri. The proof of Borowsky and Gafni [10] is based on a powerful simulation method that allows N - process protocols to be executed by fewer processes in a resilient way. Both Saks and Zaharoglou [39] and the current authors [30] apply notions and techniques from mainstream combinatorial topology. <p> The set agreement problem was first proposed by Soma Chaudhuri [13] in 1989, along with a conjecture that it could not be solved in certain asynchronous systems. This problem remained open until 1993, when three independent research teams, Borowsky and Gafni <ref> [10] </ref>, Herlihy and Shavit [30], and Saks and Zaharoglou [39] proved this conjecture correct. 3.3 Fetch-And-Add In the fetch-and-add task [23], a generalization of the Fetch-And-Inc task defined earlier, each of n + 1 processes atomically adds an integer input (from a fixed range) to a shared register, initially zero, and
Reference: [11] <author> E. Borowsky and E. Gafni. </author> <title> Immediate atomic snapshots and fast renam-ing. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: This subdivision is a color-preserving analogue of the classical barycen tric subdivision. * Simplex agreement on (I) is solved by the "participating set" protocol of Borowsky and Gafni <ref> [11] </ref>. Simplex agreement on k (I) is solved by iterating that protocol k times. * If (I) is an arbitrary chromatic subdivision of I, then there exists an integer k such that if K &gt; k, there is a carrier-preserving simplicial map : K (I) ! (I). <p> This is exactly the participating set problem of Borowsky and Gafni <ref> [11] </ref>, developed as part of their "immediate snapshot" algorithm. Their elegant wait-free solution appears in Figure 20. Borowsky [9] gives a proof of this algorithm. <p> Attiya and Rajsbaum cast our topological model in a related "combinatorial" representation [5]. Borowsky and Gafni <ref> [9, 11] </ref> have based a key part of the proof of their simulation method our proof and construction of spans.
Reference: [12] <author> E. Borowsky and E. Gafni. </author> <title> The implications of the borowski-gafni simulation on the set consensus hierarchy. </title> <type> Technical Report TR-930021, </type> <institution> University of California Los Angeles, </institution> <address> Los Angeles, California, </address> <year> 1993. </year>
Reference-contexts: We note that our main theorem and its implications carry through also for tasks that do not meet this requirement as the read/write shared memory model we build on is extensible by definition. However, extensibility is crucial for results such as <ref> [2, 12, 26, 29] </ref> that use this framework to derive lower bounds in more powerful computational models. The class of tasks our model describes includes all linearizable one-time objects, that is linearizable objects [32] that permit at most one operation per process.
Reference: [13] <author> S. Chaudhuri. </author> <title> Agreement is harder than consensus: Set consensus problems in totally asynchronous systems. </title> <booktitle> In Proceedings Of The Ninth Annual ACM Symosium On Principles of Distributed Computing, </booktitle> <pages> pages 311-234, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Although our characterization is quite general, it has concrete applications. In particular, it yields the first impossibility results for several longstanding open problems in distributed computing, including the renaming problem of Attiya et. al. [6] with a small number of names, and the set agreement problem of Chaudhuri <ref> [13] </ref>. It is also a building block in other characterizations such as Afek and Stupp's characterization of the effect of register size on the power of multiprocessor synchronization operations [2]. Informally speaking, impossibility is demonstrated as follows. <p> Although the problem subsequently received considerable attention, it proved difficult to extend such graph-theoretic approaches to encompass more than a single failure. Even the problem of fully characterizing specific tasks like renaming [6] and set agreement <ref> [13] </ref> remained unresolved. Chor and Moscovici [16] later provided a graph-theoretic characterization of tasks solvable in a system where the n + 1 processes can solve (n + 1)-process consensus (either deterministically or randomized). <p> Consensus is the generalization of binary consensus to allow input values from an arbitrary range, not only f0; 1g. 3.2 Set Agreement A natural generalization of consensus is the k-set agreement task <ref> [13] </ref>. k-Set Agreement Like consensus, each process starts with an arbitrary input value, and must choose some process's input. Unlike consensus, which requires that all processes agree, set agreement requires that no more than k distinct output values be chosen. <p> This complex is connected (trivial homology in dimension zero), but has non-trivial homology in dimension one (each sphere is a "hole"). The set agreement problem was first proposed by Soma Chaudhuri <ref> [13] </ref> in 1989, along with a conjecture that it could not be solved in certain asynchronous systems.
Reference: [14] <author> S. Chaudhuri, M.P. Herlihy, N. Lynch, </author> <title> and M.R. Tuttle. A tight lower bound for k-set agreement. </title> <booktitle> In Proceedings of the 34th IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: The analysis of the topological properties of protocol complexes for protocols using more powerful primitives appears in a recent paper by Herlihy and Rajsbaum [29], and first tight topology-based lower bounds on certain tasks in the synchronous fail-stop model were presented by Chaudhuri, Herlihy, Lynch, and Tuttle <ref> [14] </ref>. Attiya and Rajsbaum cast our topological model in a related "combinatorial" representation [5]. Borowsky and Gafni [9, 11] have based a key part of the proof of their simulation method our proof and construction of spans.
Reference: [15] <author> B. Chor, A. Israeli, and M. Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1987. </year>
Reference-contexts: Figure 9 shows the input and output complexes 15 16 for 2-process binary consensus. In general, the input complex is (n 1)- acyclic, while the output complex is disconnected. It is known <ref> [15, 17, 27, 35] </ref>, that (n + 1)-process binary consensus has no wait-free protocol in read/write memory. <p> Although it is well known that this problem has no wait-free read-write protocol <ref> [15, 17, 35] </ref>, we believe the reader's intuition will benefit from a brief discussion of how this result follows from the main theorem. To keep our presentation as simple as possible, we focus on the two-process task. <p> However, these output vertexes lie in distinct connected components of the output complex, so cannot be a simplicial map, and by Theorem 4.1 2-process consensus is not solvable. (Generalizing this argument to n processes yields a simple geometric restatement of the impossibility of wait-free consensus in read/write memory <ref> [15, 17, 35] </ref>.) 4.2 Quasi-Consensus We now use another "toy" problem to illustrate the implications of the theorem. Let us relax the conditions of the consensus task as follows: Quasi-Consensus Each of P and Q is given a binary input. If both have input v, then both must decide v.
Reference: [16] <author> B. Chor and L. Moscovici. </author> <title> Solvability in asynchronous environments. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1989. </year>
Reference-contexts: Although the problem subsequently received considerable attention, it proved difficult to extend such graph-theoretic approaches to encompass more than a single failure. Even the problem of fully characterizing specific tasks like renaming [6] and set agreement [13] remained unresolved. Chor and Moscovici <ref> [16] </ref> later provided a graph-theoretic characterization of tasks solvable in a system where the n + 1 processes can solve (n + 1)-process consensus (either deterministically or randomized).
Reference: [17] <author> D. Dolev, C. Dwork, and L Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Figure 9 shows the input and output complexes 15 16 for 2-process binary consensus. In general, the input complex is (n 1)- acyclic, while the output complex is disconnected. It is known <ref> [15, 17, 27, 35] </ref>, that (n + 1)-process binary consensus has no wait-free protocol in read/write memory. <p> Although it is well known that this problem has no wait-free read-write protocol <ref> [15, 17, 35] </ref>, we believe the reader's intuition will benefit from a brief discussion of how this result follows from the main theorem. To keep our presentation as simple as possible, we focus on the two-process task. <p> However, these output vertexes lie in distinct connected components of the output complex, so cannot be a simplicial map, and by Theorem 4.1 2-process consensus is not solvable. (Generalizing this argument to n processes yields a simple geometric restatement of the impossibility of wait-free consensus in read/write memory <ref> [15, 17, 35] </ref>.) 4.2 Quasi-Consensus We now use another "toy" problem to illustrate the implications of the theorem. Let us relax the conditions of the consensus task as follows: Quasi-Consensus Each of P and Q is given a binary input. If both have input v, then both must decide v.
Reference: [18] <author> A. Fekete. </author> <title> Asymptotically optimal algorithms for approximate agreement. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: The basic intuition is that solving a decision task is really a form of approximate agreement <ref> [4, 18] </ref>, in which processes start out preferring ver-texes "far apart" on the output complex, but after a process of negotiation eventually converge to the vertexes of a single output simplex. <p> In the corresponding algorithm, one process had to perform two reads to allow convergence to a final output. The example suggests that there is an inherent relation between the level of subdivision necessary to allow a simplicial map, and the complexity of the matching "approximate agreement" style algorithm (e.g. <ref> [4, 18] </ref>) defined by it. We believe the topological approach has a great deal of promise for the theory of distributed and concurrent computation, and that it merits further investigation.
Reference: [19] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: In particular, we show that the simplicial complex associated with any wait-free protocol using read/write memory has a remarkable topological property: it has no "holes" in any dimension. We exploit this simple property to derive our impossibility results. In a fundamental paper in 1985, Fischer, Lynch, and Paterson <ref> [19] </ref> showed that there exists a simple task that cannot be solved in a message 1 passing system if even one process may fail by halting (or may be infinitely slow). <p> For example, in the well-known binary consensus task, the processes have binary inputs, and must agree on some process's input <ref> [19] </ref>. A protocol is a program that solves a decision task. A protocol is wait-free if it guarantees that every non-faulty process will finish in a bounded number of steps, no matter how many processes fail. <p> some additional notions, presented later. 4 Strictly speaking, we use reduced homology groups in this paper [38, p.71]. 14 3 Examples This section is intended to strengthen the reader's intuition by presenting a number of examples of complexes and tasks. 3.1 Consensus Perhaps the simplest decision task is binary consensus <ref> [19] </ref>. As specified in output value.
Reference: [20] <author> E. Gafni and E. Koutsoupias. </author> <title> 3-processor tasks are undecidable. PODC 95, Brief announcement. </title>
Reference-contexts: It is natural to ask whether a similar decision procedure exists for our topological representation of wait-free read/write protocols. In a recent announcement <ref> [20] </ref>, Gafni and Koutsoupias assert that the classical contractibility problem of algebraic topology can be used to show that it is undecidable whether 3-process tasks have wait-free read-write protocols.
Reference: [21] <author> P.J. Giblin. </author> <title> Graphs, Surfaces, and Homology. </title> <publisher> Chapman and Hill, </publisher> <address> Lon-don and New York, </address> <year> 1981. </year> <note> Second Edition. </note>
Reference-contexts: Unfortunately, connectivity is hard to prove directly, so we must use an indirect approach. The key notion underlying our proof strategy is the sequence of homology groups associated with a complex. (Readers completely unfamiliar with the notion may wish to consult any one of a number of standard textbooks <ref> [21, 24, 25, 33, 40] </ref>.) For our purposes, it suffices to note that an n-dimensional complex C n is associated with n + 1 Abelian groups, H 0 (C n ); : : : ; H n (C n ), one for each dimension 4 By convention, H 1 (C) is
Reference: [22] <author> L.C. Glaser. </author> <title> Geometrical Combinatorial Topology, volume 1. </title> <publisher> Van Nos-tra D Reinhold, </publisher> <address> New York, </address> <year> 1970. </year> <month> 56 </month>
Reference-contexts: The boundary complex of A n , written _ A n1 , is the subcomplex of all external (n 1)-simplexes (which is itself an (n 1)-manifold). Some, but not all, the complexes we consider are manifolds. Manifolds satisfy the following property <ref> [22, Theorem II.2] </ref>: Lemma 2.1 If M is an n-manifold with boundary, and T m an interior simplex, then lk (T m ; M) is an (n m 1)-sphere. Many complexes of interest have a simple but important topological property: they have no "holes" in certain dimensions. <p> A simplicial map : B ! C extends if they agree on A. The following lemma appears in Glaser <ref> [22, Theorem IV.2] </ref>. Lemma 5.19 Let A, B, and C be complexes such that A B, and f : jBj ! jCj is a continuous map such that f restricted to jAj is simplicial.
Reference: [23] <author> A. Gottlieb, R. Grishman, C.P. Kruskal, K.P. McAuliffe, L. Rudolph, and M. Snir. </author> <title> The NYU Ultracomputer designing an MIMD parallel computer. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-32(2):175-189, </volume> <month> Febru-ary </month> <year> 1984. </year>
Reference-contexts: This problem remained open until 1993, when three independent research teams, Borowsky and Gafni [10], Herlihy and Shavit [30], and Saks and Zaharoglou [39] proved this conjecture correct. 3.3 Fetch-And-Add In the fetch-and-add task <ref> [23] </ref>, a generalization of the Fetch-And-Inc task defined earlier, each of n + 1 processes atomically adds an integer input (from a fixed range) to a shared register, initially zero, and returns the register's previous contents. Figure 11 shows two input simplexes and their corresponding output complexes.
Reference: [24] <author> M.J. Greenberg and J.R. Harper. </author> <title> Algebraic Topology: A First Course. </title> <booktitle> Mathematics Lecture Notes Series. </booktitle> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <address> Reading MA, </address> <year> 1981. </year>
Reference-contexts: Unfortunately, connectivity is hard to prove directly, so we must use an indirect approach. The key notion underlying our proof strategy is the sequence of homology groups associated with a complex. (Readers completely unfamiliar with the notion may wish to consult any one of a number of standard textbooks <ref> [21, 24, 25, 33, 40] </ref>.) For our purposes, it suffices to note that an n-dimensional complex C n is associated with n + 1 Abelian groups, H 0 (C n ); : : : ; H n (C n ), one for each dimension 4 By convention, H 1 (C) is <p> Thus, we can prove a complex is q-connected by showing that it is (1) simply connected, and (2) q-acyclic. To prove that a complex is simply connected, we use the following special case of the Siefert/Van Kampen Theorem <ref> [24, 4.12] </ref>. Theorem 2.3 (Siefert/Van Kampen) If A and B are simply connected, and A " B is connected, then A [ B is simply connected. To prove that a complex is q-acyclic, we use the following special case of the Mayer-Vietoris sequence [40, p.186].
Reference: [25] <author> M. Henle. </author> <title> Combinatorial Introduction To Topology. W.H. </title> <publisher> Freeman and Company, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: Unfortunately, connectivity is hard to prove directly, so we must use an indirect approach. The key notion underlying our proof strategy is the sequence of homology groups associated with a complex. (Readers completely unfamiliar with the notion may wish to consult any one of a number of standard textbooks <ref> [21, 24, 25, 33, 40] </ref>.) For our purposes, it suffices to note that an n-dimensional complex C n is associated with n + 1 Abelian groups, H 0 (C n ); : : : ; H n (C n ), one for each dimension 4 By convention, H 1 (C) is
Reference: [26] <author> M. Herlihy and S. Rajsbaum. </author> <title> Algebraic spans. </title> <booktitle> In Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: We note that our main theorem and its implications carry through also for tasks that do not meet this requirement as the read/write shared memory model we build on is extensible by definition. However, extensibility is crucial for results such as <ref> [2, 12, 26, 29] </ref> that use this framework to derive lower bounds in more powerful computational models. The class of tasks our model describes includes all linearizable one-time objects, that is linearizable objects [32] that permit at most one operation per process. <p> More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement [29], and to unify a variety of known impossibility results in terms of the algebraic theory of chain maps and chain complexes <ref> [26] </ref>. 53 The graph theoretic characterization of [8] does more than provide im-possibility results, it also provides an effective procedure for deciding if a task has a 1-resilient message passing protocol. It is natural to ask whether a similar decision procedure exists for our topological representation of wait-free read/write protocols.
Reference: [27] <author> M.P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions On Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 123-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Figure 9 shows the input and output complexes 15 16 for 2-process binary consensus. In general, the input complex is (n 1)- acyclic, while the output complex is disconnected. It is known <ref> [15, 17, 27, 35] </ref>, that (n + 1)-process binary consensus has no wait-free protocol in read/write memory. <p> Figure 11 shows two input simplexes and their corresponding output complexes. Note that vertexes with the same labels are the same and should be mentally "glued together." They are drawn as distinct only for legibility. It is known <ref> [27] </ref> that fetch-and-add is not even 1-solvable in read/write memory. 4 The Main Theorem We are now ready to state our main theorem in its entirety.
Reference: [28] <author> M.P. Herlihy and S. Rajsbaum. </author> <title> On the decidability of distributed decision problems. </title> <note> In preparation. </note>
Reference-contexts: In a recent announcement [20], Gafni and Koutsoupias assert that the classical contractibility problem of algebraic topology can be used to show that it is undecidable whether 3-process tasks have wait-free read-write protocols. Based on this idea, Herlihy and Rajsbaum <ref> [28] </ref> prove the stronger claim that for N processes it is in fact undecidable whether a task has a t-resilient protocol for all 1 &lt; t &lt; N . There are many directions in which the topological approach could be extended.
Reference: [29] <author> M.P. Herlihy and S. Rajsbaum. </author> <title> Set consensus using arbitrary objects. </title> <booktitle> In Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: We note that our main theorem and its implications carry through also for tasks that do not meet this requirement as the read/write shared memory model we build on is extensible by definition. However, extensibility is crucial for results such as <ref> [2, 12, 26, 29] </ref> that use this framework to derive lower bounds in more powerful computational models. The class of tasks our model describes includes all linearizable one-time objects, that is linearizable objects [32] that permit at most one operation per process. <p> The analysis of the topological properties of protocol complexes for protocols using more powerful primitives appears in a recent paper by Herlihy and Rajsbaum <ref> [29] </ref>, and first tight topology-based lower bounds on certain tasks in the synchronous fail-stop model were presented by Chaudhuri, Herlihy, Lynch, and Tuttle [14]. Attiya and Rajsbaum cast our topological model in a related "combinatorial" representation [5]. <p> Borowsky and Gafni [9, 11] have based a key part of the proof of their simulation method our proof and construction of spans. More recently, Herlihy and Rajsbaum used homology theory to derive further impossibility results for set agreement <ref> [29] </ref>, and to unify a variety of known impossibility results in terms of the algebraic theory of chain maps and chain complexes [26]. 53 The graph theoretic characterization of [8] does more than provide im-possibility results, it also provides an effective procedure for deciding if a task has a 1-resilient message
Reference: [30] <author> M.P. Herlihy and N. Shavit. </author> <title> The asynchronous computability theorem for t-resilient tasks. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Chor and Moscovici [16] later provided a graph-theoretic characterization of tasks solvable in a system where the n + 1 processes can solve (n + 1)-process consensus (either deterministically or randomized). In 1993, three research teams|Borowsky and Gafni [10], Saks and Za-haroglou [39], and the current authors <ref> [30] </ref>, independently derived lower bounds for the k-set agreement problem of Chaudhuri. The proof of Borowsky and Gafni [10] is based on a powerful simulation method that allows N - process protocols to be executed by fewer processes in a resilient way. <p> The proof of Borowsky and Gafni [10] is based on a powerful simulation method that allows N - process protocols to be executed by fewer processes in a resilient way. Both Saks and Zaharoglou [39] and the current authors <ref> [30] </ref> apply notions and techniques from mainstream combinatorial topology. Saks and Zaharoglou introduce an innovative and elegant formal model in which processors' collective knowledge of the unfolding computation is treated as a topological space. <p> They then apply a variant of the Brouwer fixed point theorem [38] to derive impossibility of wait-free set agreement. While Saks and Zaharoglou exploit notions from point-set topology, our approach <ref> [30, 31] </ref> is more combinatorial. We introduced a new formalism based on simplicial complexes and homology groups, notions taken from undergraduate-level algebraic topology. Simplicial complexes are a natural generalization of graphs. <p> The set agreement problem was first proposed by Soma Chaudhuri [13] in 1989, along with a conjecture that it could not be solved in certain asynchronous systems. This problem remained open until 1993, when three independent research teams, Borowsky and Gafni [10], Herlihy and Shavit <ref> [30] </ref>, and Saks and Zaharoglou [39] proved this conjecture correct. 3.3 Fetch-And-Add In the fetch-and-add task [23], a generalization of the Fetch-And-Inc task defined earlier, each of n + 1 processes atomically adds an integer input (from a fixed range) to a shared register, initially zero, and returns the register's previous <p> Bar-Noy and Dolev [7] extended their upper bound solution to the shared read-write memory model. The protocols of Attiya et al. and of Bar-Noy and Dolev are both comparison-based. Whether a protocol exists for n + 2 &lt; K 2n names remained open until 1993, when Herlihy and Shavit <ref> [30] </ref> showed that no such protocol exists. Henceforth, by renaming, we mean the renaming task where K 2n. Lemma 7.2 If a renaming protocol exists, then a comparison-based protocol exists. Proof: Assume we are given a wait-free renaming protocol .
Reference: [31] <author> M.P. Herlihy and N. Shavit. </author> <title> A simple constructive computability theorem for wait-free computation. </title> <booktitle> In Proceedings of the 1994 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: They then apply a variant of the Brouwer fixed point theorem [38] to derive impossibility of wait-free set agreement. While Saks and Zaharoglou exploit notions from point-set topology, our approach <ref> [30, 31] </ref> is more combinatorial. We introduced a new formalism based on simplicial complexes and homology groups, notions taken from undergraduate-level algebraic topology. Simplicial complexes are a natural generalization of graphs.
Reference: [32] <author> M.P. Herlihy and J.M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions On Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: However, extensibility is crucial for results such as [2, 12, 26, 29] that use this framework to derive lower bounds in more powerful computational models. The class of tasks our model describes includes all linearizable one-time objects, that is linearizable objects <ref> [32] </ref> that permit at most one operation per process. Our model incorporates an explicit notion of participating processes because it is convenient to distinguish between tasks such as the following. <p> If H is sequential, H is a total order. A concurrent protocol or object is linearizable if its histories can be mapped to sequential ones by making each operation ap 5 pear to take effect instantaneously at some point between its invocation and its response (see Herlihy and Wing <ref> [32] </ref> for details). An atomic read/write memory automaton is one that is linearizable to the sequential automaton specified above.
Reference: [33] <author> S. Lefschetz. </author> <title> Introduction To Topology. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1949. </year>
Reference-contexts: Unfortunately, connectivity is hard to prove directly, so we must use an indirect approach. The key notion underlying our proof strategy is the sequence of homology groups associated with a complex. (Readers completely unfamiliar with the notion may wish to consult any one of a number of standard textbooks <ref> [21, 24, 25, 33, 40] </ref>.) For our purposes, it suffices to note that an n-dimensional complex C n is associated with n + 1 Abelian groups, H 0 (C n ); : : : ; H n (C n ), one for each dimension 4 By convention, H 1 (C) is <p> We now show that the k-set agreement task has no wait-free read-write protocol when k n. Our proof uses Sperner's Lemma <ref> [33, Lemma 5.5] </ref>: Lemma 4.2 (Sperner's Lemma) Let (S n ) be a subdivision of simplex S n .
Reference: [34] <author> H. R. Lewis and C. H. Papadimitriou. </author> <title> Elements of the Theory of Computation, </title> <booktitle> chapter 4, </booktitle> <pages> pages 168-175. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year> <month> 57 </month>
Reference-contexts: Also, as noted above, our protocols use an atomic snapshot memory [1, 3], which can be implemented from the atomic read/write memory described here. 2.3 Solvability We are interested in solvability of tasks by processes that are computa-tionally equivalent to Turing machines <ref> [34] </ref> and communicate via atomic read/write memory. A process is active at some point in a history if it does not yet have a finish event. An active process is faulty at that point if it has no output events later in that history.
Reference: [35] <author> M.C. Loui and H.H. Abu-Amara. </author> <title> Memory Requirements For Agreement Among Unreliable Asynchronous Processes, </title> <booktitle> volume 4, </booktitle> <pages> pages 163-183. </pages> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: Figure 9 shows the input and output complexes 15 16 for 2-process binary consensus. In general, the input complex is (n 1)- acyclic, while the output complex is disconnected. It is known <ref> [15, 17, 27, 35] </ref>, that (n + 1)-process binary consensus has no wait-free protocol in read/write memory. <p> Although it is well known that this problem has no wait-free read-write protocol <ref> [15, 17, 35] </ref>, we believe the reader's intuition will benefit from a brief discussion of how this result follows from the main theorem. To keep our presentation as simple as possible, we focus on the two-process task. <p> However, these output vertexes lie in distinct connected components of the output complex, so cannot be a simplicial map, and by Theorem 4.1 2-process consensus is not solvable. (Generalizing this argument to n processes yields a simple geometric restatement of the impossibility of wait-free consensus in read/write memory <ref> [15, 17, 35] </ref>.) 4.2 Quasi-Consensus We now use another "toy" problem to illustrate the implications of the theorem. Let us relax the conditions of the consensus task as follows: Quasi-Consensus Each of P and Q is given a binary input. If both have input v, then both must decide v.
Reference: [36] <author> N. A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann, </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: This result showed that the notion of "asynchronous computability" differs in important ways from conventional notions of computability (such as sequential "Turing" computability). It led to the creation of a highly active research area, the full scope of which is surveyed in recent book by Lynch <ref> [36] </ref>. A first step toward a systematic characterization of asynchronous computability was taken in 1988, when Biran, Moran, and Zaks [8] gave a graph-theoretic characterization of the tasks that could be solved by a message-passing system in the presence of a single failure. <p> In this paper, we investigate protocols in which processes communicate by reading and writing variables in shared memory. The literature encompasses a variety of shared-memory models; fortunately they are all equivalent. Given single-bit, single-reader, and single-writer variables, one can construct multi-bit, multi-reader variables (see Lynch's survey <ref> [36] </ref>). From these variables, in turn, one can implement an atomic snapshot memory: an array where each P i updates array element i, and any process can instantaneously scan (atomically read) the entire array (see [1, 3] for details.).
Reference: [37] <author> N.A. Lynch and M.R. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT Laboratory For Computer Science, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: Most decision problems studied in the literature have a finite set of input vectors. 2.2 Objects, Processes, and Protocols Formally, we model objects, processes, and protocols using a simplified form of the I/O automaton formalism of Lynch and Tuttle <ref> [37] </ref>. An I/O automaton is a non-deterministic automaton with a finite or infinite set of states, a set of input events, a set of output events, and a transition relation given by a set of steps, each defining a state transition following a given event. <p> An automaton history is the subsequence of events occurring in an execution. Automata can be composed by identifying input and output events in the natural way (details can be found in <ref> [37] </ref>). A process P is an automaton with output events call (P; v; X), and finish (P; v); input events return (P; v; X) and start (P; v), where P is a process, v is a value, and X an object.
Reference: [38] <author> J.R. Munkres. </author> <title> Elements Of Algebraic Topology. </title> <publisher> Addison Wesley, </publisher> <address> Reading MA, </address> <year> 1984. </year> <note> ISBN 0-201-04586-9. </note>
Reference-contexts: Saks and Zaharoglou introduce an innovative and elegant formal model in which processors' collective knowledge of the unfolding computation is treated as a topological space. They then apply a variant of the Brouwer fixed point theorem <ref> [38] </ref> to derive impossibility of wait-free set agreement. While Saks and Zaharoglou exploit notions from point-set topology, our approach [30, 31] is more combinatorial. We introduced a new formalism based on simplicial complexes and homology groups, notions taken from undergraduate-level algebraic topology. Simplicial complexes are a natural generalization of graphs. <p> These theorems encompass all the topological machinery we need to prove our main theorem. The impossibility proof for renaming presented in Section 7 will require some additional notions, presented later. 4 Strictly speaking, we use reduced homology groups in this paper <ref> [38, p.71] </ref>. 14 3 Examples This section is intended to strengthen the reader's intuition by presenting a number of examples of complexes and tasks. 3.1 Consensus Perhaps the simplest decision task is binary consensus [19]. As specified in output value. <p> A process that chooses vertex ~v 2 K (I) then chooses as its output value val (((~v))). 6.1 The Standard Chromatic Subdivision We start with a purely combinatorial definition of the standard chromatic subdivision. (For an analogous combinatorial definition of the standard barycentric subdivision, see <ref> [38, Lemma 15.3] </ref>.) Let S n = (~s 0 ; : : :; ~s n ), where id (~s i ) = P i . <p> If ~x 2 (f ace i (S n )), then the edge (~x; ~x i ) lies inside the triangle (~x; ~ b; ~ b i ), which lies inside a simplex in fi (S n ). Since mesh (fi (S n )) (n=(n + 1))diam (S n ) <ref> [38, Theorem 15.4] </ref>, j~x ~x i j (n=(n + 1))diam (S n ). Finally, j~x i ~x j j = ffij~s i ~s j j, and the claim follows because ffi &lt; 1=n. <p> This observation yields a contradiction, because a simplicial map is carrying the boundary of a "solid" region to the boundary of a "hole". 7.3 Orientation, Cycles, and Boundaries This section presents some additional definitions needed for our proof. Our discussion closely follows that of Munkres <ref> [38, Section 1.13] </ref>, which the reader is encouraged to consult for more details. Let S n = (~s 0 ; : : : ; ~s n ) be an n-simplex. <p> Theorem 7.4 reformulates the well-known result that the homology groups of the (n 1)-sphere B n1 are trivial below (n 1), and infinite cyclic in dimension n, generated by B. Lemma 7.5 is a special case of the well-known classical theorem <ref> [38, P.108] </ref> that any complex has the same homology as its deformation retracts. 7.4 The Impossibility of Renaming Let S n be an input simplex.
Reference: [39] <author> M. Saks and F. Zaharoglou. </author> <title> Wait-free k-set agreement is impossible: The topology of public knowledge. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Chor and Moscovici [16] later provided a graph-theoretic characterization of tasks solvable in a system where the n + 1 processes can solve (n + 1)-process consensus (either deterministically or randomized). In 1993, three research teams|Borowsky and Gafni [10], Saks and Za-haroglou <ref> [39] </ref>, and the current authors [30], independently derived lower bounds for the k-set agreement problem of Chaudhuri. The proof of Borowsky and Gafni [10] is based on a powerful simulation method that allows N - process protocols to be executed by fewer processes in a resilient way. <p> The proof of Borowsky and Gafni [10] is based on a powerful simulation method that allows N - process protocols to be executed by fewer processes in a resilient way. Both Saks and Zaharoglou <ref> [39] </ref> and the current authors [30] apply notions and techniques from mainstream combinatorial topology. Saks and Zaharoglou introduce an innovative and elegant formal model in which processors' collective knowledge of the unfolding computation is treated as a topological space. <p> This problem remained open until 1993, when three independent research teams, Borowsky and Gafni [10], Herlihy and Shavit [30], and Saks and Zaharoglou <ref> [39] </ref> proved this conjecture correct. 3.3 Fetch-And-Add In the fetch-and-add task [23], a generalization of the Fetch-And-Inc task defined earlier, each of n + 1 processes atomically adds an integer input (from a fixed range) to a shared register, initially zero, and returns the register's previous contents.
Reference: [40] <author> E.H. Spanier. </author> <title> Algebraic Topology. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1966. </year> <month> 58 </month>
Reference-contexts: lower bound proofs we allow them to be unbounded. % Code for process i update (V [i] := input_value) for round in 1 .. r do local_state := scan (V) update (V [i] := local_state) return ffi (local_state) 2.4 Simplicial Complexes We start with a number of standard technical definitions <ref> [40] </ref>. A vertex ~v is a point in a high-dimensional Euclidian space. <p> Unfortunately, connectivity is hard to prove directly, so we must use an indirect approach. The key notion underlying our proof strategy is the sequence of homology groups associated with a complex. (Readers completely unfamiliar with the notion may wish to consult any one of a number of standard textbooks <ref> [21, 24, 25, 33, 40] </ref>.) For our purposes, it suffices to note that an n-dimensional complex C n is associated with n + 1 Abelian groups, H 0 (C n ); : : : ; H n (C n ), one for each dimension 4 By convention, H 1 (C) is <p> Theorem 2.3 (Siefert/Van Kampen) If A and B are simply connected, and A " B is connected, then A [ B is simply connected. To prove that a complex is q-acyclic, we use the following special case of the Mayer-Vietoris sequence <ref> [40, p.186] </ref>. Theorem 2.4 (Mayer-Vietoris) If A and B are complexes such that A " B 6= ;, then if H q (A), H q (B), and H q1 (A " B) are all trivial, so is H q (A [ B). <p> Define t (T m ) to be ~ t _ T m1 , the complex constructed by joining ~ t with the proper faces of T m . This complex is a subdivision of T m <ref> [40, 3.3.8] </ref> that leaves the boundary complex unchanged, so replacing T m in B m with t (T m ) yields a subdivision t (B m ). Pick ~u such that (~v; ~u) is a 1-simplex in C n .
References-found: 40

