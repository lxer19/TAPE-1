URL: http://www.csl.sri.com/shankar/ftrtft96.ps.gz
Refering-URL: http://www.csl.sri.com/shankar/
Root-URL: 
Email: shankar@csl.sri.com  
Phone: Phone: +1 (415) 859-5272 Fax: +1 (415) 859-2844  
Title: Unifying Verification Paradigms  
Author: Natarajan Shankar 
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Web: FTRTFT'96  URL: http://www.csl.sri.com/~shankar/  
Note: (Extended Abstract) To appear in the Proceedings of  
Abstract: The field of formal methods is blessed with an overabundance of formalisms (functional, relational, automata-theoretic, modal, and temporal), techniques (resolution, rewriting, induction, and model checking), and application areas (hardware, reactive, fault-tolerant, real-time, and hybrid systems). No single verification approach has proven convincingly superior to the others. I argue that it is both necessary and desirable to develop a unified framework within which different approaches can coexist. The paper outlines some preliminary efforts in this direction in the context of SRI's PVS system. These efforts include the embedding of special-purpose formalisms (e.g., the Duration Calculus) into the general-purpose PVS logic, the integration of theorem proving with various forms of model checking, and the application of theorem proving and model checking to the analysis of tabular specifications.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Archer and C. Heitmeyer. </author> <title> Mechanical verification of timed automata: A case study. </title> <booktitle> In IEEE Real-Time Technology and Applications Symp. </booktitle> <address> (RTAS'96), Boston MA, </address> <month> June </month> <year> 1996. </year> <note> IEEE Computer Society Press. To Appear. </note>
Reference-contexts: Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems [25], and I/O automata <ref> [1] </ref>. This paper describes some of the steps taken in PVS towards a coherent integration of different verification paradigms, and the larger challenges that remain. <p> The amount of mathematics can be quite overwhelming if it is not organized into theories, libraries, and special-purpose formalisms. A number of other users have similarly employed PVS to support formalisms that they previously employed by hand <ref> [1, 19, 25] </ref>. PVS, like other similar systems, was not explicitly designed with the anticipation of issues of integration and unification. It was in fact designed as a framework for developing conventional mathematics that integrated the use of decision procedures, rewriting, induction, and simplification with typechecking.
Reference: 2. <author> Joanne M. Atlee and John Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 24-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Blank entries in tables are treated as unreachable and the corresponding proof obligations are generated by the PVS type checker. The TABLE construct has been used to capture an SCR-style specification <ref> [2] </ref> of the mode-transition table of a simple cruise-controller where the modes (off, inactive, cruise, override) are controlled by the environment conditions (ignited, running, toofast, brake, activate, deactivate, resume). The table indicates the next mode corresponding to the current mode and the status of the environment conditions. <p> In cruise mode, the engine is running, the vehicle is not going toofast, the brake is not on, and deactivate is not selected. 5. In override mode, the engine is running. Atlee and Gannon <ref> [2] </ref> used a hand-translation of the SCR specification into SMV [29] in order to perform model checking, whereas the tabular specification in PVS is directly combined with the PVS model checker.
Reference: 3. <author> J. R. Burch, E. M. Clarke, K. L McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: This theory is based on Park's mu-calculus [32]. Emerson and Lei [9] showed how the mu-calculus can be used to embed a number of finite-state formalisms. They also gave an efficient algorithm for checking mu-calculus formulas. Burch, Clarke, Dill, McMillan, and Hwang <ref> [3] </ref> showed how Park's mu-calculus could be decided using a symbolic representation in terms of binary decision diagrams.
Reference: 4. <author> Zhou Chaochen, C. A. R. Hoare, and A. P. Ravn. </author> <title> A calculus of durations. </title> <journal> Information Processing Letters, </journal> <volume> 40(5) </volume> <pages> 269-276, </pages> <year> 1992. </year>
Reference-contexts: The crucial difference here is that the proof theory of DC is developed and used to construct a proof checker for DC specifications and properties. Gordon [11] gives a good introduction to the embedding of program logics within higher-order logic. The Duration Calculus <ref> [4] </ref> is a real-time interval temporal logic. A DC formula is a predicate over a time interval [b; e], where b e.
Reference: 5. <author> E. Clarke, O. Grumberg, and K. Hamaguchi. </author> <title> Another look at LTL model checking. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification 94, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 415-427, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Note that whereas branching-time properties are predicates on computation states, linear-time properties are predicates on computation traces. The integration of LTL model checking is done by translating LTL formulas into a Kripke automaton which is composed with the given Kripke model <ref> [5] </ref>. The LTL model checking problem then reduces to fairCTL model checking on this extended automaton. The integration of LTL is not as smooth as that of CTL since it requires a hand-crafted translation of the LTL satisfaction relation to that for fairCTL.
Reference: 6. <author> E. M. Clarke and O. Grumberg. </author> <title> Research on automatic verication of finite state concurrent systems. </title> <booktitle> In Annual Review of Computer Science, </booktitle> <pages> pages 269-290. </pages> <publisher> Annual Reviews, Inc., </publisher> <year> 1987. </year>
Reference-contexts: For example, temporal logic [28] can succinctly capture the fairness assumptions and the safety and liveness properties of finite-state programs. Furthermore, the propositional fragment of temporal logic is decidable. This fragment of temporal logic can also be used for model checking and for synthesizing control programs <ref> [6] </ref>. Similar arguments can be made for the numerous variants of Hoare logics, process algebras, algebraic datatype specification languages, dataflow languages, and others. In my experience, no individual special-purpose formalism fully addresses the verification problems of practical significance. <p> Verification by means of theorem proving establishes a property P of a system M by proving P from M , i.e., M ` P , whereas model checking <ref> [6] </ref> demonstrates that M satisfies P , i.e., M j= P . Typically in model checking, M is a finite Kripke model of a system consisting of states and transitions between states.
Reference: 7. <author> David Cyrluk, Patrick Lincoln, Steven Miller, Paliath Narendran, Sam Owre, Sreeranga Rajan, John Rushby, Natarajan Shankar, Jens Ulrik Skakkebk, Man-dayam Srivas, and Friedrich von Henke. </author> <title> Seven papers on mechanized formal verification. </title> <type> Technical Report SRI-CSL-95-3, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: For example, Dutertre [8] found it necessary to build a library of basic facts of mathematical analysis as a prelude to the formalization of hybrid systems. Other work in the verification of real-time and fault-tolerant systems <ref> [7] </ref> also exhibits a heavy dependence on basic mathematics that are not alleviated by the use of special-purpose formalisms. Logical frameworks like Isabelle [33] do make it easier to implement proof checkers for new formalisms. However, as we have already seen, individual formalisms are not adequate for practical verification. <p> PVS has been used to: Develop domain libraries for finite sets, cardinalities, bit-vectors, and reals [8]. 2 Verify challenging exercises from areas such as hardware [39], fault-tolerant algorithms [27], real-time computing, and reactive systems <ref> [7, 19] </ref>. Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems [25], and I/O automata [1]. This paper describes some of the steps taken in PVS towards a coherent integration of different verification paradigms, and the larger challenges that remain.
Reference: 8. <author> Bruno Dutertre. </author> <title> Elements of mathematical analysis in PVS. </title> <booktitle> In International Conference on Theorem Proving in Higher Order Logics, Lecture Notes in Computer Science, </booktitle> <address> Turku, Finland, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: Though formalism does make it convenient to use mathematics, it does not avoid the need for mathematics. For many practical problems, the main burden of verification is still in the sheer amount of conventional mathematics required to carry out a successful verification. For example, Dutertre <ref> [8] </ref> found it necessary to build a library of basic facts of mathematical analysis as a prelude to the formalization of hybrid systems. <p> While PVS is a general-purpose verification system based on typed higher-order logic, it provides a notational framework for describing computational phenomena, and incorporates a variety of decision procedures for reasoning effectively about computation. PVS has been used to: Develop domain libraries for finite sets, cardinalities, bit-vectors, and reals <ref> [8] </ref>. 2 Verify challenging exercises from areas such as hardware [39], fault-tolerant algorithms [27], real-time computing, and reactive systems [7, 19]. Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems [25], and I/O automata [1].
Reference: 9. <author> E.A. Emerson and C.L Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus. </title> <booktitle> In Proceedings of the 10th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <address> New Orleans, LA, </address> <month> January </month> <year> 1985. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Model checking can be viewed as a decision procedure for the finite-state fragment of a more general theory of extremal fixpoints of monotone predicate transformers. This theory is based on Park's mu-calculus [32]. Emerson and Lei <ref> [9] </ref> showed how the mu-calculus can be used to embed a number of finite-state formalisms. They also gave an efficient algorithm for checking mu-calculus formulas. Burch, Clarke, Dill, McMillan, and Hwang [3] showed how Park's mu-calculus could be decided using a symbolic representation in terms of binary decision diagrams.
Reference: 10. <author> S. Faulk and P. Clements. </author> <title> The NRL Software Cost Reduction (SCR) requirements specification methodology. </title> <booktitle> In Fourth International Workshop on Software Specification and Design, </booktitle> <address> Monterey, CA, April 1987. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Furthermore, the model checking capabilities of PVS described in Section 3 can be used to verify and refine tabular specifications of mode transition systems. A number of influential specification and verification methodologies are based on the use of tables <ref> [10, 17, 18, 26, 36] </ref>. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 11. <author> Michael J. C. Gordon. </author> <title> Mechanizing programming logics in higher-order logic. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> Current Trends in Hardware Verification and Theorem Proving, </booktitle> <pages> pages 387-439, </pages> <address> New York, NY, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The crucial difference here is that the proof theory of DC is developed and used to construct a proof checker for DC specifications and properties. Gordon <ref> [11] </ref> gives a good introduction to the embedding of program logics within higher-order logic. The Duration Calculus [4] is a real-time interval temporal logic. A DC formula is a predicate over a time interval [b; e], where b e.
Reference: 12. <author> Klaus Havelund and N. Shankar. </author> <title> Experiments in theorem proving and model checking for protocol verification. </title> <booktitle> In Formal Methods Europe FME '96, number 1051 in Lecture Notes in Computer Science, </booktitle> <pages> pages 662-681, </pages> <address> Oxford, UK, March 1996. </address> <publisher> Springer-Verlag. </publisher> <pages> 16 </pages>
Reference-contexts: The benefit of using model checking is that one does not need to discover a suitably strengthened inductive invariant. The discovery of the right abstraction mapping still requires some creativity but this is usually simpler than invariant discovery. In joint work with Havelund <ref> [12] </ref>, we have applied abstraction to reduce the verification of a communication protocol to a form amenable to model checking. With Rajan and Schuerman, we have also integrated model checking for the linear-time temporal logic LTL.
Reference: 13. <author> Mats P. E. Heimdahl. </author> <title> Experiences and lessons from the analysis of TCAS II. </title> <editor> In Steven J. Zeil, editor, </editor> <booktitle> International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 79-83, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1996. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: A number of influential specification and verification methodologies are based on the use of tables [10, 17, 18, 26, 36]. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML <ref> [13, 14] </ref>, and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 14. <author> Mats P. E. Heimdahl and Nancy G. Leveson. </author> <title> Completeness and consistency in hierarchical state-based requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6) </volume> <pages> 363-377, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: A number of influential specification and verification methodologies are based on the use of tables [10, 17, 18, 26, 36]. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML <ref> [13, 14] </ref>, and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 15. <author> Constance Heitmeyer, Alan Bull, Carolyn Gasarch, and Bruce Labaw. SCR*: </author> <title> A toolset for specifying and analyzing requirements. </title> <booktitle> In COMPASS [22], </booktitle> <pages> pages 109-122. </pages>
Reference-contexts: A number of influential specification and verification methodologies are based on the use of tables [10, 17, 18, 26, 36]. There are a few special purpose tools that support the analysis of tabular specifications like SCR* <ref> [15, 16] </ref>, RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 16. <author> Constance Heitmeyer, Bruce Labaw, and Daniel Kiskis. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <booktitle> In International Symposium on Requirements Engineering, </booktitle> <address> York, England, March 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: A number of influential specification and verification methodologies are based on the use of tables [10, 17, 18, 26, 36]. There are a few special purpose tools that support the analysis of tabular specifications like SCR* <ref> [15, 16] </ref>, RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 17. <author> K. L. Heninger. </author> <title> Specifying software requirements for complex systems: New techniques and their application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-13, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Furthermore, the model checking capabilities of PVS described in Section 3 can be used to verify and refine tabular specifications of mode transition systems. A number of influential specification and verification methodologies are based on the use of tables <ref> [10, 17, 18, 26, 36] </ref>. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 18. <author> K. L. Heninger et al. </author> <title> Software requirements for the A-7E aircraft. </title> <type> NRL Report 3876, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1978. </year>
Reference-contexts: Furthermore, the model checking capabilities of PVS described in Section 3 can be used to verify and refine tabular specifications of mode transition systems. A number of influential specification and verification methodologies are based on the use of tables <ref> [10, 17, 18, 26, 36] </ref>. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 19. <author> Jozef Hooman. </author> <title> Correctness of real time systems by construction. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-40, </pages> <address> Lubeck, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: PVS has been used to: Develop domain libraries for finite sets, cardinalities, bit-vectors, and reals [8]. 2 Verify challenging exercises from areas such as hardware [39], fault-tolerant algorithms [27], real-time computing, and reactive systems <ref> [7, 19] </ref>. Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems [25], and I/O automata [1]. This paper describes some of the steps taken in PVS towards a coherent integration of different verification paradigms, and the larger challenges that remain. <p> The amount of mathematics can be quite overwhelming if it is not organized into theories, libraries, and special-purpose formalisms. A number of other users have similarly employed PVS to support formalisms that they previously employed by hand <ref> [1, 19, 25] </ref>. PVS, like other similar systems, was not explicitly designed with the anticipation of issues of integration and unification. It was in fact designed as a framework for developing conventional mathematics that integrated the use of decision procedures, rewriting, induction, and simplification with typechecking.
Reference: 20. <author> D. N. Hoover and Zewei Chen. Tablewise, </author> <title> a decision table tool. </title> <booktitle> In COMPASS [22], </booktitle> <pages> pages 97-108. </pages>
Reference-contexts: A number of influential specification and verification methodologies are based on the use of tables [10, 17, 18, 26, 36]. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML [13, 14], and Tablewise <ref> [20] </ref>. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 21. <author> John Hopcroft and Jeffrey Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: It too involves such familiar ideas as inductive definitions, structural in-duction, definition expansion, and predicate calculus. The textbook proofs of this equivalence are unduly circuitous <ref> [21] </ref>. They also overlook the observation that these equivalences make no use of the finiteness of the state type. The main point is that a lot of basic mathematics (predicate calculus, set theory, lists, arithmetic, recursion) is needed to describe even a simple computational phenomenon.
Reference: 22. <institution> COMPASS '95 (Proceedings of the Ninth Annual Conference on Computer Assurance), Gaithersburg, MD, </institution> <month> June </month> <year> 1995. </year> <institution> IEEE Washington Section. </institution>
Reference: 23. <author> Recep Inal and Jens U. Skakkebk. </author> <title> Applying a mechanized duration calculus assistant. </title> <editor> In Hans Rischel, editor, </editor> <booktitle> Nordic Seminar on Dependable Computing Systems, </booktitle> <pages> pages 69-80, </pages> <address> Lyngby, Denmark, </address> <month> August </month> <year> 1994. </year> <institution> Technical University of Denmark. </institution>
Reference-contexts: Inal and Skakkebk <ref> [23] </ref> have applied PC/DC to a several previously studied DC examples. They report finding errors in every example that they examined.
Reference: 24. <author> G. </author> <type> Janssen. </type> <institution> ROBDD Software. Department of Electrical Engineering, Eindhoven University of Technology, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: When the state type T is finite, the least and greatest fixpoints can be explicitly computed. In PVS, this is done by carrying out a binary encoding the variables of state type as an n-tuple of booleans, and using a package due to Janssen <ref> [24] </ref> which employs binary decision diagrams (BDDs) to symbolically compute least and greatest fixpoints over the booleans. With the ability to represent finite states and compute fixpoints, we can, for example, compute the reachability relation on the program graph and represent the operators of the branching-time temporal logic CTL.
Reference: 25. <author> Pertti Kellomaki. </author> <title> Mechanical verification of DisCo specifications. </title> <booktitle> In Israeli-Finnish Binational Symposium on Specification, Development, and Verification of Concurrent Systems, </booktitle> <address> Haifa, Israel, </address> <month> January </month> <year> 1996. </year> <note> The Technion. </note>
Reference-contexts: Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems <ref> [25] </ref>, and I/O automata [1]. This paper describes some of the steps taken in PVS towards a coherent integration of different verification paradigms, and the larger challenges that remain. <p> The amount of mathematics can be quite overwhelming if it is not organized into theories, libraries, and special-purpose formalisms. A number of other users have similarly employed PVS to support formalisms that they previously employed by hand <ref> [1, 19, 25] </ref>. PVS, like other similar systems, was not explicitly designed with the anticipation of issues of integration and unification. It was in fact designed as a framework for developing conventional mathematics that integrated the use of decision procedures, rewriting, induction, and simplification with typechecking.
Reference: 26. <author> Nancy G. Leveson, Mats Per Erik Heimdahl, Holly Hildreth, and Jon Damon Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Furthermore, the model checking capabilities of PVS described in Section 3 can be used to verify and refine tabular specifications of mode transition systems. A number of influential specification and verification methodologies are based on the use of tables <ref> [10, 17, 18, 26, 36] </ref>. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 27. <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an algorithm for interactive consistency under a hybrid fault model. In Costas Courcoubetis, editor, Computer-Aided Verification, </title> <booktitle> CAV '93, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 292-304, </pages> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: PVS has been used to: Develop domain libraries for finite sets, cardinalities, bit-vectors, and reals [8]. 2 Verify challenging exercises from areas such as hardware [39], fault-tolerant algorithms <ref> [27] </ref>, real-time computing, and reactive systems [7, 19]. Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems [25], and I/O automata [1].
Reference: 28. <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Volume 1: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: For example, temporal logic <ref> [28] </ref> can succinctly capture the fairness assumptions and the safety and liveness properties of finite-state programs. Furthermore, the propositional fragment of temporal logic is decidable. This fragment of temporal logic can also be used for model checking and for synthesizing control programs [6].
Reference: 29. <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1993. </year>
Reference-contexts: In cruise mode, the engine is running, the vehicle is not going toofast, the brake is not on, and deactivate is not selected. 5. In override mode, the engine is running. Atlee and Gannon [2] used a hand-translation of the SCR specification into SMV <ref> [29] </ref> in order to perform model checking, whereas the tabular specification in PVS is directly combined with the PVS model checker.
Reference: 30. <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year> <month> 17 </month>
Reference-contexts: In an attempt to do something about these beliefs, we have been engaged in the development of a verification framework named PVS <ref> [30] </ref>. While PVS is a general-purpose verification system based on typed higher-order logic, it provides a notational framework for describing computational phenomena, and incorporates a variety of decision procedures for reasoning effectively about computation.
Reference: 31. <author> Sam Owre, John Rushby, and Natarajan Shankar. </author> <title> Analyzing tabular and state--transition specifications in PVS. </title> <type> Technical Report SRI-CSL-95-12, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> July </month> <year> 1995. </year> <title> Available, with specification files, </title> <note> from http://www.csl.sri.com/csl-95-12.html </note> . 
Reference-contexts: This section presents the enhancement of PVS with support for tabular specification <ref> [31] </ref>. This enhancement 12 yields a visually attractive specification notation that is supported by the specifi-cation and deductive capabilities already in PVS. In particular, PVS typecheck-ing is used to generate well-formedness proof obligations. These proof obligations can be verified using the PVS proof checker.
Reference: 32. <author> David Park. </author> <title> Finiteness is mu-ineffable. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 173-181, 19. </pages>
Reference-contexts: Model checking can be viewed as a decision procedure for the finite-state fragment of a more general theory of extremal fixpoints of monotone predicate transformers. This theory is based on Park's mu-calculus <ref> [32] </ref>. Emerson and Lei [9] showed how the mu-calculus can be used to embed a number of finite-state formalisms. They also gave an efficient algorithm for checking mu-calculus formulas.
Reference: 33. <author> Lawrence C. Paulson. </author> <title> Isabelle: A Generic Theorem Prover, </title> <booktitle> volume 828 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Other work in the verification of real-time and fault-tolerant systems [7] also exhibits a heavy dependence on basic mathematics that are not alleviated by the use of special-purpose formalisms. Logical frameworks like Isabelle <ref> [33] </ref> do make it easier to implement proof checkers for new formalisms. However, as we have already seen, individual formalisms are not adequate for practical verification. <p> The integrated nature of PVS has proved useful in the definition and integration of more specialized logics and deductive tools, but such integration work still has to be carried out in a somewhat ad hoc manner. Logical frameworks like Isabelle <ref> [33] </ref> offer considerable convenience in defining and constructing deductive tools for specialized logics, but lack any systematic support for a coherent integration of the capabilities of different formalisms.
Reference: 34. <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <editor> In Pierre Wolper, editor, </editor> <booktitle> Computer-Aided Verification, CAV '95, volume 939 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-97, </pages> <address> Liege, Belgium, June 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: PVS has been used to: Develop domain libraries for finite sets, cardinalities, bit-vectors, and reals [8]. 2 Verify challenging exercises from areas such as hardware [39], fault-tolerant algorithms [27], real-time computing, and reactive systems [7, 19]. Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics <ref> [34] </ref>, action systems [25], and I/O automata [1]. This paper describes some of the steps taken in PVS towards a coherent integration of different verification paradigms, and the larger challenges that remain. <p> They showed how several other model checking paradigms such as branching and linear-time model checking, LTL validity checking, simulation checking in process algebra, and language containment could be captured within the unified framework of the mu-calculus. In joint work with Rajan and Srivas <ref> [34] </ref>, we showed how the mu-calculus could be defined in a higher-order logic as a way of combining the benefits of theorem proving and model checking.
Reference: 35. <author> H. Rue, N. Shankar, </author> <title> and M.K. Srivas. Modular verification of SRT division. </title> <editor> In R. Alur and T.A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: We can use model checking to prove safety and liveness properties of a tabular specification of the auto-pilot system and also to demonstrate that one tabular specification implements another. PVS tables were used to capture the quotient lookup table in the verification of hardware for SRT division <ref> [35] </ref>. These example applications illustrate the value of integrating tabular notation into a general-purpose verification framework.
Reference: 36. <author> Lance Sherry. </author> <title> A structured approach to requirements specification for software-based systems using operational procedures. </title> <booktitle> In 13th AIAA/IEEE Digital Avionics Systems Conference, </booktitle> <pages> pages 64-69, </pages> <address> Phoenix, AZ, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Furthermore, the model checking capabilities of PVS described in Section 3 can be used to verify and refine tabular specifications of mode transition systems. A number of influential specification and verification methodologies are based on the use of tables <ref> [10, 17, 18, 26, 36] </ref>. There are a few special purpose tools that support the analysis of tabular specifications like SCR* [15, 16], RSML [13, 14], and Tablewise [20]. Since these tools are not attached to a general-purpose verification system, the analysis capabilities of these tools are quite limited.
Reference: 37. <author> Jens U. Skakkebk and N. Shankar. </author> <title> A Duration Calculus proof checker: Using PVS as a semantic framework. </title> <type> Technical Report SRI-CSL-93-10, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference: 38. <author> Jens Ulrik Skakkebk. </author> <title> A Verification Assistant for a Real-Time Logic. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Technical University of Denmark, Lyngby, Denmark, </institution> <month> November </month> <year> 1994. </year>
Reference: 39. <author> Mandayam K. Srivas and Steven P. Miller. </author> <title> Formal verification of the AAMP5 microprocessor. </title> <editor> In Michael G. Hinchey and Jonathan P. Bowen, editors, </editor> <booktitle> Applications of Formal Methods, Prentice Hall International Series in Computer Science, chapter 7, </booktitle> <pages> pages 125-180. </pages> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1995. </year>
Reference-contexts: PVS has been used to: Develop domain libraries for finite sets, cardinalities, bit-vectors, and reals [8]. 2 Verify challenging exercises from areas such as hardware <ref> [39] </ref>, fault-tolerant algorithms [27], real-time computing, and reactive systems [7, 19]. Embed various formalisms like the Duration Calculus [37,38], branching and linear-time modal logics [34], action systems [25], and I/O automata [1].
Reference: 40. <editor> Jan van Leeuwen, editor. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> Elsevier and MIT press, </publisher> <address> Amsterdam, The Nether-lands, and Cambridge, MA, </address> <year> 1990. </year> <month> 18 </month>
Reference-contexts: 1 Introduction There has been a dramatic proliferation of verification formalisms in recent times. Volume B of the Handbook of Theoretical Computer Science <ref> [40] </ref> takes up the bulk of nearly 1300 pages to survey a small fraction of these formalisms (e.g., ? Supported by the Air Force Office of Scientific Research under contract F49620-95-C0044 and by the National Science Foundation under contract CCR-9509931 and CCR-930044.
References-found: 40

