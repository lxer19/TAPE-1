URL: http://www.cs.berkeley.edu/~amd/CS294S97/papers/dpga_cs294.ps
Refering-URL: http://www.cs.berkeley.edu/~amd/CS294S97/reading/day25.html
Root-URL: 
Title: Multicontext Field-Programmable Gate Arrays  
Author: Andre DeHon 
Keyword: reconfigurable-components, configurable, vlsi, FPGA, technology-mapping, instructions, area efficiency,  
Note: PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL 1  Special-issue-fpga97  
Abstract: Traditional Field-Programmable Gate Arrays (FPGAs) store a single configuration context on-chip to control the device function. This organization yields a device which is efficient at performing exactly the same function at a high cycle rate. In practice, however, most FPGA resources sit idle most of the time since applications seldom need to perform precisely the same operations at the minimum cycle time possible with today's FPGAs. We generalize the FPGA structure by adding multiple, on-chip configuration contexts and data retiming support. As a result, the FPGA resources can be efficiently used to perform a number of different operations. This modification is interesting because the area required for the each additional configuration is small compared to the active area which it controls. Traditional FPGA netlists with long critical paths, low-throughput requirements, or time-varying logic can automatically be mapped into multi-context implementations which require only one-third of the area of a single-context implementation. Even greater economy may be possible when designs are crafted explicitly to exploit multicontext operation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jonathan Rose, Robert Francis, David Lewis, and Paul Chow, </author> <title> "Architecture of field-programmable gate arrays: The effect of logic block functionality on area efficiency," </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> vol. 25, no. 5, </volume> <pages> pp. 1217-1225, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: These LUTs are wired together using programmable interconnect which actually accounts for most of the area in each FPGA cell (See Figure 1). Four input lookup tables (4-LUTs) are used for the programmable processing elements in many commercial devices due to their area-efficiency <ref> [1] </ref>. Fig. 1. LUT-based FPGA Caricature A multicontext FPGA is a generalization of this FPGA model where we make c copies of the configuration memory (See Figure 2). This allows us to rapidly change the behavior of the device. Fig. 2. <p> Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] C <ref> [1] </ref> C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] <p> Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] C <ref> [1] </ref> C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage <p> 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] C <ref> [1] </ref> C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * <p> C [6] C [5] C [4] C [3] C [2] C <ref> [1] </ref> C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; <p> O [2] O <ref> [1] </ref> O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 <p> - 8 LUTs [C [3:0] pass through] i0 = !C <ref> [1] </ref> * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] <p> i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O <ref> [1] </ref> = i1 * !C [3] * C [1] + i15 ; Fig. 7. 4-LUT Mapping of ASCII Hex!Binary if (c &gt;= 0x30 && c &lt;= 0x39) else if (c &gt;= 0x40 && c &lt;= 0x46) res = c - 0x40 + 10; else if (c &gt;= 0x60 && c &lt;= <p> * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O <ref> [1] </ref> = i1 * !C [3] * C [1] + i15 ; Fig. 7. 4-LUT Mapping of ASCII Hex!Binary if (c &gt;= 0x30 && c &lt;= 0x39) else if (c &gt;= 0x40 && c &lt;= 0x46) res = c - 0x40 + 10; else if (c &gt;= 0x60 && c &lt;= 0x66) res = c - 0x60 + 10;
Reference: [2] <author> Andre DeHon, </author> <title> "Entropy, counting, and programmable interconnect," </title> <booktitle> in Proceedings of the 1996 International Symposium on Field Programmable Gate Arrays. </booktitle> <address> ACM/SIGDA, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: A base is consistent with arrays of 4096 4-LUTs. A cmem assumes the context memory for a processing element is contained in 64 SRAM bits, each taking 1200 2 of area. This entails more heavily encoded descriptions than conventional FPGAs <ref> [2] </ref>, but this encoding makes sense DEHON: MULTICONTEXT FIELD PROGRAMMABLE GATE ARRAYS 3 TABLE I Parameters and Variables Symbol Purpose c Number of configuration contexts i Depth of input retiming registers k LUT inputs (assumed 4) L Number of cycles available to perform a computation N a Number of simultaneously active <p> Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C <ref> [2] </ref> C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * <p> Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C <ref> [2] </ref> C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; <p> DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C <ref> [2] </ref> C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 <p> [5] C [4] C [3] C <ref> [2] </ref> C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 <p> [1] C [0] ; OUTORDER = O [3] O <ref> [2] </ref> O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 <p> * C <ref> [2] </ref> ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C [3],C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O [1] = i1 * !C [3] * C [1] + i15
Reference: [3] <author> Andre DeHon, </author> <title> "Reconfigurable architectures for general-purpose computing," </title> <type> AI Technical Report 1586, </type> <institution> MIT Artificial Intelligence Laboratory, 545 Technology Sq., </institution> <address> Cambridge, MA 02139, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: A input assumes each input register is a 4K 2 shift register with a 2.5K 2 switch for selecting the desired input. For more details on these model values see <ref> [3] </ref>. The most important characteristic of these numbers is their ratios (e.g. A base A cmem 10). Table I summarizes the various parameters used in this article. C. Basic Tradeoffs and Effects We have two distinct components which combine to define the requisite area for a programmable computing device: 1. <p> Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C <ref> [3] </ref> C [2] C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C <p> Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C <ref> [3] </ref> C [2] C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C <p> = C [0] * C [1] * !C [2] ; i6 = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C <ref> [3] </ref>,C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] <p> = !C [0] * C [2] ; i8 = C [0] * !C [1] ; # stage 2 - 9 LUTs [i1,C <ref> [3] </ref>,C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O [1] = i1 * !C [3] * C <p> LUTs [i1,C <ref> [3] </ref>,C [1] pass through] i5 = i0 * i1 + i3 * i4 ; i10 = C [3] + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O [1] = i1 * !C [3] * C [1] + i15 ; Fig. 7. 4-LUT Mapping of ASCII Hex!Binary if (c &gt;= 0x30 && c &lt;= 0x39) else <p> <ref> [3] </ref> + i3 * i4 ; i13 = i1 * !C [3] * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O [1] = i1 * !C [3] * C [1] + i15 ; Fig. 7. 4-LUT Mapping of ASCII Hex!Binary if (c &gt;= 0x30 && c &lt;= 0x39) else if (c &gt;= 0x40 && c &lt;= 0x46) res = c - 0x40 + 10; else if (c &gt;= <p> * !C <ref> [3] </ref> * C [2] ; i15 = i8 * i4 + i7 * i4 ; i17 = i1 * !C [3] * C [0] + C [0] * i0 * i1 ; # stage 3 - 4 LUTs O [3] = (i10+i9)*(i5+i9); O [1] = i1 * !C [3] * C [1] + i15 ; Fig. 7. 4-LUT Mapping of ASCII Hex!Binary if (c &gt;= 0x30 && c &lt;= 0x39) else if (c &gt;= 0x40 && c &lt;= 0x46) res = c - 0x40 + 10; else if (c &gt;= 0x60 && c &lt;= 0x66) res = c - <p> Note that the ratio of configuration area to base LUT area is roughly 1:20. Had the prototype used SRAM instead of DRAM, this ratio would have been closer to 1:10 as in Section II. More details on the prototype are available elsewhere <ref> [3] </ref> [6]. V. Related Devices Recently several other devices have been proposed or built which can also be viewed as multicontext FPGAs. While these were originally motivated by different goals, we see that they fit basically within the architectural framework we describe here.
Reference: [4] <author> Ellen M. Sentovich, Kanwar Jit Singh, Luciano Lavagno, Cho Moon, Rajeev Murgai, Alexander Saldanha, Hamid Savoj, DEHON: MULTICONTEXT FIELD PROGRAMMABLE GATE ARRAYS 9 Paul R. Stephan, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli, </author> <title> "Sis: A system for sequential circuit synthesis," </title> <institution> UCB/ERL M92/41, University of California, Berkeley, Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: III. Example To illustrate the opportunity and tradeoffs, consider the task of converting an ASCII Hex digit into binary. Figure 6 describes the basic computation required. Assuming we care about the latency of this operation, a mapping which minimizes the critical path length using SIS <ref> [4] </ref> and Chortle [5] has a path length of 3 4-LUTs and requires a total of 21 4-LUTs. Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] <p> path length using SIS <ref> [4] </ref> and Chortle [5] has a path length of 3 4-LUTs and requires a total of 21 4-LUTs. Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] ; i6 <p> The goal is three fold: 1. demonstrate CAD to automatically exploit multiple contexts FPGAs 2. show the benefits broadly across a benchmark set 3. identify the most promising region in the design space As with our example in Section III, netlists were mapped using SIS <ref> [4] </ref> and Chortle [5], both in area mode. No modifications have been made to this technology mapping phase to tailor for multicontext evaluation. The mapped netlist characteristics for the benchmark set are shown in Table II.
Reference: [5] <author> Robert Francis, </author> <title> Technology Mapping for Lookup-Table Based Field-Programmable Gate Arrays, </title> <type> Ph.D. thesis, </type> <institution> University of Toronto, </institution> <year> 1992. </year>
Reference-contexts: III. Example To illustrate the opportunity and tradeoffs, consider the task of converting an ASCII Hex digit into binary. Figure 6 describes the basic computation required. Assuming we care about the latency of this operation, a mapping which minimizes the critical path length using SIS [4] and Chortle <ref> [5] </ref> has a path length of 3 4-LUTs and requires a total of 21 4-LUTs. Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] C [1] C <p> the critical path length using SIS [4] and Chortle <ref> [5] </ref> has a path length of 3 4-LUTs and requires a total of 21 4-LUTs. Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C [6] C [5] C [4] C [3] C [2] C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * !C [2] <p> The goal is three fold: 1. demonstrate CAD to automatically exploit multiple contexts FPGAs 2. show the benefits broadly across a benchmark set 3. identify the most promising region in the design space As with our example in Section III, netlists were mapped using SIS [4] and Chortle <ref> [5] </ref>, both in area mode. No modifications have been made to this technology mapping phase to tailor for multicontext evaluation. The mapped netlist characteristics for the benchmark set are shown in Table II. As we have seen, the number of active LUTs needed depends on the throughput requirement.
Reference: [6] <author> Edward Tau, Ian Eslick, Derrick Chen, Jeremy Brown, and Andre DeHon, </author> <title> "A first generation dpga implementation," </title> <booktitle> in Proceedings of the Third Canadian Workshop on Field-Programmable Devices, </booktitle> <month> May </month> <year> 1995, </year> <pages> pp. 138-143. </pages>
Reference-contexts: Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C [7] C <ref> [6] </ref> C [5] C [4] C [3] C [2] C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C [1] * <p> Note that the ratio of configuration area to base LUT area is roughly 1:20. Had the prototype used SRAM instead of DRAM, this ratio would have been closer to 1:10 as in Section II. More details on the prototype are available elsewhere [3] <ref> [6] </ref>. V. Related Devices Recently several other devices have been proposed or built which can also be viewed as multicontext FPGAs. While these were originally motivated by different goals, we see that they fit basically within the architectural framework we describe here.
Reference: [7] <author> Lisa Maliniak, </author> <title> "Hardware emulation draws speed from innovative 3d parallel processing based on custom ics," </title> <booktitle> Electronic Design, </booktitle> <pages> pp. 38-41, </pages> <month> May 30 </month> <year> 1994. </year>
Reference-contexts: Figure 7 shows the LUT mapping both in equations and circuit topology. 4 PRELIMINARY VERSION|LIMIT DISTRIBUTION|CONTACT AUTHOR FOR FINAL INORDER = C <ref> [7] </ref> C [6] C [5] C [4] C [3] C [2] C [1] C [0] ; OUTORDER = O [3] O [2] O [1] O [0] ; # stage 1 - 8 LUTs [C [3:0] pass through] i0 = !C [1] * !C [2] ; i3 = C [0] * C <p> While these were originally motivated by different goals, we see that they fit basically within the architectural framework we describe here. The Hydra processor which Arkos Design's developed for their Pegasus hardware emulator <ref> [7] </ref> can be considered a close cousin to our DPGA. They integrate 32, 16-context, bit processors on each Hydra chip (N p = 32, c = 16). The logic function is an 8-input nand with programmable input inversions.
Reference: [8] <author> David Jones and David Lewis, </author> <title> "A time-multiplexed fpga architecture for logic emulation," </title> <booktitle> in Proceedings of the IEEE 1995 Custom Integrated Circuits Conference. IEEE, </booktitle> <month> May </month> <year> 1995, </year> <pages> pp. 495-498. </pages>
Reference-contexts: They integrate 32, 16-context, bit processors on each Hydra chip (N p = 32, c = 16). The logic function is an 8-input nand with programmable input inversions. VEGA <ref> [8] </ref> uses 1K-2K context memories to achieved a 7fi logic description density improvement over single context FPGAs. At c 1024, VEGA is optimized to be efficient primarily for very long cycles or low throughput and can be quite inefficient for regular, high-throughput tasks.
Reference: [9] <author> Narasimha B. Bhat, Kamal Chaudhary, and Ernest S. Kuh, </author> <title> "Performance-oriented fully routable dynamic architecture for a field programmable logic device," </title> <institution> UCB/ERL M93/42, University of California, Berkeley, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: At VEGA's design point, context memory is the dominant component of chip area, so it is not surprising that VEGA achieves a density improvement close to the 10fi ratio between active logic and descriptions. Dharma <ref> [9] </ref> was designed to solve the FPGA routing problem. Logic is evaluated in strict levels similar to the scheme used for circuit evaluation in Section VI with one gate-delay evaluation per cycle. Dharma is based on a few, monolithic crossbars which are reused at each level of logic.
Reference: [10] <author> Douglas Chang and Malgorzata Marek-Sadowska, </author> <title> "Buffer minimization and time-multiplexed i/o on dynammically reconfigurable fpgas," </title> <booktitle> in Proceedings of the International Symposium on Field Programmable Gate Arrays, </booktitle> <month> February </month> <year> 1997, </year> <pages> pp. 142-148. </pages>
Reference-contexts: Once gates have been assigned to evaluation levels, the full crossbar makes placement and routing trivial. While this arrangement is quite beneficial for small arrays, the scaling rate of the full crossbar makes this scheme less attractive for large arrays. DRFPGA <ref> [10] </ref> takes a different approach to relaxing re-timing restrictions. They insert separate buffering resource which are dedicated to retiming data. These buffers can be smaller than LUT processing elements, but still require space for routing if they are to be flexibly deployed as needed in a circuit. VI.
Reference: [11] <author> Charles Leiserson, Flavio Rose, and James Saxe, </author> <title> "Optimizing synchronous circuitry by retiming," </title> <booktitle> in Third Caltech Conference On VLSI, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: We use a simple annealing algorithm to assign non-critical path LUTs in order to minimize the number of retiming registers which must be added to the design. In hindsight, we could have performed the retiming more efficiently using Leiserson's retiming algorithm <ref> [11] </ref>. Similarly, we divide the multicontext cases into separate spatial pipeline stages such that the path length between pipeline registers is equal to the acceptable period between results. The LUTs within a phase are then evaluated in multicontext fashion using the available contexts.
References-found: 11

