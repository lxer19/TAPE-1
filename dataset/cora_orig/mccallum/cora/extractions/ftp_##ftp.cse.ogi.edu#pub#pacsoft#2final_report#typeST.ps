URL: ftp://ftp.cse.ogi.edu/pub/pacsoft/2final_report/typeST.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p2_report.html
Root-URL: http://www.cse.ogi.edu
Title: Monadic State: Axiomatization and Type Safety  
Author: John Launchbury and Amr Sabry 
Date: 6394.207  
Affiliation: Oregon Graduate Institute and University of Oregon  
Pubnum: ICFP97 PAPER  
Abstract: Type safety of imperative programs is an area fraught with difficulty and requiring great care. The ML solution to the problem, originally involving imperative type variables, has recently been simplified to the syntactic-value restriction. In Haskell, the problem is addressed in a rather different way using explicit monadic state. We present an operational semantics for state in Haskell and the first full proof of type safety. We demonstrate that the semantic notion of value provided by the explicit monadic types is sufficient to avoid any problems with generalization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Boehm, H.-J. </author> <title> Side effects and aliasing can have simple axiomatic descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 4 (Oct. </month> <year> 1985), </year> <pages> 637-655. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [2] <author> Crank, E., and Felleisen, M. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1991), </booktitle> <pages> pp. 233-244. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [3] <author> Felleisen, M., and Friedman, D. </author> <title> A calculus for assignments in higher-order languages. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1987), </booktitle> <pages> pp. 314-325. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [4] <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science 102 (1992), </booktitle> <month> 235-271. </month> <type> Technical Report 89-100, </type> <institution> Rice University. </institution>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [5] <author> Hoare, C., Hayes, I., Jifeng, H., Morgan, C., Roscoe, A., Sanders, J., Sorensen, I., Spivey, J., and Sufrin, B. </author> <title> Laws of programming. </title> <journal> Communications of the ACM 30, </journal> <volume> 8 (1987), </volume> <pages> 672-686. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [6] <author> Launchbury, J., and Peyton Jones, S. L. </author> <title> State in Haskell. </title> <booktitle> Lisp and Symbolic Computation 8 (1995), </booktitle> <pages> 193-341. </pages>
Reference-contexts: 1 Introduction When Launchbury and Peyton Jones introduced encapsulated monadic state <ref> [?, 6] </ref> it came equipped with a denotational semantics and a model-theoretic proof that different state threads did not interact with each other. The encapsulation operator runST had a type which statically guaranteed freedom of interaction, and the guarantee relied on a parametricity proof. <p> If it did, the type of the state thread would have been unified with the state type of the location in the environment, and universal quantification could not take place. Launchbury and Peyton Jones <ref> [6] </ref> showed that the intuition pans out by using a parametricity proof over the denotational semantics presented in the next section. In particular, they proved that the result of running a state thread is independent of an arbitrary encryption of the locations generated by all other state threads. <p> The proof we present in this paper is stronger, in that we show syntactic non-interference (which certainly implies the earlier behavioural non-interference), and in addition we show type safety. 2.2 Denotational Semantics The denotational semantics of the functional core is standard <ref> [6] </ref>. We present the semantics of reference cells and the state monad combinators in Figure 2. We use this semantics as the model against which our axioms are verified. <p> Through all this the type system is able to track that the threads do not interfere with each other, and that they are indeed separate state threads. 6 Other State Operations The State in Haskell paper <ref> [6] </ref> presented two other operations on the state. The first eqVar :: MutVar s a -&gt; MutVar s a -&gt; Bool which tests for equality of location introduces no difficulties to the foregoing material. The second, fixST, does.
Reference: [7] <author> Mason, I., and Talcott, C. L. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming 1, </journal> <month> 3 (July </month> <year> 1991), </year> <pages> 287-327. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [8] <author> Sabry, A., and Field, J. </author> <title> Reasoning about explicit and implicit representations of state. </title> <type> Tech. Rep. </type> <institution> RR-968, Yale University, </institution> <year> 1993. </year> <booktitle> ACM SIG-PLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 17-30. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell). <p> We begin with a fairly benign problem. In many languages it is reasonable to expect that writing a value e to a location x and then immediately reading the location x returns e <ref> [8] </ref>.
Reference: [9] <author> Swarup, V., Reddy, U., and Ireland, E. </author> <title> Assignments for applicative languages. </title> <booktitle> In Conference 9 on Functional Programming Languages and Com--puter Architecture (1991), </booktitle> <pages> pp. 192-214. </pages>
Reference-contexts: Secondly, the recursive state operator fixST cannot be interpreted naively in call-by-name, but really needs call-by-need to make sense. The interesting axioms are clearly the ones related to reference cells and the store. The axiomatization of references and stores is generally well-understood for many languages <ref> [1, 5, 3, 2, 4, 7, 9, 8] </ref>, but is fairly subtle for our language below (modelled on Haskell).
Reference: [10] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> Final version in Information and Computation 115 (1), </note> <year> 1994, </year> <pages> 38-94. 10 </pages>
Reference-contexts: Formally, e ::= : : : j sto e j p p ::= L 0 j L 1 j L 2 j : : : This term form is very similar in structure to the :e term form of Wright and Felleisen <ref> [10] </ref> though the axiomatization is rather different to take account of en capsulation. We view locations as a particular brand of term variable, with sto acting as a binding site. <p> The final version of the paper will include the details. 5 Type Soundness The type soundness proof follows very closely the subject reduction proofs by Wright and Felleisen <ref> [10] </ref>, providing extra evidence that their techniques are widely applicable. There are two cases where the proofs make very clear the role of the typings we provide, and in particular, the way in which the type rule for runST provides safe encapsulation. These cases will be done in some detail.
References-found: 10

