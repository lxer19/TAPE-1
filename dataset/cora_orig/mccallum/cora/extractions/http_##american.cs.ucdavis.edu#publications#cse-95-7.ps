URL: http://american.cs.ucdavis.edu/publications/cse-95-7.ps
Refering-URL: http://www.cs.ucdavis.edu/research/tech-reports/1995.html
Root-URL: http://www.cs.ucdavis.edu
Title: d d Reducing the Branch Penalty of Mispredicted Short Forward Branches  
Date: 8, 1995  
Note: August  1  
Abstract: Gary Tyson, Matthew Farrens, Kevin Rich and Andrew Pleszkun Technical Report No. CSE-95-7 Computer Science Department University of California, Davis, CA 95616 tel: (916) 752-7002, fax: (916) 752-4767 -tyson,farrens,rich-@cs.ucdavis.edu, arp@tosca.colorado.edu Abstract Many new high-performance microprocessor designs are incorporating much shorter clocks, deeper pipelines and increased support for multiple instruction issue. The complexities of superscalar issue, however, often require the addition of extra pipeline stages before the execution stage. Having multi-cycle decode and issue stages intensifies the problem of pipeline bubbles due to changes in control flow while branch prediction can keep the pipeline full of instructions when a branch outcome is correctly predicted, there can be a substantial penalty for flushing instructions and then restoring the proper sequence of instructions on a misprediction. In this paper, we show that a large percentage of cycles lost due to incorrectly predicted branches are caused by short forward branches, we examine the inefficiencies of pipeline flushing found in current prediction implementations, and we propose some new techniques which can reduce the branch penalty for a significant portion of mispredicted branches. Our simulation results indicate that a 5-15% reduction in the branch penalty can be achieved currently, and savings of 19-30% are possible in the future (as basic block sizes increase). 
Abstract-found: 1
Intro-found: 1
Reference: [BaGS94] <author> D. F. Bacon, S. L. Graham and O. J. Sharp, </author> <title> ``Compiler Transformations for High-Performance Computing'', </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 26, no. </volume> <month> 4 (December </month> <year> 1994), </year> <pages> pp. 345-420. </pages>
Reference-contexts: A myriad of techniques for dealing with this problem have been proposed, ranging from hardware techniques (like conditional execution and highly accurate branch prediction) to software techniques (basic block enlargement, boosting, predicated transformation, etc. <ref> [BaGS94] </ref>) For example, as superscalar processor designs have begun to increase both the number of instructions that can be issued per machine cycle and the depth of the pipeline, the importance of accurate branch prediction strategies has soared [FiFr92, LeS84, PaS92, Smit81, YeP93].
Reference: [FiFr92] <author> J. A. Fisher and S. M. Freudenberger, </author> <title> ``Predicting Conditional Branch Directions from Previous Runs of a Program'', </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Boston, MA (October 12-15, </address> <year> 1992), </year> <pages> pp. 85-95. </pages>
Reference-contexts: branch prediction) to software techniques (basic block enlargement, boosting, predicated transformation, etc. [BaGS94]) For example, as superscalar processor designs have begun to increase both the number of instructions that can be issued per machine cycle and the depth of the pipeline, the importance of accurate branch prediction strategies has soared <ref> [FiFr92, LeS84, PaS92, Smit81, YeP93] </ref>. In a machine that can issue 3 instructions per cycle and has 4 pipeline stages before the branch condition evaluation point, there are as many as 12 instructions that have been fetched and are being processed when the branch condition is evaluated.
Reference: [LeS84] <author> J. K. L. Lee and A. J. Smith, </author> <title> ``Branch Prediction Strategies and Branch Target Buffer Design'', </title> <journal> Computer, </journal> <volume> vol. 17, no. </volume> <month> 1 (January </month> <year> 1984), </year> <pages> pp. 6-22. </pages>
Reference-contexts: branch prediction) to software techniques (basic block enlargement, boosting, predicated transformation, etc. [BaGS94]) For example, as superscalar processor designs have begun to increase both the number of instructions that can be issued per machine cycle and the depth of the pipeline, the importance of accurate branch prediction strategies has soared <ref> [FiFr92, LeS84, PaS92, Smit81, YeP93] </ref>. In a machine that can issue 3 instructions per cycle and has 4 pipeline stages before the branch condition evaluation point, there are as many as 12 instructions that have been fetched and are being processed when the branch condition is evaluated.
Reference: [PaS92] <author> S. Pan, K. So and J. T. Rahmeh, </author> <title> ``Improving the Accuracy of Dynamic Branch Prediction Using Branch Correlation'', </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Boston, MA (October 12-15, </address> <year> 1992), </year> <pages> pp. 76-84. </pages>
Reference-contexts: branch prediction) to software techniques (basic block enlargement, boosting, predicated transformation, etc. [BaGS94]) For example, as superscalar processor designs have begun to increase both the number of instructions that can be issued per machine cycle and the depth of the pipeline, the importance of accurate branch prediction strategies has soared <ref> [FiFr92, LeS84, PaS92, Smit81, YeP93] </ref>. In a machine that can issue 3 instructions per cycle and has 4 pipeline stages before the branch condition evaluation point, there are as many as 12 instructions that have been fetched and are being processed when the branch condition is evaluated.
Reference: [Smit81] <author> J. E. Smith, </author> <title> ``A Study of Branch Prediction Strategies'', </title> <booktitle> Proceedings of the Eighth Annual International Symposium on Computer Architecture, </booktitle> <address> Minneapolis, Minnesota (May 1981), </address> <pages> pp. 135-148. </pages>
Reference-contexts: branch prediction) to software techniques (basic block enlargement, boosting, predicated transformation, etc. [BaGS94]) For example, as superscalar processor designs have begun to increase both the number of instructions that can be issued per machine cycle and the depth of the pipeline, the importance of accurate branch prediction strategies has soared <ref> [FiFr92, LeS84, PaS92, Smit81, YeP93] </ref>. In a machine that can issue 3 instructions per cycle and has 4 pipeline stages before the branch condition evaluation point, there are as many as 12 instructions that have been fetched and are being processed when the branch condition is evaluated. <p> This can be seen in Figure 3, which shows the average miss-prediction rate for branches of distance less than 2, 2-12, and greater than 12. The four prediction schemes presented in Figure 3 are: 2-bit Simple A simple predictor using a 2048-entry table of 2-bit counters <ref> [Smit81] </ref> 3-bit Simple A simple predictor using a 2048-entry table of 3-bit counters [Smit81] 2-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 2-bit counters [YeP91] 3-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of <p> The four prediction schemes presented in Figure 3 are: 2-bit Simple A simple predictor using a 2048-entry table of 2-bit counters <ref> [Smit81] </ref> 3-bit Simple A simple predictor using a 2048-entry table of 3-bit counters [Smit81] 2-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 2-bit counters [YeP91] 3-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 3-bit counters [YeP91] Looking at the relationship between branch penalty and branch distance
Reference: [SrWa94] <author> A. Srivastava and D. W. Wall, </author> <title> ``Atom: A system for building custonized program analysis tools'', </title> <booktitle> Proceedings of the ACM SIGPLAN Notices 1994 Conference on Programming Languages and Implementations(June 1994), </booktitle> <pages> pp. 196-205. </pages>
Reference-contexts: Branch Behavior Statistics The benchmarks used for this study were the fourteen floating point and five of the integer programs from the SPEC 92 suite of programs. Each program was compiled on an Alpha-based DEC 3000/400 workstation, using the native compiler and -O2 -non_shared compiler flags. The ATOM <ref> [SrWa94] </ref> toolkit was used to generate and help analyze the data. Table 1 shows the benchmark programs and the inputs used, and the total number of instructions, branches, and jumps executed, respectively.
Reference: [YeP91] <author> T. Yeh and Y. Patt, </author> <title> ``Two-Level Adaptive Training Branch Prediction'', </title> <booktitle> Proceedings of the 24th Annual International Symposium on Microarchitecture, </booktitle> <address> Albuquerque, New Mexico (November 18-20, </address> <year> 1991), </year> <pages> pp. 51-61. </pages>
Reference-contexts: presented in Figure 3 are: 2-bit Simple A simple predictor using a 2048-entry table of 2-bit counters [Smit81] 3-bit Simple A simple predictor using a 2048-entry table of 3-bit counters [Smit81] 2-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 2-bit counters <ref> [YeP91] </ref> 3-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 3-bit counters [YeP91] Looking at the relationship between branch penalty and branch distance reveals that a very large portion of the penalty comes from these branches. <p> A simple predictor using a 2048-entry table of 3-bit counters [Smit81] 2-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 2-bit counters <ref> [YeP91] </ref> 3-bit Adaptive An adaptive 2-level predictor using a 13-bit pattern history table and a 2048-entry table of 3-bit counters [YeP91] Looking at the relationship between branch penalty and branch distance reveals that a very large portion of the penalty comes from these branches.
Reference: [YeP93] <author> T. Yeh and Y. Patt, </author> <title> ``A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History'', </title> <booktitle> Proceedings of the Twentieth Annual International Symposium on Computer Architecture, </booktitle> <address> San Diego, CA (May 16-19, </address> <year> 1993), </year> <pages> pp. 257-266. </pages> <address> d d </address>
Reference-contexts: branch prediction) to software techniques (basic block enlargement, boosting, predicated transformation, etc. [BaGS94]) For example, as superscalar processor designs have begun to increase both the number of instructions that can be issued per machine cycle and the depth of the pipeline, the importance of accurate branch prediction strategies has soared <ref> [FiFr92, LeS84, PaS92, Smit81, YeP93] </ref>. In a machine that can issue 3 instructions per cycle and has 4 pipeline stages before the branch condition evaluation point, there are as many as 12 instructions that have been fetched and are being processed when the branch condition is evaluated.
References-found: 8

