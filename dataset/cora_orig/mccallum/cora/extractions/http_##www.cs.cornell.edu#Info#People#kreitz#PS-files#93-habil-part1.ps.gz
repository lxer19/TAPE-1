URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/93-habil-part1.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/papers.html
Root-URL: http://www.cs.cornell.edu
Title: M E T A SYNTHESIS Deriving Programs that Develop Programs  
Author: Christoph Kreitz 
Abstract-found: 0
Intro-found: 1
Reference: [ACHA90] <author> Stuart F. Allen, Robert L. Constable, Douglas J. Howe, and William E. Aitken. </author> <title> The semantics of reflected proof. </title> <editor> In John C. Mitchell, editor, </editor> <booktitle> LICS-90 | Proceedings of the Fifth Annual Symposium on Logic in Computer Science, 1990, </booktitle> <address> Philadelphia, PA, </address> <month> June </month> <year> 1990, </year> <pages> pages 95-106. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference: [All87] <author> Stuart Allen. </author> <title> A non-type-theoretic definition of Martin-Lof's types. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 215-224. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference: [And86] <author> Peter B. Andrews. </author> <title> An Introduction to mathematical logic and Type Theory: To Truth through Proof. </title> <publisher> Academic Press, </publisher> <address> London, Orlando, </address> <year> 1986. </year>
Reference: [AW80] <author> Luigia Aiello and Richard W. Weyhrauch. </author> <title> Using meta-theoretic reasoning to do algebra. </title> <editor> In W.Bibel and R. Kowalski, editors, </editor> <booktitle> Proceedings of the 5 th Conference on Automated Deduction, Les Arcs, </booktitle> <address> France, </address> <month> July </month> <year> 1980, </year> <booktitle> number 87 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-11. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1980. </year>
Reference: [B + 88] <editor> F. L. Bauer et al. </editor> <booktitle> The Munich Project CIP: Volume II, volume 292 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference: [Bac85] <author> Roland C. Backhouse. </author> <title> Algorithm development in Martin-Lof's Type Theory. </title> <type> Technical report, </type> <institution> Computer Science Department, University of Essex, </institution> <address> England, </address> <year> 1985. </year>
Reference: [Bac88] <author> R.-J. </author> <title> Back. A calculus of refinements for program derivations. </title> <journal> Acta Informatica, </journal> <volume> 25 </volume> <pages> 593-624, </pages> <year> 1988. </year>
Reference: [Bac89] <author> Roland C. Backhouse. </author> <title> Constructive Type Theory an introduction. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computer Science, volume 55 of NATO ASI Series, Series F: Computer & System Sciences, </booktitle> <pages> pages 9-62. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference: [Bal85] <author> Robert Balzer. </author> <title> A 15 year perspective on automatic programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(11):1257-1268, </volume> <month> November </month> <year> 1985. </year>
Reference: [Bar79] <author> David R. Barstow. </author> <title> Knowledge-Based Program Construction. </title> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: For simple data structures standard implementations provided by compilers are very efficient. However, when it comes to high-level or abstract data types, standard solutions cease being satisfactory. Syntheses thus involve not only control decisions, but also data structure selection <ref> [Bar79, SSS81] </ref>. 5.4. DERIVING STRATEGIES FROM HIGHER-ORDER SPECIFICATIONS 99 The difficulty is that complex data types can be implemented in many different ways. Sets, for instance, may be represented by lists, arrays, trees, bit-patterns, etc.
Reference: [Bar81] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus. Its syntax and semantics, </title> <booktitle> volume 103 of Studies in Logic and The Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year> <note> (revised version 1984). </note>
Reference: [Bas89] <author> David A. Basin. </author> <title> Building theories in NuPRL. </title> <editor> In A. R. Meyer and M. A. Taitslin, editors, </editor> <booktitle> Logic at Botik 89, number 363 in Lecture Notes in Computer Science, </booktitle> <pages> pages 12-25. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference: [Bau79] <author> M. A. Bauer. </author> <title> Programming by examples. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 1-21, </pages> <year> 1979. </year>
Reference: [BBD + 81] <author> F. L. Bauer, Manfred Broy, W. Dosch, R. Gnatz, B. Krieg-Bruckner, A. Laut, M. Luckmann, T. Matzner, B. Moller, H. Partsch, P. Pepper, K. Samelson, R. Steinbrucken, M. Wirsing, and H. Wossner. </author> <title> Programming in a wide spectrum language: a collection of examples. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 1 </volume> <pages> 73-114, </pages> <year> 1981. </year> <note> 103 104 BIBLIOGRAPHY </note>
Reference: [BC85] <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference: [BC91] <author> David A. Basin and Robert L. Constable. </author> <title> Metalogical frameworks. </title> <booktitle> In Procedings of the second Workshop on Logical Frameworks, </booktitle> <address> Edinburgh, Scotland, </address> <year> 1991. </year>
Reference: [BCjG83] <author> Robert Balzer, T. E. Cheatham jr, and Cordell Green. </author> <title> Software technology in the 1990's: Using a new paradigm. </title> <booktitle> Computer, </booktitle> <pages> pages 39-45, </pages> <month> November </month> <year> 1983. </year>
Reference: [BCM88a] <author> Roland C. Backhouse, P. Chisholm, and Grant Malcolm. </author> <title> Do it yourself type theory (part I). </title> <journal> EATCS Bulletin, </journal> <volume> 34 </volume> <pages> 68-110, </pages> <year> 1988. </year> <note> Also in Formal aspects of computing </note> 1:19-84, 1989. 
Reference: [BCM88b] <author> Roland C. Backhouse, P. Chisholm, and Grant Malcolm. </author> <title> Do it yourself type theory (part II). </title> <journal> EATCS Bulletin, </journal> <volume> 35 </volume> <pages> 205-245, </pages> <year> 1988. </year>
Reference: [BD77] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference: [Bea87] <editor> D. Bjorner and et. al., editors. </editor> <booktitle> VDM '87: A formal method at Work First International Symposium of VDM Europe, </booktitle> <address> Brussels, Belgium, </address> <year> 1987, </year> <booktitle> volume 252 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1987. </year>
Reference: [BEN88] <editor> D. Bjorner, A.P. Ershov, and N.D.Jones, editors. </editor> <title> Partial evaluation and mixed computation. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: (conditionally) equal or equivalent expressions according to given laws can easily be justified (only make sure that in every step the precondition for applying the substitution is checked) automating the simplification procedure requires the laws to be directed and a very efficient organization of the knowledge base. * Partial evaluation <ref> [BEN88] </ref> or specialization [Sch81] means evaluating subexpressions whose arguments are in a fixed form such as the empty sequence, singleton sequences, or fixed numbers.
Reference: [BF82] <author> Avron Barr and Edward A. Feigenbaum. </author> <booktitle> Handbook of Artificial Intelligence, volume II. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1982. </year>
Reference: [BFS78] <author> Wolfgang Bibel, Ulrich Furbach, and J. F. Schreiber. </author> <title> Strategies for the synthesis of algorithms. </title> <editor> In K. Alber, editor, </editor> <booktitle> Proceedings 5th GI Conference on Programming Languages, number 12 in Informatik Fachberichte, </booktitle> <pages> pages 97-109, </pages> <address> Berlin, 1978. </address> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York. </address>
Reference-contexts: Instead it is a Goal-Oriented-Transformation | a strategy which tries to achieve a certain goal (recursion) by means of equivalence-preserving transformations which are created during a derivation. Unfortunately, an exact formulation of GET-REC's goal is missing in the literature written on LOPS so far <ref> [BFS78, Bib80, Fro84, Neu92] </ref>. Also the meaning of "information about possible kinds of recursion" is nowhere being made precise. In order to close this 4.1. <p> Cardinality arguments (see [Bib80, page 255]) play an important role in the process. 4.1.4.5 DEPEND Immediately after CHVAR has decided which part of the output should be guessed first the strategy DEPEND (see <ref> [BFS78] </ref>) will explore the dependencies between the first guess and the remaining output values. It attempts to find the maximal requirements on an output variable in question (usually the maximal subset of conjuncts containing it) which are satisfiable also for a failing guess of the higher problem.
Reference: [BG90] <author> Lee Blaine and Allen Goldberg. </author> <title> Verifiably correct data type refinement. </title> <type> Technical report, </type> <institution> Kestrel Institute, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Depending on the mix of operations occurring in an algorithm one representation may be more efficient than another and no single default implementation will give good performance for all occurrences of an abstract type. Thus it is necessary to provide tools for verifiably correct data type refinement <ref> [BG90] </ref>. As formal foundation for such tools we may use the concept of abstract theories and their models which we have formalized in section 3.3.1. The final step of a synthesis is a translation of a mathematically described algorithm (including data structure selections) into a given target language.
Reference: [BGK84] <author> Alan W. Biermann, G. Guiho, and Y. Kodratoff, </author> <title> editors. Automatic program construction techniques. </title> <publisher> MacMillan Pub. Co., </publisher> <year> 1984. </year>
Reference: [BH84] <author> Wolfgang Bibel and K. M. Hornig. </author> <title> LOPS a system based on a strategical approach to program synthesis. </title> <editor> In Alan W. Biermann, G. Guiho, and Y. Kodratoff, editors, </editor> <title> Automatic program construction techniques, </title> <booktitle> chapter 3, </booktitle> <pages> pages 69-89. </pages> <publisher> MacMillan, </publisher> <address> New York, </address> <year> 1984. </year>
Reference: [BHL90] <editor> D. Bjorner, C. A. R. Hoare, and H. Langmaack, editors. </editor> <booktitle> VDM '90: VDM and Z Formal methods in software development 3rd International Symposium of VDM Europe, </booktitle> <address> Kiel, Germany, </address> <month> April </month> <year> 1990, </year> <booktitle> volume 428 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [Bib78] <author> Wolfgang Bibel. </author> <title> On strategies for the synthesis of algorithms. </title> <editor> In D. Sleeman, editor, </editor> <booktitle> Proceedings of AISB/GI Conference on Artificial Intelligence, </booktitle> <address> Leeds University, England, </address> <pages> pages 22-27, </pages> <year> 1978. </year>
Reference: [Bib80] <author> Wolfgang Bibel. </author> <title> Syntax-directed, semantics-supported program synthesis. </title> <journal> Artificial Intelligence, </journal> <volume> 14(3) </volume> <pages> 243-261, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: They do not say anything about improvements after guessing. In particular, the right choice of DC is crucial to the success of the synthesis and the efficiency of the result (see [Neu92] for examples). Following the spirit of <ref> [Bib80, page 251] </ref> we can put certain restrictions on the choice of G, DC, and t. The data type G represents those parts of the output that are displayable at a time and t relates an output value with its displayable part. <p> I (x) ^ O (x,y) ^ t (g,y) ) DC (x,g) Thus O must imply DC if t is equality, which usually is ensured by choosing DC from among the conjuncts in O as proposed in <ref> [Bib80, pages 246-247] </ref>. A second restriction on DC comes from the requirement that it must lead to a satisfiable specification. Otherwise applying the GUESS transformation would lead into a dead end in the synthesis process. Therefore domain predicates which can easily be checked to be satisfiable will be preferred. <p> REPRESENTING EXISTING APPROACHES 4.1.2 Postprocessing after GUESS-DOMAIN Immediately after applying the GUESS-transformation a postprocessing step is applied to separate a successful guess from an unsuccessful one. This strategy, which is called GET-DNF in <ref> [Bib80] </ref>, takes the result of GUESS, distributes the tautology over the conjunction, and introduces subproblems for further consideration. <p> Instead it is a Goal-Oriented-Transformation | a strategy which tries to achieve a certain goal (recursion) by means of equivalence-preserving transformations which are created during a derivation. Unfortunately, an exact formulation of GET-REC's goal is missing in the literature written on LOPS so far <ref> [BFS78, Bib80, Fro84, Neu92] </ref>. Also the meaning of "information about possible kinds of recursion" is nowhere being made precise. In order to close this 4.1. <p> In order to close this 4.1. LOPS TRANSFORMATIONAL SYNTHESIS 73 gap we have to abandon complete faithfulness to the original LOPS-literature and shall attempt to fill in details which follow the spirit of LOPS. Remarks in <ref> [Bib80, pages 247-248] </ref> and the example syntheses described so far suggest the following: A scheme for introducing recursion must contain as essential component a decreasing function which operates on the domain of the specification and the type of the guess-variable and depends only on the structure of the data types involved. <p> Most of them are already mentioned in <ref> [Bib80] </ref> and have received names while other steps came up during the implementation of LOPS. In this section we shall briefly describe these steps. <p> For this purpose the heuristic DOMAIN is extended by another heuristic CHVAR which chooses the output-variable for which guessing will be executed first. Cardinality arguments (see <ref> [Bib80, page 255] </ref>) play an important role in the process. 4.1.4.5 DEPEND Immediately after CHVAR has decided which part of the output should be guessed first the strategy DEPEND (see [BFS78]) will explore the dependencies between the first guess and the remaining output values. <p> We have formalized semantic knowledge contained in existing strategies and shown that such a formalization is useful for representing, refining, improving, and implementing deductive methods. In particular we have represented the kernel of the LOPS-approach to program synthesis <ref> [Bib80] </ref> which so far has been described rather vaguely. In the process of formalizing the design strategy for global search algorithms used in the KIDS system [Smi87c, Smi91a] we have discovered a small gap and shown how to close it. <p> to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS <ref> [Bib80] </ref>. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory. Further programming knowledge worth being studied is contained in research on methodologies [Dij76, Gri81, Wir71] which has not yet been automated.
Reference: [Bib83] <author> Wolfgang Bibel. </author> <title> Matings in matrices. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 26(11) </volume> <pages> 844-852, </pages> <month> November </month> <year> 1983. </year>
Reference: [Bib84] <author> Wolfgang Bibel. </author> <title> Automatic programming. </title> <editor> In Tim O'Shea, editor, </editor> <booktitle> ECAI-84 | Proceedings of the 6 th European Conference on Artificial Intelligence, </booktitle> <address> Pisa, Italy, </address> <month> September </month> <year> 1984, </year> <pages> page 561. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <year> 1984. </year>
Reference: [Bib91] <author> Wolfgang Bibel. </author> <title> Toward predicative programming. </title> <editor> In Michael R. Lowry and Robert Mc-Cartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 405-424, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. BIBLIOGRAPHY 105 </publisher>
Reference: [Bie72] <author> Alan W. Biermann. </author> <title> On the inference of Turing Machines from sample computations. </title> <journal> Artificial Intelligence, </journal> <volume> 3 </volume> <pages> 181-198, </pages> <year> 1972. </year>
Reference: [Bie78] <author> Alan W. Biermann. </author> <title> The inference of regular LISP programs from examples. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> SMC-8:585-600, </volume> <year> 1978. </year>
Reference: [BJ82] <author> D. Bjorner and C. B. Jones. </author> <title> Formal Specification and Software Development. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1982. </year>
Reference: [Bjo89] <author> Dines Bjorner. </author> <title> Towards a meaning of 'M' in VDM. </title> <editor> In J. Diaz and F. Orejas, editors, </editor> <booktitle> TAPSOFT '89 Proceedings of the International Joint Conference on Theory and Practice of Software Development, </booktitle> <address> Barcelona, Spain, </address> <month> March </month> <year> 1989, </year> <booktitle> number 352 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-35. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference: [BK76] <author> Alan W. Biermann and R. Krishnaswamy. </author> <title> Constructing programs from example computations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2:141-153, </volume> <year> 1976. </year>
Reference: [BMJ88] <editor> R. Bloomfield, L. Marshall, and R. Jones, editors. </editor> <booktitle> VDM '88: VDM The Way ahead Second International Symposium of VDM Europe, Dublin, Ireland, 1988, volume 328 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference: [BMMO86] <author> P. Bresciani, P. Miglioli, U. Moscato, and M. Ornaghi. Pap: </author> <title> Proofs as programs - (abstract). </title> <journal> Journal of Symbolic Logic, </journal> <volume> 51(3) </volume> <pages> 852-853, </pages> <year> 1986. </year>
Reference: [BP81] <author> Manfred Broy and Peter Pepper. </author> <title> Program development as a formal activity. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(1):14-22, </volume> <month> January </month> <year> 1981. </year>
Reference: [Bru80] <author> N. G. De Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J.P. Seldin and J.R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <address> London, New York, </address> <year> 1980. </year>
Reference: [BS79] <author> Alan W. Biermann and Douglas R. Smith. </author> <title> A production rule mechanism for generating LISP code. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> SMC-9:260-276, </volume> <month> May </month> <year> 1979. </year>
Reference: [BSW90] <author> A. Bundy, A. Smaill, and G. Wiggins. </author> <title> The synthesis of logic programs from inductive proofs. </title> <booktitle> In Computer Logic Proceedings, </booktitle> <address> Brussels. </address> <publisher> SPRINGER, </publisher> <year> 1990. </year>
Reference-contexts: chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods <ref> [Bun89, BSW90] </ref>, and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory. Further programming knowledge worth being studied is contained in research on methodologies [Dij76, Gri81, Wir71] which has not yet been automated.
Reference: [Bun88] <author> Alan Bundy. </author> <title> The use of explicit plans to guide inductive proofs. </title> <editor> In E. Lusk and R. Oberbeek, editors, </editor> <booktitle> Proceedings of the 9 th Conference on Automated Deduction, </booktitle> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988, </year> <pages> pages 111-120, </pages> <year> 1988. </year>
Reference: [Bun89] <author> Alan Bundy. </author> <title> Automatic guidance of program synthesis proofs. </title> <booktitle> In Proceedings of the Workshop on Automating Software Design, IJCAI-89, Kestrel Institute, </booktitle> <address> Palo Alto, </address> <pages> pages 57-59, </pages> <year> 1989. </year>
Reference-contexts: chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods <ref> [Bun89, BSW90] </ref>, and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory. Further programming knowledge worth being studied is contained in research on methodologies [Dij76, Gri81, Wir71] which has not yet been automated.
Reference: [BvHHS90] <author> Alan Bundy, Frank van Harmelen, Christian Horn, and Alan Smaill. </author> <title> The Oyster-Clam system. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10 th Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1990, </year> <booktitle> volume 449 of Lecture Notes in Computer Science, </booktitle> <pages> pages 647-648. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [BvHS91] <author> A. Bundy, F. van Harmelen, J. Hesketh, and A. Smaill. </author> <title> Experiments with proof plans for induction. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7 </volume> <pages> 303-324, </pages> <year> 1991. </year>
Reference: [BvHSI90] <author> Alan Bundy, F. van Harmelen, A. Smaill, and A. Ireland. </author> <title> Extensions to the rippling-out tactic for guiding inductive proofs. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10 th Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1990, </year> <pages> pages 132-146, </pages> <year> 1990. </year>
Reference: [CAB + 86] <author> Robert L. Constable, Stuart F. Allen, H. Mark Bromley, W. Rance Cleaveland, J. F. Cremer, Robert W. Harper, Douglas J. Howe, Todd B. Knoblock, Nax Paul Mendler, Prakash Panan-gaden, Jim T. Sasaki, and Scott F. Smith. </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year> <note> 106 BIBLIOGRAPHY </note>
Reference-contexts: Thirdly, it is completely formal, which means that all the definitions and theorems presented here can directly be realized on a proof development system for the underlying calculus. We have built our formal theory by extending an existing formal calculus (the type theory of NuPRL <ref> [CAB + 86] </ref>) by concepts for reasoning on a higher level of abstraction. We have formalized knowledge about several domains of application as well as the fundamental programming concepts such as specifications, programs, and their correctness.
Reference: [CD80] <author> Keith L. Clark and John Darlington. </author> <title> Algorithm classification through synthesis. </title> <journal> The Computer Journal, </journal> <volume> 23(1) </volume> <pages> 61-65, </pages> <year> 1980. </year>
Reference: [CFC58] <author> Haskell B. Curry, R. Feys, and W. Craig. </author> <booktitle> Combinatory Logic, </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference: [CH85] <author> Thierry Coquand and Gerard Huet. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In EUROCAL'85, </booktitle> <pages> pages 151-184, </pages> <address> Linz, Austria, </address> <month> April </month> <year> 1985. </year>
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference: [CH90a] <author> Robert L. Constable and Douglas J. Howe. </author> <title> Implementing metamathematics as an approach to automatic theorem proving. </title> <editor> In R. B. Banerjee, editor, </editor> <booktitle> Formal techniques in Artificial Intelligence, a sourcebook, </booktitle> <pages> pages 45-75. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <year> 1990. </year>
Reference: [CH90b] <author> Robert L. Constable and Douglas J. Howe. </author> <title> Nuprl as a general logic. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 77-90. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1990. </year>
Reference: [Chi87] <author> Paul Chisholm. </author> <title> Derivation of a parsing algorithm in Martin-Lof's Type Theory. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 1-42, </pages> <year> 1987. </year>
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference: [CJE82] <author> Robert L. Constable, Scott D. Johnson, and Carl D. Eichenlaub. </author> <title> Introduction to the PL/CV2 Programming Logic, </title> <booktitle> volume 135 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1982. </year>
Reference: [CKB85] <author> Robert L. Constable, Todd B. Knoblock, and Joseph L. Bates. </author> <title> Writing programs that construct proofs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1 </volume> <pages> 285-326, </pages> <year> 1985. </year>
Reference: [Cla77] <author> Keith L. Clark. </author> <title> The synthesis and verification of logic programs. </title> <type> Technical report, </type> <institution> Department of Computing and Control, Imperial College of Science and Technology, </institution> <address> London, England, </address> <month> June </month> <year> 1977. </year>
Reference: [Cle87] <author> Walter Rance Cleaveland. </author> <title> Type-theoretic models of concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <year> 1987. </year> <type> TR 87-837. </type>
Reference: [CM85] <author> Robert L. Constable and Nax Paul Mendler. </author> <title> Recursive definitions in Type Theory. </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Proceedings of the Logics of Programs Conference, </booktitle> <address> Brooklyn, NY, USA, </address> <month> June </month> <year> 1985, </year> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 61-78. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1985. </year>
Reference: [Con72] <author> Robert L. Constable. </author> <title> Constructive mathematics and automatic program writers. </title> <booktitle> In Information Processing 71, </booktitle> <pages> pages 229-233. </pages> <publisher> IFIP, North-Holland, </publisher> <address> Amsterdam, </address> <year> 1972. </year>
Reference: [Con83] <author> Robert L. Constable. </author> <title> Programs as proofs. </title> <journal> Information Processing Letters, </journal> <volume> 16(3) </volume> <pages> 105-112, </pages> <year> 1983. </year>
Reference: [Con84] <author> Robert L. Constable. </author> <note> Mathematics as programming. </note> <editor> In Edmund Clarke and Dexter Kozen, editors, </editor> <booktitle> Logics of Programs, number 164 in Lecture Notes in Computer Science, </booktitle> <pages> pages 116-128. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1984. </year>
Reference: [Con89] <author> Robert L. Constable. </author> <title> Assigning meaning to proofs: a semantic basis for problem solving environments. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Constructive Methods in Computer Science, volume 55 of NATO ASI Series, Series F: Computer & System Sciences, </booktitle> <pages> pages 63-94. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference: [Coq90] <author> Thierry Coquand. </author> <title> Metamathematical investigations of a calculus of constructions. </title> <editor> In Pier-giorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 91-122. </pages> <publisher> Academic Press, </publisher> <address> Lon-don, </address> <year> 1990. </year> <note> BIBLIOGRAPHY 107 </note>
Reference: [Cos84] <author> J. </author> <title> Costas. A study of a class of detection waveforms having nearly ideal range doppler amibiguity properties. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <volume> volume 72, </volume> <pages> pages 996-1009, </pages> <year> 1984. </year>
Reference-contexts: Example 4.2.17 Synthesis of an Algorithm enumerating Costas Arrays In <ref> [Cos84] </ref>, Costas introduced a class of permutations that can be used to generate radar and sonar signals with ideal ambiguity functions. Since then, many publications have investigated combinatorial properties of these permutations, now known as Costas arrays.
Reference: [CS77] <author> Keith L. Clark and S. Sickel. </author> <title> Predicate logic: A calculus for the formal derivation of programs. </title> <editor> In Raj Reddy, editor, </editor> <booktitle> IJCAI-77 | Proceedings of the 5 th International Joint Conference on Artificial Intelligence, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1977, </year> <pages> pages 419-420. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1977. </year>
Reference: [CS87] <author> Robert L. Constable and Scott Fraser Smith. </author> <title> Partial objects in constructive Type Theory. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 183-193. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference: [CS88] <author> Robert L. Constable and Scott Fraser Smith. </author> <title> Computational foundations of basic recursive function theory. </title> <editor> In Yuri Gurevich, editor, </editor> <booktitle> LICS-88 | Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <address> Edinburgh, Scotland, </address> <month> July </month> <year> 1988, </year> <pages> pages 360-371. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference: [Dar75] <author> John Darlington. </author> <title> Application of program transformation to program synthesis. </title> <booktitle> In IRIA Symposium on Proving and Improving programs, </booktitle> <pages> pages 133-144, </pages> <address> Arc-et-Senans, France, </address> <year> 1975. </year>
Reference: [Dar78] <author> John Darlington. </author> <title> A synthesis of several sorting algorithms. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 1-30, </pages> <year> 1978. </year>
Reference: [Dar81a] <author> John Darlington. </author> <title> An experimental program transformation and synthesis system. </title> <journal> Artificial Intelligence, </journal> <volume> 16(1) </volume> <pages> 1-46, </pages> <month> March </month> <year> 1981. </year>
Reference: [Dar81b] <author> John Darlington. </author> <title> The structured description of algorithm derivations. </title> <editor> In De Bakker and van Vliet, editors, </editor> <booktitle> Algorithmic Languages, </booktitle> <pages> pages 221-250, </pages> <address> Amsterdam, 1981. </address> <publisher> IFIP, North-Holland, Amsterdam. </publisher>
Reference: [DDH72] <author> O.-J. Dahl, Edsger W. Dijkstra, </author> <title> and C.A.R. Hoare. Structured Programming, </title> <booktitle> volume 8 of A.P.I.C. Studies in Data Processing. </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1972. </year>
Reference: [Der85a] <author> Nachum Dershowitz. </author> <title> Synthesis by completion. </title> <editor> In A. Joshi, editor, </editor> <booktitle> IJCAI-85 | Proceedings of the 9 th International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, </address> <month> August </month> <year> 1985, </year> <pages> pages 208-214, </pages> <year> 1985. </year>
Reference: [Der85b] <author> Nachum Dershowitz. </author> <title> Synthetic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 323-373, </pages> <year> 1985. </year>
Reference: [Dij68] <author> Edsger W. Dijkstra. </author> <title> A constructive approach to the problem of software correctness. </title> <journal> BIT, </journal> <volume> 8 </volume> <pages> 174-186, </pages> <year> 1968. </year>
Reference: [Dij76] <author> Edsger W. Dijkstra. </author> <title> A discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference-contexts: In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory. Further programming knowledge worth being studied is contained in research on methodologies <ref> [Dij76, Gri81, Wir71] </ref> which has not yet been automated. The method for formalizing these approaches is always the same: one has to identify the key operations and the parameters they depend on and prove formal meta-theorems about them.
Reference: [DP90] <author> Nachum Dershowitz and Eli Pinchover. </author> <title> Inductive synthesis of equational programs. </title> <booktitle> In AAAI-90 | Proceedings of the 9 th AAAI National Conference on Artificial Intelligence, </booktitle> <pages> pages 234-239. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1990. </year>
Reference: [DS79] <author> M. Davis and J. T. Schwartz. </author> <title> Metamathematical extensibility for theorem verifiers and proof checkers. </title> <journal> Computers and Mathematics with Applications, </journal> <volume> 5 </volume> <pages> 217-230, </pages> <year> 1979. </year>
Reference: [Ehr82] <author> H.-D. Ehrich. </author> <title> On the theory of specification, implementation, and parametrization of abstract data types. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 29(1) </volume> <pages> 206-227, </pages> <month> January </month> <year> 1982. </year>
Reference: [Eus91] <author> Jutta Eusterbrock. </author> <title> Speed-up transformations of logic programs by abstraction and learning. </title> <booktitle> In Proceedings of the LOPSTR'91 Workshop, </booktitle> <year> 1991. </year>
Reference: [Eus92] <author> Jutta Eusterbrock. </author> <title> Wissensbasierte Verfahren zur Synthese mathematischer Beweise: Eine kombinatorische Anwendung. </title> <type> PhD thesis, </type> <institution> Fakultat fur Informatik der Universitat Stuttgart, </institution> <month> January </month> <year> 1992. </year> <note> 108 BIBLIOGRAPHY </note>
Reference: [Fea86] <author> Martin S. Feather. </author> <title> A survey and classification of some program transformation approaches and techniques. </title> <type> Technical report, </type> <institution> USC, Information Sciences Institute, Marina del Rey, </institution> <address> CA,, </address> <year> 1986. </year>
Reference: [FF86] <author> Bertram Fronhofer and Ulrich Furbach. </author> <title> Knuth-Bendix completion versus fold/unfold: a comparative study in program synthesis. </title> <editor> In C. Rollinger and W. Horn, editors, </editor> <booktitle> GWAI-86 | Proceedings of the 10 th German Workshop on Artificial Intelligence, 1986, number 124 in Informatik Fachberichte, </booktitle> <pages> pages 289-300. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1986. </year>
Reference: [FK91] <author> Marta Franova and Yves Kodratoff. </author> <title> Solving "How to clear a block" with constructive matching methodology. </title> <booktitle> In IJCAI-91 | Proceedings of the 12 th International Joint Conference on Artificial Intelligence, Sidney, </booktitle> <month> August </month> <year> 1991, </year> <pages> pages 232-237. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1991. </year>
Reference: [FK92] <author> Marta Franova and Yves Kodratoff. </author> <title> Predicate synthesis from formal specifications. </title> <editor> In B. Neumann, editor, </editor> <booktitle> ECAI-92 | Proceedings of the 10 th European Conference on Artificial Intelligence, </booktitle> <address> Vienna, Austria, </address> <month> August </month> <year> 1992, </year> <pages> pages 87-91. </pages> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1992. </year>
Reference-contexts: In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching <ref> [Fra85b, FK92] </ref>, proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory.
Reference: [Flo67] <author> R. W. Floyd. </author> <title> Assigning meaning to programs. </title> <booktitle> Proceedings of the Symposia in Applied Mathematics, </booktitle> <volume> 19 </volume> <pages> 19-32, </pages> <year> 1967. </year>
Reference: [FM88] <author> Amy Felty and Dale Miller. </author> <title> Specifying theorem provers in a higher-order logic programming language. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proceedings of the 9 th Conference on Automated Deduction, </booktitle> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988, </year> <booktitle> volume 310 of Lecture Notes in Computer Science, </booktitle> <pages> pages 61-80. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference: [FM90] <author> Amy Felty and Dale Miller. </author> <title> Encoding a dependent-type -calculus in a logic programming language. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10 th Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1990, </year> <booktitle> volume 449 of Lecture Notes in Computer Science, </booktitle> <pages> pages 221-235. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [Fra84] <author> Marta Franova. </author> <title> CM strategy- driven deductions for automatic programming. </title> <editor> In Tim O'Shea, editor, </editor> <booktitle> ECAI-84 | Proceedings of the 6 th European Conference on Artificial Intelligence, </booktitle> <address> Pisa, Italy, </address> <month> September </month> <year> 1984, </year> <pages> pages 573-576. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <year> 1984. </year>
Reference: [Fra85a] <author> Marta Franova. CM-strategy: </author> <title> A methodology for inductive theorem proving or constructive well-generalized proofs. </title> <editor> In Aravind Joshi, editor, </editor> <booktitle> IJCAI-85 | Proceedings of the 9 th International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, </address> <month> August </month> <year> 1985, </year> <pages> pages 1214-1220. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1985. </year>
Reference: [Fra85b] <author> Marta Franova. </author> <title> A methodology for automatic programming based on the constructive matching strategy. </title> <booktitle> In EUROCAL 85, </booktitle> <pages> pages 568-570. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1985. </year>
Reference-contexts: In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching <ref> [Fra85b, FK92] </ref>, proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory.
Reference: [Fri90] <author> L. </author> <title> Fribourg. Extracting logic programs from proofs that use extended PROLOG execution and induction. </title> <booktitle> In Proceedings of the 7th International Conference on Logic Programming, Jerusalem, </booktitle> <pages> pages 685-699. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [Fro84] <author> Bertram Fronhofer. </author> <title> Heuristics for recursion improvement. </title> <editor> In Tim O'Shea, editor, </editor> <booktitle> ECAI-84 | Proceedings of the 6 th European Conference on Artificial Intelligence, </booktitle> <address> Pisa, Italy, </address> <month> Sep-tember </month> <year> 1984, </year> <pages> pages 577-580. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland) Amsterdam, </publisher> <year> 1984. </year>
Reference-contexts: Instead it is a Goal-Oriented-Transformation | a strategy which tries to achieve a certain goal (recursion) by means of equivalence-preserving transformations which are created during a derivation. Unfortunately, an exact formulation of GET-REC's goal is missing in the literature written on LOPS so far <ref> [BFS78, Bib80, Fro84, Neu92] </ref>. Also the meaning of "information about possible kinds of recursion" is nowhere being made precise. In order to close this 4.1.
Reference: [Fro85] <author> Bertram Fronhofer. </author> <title> The LOPS-approach: Towards new syntheses of algorithms. </title> <editor> In H. Trost and J. Retti, editors, </editor> <booktitle> Osterreichische AI Tagung, </booktitle> <pages> pages 164-172. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1985. </year>
Reference: [Gal90] <editor> Didier Galmiche. </editor> <title> Constructive system for automatic program synthesis. </title> <journal> Theoretical Computer Science, </journal> <volume> 71 </volume> <pages> 227-239, </pages> <year> 1990. </year> <note> BIBLIOGRAPHY 109 </note>
Reference: [Gal91] <author> Jean Gallier. </author> <title> Constructive logics. Part II: Linear logics and proof nets. </title> <type> Technical Report 9, </type> <institution> Digital Equipment Corporation, </institution> <month> May </month> <year> 1991. </year>
Reference: [GB78] <author> C.C. Green and D.R. Barstow. </author> <title> On program synthesis knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 241-279, </pages> <year> 1978. </year>
Reference: [GH86] <author> J. V. Guttag and J. J. Horning. </author> <title> Report on the Larch shared language. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 103-134, </pages> <year> 1986. </year>
Reference: [Gir71] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de godel a l'analyse, et son application a l'elimination des coupures dans l'analyse at la theorie des types. </title> <editor> In J. Fenstad, editor, </editor> <booktitle> Proceedings of the second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <address> Am-sterdam, </address> <year> 1971. </year>
Reference: [Gir86] <author> Jean-Yves Girard. </author> <title> The system F of variable types: Fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference: [GLB + 83] <author> Cordell Green, David Luckham, Robert Balzer, Thomas Cheatham, and Charles Rich. </author> <title> Report on a knowledge-based software assistant. </title> <type> Technical Report KES.U.83.2, </type> <institution> Kestrel Institute, </institution> <month> July </month> <year> 1983. </year>
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF: A mechanized Logic of Computation. </title> <booktitle> Number 78 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1979. </year>
Reference: [Gog90] <author> Joseph A. Goguen. </author> <title> An algebraic approach to refinement. </title> <editor> In D. Bjorner, C. A. R. Hoare, and H. Langmaack, editors, </editor> <booktitle> VDM '90: VDM and Z Formal methods in software development 3rd International Symposium of VDM Europe, </booktitle> <address> Kiel, Germany, </address> <month> April </month> <year> 1990, </year> <booktitle> volume 428 of Lecture Notes in Computer Science, </booktitle> <pages> pages 12-28. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [Gol82] <author> R. </author> <title> Goldblatt. </title> <booktitle> Axiomatising the Logic of Computer Programming, volume 132 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1982. </year>
Reference: [Gol86] <author> Allen T. Goldberg. </author> <title> Knowledge-based programming: A survey of program design and construction techniques. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(7):752-768, </volume> <month> July </month> <year> 1986. </year> <type> Technical Report KES.U.86.1, </type> <institution> Kestrel Institute, </institution> <month> July </month> <year> 1986. </year>
Reference: [Gor85] <author> M. Gordon. </author> <title> HOL: A machine oriented formalization of higher order logic. </title> <type> Technical Report 68, </type> <institution> Cambridge University, </institution> <year> 1985. </year>
Reference: [Gor87a] <author> M. Gordon. </author> <title> HOL: A proof generating system for higher order logic. </title> <type> Technical Report 103, </type> <institution> Cambridge University, </institution> <year> 1987. </year>
Reference: [Gor87b] <author> M. Gordon. </author> <title> HOL: A proof generating system for higher order logic. </title> <editor> In G. Birtwistle and P. A. Subrahamanyan, editors, </editor> <title> VLSI Specification, Verification, and Synthesis, </title> <year> 1987. </year>
Reference: [Gre69] <author> Cordell C. Green. </author> <title> An application of theorem proving to problem solving. </title> <booktitle> In IJCAI-69 | Proceedings of the 1 st International Joint Conference on Artificial Intelligence, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1969, </year> <pages> pages 219-239, </pages> <year> 1969. </year>
Reference: [Gri81] <editor> David Gries. </editor> <booktitle> The science of programming. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1981. </year>
Reference-contexts: In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory. Further programming knowledge worth being studied is contained in research on methodologies <ref> [Dij76, Gri81, Wir71] </ref> which has not yet been automated. The method for formalizing these approaches is always the same: one has to identify the key operations and the parameters they depend on and prove formal meta-theorems about them.
Reference: [GS89] <author> Fausto Giunchiglia and Alan Smaill. </author> <title> Reflection in constructive and non-constructive automated reasoning. </title> <editor> In Harvey Abramson and M. H. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, chapter 6, </booktitle> <pages> pages 123-140. </pages> <publisher> MIT Press, </publisher> <address> Cambridge Mass., </address> <year> 1989. </year> <note> 110 BIBLIOGRAPHY </note>
Reference: [GT79] <author> J. A. Goguen and J. Tardo. </author> <title> An introduction to OBJ: A language for writing and testing software specifications. </title> <booktitle> In Specification of Reliable Software, </booktitle> <pages> pages 170-189. </pages> <publisher> IEEE, </publisher> <year> 1979. </year>
Reference: [GT91] <author> Fausto Giunchiglia and Paolo Traverso. </author> <title> Reflective reasoning with and between declarative metatheory and the implementation code. </title> <editor> In John Mylopoulos and Ray Reiter, editors, </editor> <booktitle> IJCAI-91 | Proceedings of the 12 th International Joint Conference on Artificial Intelligence, Sidney, </booktitle> <month> August </month> <year> 1991, </year> <pages> pages 111-117. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1991. </year>
Reference: [Hag90] <author> M. Hagiya. </author> <title> Programming by example using higher order unification. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10 th Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1990, </year> <booktitle> volume 449 of Lecture Notes in Computer Science, </booktitle> <pages> pages 588-602. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [Hay86] <author> S. Hayashi. PX: </author> <title> a system extracting programs from proofs. </title> <booktitle> In Proceedings of the IFIP Confereence on Formal Description of Programming Concepts, </booktitle> <pages> pages 399-424, </pages> <year> 1986. </year>
Reference: [Hay87] <author> I. Hayes. </author> <title> Specification Case Studies. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference: [Hei89] <author> Maritta Heisel. </author> <title> A formalization and implementation of Gries's program development method with the KIV environment. </title> <type> Technical Report 3/89, </type> <institution> Fakultat fur Informatik, Universitat Karlsruhe, </institution> <year> 1989. </year>
Reference: [HHP87] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 194-204. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference: [HN88] <author> S. Hayashi and H. Nakano. PX: </author> <title> A computational logic. </title> <booktitle> In Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference: [Hog78] <author> C. J. </author> <title> Hogger. Goal-oriented derivation of logic programs. </title> <booktitle> In 7th Symposium on the Mathematical foundations of Computer Science, </booktitle> <address> Zakopane, Poland, </address> <month> September 3-8 </month> <year> 1978. </year> <institution> Polish Academy of Science. </institution>
Reference: [Hog81] <author> C. J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(2) </volume> <pages> 372-392, </pages> <month> April </month> <year> 1981. </year>
Reference: [Hor88] <author> Christian Horn. </author> <title> Interactive program and proof development with NurPRL. </title> <type> Seminar-bericht 97, </type> <institution> Sektion Mathematik der Humboldt-Universitat zu Berlin, </institution> <address> PSF 1297, 1086 Berlin, </address> <year> 1988. </year>
Reference: [How86] <author> Douglas J. Howe. </author> <title> Implementing number theory: An experiment with NuPRL. </title> <editor> In J. H. Siek-mann, editor, </editor> <booktitle> Proceedings of the 8 th Conference on Automated Deduction, </booktitle> <address> Oxford, England, </address> <year> 1986, </year> <booktitle> volume 230 of Lecture Notes in Computer Science, </booktitle> <pages> pages 404-415. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1986. </year>
Reference: [How88a] <author> Douglas J. Howe. </author> <title> Automating reasoning in an implementation of constructive Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> June </month> <year> 1988. </year> <type> TR 88-925. </type>
Reference: [How88b] <author> Douglas J. Howe. </author> <title> Computational metatheory in NuPRL. </title> <booktitle> In Proceedings of the 9 th Conference on Automated Deduction, </booktitle> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988, </year> <pages> pages 238-257, </pages> <year> 1988. </year>
Reference: [HRS88] <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> Implementing verification strategies in the KIV system. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proceedings of the 9 th Conference on Automated Deduction, </booktitle> <address> Argonne, Illinois, </address> <month> May </month> <year> 1988, </year> <booktitle> number 310 in Lecture Notes in Computer Science, </booktitle> <pages> pages 131-140. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference: [HRS89] <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> Machine-assisted program construction and modification. </title> <editor> In D. Metzing, editor, </editor> <booktitle> GWAI-89 | Proceedings of the 13 th German Workshop on Artificial Intelligence, </booktitle> <address> Eringerfeld, </address> <month> September </month> <year> 1989, </year> <booktitle> number 216 in Informatik Fachberichte, </booktitle> <pages> pages 338-347. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year> <note> BIBLIOGRAPHY 111 </note>
Reference: [HRS90] <author> M. Heisel, W. Reif, and W. Stephan. </author> <title> Tactical theorem proving in program verification. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10 th Conference on Automated Deduction, </booktitle> <address> Kaiser-slautern, Germany, </address> <month> July </month> <year> 1990, </year> <booktitle> number 449 in Lecture Notes in Computer Science, </booktitle> <pages> pages 117-131. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [HRS91] <author> Maritta Heisel, Wolfgang Reif, and Werner Stephan. </author> <title> Formal software development in the KIV system. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 547-576, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference: [HST89] <author> Robert Harper, Donald Sannella, and Andrzej Tarlecki. </author> <title> Structure and representation in LF. </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> LICS-89 | Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> pages 226-237. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference: [HT88] <author> Martin C. Henson and Raymond A. Turner. </author> <title> A constructive set theory for program development. </title> <editor> In K. V. Nori and S. Kumar, editors, </editor> <booktitle> Proceedings of the eighth Conference on Foundations of Software Technology and Theoretical Computer Science, Pune, India, De-cember 1988, Lecture Notes in Computer Science, </booktitle> <pages> pages 329-347. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference: [JF91] <author> W. Lewis Johnson and Martin S. Feather. </author> <title> Using evolution transformations to construct specifications. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 65-92, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference: [Jon90] <author> C. B. Jones. </author> <title> Systematic software development using VDM. </title> <booktitle> Prentice-Hall, 2nd edition, </booktitle> <year> 1990. </year>
Reference: [JS90] <author> C. B. Jones and R. C. Shaw. </author> <title> Case Studies in Systematic Software Development. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference: [Kan79] <author> Elaine Kant. </author> <title> A knowledge-based approach to using efficiency estimation in program synthesis. </title> <editor> In Bruce G. Buchanan, editor, </editor> <booktitle> IJCAI-79 | Proceedings of the 6 th International Joint Conference on Artificial Intelligence, </booktitle> <address> Tokyo, Japan, </address> <month> August </month> <year> 1979, </year> <pages> pages 457-462. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1979. </year>
Reference-contexts: Furthermore it supports parallel computations since depth is being replaced by breadth. Mathematically it can be expressed as an abstraction which is followed by simplifications and a formalization will have to reflect this. * Further strategies towards an efficient development of efficient programs are discussed in <ref> [Kan79, Kan83, Kan85, Kan91] </ref> and need to be investigated as well. While specifications and the design of algorithms must be based on an abstract view of the data to be manipulated, programs have to operate with concrete representations of the data.
Reference: [Kan83] <author> Elaine Kant. </author> <title> On the efficient synthesis of efficient programs. </title> <journal> Artificial Intelligence, </journal> <volume> 20(3) </volume> <pages> 253-305, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Furthermore it supports parallel computations since depth is being replaced by breadth. Mathematically it can be expressed as an abstraction which is followed by simplifications and a formalization will have to reflect this. * Further strategies towards an efficient development of efficient programs are discussed in <ref> [Kan79, Kan83, Kan85, Kan91] </ref> and need to be investigated as well. While specifications and the design of algorithms must be based on an abstract view of the data to be manipulated, programs have to operate with concrete representations of the data.
Reference: [Kan85] <author> Elaine Kant. </author> <title> Understanding and automating algorithm design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(11):1361-1374, </volume> <month> November </month> <year> 1985. </year>
Reference-contexts: Furthermore it supports parallel computations since depth is being replaced by breadth. Mathematically it can be expressed as an abstraction which is followed by simplifications and a formalization will have to reflect this. * Further strategies towards an efficient development of efficient programs are discussed in <ref> [Kan79, Kan83, Kan85, Kan91] </ref> and need to be investigated as well. While specifications and the design of algorithms must be based on an abstract view of the data to be manipulated, programs have to operate with concrete representations of the data.
Reference: [Kan91] <author> Elaine Kant. </author> <title> Data relationships and software design. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 141-168, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference-contexts: Furthermore it supports parallel computations since depth is being replaced by breadth. Mathematically it can be expressed as an abstraction which is followed by simplifications and a formalization will have to reflect this. * Further strategies towards an efficient development of efficient programs are discussed in <ref> [Kan79, Kan83, Kan85, Kan91] </ref> and need to be investigated as well. While specifications and the design of algorithms must be based on an abstract view of the data to be manipulated, programs have to operate with concrete representations of the data.
Reference: [KB81] <author> Elaine Kant and David Barstow. </author> <title> The refinement paradigm: the interaction of coding and efficiency knowledge in program synthesis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(5) </volume> <pages> 458-471, </pages> <year> 1981. </year>
Reference: [KB89] <author> B. Krieg-Bruckner. </author> <title> Algebraic specifications and functionals for transformational program and meta-program development. </title> <editor> In J. Diaz and F. Orejas, editors, </editor> <booktitle> TAPSOFT '89 Proceedings of the International Joint Conference on Theory and Practice of Software Development, </booktitle> <address> Barcelona, Spain, </address> <month> March </month> <year> 1989, </year> <booktitle> number 352 in Lecture Notes in Computer Science, </booktitle> <pages> pages 36-59. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference-contexts: Investigating the extension of synthesis strategies towards the automated creation of modules is therefore another important direction that should be followed, especially because some program transformation systems based on algebraic methods (see e.g. <ref> [KBHG + 86, KB89] </ref>) already work at developing program packages from specifications.
Reference: [KBHG + 86] <author> B. Krieg-Bruckner, B. Hoffmann, H. Ganzinger, M. Broy, R. Wilhelm, U. Moricke, B. Weis-gerber, A.D. McGettrick, I.G. Campbell, and G. Winterstein. </author> <title> PROgram development by SPECification and TRAnsformation. </title> <booktitle> In Proceedings ESPRIT Conference, </booktitle> <address> Brussels, </address> <year> 1986. </year>
Reference-contexts: Investigating the extension of synthesis strategies towards the automated creation of modules is therefore another important direction that should be followed, especially because some program transformation systems based on algebraic methods (see e.g. <ref> [KBHG + 86, KB89] </ref>) already work at developing program packages from specifications.
Reference: [KC86] <author> Todd B. Knoblock and Robert L. Constable. </author> <title> Formalized metareasoning in Type Theory. </title> <booktitle> In LICS-86 | Proceedings of the First Annual Symposium on Logic in Computer Science, 1986. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year> <note> 112 BIBLIOGRAPHY </note>
Reference: [Kin90] <author> Steve King. </author> <title> Z and the refinement calculus. </title> <editor> In D. Bjorner, C. A. R. Hoare, and H. Langmaack, editors, </editor> <booktitle> VDM '90: VDM and Z Formal methods in software development 3rd International Symposium of VDM Europe, </booktitle> <address> Kiel, Germany, </address> <month> April </month> <year> 1990, </year> <booktitle> volume 428 of Lecture Notes in Computer Science, </booktitle> <pages> pages 164-188. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [KN91] <author> Van E. Kelly and Uwe Nonnenmann. </author> <title> Reducing the complexity of formal specification acquisition. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 41-64, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference: [Knu68] <author> D. E. Knuth. </author> <title> The Art of Computer Programming, Volume 1: Fundamental Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1968. </year>
Reference: [Knu72] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, Volume 2: Seminumerical Algorithms. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1972. </year>
Reference: [Knu75] <author> D. E. Knuth. </author> <title> The Art of Computer Programming, Volume 3: Sorting and Searching. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference: [Kol32] <author> A. N. </author> <title> Kolmogorov. </title> <journal> Zur Deutung der intuitionistischen Logik. Mathematische Zeitschrift, </journal> <volume> 35 </volume> <pages> 58-65, </pages> <year> 1932. </year>
Reference: [Kre86] <author> Christoph Kreitz. </author> <title> Constructive automata theory implemented with the NuPRL proof development system. </title> <type> Technical Report TR 86-779, </type> <institution> Cornell University. Department of Computer Science, </institution> <address> Ithaca, NY 14853-7501, </address> <month> August </month> <year> 1986. </year>
Reference: [Laf90] <author> Christine Lafontaine. </author> <title> Formalization of the VDM reification in the DEVA meta-calculus. the human-leucocyte-antigen case study. </title> <booktitle> In IFIP Working Conference on Programming Concepts and Methods, </booktitle> <year> 1990. </year>
Reference: [LCW74] <author> R.C.T. Lee, C.L. Chang, and Richard J. Waldinger. </author> <title> An improved program synthesizing algorithm and its correctness. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 17(4) </volume> <pages> 211-217, </pages> <year> 1974. </year>
Reference: [LD89] <author> Michael R. Lowry and R. Duran. </author> <title> Knowledge-based software engineering. </title> <editor> In Avron Barr, Paul R. Cohen, and Edward A. Feigenbaum, editors, </editor> <booktitle> The Handbook of Artificial Intelligence, Vol. IV, chapter XX. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference: [Lei90] <author> Daniel Leivant. </author> <title> Contracting proofs to programs. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 279-328. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1990. </year>
Reference: [Lew90] <author> Christopher P. Lewington. </author> <title> Towards constructive program derivation in VDM. </title> <editor> In K. V. Nori and C. E. Veni Madhavan, editors, </editor> <booktitle> Proceedings of the tenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <address> Bangalore, India, </address> <month> December </month> <year> 1990, </year> <booktitle> number 472 in Lecture Notes in Computer Science, </booktitle> <pages> pages 115-132. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [Lin88] <author> Peter A. Lindsay. </author> <title> A survey of mechanical support for formal reasoning. </title> <journal> Software Engineering Journal, </journal> <volume> 3(1), </volume> <year> 1988. </year>
Reference: [LLS90] <author> Christine Lafontaine, Yves Ledru, and Pierre-Yves Schobbens. </author> <title> Two approaches towards the formalization of VDM. </title> <editor> In D. Bjorner, C. A. R. Hoare, and H. Langmaack, editors, </editor> <booktitle> VDM '90: VDM and Z Formal methods in software development 3rd International Symposium of VDM Europe, </booktitle> <address> Kiel, Germany, </address> <month> April </month> <year> 1990, </year> <booktitle> volume 428 of Lecture Notes in Computer Science, </booktitle> <pages> pages 370-398. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1990. </year>
Reference: [LM91] <editor> Michael R. Lowry and Robert D. McCartney, editors. </editor> <booktitle> Automating Software Design, </booktitle> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference: [Low87] <author> Michael R. Lowry. </author> <title> Algorithm synthesis through problem reformulation. </title> <booktitle> In AAAI-87 | Proceedings of the 6 th AAAI National Conference on Artificial Intelligence, </booktitle> <address> Seattle, July 1987, Seattle, WA, </address> <month> July 13-17, </month> <year> 1987. </year> <type> Technical Report KES.U.87.10, </type> <institution> Kestrel Institute, </institution> <month> August </month> <year> 1987. </year> <note> BIBLIOGRAPHY 113 </note>
Reference: [Low88] <author> Michael R. Lowry. </author> <title> The structure and design of local search algorithms. </title> <editor> In M. R. Lowry, R. McCartney, and D. R. Smith, editors, </editor> <booktitle> Proceedings of the Workshop on Automating Software Design. AAAI-88, </booktitle> <address> St. Paul, MN, </address> <month> August 25, </month> <year> 1988, </year> <pages> pages 88-94, </pages> <month> August </month> <year> 1988. </year>
Reference: [Low89] <author> Michael R. Lowry. </author> <title> Algorithm Synthesis through Problem Reformulation. </title> <type> PhD thesis, </type> <institution> Stan-ford University, </institution> <year> 1989. </year>
Reference-contexts: In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms <ref> [Low89, Low91] </ref>, dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory.
Reference: [Low91] <author> Michael R. Lowry. </author> <title> Automating the design of local search algorithms. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 515-546, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference-contexts: In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms <ref> [Low89, Low91] </ref>, dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory.
Reference: [LP90] <author> K.K. Lau and S.D. Prestwich. </author> <title> Top-down synthesis of recursive logic procedures from first-order logic specifications. </title> <booktitle> In Proceedings of the 7th International Conference on Logic Programming, </booktitle> <pages> pages 667-684. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [Men87] <author> Paul Francis Mendler. </author> <title> Recursive types and type constraints in second order lambda calculus. </title> <editor> In David Gries, editor, </editor> <booktitle> LICS-87 | Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, USA, </address> <month> June </month> <year> 1987, </year> <pages> pages 30-36. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference: [ML73] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: predicative part. </title> <editor> In H. E. Rose and J. C. Shepherdson, editors, </editor> <booktitle> Logic Colloquium '73, </booktitle> <address> Amsterdam, 1973. </address> <publisher> North-Holland, Amsterdam. </publisher>
Reference: [ML82] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In 6-th International Congress for Logic, Methodology and Philosophy of Science, </booktitle> <year> 1979, </year> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference: [ML84] <author> Per Martin-Lof. </author> <title> Intuitionistic Type Theory, </title> <booktitle> volume 1 of Studies in Proof Theory Lecture Notes. </booktitle> <publisher> Bibliopolis, Napoli, </publisher> <year> 1984. </year>
Reference: [MN86] <author> Dale Miller and Gopalan Nadathur. </author> <title> Higher-order logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the third International Conference on Logic Programming, </booktitle> <address> London, UK, </address> <month> July </month> <year> 1986, </year> <booktitle> number 225 in Lecture Notes in Computer Science, </booktitle> <pages> pages 448-462. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1986. </year>
Reference: [MN87] <author> Dale Miller and Gopalan Nadathur. </author> <title> A logic programming approach to manipulating formulas and programs. </title> <booktitle> In Proceedings of the 4th IEEE Symposium on Logic Programming, </booktitle> <address> San Francisco, CA, </address> <month> August </month> <year> 1987, </year> <pages> pages 379-388. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference: [MN88] <editor> P. Maes and D. Nardi, editors. </editor> <title> Meta-Level Architectures and Reflection. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference: [Mor90] <author> C. C. Morgan. </author> <title> Programming from specifications. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1990. </year>
Reference: [Mos91] <author> Jack Mostow. </author> <title> A transformational approach to knowledge compilation: Replayable derivations of task-specific heuristic search algorithms. </title> <editor> In Michael R. Lowry and Robert D. Mc-Cartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 231-260, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference: [MW71] <author> Zohar Manna and Richard J. Waldinger. </author> <title> Toward automatic program synthesis. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 14(3) </volume> <pages> 151-165, </pages> <month> March </month> <year> 1971. </year>
Reference: [MW75] <author> Zohar Manna and Richard J. Waldinger. </author> <title> Knowledge and reasoning in program synthesis. </title> <journal> Artificial Intelligence, </journal> <volume> 6(2) </volume> <pages> 175-208, </pages> <year> 1975. </year>
Reference: [MW77] <author> Zohar Manna and Richard J. Waldinger. </author> <title> The automatic synthesis of systems of recursive programs. </title> <editor> In Raj Reddy, editor, </editor> <booktitle> IJCAI-77 | Proceedings of the 5 th International Joint Conference on Artificial Intelligence, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1977, </year> <pages> pages 405-411. </pages> <publisher> Morgan Kaufman, </publisher> <address> Los Altos, CA, </address> <year> 1977. </year>
Reference: [MW79] <author> Zohar Manna and Richard J. Waldinger. </author> <title> Synthesis: Dreams ) programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(4):294-328, </volume> <month> July </month> <year> 1979. </year> <note> 114 BIBLIOGRAPHY </note>
Reference: [MW80] <author> Zohar Manna and Richard J. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <year> 1980. </year>
Reference: [Nad86] <author> Gopalan Nadathur. </author> <title> A Higher-Order logic as the basis for Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1986. </year>
Reference: [Ned80] <author> R. P. </author> <title> Nederpelt. An approach to theorem proving on the basis of a lambda-calculus. </title> <editor> In W.Bibel and R. Kowalski, editors, </editor> <booktitle> Proceedings of the 5 th Conference on Automated Deduction, Les Arcs, </booktitle> <address> France, </address> <month> July </month> <year> 1980, </year> <booktitle> number 87 in Lecture Notes in Computer Science, </booktitle> <pages> pages 182-194. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1980. </year>
Reference: [Neu92] <author> Gerd Neugebauer. Pragmatische Programmsynthese. </author> <type> Dissertation, </type> <institution> Technische Hochschule Darmstadt, FG Intellektik, </institution> <year> 1992. </year>
Reference-contexts: They do not say anything about improvements after guessing. In particular, the right choice of DC is crucial to the success of the synthesis and the efficiency of the result (see <ref> [Neu92] </ref> for examples). Following the spirit of [Bib80, page 251] we can put certain restrictions on the choice of G, DC, and t. The data type G represents those parts of the output that are displayable at a time and t relates an output value with its displayable part. <p> Instead it is a Goal-Oriented-Transformation | a strategy which tries to achieve a certain goal (recursion) by means of equivalence-preserving transformations which are created during a derivation. Unfortunately, an exact formulation of GET-REC's goal is missing in the literature written on LOPS so far <ref> [BFS78, Bib80, Fro84, Neu92] </ref>. Also the meaning of "information about possible kinds of recursion" is nowhere being made precise. In order to close this 4.1. <p> Consequently, guessing cannot be applied to the unrestricted problem and we have to split the problem into sorting the empty sequence and sorting nonempty sequences. Although the preprocessing step has not been formalized in the LOPS literature so far (it only occurs in example syntheses given in <ref> [Neu92] </ref>) it is easy to do so. One has to derive a boolean predicate primitive such that all input values leading to feasible outputs without displayable parts are primitive and for all primitive legal inputs a direct solution can (easily) be computed. 8x:DD.8y:RR. <p> In example 4.1.13, for instance, the predicate gm is not evaluable if m is not already known and it would be fatal if this clause would appear before m is being computed. According to <ref> [Neu92, section 5.7] </ref> this strategy essentially consists of appropriate rearrangements in the order of conjuncts occurring in the formula. This step, however, is necessary only if the target language of a synthesis is a logic programming language. <p> We will conclude this section with an example demonstrating a LOPS synthesis of several sorting algorithms. The example shall illustrate the effects of the domain-condition and the recursion scheme on the algorithm generated during a synthesis. Details how the heuristics of LOPS have found these parameters are elaborated in <ref> [Neu92, Section 6.3] </ref> and shall not be repeated here. Example 4.1.27 Synthesizing Sorting Algorithms For the sake of simplicity we consider sorting sequences of integer values.
Reference: [NFK89] <author> G. Neugebauer, Bertram Fronhofer, and Christoph Kreitz. </author> <title> XPRTS an implementation tool for program synthesis. </title> <editor> In D. Metzing, editor, </editor> <booktitle> GWAI-89 | Proceedings of the 13 th German Workshop on Artificial Intelligence, </booktitle> <address> Eringerfeld, </address> <month> September </month> <year> 1989, </year> <booktitle> number 216 in Informatik Fachberichte, </booktitle> <pages> pages 348-357. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference: [NPS90] <author> Bengt Nordstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lofs Type Theory. An introduction. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1990. </year>
Reference: [Pau85] <author> Lawrence C. Paulson. </author> <title> Verifying the unification algorithm in LCF. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 5 </volume> <pages> 143-169, </pages> <year> 1985. </year>
Reference: [Pau87a] <author> Lawrence C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1987. </year>
Reference: [Pau87b] <author> Lawrence C. Paulson. </author> <title> The representation of logics in higher-order logic. </title> <type> Technical Report 113, </type> <institution> University of Cambridge. Computer Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference: [Pau88] <author> Lawrence C. Paulson. </author> <title> A formulation of the simple theory of types (for Isabelle). </title> <editor> In P. Martin-Lof and G. Mints, editors, </editor> <booktitle> COLOG-88: Proceedings of the International Conference on Computer Logic, Tallin, </booktitle> <address> USSR, </address> <month> December </month> <year> 1988, </year> <booktitle> number 417 in Lecture Notes in Computer Science, </booktitle> <pages> pages 246-274. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1988. </year>
Reference: [Pau89] <author> Lawrence C. Paulson. </author> <title> The foundation of a generic theorem prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 363-397, </pages> <year> 1989. </year>
Reference: [Pau90] <author> Lawrence C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-386. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1990. </year>
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> ELF: a language for logic definition and verified metaprogramming. </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> LICS-89 | Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> pages 313-322. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference: [PK82] <author> Robert Paige and Shaye Koenig. </author> <title> Finite differencing of computable expressions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 402-454, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Introducing a new variable for a subexpression and replacing its evaluation by an incremental computation of the new variable is a program (module) transformation which is known as finite differencing <ref> [PK82] </ref> and can result in a significant speedup. Furthermore it supports parallel computations since depth is being replaced by breadth.
Reference: [PM89] <author> Christine Paulin-Mohring. </author> <title> Extracting F ! 's programs from proofs in the Calculus of Constructions. </title> <booktitle> In Proceedings of the 16 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 89-104, </pages> <year> 1989. </year>
Reference: [PR83] <author> H. Partsch and Steinbruggen R. </author> <title> Program transformation systems. </title> <journal> Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 199-236, </pages> <month> September </month> <year> 1983. </year>
Reference: [Rey81] <author> John C. Reynolds. </author> <title> The craft of programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, Engle-wood Cliffs, N.J., </address> <year> 1981. </year>
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <month> January </month> <year> 1965. </year>
Reference: [Rus08] <author> Bertrand Russel. </author> <title> Mathematical logic as based on a theory of types. </title> <journal> Am. J. of Math., </journal> <volume> 30 </volume> <pages> 222-262, </pages> <year> 1908. </year> <note> BIBLIOGRAPHY 115 </note>
Reference: [RW86] <editor> C. Rich and R. C. Waters, editors. </editor> <booktitle> Readings in Artificial Intelligence and Software Engineering. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference: [RW88] <author> C. Rich and R. C. Waters. </author> <title> The programmer's apprentice: a research overview. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 21(11) </volume> <pages> 10-25, </pages> <year> 1988. </year>
Reference: [RW90] <author> Charles Rich and Richard. C. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference: [SA89] <author> D. M. Steier and A. P. Anderson. </author> <title> Algorithm Synthesis: A comparative study. </title> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1989. </year>
Reference: [Sch81] <author> William Scherlis. </author> <title> Program improvement by internal specialization. </title> <booktitle> In Proceedings of the 8 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 41-49. </pages> <institution> Association for Computing Machinery, </institution> <year> 1981. </year>
Reference-contexts: equivalent expressions according to given laws can easily be justified (only make sure that in every step the precondition for applying the substitution is checked) automating the simplification procedure requires the laws to be directed and a very efficient organization of the knowledge base. * Partial evaluation [BEN88] or specialization <ref> [Sch81] </ref> means evaluating subexpressions whose arguments are in a fixed form such as the empty sequence, singleton sequences, or fixed numbers.
Reference: [SL90] <author> Douglas R. Smith and Michael R. Lowry. </author> <title> Algorithm theories and design tactics. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 14(2-3):305-321, </address> <month> October </month> <year> 1990. </year> <type> Report KES.U.89.3, </type> <institution> Kestrel Institute. </institution>
Reference-contexts: An auxiliary function, defined on legal input 7 Representing split and ext as functions is computationally more convenient than the predicates used in <ref> [Smi87c, SL90, Smi91a] </ref>; functions operating on the input domain and their corresponding axioms are allowed to be undefined on illegal input values; and the fourth axiom has been weakened to feasible output objects z which was necessary for the proof of lemma 4.2.12. 86 CHAPTER 4.
Reference: [Smi83] <author> Douglas R. Smith. </author> <title> The structure of divide-and-conquer algorithms. </title> <type> Technical Report NPS52-83-002, </type> <institution> Naval Postgraduate School, Monterey, California, </institution> <month> March </month> <year> 1983. </year>
Reference: [Smi84] <author> Jan M. Smith. </author> <title> An interpretation of Martin-Lof's Type Theory in a type-free theory of propositions. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 49(3) </volume> <pages> 730-753, </pages> <year> 1984. </year>
Reference: [Smi85a] <author> Douglas R. Smith. </author> <title> The design of divide and conquer algorithms. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 5 </volume> <pages> 37-58, </pages> <year> 1985. </year>
Reference-contexts: Such a comparison provides the means for combining the strengths of different approaches while avoiding double work. In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms <ref> [Smi85b, Smi85a, Smi87a] </ref>, local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80].
Reference: [Smi85b] <author> Douglas R. Smith. </author> <title> Top-down synthesis of divide-and-conquer algorithms. </title> <journal> Artificial Intelligence, </journal> <volume> 27(1) </volume> <pages> 43-96, </pages> <month> September </month> <year> 1985. </year> <note> (Reprinted in Readings in Artificial Intelligence and Software Engineering, </note> <editor> C. Rich and R. Waters, Eds., </editor> <address> Los Altos, CA, </address> <publisher> Morgan Kaufmann, 1986.). </publisher>
Reference-contexts: Such a comparison provides the means for combining the strengths of different approaches while avoiding double work. In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms <ref> [Smi85b, Smi85a, Smi87a] </ref>, local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80].
Reference: [Smi87a] <author> Douglas R. Smith. </author> <title> Application of a strategy for designing divide-and-conquer algorithms. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 213-229, </pages> <month> June </month> <year> 1987. </year> <note> (also Technical Report KES.U.85.2, </note> <institution> Kestrel Institute, </institution> <month> March </month> <year> 1985). </year>
Reference-contexts: Such a comparison provides the means for combining the strengths of different approaches while avoiding double work. In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms <ref> [Smi85b, Smi85a, Smi87a] </ref>, local search algorithms [Low89, Low91], dynamic programming [Smi91b], and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80].
Reference: [Smi87b] <author> Douglas R. Smith. </author> <title> On the design of generate-and-test algorithms: Subspace generators. </title> <editor> In L. G. L. T. Meertens, editor, </editor> <booktitle> IFIP TC 2 Working Conference on Program Specification and Transformation, </booktitle> <pages> pages 207-220. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year> <note> (also Technical Report KES.U.86.6, </note> <institution> Kestrel Institute, </institution> <month> September </month> <year> 1985). </year>
Reference: [Smi87c] <author> Douglas R. Smith. </author> <title> Structure and design of global search algorithms. </title> <type> Technical Report KES.U.87.12, </type> <institution> Kestrel Institute, </institution> <month> November </month> <year> 1987. </year> <note> Revised Version, </note> <month> July </month> <year> 1988. </year>
Reference-contexts: It is this combination together with the orientation towards knowledge based program development which has made KIDS the most successful synthesis system so far. In this section we shall formalize the semantic knowledge guiding the KIDS strategy designing global search algorithms. Our formalization follows <ref> [Smi87c, Smi91a] </ref> to ensure the faithfulness of our representation which, due to the formulation as formal meta-theorems, also provides the basis for a verified implementation of the design tactic. <p> avoid the typical errors occurring when encoding a tactic by hand in the spirit of the description on paper. 6 Further design tactics for other algorithmic structures will be investigated in the future. 6 Actually, there is a small mistake in the KIDS implementation of the design tactic based on <ref> [Smi87c] </ref> which may lead to a nonterminating program if the user is not careful enough (See our remarks in section 4.2.4 immediately before example 4.2.17). Thus implementation and documentation are not the same. 84 CHAPTER 4. <p> KIDS SYNTHESIS BASED ON ALGORITHM SCHEMATA 85 Our representation described above and formalized below follows closely the one given in <ref> [Smi87c] </ref> except for a few modifications which we found to be more appropriate. 7 To simplify notation we define G proj : exp to introduce standard names for components not mentioned explicitly. <p> An auxiliary function, defined on legal input 7 Representing split and ext as functions is computationally more convenient than the predicates used in <ref> [Smi87c, SL90, Smi91a] </ref>; functions operating on the input domain and their corresponding axioms are allowed to be undefined on illegal input values; and the fourth axiom has been weakened to feasible output objects z which was necessary for the proof of lemma 4.2.12. 86 CHAPTER 4. <p> Theorem 4.2.15 therefore gives rise to a verified implementation of a simple synthesis strategy designing a global search algorithm for a given specification spec = hhDD, RR, I, Oii. This strategy refines and improves the one given in <ref> [Smi87c] </ref> and consists of four heuristic steps determining the required parameters and a final step instantiating lemma 4.2.16 to create the algorithm. 1. From the library select a global search theory G = hhspec', SS,J,s 0 ,sat,split,extii whose range type is RR or a supertype of it. <p> Its earlier version <ref> [Smi87c, Proposition 3.1.] </ref> (which has been proven correct) cannot be applied since the selected GS-theory gs sequences over finite set is not well-founded. <p> In particular we have represented the kernel of the LOPS-approach to program synthesis [Bib80] which so far has been described rather vaguely. In the process of formalizing the design strategy for global search algorithms used in the KIDS system <ref> [Smi87c, Smi91a] </ref> we have discovered a small gap and shown how to close it. This shows a particular advantage of complete formality over encodings which skip details which appear to be unimportant.
Reference: [Smi91a] <author> Douglas R. Smith. </author> <title> KIDS | a knowledge-based software development system. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 483-514, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference-contexts: SORT (L-g g ) The optimal choice for arb (L) would be computing some mean value of L. 2 4.2 KIDS Synthesis Based on Algorithm Schemata KIDS | the Kestrel Interactive Development System | <ref> [Smi91a] </ref> is a highly automated environment for deriving correct and efficient programs from formal specifications integrating various kinds of domain and programming knowledge. The system provides tools for performing deductive inference, algorithm design, expression simplification, finite differencing, partial evaluation, data type refinement, and other program transformations. <p> It is this combination together with the orientation towards knowledge based program development which has made KIDS the most successful synthesis system so far. In this section we shall formalize the semantic knowledge guiding the KIDS strategy designing global search algorithms. Our formalization follows <ref> [Smi87c, Smi91a] </ref> to ensure the faithfulness of our representation which, due to the formulation as formal meta-theorems, also provides the basis for a verified implementation of the design tactic. <p> An auxiliary function, defined on legal input 7 Representing split and ext as functions is computationally more convenient than the predicates used in <ref> [Smi87c, SL90, Smi91a] </ref>; functions operating on the input domain and their corresponding axioms are allowed to be undefined on illegal input values; and the fourth axiom has been weakened to feasible output objects z which was necessary for the proof of lemma 4.2.12. 86 CHAPTER 4. <p> 0 ((x))) then F aux (x,s 0 ((x))) else ; FUNCTION F aux (x,s:DDfifiSS) WHERE I (x)^J ((x),s)^(x,s) RETURNS fz:RR|O (x,z)^sat (z,s)g = fz|z 2 ext (s)^O (x,z)g [ fF aux (x,t)|t 2 split ((x),s)^(x,t)g We shall illustrate our strategy by a real programming problem which has been used in <ref> [Smi91a] </ref> to demonstrate the capabilities of the KIDS system. <p> lemma range (A) = Set (int) f1..ng , range (A) f1..ng ^ f1..ng range (A) leads to choosing S:=f1..ng and the substitution =n.f1..ng. 8 Lacking complete formality in the steps from developing the theory on paper towards implementing the corresponding design tactic it has remained unnoticed that theorem 1 of <ref> [Smi91a] </ref> the key to a KIDS derivation is wrong since it omits well-foundedness of the GS-theory as prerequisite for termination. Its earlier version [Smi87c, Proposition 3.1.] (which has been proven correct) cannot be applied since the selected GS-theory gs sequences over finite set is not well-founded. <p> domain (A).injective (dtrow (A,j)) ^ V v Ag = if f1..ng range (V) then fVg else ; [ f Costas aux (n,V * i) |i 2 f1..ng ^ i 62 V ^ 8j 2 domain (V). (V |V|+1-j -i) 62 dtrow (V,j)g partial evaluation, finite differencing, and data type refinement <ref> [Smi91a] </ref>. These techniques shall be formalized in the future. 94 CHAPTER 4. REPRESENTING EXISTING APPROACHES Chapter 5 Towards Meta-Synthesis In the previous chapters we have elaborated the foundations of a formal theory of programming. This theory is based on three fundamental ideas. <p> In particular we have represented the kernel of the LOPS-approach to program synthesis [Bib80] which so far has been described rather vaguely. In the process of formalizing the design strategy for global search algorithms used in the KIDS system <ref> [Smi87c, Smi91a] </ref> we have discovered a small gap and shown how to close it. This shows a particular advantage of complete formality over encodings which skip details which appear to be unimportant.
Reference: [Smi91b] <author> Douglas R. Smith. </author> <title> Structure and design of dynamic programming algorithms. </title> <type> Technical report, </type> <institution> Kestrel Institute, </institution> <year> 1991. </year>
Reference-contexts: In chapter 4 we have already represented two approaches to program synthesis and we shall continue to represent and investigate further approaches such as design tactics for divide-and-conquer algorithms [Smi85b, Smi85a, Smi87a], local search algorithms [Low89, Low91], dynamic programming <ref> [Smi91b] </ref>, and other algorithm schemata; constructive matching [Fra85b, FK92], proof planning methods [Bun89, BSW90], and the additional strategies of LOPS [Bib80]. In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory.
Reference: [Smi91c] <author> Douglas R. Smith. </author> <title> Structure and design of problem reduction generators. </title> <booktitle> In Proc. IFIP TC2 Working Conference on Constructing Programs from Specifications, </booktitle> <year> 1991. </year>
Reference: [SP88] <author> Douglas R. Smith and Thomas T. Pressburger. </author> <title> Knowledge-based software development tools. </title> <editor> In P. Brereton, editor, </editor> <booktitle> Software Engineering Environments, </booktitle> <pages> pages 79-103. </pages> <publisher> Ellis Hor-wood Ltd., </publisher> <address> Chichester, </address> <year> 1988. </year> <note> (also Technical Report KES.U.87.6, </note> <institution> Kestrel Institute, </institution> <month> May </month> <year> 1987). </year>
Reference: [Spi88] <author> J. M. Spivey. </author> <title> Understanding Z: a specification language and its formal semantics, </title> <booktitle> volume 3 of Cambrindge tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1988. </year> <note> 116 BIBLIOGRAPHY </note>
Reference: [SSS81] <author> Edward Schonberg, Jacob Schwartz, and M. Sharir. </author> <title> An automatic technique for the selection of data representations in SETL programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(2) </volume> <pages> 126-143, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: For simple data structures standard implementations provided by compilers are very efficient. However, when it comes to high-level or abstract data types, standard solutions cease being satisfactory. Syntheses thus involve not only control decisions, but also data structure selection <ref> [Bar79, SSS81] </ref>. 5.4. DERIVING STRATEGIES FROM HIGHER-ORDER SPECIFICATIONS 99 The difficulty is that complex data types can be implemented in many different ways. Sets, for instance, may be represented by lists, arrays, trees, bit-patterns, etc.
Reference: [ST87] <author> Donald Sannella and Andrzej Tarlecki. </author> <title> On observational equivalence and algebraic specification. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 34 </volume> <pages> 150-178, </pages> <year> 1987. </year>
Reference: [ST88] <author> Donald Sannella and Andrzej Tarlecki. </author> <title> Toward formal development of programs from algebraic specifications: implementations revisited. </title> <journal> Acta Informatica, </journal> <volume> 25(3) </volume> <pages> 233-281, </pages> <year> 1988. </year>
Reference: [ST89] <author> T. Sato and H. Tamaki. </author> <title> First order compiler: A deterministic logic program synthesis algorithm. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 605-627, </pages> <year> 1989. </year>
Reference: [SVM88] <author> J. Silverman, V. Vickers, and J. Mooney. </author> <title> On the number of Costas arrays as a function of array size. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <volume> volume 76, </volume> <pages> pages 851-853, </pages> <year> 1988. </year>
Reference-contexts: Since then, many publications have investigated combinatorial properties of these permutations, now known as Costas arrays. So far, no general construction has been found and the problem of enumerating Costas arrays has been explored by computer search <ref> [SVM88] </ref>.
Reference: [Tai67] <author> William W. Tait. </author> <title> Intensional interpretation of functionals of finite type. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2) </volume> <pages> 187-199, </pages> <year> 1967. </year>
Reference: [TCS92] <author> Paolo Traverso, Alessandro Cimatti, and Luca Spalazi. </author> <title> Beyond the single planning paradigm: introspective planning. </title> <editor> In B. Neumann, editor, </editor> <booktitle> ECAI-92 | Proceedings of the 10 th European Conference on Artificial Intelligence, </booktitle> <address> Vienna, Austria, </address> <month> August </month> <year> 1992, </year> <pages> pages 643-647. </pages> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1992. </year>
Reference: [Ton91] <author> Christopher Tong. </author> <title> A divide-and-conquer approach to knowledge compilation. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Desig, </booktitle> <pages> pages 261-288, </pages> <address> Menlo Park, CA, 1991. </address> <publisher> AAAI Press / The MIT Press. </publisher>
Reference: [vD80] <author> Diedrik T. van Daalen. </author> <title> The language Theory of AUTOMATH. </title> <type> PhD thesis, </type> <institution> Technical University of Eindhoven, Eindhoven, Netherlands, </institution> <year> 1980. </year>
Reference: [Vel88] <author> Paolo A.S. Veloso. </author> <title> Problem solving by interpretation of theories. </title> <booktitle> In Contemporary Mathematics, </booktitle> <volume> volume 69, </volume> <pages> pages 241-250. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1988. </year>
Reference: [Wa84] <author> D.A. Waterman and al. </author> <title> Design issues for exemplary programming. </title> <editor> In Alan W. Biermann, G. Guiho, and Y. Kodratoff, editors, </editor> <booktitle> Automatic program construction techniques, </booktitle> <pages> pages 433-460. </pages> <publisher> MacMillan Pub. Co., </publisher> <year> 1984. </year>
Reference: [Wal69] <author> Richard J. Waldinger. </author> <title> Constructing programs automatically using theorem proving. </title> <type> Technical Report AD 697 041, </type> <institution> Computer Science Dept. Carnegie-Mellon University, Pittsburg, </institution> <address> PA, </address> <year> 1969. </year> <type> Ph.D. Thesis. </type>
Reference: [Web90] <author> Matthias Weber. </author> <title> Formalization of the Bird-Meertens algorithmic calculus in the DEVA meta-calculus. </title> <booktitle> In IFIP Working Conference on Programming Concepts and Methods, </booktitle> <year> 1990. </year>
Reference: [Wey80] <author> Richard W. Weyhrauch. </author> <title> Prolegomena to theory of mechanized formal reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 133-170, </pages> <year> 1980. </year>
Reference: [Wey82] <author> Richard W. Weyhrauch. </author> <title> An example of FOL using metatheory: formalizing reasoning systems and introducing derived inference rules. </title> <editor> In Donald W. Loveland, editor, </editor> <booktitle> Proceedings of the 6 th Conference on Automated Deduction, </booktitle> <address> New York, USA, </address> <month> June </month> <year> 1982, </year> <booktitle> volume 138 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-158. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1982. </year>
Reference: [Wir71] <author> N. Wirth. </author> <title> Program development by stepwise refinement. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 14(4) </volume> <pages> 221-227, </pages> <month> April </month> <year> 1971. </year>
Reference-contexts: In this context methods from automated theorem proving and plan generation should also be investigated and integrated into our theory. Further programming knowledge worth being studied is contained in research on methodologies <ref> [Dij76, Gri81, Wir71] </ref> which has not yet been automated. The method for formalizing these approaches is always the same: one has to identify the key operations and the parameters they depend on and prove formal meta-theorems about them.
Reference: [WL69] <author> Richard J. Waldinger and R. T. C. Lee. PROW: </author> <title> A step toward automatic program writing. </title> <booktitle> In IJCAI-69 | Proceedings of the 1 st International Joint Conference on Artificial Intelligence, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1969, </year> <pages> pages 241-252. </pages> , <year> 1969. </year>
References-found: 236

