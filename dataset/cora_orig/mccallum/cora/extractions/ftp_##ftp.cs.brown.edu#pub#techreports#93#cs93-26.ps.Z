URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-26.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-26.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. Mani Chandy and Leslie Lamport, </author> <title> ``Distributed Snapshots: Determining Global States of Distributed Systems,'' </title> <journal> ACM Trans on Comp Syst 3(1) pp. </journal> <month> 63-75 (Feb, </month> <year> 1985). </year>
Reference-contexts: Checkpointing and message logging has been mainly studied in the context of fault tolerant computing [4, 10, 12] and global-state evaluation <ref> [1] </ref>. Two major schemes have been proposed: coordinated checkpointing and independent checkpointing. With a coordinated checkpointing, some process must initiate the checkpoint-ing session and run an algorithm to coordinate all other processes in saving their states [1]. Messages that cross the line formed by the local checkpoints are also saved. <p> studied in the context of fault tolerant computing [4, 10, 12] and global-state evaluation <ref> [1] </ref>. Two major schemes have been proposed: coordinated checkpointing and independent checkpointing. With a coordinated checkpointing, some process must initiate the checkpoint-ing session and run an algorithm to coordinate all other processes in saving their states [1]. Messages that cross the line formed by the local checkpoints are also saved. Although coordinated checkpoints can be used for replay, their main disadvantage is that they force all processes to checkpoint at about the same time.
Reference: [2] <author> C. J. Fidge, </author> <title> ``Partial Orders for Parallel Debugging,'' </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 183-194 Madi-son, WI, </address> <month> (May </month> <year> 1988). </year> <note> Also appears in SIGPLAN Notices 24(1) (January 1989). </note>
Reference-contexts: completes a domino dependence */ 5: log Msg; 6: else 7: /* Msg does not complete a domino dependence */ 8: update this process' replay dependence vector ( RDV ) 9: from the RDV piggybacked on Msg; invoked after receiving Msg in process p. 5 similar to a vector timestamp <ref> [2] </ref> (used to maintain the happened-before relation, discussed in Section 3), except that it is a vector of state interval indices, one per process. The current RDV for process p contains the index of the earliest state interval in every other process on which p has a replay dependence.
Reference: [3] <author> Arthur P. Goldberg, Ajei Gopal, Andy Lowry, </author> <title> a nd Rob Strom, ``Restoring Consistent Global States of Distributed Computations,'' </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 144-154 Santa Cruz, CA, </address> <month> (May </month> <year> 1991). </year>
Reference-contexts: Thus, we wish to be able to restart from any checkpoint, which need not be consistent. The fault tolerance results thus do not solve the replay problem. In the debugging community, previous work on independent checkpointing for replay simply traces the contents of all messages <ref> [3, 13] </ref>, which can be prohibitively expensive. Our work on adaptive logging exploits independent checkpointing by combining checkpoints for replay in ways that adapt to the particular execution being traced. This paper reports the first results on how to support trace-and-replay debugging with independent checkpoint-ing without logging all messages.
Reference: [4] <author> David B. Johnson and Willy Zwaenepoel, </author> <title> ``Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing,'' </title> <booktitle> Proc. of the 7th Annual ACM Symp. on Principles of Dist Computing, </booktitle> <year> (1988). </year>
Reference-contexts: If the replay will always begin from either of the two lines shown messages m1 and m3 need not be logged since they will always be recomputed during any replay. Checkpointing and message logging has been mainly studied in the context of fault tolerant computing <ref> [4, 10, 12] </ref> and global-state evaluation [1]. Two major schemes have been proposed: coordinated checkpointing and independent checkpointing. With a coordinated checkpointing, some process must initiate the checkpoint-ing session and run an algorithm to coordinate all other processes in saving their states [1].
Reference: [5] <author> Leslie Lamport, </author> <title> ``Time, Clocks, and the Ordering of Events in a Distributed System,'' </title> <journal> CACM 21(7) pp. </journal> <month> 558-565 (July </month> <year> 1978). </year>
Reference-contexts: The iiiiiRD relation is identical to Lamport's happened-before relation <ref> [5] </ref> except that events in a state interval S p,i do not necessarily depend on events in S p,i-1 (the previous state interval), even though they both belong to the same process.
Reference: [6] <author> Thomas J. LeBlanc and John M. Mellor-Crummey, </author> <title> ``Debugging Parallel Programs with Instant Replay,'' </title> <journal> IEEE Trans. on Computers C-36(4) pp. </journal> <month> 471-482 (April </month> <year> 1987). </year>
Reference-contexts: By tracing the order in which messages are delivered (but not their contents), a traced execution can be replayed from its start by forcing a reex-ecution to deliver messages in the same order <ref> [6, 11, 13] </ref>. Since IPC tracing is necessary for replay, we assume that such a scheme is always used in addition to checkpointing and message logging (and since message contents are not recorded, its overhead is much lower).
Reference: [7] <author> Robert H.B. Netzer and Barton P. Miller, </author> <title> ``Optimal Tracing and Replay for Debugging Message-Passing Parallel Programs,'' </title> <booktitle> Supercomputing '92, </booktitle> <pages> pp. </pages> <address> 502-511 Minneapolis, MN, </address> <month> (November </month> <year> 1992). </year>
Reference-contexts: Our algorithm logs the first message at which such a dependence can be detected, and is thus an approximation. However, experiments show that it performs well. This work is part of our larger effort on developing adaptive tracing strategies for debugging <ref> [7, 8, 14] </ref>. 2. Motivation and Related Work There are two parts to incremental replay of message-passing programs: inter-process communication (IPC) tracing, and checkpointing and message logging. IPC tracing records enough to ensure that replay is deterministic and exhibits the same computation as the original execution. <p> Netzer and Miller have shown how to significantly reduce the size of dependence traces (by 1 to 2 orders of magnitude) by tracing only racing messages, which can be located on-the-y <ref> [7] </ref>. We wish to combine this approach with adaptive message logging. Second, we assumed that processes periodically take checkpoints. We are investigating how checkpointing and message logging can adapt to the execution. Finally, better on-line approx 8 imation algorithms for logging may exist.
Reference: [8] <author> Robert H.B. Netzer, </author> <title> ``Optimal Tracing and Replay for Debugging Shared-Memory Parallel Programs,'' </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 1-11 San Diego, CA, </address> <month> (May </month> <year> 1993). </year>
Reference-contexts: Our algorithm logs the first message at which such a dependence can be detected, and is thus an approximation. However, experiments show that it performs well. This work is part of our larger effort on developing adaptive tracing strategies for debugging <ref> [7, 8, 14] </ref>. 2. Motivation and Related Work There are two parts to incremental replay of message-passing programs: inter-process communication (IPC) tracing, and checkpointing and message logging. IPC tracing records enough to ensure that replay is deterministic and exhibits the same computation as the original execution.
Reference: [9] <author> B. Randell, </author> <title> ``System Structure for Software Fault Tolerance,'' </title> <journal> IEEE Trans. on Software Engineering SE-1(2) pp. </journal> <month> 220-232 (June </month> <year> 1975). </year>
Reference-contexts: If we were to always recompute the messages on which S p,i depends, the domino effect may force arbitrarily many state intervals in the past to be re-executed <ref> [9] </ref>. Our approach is to log enough messages to provide domino-free replay. Figure 3 illustrates a domino effect when replaying S 1,3 .
Reference: [10] <author> R. E. Strom and S. Yemini, </author> <title> ``Optimistic Recovery in Distributed Systems,'' </title> <journal> ACM Trans. on Computer Systems 3 pp. </journal> <month> 204-226 (August </month> <year> 1985). </year>
Reference-contexts: If the replay will always begin from either of the two lines shown messages m1 and m3 need not be logged since they will always be recomputed during any replay. Checkpointing and message logging has been mainly studied in the context of fault tolerant computing <ref> [4, 10, 12] </ref> and global-state evaluation [1]. Two major schemes have been proposed: coordinated checkpointing and independent checkpointing. With a coordinated checkpointing, some process must initiate the checkpoint-ing session and run an algorithm to coordinate all other processes in saving their states [1].
Reference: [11] <author> Kuo-Chung Tai and Sanjiv Ahuja, </author> <title> ``Reproducible Testing of Communication Software,'' </title> <booktitle> IEEE COMPSAC '87, </booktitle> <pages> pp. </pages> <month> 331-337 </month> <year> (1987). </year>
Reference-contexts: By tracing the order in which messages are delivered (but not their contents), a traced execution can be replayed from its start by forcing a reex-ecution to deliver messages in the same order <ref> [6, 11, 13] </ref>. Since IPC tracing is necessary for replay, we assume that such a scheme is always used in addition to checkpointing and message logging (and since message contents are not recorded, its overhead is much lower).
Reference: [12] <author> Y. M. Wang and W. K. Fuchs, </author> <title> ``Optimistic message logging for independent checkpointing in message-passing systems,'' </title> <booktitle> IEEE Symp. on Reliable Distributed Syst., </booktitle> <pages> pp. </pages> <month> 147-154 (Oct </month> <year> 1992). </year>
Reference-contexts: If the replay will always begin from either of the two lines shown messages m1 and m3 need not be logged since they will always be recomputed during any replay. Checkpointing and message logging has been mainly studied in the context of fault tolerant computing <ref> [4, 10, 12] </ref> and global-state evaluation [1]. Two major schemes have been proposed: coordinated checkpointing and independent checkpointing. With a coordinated checkpointing, some process must initiate the checkpoint-ing session and run an algorithm to coordinate all other processes in saving their states [1]. <p> To avoid the domino effect, each process must independently determine which messages to log. Most work on message logging has been in the fault tolerance community, where execution is restarted after a fault only from last consistent checkpoint <ref> [12] </ref>, and old messages can be discarded. However, for debugging, replays are requested often (unlike failures), and they must complete quickly. Thus, we wish to be able to restart from any checkpoint, which need not be consistent. The fault tolerance results thus do not solve the replay problem.
Reference: [13] <author> Larry D. Wittie, </author> <title> ``Debugging Distributed C Programs by Real Time Replay,'' </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 57-67 Madison, WI, </address> <month> (May </month> <year> 1988). </year>
Reference-contexts: By tracing the order in which messages are delivered (but not their contents), a traced execution can be replayed from its start by forcing a reex-ecution to deliver messages in the same order <ref> [6, 11, 13] </ref>. Since IPC tracing is necessary for replay, we assume that such a scheme is always used in addition to checkpointing and message logging (and since message contents are not recorded, its overhead is much lower). <p> Thus, we wish to be able to restart from any checkpoint, which need not be consistent. The fault tolerance results thus do not solve the replay problem. In the debugging community, previous work on independent checkpointing for replay simply traces the contents of all messages <ref> [3, 13] </ref>, which can be prohibitively expensive. Our work on adaptive logging exploits independent checkpointing by combining checkpoints for replay in ways that adapt to the particular execution being traced. This paper reports the first results on how to support trace-and-replay debugging with independent checkpoint-ing without logging all messages.
Reference: [14] <author> Jian Xu and Robert H.B. Netzer, </author> <title> ``Adaptive Independent Checkpointing for Reducing Rollback Propagation,'' </title> <booktitle> IEEE Symp. on Parallel and Distributed Processing, </booktitle> <address> Dallas, TX, </address> <month> (Dec </month> <year> 1993). </year>
Reference-contexts: Our algorithm logs the first message at which such a dependence can be detected, and is thus an approximation. However, experiments show that it performs well. This work is part of our larger effort on developing adaptive tracing strategies for debugging <ref> [7, 8, 14] </ref>. 2. Motivation and Related Work There are two parts to incremental replay of message-passing programs: inter-process communication (IPC) tracing, and checkpointing and message logging. IPC tracing records enough to ensure that replay is deterministic and exhibits the same computation as the original execution.
References-found: 14

