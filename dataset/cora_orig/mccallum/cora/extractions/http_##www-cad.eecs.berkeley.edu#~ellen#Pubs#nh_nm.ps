URL: http://www-cad.eecs.berkeley.edu/~ellen/Pubs/nh_nm.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~ellen/Html/pub.html
Root-URL: http://www.cs.berkeley.edu
Email: brayton@ic.eecs.berkeley.edu ellen@ic.eecs.berkeley.edu  
Phone: (510) 643-5052 (FAX) (510) 643-5052 (FAX)  
Title: Network Hierarchies and Node Minimization Area: Computer Hardware and Design  
Author: R. K. Brayton and E. M. Sentovich Professor Robert K. Brayton Ellen M. Sentovich 
Note: This work was supported by SRC, NSF/DARPA through grant MIP-8719546, the California MICRO Program, Bell Northern Research, and Fujitsu.  
Address: Berkeley, CA 94720  519 Cory Hall 205 Cory Hall #117  Berkeley, CA 94720 Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California at Berkeley  Room  Department of EECS Department of EECS University of California, Berkeley University of California, Berkeley  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R.K. Brayton, G.D. Hachtel, C.T. McMullen, and A.L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: In this paper, we mainly discuss heuristic minimizers because of practical considerations. 2.1 The espresso Paradigm The espresso paradigm <ref> [1] </ref> is a heuristic for finding a good minimal solution, given a current cover f and its don't care set d. It is based on iterating three operations on a current cover (sum-of-products). These are REDUCE, EXPAND, and IRREDUNDANT.
Reference: [2] <author> R. Rudell and A. Sangiovanni-Vincentelli. </author> <title> Exact Minimization of Multiple-Valued Functions for PLA Optimization. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 352-355, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Thus x i is in general a multiple-valued variable and can take on values in the set P i = fv 1 ; : : : ; v k i g. Again the notion of primes and the espresso paradigm generalizes easily <ref> [2] </ref>. 1 2.2 Networks of Single-Output Functions We have discussed the minimization of a single function in terms of finding a minimum sum-of-products representation. This two-level representation is not what we build in practice. Most logic is implemented in multilevel form, as a network of small interconnected gates.
Reference: [3] <author> R.K. Brayton, R. Rudell, A.L. Sangiovanni-Vincentelli, and A.R. Wang. </author> <title> MIS: A Multiple-Level Logic Optimization System. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-6(6):1062-1081, </volume> <month> November </month> <year> 1987. </year>
Reference-contexts: This two-level representation is not what we build in practice. Most logic is implemented in multilevel form, as a network of small interconnected gates. In most modern logic synthesis programs <ref> [3, 4, 5] </ref> this is represented by a Boolean network, a directed acyclic graph where each node is a single-output logic function of arbitrary complexity and an edge exists from node i and node j if the output of function i is an input of function j.
Reference: [4] <author> E.M. Sentovich, K.J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P.R. Stephan, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> SIS: A System for Sequential Circuit Synthesis. </title> <type> Technical Report Memorandum No. </type> <institution> UCB/ERL M92/41, University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: This two-level representation is not what we build in practice. Most logic is implemented in multilevel form, as a network of small interconnected gates. In most modern logic synthesis programs <ref> [3, 4, 5] </ref> this is represented by a Boolean network, a directed acyclic graph where each node is a single-output logic function of arbitrary complexity and an edge exists from node i and node j if the output of function i is an input of function j.
Reference: [5] <author> E.M. Sentovich, K.J. Singh, C. Moon, H. Savoj, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Sequential Circuit Design Using Synthesis and Optimization. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 328-333, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This two-level representation is not what we build in practice. Most logic is implemented in multilevel form, as a network of small interconnected gates. In most modern logic synthesis programs <ref> [3, 4, 5] </ref> this is represented by a Boolean network, a directed acyclic graph where each node is a single-output logic function of arbitrary complexity and an edge exists from node i and node j if the output of function i is an input of function j.
Reference: [6] <author> K.A. Bartlett, R.K. Brayton, G.D. Hachtel, R.M. Jacoby, C.R. Morrison, R.L. Rudell, A.L. Sangiovanni-Vincentelli, and A.R. Wang. </author> <title> Multi-level Logic Minimization Using Implicit Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-7(6):723-740, </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: There are no don't cares given a priori for this node, but it is possible to derive some from information about the surrounding network. Three kinds are derived, SDC (satisfiability don't cares), ODC (observability don't cares), and EXDC (external don't cares) <ref> [6] </ref>. The SDC are obtained 1 Historically, these generalizations sometimes were done just because they could be done, but without any obvious use at the time. <p> Is is conjectured but not known that SDC+ODC+EXDC does precisely characterize all the permissible functions that can be allowed at node i without changing the input/output behavior of the network (modulo the EXDC). We do know that it does characterize a large set in the following sense <ref> [6] </ref>. If we minimize each node in the network so that it is prime and irredundant using the don't care set DC = SDC+ODC+EXDC, then each connection in the network is irredundant, i.e., the network is 100% single stuck-at-1 and stuck-at-0 testable.
Reference: [7] <author> M. Damiani and G. DeMicheli. </author> <title> Derivation of Don't Care Conditions by Perturbation Analysis of Combinational Multiple-Level Logic Circuits. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1991. </year> <month> 12 </month>
Reference-contexts: It turns out that deriving the complete ODC for node i is a difficult problem <ref> [7] </ref> so in practice, only a subset of ODC is used [8, 9]; experience shows that a large and effective subset can be derived and used on most reasonable-sized networks.
Reference: [8] <author> S. Muroga, Y. Kambayashi, H. C. Lai, and J. N. Culliney. </author> <title> The Transduction Method Design of Logic Networks Based on Permissible Functions. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-38(10):1404-1424, </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: It turns out that deriving the complete ODC for node i is a difficult problem [7] so in practice, only a subset of ODC is used <ref> [8, 9] </ref>; experience shows that a large and effective subset can be derived and used on most reasonable-sized networks. An effective and practical way to use this is built into the command full simplify [10] used in the synthesis system sis.
Reference: [9] <author> H. Savoj and R.K. Brayton. </author> <title> The Use of Observability and External Don't Cares for the Simplification of Multi-Level Networks. </title> <booktitle> In Proceedings of the 27 th Design Automation Conference, </booktitle> <pages> pages 297-301, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: It turns out that deriving the complete ODC for node i is a difficult problem [7] so in practice, only a subset of ODC is used <ref> [8, 9] </ref>; experience shows that a large and effective subset can be derived and used on most reasonable-sized networks. An effective and practical way to use this is built into the command full simplify [10] used in the synthesis system sis.
Reference: [10] <author> H. Savoj, H.-Y. Wang, and R.K. Brayton. </author> <title> Improved Scripts in MIS-II for Logic Minimizaton of Combinational Circuits. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: An effective and practical way to use this is built into the command full simplify <ref> [10] </ref> used in the synthesis system sis. Even though in practice one may not derive and use this complete set, it is important to understand and characterize what is possible. Afterwards one can restrict the computation to a subset in a knowledgeable way.
Reference: [11] <author> Yosinori Watanabe. </author> <title> Logic Optimization of Interacting Components in Synchronous Digital Systems. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Even though in practice one may not derive and use this complete set, it is important to understand and characterize what is possible. Afterwards one can restrict the computation to a subset in a knowledgeable way. Recent experiments using BDD's <ref> [11] </ref> show that in some cases use of the full ODC can be more efficient than use of compatible subsets.
Reference: [12] <author> R.K. Brayton and F. Somenzi. </author> <title> Boolean Relations and the Incomplete Specification of Logic Networks. </title> <booktitle> In Proceedings of the International Conference on VLSI, </booktitle> <pages> pages 231-240, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: It was shown that for a network of components where each is a combinational function, the set of permissible functions for a component must in general be represented by a Boolean relation, and that a single Boolean relation is sufficient for this situation <ref> [12] </ref>. The next question is how to derive and represent the Boolean relation representing all permissible functions allowed at node i. With don't cares, it was possible to represent them with a cover of cubes. <p> Minimizing the Boolean Relation Since a Boolean relation is more general than an incompletely specified function, the existing minimizers for minimizing functions with don't cares are not appropriate. Thus work was begun on a Boolean relation minimizer and several heuristic and exact minimizers have been reported <ref> [14, 15, 12, 16, 17] </ref>. One such is gyocro [15], a heuristic minimizer patterned on the espresso paradigm. The EXPAND, IRREDUNDANT, REDUCE iteration was examined and several interesting differences required that these basic operations be altered.
Reference: [13] <author> H. Savoj, R.K. Brayton, and H.J. Touati. </author> <title> Extracting Local Don't Cares for Network Optimization. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 514-517, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Thus the set @z j of different don't cares for the outputs z j are not independent or "compatible". In <ref> [13] </ref>, a technique was given to derive a set of compatible don't cares from O. These are easier to compute and to propagate through a Boolean network, and since they are compatible, can be used independently as required by two-level minimizers.
Reference: [14] <author> R.K. Brayton and F. Somenzi. </author> <title> An Exact Minimizer for Boolean Relations. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 316-319, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Minimizing the Boolean Relation Since a Boolean relation is more general than an incompletely specified function, the existing minimizers for minimizing functions with don't cares are not appropriate. Thus work was begun on a Boolean relation minimizer and several heuristic and exact minimizers have been reported <ref> [14, 15, 12, 16, 17] </ref>. One such is gyocro [15], a heuristic minimizer patterned on the espresso paradigm. The EXPAND, IRREDUNDANT, REDUCE iteration was examined and several interesting differences required that these basic operations be altered.
Reference: [15] <author> Y. Watanabe and R.K. Brayton. </author> <title> Heuristic Minimization of Multiple-Valued Relations. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 126-129, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Minimizing the Boolean Relation Since a Boolean relation is more general than an incompletely specified function, the existing minimizers for minimizing functions with don't cares are not appropriate. Thus work was begun on a Boolean relation minimizer and several heuristic and exact minimizers have been reported <ref> [14, 15, 12, 16, 17] </ref>. One such is gyocro [15], a heuristic minimizer patterned on the espresso paradigm. The EXPAND, IRREDUNDANT, REDUCE iteration was examined and several interesting differences required that these basic operations be altered. <p> Thus work was begun on a Boolean relation minimizer and several heuristic and exact minimizers have been reported [14, 15, 12, 16, 17]. One such is gyocro <ref> [15] </ref>, a heuristic minimizer patterned on the espresso paradigm. The EXPAND, IRREDUNDANT, REDUCE iteration was examined and several interesting differences required that these basic operations be altered.
Reference: [16] <author> A. Ghosh, S. Devadas, and A.R. </author> <title> Newton. Heuristic Minimization of Boolean Relations using Testing Techniques. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: Minimizing the Boolean Relation Since a Boolean relation is more general than an incompletely specified function, the existing minimizers for minimizing functions with don't cares are not appropriate. Thus work was begun on a Boolean relation minimizer and several heuristic and exact minimizers have been reported <ref> [14, 15, 12, 16, 17] </ref>. One such is gyocro [15], a heuristic minimizer patterned on the espresso paradigm. The EXPAND, IRREDUNDANT, REDUCE iteration was examined and several interesting differences required that these basic operations be altered.
Reference: [17] <author> B. Lin and F. Somenzi. </author> <title> Minimization of Symbolic Relations. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 88-91, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Minimizing the Boolean Relation Since a Boolean relation is more general than an incompletely specified function, the existing minimizers for minimizing functions with don't cares are not appropriate. Thus work was begun on a Boolean relation minimizer and several heuristic and exact minimizers have been reported <ref> [14, 15, 12, 16, 17] </ref>. One such is gyocro [15], a heuristic minimizer patterned on the espresso paradigm. The EXPAND, IRREDUNDANT, REDUCE iteration was examined and several interesting differences required that these basic operations be altered.
Reference: [18] <author> Y. Watanabe, L. Guerra, and R.K. Brayton. </author> <title> Logic Optimization with Multioutput Gates. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 416-420, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Experiments were done on Boolean networks starting with single-output internal nodes. Multiple output nodes were formed by suitably clustering compatible nodes. Comparison with state-of-the-art multilevel minimizers showed roughly a 10% improvement <ref> [18] </ref>. An interesting compromise between using the more complex Boolean relation minimizer and a two-level function minimizer consists of grouping together a set of "compatible" gates to form a multiple-output node [19].
Reference: [19] <author> M. Damiani, J. Yang, and G. DeMicheli. </author> <title> Optimization of Combinational Logic Circuits Based on Compatible Gates. </title> <booktitle> In Proceedings of the 30 th Design Automation Conference, </booktitle> <pages> pages 631-636, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Comparison with state-of-the-art multilevel minimizers showed roughly a 10% improvement [18]. An interesting compromise between using the more complex Boolean relation minimizer and a two-level function minimizer consists of grouping together a set of "compatible" gates to form a multiple-output node <ref> [19] </ref>. They show how to use an efficient function minimizer (not a relation minimizer) in this case and that this can lead to better results than normal methods.
Reference: [20] <author> E.M. Sentovich, V. Singhal, and R.K. Brayton. </author> <title> Multiple Boolean Relations. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, California, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Thus one can use some of the flexibility provided by the Boolean relation to obtain a better answer without having to invoke a more complex relation minimizer. 6 2.4 Multiple Boolean Relations An interesting classification of various ways to represent permissible behaviors for combinational logic is given in <ref> [20] </ref>. The most general set of functions is just an arbitrary subset of functions. <p> Finding the smallest such sets can be related to finding a smallest cover of primes of a derived function. It was observed <ref> [20] </ref> that the set of permissible functions for some problems cannot be represented by a single Boolean relation. So indeed, multiple Boolean relations are required. The reason is that a Boolean relation or an incompletely specified function is a set of functions of a special type. <p> In this problem we seek a cover f such that S (x 1 ; x 2 ; x 3 ; f (x 1 ); f (x 2 ); f (x 3 )) = 1. It was shown <ref> [20] </ref> that this problem can be formulated using MBR's but in general not with a single Boolean relation.
Reference: [21] <author> M. Damiani and G. De Micheli. </author> <title> Recurrence Equations and the Optimization of Synchronous Logic Circuits. </title> <booktitle> In Proceedings of the 29 th Design Automation Conference, </booktitle> <pages> pages 556-561, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: A path in the automaton keeps track of input/output pair combinations and thus insures that the input correlations in the specification are satisfied. The resulting automaton is in general a non-deterministic finite automaton, under-scoring the expressibility of multiple Boolean relations for capturing sequential behaviors. In <ref> [21] </ref>, synchronous relations were defined for minimizing sequential circuits. A synchronous relation is derived by "unrolling" a circuit in time, and relating the time shifted variables. <p> It was shown [20] that this problem can be formulated using MBR's but in general not with a single Boolean relation. Special minimizers for synchronous relations have been reported <ref> [22, 21] </ref>, where the objective is to find a cover for f with a minimum number of cubes. 3 Sequential Logic Sequential logic just means a combination of pure logic elements and storage (or state) elements, which we can think of as generic latches.
Reference: [22] <author> V. Singhal, Y. Watanabe, and R.K. Brayton. </author> <title> Heuristic Minimization of Synchronous Relations. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 428-433, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: It was shown [20] that this problem can be formulated using MBR's but in general not with a single Boolean relation. Special minimizers for synchronous relations have been reported <ref> [22, 21] </ref>, where the objective is to find a cover for f with a minimum number of cubes. 3 Sequential Logic Sequential logic just means a combination of pure logic elements and storage (or state) elements, which we can think of as generic latches.
Reference: [23] <author> J. Kim and M. Newborn. </author> <title> The Simplification of Sequential Machines with Input Restrictions. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-21:1440-1443, </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: Some History Don't Care Sequences Historically, this problem was attacked by trying to derive a set of don't care sequences, in analogy to what was done for multilevel logic networks. Similar to the SDC and ODC in a Boolean network, input and output don't care sequences were attempted <ref> [23, 24, 25, 26, 27] </ref>. Input don't care sequences are sequences of inputs that never appear at the inputs to the node j . <p> Output don't care sequences are pairs of sequences for which the behavior of the network is not altered if the output of j is changed from one of the pair to the other. An elegant solution to the input don't care sequences problem was given by Kim and Newborn <ref> [23] </ref> in terms of automata which were used to derive an incompletely specified machine for the internal machine.
Reference: [24] <author> S. Devadas, H.K. Ma, A.R. Newton, and A. Sangiovanni-Vincentelli. </author> <title> Irredundant Sequential Machines via Optimal Logic Synthesis. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 9(1) </volume> <pages> 8-18, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Some History Don't Care Sequences Historically, this problem was attacked by trying to derive a set of don't care sequences, in analogy to what was done for multilevel logic networks. Similar to the SDC and ODC in a Boolean network, input and output don't care sequences were attempted <ref> [23, 24, 25, 26, 27] </ref>. Input don't care sequences are sequences of inputs that never appear at the inputs to the node j .
Reference: [25] <author> J.-K. Rho, G. Hachtel, and F. Somenzi. </author> <title> Don't Care Sequences and the Optimization of Interacting Finite State Machines. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 418-421, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Some History Don't Care Sequences Historically, this problem was attacked by trying to derive a set of don't care sequences, in analogy to what was done for multilevel logic networks. Similar to the SDC and ODC in a Boolean network, input and output don't care sequences were attempted <ref> [23, 24, 25, 26, 27] </ref>. Input don't care sequences are sequences of inputs that never appear at the inputs to the node j .
Reference: [26] <author> H.Y. Wang and R.K. Brayton. </author> <title> Permissible Observability Relations in Interacting Finite State Machines. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, California, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Some History Don't Care Sequences Historically, this problem was attacked by trying to derive a set of don't care sequences, in analogy to what was done for multilevel logic networks. Similar to the SDC and ODC in a Boolean network, input and output don't care sequences were attempted <ref> [23, 24, 25, 26, 27] </ref>. Input don't care sequences are sequences of inputs that never appear at the inputs to the node j . <p> The situation for characterizing output don't care sequences is even worse; in general it seems that MBR's are needed. It is not known in what simpler form these can be characterized, for example, by a single NFA. The paper by Wang <ref> [26] </ref> provides a good discussion about the state of this problem and some new heuristics to derive a subset of permissible behaviors. It is quite surprising then that some recent work gave an answer for capturing all the input and output don't care sequences using a single NFA [30].
Reference: [27] <author> H.-Y. Wang and R.K. Brayton. </author> <title> Input Don't Care Sequences in FSM Networks. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 321-328, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Some History Don't Care Sequences Historically, this problem was attacked by trying to derive a set of don't care sequences, in analogy to what was done for multilevel logic networks. Similar to the SDC and ODC in a Boolean network, input and output don't care sequences were attempted <ref> [23, 24, 25, 26, 27] </ref>. Input don't care sequences are sequences of inputs that never appear at the inputs to the node j . <p> Kim and Newborn derived the set of permissible behaviors as an automaton which is incompletely specified but deterministic. In a recent paper, Wang <ref> [27] </ref> also studied input don't care sequences but allowed an output of M 2 to feed back into M 1 so that general two-way communication is allowed.
Reference: [28] <author> M. Avedillo, J. Quintana, and L. Huertas. </author> <title> New Approach to the State Reduction in Incompletely Specified Sequential Machines. </title> <booktitle> In Proceedings of the International Symposium on Circuits and Systems, </booktitle> <year> 1990. </year>
Reference-contexts: Since in these cases, the derived machine is incompletely specified, one can use standard state minimization methods <ref> [28, 29] </ref>, using the notion of compatible pairs of states to "minimize the machine": a minimum state machine for M 2 is derived. Of course a minimum state machine does not necessarily lead to the best implementation; state minimization is simply a good heuristic.
Reference: [29] <author> J.-K. Rho, G.D. Hachtel, F. Somenzi, and R.M. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Machines. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 13(2) </volume> <pages> 167-177, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Since in these cases, the derived machine is incompletely specified, one can use standard state minimization methods <ref> [28, 29] </ref>, using the notion of compatible pairs of states to "minimize the machine": a minimum state machine for M 2 is derived. Of course a minimum state machine does not necessarily lead to the best implementation; state minimization is simply a good heuristic.
Reference: [30] <author> Y. Watanabe and R.K. Brayon. </author> <title> The Maximum Set of Permissible Behaviors for FSM Networks. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer-Aided Design, </booktitle> <pages> pages 316-320, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: It is quite surprising then that some recent work gave an answer for capturing all the input and output don't care sequences using a single NFA <ref> [30] </ref>. General Problem Consider the general situation. A is the NFA representing the specification automaton for machine . is an FSM network which is a "cover" for some machine M A. <p> This requires a technique which is similar to a subset construction for determinizing a nondeterministic machine. States of the new ~ A j are now subsets of states of A j where subsets containing the state have been deleted. This construction is given in <ref> [30] </ref> and results in a machine called the E-machine. Also there, a similar construction is given for A j when A, the specification automaton, is allowed to be nondeterministic. Example: The construction of the E-machine is illustrated with an example. The interconnection structure is shown in Figure 1.
Reference: [31] <author> Y. Watanabe and R.K. Brayton. </author> <title> State Minimization of Pseudo Non-Deterministic FSM's. </title> <booktitle> In Proceedings of the European Conference on Design Automation, </booktitle> <year> 1994. </year> <month> 13 </month>
Reference-contexts: Instead we want a minimum state machine contained in a given NFA. The distinction is that in the former we want to keep all behaviors while in the latter, we are looking for only one behavior contained in the NFA. A key observation, made in <ref> [31] </ref>, is that the E-machine is a pseudo non-deterministic FSM (PNDFSM), meaning that its corresponding automaton, constructed by merging input and output symbols into single input symbols on the edges, 10 is deterministic. <p> Thus all of the compatibles shown could be part of a Moore machine because each output function is independent of the input u. implementations of M 1 . In <ref> [31] </ref>, both exact and heuristic minimization procedures are presented for generating a solution, and again the espresso paradigm is employed in a heuristic search procedure. Still, these techniques produce only a minimum-state 11 machine, which does not necessarily lead to a minimum-sized implementation.
References-found: 31

