URL: http://www.cs.ucla.edu/~zaniolo/cz/iclp95.ps
Refering-URL: http://www.cs.ucla.edu/~zaniolo/cz/ZanioloPapers.html
Root-URL: http://www.cs.ucla.edu
Title: Relating Stable Models and AI Plan-  Domains  
Author: ning V.S. Subrahmanian Carlo Zaniolo 
Address: College Park, MD 20742, U.S.A.  Los Angeles, CA 90024, USA.  
Affiliation: University of Maryland  University of California  
Abstract: In this paper, we show that there is a simple connection between logic programming and planning. The main result of this paper is the following: given any planning domain consisting of an initial state, and a set of operation definitions, this domain can be translated, in linear-time, to a logic program such that a given goal G is achievable in the planning domain iff a related goal G ? is true in some stable model of the logic program obtained by the translation. We show that this translation yields at least two interesting consequences: (1) methods to update databases can be used to handle surprises when executing plans (i.e. a surprise occurs when an initial plan is partly executed, but one of the resulting intermediate states differs, perhaps due to external reasons, from what is predicted). (2) rigid actions, which are actions that must be executed when their pre-conditions are true, can be easily accommodated within our framework as well. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bonner and M. Kifer. </author> <title> (1993) Transaction Logic Programming, </title> <booktitle> Proc. 1993 Intl. Conf. on Logic Programming (ed. D.S. Warren), </booktitle> <address> pps 257-279, </address> <publisher> MIT Press. </publisher>
Reference-contexts: We show how such actions can be incorporated within our framework. The idea that there is a connection between planning and logic programming is not new. Bonner and Kifer <ref> [1] </ref> proposed a formalism called transaction logic programming where they developed a path-based modal semantics for logic programming and show how planning operators can be incorporated in their language. In contrast, we do not extend logic programming in any way.
Reference: [2] <editor> D. Chimenti et. al. </editor> <title> (1990) The LDL System Prototype, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2, 1, </volume> <pages> pps 76-90. </pages>
Reference-contexts: The stable semantics for logic programs is one of the best known semantics for logic programming with negation. We present a uniform translation of planning domains into logic programs whose stable models capture the set of goals achievable from the planning domain. The LDL system <ref> [2] </ref> that has been implemented over the years at MCC has facilities to support the use of the choice construct, and hence, LDL can be used as a platform upon which to develop efficient implementations of planning systems based upon the translation of planning domains to logic programs described herein. 2 <p> The predicate choice is a special predicate that, for each instance of its first argument, nonde-terministically picks a unique instance of the second argument hence the word choice. The semantics of such choice constructs have been extensively studied in the database literature <ref> [2, 11] </ref>, and are fully implemented in the LDL system fielded by MCC [2]. Frame Axioms. <p> The semantics of such choice constructs have been extensively studied in the database literature [2, 11], and are fully implemented in the LDL system fielded by MCC <ref> [2] </ref>. Frame Axioms.
Reference: [3] <author> P. M. Dung. </author> <title> (1993) Representing Actions in Logic Programming and its Applications in Database Updates, </title> <booktitle> Proc. 1993 Intl. Conf. on Logic Programming (ed. D.S. Warren), </booktitle> <address> pps 222-238, </address> <publisher> MIT Press. </publisher>
Reference-contexts: At the same time, Gelfond and Lifschitz [6] have argued that incorporating actions into logic programming may be achieved by using two forms of negation explicit negation, and nonmonotonic negation. Dung <ref> [3] </ref> has argued that there are various inadequacies in the Gelfond-Lifschitz framework. He has suggested a new language that incorporates actions into logic programming, studied the semantics of this language, and proven various elegant soundness and completeness results.
Reference: [4] <author> K. Erol, </author> <title> D.S. Nau and V.S. Subrahmanian. (1992) On the Complexity of Domain-Independent Planning, </title> <booktitle> Proc. AAAI-92, </booktitle> <publisher> MIT Press, </publisher> <month> July </month> <year> 1992. </year>
Reference-contexts: Dung [3] has argued that there are various inadequacies in the Gelfond-Lifschitz framework. He has suggested a new language that incorporates actions into logic programming, studied the semantics of this language, and proven various elegant soundness and completeness results. Erol, Nau and Subrahmanian <ref> [4] </ref> have shown that there is a very simple and natural translation of planning domains (whose operations have empty delete lists) to negation-free logic programs such that a goal G can be achieved from the planning domain iff a related goal can be proved from the negation-free logic program obtained by
Reference: [5] <author> K. Erol, </author> <title> D.S. Nau and V.S. Subrahmanian. (1992) Complexity, Decid-ability and Undecidability Results for Domain-Independent Planning. </title> <note> accepted for publication in: Artificial Intelligence journal. </note>
Reference: [6] <author> M. Gelfond and V. Lifschitz. </author> <title> (1988) Logic Programs with Classical Negation, </title> <booktitle> in: Proc. 7th International Conference on Logic Programming, </booktitle> <editor> eds. D.H.D. Warren and P. Szeredi, </editor> <address> pps 579-597. </address>
Reference-contexts: The situation calculus, due to McCarthy [8] is perhaps the best known such formalism. A resurgence of interest in the situation calculus, and its implementation via logic programming has recently been studied by Pinto and Reiter [9]. At the same time, Gelfond and Lifschitz <ref> [6] </ref> have argued that incorporating actions into logic programming may be achieved by using two forms of negation explicit negation, and nonmonotonic negation. Dung [3] has argued that there are various inadequacies in the Gelfond-Lifschitz framework.
Reference: [7] <author> M. Gelfond and V. Lifschitz. </author> <title> (1992) Representing Actions in Extended Logic Programming, </title> <booktitle> Proc. 9th International Conference and Symposium on Logic Programming, </booktitle> <editor> ed. K. </editor> <publisher> Apt. </publisher>
Reference: [8] <author> J. McCarthy and P. Hayes. </author> <title> (1969) Some Philosophical Problems from the Standpoint of Artificial Intelligence, </title> <booktitle> in: Machine Intelligence 4 (eds. </booktitle> <editor> B. Meltzer and D. Michie), </editor> <address> pps 463-502. </address>
Reference-contexts: Expressing such a specification of an operation using formal logic has been studied widely. The situation calculus, due to McCarthy <ref> [8] </ref> is perhaps the best known such formalism. A resurgence of interest in the situation calculus, and its implementation via logic programming has recently been studied by Pinto and Reiter [9].
Reference: [9] <author> J. Pinto and R. Reiter. </author> <title> (1993) Temporal Reasoning in Logic Program--ming: A Case for the Situation Calculus, </title> <booktitle> Proc. 1993 Intl. Conf. on Logic Programming (ed. D.S. Warren), </booktitle> <address> pps 203-221, </address> <publisher> MIT Press. </publisher>
Reference-contexts: The situation calculus, due to McCarthy [8] is perhaps the best known such formalism. A resurgence of interest in the situation calculus, and its implementation via logic programming has recently been studied by Pinto and Reiter <ref> [9] </ref>. At the same time, Gelfond and Lifschitz [6] have argued that incorporating actions into logic programming may be achieved by using two forms of negation explicit negation, and nonmonotonic negation. Dung [3] has argued that there are various inadequacies in the Gelfond-Lifschitz framework.
Reference: [10] <author> T. Przymusinski. </author> <title> (1988) On the Declarative and Procedural Semantics of Stratified Deductive Databases, </title> <editor> in J. Minker (ed.), </editor> <booktitle> "Foundations of Deductive Databases and Logic Programming," </booktitle> <address> pps 193-216, Morgan-Kaufman. </address>
Reference-contexts: It is well-known that a locally stratified logic program Q has a unique stable model, which can be computed as follows: Iterated Fixpoint basis: M 0 := ; induction: for 0 &lt; j M j := the unique perfect model (cf. Przymusinski <ref> [10] </ref>) of M j1 [ ground j (Q); where: ground j (Q) denotes the rules of ground (Q) with head in the j-th stratum 2 . <p> The result, of the iterated fixpoint procedure just described, M ! = [ 0j&lt;! M j , is equal to the perfect model, and unique stable model, of Q <ref> [10] </ref>. Suppose now that P is a planning domain hence, by Proposition 3.1, CH (P) is locally stratified modulo choice. Observe that LP (P) can be split into the set of rules defining the diffchoice predicate, denoted DFC (LP (P)), and the remaining rules LP (P)DFC (LP (P)).
Reference: [11] <author> D. Sacca and C. Zaniolo. </author> <title> (1990) Stable Models and Non-Determinism in Logic Programs with Negation, </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems. </booktitle>
Reference-contexts: connection between the stable model semantics for logic programs, active databases, and AI planning domains. 3.1 Choice Models and AI Planning Domains In this section, we will show how, given a planning domain, P, we can associate a logic program, CH (P), with choice constructs (due to Sacca and Zaniolo <ref> [11] </ref>). For every ground atom p ( ~ t) 2 S 0 , CH (P) contains the unit clause p (0; ~ t) . Intuitively, this clause says that p ( ~ t) is true at stage 0. <p> The predicate choice is a special predicate that, for each instance of its first argument, nonde-terministically picks a unique instance of the second argument hence the word choice. The semantics of such choice constructs have been extensively studied in the database literature <ref> [2, 11] </ref>, and are fully implemented in the LDL system fielded by MCC [2]. Frame Axioms. <p> ; O), we can convert P into a choice logic program, CH (P), by associating, with each operator ff 2 O, the clauses (1)- (4) above, and for each predicate symbol p, the clauses (5) and (6) above. 3.2 From Choice Programs to Choice-Free Programs Using the techniques specified in <ref> [11] </ref>, any choice logic program can be converted into a logic program with negation. <p> Each result, of such a computation, i.e., M ! = S will be called a result of the Iterated Choice Fixpoint on P . Theorem 3.1 (Sacca and Zaniolo <ref> [11] </ref>) Any logic program that is locally stratified modulo choice has at least one stable model. 2 It follows immediately from Theorem 3.1 and by Proposition 3.1 that: Proposition 3.2 Suppose P is a planning domain. <p> It is precisely this notion of choice that provides a correspondence between logic programs with choice constructs (Sacca and Zaniolo <ref> [11] </ref>), and AI planning domains. In many domains however, there may be a variety of operations that must be executed whenever their pre-conditions are satisfied. We term such operations rigid operations. Such operations may include safety devices in intelligent plant monitoring devices and mission-critical control systems.
Reference: [12] <author> V.S. Subrahmanian and C. Zaniolo. </author> <title> (1994) Database Updates and AI Planning Domains, </title> <type> Tech. Report, </type> <institution> Univ. of Maryland. </institution>
Reference-contexts: We have shown how our framework can be used to represent such actions. Due to space limitations, we have not been able to include a detailed example illustrating the theory underlying this paper. The user interested in a more comprehensive description is referred to <ref> [12] </ref>. Acknowledgements. We are grateful to Antonio Brogi, Jim Hendler and Kutluhan Erol for comments on a previous version of this manuscript. Acknowledgements This work was supported by the Army Research Office under grant number DAAL-03-92-G-0225, by the Air Force Office of Scientific Research under Grant Nr.
Reference: [13] <author> C. Zaniolo. </author> <title> (1993) A Unified Semantics for Active and Deductive Databases, in "Rules in Database Systems," </title> <editor> (N. Paton, ed.), </editor> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Zaniolo <ref> [13] </ref> has described a procedure whereby this can be operationally accomplished on top of the LDL database system. In short, plan modification in the presence of surprises corresponds to incremental switching from one stable model to another.
References-found: 13

