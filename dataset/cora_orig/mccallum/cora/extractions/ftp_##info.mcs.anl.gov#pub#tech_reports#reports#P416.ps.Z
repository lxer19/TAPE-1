URL: ftp://info.mcs.anl.gov/pub/tech_reports/reports/P416.ps.Z
Refering-URL: http://www.mcs.anl.gov/publications/abstracts/abstracts94.htm
Root-URL: http://www.mcs.anl.gov
Email: e-mail: boyle@mcs.anl.gov  
Title: 83 Automatic, Self-adaptive Control of Unfold-Fold Transformations  
Author: James M. Boyle a 
Keyword: Keyword Codes: D.1.2; D.1.1; F.4.2 Keywords: Automatic Programming; Applicative (Functional) Programming; Grammars and Other Rewriting Systems  
Note: This work was supported in part by the Office of Scientific Computing, U.S. Department of Energy, under Contract W-31-109-Eng-38, and in part by the BM/C3 directorate, Ballistic Missile Defense Organization, U.S. Department of Defense  
Address: IL 60439, U.S.A.  
Affiliation: a Mathematics and Computer Science Division, Argonne National Laboratory, Argonne,  
Abstract: I describe an automated approach to partial evaluation based transformations for elementary simplifications and unfolding and folding. The approach emphasizes program algebra and relies on canonical forms and distributive laws to expose instances to which the elementary simplifications apply. This approach to partial evaluation has been applied to a number of practical examples of moderate complexity, including eliminating a data structure from a partial-differential-equation solver. Program transformations for unfolding and folding were introduced in the classic paper of Burstall and Darlington [7]. These transformations are very powerful; they are capable of proving theorems about function definitions by mathematical induction. Use of unfold-fold in automatic program transformation is difficult, however. The unfold transformation, in particular, is challenging, because it replaces the application of a named function by an application of the definition of that function. Obviously, if the named function is recursive, such replacement could go on forever. After to the appearance of the Burstall and Darlington paper, some work was done on control of unfold-fold transformations. Feather [8] implemented a strategy in which unfolding took place until a user-specified pattern was found. The user of Feather's system prevented infinite unfolding by providing an explicit limit on the number of times unfolding took place. Feather's approach has not been widely used, however, in part because it is difficult to predict the required target pattern and the limit on unfolding; in practice, their determination required extensive experimentation. A somewhat similar approach is to use "metaprogramming" to control unfolding. This approach also suffers 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> James M. Boyle, </author> <title> A Transformational Component for Programming Language Grammar, </title> <type> Report ANL-7690, </type> <institution> Argonne National Laboratory, Argonne, Illinois, </institution> <month> July </month> <year> 1970. </year> <month> 103 </month>
Reference: 2. <author> James M. Boyle and M. N. Muralidharan, </author> <title> Program reusability through program transformation, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, No. 5, </volume> <month> Sept. </month> <year> 1984, </year> <pages> pp. 574-588. </pages>
Reference: 3. <author> James M. Boyle, Kenneth W. Dritz, Monagur M. Muralidharan, and Roy Taylor, </author> <title> Deriving Sequential and Parallel Programs from Pure LISP Specifications by Program Transformation , Program Specification and Transformation, </title> <booktitle> Proceedings of the IFIP TC2/WG2.1 Working Conference on Program Specification and Transformation, </booktitle> <address> Pacific Grove, Calif., </address> <month> 13-16 May </month> <year> 1991, </year> <editor> L.G.L.T. Meertens, ed., </editor> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1987. </year>
Reference: 4. <author> James M. Boyle, </author> <title> Abstract programming and program transformations|An approach to reusing programs. Software Reusability, Volume I, </title> <editor> Ted J. Biggerstaff and Alan J. Perlis, eds., </editor> <publisher> ACM Press (Addison-Wesley Publishing Company), </publisher> <address> New York, </address> <year> 1989, </year> <pages> pp. 361-413. </pages>
Reference-contexts: and cons .sd. car ( cons ( &lt;basic entity&gt;"1" &lt;type info&gt;"1" ) ( &lt;entity&gt; ) &lt;type info&gt; ) &lt;type info&gt; ==&gt; &lt;basic entity&gt;"1" &lt;type info&gt;"1" .sc. are immaterial, while that of the first argument of cons (&lt;basic entity&gt;"1") is to be preserved in the result of applying the transformation. (See <ref> [4] </ref> for a brief discussion of how one writes TAMPR transformations.) 5.10.
Reference: 5. <author> James M. Boyle and Terence J. Harmer, </author> <title> Functional Specifications for Mathematical Computations, Constructing Programs from Specifications, </title> <booktitle> Proceedings of the IFIP TC2/WG2.1 Working Conference on Constructing Programs from Specifications, </booktitle> <address> Pacific Grove, Calif., </address> <month> 13-16 May </month> <year> 1991, </year> <editor> B. Moller, ed., </editor> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1991, </year> <pages> pp. 205-224. </pages>
Reference: 6. <author> James M. Boyle and Terence J. Harmer, </author> <title> A practical functional program for the CRAY X-MP, </title> <journal> Journal of Functional Programming, </journal> <volume> Vol. 2, No. 1, </volume> <month> Jan. </month> <year> 1992, </year> <pages> pp. 81-126. </pages>
Reference: 7. <author> R. M. Burstall and J. Darlington, </author> <title> A transformation system for developing recursive programs, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 24, No. 1, </volume> <year> 1977, </year> <pages> pp. 44-67. </pages>
Reference-contexts: 1. WHY SELF-ADAPTIVE UNFOLDING? Program transformations for unfolding and folding were introduced in the classic paper of Burstall and Darlington <ref> [7] </ref>. These transformations are very powerful; they are capable of proving theorems about function definitions by mathematical induction. Use of unfold-fold in automatic program transformation is difficult, however. <p> These steps employ algebraic manipulation to expose possibilities for simplification. 5.3. Unfolding to Expose Simplifications Because parts of the information needed to apply an elementary simplification may be hidden in separate function definitions, function definitions must be unfolded (copied in place of the applications of their function names) <ref> [7] </ref> in order to expose simplifications.
Reference: 8. <author> Martin S. Feather, </author> <title> A system for assisting program transformation, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 1, </volume> <year> 1982, </year> <pages> pp. 1-20. </pages>
Reference-contexts: Obviously, if the named function is recursive, such replacement could go on forever. After to the appearance of the Burstall and Darlington paper, some work was done on control of unfold-fold transformations. Feather <ref> [8] </ref> implemented a strategy in which unfolding took place until a user-specified pattern was found. The user of Feather's system prevented infinite unfolding by providing an explicit limit on the number of times unfolding took place.
Reference: 9. <author> Daniel P. Friedman and Matthias Felleisen, </author> <title> The Little LISPer, </title> <institution> Science Research Associates, Inc., Chicago, </institution> <year> 1986. </year>
Reference: 10. <author> Carsten K. Gomard and Neil D. Jones, </author> <title> A partial evaluator for the untyped lambda-calculus, </title> <journal> Journal of Functional Programming, </journal> <volume> Vol. 1, No. 1, </volume> <month> Jan. </month> <year> 1991, </year> <pages> pp. 21-69. </pages>
Reference: 11. <author> C. A. R. Hoare, He Jifeng, and A. Sampaio, </author> <title> Normal form approach to compiler design, </title> <journal> Acta Informatica, </journal> <volume> Vol. 30, </volume> <year> 1993, </year> <pages> pp. 701-739. </pages>
Reference-contexts: Thus, TAMPR computes the fixed point (if it exists) of a set of transformations applied to a program text, producing a new text in a (new) canonical form. A slightly different view of the use of a canonical form to guide transformation is discussed in <ref> [11] </ref>. I point out that the use of canonical 88 forms has always been fundamental to using TAMPR, and it has been discussed in [2-4]. One wishes, of course, to write transformation rules that preserve correctness. A fertile source for such rules is algebraic identities|identities in a program algebra.
Reference: 12. <author> B. Moller, ed., </author> <title> Constructing Programs from Specifications, </title> <booktitle> Proceedings of the IFIP TC2/WG2.1 Working Conference on Constructing Programs from Specifications, </booktitle> <address> Pacific Grove, Calif., 13-16 May 1991, </address> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1991. </year>
Reference-contexts: A fertile source for such rules is algebraic identities|identities in a program algebra. For partial evaluation of the type discussed here, the program algebra is the -calculus. In many areas of program transformation (see, for example, the papers in <ref> [12] </ref>), distributive laws play a significant role. Partial evaluation is no exception. Thus, besides the familiar laws from -calculus (ff- and fi-conversion), I use less-familiar distribution laws for lambda expressions as the basis for transformations. 5.2.
Reference: 13. <author> Hanne Riis Nielson and Flemming Nielson, </author> <title> Using transformation in the implementation of higher-order functions, </title> <journal> Journal of Functional Programming, </journal> <volume> Vol. 1, No. 4, </volume> <month> Oct. </month> <year> 1991, </year> <pages> pp. 459-494. </pages>
Reference-contexts: That is, practical automated binding-time analysis must err on the side of safety; it must make some assumptions that lead to classifying data that in reality is available at partial-evaluation time as not being available until run time <ref> [13] </ref>. In particular, it is not clear whether automated binding-time analysis is able to recognize that data (such as the size of a set) encoded in user-defined functions is available at partial-evaluation time, even though such data may lead to simplifications. Thus, other approaches are worth considering.
References-found: 13

