URL: ftp://ftp.cs.arizona.edu/reports/1997/TR97-16.ps
Refering-URL: http://www.cs.arizona.edu/people/spatsch/resume.html
Root-URL: http://www.cs.arizona.edu
Title: Joust: A Platform for Communication-Oriented Liquid Software  
Author: John H. Hartman, Larry L. Peterson, Andy Bavier Peter A. Bigot, Patrick Bridges, Brady Montz Rob Piltz, Todd A Proebsting, and Oliver Spatscheck 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Note: December  
Date: TR 97-16  3, 1997  
Abstract: Joust is a software platform for liquid softwarecode that flows easily from machine to machine. Liquid software makes it easier to maintain, debug, update, and customize networked systems. One of the most interesting applications of liquid software is to interject it into the nodes of a network, allowing network functionality, such as routing, to be customized. Additional features, such as special-purpose congestion control and filtering algorithms, are also easily added. The challenge is to develop a communication-oriented platform for liquid software, one in which the focus is the efficient transfer of data, not high-performance computation. To this end we have designed and implemented Joust, which consists of a complete re-implementation of the Java virtual machine (including both the runtime system and a just-in-time compiler), running on the Scout operating system (a configurable, communication-oriented OS). The result is a configurable, high-performance platform for running communication-oriented liquid software. We present the results of implementing three different liquid software applications on Joust, including a prototype architecture for active networks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practive & Experience, </journal> <pages> pages 807820, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: This limited form of roll-forward prevents the system from deadlocking if the catching thread is inside a critical section when an exception is thrown. Finally, the JVM provides garbage-collection facilities. The Joust garbage collector is adapted from the Boehm-Demers-Weiser (BDW) conservative garbage collector <ref> [1] </ref>. This collector considers every register and every word of allocated memory a potential pointer, and considers all memory reachable from these pointers to be in-use.
Reference: [2] <author> M. Corporation. </author> <title> Microsoft security management architecture white paper. </title> <note> URL: http://www.microsoft.com/security/ie4security.htm, 1997. </note>
Reference-contexts: The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within the JVM. This is the subject of current research, as summarized in [12]. Netscape [3] and Microsoft <ref> [2] </ref> use object signing to identify the principal responsible for the program, and extended stack introspection to determine the rights of a current thread. These models can easily be used, not only to reveal the rights a current thread possesses, but also to determine the principal that requested those rights.
Reference: [3] <author> N. C. Corporation. </author> <title> Netscape devedge online documentation. </title> <note> URL: http://developer.netscape.com/library/documentation/, 1997. </note>
Reference-contexts: The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within the JVM. This is the subject of current research, as summarized in [12]. Netscape <ref> [3] </ref> and Microsoft [2] use object signing to identify the principal responsible for the program, and extended stack introspection to determine the rights of a current thread.
Reference: [4] <author> W. G. Griswold and P. S. Phillips. </author> <title> Microbenchmarks for Java. </title> <note> URL: http://www-cse.uscd.edu/wgg/JavaProf/javaprof.html, 1996. </note>
Reference-contexts: Table 1 shows the performance of several Java implementations on a set of microbenchmarks adapted from the UCSD Java Microbench-marks <ref> [4] </ref>. The times are in microseconds, obtained by measuring a given number of repetitions and averaging. All tests were performed on a 200MHz Pentium Pro system; the Unix tests used Linux 2.0.31. We tested two versions of Sun's Java Developer's Kit.
Reference: [5] <author> M. Hicks, P. Kakkar, J. T. Moore, C. A. Gunter, and S. Nettles. </author> <title> PLAN: A programming language for active networks. </title> <address> URL: http://www.cis.upenn.edu/switchware/papers/plan.ps. </address>
Reference-contexts: A network that exploits liquid software in this way is often called an active network because the network's packet delivery service is programmable instead of fixed <ref> [13, 5] </ref>. For a system to support liquid softwarethat is, for a program to run on any node in the networkeach node must export a common interface. This interface must be independent of both the node's machine architecture and its operating system.
Reference: [6] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: This interface must be independent of both the node's machine architecture and its operating system. Java provides a good starting point for building such a system <ref> [6] </ref>. Java bytecode defines an architecture-independent representation of a program, and the Java Virtual Machine (JVM) defines an OS-independent interface for accessing OS/hardware resources. While Java provides a good foundation for liquid software, the current JVM is limited in both the functionality it provides and the performance it delivers.
Reference: [7] <author> D. Mosberger. </author> <title> Scout: A path-based operating system. </title> <type> PhD thesis, </type> <institution> University of Arizona, </institution> <year> 1997. </year>
Reference-contexts: First, NetTV is able to achieve excellent MPEG performance. Table 4 compares the maximum frame rates for videos played on Scout and Linux/X11 systems; we observe that Scout consistently outperforms a Linux-based MPEG decoder by 20-34% <ref> [7] </ref>. We know of no comparable numbers for an MPEG decoder written in Java. Second, separating the MPEG path from the JVM makes it possible to schedule the two entities separately, and in fact, allows different schedulers to be 14 used for each.
Reference: [8] <author> D. Mosberger and L. Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 73153168, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: The system, called Joust, is specifically designed to support liquid software on low-level, communication-oriented systems, of which active networks are a driving example. To a first approximation, Joust is an implementation of the JVM on top of the Scout operating system <ref> [8] </ref>. As illustrated in Figure 1, it consists of the underlying Scout OS, a runtime system for the JVM, and a Just-in-Time (JIT) compiler that translates Java bytecodes into native instructions.
Reference: [9] <author> B. G. H. </author> <note> Page. Biss GmbH. URL: http://www.biss-net.com/, 1997. </note>
Reference-contexts: Unfortunately, WIMP is not a GUI toolkit; it is simply a window manager. It draws geometric shapes, but does not implement widgets, such as 7 buttons. Instead of writing an entire GUI toolkit ourselves, we use the BISS GmbH <ref> [9] </ref> implementation of the AWT. BISS AWT can be used as a substitute for Java's AWT, or as the toolkit underneath it. Joust uses it as a toolkit so that applications require no modification; they use the standard Sun AWT classes.
Reference: [10] <author> T. A. Proebsting, G. Townsend, P. Bridges, J. H. Hartman, T. Newsham, and S. A. Watterson. Toba: </author> <title> Java for applicationsa way ahead of time (WAT) compiler. </title> <type> Technical Report 9701, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <year> 1997. </year>
Reference-contexts: Third, the Java API itself must be extended so that Java applications can directly take advantage of Scout functionality. 3.1 General Optimizations Joust's JVM was originally developed for the Toba system <ref> [10] </ref>. There are several platform-independent issues in the implementation of the JVM, primarily related to differences between the JVM's functionality and that commonly provided by operating systems. First, the JVM implements pre-emptive threads that use monitors and condition variables to synchronize. <p> This involves exposing the path and message abstraction to the application, so that it can use them effectively. Together, these optimizations result in a high-performance JVM that is specialized for use in a communication-oriented system. 4 Bytecode Compiler The Joust execution framework is based on the Toba translation system <ref> [10] </ref>. Toba originally supported a way-ahead-of-time (WAT) Java translator, and ran on various Unix systems. We have since ported it to Scout and added a just-in-time (JIT) compiler.
Reference: [11] <author> O. Spatscheck and L. Peterson. Escort: </author> <title> Scout security architecture. </title> <type> Technical Report TR97-17, </type> <institution> The Department of Computer Science, University of Arizona, Tucson, Arizona, </institution> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: When these applications are independenti.e., they do not interact within the scope of JVMsecurity can be enforced by multiply instantiating the JVM module. This can be done in Scout, which boths supports multiple instantiation of modules and the isolation of modules in hardware-enforced protection domains <ref> [11] </ref>. The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within the JVM. This is the subject of current research, as summarized in [12].
Reference: [12] <author> D. Wallach, D. Balfanz, D. Dean, and E. Felten. </author> <title> Extensible security architecture for Java. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 116128, </pages> <address> Saint Malo, France, </address> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: The more difficult question is how to enforce a security policy for multiple, mutually untrusted Java applications that interact with each other within the JVM. This is the subject of current research, as summarized in <ref> [12] </ref>. Netscape [3] and Microsoft [2] use object signing to identify the principal responsible for the program, and extended stack introspection to determine the rights of a current thread.
Reference: [13] <author> D. Wetherall, J. Guttag, and D. Tennenhouse. </author> <title> ANTS: A toolkit for building and dynamically deploying network protocols. </title> <booktitle> In IEEE OPENARCH 98, </booktitle> <address> San Francisco, CA, </address> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: A network that exploits liquid software in this way is often called an active network because the network's packet delivery service is programmable instead of fixed <ref> [13, 5] </ref>. For a system to support liquid softwarethat is, for a program to run on any node in the networkeach node must export a common interface. This interface must be independent of both the node's machine architecture and its operating system. <p> In an active network, routers not only forward packets, but they may also execute code on behalf of those packets. For example, this code could do sophisticated routing, congestion control management, or packet filtering. ANTS is an experimental active network architecture written in Java <ref> [13] </ref>. All ANTS packets, called capsules, carry or refer to executable code. This code is installed in ANTS routers in the network as they are traversed by capsules.
Reference: [14] <author> T. Wilkinson and Associates. KAFFE: </author> <title> A free virtual machine to run Java code. </title> <note> URL: http://www.kaffe.org, 1997. </note>
Reference-contexts: We tested two versions of Sun's Java Developer's Kit. Version 1.0.2 is the one with which Toba (and Joust) is compatible, but significant performance improvements in later JDK releases make it appropriate to base our comparisons on JDK 1.1.3. We also compare with the Kaffe system <ref> [14] </ref>, another system which implements just-in-time compilation of Java bytecode. The final three columns compare the Toba/Linux JIT, the Toba/Linux WAT, and Joust. The microbenchmark names are for the most part descriptive.
References-found: 14

