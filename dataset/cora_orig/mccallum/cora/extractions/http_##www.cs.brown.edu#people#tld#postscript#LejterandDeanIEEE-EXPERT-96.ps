URL: http://www.cs.brown.edu/people/tld/postscript/LejterandDeanIEEE-EXPERT-96.ps
Refering-URL: http://www.cs.brown.edu/people/tld/
Root-URL: 
Email: Email: fmlm,tldg@cs.brown.edu  
Phone: Phone: (401) 863-7600 Fax: (401) 863-7657  
Title: A Framework for the Development of Multi-Agent Architectures  
Author: Moises Lejter Thomas Dean 
Address: 115 Waterman Street, Providence, RI 02912, USA  
Affiliation: Department of Computer Science, Brown University  
Abstract: This paper describes a high-performance software system that supports distributed computing and multi-agent coordination. Our system provides the facilities necessary for experimenting with a variety of choices at different levels of abstraction. At each level, we provide a set of abstractions, tools to manipulate those abstractions, and the design rationale behind those abstractions. This paper presents the abstractions that make up our system, along with an empirical evaluation of their usefulness. At the base level, we define a set of abstractions for communications among a collection of agents. At this level, the key advantages of our system are twofold: design flexibility and scalability. We also provide additional abstractions that provide functionality equivalent to that found in other well-known communications formalisms. At higher levels, we define a set of abstractions that describe the most widely used distributed control protocols. As a result, we also gain portability. We also provide an empirical evaluation of the utility of our framework for the construction of distributed systems. The low-level abstractions are evaluated in the context of their efficiency and scalability for likely distributed architectures; the high-level abstractions are evaluated in terms of their expressive power. 
Abstract-found: 1
Intro-found: 1
Reference: [Amir et al, 1992] <author> Yair Amir, Danny Dolev, Shlomo Kramer, and Dalia Malki, Transis: </author> <title> A Communication Subsystem for High Availability,, </title> <institution> He-brew University of Jerusalem Tech Report CS91-13, </institution> <month> April 30, </month> <year> 1992. </year>
Reference: [Andrews, 1991] <author> Gregory R. Andrews, </author> <title> Paradigms for Process Interaction in Distributed Programs, </title> <journal> ACM Computing Surveys, </journal> <volume> 23: </volume> <pages> 4990. </pages>
Reference-contexts: Most distributed systems evolve a control structure during their design that is appropriate for the tasks that system is assigned. A few different strategies can be identified, across the distributed systems described in the literature (see <ref> [Andrews, 1991] </ref> for a survey of distributed processing paradigms): * pipeline In pipeline strategies, the individual agents in the system are seen as producer/consumers of information. <p> The set of abstractions presented by DisPeL is an extension of the basic framework proposed in <ref> [Andrews, 1991] </ref>. 6 tems built using those DisPeL abstractions. DisPeL support for pipeline strategies is based on the PipelineAgent abstraction, along with the three special cases of Source, Filter, and Sink. <p> A generic abstraction ReqRespAgent is provided, to describe at a high-level all agents participating in a system organized using such strategies. To support client-server strategies, DisPeL includes the two abstractions Client and Server. As in <ref> [Andrews, 1991] </ref>, a client is a triggering agent, making requests of servers; a server is a reactive agent, responding to those requests it receives. Clients initiate activities; they do not necessarily have to wait for their requests to be fulfilled before continuing on their own execution.
Reference: [Birrell and Nelson, 1984] <author> A. D. Birrell, and B. J. Nelson, </author> <title> Implementing Remote Procedure Calls, </title> <journal> ACM Transactions on Computer Systems, 2:3959. </journal>
Reference-contexts: Section 2.1 will discuss these abstractions in more detail. At this level, we also define a set of abstractions that provide functionality equivalent to that found in other well-known communications formalisms, such as remote procedure calls <ref> [Birrell and Nelson, 1984] </ref>, and tuple-space, or generative, communications [Gelernter, 1985]. The next layer of abstractions builds on this communications infrastructure. It provides abstractions that ease the task of constructing distributed systems based on common control protocols, such as client-server, subsumption layers, or pipelines of agents. <p> These constraints introduce potential impedance mismatches between the exist 32 ing language's underlying model and the requirements placed on it by the new distributed processing abstractions. Remote procedure calls <ref> [Birrell and Nelson, 1984] </ref>, Sun Microsystems' ToolTalk [Julienne and Holtz, 1994], FIELD's communications framework [Reiss, 1990], ARPI's CPE testbed initiative, the Transis system [Amir et al,1992], PVM [Sunderam, 1990], [Geist et al, 1994], and our CoRaCLe framework, are examples of this third approach.
Reference: [Brattman, Israel, and Pollack, 1988] <author> M. E. Brattman, D. J. Israel, M. E.Pollack, </author> <title> Plans and resource-bound practical reasoning, </title> <journal> Computational Intelligence, 4:349355. </journal>
Reference: [Brooks, 1985] <author> Rodney A. Brooks, </author> <title> A Robust Layered Control System for a Mobile Robot, MIT A.I. </title> <note> Memo 864. </note>
Reference-contexts: The AI literature includes examples of systems that span the spectrum of strategies just described. There are systems which have a fixed (hierarchical) organization of agents, along with systems where the hierarchical organization interacts with the runtime behavior of the agents (Brooks's subsumption architecture <ref> [Brooks, 1985] </ref>). There are some where the set of agents and the determination of control rely on agreement among the agents involved (voting schemes). Figure 2 illustrates the architecture of Huey, one of our early attempts [Dean et al, 1990] at designing a robot architecture along hierarchical lines. <p> The DisPeL abstractions that support request-response strategies can be freely combined to provide the basis for any such agent that developers may require. The strategies described above can be used to implement the different DAI architectures in the literature. Some, like Brook's subsumption architecture <ref> [Brooks, 1985] </ref>, motivate the strategies proposed. Others are examples of those strategies, like Ferguson's TouringMachines [Ferguson, 1992] (master-slave strategy), or Brattman, Israel, and Pollack's IRMA [Brattman, Israel and Pollack, 1988] (master-slave and pipeline strategies). In partic 8 The TouringMachines system has an overall controller (the ControlFramework) running the system.
Reference: [Cardelli] <author> Luca Cardelli, </author> <title> A Language with Distributed Scope. </title>
Reference-contexts: The principal drawback to these programming languages is that they are new, typically incompatible with existing languages. This increases the initial effort required, until developers are familiar with the new language. Languages such as Linda [Gelernter, 1985], Argus [Liskov, 1988], Obliq <ref> [Cardelli] </ref>, and E [EC, 1996] are examples of this second approach. Third, we have those who attempt to incorporate this support into existing programming languages and operating systems among which we place our own efforts.
Reference: [Cheriton, 1984] <author> D. R. Cheriton, </author> <title> The V kernel: a software base for distributed systems., </title> <journal> IEEE Software, </journal> <month> April </month> <year> 1984, </year> <pages> pages 19-42. </pages>
Reference-contexts: Nonetheless, several attempts have been made to develop operating systems specifically for distributed computation: the x-kernel [Peterson et al, 1990], for example, or the V <ref> [Cheriton, 1984] </ref>, Amoeba [Tanenbaum, 1995] and Sprite [Ousterhout et al, 1988] operating systems (or see [Tanen-baum and Renesse, 1985], [Tanenbaum, 1995]).
Reference: [EC, 1996] <author> Electric Communities, </author> <title> The E Programming Language, </title> <editor> http://www.communities.com/e/index.html [Dean et al, 1990], Thomas Dean, Kenneth Basye, Robert Chekaluk, Se-ungseok Hyun, Moises Lejter, Margaret Randazza, </editor> <title> Copying with Uncertainty in a Control System for Navigation and Exploration. </title> <booktitle> Proceedings of AAAI-90, </booktitle> <year> 1990. </year>
Reference-contexts: The principal drawback to these programming languages is that they are new, typically incompatible with existing languages. This increases the initial effort required, until developers are familiar with the new language. Languages such as Linda [Gelernter, 1985], Argus [Liskov, 1988], Obliq [Cardelli], and E <ref> [EC, 1996] </ref> are examples of this second approach. Third, we have those who attempt to incorporate this support into existing programming languages and operating systems among which we place our own efforts.
Reference: [Ferguson, 1992] <author> I. A. Ferguson, </author> <title> Towards an Architecture for Adaptive, 40 Rational, Mobile Agents,: </title> <editor> E. Werner, ed., </editor> <booktitle> Decentralized AI 3 Proceedings of the Third European Workshop on Modeling Autonomous Agents and Multi-Agent Worlds, </booktitle> <volume> 249262, </volume> <publisher> Elsevier. </publisher>
Reference-contexts: The strategies described above can be used to implement the different DAI architectures in the literature. Some, like Brook's subsumption architecture [Brooks, 1985], motivate the strategies proposed. Others are examples of those strategies, like Ferguson's TouringMachines <ref> [Ferguson, 1992] </ref> (master-slave strategy), or Brattman, Israel, and Pollack's IRMA [Brattman, Israel and Pollack, 1988] (master-slave and pipeline strategies). In partic 8 The TouringMachines system has an overall controller (the ControlFramework) running the system. This controller decides which of three independent modules (Reactive, Planning, or Modeling) is to run.
Reference: [Geist et al, 1994] <author> A. Geist, A. Beguelin, J. Dongarra, R. Manchek, W. Jiang, and V. Sunderam, </author> <title> PVM: A User's Guide and Tutorial for Networked Parallel Computing Cambridge, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Remote procedure calls [Birrell and Nelson, 1984], Sun Microsystems' ToolTalk [Julienne and Holtz, 1994], FIELD's communications framework [Reiss, 1990], ARPI's CPE testbed initiative, the Transis system [Amir et al,1992], PVM [Sunderam, 1990], <ref> [Geist et al, 1994] </ref>, and our CoRaCLe framework, are examples of this third approach. In this section, we will concentrate on comparing our framework's performance against that of some of these other systems: Sun Microsys-tems' ToolTalk, FIELD's communications framework, and ARPI's CPE testbed environment.
Reference: [Gelernter, 1985] <author> D. Gelernter, </author> <title> Generative communication in Linda, </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 7: </volume> <pages> 80112. </pages>
Reference-contexts: Section 2.1 will discuss these abstractions in more detail. At this level, we also define a set of abstractions that provide functionality equivalent to that found in other well-known communications formalisms, such as remote procedure calls [Birrell and Nelson, 1984], and tuple-space, or generative, communications <ref> [Gelernter, 1985] </ref>. The next layer of abstractions builds on this communications infrastructure. It provides abstractions that ease the task of constructing distributed systems based on common control protocols, such as client-server, subsumption layers, or pipelines of agents. <p> The principal drawback to these programming languages is that they are new, typically incompatible with existing languages. This increases the initial effort required, until developers are familiar with the new language. Languages such as Linda <ref> [Gelernter, 1985] </ref>, Argus [Liskov, 1988], Obliq [Cardelli], and E [EC, 1996] are examples of this second approach. Third, we have those who attempt to incorporate this support into existing programming languages and operating systems among which we place our own efforts.
Reference: [Hayes-Roth, 1985] <author> Barbara Hayes-Roth, </author> <title> A Blackboard Architecture for Control, </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 26, </volume> <year> 1985, </year> <pages> pages 251-321. </pages>
Reference-contexts: Any design decisions related to that internal structure are taken by those who provide the protocol; they are fixed, or at best rigidly constrained, from the 3 This approach was introduced as a programming-language paradigm by Linda [Gel-ernter, 1985]; it was also introduced as an architecture for AI systems by <ref> [Hayes-Roth, 1985] </ref>. 3 perspective of the multi-agent systems using them. CoRaCLe was designed with this kind of design flexibility in mind. CoRaCLe describes generic abstractions that any message-passing protocol can be implemented on; the relationships between these abstractions are illustrated in Figure 1.
Reference: [Jennings, 1996] <author> N. R. Jennings. </author> <booktitle> Coordination Techniques for Distributed Artificial Intelligence, in Foundations of Distributed Artificial Intelligence (eds. </booktitle> <editor> G. M. P. O'Hare and N. R. Jennings), </editor> <publisher> Wiley, </publisher> <year> 1996, </year> <pages> pages 187-210. </pages>
Reference-contexts: The approach taken in CAF addresses this issue by incrementally updating the game tree and letting all agents criticize it as it expands. An updated presentation of Lesser's formalism, along with an alternative approach to address this issue, is presented by <ref> [Jennings, 1996] </ref>.
Reference: [Julienne and Holtz, 1994] <author> Astrid M. Julienne and Brian Holtz, </author> <title> ToolTalk and Open Protocols: Inter-Application Communication, </title> <publisher> Sunsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: All agents who use that framework to communicate with each other in fact communicate only with that central clearinghouse; the clearinghouse then delivers all messages to their appropriate destinations. The FIELD environment [Reiss, 1990], Sun Mi-crosystems' ToolTalk <ref> [Julienne and Holtz, 1994] </ref>, and the Central realization of CoRaCLe are all examples of this kind of a framework. <p> These constraints introduce potential impedance mismatches between the exist 32 ing language's underlying model and the requirements placed on it by the new distributed processing abstractions. Remote procedure calls [Birrell and Nelson, 1984], Sun Microsystems' ToolTalk <ref> [Julienne and Holtz, 1994] </ref>, FIELD's communications framework [Reiss, 1990], ARPI's CPE testbed initiative, the Transis system [Amir et al,1992], PVM [Sunderam, 1990], [Geist et al, 1994], and our CoRaCLe framework, are examples of this third approach.
Reference: [Lejter, 1996] <author> Moises Lejter, </author> <title> A Framework for the Development of Multi-Agent Architectures. </title> <institution> Brown University Department of Computer Science, </institution> <type> Ph.D. Thesis, </type> <year> 1996 </year> <month> (forthcoming). </month>
Reference-contexts: In this paper, we will concentrate on the council architecture we describe. 11 Table 4 only includes averages, to preserve space. Complete results can be found in <ref> [Lejter, 1996] </ref> 26 number of peers per councillor. In the council tests, the configuration of the system can be described as a collection of fully-connected subnets hooked together. <p> around this limitation, the test agent used for the experiments discussed below was modified to match: each agent still chooses at random whether to send or receive a 15 We will only present results for ToolTalk and FIELD's framework, since we do not yet have access to the CPE testbed. <ref> [Lejter, 1996] </ref> provides comparisons with these and other systems. 36 message; outgoing messages are still sent to a target selected randomly for each message, but incoming messages are accepted regardless of source.
Reference: [Lesser, 1991] <author> Victor R. </author> <title> Lesser A retrospective view of FA/C Distributed Problem Solving IEEE Transactions on Man, </title> <journal> Machine, and Cybernetics, </journal> <volume> Vol. 21, </volume> <pages> pages 1347-1363. </pages>
Reference-contexts: Essentially, agents interested in coordinating their behaviors construct a game-tree in which they each describe their choices on every step of the evolving plan represented by the game tree, until a mutually satisfiable solution is found. The approach taken here in broad terms is similar to that described in <ref> [Lesser, 1991] </ref> we build a graph of the options available to the set of agents to coordinate, then choose the most appropriate action. The details on how the graph is constructed and then later evaluated differ from those Lesser describes.
Reference: [Liskov, 1988] <author> Barbara Liskov, </author> <title> Distributed Programming in Argus, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 31, Num. 3, </volume> <month> March </month> <year> 1988, </year> <pages> pages 300-312. 41 </pages>
Reference-contexts: The principal drawback to these programming languages is that they are new, typically incompatible with existing languages. This increases the initial effort required, until developers are familiar with the new language. Languages such as Linda [Gelernter, 1985], Argus <ref> [Liskov, 1988] </ref>, Obliq [Cardelli], and E [EC, 1996] are examples of this second approach. Third, we have those who attempt to incorporate this support into existing programming languages and operating systems among which we place our own efforts.
Reference: [Ousterhout et al, 1988] <author> John K. Ousterhout, Andrew R. Cherenson, Freder--ick Douglis, Michael N. Nelson, and Brent W. Welch, </author> <title> The Sprite Network Operating System, </title> <booktitle> IEEE Computer, </booktitle> <month> February </month> <year> 1988, </year> <pages> pages 23-36. </pages>
Reference-contexts: Nonetheless, several attempts have been made to develop operating systems specifically for distributed computation: the x-kernel [Peterson et al, 1990], for example, or the V [Cheriton, 1984], Amoeba [Tanenbaum, 1995] and Sprite <ref> [Ousterhout et al, 1988] </ref> operating systems (or see [Tanen-baum and Renesse, 1985], [Tanenbaum, 1995]). Second, we have those who believe that this support should be incorporated at the programming language level, providing the best set of abstractions for distributed processing within the language to be used for developing these applications.
Reference: [Peterson et al, 1990] <author> Larry Peterson, Norman Hutchinson, Sean O'Malley, and Herman Rao, </author> <title> The x-kernel: A Platform for Accessing Internet Resources, </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1990, </year> <pages> pages 23-32. </pages>
Reference-contexts: The disadvantages have to do with portability and compatibility with existing operating systems, programming languages, and hardware: all these become a load for the designers of that new operating system. Nonetheless, several attempts have been made to develop operating systems specifically for distributed computation: the x-kernel <ref> [Peterson et al, 1990] </ref>, for example, or the V [Cheriton, 1984], Amoeba [Tanenbaum, 1995] and Sprite [Ousterhout et al, 1988] operating systems (or see [Tanen-baum and Renesse, 1985], [Tanenbaum, 1995]).
Reference: [Reiss, 1990] <author> Steven P. Reiss, </author> <title> Connecting Tools using Message Passing in the FIELD Program Development Environment, </title> <journal> IEEE Software, </journal> <month> July, </month> <year> 1990. </year>
Reference-contexts: All agents who use that framework to communicate with each other in fact communicate only with that central clearinghouse; the clearinghouse then delivers all messages to their appropriate destinations. The FIELD environment <ref> [Reiss, 1990] </ref>, Sun Mi-crosystems' ToolTalk [Julienne and Holtz, 1994], and the Central realization of CoRaCLe are all examples of this kind of a framework. <p> These constraints introduce potential impedance mismatches between the exist 32 ing language's underlying model and the requirements placed on it by the new distributed processing abstractions. Remote procedure calls [Birrell and Nelson, 1984], Sun Microsystems' ToolTalk [Julienne and Holtz, 1994], FIELD's communications framework <ref> [Reiss, 1990] </ref>, ARPI's CPE testbed initiative, the Transis system [Amir et al,1992], PVM [Sunderam, 1990], [Geist et al, 1994], and our CoRaCLe framework, are examples of this third approach.
Reference: [Sen, 1996] <author> Sandip Sen, </author> <title> An automated distributed meeting scheduler, </title> <note> accepted for publication in IEEE Expert. </note>
Reference-contexts: The highest bidder always wins each subtask and becomes responsible for achieving it. Smith's Contract Nets [Smith, 1980] originally introduced the bidding protocol strategy. A recent example of a system built using contract nets is Sen's distributed meeting scheduler <ref> [Sen, 1996] </ref>. The support CAF provides for contract net protocols revolves around the abstractions Bidder, Client, and Contract. Each agent that wishes to submit a task to bidding must be an instance of a Client.
Reference: [Smith, 1980] <author> Reid G. </author> <title> SmithThe Contract Net Protocol: High-Level Communications and Control in a Distributed Problem Solver, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C29, No. 12, </volume> <month> December </month> <year> 1980. </year>
Reference-contexts: These protocols can be characterized by their more dynamic nature: the details of the responsibilities and interactions among agents may not be known until run-time. A simple example of a coordination protocol could be the contract net <ref> [Smith, 1980] </ref>, where the actual responsibilities of the individual agents depend on circumstance. Section 2.3 will discuss these abstractions in more detail. 2 We also provide an empirical evaluation of the utility of our framework for constructing distributed systems. <p> Agents able to fulfill those tasks will bid for them, based on their own expectations of how well that agent can fulfill the tasks. The highest bidder always wins each subtask and becomes responsible for achieving it. Smith's Contract Nets <ref> [Smith, 1980] </ref> originally introduced the bidding protocol strategy. A recent example of a system built using contract nets is Sen's distributed meeting scheduler [Sen, 1996]. The support CAF provides for contract net protocols revolves around the abstractions Bidder, Client, and Contract.
Reference: [Sunderam, 1990] <author> V. S. Sunderam, </author> <title> PVM, A Framework for Parallel Distributed Computing, </title> <journal> Practice and Experience, </journal> <volume> Vol. 2, Num. 4, </volume> <month> December </month> <year> 1990, </year> <pages> pages 315-339. </pages>
Reference-contexts: Remote procedure calls [Birrell and Nelson, 1984], Sun Microsystems' ToolTalk [Julienne and Holtz, 1994], FIELD's communications framework [Reiss, 1990], ARPI's CPE testbed initiative, the Transis system [Amir et al,1992], PVM <ref> [Sunderam, 1990] </ref>, [Geist et al, 1994], and our CoRaCLe framework, are examples of this third approach. In this section, we will concentrate on comparing our framework's performance against that of some of these other systems: Sun Microsys-tems' ToolTalk, FIELD's communications framework, and ARPI's CPE testbed environment.
Reference: [Tanenbaum and Renesse, 1985] <author> Andrew S. Tanenbaum and Robbert van Renesse, </author> <title> Distributed Operating Systems, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 17, </volume> <editor> N. </editor> <volume> 4, </volume> <month> December </month> <year> 1985, </year> <pages> pages 419-470. </pages> <note> [Tanenbaum, 1995], </note> <author> Andrew S. Tanenbaum, </author> <title> Distributed Operating Systems Prentice Hall, </title> <address> New Jersey, </address> <year> 1995. </year>
Reference: [Urken, 1990] <author> Arnold B. Urken, </author> <title> Coordinating Distributed Action via Agent Voting ACM, </title> <address> OIS90, </address> <year> 1990. </year>
Reference-contexts: All three modules FeatureRecognizer, CorridorFollower, and ObstacleAv-oidance share access to the Sonar and Motor controllers that are in charge of the robot's sensors and motion. 10 ing proposals, then choosing the most popular alternative. For example, Urken <ref> [Urken, 1990] </ref> describes the application of a voting scheme to distributed network routing on a phone network.

References-found: 25

