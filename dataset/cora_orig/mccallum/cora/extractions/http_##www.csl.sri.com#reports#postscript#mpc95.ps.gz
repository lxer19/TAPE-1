URL: http://www.csl.sri.com/reports/postscript/mpc95.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Author: Natarajan Shankar 
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Note: Computer-Aided Computing Invited talk to be presented at MPC '95: Third international conference on the Mathematics of Program Construction, Kloster Irsee, Germany,  
Email: shankar@csl.sri.com  
Phone: Phone: +1 (415) 859-5272 Fax: +1 (415) 859-2844  
Date: July 1995  
Web: URL: http://www.csl.sri.com/shankar.html  
Abstract: Formal program design methods are most useful when supported with suitable mechanization. This need for mechanization has long been apparent, but there have been doubts whether verification technology could cope with the problems of scale and complexity. Though there is very little compelling evidence either way at this point, several powerful mechanical verification systems are now available for experimentation. Using SRI's PVS as one representative example, we argue that the technology of mechanical verification is already quite effective. PVS derives its power from an integration of theorem proving with type-checking, decision procedures with interactive proof construction, and more recently, model checking with theorem proving. We discuss these individual aspects of PVS using examples, and motivate some of the challenges that lie ahead.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> William R. Bevier, Warren A. Hunt, Jr., J Strother Moore, and William D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 411-428, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Informal mathematics also often mixes mathematical and metamathematical argumentation, and this too is not easily mechanized. The case for mechanized verification is very strong. We now know that it is feasible to verify large systems. Bevier, Hunt, Moore, and Young <ref> [1] </ref> present a proof of a system consisting of a microprocessor, an assembler for this microprocessor, a compiler for a Pascal-like language with the assembler as its target language, and an operating system kernel. This verification used the Boyer-Moore theorem prover [2].
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: Bevier, Hunt, Moore, and Young [1] present a proof of a system consisting of a microprocessor, an assembler for this microprocessor, a compiler for a Pascal-like language with the assembler as its target language, and an operating system kernel. This verification used the Boyer-Moore theorem prover <ref> [2] </ref>. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS [14], HOL [17], Isabelle [25], LP [15], Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 3. <author> J. R. Burch, E. M. Clarke, K. L McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Model checking with theorem proving. Many forms of finite-state verification, such as linear temporal logic model checking, language containment, and bisimulation checking, can be expressed in the mu-calculus <ref> [3, 13] </ref>. The higher-order logic of PVS is used to define the least and greatest fixpoint operators of the mu-calculus. When the state type is finite, the mu-calculus expressions are translated into the propositional mu-calculus and a propositional mu-calculus model checker can be used as a decision procedure.
Reference: 4. <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: We do not discuss the details of this encoding here (see [27]). An efficient model checking algorithm for the propositional mu-calculus was presented by Emerson and Lei [13], and the symbolic variant employing BDDs was presented by Burch, et al <ref> [4] </ref>. The above embedding of the mu-calculus and CTL owes much to these seminal papers. Compositionality. We now digress from our main point to describe a technique for compositional verification of concurrent systems [28].
Reference: 5. <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: With this integration, PVS includes a useful model checker that is complemented with the theorem proving capabilities of PVS. In particular, PVS can be used to define property-preserving abstractions from an unbounded-state system to a finite-state one <ref> [5, 11] </ref>. The induction and rewriting capabilities of PVS can also be used in conjunction with model checking. We have in fact verified two illustrative examples with a combination of theorem proving and model checking: a processor-memory combination and an N-process mutual exclusion algorithm [27]. <p> If we have ensured that the abstraction preserves the correctness property, then the correctness of the N-process algorithm follows. Such abstractions have been studied by Clarke, Grumberg, and Long <ref> [5] </ref>, and by Dams, Grumberg, and Gerth [11]. 14 The above example is of course purely illustrative since the algorithm is a somewhat naive and contrived one.
Reference: 6. <author> R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS [14], HOL [17], Isabelle [25], LP [15], Nuprl <ref> [6] </ref>, and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 7. <author> T. Coquand and G. P. Huet. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In Proceedings of EUROCAL 85, </booktitle> <address> Linz (Austria), Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq <ref> [7] </ref>, EVES [8], IMPS [14], HOL [17], Isabelle [25], LP [15], Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 8. <author> Dan Craigen, Sentot Kromodimoeljo, Irwin Meisels, Bill Pase, and Mark Saaltink. </author> <title> EVES: An overview. </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91: Formal Software Development Methods, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 389-405, </pages> <address> Noordwijkerhout, The Netherlands, </address> <month> October </month> <year> 1991. </year> <journal> Springer-Verlag. </journal> <volume> Volume 1: </volume> <booktitle> Conference Contributions. </booktitle>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES <ref> [8] </ref>, IMPS [14], HOL [17], Isabelle [25], LP [15], Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 9. <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <editor> In Ramayya Kumar and Thomas Kropf, editors, </editor> <booktitle> Preliminary Proceedings of the Second Conference on Theorem Provers in Circuit Design, </booktitle> <pages> pages 287-305, </pages> <address> Bad Herrenalb (Blackforest), Germany, </address> <month> September </month> <year> 1994. </year> <institution> Forschungszen-trum Informatik an der Universitat Karlsruhe, </institution> <note> FZI Publication 4/94. </note>
Reference-contexts: The PVS proof checker strives to strike a careful balance between an automatic theorem prover and a low-level proof checker. Through the use of BDD-based simplification, simple PVS proof strategies can be defined for efficiently and automatically verifying simple processor designs and N-bit arithmetic circuits <ref> [9] </ref>. Model checking with theorem proving. Many forms of finite-state verification, such as linear temporal logic model checking, language containment, and bisimulation checking, can be expressed in the mu-calculus [3, 13]. The higher-order logic of PVS is used to define the least and greatest fixpoint operators of the mu-calculus.
Reference: 10. <author> David Cyrluk, Patrick Lincoln, Paliath Narendran, Sam Owre, Sreeranga Ragan, John Rushby, Natarajan Shankar, Jens Ulrik Skakkebk, Mandayam Srivas, and Friedrich von Henke. </author> <title> Seven papers on mechanized formal verification. </title> <type> Technical Report SRI-CSL-95-3, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: A variety of examples have been verified using PVS. It has been used to verify fault-tolerant agreement protocols under Byzantine and hybrid fault models, and real-time protocols such as Fischer's mutual exclusion algorithm and a generalized railroad crossing <ref> [10, 18] </ref>. The most substantial use of PVS has been in the verification of the microcode for selected instructions of a commercial-scale microprocessor called AAMP5 designed by Rockwell-Collins and containing about 500,000 transistors [21].
Reference: 11. <author> Dennis Dams, Orna Grumberg, and Rob Gerth. </author> <title> Abstract interpretation of reactive systems: Abstractions preserving 8CTL*, </title> <editor> 9CTL* and CTL*. In Ernst-Rudiger Olderog, editor, </editor> <booktitle> Programming Concepts, Methods and Calculi (PROCOMET '94), </booktitle> <pages> pages 561-581, </pages> <year> 1994. </year>
Reference-contexts: With this integration, PVS includes a useful model checker that is complemented with the theorem proving capabilities of PVS. In particular, PVS can be used to define property-preserving abstractions from an unbounded-state system to a finite-state one <ref> [5, 11] </ref>. The induction and rewriting capabilities of PVS can also be used in conjunction with model checking. We have in fact verified two illustrative examples with a combination of theorem proving and model checking: a processor-memory combination and an N-process mutual exclusion algorithm [27]. <p> If we have ensured that the abstraction preserves the correctness property, then the correctness of the N-process algorithm follows. Such abstractions have been studied by Clarke, Grumberg, and Long [5], and by Dams, Grumberg, and Gerth <ref> [11] </ref>. 14 The above example is of course purely illustrative since the algorithm is a somewhat naive and contrived one.
Reference: 12. <author> Richard A. De Millo, Richard J. Lipton, and Alan J. Perlis. </author> <title> Social processes and proofs of theorems and programs. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 271-280, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: There are several examples of published proofs of important results where the errors have gone unnoticed until they were revealed by mechanical verification. Mechanical verification is not a substitute for the social process <ref> [12] </ref> but is merely a tool that aids the social process. There is nothing inherently inhuman about mechanized verification. A mechanical verifier plays the role of an implacable skeptic that highlights weaknesses in an argument such as misapplied lemmas, missing cases, and inappropriate inductions or instantiations.
Reference: 13. <author> E.A. Emerson and C.L Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus. </title> <booktitle> In Proceedings of the 10th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <address> New Orleans, LA, </address> <month> January </month> <year> 1985. </year> <institution> Association for Computing Machinery. </institution> <month> 16 </month>
Reference-contexts: Model checking with theorem proving. Many forms of finite-state verification, such as linear temporal logic model checking, language containment, and bisimulation checking, can be expressed in the mu-calculus <ref> [3, 13] </ref>. The higher-order logic of PVS is used to define the least and greatest fixpoint operators of the mu-calculus. When the state type is finite, the mu-calculus expressions are translated into the propositional mu-calculus and a propositional mu-calculus model checker can be used as a decision procedure. <p> We do not discuss the details of this encoding here (see [27]). An efficient model checking algorithm for the propositional mu-calculus was presented by Emerson and Lei <ref> [13] </ref>, and the symbolic variant employing BDDs was presented by Burch, et al [4]. The above embedding of the mu-calculus and CTL owes much to these seminal papers. Compositionality. We now digress from our main point to describe a technique for compositional verification of concurrent systems [28].
Reference: 14. <author> William M. Farmer, Joshua D. Guttman, and F. Javier Thayer. IMPS: </author> <title> An interac-tive mathematical proof system. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11(2) </volume> <pages> 213-248, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS <ref> [14] </ref>, HOL [17], Isabelle [25], LP [15], Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 15. <author> Stephen J. Garland and John V. Guttag. </author> <title> LP: The Larch prover. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> 9th International Conference on Automated Deduction (CADE), volume 310 of Lecture Notes in Computer Science, </booktitle> <pages> pages 748-749, </pages> <address> Ar-gonne, IL, May 1988. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS [14], HOL [17], Isabelle [25], LP <ref> [15] </ref>, Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 16. <author> M. Gordon, R. Milner, and C. Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: The development of PVS was funded by SRI International. 2 PVS also uses BDD-based propositional simplification so that it can com-bine the capability of simplifying very large propositional expressions with equality, arithmetic, induction, and rewriting. Higher-level inference steps can be defined by means of strategies (akin to LCF tactics <ref> [16] </ref>) written in a simple strategy language. Typical strategies include heuristic instantiation of quantifiers, propositional and arithmetic simplification, and induction and rewriting. The PVS proof checker strives to strike a careful balance between an automatic theorem prover and a low-level proof checker. <p> Strategies. The PVS proof checker provides powerful primitive inference steps that make heavy use of decision procedures, but proof construction solely in terms of even these inference steps can be quite tedious. PVS therefore provides a language for defining high-level inference strategies (which are similar to tactics in LCF <ref> [16, 24] </ref>). This language includes recursion, a let binding construct, a backtracking try strategy construction, and a conditional if strategy construction.
Reference: 17. <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic. </title> <publisher> Cambridge University Press, </publisher> <address> Cam-bridge, UK, </address> <year> 1993. </year>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS [14], HOL <ref> [17] </ref>, Isabelle [25], LP [15], Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 18. <author> Constance Heitmeyer and Nancy Lynch. </author> <title> The generalized railroad crossing: A case study in formal verification of real-time systems. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 120-131, </pages> <address> San Juan, Puerto Rico, </address> <month> December </month> <year> 1994. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: A variety of examples have been verified using PVS. It has been used to verify fault-tolerant agreement protocols under Byzantine and hybrid fault models, and real-time protocols such as Fischer's mutual exclusion algorithm and a generalized railroad crossing <ref> [10, 18] </ref>. The most substantial use of PVS has been in the verification of the microcode for selected instructions of a commercial-scale microprocessor called AAMP5 designed by Rockwell-Collins and containing about 500,000 transistors [21].
Reference: 19. <author> D. Kapur and H. Zhang. RRL: </author> <title> A User's Manual. General Electric Corporate Research and Development, </title> <address> Schenectady, NY, </address> <month> March </month> <year> 1986. </year> <type> Unpublished Manuscript. </type>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS [14], HOL [17], Isabelle [25], LP [15], Nuprl [6], and RRL <ref> [19] </ref>, to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 20. <author> D. Kozen. </author> <title> Results on the propositional mu-calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 333-354, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: The propositional mu-calculus is a restriction of the general mu-calculus where the state type is an n-tuple of booleans. The propositional mu-calculus thus extends quantified boolean formulas (i.e., propositional logic with boolean quantification) to include the application of n-ary relational terms to n argument formulas <ref> [20] </ref>. The relational terms can constructed by means of lambda-abstraction, or by taking the least fixpoint Q:F [Q] where Q is an nary predicate variable and F is a monotone predicate transformer. The greatest fixpoint operation can be written as -Q:F [Q] and defined as :Q::F [:Q].
Reference: 21. <author> Steven P. Miller and Mandayam Srivas. </author> <title> Formal verification of the AAMP5 microprocessor: A case study in the industrial use of formal methods. </title> <booktitle> In WIFT '95: Workshop on Industrial-Strength Formal specification Techniques, </booktitle> <address> Boca Raton, FL, </address> <year> 1995. </year> <journal> IEEE Computer Society. </journal> <note> To appear. </note>
Reference-contexts: The most substantial use of PVS has been in the verification of the microcode for selected instructions of a commercial-scale microprocessor called AAMP5 designed by Rockwell-Collins and containing about 500,000 transistors <ref> [21] </ref>. We now discuss each of the above facets of PVS in greater detail. 3 Combining Theorem Proving and Typechecking The PVS specification language is based on classical, simply typed higher-order logic, but the type system has been augmented with subtypes and dependent types. 3 Subtypes and Proof Obligations.
Reference: 22. <author> Paul S. Miner. </author> <title> Defining the IEEE-854 floating-point standard in PVS. </title> <type> Technical Memorandum 110167, </type> <institution> NASA Langley Research Center, </institution> <year> 1995. </year>
Reference-contexts: By exploiting these features, researchers at NASA Langley Research Center and SRI have developed a very general bit-vector library. Paul Miner at NASA has developed a specification of portions of the IEEE 854 floating-point standard in PVS <ref> [22] </ref>. Powerful decision procedures with user interaction. PVS proofs are constructed interactively. The primitive inference steps for constructing proofs are quite powerful. They make extensive use of efficient decision procedures for equality and linear arithmetic.
Reference: 23. <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <title> Three volumes: Language, System, and Prover Reference Manuals. </title>
Reference-contexts: We focus here on one such verification system, PVS, merely out of familiarity <ref> [23] </ref>. 2 We describe the key facets of the design of PVS and illustrate their role in effective verification by means of examples. Our main observation is that general-purpose tools like PVS must be integrated with domain-specific tools, notations, methodologies in order to achieve truly effective mechanization.
Reference: 24. <author> L. C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, </address> <year> 1987. </year>
Reference-contexts: Strategies. The PVS proof checker provides powerful primitive inference steps that make heavy use of decision procedures, but proof construction solely in terms of even these inference steps can be quite tedious. PVS therefore provides a language for defining high-level inference strategies (which are similar to tactics in LCF <ref> [16, 24] </ref>). This language includes recursion, a let binding construct, a backtracking try strategy construction, and a conditional if strategy construction.
Reference: 25. <author> Lawrence C. Paulson. </author> <title> Isabelle: A generic Theorem Prover, </title> <booktitle> volume 828 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This verification used the Boyer-Moore theorem prover [2]. There are many other impressive verification examples carried out on a variety of systems including Coq [7], EVES [8], IMPS [14], HOL [17], Isabelle <ref> [25] </ref>, LP [15], Nuprl [6], and RRL [19], to name a few. The main challenge is to make mechanical verification less arduous and more perspicuous.
Reference: 26. <author> G. L. Peterson. </author> <title> Myths about the mutual exclusion problem. </title> <journal> Information Processing Letters, </journal> <volume> 12(3) </volume> <pages> 115-116, </pages> <year> 1981. </year>
Reference-contexts: If a property is simply a subset of traces, then any property of P 1 or P 2 is also a property of P 1 kP 2 . Two Process Mutual Exclusion. Peterson's mutual exclusion algorithm <ref> [26] </ref> is a easy exercise for a model checker, and is somewhat less easily verified by means of theorem proving. We merely sketch the details of the PVS verification of this algorithm.
Reference: 27. <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <editor> In Pierre Wolper, editor, </editor> <booktitle> Computer-Aided Verification, CAV '95, Lecture Notes in Computer Science, Liege, </booktitle> <address> Belgium, </address> <month> June </month> <year> 1995. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: The induction and rewriting capabilities of PVS can also be used in conjunction with model checking. We have in fact verified two illustrative examples with a combination of theorem proving and model checking: a processor-memory combination and an N-process mutual exclusion algorithm <ref> [27] </ref>. A variety of examples have been verified using PVS. It has been used to verify fault-tolerant agreement protocols under Byzantine and hybrid fault models, and real-time protocols such as Fischer's mutual exclusion algorithm and a generalized railroad crossing [10, 18]. <p> For control-intensive approaches over small finite states, model checking is very effective since a more traditional Hoare logic style proof involves discovering a sufficiently strong invariant. These two approaches have traditionally been seen as incompatible ways of viewing the verification problem. In recent work <ref> [27] </ref>, we were able to unify the two views and incorporate a model checker as decision procedure for a well-defined fragment of PVS. 10 This integration uses the mu-calculus as a medium for communicating be-tween PVS and a model checker for the propositional mu-calculus. <p> We do not discuss the details of this encoding here (see <ref> [27] </ref>). An efficient model checking algorithm for the propositional mu-calculus was presented by Emerson and Lei [13], and the symbolic variant employing BDDs was presented by Burch, et al [4]. The above embedding of the mu-calculus and CTL owes much to these seminal papers. Compositionality.
Reference: 28. <author> N. Shankar. </author> <title> A lazy approach to compositional verification. </title> <type> Technical Report SRI-CSL-93-8, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The above embedding of the mu-calculus and CTL owes much to these seminal papers. Compositionality. We now digress from our main point to describe a technique for compositional verification of concurrent systems <ref> [28] </ref>. We say that the parallel 12 composition P 1 kP 2 of two specifications P 1 and P 2 is compositional if every local property, that is, a property of one of the P i , is also a global property of the composition P 1 kP 2 .
Reference: 29. <author> R. E. Shostak, R. Schwartz, and P. M. Melliar-Smith. STP: </author> <title> A mechanized logic for specification and verification. </title> <editor> In D. Loveland, editor, </editor> <booktitle> 6th International Conference on Automated Deduction (CADE), volume 138 of Lecture Notes in Computer Science, </booktitle> <address> New York, NY, 1982. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The simplifications wrought by the decision procedures are not always immediately comprehensible but they are typically ones that would be quite tedious to carry out manually. The basic PVS decision procedures were originally developed by Shostak in the context of the STP theorem prover <ref> [29, 30] </ref>. These decision procedures use the congruence closure algorithm for equality reasoning to combine decision procedures for various theories such as linear arithmetic, arrays, and tuples, in the presence of function symbols that are uninterpreted by any of the function symbols.
Reference: 30. <author> Robert E. Shostak. </author> <title> Deciding combinations of theories. </title> <journal> Journal of the ACM, </journal> <volume> 31(1) </volume> <pages> 1-12, </pages> <month> January </month> <year> 1984. </year> <month> 17 </month>
Reference-contexts: The simplifications wrought by the decision procedures are not always immediately comprehensible but they are typically ones that would be quite tedious to carry out manually. The basic PVS decision procedures were originally developed by Shostak in the context of the STP theorem prover <ref> [29, 30] </ref>. These decision procedures use the congruence closure algorithm for equality reasoning to combine decision procedures for various theories such as linear arithmetic, arrays, and tuples, in the presence of function symbols that are uninterpreted by any of the function symbols.
References-found: 30

