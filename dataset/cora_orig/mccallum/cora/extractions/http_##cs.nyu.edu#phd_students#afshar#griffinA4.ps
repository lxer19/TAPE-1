URL: http://cs.nyu.edu/phd_students/afshar/griffinA4.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/afshar/index.html
Root-URL: http://www.cs.nyu.edu
Email: afshar@cs.nyu.edu harrison@cs.nyu.edu  
Title: Expressing Concurrency in Griffin  
Author: Niki Afshartous Malcolm C. Harrison 
Address: New York University 251 Mercer Street, New York, NY 10012 USA  
Affiliation: Courant Institute of Mathematical Sciences  
Abstract: Griffin is a statically typed language designed specifically for the rapid prototyping of Ada software. In this paper we describe the Griffin language constructs for expressing concurrency. There are two salient innovations: 1) an extended select statement that provides greater flexability in managing non-deterministic behavior and 2) the capability of a receiving thread to concurrently rendezvous with multiple sending threads. Thus by increasing concurrency, we alleviate the chief drawback to synchronous communication. We then apply the Griffin constructs in implementing solutions to the readers-writers problem, group lock mechanism, and scheduling groups of concurrent operations. The Griffin constructs facilitate the expression of high-level algorithms that maximize concurrency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert Balzer, Frank Belz, Robert Dewar, David Fisher, John Guttag, Paul Hudak, and Mitchel Wand. </author> <title> Draft Report on Requirements for a Common Prototyping System, </title> <year> 1988. </year>
Reference: [2] <author> W. Carlson. </author> <title> Software Prototyping, System Architecture, and the System Life Cycle. </title> <note> Preliminary ProtoTech Phase 2 Report, </note> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: This restriction has been addressed in the design of Ada95 [10], by adding another concept, that of "protected" types. Griffin ([8], [11]) is a statically typed language designed specifically for the rapid prototyping ([1], <ref> [2] </ref>) of Ada software. The Griffin constructs we describe in this paper address the above issues in a different way, which provides greater flexibility without inhibiting concurrency. Concurrency in Griffin is provided by two types: threads and channels. Threads provide concurrent execution, while channels provide communication and synchronization between threads.
Reference: [3] <author> Department of Defense. </author> <title> Reference Manual for the Ada Programming Language, </title> <month> Jan. </month> <year> 1983. </year>
Reference-contexts: Monitors [9], while less error-prone than semaphores are restrictive in that only a single thread of control can be active inside a monitor at once. The Ada rendezvous <ref> [3] </ref> allows two tasks to synchronously communicate. This model is also restrictive. Consider a server task that supports a read operation. Since mutual exclusion is not required for read, multiple read requests could be serviced concurrently.
Reference: [4] <author> Isaac A. Dimitrovsky. </author> <title> The Group Lock and its Applications. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 11 </volume> <pages> 291-302, </pages> <year> 1991. </year>
Reference-contexts: [int]int; proc scheduler (init: int) =&gt; x:= init; loop recv fetchChannel ?inc =&gt; (x := x+inc; x-inc); can be obtained either by building in such a type (ensuring atomicity), or by arranging the virtual timing so that the overhead in the implementation is zero. 4.3 Group lock The group lock <ref> [4] </ref> is a mechanism that allows greater concurrency by relaxing the requirement of mutual exclusion in the critical section. In [4] it is used to design parallel operations for stacks, queues, 2-3 trees, and fetch-and-phi routines. <p> either by building in such a type (ensuring atomicity), or by arranging the virtual timing so that the overhead in the implementation is zero. 4.3 Group lock The group lock <ref> [4] </ref> is a mechanism that allows greater concurrency by relaxing the requirement of mutual exclusion in the critical section. In [4] it is used to design parallel operations for stacks, queues, 2-3 trees, and fetch-and-phi routines. In this subsection we describe the semantic properties of the group lock and then illustrate an implementation in Griffin. A simple analogy described in [4] best illustrates the idea behind the group lock. <p> In <ref> [4] </ref> it is used to design parallel operations for stacks, queues, 2-3 trees, and fetch-and-phi routines. In this subsection we describe the semantic properties of the group lock and then illustrate an implementation in Griffin. A simple analogy described in [4] best illustrates the idea behind the group lock. Consider a ferry transporting passengers across a river. The ferry may be regarded as a parallel resource since it is simultaneously accessed by all passengers on board.
Reference: [5] <author> K.P. Eswaran, J.N. Gray, R.A. Lorie, </author> <title> and I.L. Traiger. The notions of consistency and predicate locks in a database system. </title> <journal> CACM, </journal> 19(11) 624-633, Nov 1976. 
Reference-contexts: While the rendezvous are in progress, if additional senders perform sends on channel ch, they will block until another recv is performed on channel ch. The semantics of multiple provide an opportunity for parallelism that an implementation of the language may take advantage of. Serializability <ref> [5] </ref> is not guaranteed and consequently the programmer is responsible for synchronizing conflicting operations on shared variables. 3.2 Channel declarations For an asynchronous channel, only a single datatype is specified: the type of the argument inserted into the channel by the send.
Reference: [6] <author> Narain H. Gehani and William D. Roome. </author> <title> Rendezvous Facilities: Concurrent C and the Ada Language. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(11), </volume> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: select multiple recv ch1 as ?x =&gt; compute service1 (x); then text io.put ("channel 1 active"); or multiple recv ch2 as ?x =&gt; compute service2 (x); Synchronous channel operation select operator send recv multiple recv and no yes yes channels. within the same select statement. 3.4 Related work Concurrent C <ref> [6] </ref> has a select statement that provides conditional acceptance and out of FIFO order processing. A message may be accepted conditionally based on evaluating a boolean expression that contains parameters from the actual message.
Reference: [7] <author> Allan Gottlieb, Boris D. Lubachevsky, and Lawrence Rudolph. </author> <title> Basic techniques for the efficient coordination of very large numbers of cooperating sequential processes. </title> <journal> In ACM TOPLAS, </journal> <volume> volume 5, </volume> <pages> pages 164-189. </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: These include concurrent read operations when a cache is used, or operations such as fetch-and-add <ref> [7] </ref> that are combined in a network.
Reference: [8] <author> M. Harrison. </author> <title> The Griffin prototyping language. </title> <booktitle> Proc. DARPA PI Meeting, </booktitle> <address> Feb. 1991. Providence, RI. </address>
Reference: [9] <author> C. A. R. Hoare. </author> <title> Monitors: an operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17 </volume> <pages> 549-557, </pages> <year> 1974. </year>
Reference-contexts: By choosing to view this document, you agree to all provisions of the copyright laws protecting it. z Assisted by a Sokol Travel/Research Award. to programmer error. Monitors <ref> [9] </ref>, while less error-prone than semaphores are restrictive in that only a single thread of control can be active inside a monitor at once. The Ada rendezvous [3] allows two tasks to synchronously communicate. This model is also restrictive. Consider a server task that supports a read operation.
Reference: [10] <author> Intermetrics, Inc. </author> <title> Ada 95 Rationale, </title> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Since mutual exclusion is not required for read, multiple read requests could be serviced concurrently. The rendezvous, however allows a task to communicate with only one other task at a time. This restriction has been addressed in the design of Ada95 <ref> [10] </ref>, by adding another concept, that of "protected" types. Griffin ([8], [11]) is a statically typed language designed specifically for the rapid prototyping ([1], [2]) of Ada software. <p> Both conditional acceptance and out of FIFO order processing may be combined in the same accept statement. While useful for certain applications, conditional acceptance and out of FIFO ordering do not increase concurrency in contrast to the Griffin keywords multiple and and. Ada95 <ref> [10] </ref> takes another approach to increasing concurrency by adding "protected" types. These are types with hidden implementations whose operations consist of functions or procedures, with the constraint that only functions may be executed concurrently.
Reference: [11] <author> K. Laufer. </author> <title> Toward a formal description of Griffin, </title> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The rendezvous, however allows a task to communicate with only one other task at a time. This restriction has been addressed in the design of Ada95 [10], by adding another concept, that of "protected" types. Griffin ([8], <ref> [11] </ref>) is a statically typed language designed specifically for the rapid prototyping ([1], [2]) of Ada software. The Griffin constructs we describe in this paper address the above issues in a different way, which provides greater flexibility without inhibiting concurrency.
Reference: [12] <author> P. Mills. </author> <title> Programming Parallel and Distributed Programs in Proteus. </title> <type> Technical Report TR90-041, </type> <institution> University of North Carolina, </institution> <year> 1990. </year>
Reference-contexts: The goal is to allow invocations of operations that do not conflict to run concurrently, while ensuring mutual exclusion for conflicting operations. The Proteus <ref> [12] </ref> system supports this feature with the keyword schedule in the class definition. Figure 10 shows the Proteus class definition for a shared variable. The semantics of schedule are that the pairs of operations specified cannot run concurrently.
Reference: [13] <author> E. Schonberg. </author> <title> Ada in use. </title> <booktitle> In Proceedings of the Ada International Conference, </booktitle> <pages> pages 58-71. </pages> <publisher> Cam-bridge University Press, </publisher> <month> May </month> <year> 1985. </year>
Reference-contexts: These include concurrent read operations when a cache is used, or operations such as fetch-and-add [7] that are combined in a network. In Griffin, a fetch-and-add operation can be implemented as shown in Figure 7 This implementation is similar to that proposed for Ada83 <ref> [13] </ref>, where it was shown that Ada semantics were maintained (modulo some minor exception situations) by implementing the code (which uses a task in Ada83) by the built-in instruction if it was available.
References-found: 13

