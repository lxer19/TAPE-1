URL: http://www.cs.utah.edu/~banavar/thesis.ps.Z
Refering-URL: http://www.cs.utah.edu/~banavar/research.html
Root-URL: 
Title: AN APPLICATION FRAMEWORK FOR COMPOSITIONAL MODULARITY  
Author: by Guruduth S. Banavar 
Degree: A dissertation submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: December 1995  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Allen, R., and Garlan, D. </author> <title> Beyond definition/use: Architectural interconnection. </title> <booktitle> In Proc. of Workshop on Interface Definition Languages (January 1994), </booktitle> <editor> J. Wing, </editor> <publisher> Ed., </publisher> <pages> pp. </pages> <note> 35 - 45. Available as August 1994 issue of ACM SIGPLAN Notices. </note>
Reference-contexts: Nonetheless, formal and machine-processable descriptions are becoming necessary and widespread, especially in the context of distributed systems. An architecture aims to describe the components of a system and their relationships, such as "is-a," "has-a," and "communicates-with." These properties are usually described via architecture description languages (ADLs) <ref> [54, 1] </ref> of varying 135 degrees of expressive power. A description of the conventional typed interfaces of components is a simple example of an architecture description.
Reference: [2] <author> Amadio, R. M., and Cardelli, L. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems 15, </journal> <month> 4 (September </month> <year> 1993). </year>
Reference-contexts: A key insight in this work is that there is indeed a wide range of software artifacts that can be modeled as self-referential namespaces. For instance, it is well known that recursive interface types can be viewed as self-referential namespaces <ref> [14, 2] </ref>. A traditional compiled object file can also be viewed as a self-referential namespace. Furthermore, structured document fragments can be modeled as self-referential namespaces. Even other artifacts, such as GUI components and file system directories can be regarded as recursive namespaces. <p> Class Type requires that subclasses provide separate methods for finding equality (eq rec) and subtyping (le rec) of recursive types. Subclasses of class Type shown in Figure 5.4 directly implement the recursive subtyping algorithm given by Amadio and Cardelli <ref> [2] </ref>, which uses a trail of pairs of known recursive subtypes to avoid diverging on cyclic structures. <p> For example, structural typing can be applied to languages such as ANSI C with name-based typing. Pure name-based typing becomes a problem in persistent and distributed environments, where data and types could migrate outside the program in which they were originally created <ref> [2] </ref> and lead to matching of names that may or may not have the same programmer-intended meaning. <p> For interfaces, which are recursive types, subtyping is determined 140 structurally, as described by the following rule (algorithms for subtyping recursive types are given by Amadio and Cardelli <ref> [2] </ref>): ` g t 1 : fls: fa 1 : ff 11 ; : : : ; a k : ff 1k ; : : : ; a n : ff 1n g; ` 8i 2 1 : : : k; ff 1i ff 2i ` g t 1 g t <p> Instead of integrating inherited types with name-based typing, we can introduce structural typing of interfaces. Pure name-based typing could become a problem in distributed environments, where data and types could migrate outside the program in which they were originally created <ref> [2] </ref> and lead to matching of names that may or may not have the same programmer-intended meaning. With structural typing, the names and types of individual con stituents of interfaces are significant. 3. We shall support arbitrary rebinding of operations with the override operator.
Reference: [3] <author> Apollo Computer, Inc. </author> <title> DOMAIN Software Engineering Environment (DSEE) Call Reference. </title> <address> Chelmsford, MA, </address> <year> 1987. </year>
Reference-contexts: From the systems point of view, a user-space loader such as OMOS is considered no longer unusual [69, 31]. Also, OMOS has some similarity to utilities such as dld [38] that aid programmers in the dynamic loading of code and data. Finally, the Apollo DSEE <ref> [3] </ref> system was a server-based system which managed sources and objects, taking advantage of caching to avoid recompilation. However, DSEE was 131 primarily a CASE tool and did not take part in the execution phase of program development.
Reference: [4] <author> Auerbach, J., and Russel, J. </author> <title> The Concert signature representation: IDL as intermediate language. </title> <booktitle> In Proc. of Workshop on Interface Definition Languages (January 1994), </booktitle> <editor> J. Wing, </editor> <publisher> Ed., </publisher> <pages> pp. </pages> <note> 1 - 12. Available as August 1994 issue of ACM SIGPLAN Notices. </note>
Reference-contexts: These languages usually support some form (however weak) of specifying the interfaces of components, e.g., header files in C. However, many distributed systems, e.g., refs. <ref> [60, 4, 44] </ref>, support a separate IDL distinct from CPLs. Explicit interface descriptions are useful for various purposes: (1) Specification. To specify the contractual obligations between a service providing component and its clients, and to ascertain that they are met. <p> If the specificational power of an IDL does not exceed that of conventional programming language type systems, the question arises as to the need for supporting a separate IDL that is human-readable. It can be argued, as in ref. <ref> [4] </ref>, that instead, the type systems of individual CPLs can be augmented with constructs to specify interoperability requirements and used to generate specifications in a purely machine-readable IDL. <p> In addition, Rapide supports a notion of private interfaces which facilitates ADT-style implementation of n-ary methods. However, it does not permit arbitrary overriding as with the override operator. Also, there is no notion of self-reference of type constituents of interfaces. Concert <ref> [4] </ref> is a multilanguage distributed programming system in which interface specification is the responsibility of individual programming languages, not a separate IDL. However, a machine-readable IDL is used to define equivalence between declarations in different languages and to support a single intermediate representation.
Reference: [5] <author> Bershad, B., Anderson, T., Lazowska, E., and Levy, H. </author> <title> Lightweight remote procedure call. </title> <journal> Association for Computing Machinery Transactions on Computer Systems 8, </journal> <month> 1 (February </month> <year> 1990), </year> <pages> 37-55. </pages>
Reference-contexts: There is a plethora of literature related to stub generation <ref> [6, 5, 75] </ref>. The Polygen system [12] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [6] <author> Birrell, A., and Nelson, B. </author> <title> Implementing remote procedure calls. </title> <journal> Association for Computing Machinery Transactions on Computer Systems 2, </journal> <month> 1 (February </month> <year> 1984), </year> <pages> 39-59. </pages>
Reference-contexts: There is a plethora of literature related to stub generation <ref> [6, 5, 75] </ref>. The Polygen system [12] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [7] <author> Bracha, G. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <note> Technical report UUCS-92-007; 143 pp. </note>
Reference-contexts: Based on this, Bracha and Lindstrom [9] promulgated the idea that OO inheritance is really a form of modularity and introduced a comprehensive suite of operations to manipulate record generators. Furthermore, Bracha <ref> [7] </ref> expressed this model abstractly and suggested that it could be formulated as a framework. This dissertation further advances the semantic models proposed previously, by introducing the notion of compositional nesting. A problem with previous models was that direct lexical nesting of modules restricts reuse of the nested modules. <p> MT E X is also a direct completion of Etyma. 1.6 Dissertation Organization The next chapter presents the foundational and motivational concepts of compositional modularity. In particular, the starting point of this work, embodied in the programming language Jigsaw <ref> [7] </ref>, is presented in some detail. Following that, Chapter 3 demonstrates the expressive power of compositional modularity via several examples shown in the language CMS. The focus is on emulating the important idioms and styles of OO programming. This chapter also illustrates the programming style associated with compositional modularity. <p> Furthermore, if the implementation of a module directly depends on its inherited ancestors by 18 naming them, its reusability will be compromised. For an extended treatment of these and other problems with violation of encapsulation, the reader is referred to Bracha's thesis <ref> [7] </ref>, Chapter 2. The interface supported by objects of a class is called their type. Many OO programming languages equate the concept of a class with that of a type. <p> In such a model, binding and rebinding of names is done via operations over generators that appropriately manipulate the s parameter. In fact, generators can be adapted and combined in many useful ways before actually instantiating them. Several examples of this are shown in Section 2.2.1. Bracha <ref> [7] </ref> shows that this notion of abstracting over self can be used to achieve a comprehensive array of individual effects of inheritance. Furthermore, a generator is instantiated by taking its fixpoint by applying the fixpoint operator Y . Such an individual instance is a concrete namespace. <p> This viewpoint, above all, characterizes the essence of the model of compositional modularity. Another way to describe compositional modularity is to articulate a set of characteristics that are expected of module models that claim to support it. The desiderata for module systems, given in ref. <ref> [7] </ref>, is a good starting point for such a list. Below, we first describe characteristics of traditional modularity and then describe how compositional modularity augments them. Encapsulation is a crucial notion in traditional modularity. Modules must be able to hide their implementation and expose only an interface. <p> Such a generic model can then be expressed in an OO manner, constituting what is generally referred to as an object-oriented framework [42]. This approach was first suggested in Bracha's thesis <ref> [7] </ref>, although no engineering strategies or implementation work was presented. A more complete and detailed description of compositional modularity will be provided in Chapters 3 and 4 by presenting a language embodying its concepts. 2.2 A Formal Characterization In this section, we summarize the formal semantics of Jigsaw [7], a module <p> Bracha's thesis <ref> [7] </ref>, although no engineering strategies or implementation work was presented. A more complete and detailed description of compositional modularity will be provided in Chapters 3 and 4 by presenting a language embodying its concepts. 2.2 A Formal Characterization In this section, we summarize the formal semantics of Jigsaw [7], a module language that supports most notions of compositional modularity, and constitutes the starting point for this research. The concepts in this section will be covered in the concrete context of a variant of Scheme in the following chapter; thus this section may be skipped without loss of continuity. <p> The formal semantics are given here so that extensions to this semantics can be presented formally in the rest of the dissertation. 2.2.1 Generator Manipulation The semantics are specified here using the untyped lambda calculus | see the original description <ref> [7, 9] </ref> for full details. As mentioned earlier, the basis of generator semantics goes back to record 24 calculi. A record is characterized as a function from a finite domain of labels to a domain of values. Each label-value pair is called an attribute. <p> a = g: s: (f reeze a)(g)(s) n r a copy-as a b = g: s: let super = g (s) in super k r fb = super: r ag The definitions for the unary operators given in the figure are more involved; the interested reader is referred to ref. <ref> [7] </ref>. (Also, Chapter 3 explains the semantics of these operators, along with examples and idioms of their use, within the concrete context of an extension of the Scheme language.) In order to model imperative semantics in this framework, we must account for the effect of instantiation on the store. <p> (b) (define-subclass land-vehicle (land-veh-chars vehicle)) (define-subclass sea-vehicle (sea-veh-chars vehicle)) (define-subclass amphibian (land-veh-chars sea-veh-chars vehicle)) (c) (define amphibian (hide (override (copy-as vehicle '(display) '(super-display)) (hide (override (copy-as sea-veh-chars '(display) '(super-display)) land-veh-chars) '(super-display))) '(super-display))) inheritance given here uniformly treats all aspects of inheritance as operations over modules, as was first developed in <ref> [7] </ref>. With the definitions in box (a), we can create land-vehicle and sea-vehicle "sub classes" of vehicle as shown in box (b). This is achieved using the copy-override-hide idiom (Figure 3.9), but with the macro define-subclass which accepts a slightly different syntax. <p> Note that the augmentation of ordinary generators into closed generators requires augmentation of static type rules defined on ordinary generators in ref. <ref> [7] </ref>; however these augmentations will not be given here. The first question is whether we can treat imported names simply as declared names, thus not distinguishing between declared self-references and nonlocal references. <p> Additionally, it must be noted that the binary module operators merge and override cannot be specified polymorphically, since they require complete knowledge of their incoming parameters. (The problem of integrating the notion of ADT's with inheritance in the presence of static typing was noted in ref. <ref> [7] </ref>.) There are several interesting and useful directions in connection with compositional modularity that are as yet unexplored. These are sketched in the following section. 9.2 Future Directions 9.2.1 Framework Enhancements The design of Etyma can be enhanced to encompass more functionality than presented here. <p> Furthermore, for each occurrence of module instantiation in the source, class Method's translate can call class Module's method gen instance () which would generate C code that allocates an instance of that module with the appropriate layout (an object layout mechanism such as that suggested in ref. <ref> [7] </ref> can be used). Compilation in the presence of first-class modules will be slightly more involved, since code to represent modules and perform module operations at run-time must be generated as well. 9.2.2 Other Completions Processors for many other programming languages can be built by reusing Etyma. <p> Of course, if they are already OO, it will be much harder to reconcile the semantics and pragmatics of the preexisting OO model with that of compositional modularity. (A brief treatment of extending Modula-3 to incorporate compositional operators is given in ref. <ref> [7] </ref>.) However, in my opinion, much more can be gained by layering compositional modularity on top of non-OO languages and systems, such as the four examples presented in this work.
Reference: [8] <author> Bracha, G., and Cook, W. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. OOPSLA Conference (Ottawa, </booktitle> <month> October </month> <year> 1990), </year> <note> ACM. </note>
Reference-contexts: Abstract modules such as these are sometimes called "mixins" | reusable abstractions that require other abstractions in order to be usefully applied. Such abstractions have been characterized as functions from classes to classes <ref> [8] </ref>.
Reference: [9] <author> Bracha, G., and Lindstrom, G. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages (San Francisco, </booktitle> <address> CA, April 20-23, 1992), </address> <publisher> IEEE Computer Society, </publisher> <pages> pp. 282-290. </pages> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: The semantic foundations of the model go back to record calculi pioneered by Cardelli, Mitchell, and others [36, 16]. Classes were first modeled as record generators (records abstracted over themselves) by Cook [24], who also introduced some operators to manipulate generators. Based on this, Bracha and Lindstrom <ref> [9] </ref> promulgated the idea that OO inheritance is really a form of modularity and introduced a comprehensive suite of operations to manipulate record generators. Furthermore, Bracha [7] expressed this model abstractly and suggested that it could be formulated as a framework. <p> The formal semantics are given here so that extensions to this semantics can be presented formally in the rest of the dissertation. 2.2.1 Generator Manipulation The semantics are specified here using the untyped lambda calculus | see the original description <ref> [7, 9] </ref> for full details. As mentioned earlier, the basis of generator semantics goes back to record 24 calculi. A record is characterized as a function from a finite domain of labels to a domain of values. Each label-value pair is called an attribute.
Reference: [10] <author> Bruce, K. B. </author> <title> A paradigmatic object-oriented programming language: Design static typing and semantics. </title> <type> Tech. Rep. </type> <institution> CS-92-01, Williams College, </institution> <month> January 31, </month> <year> 1992. </year>
Reference-contexts: The answer is no. In a sufficiently expressive language, inheritance does not necessarily result in subtypes. (The reason for this has to do with contravariant subtyping of binary methods <ref> [10] </ref>.) Only recently has inheritance been widely understood as an implementation reuse mechanism, divorced from subtyping, which defines "is-a" relationships between objects [23]. High-performance OO languages that support static typechecking and separate compilation of classes impose special requirements on the implementation of inheritance. <p> More recently, there have been some denotational characterizations of the notion of classes and inheritance <ref> [10, 24, 41] </ref>. The one that is relevant to this work is due to Cook, in whose original formulation [24], a class is viewed as a record abstracted over its own notion of what "self" means. References to symbols within the class are made via the abstracted self parameter. <p> Expressions that are evaluators can only be replaced with expressions whose types are subtypes of the original, whereas expressions that are acceptors can only be replaced by expressions whose types are supertypes of the original <ref> [10] </ref>. As a result, subtyping of variables is always restricted to type equivalence. 5.2.2.2.5 Recursive types. Etyma supports recursive types (not shown in as an object of class RecType. Class Type requires that subclasses provide separate methods for finding equality (eq rec) and subtyping (le rec) of recursive types. <p> Expressions that are evaluators can only be replaced with expressions whose types are subtypes of the original, whereas expressions that are acceptors can only be replaced by expressions whose types are supertypes of the original <ref> [10] </ref>. As a result, subtyping of variables must always be restricted to type equivalence. Consider file-level read-only (i.e., const) variables. <p> As a result, subtyping on file-level read-only variables is also restricted to type equivalence. Arguments such as the above can be formulated to show that subtyping on pointer types is also restricted to type equivalence. Consider subtyping of function types. Subtyping of function types is by con-travariance <ref> [10] </ref>. That is, a function type is a subtype of another with the same number of arguments if its return type is a subtype of the latter's, and its input argument types are supertypes of the corresponding ones in the latter. <p> Also, the operators freeze and hide do not apply, since interfaces by definition 139 represent the public types of modules. In the following section, we provide a formal characterization of interface inheritance in order to clarify the above notions. 7.1.3 Type Generators An interface is a recursive structure <ref> [23, 10] </ref> corresponding to what we shall call a type generator. Type generators are analogous to ordinary generators given in Section 2.2.1, except that they are functions over records in which labels are bound to types viewed as values. In this sense, types are first-class within IDLs. <p> Interface F inherits from an interface derived from (a subset of) D via the project operator. 7.3 Related Work The TOOPL language <ref> [10] </ref> extensively treats the foundations of type systems in relation to inheritance. The notions of selftype and inherited types given here are taken from there. The type sublanguage of the Rapide [44] programming language framework supports much the same functionality that is given in this chapter.
Reference: [11] <author> Burstall, R., and Lampson, B. </author> <title> A kernel language for abstract data types and modules. </title> <booktitle> In Proceedings, International Symposium on the Semantics of 164 Data Types, </booktitle> <editor> G. Kahn, D. MacQueen, and G. Plotkin, Eds., </editor> <volume> vol. </volume> <booktitle> 173 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984, </year> <pages> pp. 1-50. </pages>
Reference-contexts: Furthermore, module systems facilitate the manipulation of namespaces. Given that namespaces exist as environments at run-time, it seems natural to support modules themselves as first-class entities. Additionally, this results in uniformity 16 of manipulable values. Languages such as Pebble <ref> [11] </ref>, Rascal [40, 41], and others [72] support first-class modules. (It is worth mentioning that support for higher-order modules does not necessarily mean that modules are first-class. For instance, a higher-order SML module system such as in ref. [35] might support functors with functor parameters, or higher-order modules. <p> Also, these module systems closely associate a static type system with the module system. From the viewpoint of compositionality and reuse, these systems are quite limited, as explained in Section 2.1.1. An early effort to incorporate first-class modules into a language was in Pebble <ref> [11] </ref>. There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX [72] and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems [39, 59, 76, 25, 67].
Reference: [12] <author> Callahan, J. R., and Purtilo, J. M. </author> <title> A packaging system for heterogeneous execution environments. </title> <journal> IEEE Transactions on Software Engineering 17, </journal> <month> 6 (June </month> <year> 1991), </year> <pages> 626-635. </pages>
Reference-contexts: However, DSEE was 131 primarily a CASE tool and did not take part in the execution phase of program development. The module language of OMOS is somewhat similar to architecture description languages, such as Rapide [44], the POLYLITH Module Interconnection Language (MIL) <ref> [12, 66] </ref>, and OMG's Interface Definition Language (IDL) [60]. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections. <p> There is a plethora of literature related to stub generation [6, 5, 75]. The Polygen system <ref> [12] </ref> is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [13] <author> Campbell, R. H., Islam, N., Johnson, R., Kougiouris, P., and Madany, P. </author> <title> Choices, frameworks and refinement. </title> <booktitle> In Object Orientation in Operating Systems (Palo Alto, </booktitle> <address> CA, </address> <month> October </month> <year> 1991), </year> <journal> IEEE Computer Society, </journal> <pages> pp. 9-15. </pages>
Reference-contexts: For all three iterations, both design and code reuse were found to be significant, between 73.3% and 91.7%. 5.5 Related Work Several OO frameworks have been developed, initially for user interfaces and subsequently for many other domains as well <ref> [26, 78, 79, 13] </ref>. Etyma bears a close relationship to compiler frameworks [21], which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into 95 two categories: those that represent programs syntactically such as Sage++ [80] and those that represent programs semantically, such as ours.
Reference: [14] <author> Canning, P., Cook, W., Hill, W., and Olthoff, W. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (1989), </booktitle> <editor> N. Meyrowitz, </editor> <publisher> Ed., </publisher> <pages> pp. 457-467. </pages>
Reference-contexts: A key insight in this work is that there is indeed a wide range of software artifacts that can be modeled as self-referential namespaces. For instance, it is well known that recursive interface types can be viewed as self-referential namespaces <ref> [14, 2] </ref>. A traditional compiled object file can also be viewed as a self-referential namespace. Furthermore, structured document fragments can be modeled as self-referential namespaces. Even other artifacts, such as GUI components and file system directories can be regarded as recursive namespaces. <p> This represents the widely accepted notion that an inherited module does not necessarily result in a subtype of the "parent," in effect separating inheritance from subtyping <ref> [14] </ref>. 3.1.2 Combination The module capacity-module given in Figure 3.1 (c) exports two symbols: capacity, which represents the fuel capacity of a vehicle in gallons, and greater-capacity?, bound to a procedure that determines if the current instance has greater fuel capacity than the incoming argument. <p> The primitive defined? can actually be implemented in terms of attrs-of. The module from which an instance was created can be obtained with the primitive module-of. Thus, (module-of (self)) is similar to self class in Smalltalk, like current in Eiffel [57] and myclass given in Canning et al. <ref> [14] </ref>. It is sometimes useful to know the names of public attributes that are self-referenced within a method. The primitive self-refs-in returns a flat list comprising the set of all the self-referenced public attributes within the bindings of the given attribute names.
Reference: [15] <author> Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B., and Nelson, G. </author> <type> Modula-3 report. Tech. Rep. 31, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: To enforce stronger separation between modules, some systems require that all interactions between modules be declared explicitly, by importing names used from the interfaces of other modules. Examples of such module systems are those of the Modula family <ref> [15] </ref> and the Scheme module system given in ref. [25]. Typically, such systems perform some level of static conformance checking (at compile time) and binding (at link time) between the imports and exports of modules. However, completely dynamic importation has also been proposed [77].
Reference: [16] <author> Cardelli, L., and Mitchell, J. C. </author> <title> Operations on records. </title> <type> Tech. Rep. 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: This property is used to advantage in developing an application framework, outlined in Section 1.4. In introducing the model of compositional modularity, it is important to acknowledge its lineage. The semantic foundations of the model go back to record calculi pioneered by Cardelli, Mitchell, and others <ref> [36, 16] </ref>. Classes were first modeled as record generators (records abstracted over themselves) by Cook [24], who also introduced some operators to manipulate generators. <p> Each label-value pair is called an attribute. Operators over records, such as for concatenation (k r ), attribute overriding ( r ), attribute removal (n r ), renaming (rename r ) and selection (: r ), are defined elsewhere <ref> [16] </ref> and not given here. The subscript r signifies that the operations are defined on records. Applicatively, a module is modeled as a record generating function, or a generator. <p> The concept of records models the classical notion: finite functions from labels to values, with no notion of self-reference. Records support operations such as merge, override, rename, restrict, and copy-as, similar to the ones found in refs. <ref> [16, 36] </ref>. In addition, the select operation on records models attribute selection. Modules support all the above operations except select, plus the operations freeze and hide. Thus, the concept of a module is clearly not a subtype (is-a) of the concept of a record.
Reference: [17] <author> Cardelli, L., and Wegner, P. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys 17, </journal> <month> 4 (December </month> <year> 1985), </year> <pages> 471-522. </pages>
Reference-contexts: An interface that supports at least as much functionality as another, possibly more, is called a subtype of the other. Polymorphism (more accurately, inclusion polymorphism <ref> [17] </ref>) is a direct consequence of subtyping relationships between objects' types. Polymorphism is usually implemented by using techniques of late binding of method calls to the actual code that implements the methods.
Reference: [18] <author> Chamberlain, S. libbfd. </author> <title> Free Software Foundation, Inc. Contributed by Cygnus Support, </title> <month> March </month> <year> 1992. </year>
Reference-contexts: The notion of an object file is implemented as a concrete subclass DotO of Module. The methods of class DotO are implemented using a code library that provides relative independence from particular object file formats, the Binary File Descriptor (BFD) library <ref> [18] </ref> from Cygnus Corporation. As mentioned earlier, a dot-o is instantiated into fixed executables, modeled by class FixedExe, a subclass of Instance. A fixed executable is internally represented as an address map.
Reference: [19] <author> Chambers, C., Ungar, D., Chang, B.-W., and Holzle, U. </author> <title> Parents are shared parts of objects: Inheritance and encapsulation in SELF. LISP and Symbolic Computation: </title> <note> An International Journal 4, 3 (1991). </note>
Reference-contexts: However, it is not clear that completely opening up the implementation will not result in much complexity and inadvertent abuse by users. Finally, inheritance of first-class modules must be compared with class-less programming with prototypes and delegation as in SELF <ref> [19] </ref>. Class-less programming languages allow individual objects to inherit from (or delegate to) other objects. Thus, there is no notion of classes instantiable into objects.
Reference: [20] <author> Chiba, S., and Masuda, T. </author> <title> Designing an extensible distributed language with a meta-level architecture. </title> <booktitle> In Proceedings of the 7th European Conference on Object-Oriented Programming (New York, 1993), </booktitle> <publisher> Springer-Verlag. LNCS 707. </publisher>
Reference-contexts: Dexterity of multiple inheritance as given in Section 3.4.1 was a primary practical consideration in the design of the CLOS MOP. CMS must also be compared to the approach of open implementations. Meta-object protocols (MOPs) for CLOS [47] and C++ <ref> [20] </ref> expose the OO implementation of the language processor to the programmer, via a controlled protocol. Many aspects of the language's implementation, such as the mechanisms of inheritance, object data layout, and method dispatch, are controllable via such MOPs.
Reference: [21] <author> Clark, C. </author> <title> OO compilation | what are the objects? In Addendum to the proceedings of OOPSLA (Portland, </title> <address> Oregon, </address> <month> October </month> <year> 1994), </year> <editor> M. C. Wilkes, Ed., OOPS Messenger, </editor> <booktitle> ACM SIGPLAN, </booktitle> <pages> pp. 67 - 71. </pages>
Reference-contexts: Etyma bears a close relationship to compiler frameworks <ref> [21] </ref>, which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into 95 two categories: those that represent programs syntactically such as Sage++ [80] and those that represent programs semantically, such as ours. <p> As mentioned earlier, Etyma does not support front-end and back-end related abstractions for tool construction. For supporting front-ends, a modular parser can be associated with each abstraction that parses by calling parsers associated other abstractions in turn. Object-oriented parser technology such as yacc++ <ref> [21] </ref> can be utilized for this. Back-end compilation is more interesting. Say we want to support translation into the C language. As usual, the front-end can first build up an internal representation of the program comprising instances of specialized Etyma classes.
Reference: [22] <editor> Clinger, W., and Rees, J. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <booktitle> ACM Lisp Pointers 4, </booktitle> <month> 3 </month> <year> (1991). </year>
Reference-contexts: CHAPTER 3 COMPOSITIONALLY MODULAR SCHEME The purpose of this chapter is twofold. One is to introduce the concepts of compositional modularity in the concrete context of a programming language. The language presented here is called Compositionally Modular Scheme, or CMS for short, which is the programming language Scheme <ref> [22] </ref> extended to support compositional modularity. The other purpose is to demonstrate that these notions are general enough to emulate idioms of advanced modularity such as OO inheritance. <p> while keeping with its original design philosophy that "... a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today" <ref> [22] </ref>. CHAPTER 4 MODULE NESTING Software development by decomposition naturally leads to hierarchical nesting of modules. Thus, support for nesting is an important requirement for module systems. In this chapter, the notion of module nesting is developed and integrated with the notion of compositionality. <p> Finally, it must be continually available. For these reasons, the logical module layer in the prototype described here is managed by a server process | a second generation implementation of a server named OMOS [63]. The module manipulation language supported by OMOS is derived from the programming language Scheme <ref> [22] </ref> and is similar in flavor to CMS. The most important distinction, of course, is that its notion of modules is that of object files. Modules are created by reading in physical object files. Conventional linking is accomplished using the merge operator of the module language.
Reference: [23] <author> Cook, W., Hill, W., and Canning, P. </author> <title> Inheritance is not subtyp-ing. In Theoretical Aspects of Object-Oriented Programming, </title> <editor> C. Gunter and J. Mitchell, Eds. </editor> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> pp. 497 - 517. 165 </pages>
Reference-contexts: In a sufficiently expressive language, inheritance does not necessarily result in subtypes. (The reason for this has to do with contravariant subtyping of binary methods [10].) Only recently has inheritance been widely understood as an implementation reuse mechanism, divorced from subtyping, which defines "is-a" relationships between objects <ref> [23] </ref>. High-performance OO languages that support static typechecking and separate compilation of classes impose special requirements on the implementation of inheritance. <p> Most importantly, an IDL should be able to express the types of components generated via implementation inheritance in CPLs. In fact, it has been shown that inheritance of interfaces generates exactly those types, known as inherited types, that correspond to the types of inherited objects <ref> [23] </ref>. (Inherited types are distinct from subtypes, see below.) These reasons point to a need for flexible interface inheritance mechanisms in IDLs. Several existing IDLs, e.g., refs. [60, 44], support some form of interface inheritance. <p> Also, the operators freeze and hide do not apply, since interfaces by definition 139 represent the public types of modules. In the following section, we provide a formal characterization of interface inheritance in order to clarify the above notions. 7.1.3 Type Generators An interface is a recursive structure <ref> [23, 10] </ref> corresponding to what we shall call a type generator. Type generators are analogous to ordinary generators given in Section 2.2.1, except that they are functions over records in which labels are bound to types viewed as values. In this sense, types are first-class within IDLs.
Reference: [24] <author> Cook, W., and Palsberg, J. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications (1989), </booktitle> <pages> pp. 433-444. </pages>
Reference-contexts: In introducing the model of compositional modularity, it is important to acknowledge its lineage. The semantic foundations of the model go back to record calculi pioneered by Cardelli, Mitchell, and others [36, 16]. Classes were first modeled as record generators (records abstracted over themselves) by Cook <ref> [24] </ref>, who also introduced some operators to manipulate generators. Based on this, Bracha and Lindstrom [9] promulgated the idea that OO inheritance is really a form of modularity and introduced a comprehensive suite of operations to manipulate record generators. <p> More recently, there have been some denotational characterizations of the notion of classes and inheritance <ref> [10, 24, 41] </ref>. The one that is relevant to this work is due to Cook, in whose original formulation [24], a class is viewed as a record abstracted over its own notion of what "self" means. References to symbols within the class are made via the abstracted self parameter. <p> More recently, there have been some denotational characterizations of the notion of classes and inheritance [10, 24, 41]. The one that is relevant to this work is due to Cook, in whose original formulation <ref> [24] </ref>, a class is viewed as a record abstracted over its own notion of what "self" means. References to symbols within the class are made via the abstracted self parameter. Furthermore, inheritance is viewed as an operation that appropriately modifies "self" and references to it.
Reference: [25] <author> Curtis, P., and Rauen, J. </author> <title> A module system for Scheme. </title> <booktitle> In Conference Record of the ACM Lisp and Functional Programming (1990), ACM. </booktitle>
Reference-contexts: Procedures may contain references to other name bindings within the module. In this manner, a Scheme module may be modeled as a self-referential namespace. Several module systems for Scheme have been proposed previously <ref> [25, 77, 67] </ref>, but these systems mainly provide a facility for structuring programs via decomposition. However, the ability to recompose first-class modules can additionally support design and implementation reuse akin to inheritance in OO programming. <p> To enforce stronger separation between modules, some systems require that all interactions between modules be declared explicitly, by importing names used from the interfaces of other modules. Examples of such module systems are those of the Modula family [15] and the Scheme module system given in ref. <ref> [25] </ref>. Typically, such systems perform some level of static conformance checking (at compile time) and binding (at link time) between the imports and exports of modules. However, completely dynamic importation has also been proposed [77]. One way to specify modules is to describe each of them completely from scratch. <p> There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX [72] and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems <ref> [39, 59, 76, 25, 67] </ref>. This is known to support large-scale programming, since clients can be written (and compiled) based on a module's interface. The module's implementors can then associate (possibly multiple) im 52 plementations with the interface. The CMS language presented here does not explicitly support interfaces. <p> Subsequently, implementations for this interface can be combined with it via override and private attributes encapsulated via hide. Several module systems have been developed for the Scheme programming language. Curtis and Rauen's system <ref> [25] </ref> supports explicit interfaces and modules with import and export specifications. Tung's [77] system additionally supports a notion of renaming conflicting imports, as well as dynamic binding of imported attributes. <p> This is equivalent to the conventional semantics of nested functions in most languages. Examples are ML substructures [76], Scheme modules <ref> [25] </ref>, and Beta subpatterns. However, one can only directly lexically nest modules in these systems; there is no notion of compositional nesting. The most experience with nested modules to date is with subpatterns supported by the Beta language [51, 55].
Reference: [26] <author> Deutsch, L. P. </author> <title> Design reuse and frameworks in the Smalltalk-80 programming system. In Software Reusability, </title> <editor> T. J. Biggerstaff and A. J. Perlis, Eds., </editor> <volume> vol. 2. </volume> <publisher> ACM Press, </publisher> <year> 1989, </year> <pages> pp. 55-71. </pages>
Reference-contexts: Reuse issues are explored in the following section. 5.4 Reuse Issues OO frameworks are built to be reused. Although the traditional notion of reuse is that of code reuse, design reuse is generally acknowledged to be equally or more important. According to Peter Deutsch <ref> [26] </ref>, interface design and functional factoring constitutes the key intellectual content of software and is far more difficult to create or recreate than code. In fact, it would not be wrong to say that the primary benefit of OO frameworks is design reuse. Table 5.2. <p> For all three iterations, both design and code reuse were found to be significant, between 73.3% and 91.7%. 5.5 Related Work Several OO frameworks have been developed, initially for user interfaces and subsequently for many other domains as well <ref> [26, 78, 79, 13] </ref>. Etyma bears a close relationship to compiler frameworks [21], which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into 95 two categories: those that represent programs syntactically such as Sage++ [80] and those that represent programs semantically, such as ours.
Reference: [27] <author> Ducournau, R., Habib, M., Huchard, M., and Mugnier, M. L. </author> <title> Proposal for a monotonic multiple inheritance linearization. </title> <booktitle> In Proceedings of OOPSLA (October 1994), </booktitle> <pages> pp. 164 - 175. </pages>
Reference-contexts: It has been argued that currently used linearizations do not ensure that "the inheritance mechanism behaves `naturally' relative to the incremental design of the inheritance hierarchy" <ref> [27] </ref>. Moreover, changing the inherited superclass of a class (an implementation detail) can change the computed linearization of superclasses, producing a completely different behavior than before. Perhaps it is better to let the programmer select the precedence order of super-classes as dictated by individual applications.
Reference: [28] <author> Ellis, M. A., and Stroustrup, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: These notions are captured in the type rule given in Figure 4.4 (omitting clauses for uniqueness conditions, etc.). This concludes our treatment of the semantics of nested modules. 4.5 Discussion and Related Work In C++ <ref> [28] </ref>, class nesting is merely a name-space structuring mechanism. Nonlocal references within nested classes are disallowed (except to statics, which are globally referable via qualified names) . A more conventional semantics is to have nonlocal references access bindings of names in a surrounding scope. <p> Furthermore, we use OO diagrams to describe the framework. Our diagramming conventions are based on that given in [30], and are given in Figure 5.1, These diagramming conventions have been adapted to describe a framework realized using the C++ language <ref> [28] </ref> such as Etyma. 75 Table 5.1. Design patterns used to describe Etyma. Name Description Bridge Decouple an abstraction from its implementation so that the two can vary independently. Composite Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. <p> However, the crucial advantage with our approach is that we perform type-checking as a controlled and programmable link-time activity. Use of header files has been a longstanding attempt at type-safety of separate compilation. The Annotated C++ Reference Manual <ref> [28, page 122] </ref> explains the inadequacy of header files as follows: ... C tried to ensure the consistency of separately compiled programs by controlling the information given to the compiler in header files. <p> With the objective of enabling type-safe linkage within the constraints of existing linkers, Stroustrup <ref> [74, 28] </ref> describes a mechanism for encoding functions with the types of input arguments. <p> With the objective of enabling type-safe linkage within the constraints of existing linkers, Stroustrup [74, 28] describes a mechanism for encoding functions with the types of input arguments. However, this mechanism is inadequate for our purposes since (i) certain classes of type errors cannot be detected (page 126 of <ref> [28] </ref>) since variable types and function return types are not encoded; (ii) although it could be extended to deal with structural typing of C aggregate types, it does not scale well to arbitrarily large types, e.g., large structs; and (iii) we want to do not only type-checking, but also useful adaptation
Reference: [29] <author> Gallesio, E. </author> <note> STk reference manual. Version 2.1, 1993/94. </note>
Reference-contexts: The CMS interpreter consists of two parts: a basic Scheme interpreter written in the C language, and the module system implemented as a completion of Etyma. The basic Scheme interpreter itself was derived from a publicly available scriptable windowing toolkit called STk <ref> [29] </ref>. The interpreter implementation exports many of the functions implementing Scheme semantics, thus making it easy to access its internals. Furthermore, the interpreter was originally designed to be extensible, i.e., new Scheme primitives can be implemented in C/C++ and easily incorporated into the interpreter.
Reference: [30] <author> Gamma, E., Helm, R., Johnson, R., and Vlissides, J. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. Professional Computing Series. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: Within the framework, however, the differences between these two kinds of module attributes are abstracted away; both of them are viewed through a single abstract interface. The architecture of the Etyma framework is documented in this dissertation using the concept of design patterns <ref> [30] </ref>. The version of Etyma documented here comprises about 45 reusable C++ classes in 7000 lines that evolved over six iterations over two years. <p> Design patterns are somewhat smaller architectural units than frameworks and are more general. Design patterns systematically name, explain, and evaluate important and recurring solutions to specific problems in OO software design. Thus, a pattern "catalog," such as the one given by Gamma et al. <ref> [30] </ref>, helps an OO designer to identify and apply simple and elegant solutions to commonly occurring problems in OO design to achieve greater reuse and flexibility. Table 5.1 gives brief descriptions of the patterns used in describing Etyma; the reader is referred to ref. [30] for complete descriptions. <p> one given by Gamma et al. <ref> [30] </ref>, helps an OO designer to identify and apply simple and elegant solutions to commonly occurring problems in OO design to achieve greater reuse and flexibility. Table 5.1 gives brief descriptions of the patterns used in describing Etyma; the reader is referred to ref. [30] for complete descriptions. Furthermore, we use OO diagrams to describe the framework. Our diagramming conventions are based on that given in [30], and are given in Figure 5.1, These diagramming conventions have been adapted to describe a framework realized using the C++ language [28] such as Etyma. 75 Table 5.1. <p> Table 5.1 gives brief descriptions of the patterns used in describing Etyma; the reader is referred to ref. <ref> [30] </ref> for complete descriptions. Furthermore, we use OO diagrams to describe the framework. Our diagramming conventions are based on that given in [30], and are given in Figure 5.1, These diagramming conventions have been adapted to describe a framework realized using the C++ language [28] such as Etyma. 75 Table 5.1. Design patterns used to describe Etyma.
Reference: [31] <author> Gingell, R. A. </author> <title> Shared libraries. Unix Review 7, </title> <month> 8 (August </month> <year> 1989), </year> <pages> 56-66. </pages>
Reference-contexts: Typically, some notion of hiding is supported. However, it is novel to support an expressive suite of combination operators and the ability to use a full-featured programming language to compose object modules. From the systems point of view, a user-space loader such as OMOS is considered no longer unusual <ref> [69, 31] </ref>. Also, OMOS has some similarity to utilities such as dld [38] that aid programmers in the dynamic loading of code and data. Finally, the Apollo DSEE [3] system was a server-based system which managed sources and objects, taking advantage of caching to avoid recompilation.
Reference: [32] <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: A model of a model, i.e., a meta-model, of a software system is usually referred to as a meta-level architecture (or meta-architecture). For instance, the OO programming model supported by Smalltalk <ref> [32] </ref> is itself captured as a set of interacting meta-objects, such as Object, Class and CompiledMethod, which constitutes the Smalltalk meta-architecture. Thus, a generic OO realization of the essential 77 concepts of compositional modularity, such as Etyma, can be termed as an OO meta-architecture for compositional modularity. <p> Compiler frameworks are designed with various objectives, such as for representing abstract syntax, constructing tools for programming environments, or for structuring the compiler itself, e.g., with objects representing phases of the compiler <ref> [32] </ref>, or for enabling compile-time reflection via a meta-object protocol [49]. Etyma, although supporting many of the above, is unique in that it is intended to be a reusable architecture for constructing a variety of modular systems. As mentioned earlier, Etyma represents a meta-architecture for modular systems. <p> However, being a meta-architecture, Etyma enables the construction of reflective systems, and the design of suitable MOPs, and thus could potentially bring the advantages mentioned above. As points of comparison, we now briefly present two widely known language meta-architectures: Smalltalk-80 <ref> [32] </ref> and the Common Lisp Object System (CLOS) [47]. 5.5.1 Smalltalk Smalltalk is based on a uniform model of communicating objects. It has a small number of concepts | object, class, instance, message, and method.
Reference: [33] <author> Gordon, M. J. C. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: A distinguishing feature of Etyma is that its design has been guided mainly by a formal description (i.e., denotational semantics and type rules) of the corresponding linguistic concepts. The reader might have noted the correspondence between the above framework abstraction design and denotational models of programming languages <ref> [33] </ref>. Denotational semantics applies functional programming to abstract over language functionality. Here, we apply a denotational description of modularity to abstract over language modularity.
Reference: [34] <author> Hamilton, G., and Radia, S. </author> <title> Using interface inheritance to address problems in system software evolution. </title> <booktitle> In Proc. of Workshop on Interface Definition Languages (January 1994), </booktitle> <editor> J. Wing, </editor> <publisher> Ed., </publisher> <pages> pp. </pages> <note> 119 - 128. Available as August 1994 issue of ACM SIGPLAN Notices. </note>
Reference-contexts: It may often be useful to specify an interface by reusing, i.e., inheriting from, existing interfaces. Reuse facilitates the evolution of interfaces <ref> [34] </ref> by ascertaining that inheriting interfaces evolve in step with the inherited interfaces. It also simplifies maintenance by reducing redundant code. Most importantly, an IDL should be able to express the types of components generated via implementation inheritance in CPLs. <p> However, a machine-readable IDL is used to define equivalence between declarations in different languages and to support a single intermediate representation. The use of interface inheritance to address a variety of problems in the evolution of distributed systems is explored nicely in ref. <ref> [34] </ref>, in the context of the Spring distributed system. 7.4 Summary It is argued in this chapter that complex distributed systems need an explicit notion of interface specification and an expressive language to support such specifications. The expressiveness required of such a language typically includes a notion of interface inheritance.
Reference: [35] <author> Harper, R., Mitchell, J. C., and Moggi, E. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Conference record of the 17th ACM Symposium on Principles of Programming Languages (POPL) (San Francisco, </booktitle> <address> CA USA, </address> <year> 1990), </year> <pages> pp. 341-354. </pages>
Reference-contexts: Languages such as Pebble [11], Rascal [40, 41], and others [72] support first-class modules. (It is worth mentioning that support for higher-order modules does not necessarily mean that modules are first-class. For instance, a higher-order SML module system such as in ref. <ref> [35] </ref> might support functors with functor parameters, or higher-order modules. However, functors are not run-time entities and, thus, not first-class. <p> In this section, its relationship to various other module models is given. Most classical module systems such as SML [76], and Ada [39] do not support first-class modules. Some ML systems <ref> [35] </ref>, however, do support higher-order functors, although not as first-class run-time values. Also, these module systems closely associate a static type system with the module system. From the viewpoint of compositionality and reuse, these systems are quite limited, as explained in Section 2.1.1.
Reference: [36] <author> Harper, R., and Pierce, B. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 131-142. </pages>
Reference-contexts: This property is used to advantage in developing an application framework, outlined in Section 1.4. In introducing the model of compositional modularity, it is important to acknowledge its lineage. The semantic foundations of the model go back to record calculi pioneered by Cardelli, Mitchell, and others <ref> [36, 16] </ref>. Classes were first modeled as record generators (records abstracted over themselves) by Cook [24], who also introduced some operators to manipulate generators. <p> The concept of records models the classical notion: finite functions from labels to values, with no notion of self-reference. Records support operations such as merge, override, rename, restrict, and copy-as, similar to the ones found in refs. <ref> [16, 36] </ref>. In addition, the select operation on records models attribute selection. Modules support all the above operations except select, plus the operations freeze and hide. Thus, the concept of a module is clearly not a subtype (is-a) of the concept of a record. <p> Such an interface is referred to as a "branded" interface [59]. Again, the le method may take into account explicit specification of subtyping relationships between branded interfaces. Class RecordType represents the type of records <ref> [36] </ref>, as well as the type of instances. It supports template methods for typechecking individual record operations, including select. These methods are implemented in a manner similar to those of class Interface.
Reference: [37] <author> Harrison, W., and Ossher, H. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of OOPSLA Conference (September 1993), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 411 - 428. 166 </pages>
Reference-contexts: An environment for flexible application development has been pursued in the line of research leading to the so-called subject-oriented programming (SOP) <ref> [37] </ref>. In this research, a "subject" is in essence an OO component, i.e., a component built around an OO class hierarchy. Subjects can be separately compiled and composed using tools know as "compositors" (similar to OMOS). Compositors use various operators similar to the ones presented here.
Reference: [38] <author> Ho, W., and Olsson, R. </author> <title> An approach to genuine dynamic linking. </title> <journal> Software| Practice and Experience 21, </journal> <month> 4 (April </month> <year> 1991), </year> <pages> 375-390. </pages>
Reference-contexts: From the systems point of view, a user-space loader such as OMOS is considered no longer unusual [69, 31]. Also, OMOS has some similarity to utilities such as dld <ref> [38] </ref> that aid programmers in the dynamic loading of code and data. Finally, the Apollo DSEE [3] system was a server-based system which managed sources and objects, taking advantage of caching to avoid recompilation.
Reference: [39] <author> Intermetrics, Inc. </author> <title> Ada 9X Reference Manual. </title> <address> Cambridge, Massachusetts, </address> <year> 1994. </year> <title> Ada 9X Mapping/Revision Team Effort. </title>
Reference-contexts: However, such complete specification does not facilitate reuse of portions of the module that could potentially be common to several modules. To support reuse better, modules can be parameterized with the (free) names used within the module, as in SML functors [76] and ADA generic packages <ref> [39] </ref>. A parameterized module can be multiply instantiated (usually before run-time) with actual argument values to produce concrete modules, which are then used in the same manner as completely specified modules. <p> In this section, its relationship to various other module models is given. Most classical module systems such as SML [76], and Ada <ref> [39] </ref> do not support first-class modules. Some ML systems [35], however, do support higher-order functors, although not as first-class run-time values. Also, these module systems closely associate a static type system with the module system. <p> There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX [72] and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems <ref> [39, 59, 76, 25, 67] </ref>. This is known to support large-scale programming, since clients can be written (and compiled) based on a module's interface. The module's implementors can then associate (possibly multiple) im 52 plementations with the interface. The CMS language presented here does not explicitly support interfaces.
Reference: [40] <author> Jagannathan, S. </author> <title> Dynamic modules in higher-order languages. </title> <booktitle> In Proceedings of the International Conference on Computer Languages (1994), IEEE. </booktitle>
Reference-contexts: Furthermore, module systems facilitate the manipulation of namespaces. Given that namespaces exist as environments at run-time, it seems natural to support modules themselves as first-class entities. Additionally, this results in uniformity 16 of manipulable values. Languages such as Pebble [11], Rascal <ref> [40, 41] </ref>, and others [72] support first-class modules. (It is worth mentioning that support for higher-order modules does not necessarily mean that modules are first-class. For instance, a higher-order SML module system such as in ref. [35] might support functors with functor parameters, or higher-order modules.
Reference: [41] <author> Jagannathan, S. </author> <title> Metalevel building blocks for modular systems. </title> <journal> ACM Transactions on Programming Languages and Systems 16, </journal> <month> 3 (May </month> <year> 1994), </year> <pages> 456-492. </pages>
Reference-contexts: Furthermore, module systems facilitate the manipulation of namespaces. Given that namespaces exist as environments at run-time, it seems natural to support modules themselves as first-class entities. Additionally, this results in uniformity 16 of manipulable values. Languages such as Pebble [11], Rascal <ref> [40, 41] </ref>, and others [72] support first-class modules. (It is worth mentioning that support for higher-order modules does not necessarily mean that modules are first-class. For instance, a higher-order SML module system such as in ref. [35] might support functors with functor parameters, or higher-order modules. <p> More recently, there have been some denotational characterizations of the notion of classes and inheritance <ref> [10, 24, 41] </ref>. The one that is relevant to this work is due to Cook, in whose original formulation [24], a class is viewed as a record abstracted over its own notion of what "self" means. References to symbols within the class are made via the abstracted self parameter. <p> The environment at any point can also be captured by using a special primitive, such as the-environment. However, the only useful operation defined on environments is eval. Reflective operations on first-class environments have been proposed in the language Rascal <ref> [41] </ref>. In this language, one can construct an environment with lexical and public bindings, reify the environment into a data structure, and subsequently reflect the data structure back into an environment. Only public bindings are visible when environments are reflected.
Reference: [42] <author> Johnson, R. E., and Russo, V. F. </author> <title> Reusing object-oriented designs. </title> <type> Tech. Rep. </type> <institution> UIUCDCS 91-1696, University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: In fact, the general concepts of compositional modularity can themselves be abstracted and expressed independent of the particular computational model of a base language. Such a generic model can then be expressed in an OO manner, constituting what is generally referred to as an object-oriented framework <ref> [42] </ref>. This approach was first suggested in Bracha's thesis [7], although no engineering strategies or implementation work was presented. <p> Furthermore, such a space of concepts can itself be specified using an OO language, thus constituting what is known as an OO framework. In essence, an OO framework is an OO model that captures the essential abstractions in a particular application domain <ref> [42] </ref>. It expresses the architecture of applications in the domain in terms of objects and interactions between them. Frameworks allow developers to build applications effectively by concretizing abstract classes in the framework via inheritance and by configuring, i.e., connecting instances of, predefined concrete classes in the framework.
Reference: [43] <author> Joy, W., Graham, S., Haley, C., McKusick, M. K., and Kessler, P. </author> <title> Berkeley Pascal user's manual. In UNIX Programmer's Manual, </title> <booktitle> vol. 1 of 4.3 BSD. USENIX Association, </booktitle> <institution> CSRG, University of California, Berkeley, </institution> <address> CA, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: However, our work differs from IDEs in that we provide a systemwide linkage facility that attempts to typecheck combined modules independent of language processors. Furthermore, the programmability of our linker enables "fine tuning" the compatibility of (possibly heterogeneous) object modules at link time. The Berkeley Pascal Compiler pc <ref> [43] </ref> is similar to our effort in that it employs debugging information to check type consistency across separately compiled modules.
Reference: [44] <author> Katiyar, D., Luckham, D., and Mitchell, J. </author> <title> A type system for proto-typing languages. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages (Portland, </booktitle> <address> OR, </address> <month> January </month> <year> 1994), </year> <booktitle> ACM, </booktitle> <pages> pp. 138-150. </pages>
Reference-contexts: However, DSEE was 131 primarily a CASE tool and did not take part in the execution phase of program development. The module language of OMOS is somewhat similar to architecture description languages, such as Rapide <ref> [44] </ref>, the POLYLITH Module Interconnection Language (MIL) [12, 66], and OMG's Interface Definition Language (IDL) [60]. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections. <p> These languages usually support some form (however weak) of specifying the interfaces of components, e.g., header files in C. However, many distributed systems, e.g., refs. <ref> [60, 4, 44] </ref>, support a separate IDL distinct from CPLs. Explicit interface descriptions are useful for various purposes: (1) Specification. To specify the contractual obligations between a service providing component and its clients, and to ascertain that they are met. <p> Several existing IDLs, e.g., refs. <ref> [60, 44] </ref>, support some form of interface inheritance. However, some IDLs, e.g., CORBAs IDL [60] described in Section 137 7.2, unnecessarily limit the expressiveness of their interface inheritance mechanism. <p> The notions of selftype and inherited types given here are taken from there. The type sublanguage of the Rapide <ref> [44] </ref> programming language framework supports much the same functionality that is given in this chapter.
Reference: [45] <author> Keene, S. E. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: In particular, static typing is not explored in Rascal. Also, compositional nesting, as given in the following chapter, is unique to CMS. A popular language family for OO programming with Lisp is the CLOS family of languages <ref> [45, 50] </ref>. CLOS supports a quite different model of OO programming from the one described here, with multiple-dispatch, generic functions, but much weaker encapsulation. CMS, on the other hand, supports only single dispatch. CLOS also supports a protocol to interact with its meta-architecture. <p> subclass hierarchy of Smalltalk is slightly more involved than what is described here, due to the desirability of symmetric class and metaclass hierarchies, but the given description will suffice for this discussion.) 5.5.2 CLOS The CLOS object system supports the standard concept of classes, which can be instantiated into instances <ref> [45] </ref>. Class attributes are called slots. A distinguishing feature of the CLOS model is the notion of generic functions which are defined independent of any class and can be specialized into methods that are applicable to specific classes. Generic functions can be dispatched based on multiple arguments (multimethods).
Reference: [46] <author> Kernighan, B. W., and Ritchie, D. M. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: As before, attributes match if they have the same name. There cannot be matching attributes within a single interface, and attributes that match across interfaces must be type compatible. This section describes the relevant type system of ANSI C (type domain and type equivalence) <ref> [46] </ref> and enhancements made to it for type-checking across compilation units (structural typing, and function subtyping).
Reference: [47] <author> Kiczales, G., des Rivi eres, J., and Bobrow, D. G. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: CLOS also supports a protocol to interact with its meta-architecture. Dexterity of multiple inheritance as given in Section 3.4.1 was a primary practical consideration in the design of the CLOS MOP. CMS must also be compared to the approach of open implementations. Meta-object protocols (MOPs) for CLOS <ref> [47] </ref> and C++ [20] expose the OO implementation of the language processor to the programmer, via a controlled protocol. Many aspects of the language's implementation, such as the mechanisms of inheritance, object data layout, and method dispatch, are controllable via such MOPs. <p> However, being a meta-architecture, Etyma enables the construction of reflective systems, and the design of suitable MOPs, and thus could potentially bring the advantages mentioned above. As points of comparison, we now briefly present two widely known language meta-architectures: Smalltalk-80 [32] and the Common Lisp Object System (CLOS) <ref> [47] </ref>. 5.5.1 Smalltalk Smalltalk is based on a uniform model of communicating objects. It has a small number of concepts | object, class, instance, message, and method. Every concept in the system is modeled as an object, either instantiable (class object) or not (instance object). <p> The above idea of single inheritance can be generalized to multiple inheritance as found in languages such as CLOS <ref> [47] </ref>. In these languages, the graph of superclasses of a class is linearized into a single inheritance hierarchy by a language provided mechanism.
Reference: [48] <author> Kiczales, G., and Lamping, J. </author> <title> Issues in the design and specification of class libraries. </title> <booktitle> In OOPSLA Proceedings (1992), ACM. </booktitle>
Reference-contexts: Moreover, once they are designed to be reusable, an appropriate method or "protocol" for effectively reusing the framework must be documented <ref> [48] </ref>. Some reuse techniques used in Etyma are given below. 5.4.1 Designing for Reuse The best known OO reuse mechanism is that of abstract base classes. Abstract classes are partially defined classes that specify the essential characteristics of an abstraction, so that concrete subclasses provide the incomplete parts. <p> In doing so, we have introduced a dependency between the project and restrict methods: every time a subclass redefines the restrict method, the project method must be appropriately redefined as well. Exposing such dependencies has been dubbed "consistent protocols" in the literature <ref> [48] </ref>. 5.4.3 Framework Evolution A fundamental phenomenon of OO framework construction is evolution over iterative reuse cycles. It is commonly said that the reusability of a framework increases over reuse iterations. Reuse begets reuse.
Reference: [49] <author> Kiczales, G., Lamping, J., and Mendhekar, A. </author> <title> What a metaobject protocol based compiler can do for Lisp. </title> <note> Unpublished report. A modified version presented at the OOPSLA '94 workshop on O-O Compilation [21], </note> <year> 1994. </year>
Reference-contexts: Compiler frameworks are designed with various objectives, such as for representing abstract syntax, constructing tools for programming environments, or for structuring the compiler itself, e.g., with objects representing phases of the compiler [32], or for enabling compile-time reflection via a meta-object protocol <ref> [49] </ref>. Etyma, although supporting many of the above, is unique in that it is intended to be a reusable architecture for constructing a variety of modular systems. As mentioned earlier, Etyma represents a meta-architecture for modular systems.
Reference: [50] <author> Kiczales, G., and Rodriguez, L. </author> <title> Efficient method dispatch in PCL. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (1990), ACM, </booktitle> <pages> pp. 99-105. </pages>
Reference-contexts: In particular, static typing is not explored in Rascal. Also, compositional nesting, as given in the following chapter, is unique to CMS. A popular language family for OO programming with Lisp is the CLOS family of languages <ref> [45, 50] </ref>. CLOS supports a quite different model of OO programming from the one described here, with multiple-dispatch, generic functions, but much weaker encapsulation. CMS, on the other hand, supports only single dispatch. CLOS also supports a protocol to interact with its meta-architecture.
Reference: [51] <author> Kristensen, B. B., Madsen, O. L., Moller-Pedersen, B., and Ny-gaard, K. </author> <title> The BETA programming language. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 7 - 48. 167 </pages>
Reference-contexts: It can be used for expressing other effects such as prefix-based inheritance, wrapping, and mixin combination, described later. We shall refer to this form as the copy-override-hide idiom. 3.2.2 Prefixing The programming language Beta <ref> [51] </ref> supports a form of single inheritance called prefixing, which is quite different from the single inheritance presented in Section 3.2.1. In prefixing, a superclass method that expects to be re-bound by a subclass definition uses a construct called inner somewhere in its body. <p> Examples are ML substructures [76], Scheme modules [25], and Beta subpatterns. However, one can only directly lexically nest modules in these systems; there is no notion of compositional nesting. The most experience with nested modules to date is with subpatterns supported by the Beta language <ref> [51, 55] </ref>. Nested patterns are idiomatically used in Beta for obtaining several effects, one of which is the mixin style of programming.
Reference: [52] <author> Lamping, J. </author> <title> Typing the specialization interface. </title> <booktitle> In Proceedings of OOPSLA '93, ACM SIGPLAN Notices (October 1993), </booktitle> <pages> pp. 201-214. </pages>
Reference-contexts: The introspective operations given above do not permit access to any aspect of 39 private attributes of modules. Being meta-level primitives, they do permit exposing some details of method implementations, such as self-references. However, it has been argued in the literature <ref> [52] </ref> that the self-reference dependencies of methods are indeed an aspect of their inheritance interface, rather than their implementation. 3.2 Single Inheritance From the programmer's point of view, it is necessary to know not only the available constructs in a language but also the intent and usefulness of the constructs.
Reference: [53] <author> Lamport, L. </author> <title> L a T E X, a Document Processing System. </title> <publisher> Addison Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: As mentioned earlier, the model of compositional modularity can be layered on top of a variety of computational sublanguages. The MT E X system presented in this chapter is built on top of a restricted version of the L a T E X document preparation system <ref> [53] </ref>. L a T E X is a typesetting program that takes in an ASCII text file annotated with typesetting commands (such as "section and "ref) and produces a high quality document as a device independent (dvi) file.
Reference: [54] <author> Luckham, D., and Vera, J. </author> <title> Event-based concepts and language for system architecture. Available from Stanford Program Analysis and Verification Group, </title> <month> March </month> <year> 1993. </year>
Reference-contexts: Nonetheless, formal and machine-processable descriptions are becoming necessary and widespread, especially in the context of distributed systems. An architecture aims to describe the components of a system and their relationships, such as "is-a," "has-a," and "communicates-with." These properties are usually described via architecture description languages (ADLs) <ref> [54, 1] </ref> of varying 135 degrees of expressive power. A description of the conventional typed interfaces of components is a simple example of an architecture description.
Reference: [55] <author> Madsen, O. L. </author> <title> Block structure and object-oriented languages. </title> <booktitle> In Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987, </year> <pages> pp. 113 - 128. </pages>
Reference-contexts: Examples are ML substructures [76], Scheme modules [25], and Beta subpatterns. However, one can only directly lexically nest modules in these systems; there is no notion of compositional nesting. The most experience with nested modules to date is with subpatterns supported by the Beta language <ref> [51, 55] </ref>. Nested patterns are idiomatically used in Beta for obtaining several effects, one of which is the mixin style of programming. <p> We develop a denotational semantic formulation of nested modules as closed-generators that meets the above goal. An important point of this chapter is that block structure is not orthogonal to modularity. Madsen <ref> [55] </ref> has argued that block structure is not a mechanism for programming in the large and that a language must contain other facilities for modularizing a program into smaller parts.
Reference: [56] <author> Menapace, J., Kingdon, J., and MacKenzie, D. </author> <title> The "stabs" debug format. Free Software Foundation, Inc. Contributed by Cygnus Support, </title> <year> 1993. </year>
Reference-contexts: To solve this, we modified the back end of gcc to generate debugging information for all symbols. For accessing the sections of the object file that contain debugging information (.stab and .stabstr), we again use the BFD library and parse the "stabs" format debug strings <ref> [56] </ref> using a yacc/lex generated parser. The parser instantiates the appropriate subclasses of Etyma classes to create the interface of the object module. For instance, the subclass CPrimType of the framework class PrimType implements the partial order of primitive types introduced before.
Reference: [57] <author> Meyer, B. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: The primitive defined? can actually be implemented in terms of attrs-of. The module from which an instance was created can be obtained with the primitive module-of. Thus, (module-of (self)) is similar to self class in Smalltalk, like current in Eiffel <ref> [57] </ref> and myclass given in Canning et al. [14]. It is sometimes useful to know the names of public attributes that are self-referenced within a method. The primitive self-refs-in returns a flat list comprising the set of all the self-referenced public attributes within the bindings of the given attribute names.
Reference: [58] <author> Meyer, B. </author> <title> Eiffel, the environment, </title> <month> August </month> <year> 1989. </year>
Reference-contexts: On the other hand, our research has focussed on layered evolutionary support. 6.6.2 Type Safety Integrated Development Environments (IDEs) for strongly typed languages, e.g., Eiffel <ref> [58] </ref>, utilize mechanisms for type-checking separately compiled modules, since they have complete knowledge and control over source and object modules. However, our work differs from IDEs in that we provide a systemwide linkage facility that attempts to typecheck combined modules independent of language processors.
Reference: [59] <author> Nelson, E. G. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX [72] and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems <ref> [39, 59, 76, 25, 67] </ref>. This is known to support large-scale programming, since clients can be written (and compiled) based on a module's interface. The module's implementors can then associate (possibly multiple) im 52 plementations with the interface. The CMS language presented here does not explicitly support interfaces. <p> Name-based typing of interfaces can be supported by creating a concrete subclass that inherits from classes Interface and NamedType and inheriting the eq and le methods from NamedType. Such an interface is referred to as a "branded" interface <ref> [59] </ref>. Again, the le method may take into account explicit specification of subtyping relationships between branded interfaces. Class RecordType represents the type of records [36], as well as the type of instances. It supports template methods for typechecking individual record operations, including select. <p> This argues for structural matching of aggregate types similar to Modula-3 <ref> [59] </ref>, using member order and type significance along with names. 6.4.2 A Scenario As before, an ANSI C program source or object file is considered a module consisting of a set of attributes with no order significance.
Reference: [60] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <month> December </month> <year> 1991. </year> <note> Revision 1.1. </note>
Reference-contexts: A compiler front-end to an experimental compositional interface definition language, derived as a direct completion of Etyma, is presented in Chapter 7. Also, an outline of how to extend a base language such as CORBA's IDL <ref> [60] </ref> is given there. Finally, a compositionally modular document processing system, called MT E X, layered on top of the L a T E X document preparation language is presented in Chapter 8. <p> The module language of OMOS is somewhat similar to architecture description languages, such as Rapide [44], the POLYLITH Module Interconnection Language (MIL) [12, 66], and OMG's Interface Definition Language (IDL) <ref> [60] </ref>. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections. Our approach offers the important advantage that OO like program adaptation and reuse techniques (inheritance, in all its meanings) can be applied to legacy components written in non-OO languages. <p> These languages usually support some form (however weak) of specifying the interfaces of components, e.g., header files in C. However, many distributed systems, e.g., refs. <ref> [60, 4, 44] </ref>, support a separate IDL distinct from CPLs. Explicit interface descriptions are useful for various purposes: (1) Specification. To specify the contractual obligations between a service providing component and its clients, and to ascertain that they are met. <p> Several existing IDLs, e.g., refs. <ref> [60, 44] </ref>, support some form of interface inheritance. However, some IDLs, e.g., CORBAs IDL [60] described in Section 137 7.2, unnecessarily limit the expressiveness of their interface inheritance mechanism. <p> Several existing IDLs, e.g., refs. [60, 44], support some form of interface inheritance. However, some IDLs, e.g., CORBAs IDL <ref> [60] </ref> described in Section 137 7.2, unnecessarily limit the expressiveness of their interface inheritance mechanism. Thus, support for compositionality of interfaces can prove to be useful, especially since it can be layered on top of existing IDLs, including those that do not already support inheritance. <p> Design and code reuse numbers for this completion are given in Table 7.1. 7.2 Making CORBAs IDL Compositional As an illustration of how an existing IDL can be enhanced with compositional concepts, we present an extension of the IDL specified as part of the Common Object Request Broker Architecture (CORBA) <ref> [60] </ref> in this section. With CORBA IDL, one can specify interfaces comprising data attributes (constant or variable) and operations (functions), as well as type definitions and exceptions.
Reference: [61] <author> Orr, D., Bonn, J., Lepreau, J., and Mecklenburg, R. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proc. USENIX Summer Conference (Cincinnati, </booktitle> <month> June </month> <year> 1993), </year> <pages> pp. 237-251. </pages>
Reference-contexts: For example, system services (such as libraries) can be abstracted over their actual implementations, adding a level of indirection between a service and its actual implementation. This permits optimizations of the service implementation based on clients' disclosed behavioral characteristics. Such system-level support is explored in several studies <ref> [61, 64, 62] </ref> and is summarized in Section 6.2.3. However, for the most part, this chapter focuses on application level support. Indeed, much of this chapter is based on work performed by Douglas Orr and others on OMOS, the Object Meta-Object Server [63]. <p> The details of this mechanism can be found in ref. [62]. Since OMOS loads programs into client address spaces, it can be used as the basis for system program execution and shared libraries <ref> [61] </ref>, as well as dynamic loading of modules. OMOS module specs have also been used to implement program monitoring and reordering [64]. Since OMOS is an active entity (a server), it is capable of performing sophisticated module manipulations on each instantiation of a module. <p> As a result, OMOS caches module results in order to avoid re-doing unnecessary work. Combining a caching linker with the system object loader gives OMOS the flexibility to change implementations as it deems necessary, e.g., to reflect an updated implementation of a shared module across all its clients <ref> [61] </ref>. Backward compatibility is a crucial issue to be addressed in the context of the architecture presented here.
Reference: [62] <author> Orr, D. B. </author> <title> Application of meta-protocols to improve OS services. </title> <booktitle> In HOTOS-V: Fifth Workshop on Hot Topics in Operating Systems (May 1995). </booktitle>
Reference-contexts: For example, system services (such as libraries) can be abstracted over their actual implementations, adding a level of indirection between a service and its actual implementation. This permits optimizations of the service implementation based on clients' disclosed behavioral characteristics. Such system-level support is explored in several studies <ref> [61, 64, 62] </ref> and is summarized in Section 6.2.3. However, for the most part, this chapter focuses on application level support. Indeed, much of this chapter is based on work performed by Douglas Orr and others on OMOS, the Object Meta-Object Server [63]. <p> This mechanism, in effect, provides a level of indirection between a system service and its actual implementation, thus permitting optimizations of the service implementation based on clients' disclosed behavioral characteristics. The details of this mechanism can be found in ref. <ref> [62] </ref>. Since OMOS loads programs into client address spaces, it can be used as the basis for system program execution and shared libraries [61], as well as dynamic loading of modules. OMOS module specs have also been used to implement program monitoring and reordering [64].
Reference: [63] <author> Orr, D. B., and Mecklenburg, R. W. </author> <title> OMOS | An object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems (Paris, </booktitle> <month> September </month> <year> 1992), </year> <journal> IEEE Computer Society, </journal> <pages> pp. 200-209. </pages> <note> Also available as technical report UUCS-92-033. </note>
Reference-contexts: However, for the most part, this chapter focuses on application level support. Indeed, much of this chapter is based on work performed by Douglas Orr and others on OMOS, the Object Meta-Object Server <ref> [63] </ref>. OMOS was primarily conceived as an "object server" | a server process that generates implementations of programs based on user and system requirements. <p> Finally, it must be continually available. For these reasons, the logical module layer in the prototype described here is managed by a server process | a second generation implementation of a server named OMOS <ref> [63] </ref>. The module manipulation language supported by OMOS is derived from the programming language Scheme [22] and is similar in flavor to CMS. The most important distinction, of course, is that its notion of modules is that of object files. Modules are created by reading in physical object files. <p> This is the system that manages the logical layer, OMOS <ref> [63] </ref>. The term "meta-object" was originally intended to be indicative of the intensional nature of module specs and the fact that module specs are really programs that generate other programs. However this name should be considered historical and will not be further justified here. <p> Nevertheless, the design of OMOS closely follows the class design of Etyma. Moreover, concepts of compositional modularity first developed with respect to Etyma and CMS were directly reused in the context of OMOS. The first generation implementation of OMOS <ref> [63] </ref> existed much before Etyma was born. Later in its lifecycle, OMOS was reengineered to incorporate several major design enhancements. During this, its "upper" class hierarchy was made to follow the Etyma class design.
Reference: [64] <author> Orr, D. B., Mecklenburg, R. W., Hoogenboom, P. J., and Lep-reau, J. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. In The Interaction of Compilation Technology and Computer Architecture. </title> <publisher> Kluwer Academic Publishers, </publisher> <month> February </month> <year> 1994. </year>
Reference-contexts: For example, system services (such as libraries) can be abstracted over their actual implementations, adding a level of indirection between a service and its actual implementation. This permits optimizations of the service implementation based on clients' disclosed behavioral characteristics. Such system-level support is explored in several studies <ref> [61, 64, 62] </ref> and is summarized in Section 6.2.3. However, for the most part, this chapter focuses on application level support. Indeed, much of this chapter is based on work performed by Douglas Orr and others on OMOS, the Object Meta-Object Server [63]. <p> Since OMOS loads programs into client address spaces, it can be used as the basis for system program execution and shared libraries [61], as well as dynamic loading of modules. OMOS module specs have also been used to implement program monitoring and reordering <ref> [64] </ref>. Since OMOS is an active entity (a server), it is capable of performing sophisticated module manipulations on each instantiation of a module. Evaluation of a module expression will often produce the same results each time. As a result, OMOS caches module results in order to avoid re-doing unnecessary work.
Reference: [65] <author> Ossher, H., and Harrison, W. </author> <title> Combination of inheritance hierarchies. </title> <booktitle> In OOPSLA Proceedings (October 1992), </booktitle> <pages> pp. 25-40. </pages>
Reference-contexts: Note the use of merge in the above expression (as opposed to override) since we want to disallow conflicts. Effects similar to the above were first given by Ossher and Harrison <ref> [65] </ref>.
Reference: [66] <author> Purtilo, J. M. </author> <title> The POLYLITH software bus. </title> <journal> ACM Transactions on Programming Languages and Systems 16, </journal> <month> 1 (January </month> <year> 1994), </year> <pages> 151-174. </pages>
Reference-contexts: However, DSEE was 131 primarily a CASE tool and did not take part in the execution phase of program development. The module language of OMOS is somewhat similar to architecture description languages, such as Rapide [44], the POLYLITH Module Interconnection Language (MIL) <ref> [12, 66] </ref>, and OMG's Interface Definition Language (IDL) [60]. These languages all share the characteristic that they support the flexible specification of high-level components and interconnections.
Reference: [67] <author> Rees, J. </author> <title> Another module system for Scheme. Included in the Scheme 48 168 distribution, </title> <year> 1993. </year>
Reference-contexts: Procedures may contain references to other name bindings within the module. In this manner, a Scheme module may be modeled as a self-referential namespace. Several module systems for Scheme have been proposed previously <ref> [25, 77, 67] </ref>, but these systems mainly provide a facility for structuring programs via decomposition. However, the ability to recompose first-class modules can additionally support design and implementation reuse akin to inheritance in OO programming. <p> There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX [72] and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems <ref> [39, 59, 76, 25, 67] </ref>. This is known to support large-scale programming, since clients can be written (and compiled) based on a module's interface. The module's implementors can then associate (possibly multiple) im 52 plementations with the interface. The CMS language presented here does not explicitly support interfaces. <p> These systems do not support composition and, in effect, provide little more than the functionality described in Sections 3.1.1 and 3.1.2. Lisp packages [73] are namespaces that map strings to symbols. Symbols exported from one package may be imported by another. The Scheme 48 module system <ref> [67] </ref> is a more sophisticated namespace manipulation mechanism, in that it supports multiple instantiation of modules into packages, as well as explicit interfaces. However, there are no mechanisms for composition or adaptation in either of the above systems. Some Scheme implementations support first-class environments.
Reference: [68] <author> Rossberg, W., Smith, E., and Matinkhah, A. </author> <title> Structured text system. </title> <type> US Patent Number 5,341,469, </type> <month> August </month> <year> 1994. </year>
Reference-contexts: In fact, specialized document processing systems for architectural activities have been devised <ref> [68] </ref>. Typically, a building architect obtains several large textbases of materials specifications, which we shall call MasterSpecs, from a MasterSpec developer. The architect then carefully extracts those parts of the various MasterSpecs that are pertinent to the project in hand.
Reference: [69] <author> Sabatella, M. </author> <title> Issues in shared libraries design. </title> <booktitle> In Proc. of the Summer 1990 USENIX Conference (Anaheim, </booktitle> <address> CA, </address> <month> June </month> <year> 1990), </year> <pages> pp. 11-24. </pages>
Reference-contexts: Typically, some notion of hiding is supported. However, it is novel to support an expressive suite of combination operators and the ability to use a full-featured programming language to compose object modules. From the systems point of view, a user-space loader such as OMOS is considered no longer unusual <ref> [69, 31] </ref>. Also, OMOS has some similarity to utilities such as dld [38] that aid programmers in the dynamic loading of code and data. Finally, the Apollo DSEE [3] system was a server-based system which managed sources and objects, taking advantage of caching to avoid recompilation.
Reference: [70] <author> Sankar, S., and Hayes, R. </author> <title> ADL | an interface definition language for specifying and testing software. </title> <booktitle> In Proc. of Workshop on Interface Definition Languages (January 1994), </booktitle> <editor> J. Wing, </editor> <publisher> Ed., </publisher> <pages> pp. </pages> <note> 13 - 21. Available as August 1994 issue of ACM SIGPLAN Notices. </note>
Reference-contexts: module as long as the interface, which is the module's contract with its clients, is not changed. (The expressiveness of the interface to satisfactorily state the contract is a crucial issue; present-day techniques typically employ some notion of type specification to express the contract, although more expressive mechanisms, e.g., ref. <ref> [70] </ref>, are being studied.) The mechanism of inheritance supports incremental programming. That is, a programmer can specify a module by stating how its implementation differs from that of an existing module. As a result, inheritance is a primary implementation reuse mechanism in OO programming. <p> Explicit interface descriptions are useful for various purposes: (1) Specification. To specify the contractual obligations between a service providing component and its clients, and to ascertain that they are met. Minimally, IDLs employ conventional programming language types for the specification of interfaces, although some IDLs, e.g., ref. <ref> [70] </ref>, support much stronger forms of behavior specification than others. (2) Interoperability. As an intermediate language to facilitate interoperability among components in heterogeneous, e.g., hardware or programming language, environments. There are usually several "language mappings" from an IDL to individual CPLs, or vice versa (see below). (3) Implementation.
Reference: [71] <author> Seeley, D. </author> <title> Shared libraries as objects. </title> <booktitle> In Proc. USENIX Summer Conference (Anaheim, </booktitle> <address> CA, </address> <month> June </month> <year> 1990). </year>
Reference-contexts: A discussion of the disadvantages of header files used in the traditional manner is found below in Section 6.6. 6.6 Related Work This work is in essence a general and concrete realization of a vision due to Donn Seeley <ref> [71] </ref>. 6.6.1 OMOS Traditionally linkers support little control over name conflicts and the semantics of combination. As mentioned earlier, traditional linking essentially amounts to what is supported by merge. Although programmable linkers exist, they do not offer the generality and flexibility of our system.
Reference: [72] <author> Sheldon, M. A. </author> <title> Static dependent types for first class modules. </title> <booktitle> In ACM Conference on Lisp and Functional Programming (June 1990). </booktitle>
Reference-contexts: Furthermore, module systems facilitate the manipulation of namespaces. Given that namespaces exist as environments at run-time, it seems natural to support modules themselves as first-class entities. Additionally, this results in uniformity 16 of manipulable values. Languages such as Pebble [11], Rascal [40, 41], and others <ref> [72] </ref> support first-class modules. (It is worth mentioning that support for higher-order modules does not necessarily mean that modules are first-class. For instance, a higher-order SML module system such as in ref. [35] might support functors with functor parameters, or higher-order modules. <p> An early effort to incorporate first-class modules into a language was in Pebble [11]. There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX <ref> [72] </ref> and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems [39, 59, 76, 25, 67]. This is known to support large-scale programming, since clients can be written (and compiled) based on a module's interface.
Reference: [73] <author> Steele Jr., G. L. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1984. </year>
Reference-contexts: Tung's [77] system additionally supports a notion of renaming conflicting imports, as well as dynamic binding of imported attributes. These systems do not support composition and, in effect, provide little more than the functionality described in Sections 3.1.1 and 3.1.2. Lisp packages <ref> [73] </ref> are namespaces that map strings to symbols. Symbols exported from one package may be imported by another. The Scheme 48 module system [67] is a more sophisticated namespace manipulation mechanism, in that it supports multiple instantiation of modules into packages, as well as explicit interfaces.
Reference: [74] <author> Stroustrup, B. </author> <title> Type-safe linkage for C++. </title> <booktitle> In USENIX C++ Conference (1988). </booktitle>
Reference-contexts: With the objective of enabling type-safe linkage within the constraints of existing linkers, Stroustrup <ref> [74, 28] </ref> describes a mechanism for encoding functions with the types of input arguments.
Reference: [75] <author> Thatte, S. R. </author> <title> Automated synthesis of interface adapters for reusable classes. </title> <booktitle> In Symposium on Principles of Programming Languages (January, </booktitle> <year> 1994). </year>
Reference-contexts: There is a plethora of literature related to stub generation <ref> [6, 5, 75] </ref>. The Polygen system [12] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [76] <author> Tofte, M. </author> <title> Four Lectures on Standard ML. </title> <type> LFCS Report Series, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: An example of such modules is the structure construct of Standard ML (a generalized "record" with type, value, and structure components), whose public interface is given by a signature <ref> [76] </ref>. To enforce stronger separation between modules, some systems require that all interactions between modules be declared explicitly, by importing names used from the interfaces of other modules. Examples of such module systems are those of the Modula family [15] and the Scheme module system given in ref. [25]. <p> However, such complete specification does not facilitate reuse of portions of the module that could potentially be common to several modules. To support reuse better, modules can be parameterized with the (free) names used within the module, as in SML functors <ref> [76] </ref> and ADA generic packages [39]. A parameterized module can be multiply instantiated (usually before run-time) with actual argument values to produce concrete modules, which are then used in the same manner as completely specified modules. <p> In this section, its relationship to various other module models is given. Most classical module systems such as SML <ref> [76] </ref>, and Ada [39] do not support first-class modules. Some ML systems [35], however, do support higher-order functors, although not as first-class run-time values. Also, these module systems closely associate a static type system with the module system. <p> There, the uniformity and expressive power obtained by using first-class modules were recognized. More recently, many other languages such as FX [72] and Rascal also support first-class modules. Support for explicit interfaces separate from implementations is a frequent feature of module systems <ref> [39, 59, 76, 25, 67] </ref>. This is known to support large-scale programming, since clients can be written (and compiled) based on a module's interface. The module's implementors can then associate (possibly multiple) im 52 plementations with the interface. The CMS language presented here does not explicitly support interfaces. <p> This is equivalent to the conventional semantics of nested functions in most languages. Examples are ML substructures <ref> [76] </ref>, Scheme modules [25], and Beta subpatterns. However, one can only directly lexically nest modules in these systems; there is no notion of compositional nesting. The most experience with nested modules to date is with subpatterns supported by the Beta language [51, 55].
Reference: [77] <author> Tung, S.-H. S. </author> <title> Interactive modular programming in Scheme. </title> <booktitle> In Proceedings of the ACM Lisp and Functional Programming Conference (1992), ACM, </booktitle> <pages> pp. pages 86 - 95. </pages>
Reference-contexts: Procedures may contain references to other name bindings within the module. In this manner, a Scheme module may be modeled as a self-referential namespace. Several module systems for Scheme have been proposed previously <ref> [25, 77, 67] </ref>, but these systems mainly provide a facility for structuring programs via decomposition. However, the ability to recompose first-class modules can additionally support design and implementation reuse akin to inheritance in OO programming. <p> Typically, such systems perform some level of static conformance checking (at compile time) and binding (at link time) between the imports and exports of modules. However, completely dynamic importation has also been proposed <ref> [77] </ref>. One way to specify modules is to describe each of them completely from scratch. However, such complete specification does not facilitate reuse of portions of the module that could potentially be common to several modules. <p> In fact, the most one can do in these systems by way of module manipulation is to instantiate a parameterized module. Clearly, more flexible and expressive module systems are needed. A step in this direction was taken by Tung <ref> [77] </ref>, by supporting a simple notion of renaming imported names that conflict with those defined in a module. <p> Subsequently, implementations for this interface can be combined with it via override and private attributes encapsulated via hide. Several module systems have been developed for the Scheme programming language. Curtis and Rauen's system [25] supports explicit interfaces and modules with import and export specifications. Tung's <ref> [77] </ref> system additionally supports a notion of renaming conflicting imports, as well as dynamic binding of imported attributes. These systems do not support composition and, in effect, provide little more than the functionality described in Sections 3.1.1 and 3.1.2. Lisp packages [73] are namespaces that map strings to symbols.
Reference: [78] <author> Vlissides, J. M., and Linton, M. A. Unidraw: </author> <title> a framework for building domain-specific graphical editors. </title> <booktitle> In Proceedings of the ACM User Interface Software and Technologies '89 Conference (November 1989), </booktitle> <pages> pp. 81-94. </pages>
Reference-contexts: For all three iterations, both design and code reuse were found to be significant, between 73.3% and 91.7%. 5.5 Related Work Several OO frameworks have been developed, initially for user interfaces and subsequently for many other domains as well <ref> [26, 78, 79, 13] </ref>. Etyma bears a close relationship to compiler frameworks [21], which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into 95 two categories: those that represent programs syntactically such as Sage++ [80] and those that represent programs semantically, such as ours.
Reference: [79] <author> Weinand, A., Gamma, E., and Marty, R. ET++: </author> <title> an object-oriented application framework in C++. </title> <booktitle> In Proceedings of OOPSLA '88 (November 1988), ACM, </booktitle> <pages> pp. 46-57. </pages>
Reference-contexts: For all three iterations, both design and code reuse were found to be significant, between 73.3% and 91.7%. 5.5 Related Work Several OO frameworks have been developed, initially for user interfaces and subsequently for many other domains as well <ref> [26, 78, 79, 13] </ref>. Etyma bears a close relationship to compiler frameworks [21], which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into 95 two categories: those that represent programs syntactically such as Sage++ [80] and those that represent programs semantically, such as ours.
Reference: [80] <author> Winnicka, B., Bodin, F., and Gannon, D. </author> <title> C++ objects for representing and manipulating program trees in the Sage++ system. </title> <booktitle> Presented at the O-O Compilation Workshop at OOPSLA, </booktitle> <month> October </month> <year> 1994. </year> <note> See [21]. </note>
Reference-contexts: Etyma bears a close relationship to compiler frameworks [21], which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into 95 two categories: those that represent programs syntactically such as Sage++ <ref> [80] </ref> and those that represent programs semantically, such as ours.
References-found: 80

