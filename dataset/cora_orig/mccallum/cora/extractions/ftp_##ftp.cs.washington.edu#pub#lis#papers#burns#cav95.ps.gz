URL: ftp://ftp.cs.washington.edu/pub/lis/papers/burns/cav95.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/burns/professional/pubs.html
Root-URL: http://www.cs.washington.edu
Email: E-mail: fhenrik,burnsg@cs.washington.edu  
Title: Efficient Timing Analysis of a Class of Petri Nets  
Author: Henrik Hulgaard and Steven M. Burns 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: We describe an algebraic technique for performing timing analysis on a restricted class of Petri nets with interval time delays specified on the places of the net. The timing analysis we perform determines the extreme separation in time between specified occurrences of pairs of transitions for all possible timed executions of the system. We present the details of the timing analysis algorithm and demonstrate polynomial running time on a non-trivial parameterized example. Petri nets with 3000 nodes and 10 16 reachable states have been analyzed using these techniques. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Alur and D. L. Dill. </author> <title> The theory of timed automata. </title> <editor> In J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rosenberg, editors, </editor> <booktitle> Real-Time: Theory in Practice, </booktitle> <volume> LNCS #600, </volume> <pages> pages 28-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: VLSI CAD, and operations research. Timed automata <ref> [1] </ref> is one of the more powerful models for which automated verification methods exists. A timed automaton has a number of clocks (timers) whose values can be used in guards of the transitions of the automaton. <p> Fig. 2 and the two terminal processes in Fig. 3: 3 v 0 3 v 0 3 v 0 3 v 0 T 1 For this example, [v 0 ] 0 = [ T1 ] j [ T2 ] and for all k 1 : [v 0 ] k = <ref> [ 1 ] </ref> fi ([ 2 ] j [ 3 ]) fi [v 0 ] k1 . Whenever the node v 0 is reached in the k th unfolding, [v 0 ] k represents the maximum separation for all executions represented by that unfolding, denoted k . <p> Each [f; m] pair is computed in backward topological order of b. For each place s, the pair [f 0 ; m 0 ] at s is determined by: [f 0 ; m 0 ] = &lt; <ref> [0; 1] </ref> if s* = ; where [f; m] is the pair stored at t 2 s*. <p> This dependency is encoded by a vector u of length n. The vector product u 0 m computes the shortest path to the internal node where u is stored. For example, in the process segment 1 of Fig. 2 with all delay ranges set to <ref> [1; 2] </ref>, we get the two matrices F = @ fh4; ( 0 0 1 )ig fh2; ( 0 0 1 )ig 0 1 0 2 1 1 1 1 0 A : Given a process segment , we denote the corresponding function and m-value matrices by F () and M <p> The algebraic element [] is then defined as the singleton set f [F (); M ()]g. We can now define the two operators fi and j. The choice operator is defined as set union: <ref> [ 1 ] </ref> j [ 2 ] = [ 1 ] [ [ 2 ] : The composition operator is more complex. When composing two segments 1 and 2 , the functions in 1 need to refer to the m-values in 2 * rather than those at 1 *. <p> The algebraic element [] is then defined as the singleton set f [F (); M ()]g. We can now define the two operators fi and j. The choice operator is defined as set union: <ref> [ 1 ] </ref> j [ 2 ] = [ 1 ] [ [ 2 ] : The composition operator is more complex. When composing two segments 1 and 2 , the functions in 1 need to refer to the m-values in 2 * rather than those at 1 *. <p> We introduce an upper bound operator, r, with the property that <ref> [ 1 ] </ref> fi [ 2 ] n fi [ 3 ] [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. <p> We introduce an upper bound operator, r, with the property that <ref> [ 1 ] </ref> fi [ 2 ] n fi [ 3 ] [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. By applying this lemma, the cycle p 2 is removed from path p. <p> Table 1 and Fig. 5 shows execution times of the CTSE algorithm for these two separation analyses on eager stacks of various sizes where all delay ranges are set to <ref> [1; 2] </ref>. Table 1. Execution times of the CTSE algorithm on eager stacks of various sizes, n. All delay ranges are [1; 2]. <p> 1 and Fig. 5 shows execution times of the CTSE algorithm for these two separation analyses on eager stacks of various sizes where all delay ranges are set to <ref> [1; 2] </ref>. Table 1. Execution times of the CTSE algorithm on eager stacks of various sizes, n. All delay ranges are [1; 2]. The size of the specification, i.e., number of places, number of transitions, and the size of the flow relation, is given by jS j, jT j, and jF j, respectively.
Reference: 2. <author> F. Baccelli, G. Cohen, G. J. Olsder, and J.-P. Quadrat. </author> <title> Synchronization and Linearity. </title> <publisher> John Wiley and Sons, </publisher> <year> 1992. </year>
Reference-contexts: Related work in timing analysis and verification of concurrent systems comes from a variety of different research communities including: real-time systems, ? This work is supported by an NSF YI Award <ref> (MIP-9257987) </ref> and by the DARPA/CSTO Microsystems Program under an ONR monitored contract (N00014 91-J-4041). VLSI CAD, and operations research. Timed automata [1] is one of the more powerful models for which automated verification methods exists. <p> This dependency is encoded by a vector u of length n. The vector product u 0 m computes the shortest path to the internal node where u is stored. For example, in the process segment 1 of Fig. 2 with all delay ranges set to <ref> [1; 2] </ref>, we get the two matrices F = @ fh4; ( 0 0 1 )ig fh2; ( 0 0 1 )ig 0 1 0 2 1 1 1 1 0 A : Given a process segment , we denote the corresponding function and m-value matrices by F () and M <p> The algebraic element [] is then defined as the singleton set f [F (); M ()]g. We can now define the two operators fi and j. The choice operator is defined as set union: [ 1 ] j <ref> [ 2 ] </ref> = [ 1 ] [ [ 2 ] : The composition operator is more complex. When composing two segments 1 and 2 , the functions in 1 need to refer to the m-values in 2 * rather than those at 1 *. <p> The algebraic element [] is then defined as the singleton set f [F (); M ()]g. We can now define the two operators fi and j. The choice operator is defined as set union: [ 1 ] j <ref> [ 2 ] </ref> = [ 1 ] [ [ 2 ] : The composition operator is more complex. When composing two segments 1 and 2 , the functions in 1 need to refer to the m-values in 2 * rather than those at 1 *. <p> We introduce an upper bound operator, r, with the property that [ 1 ] fi <ref> [ 2 ] </ref> n fi [ 3 ] [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. <p> We introduce an upper bound operator, r, with the property that [ 1 ] fi <ref> [ 2 ] </ref> n fi [ 3 ] [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. By applying this lemma, the cycle p 2 is removed from path p. <p> Table 1 and Fig. 5 shows execution times of the CTSE algorithm for these two separation analyses on eager stacks of various sizes where all delay ranges are set to <ref> [1; 2] </ref>. Table 1. Execution times of the CTSE algorithm on eager stacks of various sizes, n. All delay ranges are [1; 2]. <p> 1 and Fig. 5 shows execution times of the CTSE algorithm for these two separation analyses on eager stacks of various sizes where all delay ranges are set to <ref> [1; 2] </ref>. Table 1. Execution times of the CTSE algorithm on eager stacks of various sizes, n. All delay ranges are [1; 2]. The size of the specification, i.e., number of places, number of transitions, and the size of the flow relation, is given by jS j, jT j, and jF j, respectively.
Reference: 3. <author> B. Berthomieu and M. Diaz. </author> <title> Modeling and verification of time dependent systems using time Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 259-273, </pages> <year> 1991. </year>
Reference-contexts: Orbits is based on a Petri net model augmented with timing information. Other approaches that fall in this category include Timed Petri net [15] and Time Petri nets <ref> [3] </ref>. In Timed Petri nets a fixed delay is associated with each transitions while Time Petri nets use a more general model with delay ranges associated with the transitions. 2 Specifications We use safe Petri nets to model concurrent systems. <p> Fig. 3: 3 v 0 3 v 0 3 v 0 3 v 0 T 1 For this example, [v 0 ] 0 = [ T1 ] j [ T2 ] and for all k 1 : [v 0 ] k = [ 1 ] fi ([ 2 ] j <ref> [ 3 ] </ref>) fi [v 0 ] k1 . Whenever the node v 0 is reached in the k th unfolding, [v 0 ] k represents the maximum separation for all executions represented by that unfolding, denoted k . <p> We introduce an upper bound operator, r, with the property that [ 1 ] fi [ 2 ] n fi <ref> [ 3 ] </ref> [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. By applying this lemma, the cycle p 2 is removed from path p. <p> We introduce an upper bound operator, r, with the property that [ 1 ] fi [ 2 ] n fi <ref> [ 3 ] </ref> [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. By applying this lemma, the cycle p 2 is removed from path p. <p> We introduce an upper bound operator, r, with the property that [ 1 ] fi [ 2 ] n fi <ref> [ 3 ] </ref> [ 1 ] fi [ 3 ] j (r [ 2 ]) fi [ 3 ] ; where i = (p i ) for i = 1; 2; 3 and n 1. By applying this lemma, the cycle p 2 is removed from path p.
Reference: 4. <author> E. Best and J. Desel. </author> <title> Partial order behavior and structure of Petri nets. </title> <journal> Formal Aspects of Computing, </journal> <volume> 2 </volume> <pages> 123-138, </pages> <year> 1990. </year>
Reference-contexts: Petri net is a net N and a labeling lab : S [ T ! S [ T . (We subscript S, T , and F to distinguish between the nets of and .) N and lab must satisfy appropriate properties such that can be interpreted as an execution of <ref> [4, 18] </ref>. Intuitively, the process = (N; lab) is an unfolding of where all choice has been resolved, i.e., N is acyclic and choice free. Fig. 1 (b) shows a process for the Petri net in Fig. 1 (a). <p> However, a safe Petri net has only a finite number of reachable markings. Processes have the property that any cut of places corresponds to a reachable marking of <ref> [4, Lemma 2.7] </ref>. Therefore, sufficiently long processes will contain repeated segments of processes. We represent the infinite set of processes () by a finite graph we call the process automaton. The vertices of the process automaton correspond to markings of and the edges are annotated with segments of processes.
Reference: 5. <author> E. Best and Raymond Devillers. </author> <title> Interleaving and partial orders in concurrency: A formal comparison. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Formal Description of Programming Concepts-III, </booktitle> <pages> pages 299-323, </pages> <year> 1986. </year>
Reference-contexts: We can construct the process automaton without first constructing the reach-ability graph <ref> [5, 9] </ref>. If there is no concurrency in the net, the size of the process automaton is equal to the size of the reachability graph. However, if there is a high degree of concurrency, the process automaton will be considerably smaller.
Reference: 6. <author> J. R. Burch. </author> <title> Trace Algebra for Automatic Verification of Real-Time Concurrent Systems. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: Furthermore, the verification time is proportional to the product of the maximum value of the clocks and also proportional to the number of permutations of the clocks. To improve the run-time complexity, Burch <ref> [6] </ref> extends trace theory with discrete time but still uses automata-based methods for verification. This approach also suffers from exponential runtime in the size of the delay values but avoids the factorial associated with the permutations of the clocks.
Reference: 7. <author> C. Courcoubetis and M. Yannakakis. </author> <title> Minimum and maximum delay problems in real-time systems. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 385-415, </pages> <year> 1992. </year>
Reference-contexts: Related work in timing analysis and verification of concurrent systems comes from a variety of different research communities including: real-time systems, ? This work is supported by an NSF YI Award <ref> (MIP-9257987) </ref> and by the DARPA/CSTO Microsystems Program under an ONR monitored contract (N00014 91-J-4041). VLSI CAD, and operations research. Timed automata [1] is one of the more powerful models for which automated verification methods exists. <p> A timed automaton has a number of clocks (timers) whose values can be used in guards of the transitions of the automaton. Such models have been extensively studied and several algorithms exist for determining timing properties for timed automata <ref> [7, 8] </ref>. As in the untimed case, timed automata suffer from the state explosion problem when constructing the cross product of component specifications. Furthermore, the verification time is proportional to the product of the maximum value of the clocks and also proportional to the number of permutations of the clocks.
Reference: 8. <editor> D. L. Dill, editor. </editor> <booktitle> Computer-Aided Verification '94. </booktitle>
Reference-contexts: A timed automaton has a number of clocks (timers) whose values can be used in guards of the transitions of the automaton. Such models have been extensively studied and several algorithms exist for determining timing properties for timed automata <ref> [7, 8] </ref>. As in the untimed case, timed automata suffer from the state explosion problem when constructing the cross product of component specifications. Furthermore, the verification time is proportional to the product of the maximum value of the clocks and also proportional to the number of permutations of the clocks.
Reference: 9. <author> P. Godefroid. </author> <title> Using partial orders to improve automatic verification methods. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Computer-Aided Verification '90, </booktitle> <pages> pages 321-340. </pages>
Reference-contexts: We can construct the process automaton without first constructing the reach-ability graph <ref> [5, 9] </ref>. If there is no concurrency in the net, the size of the process automaton is equal to the size of the reachability graph. However, if there is a high degree of concurrency, the process automaton will be considerably smaller.
Reference: 10. <author> H. Hulgaard and S. M. Burns. </author> <title> Bounded delay timing analysis of a class of CSP programs with choice. </title> <booktitle> In International Symposium on Advanced Research in Asynchronous Circuits and Systems, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: This paper presents the details of an algorithm that determines the extreme case separation in time between two given transitions in a Petri net specification over all timed executions. By answering this separation problem, one can solve a number of problems in timing analysis, performance analysis and timing verification <ref> [10, 11] </ref>. For example, the best and worst case cycle period of a system is the minimum and maximum time, respectively, from a transition to the next occurrence of the same transition. <p> The set b is used to describe all the possible processes where the distinguished transitions t src and t dst have the appropriate relationship. This relationship must be established in order for the timing analysis to yield interesting information <ref> [10] </ref>. Consider finding the maximum time between consecutive firings of transition a in Fig. 1 (a), i.e., t from = t to = a. All the elements of b must have the property that no other transition t between t src and t dst has label a. <p> This observation was key to achieving polynomial run-time for the example described in the following section. 6 Benchmark Example: The Eager Stack Replicating a single process in a linear array provides an efficient hardware implementation of a last-in, first-out memory which we refer to as an eager stack <ref> [10] </ref>. The eager stack contains an interesting mixture of choice and concurrency and represents an excellent parameterizable example for benchmarking our implementation of the algorithm. A stack capable of storing n elements is constructed from n identical processes arranged in a linear array.
Reference: 11. <author> H. Hulgaard, S. M. Burns, T. Amon, and G. Borriello. </author> <title> Practical applications of an efficient time separation of events algorithm. </title> <booktitle> In Proc. International Conf. Computer-Aided Design (ICCAD), </booktitle> <pages> pages 146-151, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: This paper presents the details of an algorithm that determines the extreme case separation in time between two given transitions in a Petri net specification over all timed executions. By answering this separation problem, one can solve a number of problems in timing analysis, performance analysis and timing verification <ref> [10, 11] </ref>. For example, the best and worst case cycle period of a system is the minimum and maximum time, respectively, from a transition to the next occurrence of the same transition.
Reference: 12. <author> H. Hulgaard, S. M. Burns, T. Amon, and G. Borriello. </author> <title> An algorithm for exact bounds on the time separation of events in concurrent systems. </title> <note> To appear in IEEE Transactions on Computers. Available as University of Washington CS&E Technical Report #94-02-02. (anonymous ftp: cs.washington.edu:tr/1994/02/UW-CSE94-02-02.PS.Z) </note>
Reference-contexts: The f 0 -part must represent the longest path respecting the delays assigned by the shortest path computation. For details see <ref> [12] </ref>. To find the maximum separation represented by a [f; m] pair, we evaluate f at m and 0, computing the sum of the longest and shortest paths.
Reference: 13. <author> K. L. McMillan and D. L. Dill. </author> <title> Algorithms for interface timing verification. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: The CTSE algorithm computing given a process automaton G. 5 Computing ( b ) This section describes the algebra used in the CTSE algorithm. This algebra is used to reformulate an algorithm by McMillan and Dill <ref> [13] </ref> for determining the maximum separation of two events in an acyclic graph. 5.1 Algebras Before presenting the algorithm for computing (b) we introduce two algebras.
Reference: 14. <author> J. L. Peterson. </author> <title> Petri Net Theory and The Modeling of Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: A Petri net is a pair (N; M 0 ), where N is a net and M 0 : S ! N is the initial marking. A Petri net is safe if for all reachable markings M and all places s, M (s) 1. See <ref> [14] </ref> for further details on the Petri net model. s 0 s 2 s 4 s 6 d f s 0 e s 1 b s 0 f s 1 b s 0 s 6 Fig. 1. (a) A simple Petri net .
Reference: 15. <author> C. V. Ramamoorthy and G. S. Ho. </author> <title> Performance evaluation of asynchronous concurrent systems using Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(5):440-448, </volume> <month> September </month> <year> 1980. </year>
Reference-contexts: Orbits [16] uses convex regions to represent sets of timed states and thus avoids the explicit enumeration of each individual discrete timed state. Orbits is based on a Petri net model augmented with timing information. Other approaches that fall in this category include Timed Petri net <ref> [15] </ref> and Time Petri nets [3]. In Timed Petri nets a fixed delay is associated with each transitions while Time Petri nets use a more general model with delay ranges associated with the transitions. 2 Specifications We use safe Petri nets to model concurrent systems.
Reference: 16. <author> T. G. Rokicki. </author> <title> Representing and Modeling Digital Circuits. </title> <type> Ph.D. thesis, </type> <institution> Stanford University, </institution> <year> 1993. </year>
Reference-contexts: To improve the run-time complexity, Burch [6] extends trace theory with discrete time but still uses automata-based methods for verification. This approach also suffers from exponential runtime in the size of the delay values but avoids the factorial associated with the permutations of the clocks. Orbits <ref> [16] </ref> uses convex regions to represent sets of timed states and thus avoids the explicit enumeration of each individual discrete timed state. Orbits is based on a Petri net model augmented with timing information. <p> 47 31 127 97 1.8 1.3 8 110 73 298 2124 6.8 6.6 12 236 157 638 14 10 4 34 31 20 632 421 1702 6 10 8 303 296 28 1220 813 3278 2 10 12 1404 1494 36 2000 1333 5366 1 10 16 4510 4858 Orbits <ref> [16] </ref> is, to the authors knowledge, the most developed and efficient tool for answering temporal questions about Petri nets specifications. Orbits constructs the timed reachability graph, i.e., the states reachable given the timing information.
Reference: 17. <author> T. G. Rokicki and C. J. Myers. </author> <title> Automatic verification of timed circuits. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer-Aided Verification '94, </booktitle> <pages> pages 468-480. </pages>
Reference-contexts: Double logarithmic plot of CPU time for the two separation analyses as a function of the Petri net size, jF j. are also used in Orbits to reduce the state space explosion <ref> [17] </ref>. However, the time to construct the timed reachability graph for the eager stack increases exponentially with the stack size n. For n = 6 the time is 234 CPU seconds on a Decstation 5000 with 256 MB, i.e., two orders of magnitude slower than the CTSE algorithm.
Reference: 18. <author> W. Vogler. </author> <title> Modular Construction and Partial Order Semantics of Petri Nets. </title> <publisher> LNCS #625. Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Petri net is a net N and a labeling lab : S [ T ! S [ T . (We subscript S, T , and F to distinguish between the nets of and .) N and lab must satisfy appropriate properties such that can be interpreted as an execution of <ref> [4, 18] </ref>. Intuitively, the process = (N; lab) is an unfolding of where all choice has been resolved, i.e., N is acyclic and choice free. Fig. 1 (b) shows a process for the Petri net in Fig. 1 (a). <p> The process automaton has the property that () = fpref ((p)) j v 0 p ; v is a path in the process automatong ; where pref () is the set of prefixes (defined on partial orders <ref> [18] </ref>) of a process . We can construct the process automaton without first constructing the reach-ability graph [5, 9]. If there is no concurrency in the net, the size of the process automaton is equal to the size of the reachability graph.
References-found: 18

