URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/theses/pnevmati.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/theses/
Root-URL: http://www.cs.wisc.edu
Title: Incorporating Guarded Execution into Existing Instruction Sets  
Author: by Dionisios N. Pnevmatikatos 
Degree: A dissertation submitted in partial fulfillment of the requirements for the Degree of Doctor of Philosophy (Computer Sciences) at the  
Date: 1996  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [AKPW83] <author> J. R. Allen, Ken Kennedy, Carrie Porterfield, and Joe Warren. </author> <title> Conversion of Control Dependence to Data Dependence. </title> <booktitle> In Proceedings 10th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-189, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion <ref> [AKPW83] </ref> and guarded execution [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94]. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. <p> The Cray-1 also includes a scalar version of the vector mask, and a merge instruction which is a superset of the conditional move instruction. Allen et al. formalized and generalized the idea of vector masks introducing if-conversion <ref> [AKPW83] </ref>, a general code transformation technique that facilitates the vectorization of floating point intensive applications. <p> Lin's Masters thesis [Lin92] and Mahlke et al. [MLC + 92] provide a more detailed discussion of the hyperblock formation. 3.2 If-conversion basics If-conversion as introduced by Allen et al. <ref> [AKPW83] </ref> operated on a per-statement level on the source of Fortran programs. Their if-conversion algorithm works by allocating a Boolean variable to hold the guard condition for each conditional branch in the code.
Reference: [ANHN95] <author> Hideki Ando, Chikako Nakanishi, Tetsuya Hara, and Masao Nakaya. </author> <title> Unconstrained Speculative Execution with Predicated State Buffering. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 126-137, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year>
Reference-contexts: In case (c) the promotion of the sub instruction from case (b) is made legal by stat ically renaming register r2 to r9. Predicate promotion can also be supported directly in hardware. Ando et al. <ref> [ANHN95] </ref> proposed Predicate State Buffering which allows a guarded instruction to execute before its guard operand (s) is available. In Predicate State Buffering, when a promoted guarded instruction is executed, 37 the result, tagged with the guard condition, is stored into a speculative version of the destination register. <p> Furthermore, the dependency resolution hardware opens up the possibility for speculative execution of guarded instructions, in which the guarded instruction can be speculative executed immediately, and verified later, when the guard condition becomes available. This approach would be similar to the Predicate State Buffering <ref> [ANHN95] </ref>, but it would be a micro-architecture feature, rather than being explicit in the instruction set architecture as in the case of Predicate State Buffering. 110
Reference: [APS95] <author> Todd M. Austin, Dionisios N. Pnevmatikatos, and Gurindar S. Sohi. </author> <title> Streamlining Data Cache Access with Fast Address Calculation. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 369-380, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year>
Reference-contexts: For Wc the input is file cccp.c supplied by the Illinois IMPACT group. Elvis is a vi-compatible full-screen editor performing two regular expression search-and-substitute operations (in a batch-mode) for the input file unix.c. The same benchmark and input was also used by Austin et al. <ref> [APS95] </ref>. Table 5.1 lists all our benchmark programs with their command line arguments. 5.4 Effects of full guarding In this section we examine the effects of full guarding on the instruction mix and dynamic behavior of our benchmark programs. <p> We also evaluate the guard condition characteristics of our guarded regions and the impact of guarding on the dynamic branch behavior of the program. 69 Program Command Line Comments Compress in-ref reference SPEC92 input Elvis -b CMDS unix.c input used in <ref> [APS95] </ref> Eqntott -s -.ioplte int pri 3.eqn reference SPEC92 input Espresso -t cps.in one of the SPEC92 reference inputs Gcc (cc1) -O integrate.i one of the SPEC92 reference inputs Sc test.start &lt; loada1 one of the SPEC92 reference inputs Xlisp queens7.lsp SPEC92 reference solves 9 queens Wc cccp.c input file used
Reference: [BL93] <author> Tomas Ball and James R. Larus. </author> <title> Branch Prediction For Free. </title> <booktitle> In Proceedings of the SIG-PLAN 1993 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-313, </pages> <month> April 20-23, </month> <year> 1993. </year>
Reference-contexts: If profile information for the prediction accuracies of branches is not available, the compiler can resort to heuristic approaches to derive static branch prediction estimates <ref> [BL93] </ref>. When no profiling information is available, the compiler can follow a conservative approach and assume that all paths in the CFG are equally likely.
Reference: [BL94] <author> Thomas Ball and James R. Larus. </author> <title> Optimally Profiling and Tracing Programs. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 16(4) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: This process can be helped by the use of profiling information. An if-converting compiler can take advantage of several types of profile information. The simplest and more widespread type of profiling information is basic block counts; tools such as pixie [MIP90] and QPT <ref> [Lar93, BL94] </ref> can provide this type of information. Other types of profiling include CFG arc frequencies [Lar93, BL94], and branch prediction accuracies [FF92]. <p> An if-converting compiler can take advantage of several types of profile information. The simplest and more widespread type of profiling information is basic block counts; tools such as pixie [MIP90] and QPT <ref> [Lar93, BL94] </ref> can provide this type of information. Other types of profiling include CFG arc frequencies [Lar93, BL94], and branch prediction accuracies [FF92].
Reference: [BRRP82] <author> A C. D. Glaeser B. R. Rau and R. L. </author> <title> Picard. Efficient Code Generation For Horizontal Architectures: </title> <booktitle> Compiler Techniques and Architectural Support. In Proceedings of the 9th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 131-139, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: The general methodology is to apply if-conversion to loop bodies so they become free of control dependences, and then to apply other loop scheduling technique such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>. These machines provided instruction set and hardware support for guarded execution. <p> In essence, the ability to overlap different control paths is similar to global scheduling techniques [Nic85, Smi92]. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>, modulo scheduling [Rau94], etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. Small basic blocks cause frequent changes in the flow of control, resulting in under-utilization of the instruction fetch bandwidth and the processor resources.
Reference: [Cas93] <author> Brian Case. </author> <title> SPARC V9 Adds Wealth of New Features. In Microprocessor Report, </title> <booktitle> volume 7, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: The opcode space limitations forced designers to introduce only a small number of guarded instructions. Many instruction set architectures such as the Cray-1 [Rus78], the DEC Alpha [Com88], the SPARC V9 <ref> [Cas93] </ref>, the MIPS R10000 [Pri94], the PowerPC [Cor94] and the Intel P6 [Gwe95] include a conditional move (cmov) instruction. The cmov instruction is almost trivial to add: since a move uses only one source specifier, the second specifier is used to specify the guard condition.
Reference: [CHPC95] <author> Po-Yung Chang, Eric Hao, Yale N. Patt, and Pohua P. Chang. </author> <title> Using Predicated Execution to Improve the Performance of a Dynamically Scheduled Machine with Speculative Execution. </title> <editor> In Lubomir Bic, Wim B ohm, Paraskevas Evripidou, and Jean-Luc Gaudiot, editors, </editor> <booktitle> Proceedings of the IFIP WG 10.3 Working Conference on Parallel Architectures and Compilation Techniques, PACT '95, </booktitle> <pages> pages 99-108, </pages> <address> Limassol, Cyprus, June 27-29, 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: restructuring Before Useful Tail duplication Before Yes Loop peeling Before Yes Control-tree height reduction After No Condition evaluation optimizations After No Exit coalescing After Yes Predicate promotion After Useful Table 3.3: Categorization of if-conversion specific optimizations. 3.3.1 Loop restructuring Loop restructuring (also called loop branch coalescing by Chang et al. <ref> [CHPC95] </ref>) transforms the control flow graph of a loop into a canonical form, in an effort to increase the number of forward branches and make the if-conversion more effective. <p> In the presence of long latency instructions such as multiplications or load instructions that may miss in the level-1 cache, this restriction can limit the performance. Code promotion, initially proposed by Tirumalai et al. [TLS90] and subsequently used by other research groups <ref> [MLC + 92, CHPC95, HMG + 95] </ref>, bypasses this limitation by moving the guarded computation before the guard condition is evaluated and executing them unconditionally. Since the dependency on the 36 guard register is removed, the instruction can be moved as far back as the remaining data dependences permit. <p> instruction guards just a few instructions, the overhead will be large; if each GUARD specifies the guard condition for several instructions, the specification overhead will be relatively small. 5.2 Related work Several studies have addressed the effects of guarding on the instruction mix and the dynamic branch behavior of programs <ref> [PS94, MHB + 94, MHM + 95, CHPC95, Tys94b] </ref>. The first study to consider these effects was done by Pnevmatikatos and Sohi [PS94]. <p> Chang et al. <ref> [CHPC95] </ref> used branch prediction profiling and hand-coding to if-convert branches that cause many mispredictions. They found that this profile-based if-conversion can eliminate more than 60% of the mispredictions for the programs Compress, Eqntott and Sc and estimated that it could eliminate 40% of the misprediction for Gcc.
Reference: [CMC + 91] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, Nancy J. Warter, and Wen-Mei W. Hwu. </author> <title> IMPACT: An Architectural Framework for Multiple-Instruction-Issue Processors. </title> <booktitle> In Proceedings of the 18th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 266-275, </pages> <address> Toronto, Ontario, </address> <month> May 27-30, </month> <year> 1991. </year>
Reference-contexts: Static predictions can also be used by the compiler for scheduling purposes, as in the case of trace scheduling and its variants <ref> [Fis81, LFK + 93, CNO + 88, CMC + 91] </ref>. In trace scheduling, the compiler predicts a branch and optimizes the code assuming the prediction is correct.
Reference: [CMMP95] <author> Thomas M. Conte, Kishore N. Menezes, Patrick M. Mills, and Burzin A. Patel. </author> <title> Optimization of Instruction Fetch Mechanisms for High Issue Rates. </title> <booktitle> In Proceedings of the 111 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 333-344, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year>
Reference-contexts: Similarly, the scalar mask can be supplied to a merging or collapsing network <ref> [Joh90, CMMP95] </ref>, which would completely remove from the pipeline any squashed instructions that have being fetched, before they are even decoded. The combination of GUARD instructions and the scalar mask register allows an additional optimization.
Reference: [CNO + 88] <author> R. P. Colwell, R. P. Nix, J. J. O'Donnell, D. B. Papworth, and P. K. Rodman. </author> <title> A VLIW Architecture for a Trace Scheduling Compiler. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8) </volume> <pages> 967-979, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Static predictions can also be used by the compiler for scheduling purposes, as in the case of trace scheduling and its variants <ref> [Fis81, LFK + 93, CNO + 88, CMC + 91] </ref>. In trace scheduling, the compiler predicts a branch and optimizes the code assuming the prediction is correct.
Reference: [Com88] <author> R. Comerford. </author> <title> How DEC Developed Alpha. </title> <journal> IEEE Spectrum, </journal> <volume> 29(7) </volume> <pages> 43-47, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: The opcode space limitations forced designers to introduce only a small number of guarded instructions. Many instruction set architectures such as the Cray-1 [Rus78], the DEC Alpha <ref> [Com88] </ref>, the SPARC V9 [Cas93], the MIPS R10000 [Pri94], the PowerPC [Cor94] and the Intel P6 [Gwe95] include a conditional move (cmov) instruction. The cmov instruction is almost trivial to add: since a move uses only one source specifier, the second specifier is used to specify the guard condition.
Reference: [Cor94] <author> International Business Machines Corporation. </author> <title> The PowerPC Architecture: Specifications for a New family of RISC Processors. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Fransisco, </address> <year> 1994. </year>
Reference-contexts: The opcode space limitations forced designers to introduce only a small number of guarded instructions. Many instruction set architectures such as the Cray-1 [Rus78], the DEC Alpha [Com88], the SPARC V9 [Cas93], the MIPS R10000 [Pri94], the PowerPC <ref> [Cor94] </ref> and the Intel P6 [Gwe95] include a conditional move (cmov) instruction. The cmov instruction is almost trivial to add: since a move uses only one source specifier, the second specifier is used to specify the guard condition.
Reference: [DHB89] <author> James C. Dehnert, Peter Y.-T. Hsu, and Joseph P. Bratt. </author> <title> Overlapped Loop Support in the Cydra 5. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 26-38, </pages> <address> Boston, Mas-sachusetts, </address> <month> April 3-6, </month> <year> 1989. </year>
Reference-contexts: A later phase of PFC was responsible for mapping these converted loops into vector instructions using the vector masks if they were supported by the underlying architecture. VLIW machines, for example Cydra-5 <ref> [RYYT89, DHB89] </ref>, and the IBM VLIW machine [Ebc88], have also used if-conversion and guarded execution to facilitate the software pipelining of loops with conditional branches. <p> All these programs are integer intensive; we did not use any floating point intensive programs as we feel that the effectiveness of guarded execution for scientific programs has long being established for vector and VLIW architectures <ref> [RYYT89, DHB89, HT72, Wat72, Rus78] </ref>. For the SPEC92 benchmark programs we used the SPEC reference inputs, with the exception of Xlisp, for which we used a smaller input (we solved the seven queens problem instead of the nine queens problem specified by the SPEC92 reference input file).
Reference: [Dij75] <author> E. W. Dijkstra. </author> <title> Guarded Commands, Nondeterminacy and Formal Derivation of Programs. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 453-457, </pages> <month> August </month> <year> 1975. </year>
Reference-contexts: However the processor will still have to fetch and decode them, possibly preventing other useful instructions from executing. 1.2 Guarding Background Guarded execution (or simply guarding), has been proven effective in several contexts. Originally, it was proposed by Dijkstra <ref> [Dij75] </ref> as a high level programming construct, meant to simplify the expression of algorithms and to allow the formal verification of the derived algorithms. Dijkstra allowed an arbitrary Boolean conditions to be used as the guard condition of a high level statement.
Reference: [Ebc87] <author> Kemal Ebcioglu. </author> <title> A Compilation Technique for Software Pipelining of Loops with Conditional Jumps. </title> <booktitle> In Proceedings of the 20th Annual Workshop on Microprogramming (Micro 20), </booktitle> <pages> pages 69-79, </pages> <month> December 1-4, </month> <year> 1987. </year>
Reference-contexts: The general methodology is to apply if-conversion to loop bodies so they become free of control dependences, and then to apply other loop scheduling technique such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>. These machines provided instruction set and hardware support for guarded execution. <p> In essence, the ability to overlap different control paths is similar to global scheduling techniques [Nic85, Smi92]. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>, modulo scheduling [Rau94], etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. Small basic blocks cause frequent changes in the flow of control, resulting in under-utilization of the instruction fetch bandwidth and the processor resources.
Reference: [Ebc88] <author> Kemal Ebcioglu. </author> <title> Some Design Ideas for a VLIW Architecture for Sequential Natured Software. </title> <editor> In Cosnard et al., editor, </editor> <booktitle> Parallel Processing (Proceedings of IFIP WG 10.3 Working Conference on Parallel Processing), </booktitle> <pages> pages 3-21. </pages> <publisher> North Holland, </publisher> <month> April </month> <year> 1988. </year>
Reference-contexts: A later phase of PFC was responsible for mapping these converted loops into vector instructions using the vector masks if they were supported by the underlying architecture. VLIW machines, for example Cydra-5 [RYYT89, DHB89], and the IBM VLIW machine <ref> [Ebc88] </ref>, have also used if-conversion and guarded execution to facilitate the software pipelining of loops with conditional branches.
Reference: [FF92] <author> Joseph A. Fisher and Stefan M. Freudenberger. </author> <title> Predicting Conditional Branch Directions From Previous Runs of a Program. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 85-95, </pages> <address> Boston, Massachusetts, </address> <month> October 12-15, </month> <year> 1992. </year>
Reference-contexts: The simplest and more widespread type of profiling information is basic block counts; tools such as pixie [MIP90] and QPT [Lar93, BL94] can provide this type of information. Other types of profiling include CFG arc frequencies [Lar93, BL94], and branch prediction accuracies <ref> [FF92] </ref>. Basic block or arc frequency profiling can be used to control the amount of squashed computation; using this information, the compiler can identify nodes and arcs that are so infrequent that including them in the if-converted code will only consume resources, without a corresponding improvement in execution time.
Reference: [Fis81] <author> Joseph A. Fisher. </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(7), </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: Static predictions can also be used by the compiler for scheduling purposes, as in the case of trace scheduling and its variants <ref> [Fis81, LFK + 93, CNO + 88, CMC + 91] </ref>. In trace scheduling, the compiler predicts a branch and optimizes the code assuming the prediction is correct.
Reference: [FOW87] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The Program Dependence Graph and Its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> pages 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Given a directed acyclic control flow graph G with a single entry point, the first step of the RK algorithm is the computation the control dependences in G, as described by Ferrante et al. <ref> [FOW87] </ref>. <p> Figure 4.5 shows the modified version of the GUARD mask assignment algorithm, supporting GUARDBOTH instructions. 4.3.2 An example of GUARD assignment To illustrate the operation of guard assignment algorithm consider the control flow graph in Figure 4.6. (This CFG is similar to the examples used by Ferrante et al. <ref> [FOW87] </ref> and Park and Schlansker [PS91].) The CFG is annotated with the required GUARD instructions to achieve correct guarded execution as determined by the algorithm of Figure 4.4.
Reference: [Fra93] <author> Manoj Franklin. </author> <title> The Multiscalar Architecture. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Multiblocks must satisfy three conditions: * Condition 1: there should be a single entry point to each multiblock, * Condition 2: the should be no nested loops inside a multiblock, and * Condition 3: a multiblock should have at most two targets. The Multiscalar processor <ref> [FS92, Fra93] </ref>, used these multiblocks to dispatch multiple basic blocks to each of its multiple execution stages and to avoid predicting the branches that were inside multiblocks.
Reference: [FS92] <author> Manoj Franklin and Gurindar S. Sohi. </author> <title> The Expandable Split Window Paradigm for Exploiting Fine-Grained Parallelism. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 58-67, </pages> <address> Gold Coast, Australia, </address> <month> May 19-21, </month> <year> 1992. </year>
Reference-contexts: Multiblocks must satisfy three conditions: * Condition 1: there should be a single entry point to each multiblock, * Condition 2: the should be no nested loops inside a multiblock, and * Condition 3: a multiblock should have at most two targets. The Multiscalar processor <ref> [FS92, Fra93] </ref>, used these multiblocks to dispatch multiple basic blocks to each of its multiple execution stages and to avoid predicting the branches that were inside multiblocks.
Reference: [Gwe95] <author> Linley Gwennap. </author> <title> Intel's P6 Uses Decoupled Superscalar Design. </title> <type> Microprocessor Report, 9(2) </type> <pages> 9-15, </pages> <month> February </month> <year> 1995. </year> <month> 112 </month>
Reference-contexts: The opcode space limitations forced designers to introduce only a small number of guarded instructions. Many instruction set architectures such as the Cray-1 [Rus78], the DEC Alpha [Com88], the SPARC V9 [Cas93], the MIPS R10000 [Pri94], the PowerPC [Cor94] and the Intel P6 <ref> [Gwe95] </ref> include a conditional move (cmov) instruction. The cmov instruction is almost trivial to add: since a move uses only one source specifier, the second specifier is used to specify the guard condition.
Reference: [HCP94] <author> Eric Hao, Po-Yung Chang, and Yale N. Patt. </author> <title> The Effect of Speculatively Updating Branch History on Branch Prediction Accuracy, Revisited. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 228-232, </pages> <address> San Jose, California, </address> <month> November 30-December 2, </month> <year> 1994. </year>
Reference-contexts: Other researchers have also reported that predicting based on speculative branch history usually has a small impact on the prediction accuracy <ref> [TYS + 94a, HCP94] </ref>. Table 5.6 lists the dynamic prediction accuracies and the absolute number of mispredictions for the original and guarded version of the benchmark programs for a counter based predictor with 1024 2-bit counters. Guarding increases the prediction accuracies for all the programs except Elvis.
Reference: [HD86] <author> Peter Y. T. Hsu and Edward S. Davidson. </author> <title> Highly Concurrent Scalar Processing. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 386-395, </pages> <address> Tokyo, Japan, </address> <month> June 2-5, </month> <year> 1986. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion [AKPW83] and guarded execution <ref> [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94] </ref>. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. This operand specifies whether the instruction should be executed or not, and the branch controlling the execution of that region can be removed from the code. <p> For example, the Cydra-5 contained a predicate field per operation, and the IBM VLIW machine supported tree instructions, which would evaluate an expression tree and depending on the exact conditions would nullify the appropriate operations along the branches of the tree. Hsu and Davidson <ref> [Hsu86, HD86] </ref> used guarding on a scalar processor to allow better scheduling of decision trees. In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the tree. <p> For example, if the instruction set allows the conjunction of two registers to be used as a guard expression (in a manner similar to Hsu and Davidson's work <ref> [Hsu86, HD86] </ref>), the guard condition A&B can be attached to a guarded instruction directly.
Reference: [HMG + 95] <author> Richard E. Hank, Scott A. Mahlke, John C. Gyllenhaal, David I. August, and Wen-Mei W. Hwu. </author> <title> Control Flow Optimization with Predicated Execution in Future Microprocessors. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: In the presence of long latency instructions such as multiplications or load instructions that may miss in the level-1 cache, this restriction can limit the performance. Code promotion, initially proposed by Tirumalai et al. [TLS90] and subsequently used by other research groups <ref> [MLC + 92, CHPC95, HMG + 95] </ref>, bypasses this limitation by moving the guarded computation before the guard condition is evaluated and executing them unconditionally. Since the dependency on the 36 guard register is removed, the instruction can be moved as far back as the remaining data dependences permit. <p> The IMPACT group publications show guarding to provide speedups over a base case in the range of 3 to 8 <ref> [HMG + 95] </ref>. Much of the difference can be attributed to different assumptions made in our and their work about the base case, the execution model and the compilation environment.
Reference: [HP87] <author> Wen-Mei W. Hwu and Yale N. Patt. </author> <title> Checkpoint Repair for High-Performance Out-of-Order Execution Machines. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(12):1496-1514, </volume> <month> De-cember </month> <year> 1987. </year>
Reference-contexts: In this approach, the handling of traps (which cannot be deferred until the state of the processor becomes clean) requires that the processor must be able to revert to the last PC for which the state was clean, in a manner similar to the checkpoint repair of <ref> [HP87] </ref>. Since the control of GUARD instructions is in the hands of the compiler or the user, it will be hard or even impossible to predict how soon the processor state will become clean.
Reference: [Hsu86] <author> Peter Y. T. Hsu. </author> <title> Highly Concurrent Scalar Processing. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1986. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion [AKPW83] and guarded execution <ref> [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94] </ref>. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. This operand specifies whether the instruction should be executed or not, and the branch controlling the execution of that region can be removed from the code. <p> For example, the Cydra-5 contained a predicate field per operation, and the IBM VLIW machine supported tree instructions, which would evaluate an expression tree and depending on the exact conditions would nullify the appropriate operations along the branches of the tree. Hsu and Davidson <ref> [Hsu86, HD86] </ref> used guarding on a scalar processor to allow better scheduling of decision trees. In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the tree. <p> For example, if the instruction set allows the conjunction of two registers to be used as a guard expression (in a manner similar to Hsu and Davidson's work <ref> [Hsu86, HD86] </ref>), the guard condition A&B can be attached to a guarded instruction directly.
Reference: [HT72] <author> R. G. Hintz and D. P. Tate. </author> <title> Control Data STAR-100 Processor Design. </title> <booktitle> In COMCON, IEEE, </booktitle> <pages> pages 1-4, </pages> <month> September </month> <year> 1972. </year>
Reference-contexts: Dijkstra allowed an arbitrary Boolean conditions to be used as the guard condition of a high level statement. Vector processors such as the CDC STAR-100 <ref> [HT72] </ref>, TI ASC [Wat72] and Cray-1 [Rus78] have long benefited from guarded execution expressed through the use of vector masks. A vector mask is an N-bit wide control register, where N is the number of elements in a vector register. <p> All these programs are integer intensive; we did not use any floating point intensive programs as we feel that the effectiveness of guarded execution for scientific programs has long being established for vector and VLIW architectures <ref> [RYYT89, DHB89, HT72, Wat72, Rus78] </ref>. For the SPEC92 benchmark programs we used the SPEC reference inputs, with the exception of Xlisp, for which we used a smaller input (we solved the seven queens problem instead of the nine queens problem specified by the SPEC92 reference input file).
Reference: [Joh90] <author> M. Johnson. </author> <title> Superscalar Microprocessor Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: Similarly, the scalar mask can be supplied to a merging or collapsing network <ref> [Joh90, CMMP95] </ref>, which would completely remove from the pipeline any squashed instructions that have being fetched, before they are even decoded. The combination of GUARD instructions and the scalar mask register allows an additional optimization.
Reference: [Kan87] <author> Gerry Kane. </author> <title> MIPS R2000 RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: Saving and restoring the scalar mask value can be easily achieved if the architecture defines an Exception Scalar Mask (ESM) register, similar to the Exception Program Counter of the MIPS architecture <ref> [Kan87] </ref>. When an interrupt or an exception is taken by the processor, the value of the scalar mask register is copied into the ESM register, and all the scalar mask bits are set to 1.
Reference: [KSR94] <author> Vinod Kathail, Michael Schlansker, and B. Ramakrishna Rau. </author> <title> HPL PlayDoh Architecture Specification: Version 1.0. </title> <type> Technical Report HPL-93-80, </type> <institution> Hewlett Packard Laboratories, </institution> <address> Palo Alto, CA, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion [AKPW83] and guarded execution <ref> [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94] </ref>. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. This operand specifies whether the instruction should be executed or not, and the branch controlling the execution of that region can be removed from the code. <p> The problem is exacerbated by the instruction scheduler which, by rearranging instructions to increase parallelism, can increase the register lifetimes. One possible solution to this problem is to add a separate predicate register file <ref> [MLC + 92, RYYT89, KSR94] </ref>, to relieve the pressure on the general purpose registers. This solution, however, is a major architectural change and may not be easily incorporated into existing architectures. <p> A dash in an entry indicates that the destination register is left unmodified. of the computation. The PlayDoh instruction set <ref> [KSR94] </ref> addresses these potential problems by supporting a rich set of predicate setting instructions. PlayDoh, supports a special pred clear instruction which initializes all the guard registers in a single cycle. <p> This symmetry simplifies the compiler construction since no case analysis is needed to determine whether a code sequence can be expressed using the existing set of guarded instructions. Proposed methods for specifying guarded execution use an additional operand field for each instruction <ref> [MLC + 92, RYYT89, Mac93, KSR94] </ref>. An additional bit in the opcode specifies whether the guard condition should be true or false for the instruction to execute. <p> Using the control-tree height reduction technique, Expression 3.1 can be represented with the tree in The control height reduction can be even more effective using the special set instructions and semantics provided by the PlayDoh architecture <ref> [KSR94] </ref>. As described in Chapter 2, the PlayDoh architecture defines an action specifier which, together with the result of the comparison, determine whether the destination register should be left unmodified, and if not, they determine the value that should be written to it. <p> Predicting and traversing multiple branches per cycle is indeed complicated, but if the branches are predicted one at a time, executing more than one branch per cycle (that is, verifying the corresponding predictions) is not very hard. Other research in VLIW embraces the execution of multiple branches per cycle <ref> [KSR94, SK95] </ref>. For example, the PlayDoh instruction set allows the execution of multiple branches per cycle, under the constraint that the compiler must guarantee that at most one of them can be taken.
Reference: [Kuc78] <author> D. J. Kuck. </author> <title> The Structure of Computers and Computations. </title> <publisher> John Wiley and Sons, </publisher> <year> 1978. </year>
Reference-contexts: Part (b) shows the if-converted set sequence for the same condition. Expression 3.1 can be represented using the expression tree of height three, show in Figure 3.9. Control-tree height reduction is similar to the technique that was proposed by Kuck to reduce the time to evaluate expression trees <ref> [Kuc78] </ref>. This technique works by evaluating all the leaf nodes in parallel during the first step, and continues with the evaluation of the next level until the root of the tree is reached. In this way, the expression tree (control or computation alike) is evaluated in logarithmic time.
Reference: [Lam88] <author> Monica S. Lam. </author> <title> Software Pipelining: An Effective Scheduling Technique for VLIW Machines. </title> <booktitle> In Proceedings of the SIGPLAN 1988 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 318-328, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The general methodology is to apply if-conversion to loop bodies so they become free of control dependences, and then to apply other loop scheduling technique such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>. These machines provided instruction set and hardware support for guarded execution. <p> In essence, the ability to overlap different control paths is similar to global scheduling techniques [Nic85, Smi92]. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>, modulo scheduling [Rau94], etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. Small basic blocks cause frequent changes in the flow of control, resulting in under-utilization of the instruction fetch bandwidth and the processor resources.
Reference: [Lar93] <author> James R. Larus. </author> <title> Efficient Program Tracing. </title> <journal> IEEE Computer, </journal> <volume> 26(5) </volume> <pages> 52-61, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This process can be helped by the use of profiling information. An if-converting compiler can take advantage of several types of profile information. The simplest and more widespread type of profiling information is basic block counts; tools such as pixie [MIP90] and QPT <ref> [Lar93, BL94] </ref> can provide this type of information. Other types of profiling include CFG arc frequencies [Lar93, BL94], and branch prediction accuracies [FF92]. <p> An if-converting compiler can take advantage of several types of profile information. The simplest and more widespread type of profiling information is basic block counts; tools such as pixie [MIP90] and QPT <ref> [Lar93, BL94] </ref> can provide this type of information. Other types of profiling include CFG arc frequencies [Lar93, BL94], and branch prediction accuracies [FF92].
Reference: [LFK + 93] <author> P. G. Lowney, S. M. Freudenberger, T. J. Karzes, W. D. Lichtenstein, R. P. Nix, J. S. O'Donnel, and J. C. Ruttenberg. </author> <title> The Multiflow Trace Scheduling Compiler. </title> <journal> The Journal of Supercomputing, </journal> <volume> 4(11) </volume> <pages> 376-408, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Static predictions can also be used by the compiler for scheduling purposes, as in the case of trace scheduling and its variants <ref> [Fis81, LFK + 93, CNO + 88, CMC + 91] </ref>. In trace scheduling, the compiler predicts a branch and optimizes the code assuming the prediction is correct.
Reference: [Lin92] <author> David Chu Lin. </author> <title> Compiler Support for Predicate Execution in Superscalar Processors. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Each of these steps involves a number of tradeoffs that determine the quality and the performance of the generated code. The compiler aspects of guarded execution of general purpose programs have been only recently explored in detail and mostly by the Illinois IMPACT group <ref> [Lin92, MLC + 92] </ref>. <p> The main difference from a multiblock is that a hyperblock is allowed to contain branches (and therefore have multiple exit targets). This difference gives more flexibility to the compiler to select the hyperblocks and permits the hyperblocks to be larger than multiblocks. Lin's Masters thesis <ref> [Lin92] </ref> and Mahlke et al. [MLC + 92] provide a more detailed discussion of the hyperblock formation. 3.2 If-conversion basics If-conversion as introduced by Allen et al. [AKPW83] operated on a per-statement level on the source of Fortran programs. <p> The RK algorithm determines the guard condition that will be assigned to each basic block and the operations required to evaluate the guard conditions. The algorithm is provably 26 correct for all types of control flow graphs, and generates a minimal set of condition evaluation instructions. Lin <ref> [Lin92] </ref> compared three if-conversion algorithms, one that associates a guard condition to each CFG arc (roughly corresponding to Allen et al.'s if-conversion algorithm after the Boolean minimization step and common subexpression elimination), one that associates one guard condition for every basic block, and the RK algorithm.
Reference: [LS84] <author> Johnny K. F. Lee and Alan Jay Smith. </author> <title> Branch Prediction Strategies and Branch Target Buffer Design. </title> <journal> IEEE Computer, </journal> <volume> 17(1) </volume> <pages> 6-22, </pages> <month> January </month> <year> 1984. </year> <month> 113 </month>
Reference-contexts: Because the direction of a branch is not by itself sufficient to allow the instruction fetch mechanism to commence fetching new instructions, a Branch Target Buffer is also used to cache branch target address <ref> [LS84] </ref>. Dynamic branch prediction techniques are significantly more accurate than static ones, and due of their simple, table-based structure, are relatively easy to implement. As a result, virtually every new processor resorts to some form of dynamic branch prediction. Even the most accurate prediction mechanisms face performance limitations.
Reference: [LW92] <author> Monica S. Lam and Robert P. Wilson. </author> <title> Limits of Control Flow on Parallelism. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 46-57, </pages> <address> Gold Coast, Australia, </address> <month> May 19-21, </month> <year> 1992. </year>
Reference-contexts: Furthermore, after if-conversion, instructions from different control paths can be freely intermixed, allowing instruction schedules that overlap different control paths during execution, a flexibility that is shown to have significant performance potential; Lam and Wilson <ref> [LW92] </ref> found that allowing the execution of multiple flows of control almost tripled the amount of parallelism exposed to their 8 abstract machine models. In essence, the ability to overlap different control paths is similar to global scheduling techniques [Nic85, Smi92].
Reference: [Mac93] <institution> Advanced RISC Machines. ARM 610 RISC Processor, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion [AKPW83] and guarded execution <ref> [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94] </ref>. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. This operand specifies whether the instruction should be executed or not, and the branch controlling the execution of that region can be removed from the code. <p> These diverging control structures are not amenable to if-conversion, and guarding was used as a general purpose technique to fill multiple architectural branch delay slots. However, the only current commercial scalar instruction set to include support for guarded execution is the ARM instructions set <ref> [Mac93] </ref>. The Illinois IMPACT group [CMC + 91, MCH + 92, MLC + 92, MHB + 94, MHM + 95] has developed several compilation techniques to improve the performance of guarded execution for ordinary programs. <p> This symmetry simplifies the compiler construction since no case analysis is needed to determine whether a code sequence can be expressed using the existing set of guarded instructions. Proposed methods for specifying guarded execution use an additional operand field for each instruction <ref> [MLC + 92, RYYT89, Mac93, KSR94] </ref>. An additional bit in the opcode specifies whether the guard condition should be true or false for the instruction to execute.
Reference: [MCH + 92] <author> Scott A. Mahlke, William Y. Chen, Wen-Mei W. Hwu, B. Ramakrishna Rau, and Michael S. Schlansker. </author> <title> Sentinel Scheduling for VLIW and Superscalar Processors. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 238-247, </pages> <address> Boston, Massachusetts, Octo-ber 12-15, </address> <year> 1992. </year>
Reference-contexts: execution depends on a branch outcome) cannot, in general, be moved across branches, unless it is safe, i.e., unless the compiler can guarantee that the computation will never cause an exception, or unless adequate hardware support is provided to buffer the exceptions until the condition is resolved (e.g., sentinel scheduling <ref> [MCH + 92] </ref>, or boosting [SLH90, SHL92]). 1.1 What can we do about branches? A number of solutions have been proposed to deal with the limitations of branches. The general idea behind many techniques is to predict a likely direction for a branch and optimize the execution along that path. <p> The tag can be checked later by the conditional move instruction if the condition evaluates to true and if so, the exception should be serviced. This functionality is very similar to sentinel scheduling proposed by Mahlke et al. <ref> [MCH + 92] </ref> and the Rogers and Li's hardware support for speculative loads [RL92]. However, the storage required to postpone the handling of exceptions (for example, the exception tags along each register) is part of the architectural state of the processor.
Reference: [MHB + 94] <author> Scott A. Mahlke, Richard E. Hank, Roger A. Bringmann, John C. Gyllenhaal, David M. Gallagher, and Wen-Mei W. Hwu. </author> <title> Characterizing the Impact of Predicated Execution on Branch Prediction. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Mi-croarchitecture, </booktitle> <pages> pages 217-227, </pages> <address> San Jose, California, </address> <month> November 30-December 2, </month> <year> 1994. </year>
Reference-contexts: While the loop restructuring transformation is very successful in increasing the effectiveness of if-conversion in eliminating branches <ref> [MHB + 94] </ref>, it comes at a considerable cost. The amount of computation that is bypassed in the original code using the multiple backward arcs can be large, and including it in the if-conversion can hurt the performance instead of improving it. <p> instruction guards just a few instructions, the overhead will be large; if each GUARD specifies the guard condition for several instructions, the specification overhead will be relatively small. 5.2 Related work Several studies have addressed the effects of guarding on the instruction mix and the dynamic branch behavior of programs <ref> [PS94, MHB + 94, MHM + 95, CHPC95, Tys94b] </ref>. The first study to consider these effects was done by Pnevmatikatos and Sohi [PS94]. <p> They also proposed and evaluated the concept of GUARD instructions, reporting an preliminary overhead of about 8%. Mahlke et al. <ref> [MHB + 94] </ref> evaluated the effect of guarding on the branch characteristics of a program using the IMPACT compiler. The IMPACT compiler uses sophisticated code transformations guided by profiling information and heuristics to form the Hyperblocks described in Chapter 3.
Reference: [MHM + 95] <author> Scott A. Mahlke, Richard E. Hank, James E. McCormick, David I. August, and Wen-Mei W. Hwu. </author> <title> A Comparison of Full and Partial Predicated Execution Support for ILP Processors. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 138-149, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year>
Reference-contexts: A representative subset of the scalar equivalent of these sequences is listed in the second column of Table 2.3. Mahlke et al. <ref> [MHM + 95] </ref> used these sequences to synthesize the guarded form of all instructions using cmovs. <p> instruction guards just a few instructions, the overhead will be large; if each GUARD specifies the guard condition for several instructions, the specification overhead will be relatively small. 5.2 Related work Several studies have addressed the effects of guarding on the instruction mix and the dynamic branch behavior of programs <ref> [PS94, MHB + 94, MHM + 95, CHPC95, Tys94b] </ref>. The first study to consider these effects was done by Pnevmatikatos and Sohi [PS94]. <p> The IMPACT compiler uses sophisticated code transformations guided by profiling information and heuristics to form the Hyperblocks described in Chapter 3. They found that the number of branches was reduced by 27%, with a corresponding 30% reduction in the number of mispredictions. In a later paper <ref> [MHM + 95] </ref>, Mahlke et al. compared the performance of full guarding to the performance of guarding using conditional move instructions, and found that conditional moves achieved about 50% of the performance of full guarding. However, Mahlke et al. use a processor model with an infinite number of registers.
Reference: [MIP90] <institution> MIPS Computer Systems, Inc. UMIPS-V Reference Manual (pixie and pixstats). Sunny-vale, California, </institution> <year> 1990. </year>
Reference-contexts: This process can be helped by the use of profiling information. An if-converting compiler can take advantage of several types of profile information. The simplest and more widespread type of profiling information is basic block counts; tools such as pixie <ref> [MIP90] </ref> and QPT [Lar93, BL94] can provide this type of information. Other types of profiling include CFG arc frequencies [Lar93, BL94], and branch prediction accuracies [FF92].
Reference: [MLC + 92] <author> Scott A. Mahlke, David C. Lin, William Y. Chen, Richard E. Hank, and Roger A. Bring-mann. </author> <title> Effective Compiler Support for Predicated Execution Using the Hyperblock. </title> <booktitle> In Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 45-54, </pages> <address> Portland, Oregon, </address> <month> December 1-4, </month> <year> 1992. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion [AKPW83] and guarded execution <ref> [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94] </ref>. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. This operand specifies whether the instruction should be executed or not, and the branch controlling the execution of that region can be removed from the code. <p> The problem is exacerbated by the instruction scheduler which, by rearranging instructions to increase parallelism, can increase the register lifetimes. One possible solution to this problem is to add a separate predicate register file <ref> [MLC + 92, RYYT89, KSR94] </ref>, to relieve the pressure on the general purpose registers. This solution, however, is a major architectural change and may not be easily incorporated into existing architectures. <p> This symmetry simplifies the compiler construction since no case analysis is needed to determine whether a code sequence can be expressed using the existing set of guarded instructions. Proposed methods for specifying guarded execution use an additional operand field for each instruction <ref> [MLC + 92, RYYT89, Mac93, KSR94] </ref>. An additional bit in the opcode specifies whether the guard condition should be true or false for the instruction to execute. <p> Each of these steps involves a number of tradeoffs that determine the quality and the performance of the generated code. The compiler aspects of guarded execution of general purpose programs have been only recently explored in detail and mostly by the Illinois IMPACT group <ref> [Lin92, MLC + 92] </ref>. <p> Obviously, this conservative approach will not be able to achieve the performance levels that profiled based approaches will. Next, we describe two region selection schemes that have been used in earlier studies. The first, called Multiblock [PFS93], is based on the CFG structure, and the second, called Hyperblock <ref> [MLC + 92] </ref>, is based on the CFG structure as well as on profiling information and heuristics to guide the Hyperblock formation process. Both schemes form a collection of nodes of the CFG, that have a single entry point. <p> Pnevmatikatos and Sohi used these regions to evaluate the effects of guarded execution on the static and dynamic branch behavior of programs. 25 3.1.2 The Hyperblock region selection scheme The Hyperblock construct <ref> [MLC + 92] </ref>, proposed by the Illinois IMPACT group, is a hybrid of trace scheduling and if-conversion. Given a control flow graph, a hyperblock is formed by identifying a subset of the graph for inclusion in the hyperblock. <p> This difference gives more flexibility to the compiler to select the hyperblocks and permits the hyperblocks to be larger than multiblocks. Lin's Masters thesis [Lin92] and Mahlke et al. <ref> [MLC + 92] </ref> provide a more detailed discussion of the hyperblock formation. 3.2 If-conversion basics If-conversion as introduced by Allen et al. [AKPW83] operated on a per-statement level on the source of Fortran programs. <p> Tail duplication does not increase the dynamic instruction count, but it does increase the static code size of a program and can adversely affect the instruction cache performance. To limit the code increase, Mahlke et al. <ref> [MLC + 92] </ref> suggest limiting the duplication to make at most one copy of each basic block. 31 dashed line) in (a) has two entry points. <p> In the presence of long latency instructions such as multiplications or load instructions that may miss in the level-1 cache, this restriction can limit the performance. Code promotion, initially proposed by Tirumalai et al. [TLS90] and subsequently used by other research groups <ref> [MLC + 92, CHPC95, HMG + 95] </ref>, bypasses this limitation by moving the guarded computation before the guard condition is evaluated and executing them unconditionally. Since the dependency on the 36 guard register is removed, the instruction can be moved as far back as the remaining data dependences permit. <p> Instead, we use the structural properties of the program to determine the guarding regions of the control flow graph. Our region selection criteria are similar to the ones used by the Hyperblock <ref> [MLC + 92] </ref>. The regions are required to have a single entry point, and must not contain nested loops. In addition we require that a function call must terminate the guarding region.
Reference: [Nic85] <author> Alexandru Nicolau. </author> <title> Percolation Scheduling: A Parallel Compilation Technique. </title> <type> Technical Report TR 85-678, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> May </month> <year> 1985. </year>
Reference-contexts: In essence, the ability to overlap different control paths is similar to global scheduling techniques <ref> [Nic85, Smi92] </ref>. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining [RG91, BRRP82, Lam88, Ebc87], modulo scheduling [Rau94], etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. <p> Since the dependency on the 36 guard register is removed, the instruction can be moved as far back as the remaining data dependences permit. This code transformation is essentially global code motion similar to Nicolau's Percolation Scheduling <ref> [Nic85] </ref>. (An excellent overview of global scheduling techniques can be found in Michael Smith's thesis [Smi92].) Promoted instructions are always executed and produce results, even when the actual guard condition is false.
Reference: [PFS93] <author> Dionisios N. Pnevmatikatos, Manoj Franklin, and Gurindar S. Sohi. </author> <title> Control Flow Prediction for Dynamic ILP Processors. </title> <booktitle> In Proceedings of the 26th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 153-163, </pages> <address> Austin, Texas, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Obviously, this conservative approach will not be able to achieve the performance levels that profiled based approaches will. Next, we describe two region selection schemes that have been used in earlier studies. The first, called Multiblock <ref> [PFS93] </ref>, is based on the CFG structure, and the second, called Hyperblock [MLC + 92], is based on the CFG structure as well as on profiling information and heuristics to guide the Hyperblock formation process. <p> This requirement allows the compiler to freely rearrange the instructions inside the region. If multiple entry points are allowed, the compiler cannot move instructions across the multiple entry points. 3.1.1 The Multiblock region selection scheme Pnevmatikatos et al. <ref> [PFS93] </ref> used the CFG structure to construct Multiblocks, which are loop free regions of contiguous basic blocks having at most two possible successors.
Reference: [Pri94] <author> Charles Price. </author> <title> MIPS IV ISA Manual, </title> <month> October </month> <year> 1994. </year>
Reference-contexts: The opcode space limitations forced designers to introduce only a small number of guarded instructions. Many instruction set architectures such as the Cray-1 [Rus78], the DEC Alpha [Com88], the SPARC V9 [Cas93], the MIPS R10000 <ref> [Pri94] </ref>, the PowerPC [Cor94] and the Intel P6 [Gwe95] include a conditional move (cmov) instruction. The cmov instruction is almost trivial to add: since a move uses only one source specifier, the second specifier is used to specify the guard condition.
Reference: [PS91] <author> Joseph C. H. Park and Mike Schlansker. </author> <title> On Predicated Execution. </title> <type> Technical Report HPL-91-58, </type> <institution> Hewlett Packard Laboratories, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: At least one compiler, the Cydrome compiler used by the Cydra 5 [RYYT89], is reported <ref> [PS91] </ref> to produced incorrect code for certain control flow graphs. Park and Schlansker addressed this problem and formalized the if-conversion process in the RK algorithm [PS91]. The RK algorithm determines the guard condition that will be assigned to each basic block and the operations required to evaluate the guard conditions. <p> At least one compiler, the Cydrome compiler used by the Cydra 5 [RYYT89], is reported <ref> [PS91] </ref> to produced incorrect code for certain control flow graphs. Park and Schlansker addressed this problem and formalized the if-conversion process in the RK algorithm [PS91]. The RK algorithm determines the guard condition that will be assigned to each basic block and the operations required to evaluate the guard conditions. The algorithm is provably 26 correct for all types of control flow graphs, and generates a minimal set of condition evaluation instructions. <p> modified version of the GUARD mask assignment algorithm, supporting GUARDBOTH instructions. 4.3.2 An example of GUARD assignment To illustrate the operation of guard assignment algorithm consider the control flow graph in Figure 4.6. (This CFG is similar to the examples used by Ferrante et al. [FOW87] and Park and Schlansker <ref> [PS91] </ref>.) The CFG is annotated with the required GUARD instructions to achieve correct guarded execution as determined by the algorithm of Figure 4.4.
Reference: [PS94] <author> Dionisios N. Pnevmatikatos and Gurindar S. Sohi. </author> <title> Guarded Execution and Branch Prediction in Dynamic ILP Processors. </title> <booktitle> In Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 120-129, </pages> <address> Chicago, Illinois, </address> <month> April 18-21, </month> <year> 1994. </year>
Reference-contexts: The $safe addr register contains an memory address guaranteed not cause an exception.The guarded form of floating point instructions are synthesized in manner similar to div instruction. 16 register specifier. Based on this observation, Pnevmatikatos and Sohi <ref> [PS94] </ref> defined restricted guarding to include the guarded form only for ALU operations. <p> Within each execution stage, the multiscalar processor employed speculative execution and suppressed the commitment of speculative results until all the control dependences were resolved, implementing in this way a dynamic form of guarding. The guarding regions used by Pnevmatikatos and Sohi <ref> [PS94] </ref> are also similar to multiblocks, with the additional restriction that one of the two possible targets is restricted to be the fall through path. <p> instruction guards just a few instructions, the overhead will be large; if each GUARD specifies the guard condition for several instructions, the specification overhead will be relatively small. 5.2 Related work Several studies have addressed the effects of guarding on the instruction mix and the dynamic branch behavior of programs <ref> [PS94, MHB + 94, MHM + 95, CHPC95, Tys94b] </ref>. The first study to consider these effects was done by Pnevmatikatos and Sohi [PS94]. <p> The first study to consider these effects was done by Pnevmatikatos and Sohi <ref> [PS94] </ref>.
Reference: [PSR92] <author> Shien-Tai Pan, Kimming So, and Joseph T. Rahmeh. </author> <title> Improving the Accuracy of Dynamic Branch Prediction Using Branch Correlation. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 76-84, </pages> <address> Boston, Massachusetts, </address> <month> October 12-15, </month> <year> 1992. </year> <month> 114 </month>
Reference-contexts: The second is a 2-level adaptive predictor that uses an 8-bit pattern history register in the first level and 4K 2-bit counters in the second level; this configuration corresponds to the Correlation Branch Predictor of Pan et al. <ref> [PSR92] </ref> or GAp (8) according to the Yeh's and Patt's classification scheme [YP93]. 5.3.3 Benchmark programs For evaluation purposes we use 8 benchmark programs. These are the 6 integer SPEC92 benchmark programs [SPE91], namely Compress, Eqntott, Espresso, Gcc, Sc and Xlisp, along with Elvis and Wc.
Reference: [Rau94] <author> B. Ramakrishna Rau. </author> <title> Iterative Modulo Scheduling: An Algorithm For Software Pipelin-ing Loops. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchi-tecture, </booktitle> <pages> pages 63-74, </pages> <address> San Jose, California, </address> <month> November 30-December 2, </month> <year> 1994. </year>
Reference-contexts: In essence, the ability to overlap different control paths is similar to global scheduling techniques [Nic85, Smi92]. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining [RG91, BRRP82, Lam88, Ebc87], modulo scheduling <ref> [Rau94] </ref>, etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. Small basic blocks cause frequent changes in the flow of control, resulting in under-utilization of the instruction fetch bandwidth and the processor resources.
Reference: [RG91] <author> B. R. Rau and C. D. Glaeser. </author> <title> Some Scheduling techniques and an Easily Schedulable Horizontal Architecture for High Performance Scientific Computing. </title> <booktitle> In Proceedings of the Fourteenth Annual Workshop on Microprogramming, </booktitle> <pages> pages 183-198, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The general methodology is to apply if-conversion to loop bodies so they become free of control dependences, and then to apply other loop scheduling technique such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>. These machines provided instruction set and hardware support for guarded execution. <p> In essence, the ability to overlap different control paths is similar to global scheduling techniques [Nic85, Smi92]. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining <ref> [RG91, BRRP82, Lam88, Ebc87] </ref>, modulo scheduling [Rau94], etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. Small basic blocks cause frequent changes in the flow of control, resulting in under-utilization of the instruction fetch bandwidth and the processor resources.
Reference: [RL92] <author> Anne Rogers and Kai Li. </author> <title> Software Support for Speculative Loads. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 38-50, </pages> <address> Boston, Massachusetts, </address> <month> October 12-15, </month> <year> 1992. </year>
Reference-contexts: This functionality is very similar to sentinel scheduling proposed by Mahlke et al. [MCH + 92] and the Rogers and Li's hardware support for speculative loads <ref> [RL92] </ref>. However, the storage required to postpone the handling of exceptions (for example, the exception tags along each register) is part of the architectural state of the processor. Therefore, this storage must be saved and restored in contexts switched, external interrupts etc, requiring additional mechanisms to support these operations.
Reference: [Rus78] <author> R. M. Russel. </author> <title> The CRAY-1 Computer System. </title> <journal> Communications of the ACM, </journal> <volume> 21(1) </volume> <pages> 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: Dijkstra allowed an arbitrary Boolean conditions to be used as the guard condition of a high level statement. Vector processors such as the CDC STAR-100 [HT72], TI ASC [Wat72] and Cray-1 <ref> [Rus78] </ref> have long benefited from guarded execution expressed through the use of vector masks. A vector mask is an N-bit wide control register, where N is the number of elements in a vector register. <p> The opcode space limitations forced designers to introduce only a small number of guarded instructions. Many instruction set architectures such as the Cray-1 <ref> [Rus78] </ref>, the DEC Alpha [Com88], the SPARC V9 [Cas93], the MIPS R10000 [Pri94], the PowerPC [Cor94] and the Intel P6 [Gwe95] include a conditional move (cmov) instruction. <p> All these programs are integer intensive; we did not use any floating point intensive programs as we feel that the effectiveness of guarded execution for scientific programs has long being established for vector and VLIW architectures <ref> [RYYT89, DHB89, HT72, Wat72, Rus78] </ref>. For the SPEC92 benchmark programs we used the SPEC reference inputs, with the exception of Xlisp, for which we used a smaller input (we solved the seven queens problem instead of the nine queens problem specified by the SPEC92 reference input file).
Reference: [RYYT89] <author> B. Ramakrishna Rau, David W. L. Yen, Wei Yen, and Ross A. Towle. </author> <title> The Cydra 5 Departmental Supercomputer: Design Philosophies, Decisions, and Trade-offs. </title> <journal> IEEE Computer, </journal> <volume> 22(1) </volume> <pages> 12-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: In addition, branches restrict the ability of the compiler to schedule the code, making it harder for the execution hardware to discover the available parallelism. One way to alleviate these limitations, is to use if-conversion [AKPW83] and guarded execution <ref> [Hsu86, HD86, Mac93, MLC + 92, RYYT89, KSR94] </ref>. In guarded execution, instructions in conditional regions of code are augmented with a guard operand. This operand specifies whether the instruction should be executed or not, and the branch controlling the execution of that region can be removed from the code. <p> A later phase of PFC was responsible for mapping these converted loops into vector instructions using the vector masks if they were supported by the underlying architecture. VLIW machines, for example Cydra-5 <ref> [RYYT89, DHB89] </ref>, and the IBM VLIW machine [Ebc88], have also used if-conversion and guarded execution to facilitate the software pipelining of loops with conditional branches. <p> The problem is exacerbated by the instruction scheduler which, by rearranging instructions to increase parallelism, can increase the register lifetimes. One possible solution to this problem is to add a separate predicate register file <ref> [MLC + 92, RYYT89, KSR94] </ref>, to relieve the pressure on the general purpose registers. This solution, however, is a major architectural change and may not be easily incorporated into existing architectures. <p> This symmetry simplifies the compiler construction since no case analysis is needed to determine whether a code sequence can be expressed using the existing set of guarded instructions. Proposed methods for specifying guarded execution use an additional operand field for each instruction <ref> [MLC + 92, RYYT89, Mac93, KSR94] </ref>. An additional bit in the opcode specifies whether the guard condition should be true or false for the instruction to execute. <p> At least one compiler, the Cydrome compiler used by the Cydra 5 <ref> [RYYT89] </ref>, is reported [PS91] to produced incorrect code for certain control flow graphs. Park and Schlansker addressed this problem and formalized the if-conversion process in the RK algorithm [PS91]. <p> All these programs are integer intensive; we did not use any floating point intensive programs as we feel that the effectiveness of guarded execution for scientific programs has long being established for vector and VLIW architectures <ref> [RYYT89, DHB89, HT72, Wat72, Rus78] </ref>. For the SPEC92 benchmark programs we used the SPEC reference inputs, with the exception of Xlisp, for which we used a smaller input (we solved the seven queens problem instead of the nine queens problem specified by the SPEC92 reference input file).
Reference: [SHL92] <author> Michael D. Smith, Mark Horowitz, and Monica S. Lam. </author> <title> Efficient Superscalar Performance Through Boosting. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 248-259, </pages> <address> Boston, Massachusetts, </address> <month> October 12-15, </month> <year> 1992. </year>
Reference-contexts: outcome) cannot, in general, be moved across branches, unless it is safe, i.e., unless the compiler can guarantee that the computation will never cause an exception, or unless adequate hardware support is provided to buffer the exceptions until the condition is resolved (e.g., sentinel scheduling [MCH + 92], or boosting <ref> [SLH90, SHL92] </ref>). 1.1 What can we do about branches? A number of solutions have been proposed to deal with the limitations of branches. The general idea behind many techniques is to predict a likely direction for a branch and optimize the execution along that path.
Reference: [SK95] <author> Michael Schlansker and Vinod Kathail. </author> <title> Critical Path Reduction for Scalar Programs. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 57-69, </pages> <address> Ann Arbor, Michigan, </address> <month> November 29-December 1, </month> <year> 1995. </year>
Reference-contexts: The peeling factor for each loop can be accurately determined using profiling information. However, the usefulness of this optimization is limited when profiling information is not available, reducing the general purpose value of the transformation. 3.3.4 Control-tree height reduction Control-tree height reduction <ref> [SKA94, SK95] </ref> is a technique that reduces the time to evaluate complex condition expressions. The C programming language employs short-circuit semantics for control expression evaluation. Compilers also employ short circuit evaluation for expressions in an attempt to reduce the instruction count of the generated program. <p> Predicting and traversing multiple branches per cycle is indeed complicated, but if the branches are predicted one at a time, executing more than one branch per cycle (that is, verifying the corresponding predictions) is not very hard. Other research in VLIW embraces the execution of multiple branches per cycle <ref> [KSR94, SK95] </ref>. For example, the PlayDoh instruction set allows the execution of multiple branches per cycle, under the constraint that the compiler must guarantee that at most one of them can be taken.
Reference: [SKA94] <author> Michael Schlansker, Vinod Kathail, and Sadun Anik. </author> <title> Height Reduction of Control Recurrences for ILP Processors. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 40-51, </pages> <address> San Jose, California, </address> <month> November 30-December 2, </month> <year> 1994. </year>
Reference-contexts: The peeling factor for each loop can be accurately determined using profiling information. However, the usefulness of this optimization is limited when profiling information is not available, reducing the general purpose value of the transformation. 3.3.4 Control-tree height reduction Control-tree height reduction <ref> [SKA94, SK95] </ref> is a technique that reduces the time to evaluate complex condition expressions. The C programming language employs short-circuit semantics for control expression evaluation. Compilers also employ short circuit evaluation for expressions in an attempt to reduce the instruction count of the generated program.
Reference: [SLH90] <author> Michael D. Smith, Monica S. Lam, and Mark A. Horowitz. </author> <title> Boosting Beyond Static Scheduling in a Superscalar Processor. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 344-354, </pages> <address> Seattle, Washington, </address> <month> May 28-31, </month> <year> 1990. </year>
Reference-contexts: outcome) cannot, in general, be moved across branches, unless it is safe, i.e., unless the compiler can guarantee that the computation will never cause an exception, or unless adequate hardware support is provided to buffer the exceptions until the condition is resolved (e.g., sentinel scheduling [MCH + 92], or boosting <ref> [SLH90, SHL92] </ref>). 1.1 What can we do about branches? A number of solutions have been proposed to deal with the limitations of branches. The general idea behind many techniques is to predict a likely direction for a branch and optimize the execution along that path.
Reference: [Smi81] <author> James E. Smith. </author> <title> A Study of Branch Prediction Strategies. </title> <booktitle> In Proceedings of the 8th International Symposium on Computer Architecture, </booktitle> <pages> pages 135-148, </pages> <address> Minneapolis, Minnesota, </address> <month> May 12-14, </month> <year> 1981. </year>
Reference-contexts: Dynamic branch prediction utilizes information collected at run time to decide which is the most likely direction for a branch. Generally, dynamic branch prediction is based on maintaining a table of counters that record the past behavior of branches <ref> [Smi81, YP92, YP93] </ref> and a selection mechanism (called a divisor by Young et al. [YGS95]) that will determine which counter to use for the prediction 2 of each branch.
Reference: [Smi92] <author> Michael D. Smith. </author> <title> Support for Speculative Execution in High-Performance Processors. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: In essence, the ability to overlap different control paths is similar to global scheduling techniques <ref> [Nic85, Smi92] </ref>. The removal of control dependences also can increase the effectiveness of other code transformation techniques such as software pipelining [RG91, BRRP82, Lam88, Ebc87], modulo scheduling [Rau94], etc. For the instruction fetch unit of a processor, the larger, if-converted basic blocks allow for higher instruction fetch efficiency. <p> This code transformation is essentially global code motion similar to Nicolau's Percolation Scheduling [Nic85]. (An excellent overview of global scheduling techniques can be found in Michael Smith's thesis <ref> [Smi92] </ref>.) Promoted instructions are always executed and produce results, even when the actual guard condition is false.
Reference: [Soh90] <author> Gurindar S. Sohi. </author> <title> Instruction Issue Logic for High-Performance, Interruptible, Multiple Functional Unit, Pipelined Processors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(3) </volume> <pages> 349-359, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The GUARD instructions should be buffered in the Reorder Update Unit (RUU) <ref> [SV87, Soh90] </ref> or the equivalent structure, so that they will be executed 56 Interrupt Handling and GUARD Instructions Option Mechanism Comments Expose scalar mask register to the user Need a mechanism to freeze and resume the shifting of the scalar mask register and instructions to save/restore its value Flexible and guarantees <p> The guarded computation will be squashed (if needed) by the guard condition by the end of the decode stage. 6.1.2 Out-of-order execution model Our out-of-order processor uses a Reorder Update Unit (RUU) <ref> [SV87, Soh90] </ref> to achieve instruction buffering and register renaming. Guarded instructions are squashed during the decode stage if the guard condition is available.
Reference: [SPE91] <institution> SPEC newsletter, </institution> <month> December </month> <year> 1991. </year> <month> 115 </month>
Reference-contexts: These are the 6 integer SPEC92 benchmark programs <ref> [SPE91] </ref>, namely Compress, Eqntott, Espresso, Gcc, Sc and Xlisp, along with Elvis and Wc.
Reference: [SV87] <author> Gurindar S. Sohi and Sriram Vajapeyam. </author> <title> Instruction Issue Logic for High-Performance, Interruptible Pipelined Processors. </title> <booktitle> In Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 27-34, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> June 2-5, </month> <year> 1987. </year>
Reference-contexts: Instead the processor must treat all guarded instructions as selects between the old and the new value. This solution is essentially the out-of-order execution equivalent of Figure 2.5. To implement this solution, the Reservation Station entries [Tom67] or Reorder Update Unit entries <ref> [SV87] </ref> must be augmented with storage that will hold the old value of the destination register, in case the guard condition evaluates to false. The logic that determines whether an instruction is ready to be executed and produce a result must also be modified. <p> The GUARD instructions should be buffered in the Reorder Update Unit (RUU) <ref> [SV87, Soh90] </ref> or the equivalent structure, so that they will be executed 56 Interrupt Handling and GUARD Instructions Option Mechanism Comments Expose scalar mask register to the user Need a mechanism to freeze and resume the shifting of the scalar mask register and instructions to save/restore its value Flexible and guarantees <p> The guarded computation will be squashed (if needed) by the guard condition by the end of the decode stage. 6.1.2 Out-of-order execution model Our out-of-order processor uses a Reorder Update Unit (RUU) <ref> [SV87, Soh90] </ref> to achieve instruction buffering and register renaming. Guarded instructions are squashed during the decode stage if the guard condition is available.
Reference: [TLS90] <author> P. Tirumalai, M Lee, and M Schlansker. </author> <title> Parallelization of Loops With Exits on Pipelined architectures. </title> <booktitle> In Proceedings of Supercomputing '90, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: In the presence of long latency instructions such as multiplications or load instructions that may miss in the level-1 cache, this restriction can limit the performance. Code promotion, initially proposed by Tirumalai et al. <ref> [TLS90] </ref> and subsequently used by other research groups [MLC + 92, CHPC95, HMG + 95], bypasses this limitation by moving the guarded computation before the guard condition is evaluated and executing them unconditionally.
Reference: [Tom67] <author> R. M. Tomasulo. </author> <title> An Efficient Algorithm for Exploiting Multiple Arithmetic Units. </title> <journal> IBM Journal, </journal> <pages> pages 25-33, </pages> <month> January </month> <year> 1967. </year>
Reference-contexts: Instead the processor must treat all guarded instructions as selects between the old and the new value. This solution is essentially the out-of-order execution equivalent of Figure 2.5. To implement this solution, the Reservation Station entries <ref> [Tom67] </ref> or Reorder Update Unit entries [SV87] must be augmented with storage that will hold the old value of the destination register, in case the guard condition evaluates to false. The logic that determines whether an instruction is ready to be executed and produce a result must also be modified.
Reference: [TYS + 94a] <author> Adam R. Talcott, Wayne Yamamoto, Mauricio J. Serrano, Roger C. Wood, and Mario Nemirovsky. </author> <title> The Impact of Unresolved Branches on Branch Prediction Scheme Performance. </title> <booktitle> In Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 12-21, </pages> <address> Chicago, Illinois, </address> <month> April 18-21, </month> <year> 1994. </year>
Reference-contexts: Other researchers have also reported that predicting based on speculative branch history usually has a small impact on the prediction accuracy <ref> [TYS + 94a, HCP94] </ref>. Table 5.6 lists the dynamic prediction accuracies and the absolute number of mispredictions for the original and guarded version of the benchmark programs for a counter based predictor with 1024 2-bit counters. Guarding increases the prediction accuracies for all the programs except Elvis.
Reference: [Tys94b] <author> Gary Scott Tyson. </author> <title> The Effects of Predicated Execution on Branch Prediction. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 196-206, </pages> <address> San Jose, California, </address> <month> November 30-December 2, </month> <year> 1994. </year>
Reference-contexts: instruction guards just a few instructions, the overhead will be large; if each GUARD specifies the guard condition for several instructions, the specification overhead will be relatively small. 5.2 Related work Several studies have addressed the effects of guarding on the instruction mix and the dynamic branch behavior of programs <ref> [PS94, MHB + 94, MHM + 95, CHPC95, Tys94b] </ref>. The first study to consider these effects was done by Pnevmatikatos and Sohi [PS94]. <p> They found that this profile-based if-conversion can eliminate more than 60% of the mispredictions for the programs Compress, Eqntott and Sc and estimated that it could eliminate 40% of the misprediction for Gcc. Tyson <ref> [Tys94b] </ref> considered a form of predication where instructions covered by a short forward branch are transformed into guarded instructions. This transformation can be performed either statically by the compiler/assembler, or dynamically by the processor.
Reference: [Wat72] <author> W. J. Watson. </author> <title> The TI-ASC A Highly Modular and Flexible Super Computer Architecture. </title> <booktitle> In Proceedings of the AFIPS Fall Joint Computer Conference, </booktitle> <pages> pages 221-228, </pages> <year> 1972. </year>
Reference-contexts: Dijkstra allowed an arbitrary Boolean conditions to be used as the guard condition of a high level statement. Vector processors such as the CDC STAR-100 [HT72], TI ASC <ref> [Wat72] </ref> and Cray-1 [Rus78] have long benefited from guarded execution expressed through the use of vector masks. A vector mask is an N-bit wide control register, where N is the number of elements in a vector register. <p> All these programs are integer intensive; we did not use any floating point intensive programs as we feel that the effectiveness of guarded execution for scientific programs has long being established for vector and VLIW architectures <ref> [RYYT89, DHB89, HT72, Wat72, Rus78] </ref>. For the SPEC92 benchmark programs we used the SPEC reference inputs, with the exception of Xlisp, for which we used a smaller input (we solved the seven queens problem instead of the nine queens problem specified by the SPEC92 reference input file).
Reference: [WMHR93] <author> Nancy J. Warter, Scott A. Mahlke, Wen-Mei W. Hwu, and B. Ramakrishna Rau. </author> <title> Reverse If-Conversion. </title> <booktitle> In Proceedings of the SIGPLAN 1993 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 290-299, </pages> <year> 1993. </year>
Reference-contexts: These algorithms can be used almost unchanged, with minor modifications that depend on the idiosyncrasies of the underlying execution hardware. If the target instruction set does not support guarded instructions, the necessary branches can be introduced in the scheduled code using the Reverse if-conversion technique <ref> [WMHR93] </ref>.
Reference: [YGS95] <author> Cliff Young, Nicholas Gloy, and Michael D. Smith. </author> <title> A Comparative Analysis of Schemes for Correlated Branch Prediction. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 276-286, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year>
Reference-contexts: Generally, dynamic branch prediction is based on maintaining a table of counters that record the past behavior of branches [Smi81, YP92, YP93] and a selection mechanism (called a divisor by Young et al. <ref> [YGS95] </ref>) that will determine which counter to use for the prediction 2 of each branch. Because the direction of a branch is not by itself sufficient to allow the instruction fetch mechanism to commence fetching new instructions, a Branch Target Buffer is also used to cache branch target address [LS84].
Reference: [YMP93] <author> Tse-Yu Yeh, Deborah T. Marr, and Yale N. Patt. </author> <title> Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache. </title> <booktitle> In Proceedings of ICS-7, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Processors employing dynamic branch prediction, can also benefit from guarding. For programs with small basic blocks, multiple predictions per cycle may be required to find enough instructions and to fully utilize the pipeline resources <ref> [YMP93] </ref>. The larger basic blocks of the if-converted code keep the pipeline more full, reducing the importance of multiple predictions per cycle. A smaller number of predictions usually generates fewer mispredictions.
Reference: [YP92] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> Alternative Implementations of Two-Level Adaptive Branch Prediction. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 124-134, </pages> <address> Gold Coast, Australia, </address> <month> May 19-21, </month> <year> 1992. </year>
Reference-contexts: Dynamic branch prediction utilizes information collected at run time to decide which is the most likely direction for a branch. Generally, dynamic branch prediction is based on maintaining a table of counters that record the past behavior of branches <ref> [Smi81, YP92, YP93] </ref> and a selection mechanism (called a divisor by Young et al. [YGS95]) that will determine which counter to use for the prediction 2 of each branch.
Reference: [YP93] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A Comparison of Dynamic Branch Predictors that Use Two Levels of Branch History. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 257-266, </pages> <address> San Diego, California, </address> <month> May 17-19, </month> <year> 1993. </year>
Reference-contexts: Dynamic branch prediction utilizes information collected at run time to decide which is the most likely direction for a branch. Generally, dynamic branch prediction is based on maintaining a table of counters that record the past behavior of branches <ref> [Smi81, YP92, YP93] </ref> and a selection mechanism (called a divisor by Young et al. [YGS95]) that will determine which counter to use for the prediction 2 of each branch. <p> The second is a 2-level adaptive predictor that uses an 8-bit pattern history register in the first level and 4K 2-bit counters in the second level; this configuration corresponds to the Correlation Branch Predictor of Pan et al. [PSR92] or GAp (8) according to the Yeh's and Patt's classification scheme <ref> [YP93] </ref>. 5.3.3 Benchmark programs For evaluation purposes we use 8 benchmark programs. These are the 6 integer SPEC92 benchmark programs [SPE91], namely Compress, Eqntott, Espresso, Gcc, Sc and Xlisp, along with Elvis and Wc.
References-found: 75

