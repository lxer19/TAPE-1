URL: http://www.cs.arizona.edu/people/debray/papers/cfa.ps
Refering-URL: http://www.cs.arizona.edu/jc/
Root-URL: http://www.cs.arizona.edu
Email: Email: fdebray, toddg@cs.arizona.edu  
Title: Interprocedural Control Flow Analysis of First-Order Programs with Tail Call Optimization  
Author: Saumya K. Debray and Todd A. Proebsting 
Date: December 5, 1996  
Address: Tucson, AZ 85721, USA.  
Affiliation: Department of Computer Science The University of Arizona  
Abstract: The analysis of control flow Involves figuring out where returns will go. How this may be done With items LR-0 and -1 Is what in this paper we show. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Most code optimizations depend on control flow analysis, typically expressed in the form of a control flow graph <ref> [1] </ref>. Traditional algorithms construct intraprocedural flow graphs, which do not account for control flow between procedures. Optimizations that depend on this limited information cannot consider the behavior of other procedures. Interprocedural versions of these optimizations must capture the flow of control across procedure boundaries. <p> and Notation We assume that a program consists of a set of procedure definitions, together with an entry point procedure. (It is straightforward to extend these ideas to accommodate multiple entry points.) Since we assume a first-order language, the intraprocedural control flow can be modelled by a control flow graph <ref> [1] </ref>. <p> RetLbl (p) = f` j (q 0 ; w; $) ` ? (p; w 0 ; `fi)g It is a direct consequence of Theorem 4.1 that this set is precisely the FOLLOW set of p in the control flow grammar of the program (see <ref> [1] </ref> for the definition of FOLLOW sets): Theorem 5.1 For any procedure p in a program P , RetLbl (p) = FOLLOW (p). Proof Suppose the program P has entry point S. <p> Compute FOLLOW sets for the nonterminals of G P . 3. Construct a partial control flow graph for P , without accounting for control transfers due to procedure returns. This is done by adding edges corresponding to intra-procedural control transfers, as in <ref> [1] </ref>, together with an edge from each call block and tail-call block to the entry node of the corresponding called function. 4. <p> It is well-known that the number of states in such a DFA can become very large, but that by judiciously merging certain states (those with a common "kernel", see <ref> [1] </ref>) the number of states can be reduced considerably without significantly sacrificing the information contained in the DFA. Parsers that are constructed in this way are known as LALR (1) parsers, which can be built efficiently (without initially building the LR (1) DFA).
Reference: [2] <author> J.-D. Choi, M. Burke, and P. Carini, </author> <title> "Efficient Flow-Sensitive Interprocedural Computation of Pointer-Induced Aliases and Side Effects", </title> <booktitle> Proc. 20th. ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1993, </year> <pages> pp. 232-245. </pages>
Reference-contexts: As a result, the analysis can infer spurious pointer aliases by propagating information from one call site back to a different call site. Using context-sensitive interprocedural analyses avoids this by maintaining information about where a call came from <ref> [2, 9, 23] </ref>, which is precisely the information provided by 1-CFA.
Reference: [3] <author> K. De Bosschere and S. K. Debray, </author> <title> "alto : A Link-Time Optimizer for the DEC Alpha", </title> <type> Technical Report 96-15, </type> <institution> Dept. of Computer Science, The University of Arizona, Tucson, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: As a specific example of the utility of context-sensitive flow information, our experiments with dead code elimination based on interprocedural liveness analysis, in the context of the alto link-time optimizer <ref> [3] </ref> applied to a number of SPEC benchmarks, indicate that compared to the number of register loads and stores that can be deleted based on context-insensitive liveness information, an additional 5%-8% can be deleted using context-sensitive liveness information.
Reference: [4] <author> S. K. Debray and T. </author> <title> A Proebsting, "Interprocedural Control Flow Analysis of First-Order Programs with Tail Call Optimization", </title> <type> Technical Report 96-20, </type> <institution> Dept. of Computer Science, The University of Arizona, Tucson, </institution> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Section 7 illustrates these ideas with a nontrivial example. Section 8 discusses tradeoffs between efficiency and precision. Proofs of the theorems may be found in <ref> [4] </ref>. 2 Definitions and Notation We assume that a program consists of a set of procedure definitions, together with an entry point procedure. (It is straightforward to extend these ideas to accommodate multiple entry points.) Since we assume a first-order language, the intraprocedural control flow can be modelled by a control
Reference: [5] <author> N. Heintze, </author> <title> "Control Flow Analysis and Type Systems", </title> <type> Technical Report CMU-CS-94-227, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Clearly, some nontrivial control flow analysis is necessary to determine this. Most of the work to date on control flow analysis has focused on higher-order languages: Shivers [18, 19] and Jagannathan and Weeks [8] use abstract interpretation for this purpose, while Heintze <ref> [5] </ref> and Tang and Jouvelot [20, 21] use type-based analyses. These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages.
Reference: [6] <author> F. Henglein and J. Jtrgensen, </author> <title> "Formally Optimal Boxing", </title> <booktitle> Proc. 21st. ACM Symp. on Principles of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> Jan. </month> <year> 1994, </year> <pages> pp. 213-226. 13 </pages>
Reference-contexts: The issue of maintaining untagged values has received considerable attention in recent years in the context of strongly typed polymorphic languages <ref> [6, 11, 14] </ref>. Using explicit "representation types," this work relies on the type system to propagate data representation information through the program.
Reference: [7] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The language accepted by M P is then the set of sequences of labels that control can jump to on procedure returns during an execution of the program P . Let the transitions of a pushdown automaton be denoted as follows <ref> [7] </ref>: if, from a configuration where it is in state q and has w in its input and ff on its stack, it can make a transition to state q 0 with input string w 0 and with fi on its stack, we write (q; w; ff) ` (q 0 ; <p> Let ) lm denote the leftmost derivation relation in G P . The following theorem, whose proof closely resembles the standard proof of the equivalence between pushdown automata and context-free languages <ref> [7] </ref>, expresses the intuition that the control flow grammar of a program mirrors the behavior of its control flow automaton: Theorem 4.1 Given a program P with entry point S, control flow grammar G P and control flow automaton M P , lm xAfi if and only if (S; xw; $) <p> We know, from parsing theory, that given a control flow grammar G P with variables V and terminals T , there is a nondeterministic finite automaton (NFA) (Q; ; ffi; q 0 ; Q) that recognizes viable prefixes of G <ref> [7] </ref>.
Reference: [8] <author> S. Jagannathan and S. Weeks, </author> <title> "A Unified Treatment of Flow Analysis in Higher-Order Languages", </title> <booktitle> Proc. 22nd. ACM Symp. on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> Jan. </month> <year> 1995, </year> <pages> pp. 393-407. </pages>
Reference-contexts: Clearly, some nontrivial control flow analysis is necessary to determine this. Most of the work to date on control flow analysis has focused on higher-order languages: Shivers [18, 19] and Jagannathan and Weeks <ref> [8] </ref> use abstract interpretation for this purpose, while Heintze [5] and Tang and Jouvelot [20, 21] use type-based analyses. These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages.
Reference: [9] <author> W. Landi and B. G. Ryder, </author> <title> "A Safe Approximate Algorithm for Interprocedural Pointer Aliasing", </title> <booktitle> Proc. ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 235-248. </pages>
Reference-contexts: As a result, the analysis can infer spurious pointer aliases by propagating information from one call site back to a different call site. Using context-sensitive interprocedural analyses avoids this by maintaining information about where a call came from <ref> [2, 9, 23] </ref>, which is precisely the information provided by 1-CFA.
Reference: [10] <author> T. Lindgren, </author> <title> "Control Flow Analysis of Prolog", </title> <booktitle> Proc. 1995 International Symposium on Logic Programming, </booktitle> <month> Dec. </month> <year> 1995, </year> <pages> pp. 432-446. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: As a pragmatic issue, therefore, we are interested in "ordinary" first-order programs: our aim is to account for interprocedural control flow in such programs in the presence of tail call optimization. To our knowledge, the only other work addressing this issue is that of Lindgren <ref> [10] </ref>, who uses set-based analysis for control flow analysis of Prolog. Unlike Lindgren's work, our analyses can maintain context information (see Section 6).
Reference: [11] <author> X. Leroy, </author> <title> "Unboxed objects and polymorphic typing", </title> <booktitle> Proc. 19th. ACM Symp. on Principles of Programming Languages, </booktitle> <address> Albuquerque, NM, </address> <month> Jan. </month> <year> 1992, </year> <pages> pp. 177-188. </pages>
Reference-contexts: The issue of maintaining untagged values has received considerable attention in recent years in the context of strongly typed polymorphic languages <ref> [6, 11, 14] </ref>. Using explicit "representation types," this work relies on the type system to propagate data representation information through the program.
Reference: [12] <author> J. C. Peterson, </author> <title> "Untagged Data in Tagged Environments: Choosing Optimal Representations at Compile Time", </title> <booktitle> Proc. Functional Programming Languages and Computer Architecture, </booktitle> <address> London, </address> <month> Sept. </month> <year> 1989, </year> <pages> pp. 89-99. </pages>
Reference-contexts: As a result, it is difficult to guarantee that the "optimized" program is, in fact, more efficient than the unoptimized version. Also, the idea does not extend readily to dynamically typed languages. Peterson <ref> [12] </ref> takes a procedure's control flow graph, and determines the optimal placement of representation conversion operations, based on basic block execution frequencies and conversion operation costs. As given, this is an intraprocedural optimization. For many programs, unboxing across procedure calls yields significant performance improvements.
Reference: [13] <author> L. C. Paulson, </author> <title> ML for the Working Programmer, </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: references, no additional precision is measured." However, if a context-sensitive dataflow analysis is deemed necessary for a language implementation with tail call optimization, the control flow analysis described here can be used to provide the necessary support. 7 A Larger Example Consider the following program, adapted from Section 4.17 of <ref> [13] </ref>, to determine whether a propositional formula in conjunctive normal form is a tautology: fun taut (Conj (p,q)) = taut (p) andalso taut (q) | taut (p) = ( [] &lt;&gt; int (pos (p), neg (p)) ); fun pos (Atom (a)) = [a] | pos (Neg (Atom (a))) = [] | <p> It is usually considerably more efficient than 1-CFA. As an example, for the tautology checker program of Section 7, the viable prefix DFA constructed from LR (1) items contains 97 states, while that constructed from LALR (1) items contains 55 states; if we consider the entire tautology checker from <ref> [13] </ref>, which works for arbitrary propositional formulae, the LR (1) viable prefix DFA has 304 states while the LALR (1) DFA has 112 states.
Reference: [14] <author> S. Peyton Jones and J. Launchbury, </author> <title> "Unboxed values as first class citizens in a non-strict functional language", </title> <booktitle> Proc. Functional Programming Languages and Computer Architecture 1991, </booktitle> <pages> pp. 636-666. </pages>
Reference-contexts: The issue of maintaining untagged values has received considerable attention in recent years in the context of strongly typed polymorphic languages <ref> [6, 11, 14] </ref>. Using explicit "representation types," this work relies on the type system to propagate data representation information through the program.
Reference: [15] <author> T. A. Proebsting and S. A. Watterson, </author> <title> "Filter Fusion", </title> <booktitle> Proc. 23rd. ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1996, </year> <pages> pp. 119-129. </pages>
Reference-contexts: The benefits of this optimization include a reduction in the number of jump instructions executed, with a concomitant decrease in pipeline "bubbles," as well as potentially improved opportunities for better instruction scheduling in the enlarged basic block resulting from the optimization. Our experience with filter fusion <ref> [15] </ref> indicates that this optimization can be of fundamental importance for performance in applications involving automatically generated source code. Consider the main/extract/reverse program from Section 1. A partial flow graph for this program is given in Figure 1.
Reference: [16] <author> E. Ruf, </author> <title> "Context-Insensitive Alias Analysis Reconsidered", </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 13-22. </pages>
Reference-contexts: Our experiments with interprocedural liveness analysis indicate that there are situations when such analyses can lead to a noticeable improvement in the code generated. On the other hand, in comparing context-sensitive and context-insensitive alias analyses due to indirect memory references through pointers, Ruf observes <ref> [16] </ref> that ". . . the context-sensitive analysis does compute more precise alias relationships at some program points.
Reference: [17] <author> M. Sharir and A. Pnueli, </author> <title> "Two Approaches to Interprocedural Dataflow Analysis", in Program Flow Analysis: Theory and Applications, </title> <editor> eds. S. S. Muchnick and N. D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <year> 1981, </year> <pages> pp. 189-233. </pages>
Reference-contexts: A control flow analysis that keeps track of the top k return addresses on the stack of M P is called a k-th.-order control flow analysis, or k-CFA (this corresponds to the "call-strings approach" of Sharir and Pnueli <ref> [17] </ref>). In this section, we focus our attention on first-order control flow analysis, or 1-CFA. In the previous section, we showed that the FOLLOW sets of the control flow grammar give 0-CFA information.
Reference: [18] <author> O. Shivers, </author> <title> "Control Flow Analysis in Scheme", </title> <booktitle> Proc. SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 164-174. </pages>
Reference-contexts: Clearly, some nontrivial control flow analysis is necessary to determine this. Most of the work to date on control flow analysis has focused on higher-order languages: Shivers <ref> [18, 19] </ref> and Jagannathan and Weeks [8] use abstract interpretation for this purpose, while Heintze [5] and Tang and Jouvelot [20, 21] use type-based analyses. These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages.
Reference: [19] <author> O. Shivers, </author> <title> Control Flow Analysis of Higher-Order Languages, </title> <type> PhD. Dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <note> Also available as Technical Report CMU-CS-91-145, </note> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Clearly, some nontrivial control flow analysis is necessary to determine this. Most of the work to date on control flow analysis has focused on higher-order languages: Shivers <ref> [18, 19] </ref> and Jagannathan and Weeks [8] use abstract interpretation for this purpose, while Heintze [5] and Tang and Jouvelot [20, 21] use type-based analyses. These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages.
Reference: [20] <author> Y. Tang and P. Jouvelot, </author> <title> "Control-Flow Effects for Escape Analysis", </title> <booktitle> Proc. WSA 92, </booktitle> <address> Bordeaux, France, </address> <year> 1992. </year>
Reference-contexts: Clearly, some nontrivial control flow analysis is necessary to determine this. Most of the work to date on control flow analysis has focused on higher-order languages: Shivers [18, 19] and Jagannathan and Weeks [8] use abstract interpretation for this purpose, while Heintze [5] and Tang and Jouvelot <ref> [20, 21] </ref> use type-based analyses. These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages.
Reference: [21] <author> Y. Tang and P. Jouvelot, </author> <title> "Separate Abstract Interpretation for Control Flow Analysis", </title> <booktitle> Proc. </booktitle> <address> TACS-94, </address> <year> 1994. </year>
Reference-contexts: Clearly, some nontrivial control flow analysis is necessary to determine this. Most of the work to date on control flow analysis has focused on higher-order languages: Shivers [18, 19] and Jagannathan and Weeks [8] use abstract interpretation for this purpose, while Heintze [5] and Tang and Jouvelot <ref> [20, 21] </ref> use type-based analyses. These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages.
Reference: [22] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee, </author> <title> "TIL: A Type-Directed Optimizing Compiler for ML", </title> <booktitle> Proc. SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1996, </year> <pages> pp. 181-192. </pages>
Reference-contexts: These analyses are very general, but very complex. Many widely used languages, such as Sisal and Prolog, are first-order languages. Furthermore, even for higher-order languages, specific programs often use only first-order constructs, or can have most higher-order constructs removed via transformations such as inlining and uncurrying <ref> [22] </ref>. As a pragmatic issue, therefore, we are interested in "ordinary" first-order programs: our aim is to account for interprocedural control flow in such programs in the presence of tail call optimization.
Reference: [23] <author> R. P. Wilson and M. S. Lam, </author> <title> "Efficient Context-Sensitive Pointer Analysis for C Programs", </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 1-12. 14 </pages>
Reference-contexts: As a result, the analysis can infer spurious pointer aliases by propagating information from one call site back to a different call site. Using context-sensitive interprocedural analyses avoids this by maintaining information about where a call came from <ref> [2, 9, 23] </ref>, which is precisely the information provided by 1-CFA.
References-found: 23

