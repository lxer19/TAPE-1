URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-49.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-49.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <note> (To Appear in ACM Transaction On Programming Languages and Systems). 23 </note>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
Reference: [2] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]). <p> Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. <ref> [2, 6, 15, 16, 26] </ref>), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. <p> The actual sharing relation can be derived from these two components. In our particular example, the only sharing is the couple (6; 6) which expresses that variable Y 1 shares a variable with itself. 5.2.2 The Domain Mode The domain of [24] is a reformulation of the domain of <ref> [2] </ref>. The domain could be viewed as a simplification of the elaborate domain where the pattern information has been omitted and the sharing has been simplified to an equivalence relation. Only three modes are considered: ground, var and any. <p> The original algorithm is a top-down algorithm computing a small subset of the least fixpoint necessary to answer the query. It works at a fine granularity, i.e. it keeps multiple input/output patterns for each predicate. Both algorithms can be seen as particular implementations of Bruynooghe's operational framework <ref> [2] </ref> or, alternatively, as instantiations of a universal top-down fixpoint algorithm [17]. The generic abstract interpretation algorithm is, to our knowledge, the most efficient generic algorithm available for abstract interpretation of Prolog programs. We also use the reexecution algorithm of [19].
Reference: [3] <author> M. Bruynooghe and al. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proc. 1987 Symposium on Logic Programming, </booktitle> <pages> pages 192-204, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
Reference: [4] <author> M Bruynooghe and G Janssens. </author> <title> An Instance of Abstract Interpretation: Integrating Type and Mode Inferencing. </title> <booktitle> In Proc. of the Fifth International Conference on Logic Programming, </booktitle> <pages> pages 669-683, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. <ref> [4, 14, 25] </ref>) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> The domain is more sophisticated than the sharing domains of, for instance, [14, 25] and than the mode domains of, for instance, [29, 13]. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens <ref> [4] </ref> where a pattern component has been added. The domain is fully described in [24] which contains also the proofs of monotonicity and consistency. The key concept in the representation of the substitutions in this domain is the notion of a subterm.
Reference: [5] <author> R.E. Bryant. </author> <title> Graph Based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(8) </volume> <pages> 677-691, </pages> <year> 1986. </year>
Reference-contexts: In this paper, we present an implementation of the domain Prop and we use it to instantiate a fast generic abstract interpretation algorithm for Prolog [16, 18, 12]. The key feature of our implementation of Prop is the use of ordered binary decision graphs <ref> [5] </ref> to represent Boolean functions in a compact way. The overall implementation (about 6000 lines of C) has been systematically evaluated and its efficiency and accuracy have been compared with two other abstract domains: the domain Mode (mode, same-value, sharing) and the domain Pattern (mode, same-value, sharing, pattern). <p> ^ x2 ^ x1 59 Exit EXTG x3 ^ x2 ^ x1 60 Exit RESTRC x2 ^ x1 61 Exit UNION x2 ^ x1 62 Exit clause 1 9 4 Implementation Our implementation of the domain Prop uses ordered binary decision graphs (OBDG) as a canonical form for Booleans functions <ref> [5] </ref>. We review the main concepts here. OBDGs require a total ordering on the variables. The ordering can have a significant impact on the size of Boolean functions. <p> Since there is no obvious good ordering for abstract interpretation, our implementation simply uses x 1 &lt; x 2 &lt; . . . &lt; x n . The data structure underlying OBDGs is a binary tree with a number of restrictions. Definition 9 <ref> [5] </ref> A function graph is a rooted, directed graph with vertex set V containing two types of vertices. <p> Futhermore, for any nonterminal vertex v, if low (v) is also nonterminal, then index (v) &gt; index (low (v)). Similarly, if high (v) is nonterminal, then index (v) &gt; index (high (v)). The correspondance between function graphs and Boolean functions is given by the following definitions. Definition 10 <ref> [5] </ref> A function graph G having root vertex v denotes a function f v defined recursively as 1. if v is a terminal vertex, then f v = true if value (v) = true. f v = f alse otherwise. 2. if v is a nonterminal vertex with index (v) = <p> Definition 11 <ref> [5] </ref> A function graph G is an ordered binary decision graph iff it contains no vertex v with low (v) = high (v) nor does it contain distinct vertices v and v 0 such that the subgraph rooted by v and v 0 are isomorphic 1 . [5] describes several algorithms <p> Definition 11 <ref> [5] </ref> A function graph G is an ordered binary decision graph iff it contains no vertex v with low (v) = high (v) nor does it contain distinct vertices v and v 0 such that the subgraph rooted by v and v 0 are isomorphic 1 . [5] describes several algorithms for reduction, restriction, and composition of OBDGs. Other algorithms (e.g. elimination, comparison) can be designed along the same principles. The main complexity results are given in Table 1.
Reference: [6] <author> C. Codognet, P. Codognet, and J.M. Corsini. </author> <title> Abstract Interpretation of Concurrent Logic Languages. </title> <booktitle> In Proceedings of the North-American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, Tx, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. <ref> [2, 6, 15, 16, 26] </ref>), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22].
Reference: [7] <author> A. Corsini and G. </author> <title> File. A Complete Framework for the Abstract Interpretation of Logic Programs: Theory and Applications. </title> <type> Research report, </type> <institution> University of Padova, Italy, </institution> <year> 1989. </year>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
Reference: [8] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional formulas as abstract domain for groundness analysis. </title> <booktitle> In Proc. Sixth Annual IEEE Symposium on Logic in Computer Science (LICS'91), </booktitle> <pages> pages 322-327, </pages> <year> 1991. </year>
Reference-contexts: The domain is intended to compute groundness information in Prolog programs. It is conceptually simple and elegant since abstract substitutions are represented by Boolean functions built using the logical connectives ,; _; ^. The domain has been further investigated in <ref> [8] </ref> and related to other abstract domains in [9]. Although the domain is properly understood from a theoretical standpoint, many practical questions regarding its efficiency and accuracy remain to be answered. In particular, the efficiency of Prop has been subject to much debate.
Reference: [9] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Comparison of abstract interpretations. </title> <booktitle> In Proc. 19th International; Colloquium on Automata, Languages and Programming (ICALP'92), </booktitle> <year> 1992. </year>
Reference-contexts: The domain is intended to compute groundness information in Prolog programs. It is conceptually simple and elegant since abstract substitutions are represented by Boolean functions built using the logical connectives ,; _; ^. The domain has been further investigated in [8] and related to other abstract domains in <ref> [9] </ref>. Although the domain is properly understood from a theoretical standpoint, many practical questions regarding its efficiency and accuracy remain to be answered. In particular, the efficiency of Prop has been subject to much debate.
Reference: [10] <author> A. Deutsch. </author> <title> A Storeless Model of Aliasing and its Abstraction using Finite Representations of Right-Regular Equivalence Relations. </title> <booktitle> In Fourth IEEE International Conference on Computer Languages (ICCL'92), </booktitle> <address> San Fransisco, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: The experimental results indicate that Prop behaves very well once again. A number of programs (e.g. CS, Disj) are significantly slower but the computation times 4 See <ref> [10] </ref> for a definition of on-line analysis and a comparison with usual global analysis approaches. 21 Program Calls Var MaxV MeanV Size MaxS MeanS MaxS/MaxV MeanS/MeanV Append 7 36 6 5.14 53 14 7.57 2.33 1.47 CS 392 7125 42 18.18 14375 580 36.67 13.81 2.02 Disj 330 5838 25 17.69
Reference: [11] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1-2):75-93, </volume> <year> 1990. </year>
Reference-contexts: The program cs is a cutting-stock program taken from [28]. It is a program used to generate a number of configurations representing various ways of cutting a wood board into small shelves. The program uses, in various ways, the nondeterminism of Prolog. The program Disj is taken from <ref> [11] </ref> and is the generate and test equivalent of a constraint program used to solve a disjunctive scheduling problem. This is also a program using the nondeterminism of Prolog. The program Read is the tokeniser and reader written by R. O'keefe and D.H.D. Warren for Prolog.
Reference: [12] <author> V. Englebert, B. Le Charlier, D. Roland, and P. Van Hentenryck. </author> <title> Generic Abstract Interpretation Algorithms for Prolog: Two Optimization Techniques and Their Experimental Evaluation. </title> <booktitle> In Fourth International Symposium on Programming Language Implementation and Logic Programming (PLILP-92), </booktitle> <address> Leuven (Belgium), </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. <ref> [13, 18, 12, 29] </ref>). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> In this paper, we present an implementation of the domain Prop and we use it to instantiate a fast generic abstract interpretation algorithm for Prolog <ref> [16, 18, 12] </ref>. The key feature of our implementation of Prop is the use of ordered binary decision graphs [5] to represent Boolean functions in a compact way. <p> The abstract interpretation algorithm used to obtain the trace is the so-called prefix optimization algorithm which avoids reconsidering clauses and prefixes of clauses by keeping an advanced dependency graph <ref> [12] </ref>. The initial query has a first argument which is ground and a second argument which is a variable. <p> The same restriction applies to sharing constraints. Moreover algorithms for primitive operations are significantly different. They are much simpler and the loss of accuracy is significant. 5.3 The Generic Abstract Interpretation Algorithm The algorithm used in the experimental results is the so-called "prefix optimization" algorithm <ref> [12] </ref>. It is essentially our original algorithm [16, 18] augmented with an advanced dependency graph to avoid recomputing clauses or prefixes of clauses that would not bring additional information. The original algorithm is a top-down algorithm computing a small subset of the least fixpoint necessary to answer the query. <p> Future work will be devoted to two main issues. First abstract operations in Prop seem to take longer than in Pattern. Hence an optimization such the caching of the operations <ref> [12] </ref> should be even more interesting in this case. Second it would be interesting to combine Prop with a pattern component.
Reference: [13] <author> M. Hermenegildo, R. Warren, and S. Debray. </author> <title> Global Flow Analysis as a Practical Compilation Tool. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4) </volume> <pages> 349-367, </pages> <year> 1992. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. <ref> [13, 18, 12, 29] </ref>). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> The domain is more sophisticated than the sharing domains of, for instance, [14, 25] and than the mode domains of, for instance, <ref> [29, 13] </ref>. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [4] where a pattern component has been added. The domain is fully described in [24] which contains also the proofs of monotonicity and consistency.
Reference: [14] <author> D. Jacobs and A. Langen. </author> <title> Accurate and Efficient Approximation of Variable Aliasing in Logic Programs. </title> <booktitle> In Proceedings of the North-American Conference on Logic Programming (NACLP-89), </booktitle> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. <ref> [4, 14, 25] </ref>) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> The domain is more sophisticated than the sharing domains of, for instance, <ref> [14, 25] </ref> and than the mode domains of, for instance, [29, 13]. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [4] where a pattern component has been added. The domain is fully described in [24] which contains also the proofs of monotonicity and consistency.
Reference: [15] <author> T. Kanamori and T. Kawamura. </author> <title> Analysing Success Patterns of Logic Programs by Abstract Hybrid Interpretation. </title> <type> Technical report, </type> <institution> ICOT, </institution> <year> 1987. </year> <month> 24 </month>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. <ref> [2, 6, 15, 16, 26] </ref>), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22].
Reference: [16] <author> B. Le Charlier, K. Musumbu, and P. Van Hentenryck. </author> <title> A Generic Abstract Interpretation Al--gorithm and its Complexity Analysis (Extended Abstract). </title> <booktitle> In Eighth International Conference on Logic Programming (ICLP-91), </booktitle> <address> Paris (France), </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. <ref> [2, 6, 15, 16, 26] </ref>), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. <p> In this paper, we present an implementation of the domain Prop and we use it to instantiate a fast generic abstract interpretation algorithm for Prolog <ref> [16, 18, 12] </ref>. The key feature of our implementation of Prop is the use of ordered binary decision graphs [5] to represent Boolean functions in a compact way. <p> Moreover algorithms for primitive operations are significantly different. They are much simpler and the loss of accuracy is significant. 5.3 The Generic Abstract Interpretation Algorithm The algorithm used in the experimental results is the so-called "prefix optimization" algorithm [12]. It is essentially our original algorithm <ref> [16, 18] </ref> augmented with an advanced dependency graph to avoid recomputing clauses or prefixes of clauses that would not bring additional information. The original algorithm is a top-down algorithm computing a small subset of the least fixpoint necessary to answer the query.
Reference: [17] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> A Universal Top-Down Fixpoint Algorithm. </title> <type> Technical Report CS-92-25, </type> <institution> CS Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: It works at a fine granularity, i.e. it keeps multiple input/output patterns for each predicate. Both algorithms can be seen as particular implementations of Bruynooghe's operational framework [2] or, alternatively, as instantiations of a universal top-down fixpoint algorithm <ref> [17] </ref>. The generic abstract interpretation algorithm is, to our knowledge, the most efficient generic algorithm available for abstract interpretation of Prolog programs. We also use the reexecution algorithm of [19].
Reference: [18] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <booktitle> In Fourth IEEE International Conference on Computer Languages (ICCL'92), </booktitle> <address> San Fransisco, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. <ref> [13, 18, 12, 29] </ref>). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> In this paper, we present an implementation of the domain Prop and we use it to instantiate a fast generic abstract interpretation algorithm for Prolog <ref> [16, 18, 12] </ref>. The key feature of our implementation of Prop is the use of ordered binary decision graphs [5] to represent Boolean functions in a compact way. <p> Moreover algorithms for primitive operations are significantly different. They are much simpler and the loss of accuracy is significant. 5.3 The Generic Abstract Interpretation Algorithm The algorithm used in the experimental results is the so-called "prefix optimization" algorithm [12]. It is essentially our original algorithm <ref> [16, 18] </ref> augmented with an advanced dependency graph to avoid recomputing clauses or prefixes of clauses that would not bring additional information. The original algorithm is a top-down algorithm computing a small subset of the least fixpoint necessary to answer the query. <p> in Qsort comes from the inherent loss of precision in Pattern when different clauses defining a predicate return results with different 3 The gain in accuracy is Peep is somewhat unreal since it is due to an imprecision in one of the operations of Pattern which can be corrected easily <ref> [18] </ref>. 15 Program Args G-Mod G-Pro B-Mod B-Pro Procs B-Mod-P B-Pro-P Append 3 2 3 0 1 1 0 1 CS 94 28 94 0 66 34 0 30 Disj 60 24 60 0 36 30 0 20 Gabriel 59 22 22 0 0 20 0 0 Kalah 123 55 121
Reference: [19] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Reexecution in Abstract Interpretation of Prolog. </title> <booktitle> In Proceedings of the International Joint Conference and Symposium on Logic Programming (JICSLP-92), </booktitle> <address> Washington, DC, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: The association of indices to them could be for instance f (1; t fl v); (2; t); (3; v); (4; v); (5; Y 1 n [ ]); (6; Y 1 ); (7; [ ])g: 2 i.e. to simulate the effect of the reexecution strategy <ref> [19] </ref>. 13 As mentioned previously, each index is associated with a mode taken from f? ; Gro ; V ar ; N gv ; N ovar ; Gv ; N ogro ; Anyg: In the above example, we have the following associations f (1; Gro) ; (2; Gro) ; (3; Gro) <p> The generic abstract interpretation algorithm is, to our knowledge, the most efficient generic algorithm available for abstract interpretation of Prolog programs. We also use the reexecution algorithm of <ref> [19] </ref>. This algorithm is essentially similar to the previous one, except that procedure calls and built-ins are systematically reexecuted to gain precision, exploiting the referential transparency of logic languages. The reexecution is also local to a clause.
Reference: [20] <author> K. Marriott and H. Sondergaard. </author> <title> Notes for a Tutorial on Abstract Interpretation of Logic Programs. </title> <booktitle> North American Conference on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <year> 1989. </year>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
Reference: [21] <author> K. Marriott and H. Sondergaard. </author> <title> Semantics-based Dataflow Analysis of Logic Programs. </title> <booktitle> In Information Processing-89, </booktitle> <pages> pages 601-606, </pages> <address> San Fransisco, CA, </address> <year> 1989. </year>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
Reference: [22] <author> K. Marriott and H. Sondergaard. </author> <title> Analysis of Constraint Logic Programs. </title> <booktitle> In Proceedings of the North-American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, Tx, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard <ref> [22] </ref>. The domain is intended to compute groundness information in Prolog programs. It is conceptually simple and elegant since abstract substitutions are represented by Boolean functions built using the logical connectives ,; _; ^. The domain has been further investigated in [8] and related to other abstract domains in [9].
Reference: [23] <author> C. Mellish. </author> <title> Abstract Interpretation of Prolog Programs, </title> <booktitle> volume Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 181-198. </pages> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
Reference: [24] <author> K. Musumbu. </author> <title> Interpretation Abstraite de Programmes Prolog. </title> <type> PhD thesis, </type> <institution> University of Namur (Belgium), </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [4] where a pattern component has been added. The domain is fully described in <ref> [24] </ref> which contains also the proofs of monotonicity and consistency. The key concept in the representation of the substitutions in this domain is the notion of a subterm. <p> The actual sharing relation can be derived from these two components. In our particular example, the only sharing is the couple (6; 6) which expresses that variable Y 1 shares a variable with itself. 5.2.2 The Domain Mode The domain of <ref> [24] </ref> is a reformulation of the domain of [2]. The domain could be viewed as a simplification of the elaborate domain where the pattern information has been omitted and the sharing has been simplified to an equivalence relation. Only three modes are considered: ground, var and any.
Reference: [25] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Determination of Variable Dependence Information Through Abstract Interpretation. </title> <booktitle> In Proceedings of the North-American Conference on Logic Programming (NACLP-89), </booktitle> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. <ref> [4, 14, 25] </ref>) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> The domain is more sophisticated than the sharing domains of, for instance, <ref> [14, 25] </ref> and than the mode domains of, for instance, [29, 13]. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [4] where a pattern component has been added. The domain is fully described in [24] which contains also the proofs of monotonicity and consistency.
Reference: [26] <author> R.A. O'Keefe. </author> <title> Finite Fixed-Point Problems. </title> <editor> In J-L. Lassez, editor, </editor> <booktitle> Fourth International Conference on Logic Programming, </booktitle> <pages> pages 729-743, </pages> <address> Melbourne, Australia, </address> <year> 1987. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. <ref> [2, 6, 15, 16, 26] </ref>), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22].
Reference: [27] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Ma, </address> <year> 1986. </year>
Reference-contexts: The clauses containing assert and retract have been dropped in the one program containing them (i.e. Syntax error handling in the reader program). The program kalah is a program which plays the game of kalah. It is taken from <ref> [27] </ref> and implements an alpha-beta search procedure. The program press1 is a symbolic equation-solver program taken from [27] as well. Press2 is the same program but one literal is repeated to improve 12 precision 2 . The program cs is a cutting-stock program taken from [28]. <p> Syntax error handling in the reader program). The program kalah is a program which plays the game of kalah. It is taken from <ref> [27] </ref> and implements an alpha-beta search procedure. The program press1 is a symbolic equation-solver program taken from [27] as well. Press2 is the same program but one literal is repeated to improve 12 precision 2 . The program cs is a cutting-stock program taken from [28].
Reference: [28] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: It is taken from [27] and implements an alpha-beta search procedure. The program press1 is a symbolic equation-solver program taken from [27] as well. Press2 is the same program but one literal is repeated to improve 12 precision 2 . The program cs is a cutting-stock program taken from <ref> [28] </ref>. It is a program used to generate a number of configurations representing various ways of cutting a wood board into small shelves. The program uses, in various ways, the nondeterminism of Prolog.
Reference: [29] <author> R. Warren, M. Hermedegildo, and S. Debray. </author> <title> On the Practicality of Global Flow Analysis of Logic Programs. </title> <booktitle> In Proc. of the Fifth International Conference on Logic Programming, </booktitle> <pages> pages 684-699, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks (e.g. [1, 3, 2, 7, 20, 21, 23, 30]), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. <ref> [13, 18, 12, 29] </ref>). An abstract domain which has raised much interest in recent years is the domain Prop proposed by Marriott and Sondergaard [22]. The domain is intended to compute groundness information in Prolog programs. <p> The domain is more sophisticated than the sharing domains of, for instance, [14, 25] and than the mode domains of, for instance, <ref> [29, 13] </ref>. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [4] where a pattern component has been added. The domain is fully described in [24] which contains also the proofs of monotonicity and consistency.
Reference: [30] <author> W.H. Winsborough. </author> <title> A minimal function graph semantics for logic programs. </title> <type> Technical Report TR-711, </type> <institution> Computer-Science Department, University of Wisconsin at Madison, </institution> <month> August </month> <year> 1987. </year> <month> 25 </month>
Reference-contexts: This effort is motivated by the need of optimization in Prolog compilers to be competitive with procedural languages and the declarative nature of the language which makes it more amenable to static 1 analysis. Considerable progress has been realised in this area in terms of the frameworks (e.g. <ref> [1, 3, 2, 7, 20, 21, 23, 30] </ref>), the algorithms (e.g. [2, 6, 15, 16, 26]), the abstract domains (e.g. [4, 14, 25]) and the implementations (e.g. [13, 18, 12, 29]).
References-found: 30

