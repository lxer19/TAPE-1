URL: ftp://ftp.cs.colorado.edu/users/alw/papers/sen1092.ps
Refering-URL: http://www.cs.colorado.edu/serl/arch/Papers.html
Root-URL: http://www.cs.colorado.edu
Email: dep@research.att.com  alw@cs.colorado.edu  
Title: Foundations for the Study of Software Architecture  
Author: Dewayne E. Perry Alexander L. Wolf c ,, Dewayne E. Perry and Alexander L. Wolf 
Address: 600 Mountain Avenue Murray Hill, New Jersey 07974  Boulder, Colorado 80309  
Affiliation: AT&T Bell Laboratories  Department of Computer Science University of Colorado  
Note: ACM SIGSOFT SOFTWARE ENGINEERING NOTES vol 17 no 4 Oct 1992 Page 40  
Abstract: The purpose of this paper is to build the foundation for software architecture. We first develop an intuition for software architecture by appealing to several well-established architectural disciplines. On the basis of this intuition, we present a model of software architecture that consists of three components: elements, form, and rationale. Elements are either processing, data, or connecting elements. Form is defined in terms of the properties of, and the relationships among, the elements | that is, the constraints on the elements. The rationale provides the underlying basis for the architecture in terms of the system constraints, which most often derive from the system requirements. We discuss the components of the model in the context of both architectures and architectural styles and present an extended example to illustrate some important architecture and style considerations. We conclude by presenting some of the benefits of our approach to software architecture, summarizing our contributions, and relating our approach to other current work. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.S. Avrunin, L.K. Dillon., J.C. Wileden, and W.E. Riddle, </author> <title> Constrained Expressions: Adding Analysis Capabilities to Design Methods for Concurrent Systems, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-12, No. 2, </volume> <month> Feb. </month> <year> 1986, </year> <pages> pp. 278-292. </pages>
Reference-contexts: Because of the parallel behavior of the processing elements, the interrelationships among the various ba sic properties must be explicitly described. A number of notations exist that are suitable for making such descriptions, including parallel path expressions [6], constrained expressions <ref> [1] </ref>, and petri nets [16]. In this example we use parallel path expressions, where a comma indicates sequence, a plus sign indicates one or more repetitions, an asterisk indicates zero or more repetitions, and subexpressions are enclosed in parentheses.
Reference: [2] <author> J.L. Bentley, </author> <title> Writing Efficient Programs, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1982. </year>
Reference-contexts: In building architecture, the rationale explicates the underlying philosophical aesthetics that motivate the architect. In software architecture, the rationale instead explicates the satisfaction of the system constraints. These constraints are determined by considerations ranging from basic functional aspects to various non-functional aspects such as economics [4], performance <ref> [2] </ref> and reliability [13]. 3.2 Architectural Style If architecture is a formal arrangement of architectural elements, then architectural style is that which abstracts elements and formal aspects from various specific architectures. An architectural style is less constrained and less complete than a specific architecture.
Reference: [3] <author> G.D. Bergland, </author> <title> A Guided Tour of Program Design Methodologies, </title> <journal> IEEE Computer, </journal> <volume> Vol. 14, No. 10, </volume> <month> Oct. </month> <year> 1981, </year> <pages> pp. 13-37. </pages>
Reference-contexts: This research arose in response to the unique problems of developing large-scale software systems first recognized in the 1960s [5]. The premise of the research was that design is an activity separate from implementation, requiring special notations, techniques, and tools <ref> [3, 9, 17] </ref>. The results of this software design research has now begun to make inroads into the marketplace as computer-aided software engineering (CASE) tools [7].
Reference: [4] <author> B.W. Boehm, </author> <title> Software Engineering Economics, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: In building architecture, the rationale explicates the underlying philosophical aesthetics that motivate the architect. In software architecture, the rationale instead explicates the satisfaction of the system constraints. These constraints are determined by considerations ranging from basic functional aspects to various non-functional aspects such as economics <ref> [4] </ref>, performance [2] and reliability [13]. 3.2 Architectural Style If architecture is a formal arrangement of architectural elements, then architectural style is that which abstracts elements and formal aspects from various specific architectures. An architectural style is less constrained and less complete than a specific architecture.
Reference: [5] <author> F.P. Brooks, Jr., </author> <title> The Mythical Man-Month, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1972. </year>
Reference-contexts: 1 Introduction Software design received a great deal of attention by researchers in the 1970s. This research arose in response to the unique problems of developing large-scale software systems first recognized in the 1960s <ref> [5] </ref>. The premise of the research was that design is an activity separate from implementation, requiring special notations, techniques, and tools [3, 9, 17]. The results of this software design research has now begun to make inroads into the marketplace as computer-aided software engineering (CASE) tools [7]. <p> Systems evolve and are adapted to new uses, just as buildings change over time and are adapted to new uses. One frequently accompanying property of evolution is an increasing brittleness of the system | that is, an increasing resistance to change, or at least to changing gracefully <ref> [5] </ref>. This is due in part to two architectural problems: architectural erosion and architectural drift. Architectural erosion is due to violations of the architecture.
Reference: [6] <author> R.H. </author> <title> Campbell and A.N. Habermann, The Specification of Process Synchronization by Path Expressions, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> No. 16, </volume> <month> Apr. </month> <year> 1974, </year> <pages> pp. 89-102. </pages>
Reference-contexts: Because of the parallel behavior of the processing elements, the interrelationships among the various ba sic properties must be explicitly described. A number of notations exist that are suitable for making such descriptions, including parallel path expressions <ref> [6] </ref>, constrained expressions [1], and petri nets [16]. In this example we use parallel path expressions, where a comma indicates sequence, a plus sign indicates one or more repetitions, an asterisk indicates zero or more repetitions, and subexpressions are enclosed in parentheses.
Reference: [7] <editor> E.J. Chikofsky (ed.), </editor> <booktitle> Software Development | Computer-aided Software Engineering, Technology Series, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: The premise of the research was that design is an activity separate from implementation, requiring special notations, techniques, and tools [3, 9, 17]. The results of this software design research has now begun to make inroads into the marketplace as computer-aided software engineering (CASE) tools <ref> [7] </ref>. In the 1980s, the focus of software engineering research moved away from software design specifically and more toward integrating designs and the design process into the broader context of the software process and its management.
Reference: [8] <author> G. Estrin, </author> <title> R.S. Fenchel, R.R. Razouk, and M.K. Ver non, SARA (System ARchitects Apprentice), </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-12, No. 2, </volume> <month> Feb. </month> <year> 1986, </year> <pages> pp. 293-277. </pages>
Reference-contexts: While there has been some work in defining particular software architectures (e.g., [19, 22]), and even some work in developing general support for the process of developing architectures (notably Sara <ref> [8] </ref>), it is time to reexamine the role of architecture in the broader context of the software process and software process management, as well as to marshal the various new techniques that have been developed.
Reference: [9] <author> P. Freeman and A.I. Wasserman, </author> <title> Tutorial on Software Design Techniques, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1976. </year>
Reference-contexts: This research arose in response to the unique problems of developing large-scale software systems first recognized in the 1960s [5]. The premise of the research was that design is an activity separate from implementation, requiring special notations, techniques, and tools <ref> [3, 9, 17] </ref>. The results of this software design research has now begun to make inroads into the marketplace as computer-aided software engineering (CASE) tools [7].
Reference: [10] <author> D. Jackson, </author> <title> Composing Data and Process Descriptions in the Design of Software Systems, </title> <type> LCS Tech. Report 419, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cam-bridge, MA, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: These two views are thus intertwined | each dependent on the other for at least some of the important characteristics of both data and processing. (For a more general discussion of process and data interdependence, see <ref> [10] </ref>.) The interdependence of processing and data upon the connections is more obvious: the connecting elements are the mechanisms for moving data around from processor to processor.
Reference: [11] <author> F.C. Mish, </author> <title> Webster's Ninth New Collegiate Dictionary, </title> <address> Merriam Webster, Springfield, MA, </address> <year> 1983. </year>
Reference-contexts: The concept of building architecture that we appeal to is that of the standard definition: "The art or science of building: especially designing and building habital structures" <ref> [11] </ref>. Perhaps more relevant to our needs here is a secondary definition: "A unifying or coherent form or structure" [11]. It is this sense of architecture | providing a unifying or coherent form or structure | that infuses our model of software architecture. <p> The concept of building architecture that we appeal to is that of the standard definition: "The art or science of building: especially designing and building habital structures" <ref> [11] </ref>. Perhaps more relevant to our needs here is a secondary definition: "A unifying or coherent form or structure" [11]. It is this sense of architecture | providing a unifying or coherent form or structure | that infuses our model of software architecture.
Reference: [12] <author> J.E.B. Moss and A.L. Wolf, </author> <title> Toward Principles of Inheritance and Subtyping for Programming Languages, </title> <type> COINS Tech. Report 88-95, </type> <institution> COINS Dept., Univ. </institution> <address> of Mass., Amherst, MA, </address> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: The reason is that type models, as they currently exist, are essentially only able to characterize elements and element types in terms of the relationship of one element type to another (e.g., subtyping and inheritance <ref> [12] </ref>), in terms of the relationships that particular elements have with other elements (e.g., as in Oros [18]), and in terms of the operations that can be performed on the elements. They are not suited to descriptions of characteristics of elements such as the application-oriented properties mentioned above.
Reference: [13] <author> J.D. Musa, </author> <title> Software Reliability: Measurement, Prediction, Application, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: In software architecture, the rationale instead explicates the satisfaction of the system constraints. These constraints are determined by considerations ranging from basic functional aspects to various non-functional aspects such as economics [4], performance [2] and reliability <ref> [13] </ref>. 3.2 Architectural Style If architecture is a formal arrangement of architectural elements, then architectural style is that which abstracts elements and formal aspects from various specific architectures. An architectural style is less constrained and less complete than a specific architecture.
Reference: [14] <author> D.E. Perry, </author> <title> The Inscape Environment, </title> <booktitle> Proc. Eleventh Inter. Conf. on Software Engineering, </booktitle> <address> Pittsburgh, PA, </address> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1989, </year> <pages> pp. 2-12. </pages>
Reference-contexts: There are two primary categories of analysis that we wish to perform: consistency and dependency analysis. Consistency occurs in several dimensions: consistency within the architecture and architectural styles, consistency of the architecture with the requirements, and consistency of the design with the architecture. In the same way that Inscape <ref> [14] </ref> formally and automatically manages the interdependencies between interface specifications and implementations, we also want to be able to manage the interdependencies between requirements, architecture, and design.
Reference: [15] <author> D.E. Perry, </author> <title> Industrial Strength Software Development Environments, </title> <booktitle> Proc. IFIP Congress '89, The 11th World Computer Congress, </booktitle> <address> San Francisco, CA, </address> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: However, our characterization represents a wide variety of development and evolutionary paradigms used in the creation of production software, and delineates an important, and hitherto un-derconsidered, part of a unified software product <ref> [15] </ref>. 2.3 Motivation for Architectural Speci fications There are a number of factors that contribute to the high cost of software. Two factors that are important 2 Note that the notion of requirements presented here is an idealistic one.
Reference: [16] <author> J.L. Peterson, </author> <title> Petri Nets, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 9, No. 3, </volume> <month> Sept. </month> <year> 1977, </year> <pages> pp. 223-252. </pages>
Reference-contexts: Because of the parallel behavior of the processing elements, the interrelationships among the various ba sic properties must be explicitly described. A number of notations exist that are suitable for making such descriptions, including parallel path expressions [6], constrained expressions [1], and petri nets <ref> [16] </ref>. In this example we use parallel path expressions, where a comma indicates sequence, a plus sign indicates one or more repetitions, an asterisk indicates zero or more repetitions, and subexpressions are enclosed in parentheses.
Reference: [17] <author> W.E. Riddle and J.C. Wileden, </author> <title> Tutorial on Software System Design: Description and Analysis, </title> <publisher> Computer Society Press, </publisher> <year> 1980. </year>
Reference-contexts: This research arose in response to the unique problems of developing large-scale software systems first recognized in the 1960s [5]. The premise of the research was that design is an activity separate from implementation, requiring special notations, techniques, and tools <ref> [3, 9, 17] </ref>. The results of this software design research has now begun to make inroads into the marketplace as computer-aided software engineering (CASE) tools [7].
Reference: [18] <author> W.R. Rosenblatt, J.C. Wileden, and A.L. Wolf, OROS: </author> <title> Towards a Type Model for Software Development Environments, </title> <booktitle> Proc. OOPSLA '89, </booktitle> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: is that type models, as they currently exist, are essentially only able to characterize elements and element types in terms of the relationship of one element type to another (e.g., subtyping and inheritance [12]), in terms of the relationships that particular elements have with other elements (e.g., as in Oros <ref> [18] </ref>), and in terms of the operations that can be performed on the elements. They are not suited to descriptions of characteristics of elements such as the application-oriented properties mentioned above.
Reference: [19] <author> E. Sandewall, C. Stromberg, and H. Sorensen, </author> <title> Software Architecture Based on Communicating Residential Environments, </title> <booktitle> Proc. Fifth Inter. Conf. on Software Engineering, </booktitle> <address> San Diego, CA, </address> <publisher> IEEE Computer Society Press, </publisher> <month> Mar. </month> <year> 1981, </year> <pages> pp. 144-152. </pages>
Reference-contexts: We use the term "architecture", in contrast to "design", to evoke notions of codification, of abstraction, of standards, of formal training (of software architects), and of style. While there has been some work in defining particular software architectures (e.g., <ref> [19, 22] </ref>), and even some work in developing general support for the process of developing architectures (notably Sara [8]), it is time to reexamine the role of architecture in the broader context of the software process and software process management, as well as to marshal the various new techniques that have
Reference: [20] <author> R.W. Schwanke, R.Z. Altucher, and M.A. Platoff, </author> <title> Discovering, Visualizing and Controlling Software Structure, </title> <booktitle> Proc. Fifth Inter. Workshop on Software Specification and Design, </booktitle> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989, </year> <booktitle> appearing in ACM SIGSOFT Notes, </booktitle> <volume> Vol. 14, No. 3, </volume> <month> May </month> <year> 1989, </year> <pages> pp. 147-150. </pages>
Reference-contexts: In so doing, we have set a direction for future research that should establish the primacy of software architecture. Others have begun to look at software architecture. Three that are most relevant are Schwanke, et al., Zach-man, and Shaw. Schwanke, et al., <ref> [20] </ref> define architecture as the permitted or allowed set of connections among components. We agree that that aspect of architecture is important, but feel that there is much more to architecture than simply components and connections, as we demonstrate in this paper.
Reference: [21] <author> M. Shaw, </author> <title> Larger Scale Systems Require Higher-Level Abstractions, </title> <booktitle> Proc. Fifth Inter. Workshop on Software Specification and Design, </booktitle> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989, </year> <booktitle> appearing in ACM SIGSOFT Notes, </booktitle> <volume> Vol. 14, No. 3, </volume> <month> May </month> <year> 1989, </year> <pages> pp. 143-146. </pages>
Reference-contexts: Shaw <ref> [21] </ref> comes the closest in approach to ours. She takes the view of a programming language designer and abstracts classes of components, methods of composition, and schemas from a wide variety of systems. These correspond somewhat to our notions of processing and data elements, connecting elements, and architectural style, respectively.
Reference: [22] <author> A.Z. Spector, </author> <title> Modular Architectures for Distributed and Database Systems, </title> <booktitle> Proc. Eighth ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, </booktitle> <address> Philadelphia, PA, </address> <publisher> ACM Press, </publisher> <month> Mar. </month> <year> 1989, </year> <pages> pp. 217-224. </pages>
Reference-contexts: We use the term "architecture", in contrast to "design", to evoke notions of codification, of abstraction, of standards, of formal training (of software architects), and of style. While there has been some work in defining particular software architectures (e.g., <ref> [19, 22] </ref>), and even some work in developing general support for the process of developing architectures (notably Sara [8]), it is time to reexamine the role of architecture in the broader context of the software process and software process management, as well as to marshal the various new techniques that have
Reference: [23] <author> J.A. Zachman, </author> <title> A Framework for Information Systems Architecture, </title> <journal> IBM Systems Journal, </journal> <volume> Vol. 26, No. 3, </volume> <year> 1987. </year>
Reference-contexts: Schwanke, et al., [20] define architecture as the permitted or allowed set of connections among components. We agree that that aspect of architecture is important, but feel that there is much more to architecture than simply components and connections, as we demonstrate in this paper. Zachman <ref> [23] </ref> uses the metaphor of building architecture to advantage in constructing an architecture for information systems. He exploits the notion of different architectural documents to provide a vision of what the various documents ought to be in the building of an information system.
References-found: 23

