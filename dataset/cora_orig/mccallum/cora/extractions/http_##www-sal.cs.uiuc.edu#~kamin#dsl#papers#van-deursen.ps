URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/papers/van-deursen.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/index.html
Root-URL: http://www.cs.uiuc.edu
Email: http://www.cwi.nl/~farie,paulkg/, farie,paulkg@cwi.nl  
Title: Little Languages: Little Maintenance?  
Author: Arie van Deursen and Paul Klint 
Date: December 16, 1996  
Address: P.O. Box 94079, 1090 GB Amsterdam  
Affiliation: CWI,  
Abstract: So-called little, or domain-specific languages (DSLs), have the potential to make software maintenance simpler: domain-experts can directly use the DSL to make required routine modifications. At the negative side, however, more substantial changes may become more difficult: such changes may involve altering the domain-specific language. This will require compiler technology knowledge, which not every commercial enterprise has easily available. Based on experience taken from industrial practice, we discuss the role of DSLs in software maintenance, the dangers introduced by using them, and techniques for controlling the risks involved.
Abstract-found: 1
Intro-found: 1
Reference: [ADR95] <author> B. R. T. Arnold, A. van Deursen, and M. </author> <title> Res. An algebraic specification of a language for describing financial products. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> ICSE-17 Workshop on Formal Methods Application in Software Engineering, </booktitle> <pages> pages 6-13. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: The language was to be readable for financial engineers, and descriptions in this language were to be compiled into COBOL. In this section we summarize earlier (and more detailed) accounts given in <ref> [Deu94, ADR95, BDK + 96] </ref> of the development and use of this language.
Reference: [Ben86] <author> J. L. Bentley. </author> <title> Programming pearls: Little languages. </title> <journal> Communications of the ACM, </journal> <volume> 29(8) </volume> <pages> 711-721, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Little languages, tailored towards the specific needs of a particular domain, can significantly ease building software systems for that domain <ref> [Ben86] </ref>.
Reference: [BHK89] <author> J. A. Bergstra, J. Heering, and P. Klint, </author> <title> editors. Algebraic Specification. </title> <booktitle> ACM Press/Addison-Wesley, </booktitle> <year> 1989. </year>
Reference-contexts: It was in fact used during the design of Risla and Risquest, the languages described in Section 2. It is the aim of Asf+Sdf to assist during the design and further development of (domain-specific) languages <ref> [BHK89, Kli93, DHK96] </ref>. It consists of a formalism to describe languages and of a Meta-Environment to derive tools from such language descriptions. <p> The Meta-Environment turns these into a parser, type checker, optimizer, interpreter, and compiler, respectively. 4.1 The ASF+SDF Formalism The language Asf+Sdf grew out of the integration of the Algebraic Specification Formalism ASF and the Syntax Definition Formalism SDF <ref> [BHK89] </ref>. An Asf+Sdf specification consists of a declaration of the functions that can be used to build terms, and of a set of equations expressing equalities between terms.
Reference: [BK96a] <author> J. A. Bergstra and P. Klint. </author> <title> The Discrete Time ToolBus. </title> <editor> In M. Wirs--ing and M. Nivat, editors, </editor> <booktitle> Algebraic Methodology and Software Technology (AMAST '96), volume 1101 of Lecture Notes in Computer Science, </booktitle> <pages> pages 288-305. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: How can applications that have been built by means of different DSLs be coordinated? We answer this question in two steps: first we introduce the ToolBus coordination architecture and then we show how it solves the coordination issue just raised. 5.1 The ToolBus coordination architecture In <ref> [BK96b, BK96a] </ref> the ToolBus coordination architecture has been proposed that facilitates the interoperability of heterogeneous, distributed, software components. To get control over the possible interactions between components ("tools") direct inter-tool communication is forbidden. Instead, all interactions are controlled by a "T script" that formalizes all the desired interactions among tools.
Reference: [BK96b] <author> J. A. Bergstra and P. Klint. </author> <title> The ToolBus coordination architecture. </title> <editor> In P. Ciancarini and C. Hankin, editors, </editor> <booktitle> Coordination Languages and Models (COORDINATION '96), volume 1061 of Lecture Notes in Computer Science, </booktitle> <pages> pages 75-88. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: How can applications that have been built by means of different DSLs be coordinated? We answer this question in two steps: first we introduce the ToolBus coordination architecture and then we show how it solves the coordination issue just raised. 5.1 The ToolBus coordination architecture In <ref> [BK96b, BK96a] </ref> the ToolBus coordination architecture has been proposed that facilitates the interoperability of heterogeneous, distributed, software components. To get control over the possible interactions between components ("tools") direct inter-tool communication is forbidden. Instead, all interactions are controlled by a "T script" that formalizes all the desired interactions among tools.
Reference: [Boe81] <author> B. W. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Finally, increased maintainability will affect the principal maintenance cost indicator, the annual change traffic (ACT) | the fraction of code changed due to maintenance each year. The maintenance effort ME is related to ACT and the initial development cost in man months DM as follows <ref> [Boe81] </ref>: ME = F fl DM fl ACT where F is a multiplication factor representing the system maintainability.
Reference: [BDK + 96] <author> M. G. J. van den Brand, A. van Deursen, P. Klint, S. Klusener, and E. A. van der Meulen. </author> <title> Industrial applications of ASF+SDF. </title> <editor> In M. Wirsing and M. Nivat, editors, </editor> <booktitle> Algebraic Methodology and Software Technology (AMAST '96), volume 1101 of Lecture Notes in Computer Science, </booktitle> <pages> pages 9-18. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The language was to be readable for financial engineers, and descriptions in this language were to be compiled into COBOL. In this section we summarize earlier (and more detailed) accounts given in <ref> [Deu94, ADR95, BDK + 96] </ref> of the development and use of this language. <p> The assumption is that this investment will pay for itself during the implementation phase, an assumption confirmed by the various projects carried out so far, such as the ones discussed in <ref> [BDK + 96] </ref>.
Reference: [BV96] <author> M. G. J. van den Brand and E. Visser. </author> <title> Generation of formatters for context-free languages. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5 </volume> <pages> 1-41, </pages> <year> 1996. </year>
Reference-contexts: In the Meta-Environment, the generators are invisible, and run automatically when needed. The derived pretty printer can be fine-tuned, allowing one to specify compilers to languages in which layout is semantically relevant (e.g., COBOL) <ref> [BV96] </ref>. This pattern gives rise to a series of language processors, with a functionality as specified in the language definition. Basic user-interface primitives can be used to connect the processors to an integrated L-specific environment.
Reference: [Cog95] <author> Ph. Coggan. </author> <title> The Money Machine: How the City Works. </title> <booktitle> Pinguin, 1995. Third edition. </booktitle>
Reference-contexts: The simplest interest rate product is the loan: a fixed amount in a certain currency is borrowed for a fixed period at a given interest rate. More complicated products, such as the financial future, the forward rate agreement, or the capped floater <ref> [Cog95, Chapter 12] </ref>, all aim at risk reallocation. Banks can invent new ways to do this, giving rise to more and more interest rate products.
Reference: [Deu94] <author> A. van Deursen. </author> <title> Executable Language Definitions: Case Studies and Origin Tracking Techniques. </title> <type> PhD thesis, </type> <institution> University of Amsterdam, </institution> <year> 1994. </year>
Reference-contexts: The language was to be readable for financial engineers, and descriptions in this language were to be compiled into COBOL. In this section we summarize earlier (and more detailed) accounts given in <ref> [Deu94, ADR95, BDK + 96] </ref> of the development and use of this language.
Reference: [DHK96] <author> A. van Deursen, J. Heering, and P. Klint, </author> <title> editors. Language Proto-typing: An Algebraic Specification Approach, </title> <booktitle> volume 5 of AMAST Series in Computing. </booktitle> <publisher> World Scientific Publishing Co., </publisher> <year> 1996. </year>
Reference-contexts: It was in fact used during the design of Risla and Risquest, the languages described in Section 2. It is the aim of Asf+Sdf to assist during the design and further development of (domain-specific) languages <ref> [BHK89, Kli93, DHK96] </ref>. It consists of a formalism to describe languages and of a Meta-Environment to derive tools from such language descriptions. <p> These functions are specified using conditional equations, which may have negative premises. In addition to that, Asf+Sdf supports so-called default -equations, which can be used to "cover all remaining cases", a feature which can result in significantly shorter specifications for real-life situations <ref> [DHK96] </ref>. Specification in the large is supported by some basic modularization constructs. Terms can be written in arbitrary user-defined syntax. In fact, an Asf+Sdf signature is at the same time a context-free grammar, and defines a fixed mapping between sentences over the grammar and terms over the signature.
Reference: [EG92] <author> Th. Eggenschwiler and E. Gamma. ET++ SwapsManager: </author> <title> Using object technology in the financial engineering domain. </title> <booktitle> In OOP-SLA'92 Seventh Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 166-177. </pages> <note> ACM, 1992. SIG-PLAN Notices 27(10). </note>
Reference-contexts: A clever cocktail of multi-currency loans, options, and swaps was used to finance this transaction, protecting KPN against interest rate differences and exchange rate fluctuations between the Australian and the Dutch financial markets. 2 As an example, <ref> [EG92] </ref> describe the ET++ Swaps Manager, an object-oriented library for manipulating interest rate products. 3 This can be very important: as an example, one Dutch bank decided mid-February 1996 to introduce a special one-day "leap year deposit" | a big success, but relying heavily on the flexibility of the bank's automated
Reference: [GB96] <author> S. J. Glover and K. H. Bennet. </author> <title> An agent-based approach to rapid software evolution based on a domain model. </title> <booktitle> In Proceedings International Conference on Software Maintenance ICSM'96, </booktitle> <pages> pages 228-237. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> 1996. Monterey, CA. </address>
Reference-contexts: In this paper, we elaborate on the advantages and problems of the use of domain-specific languages, emphasizing their role in software maintenance. Evidently, the attributes listed above will help reduce maintenance costs, and for that reason domain-specific approaches are investigated in order to arrive at "inherently maintainable software" <ref> [GB96] </ref>. However, using a domain-specific language can also make a system more difficult to maintain, for example if changes to the underlying domain model become necessary.
Reference: [HB88] <author> R. M. Herndon and V. A. Berzins. </author> <title> The realizable benefits of a language prototyping language. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14:803-809, </volume> <year> 1988. </year>
Reference-contexts: 1 Introduction Little languages, tailored towards the specific needs of a particular domain, can significantly ease building software systems for that domain [Ben86]. To cite Hendon and Berzins <ref> [HB88] </ref>, If a conceptual framework is rich enough and program tasks within the framework are common enough, a language supporting the primitive concepts of the framework is called for. (...) Many tasks can be easily described by agreeing upon an appropriate vocabulary and conceptual framework. <p> Moreover, the good DSL will be effectively implementable, where the DSPs capture the stable concepts and algorithmic ingredients of the particular domain. Using such a DSL for constructing domain-specific applications, increases reliability and repairability, provides self-documenting and portable descriptions, and reduces forward (and backward) engineering costs <ref> [HB88] </ref>. In this paper, we elaborate on the advantages and problems of the use of domain-specific languages, emphasizing their role in software maintenance. Evidently, the attributes listed above will help reduce maintenance costs, and for that reason domain-specific approaches are investigated in order to arrive at "inherently maintainable software" [GB96].
Reference: [Kli93] <author> P. Klint. </author> <title> A meta-environment for generating programming environ-ments. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2 </volume> <pages> 176-201, </pages> <year> 1993. </year>
Reference-contexts: It was in fact used during the design of Risla and Risquest, the languages described in Section 2. It is the aim of Asf+Sdf to assist during the design and further development of (domain-specific) languages <ref> [BHK89, Kli93, DHK96] </ref>. It consists of a formalism to describe languages and of a Meta-Environment to derive tools from such language descriptions. <p> Moreover, concrete syntax can be used in equations when specifying language properties. This smooth integration of concrete syntax with equations is one of the factors that makes Asf+Sdf attractive for language definition. 4.2 The ASF+SDF Meta-Environment The role of the Asf+Sdf Meta-Environment <ref> [Kli93] </ref> is to support the development of language definitions, and to produce prototype tools from these. It is best explained using Figure 3.
Reference: [KMB + 96] <author> R. B. Kieburtz, L. McKinney, J. M. Bell, J. Hook, A. Kotov, J. Lewis, D. P. Oliva, T. Sheard, I. Smith, and L. Walton. </author> <title> A software engineering experiment in software component generation. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering ICSE-18, </booktitle> <pages> pages 542-553. </pages> <publisher> IEEE, </publisher> <year> 1996. </year>
Reference-contexts: Concerning the costs of using DSLs, there is empirical evidence suggesting that the use of DSLs increases flexibility, productivity, reliability, and usability <ref> [KMB + 96] </ref>. As a way of reducing the costs of the initial development of the DSL and DSPs, the language and its tools can be sold as a product to competitors in the same field.
Reference: [OH94] <author> P. Oman and J. Hagemeister. </author> <title> Constructing and testing of polynomials predicting software maintainability. </title> <journal> Journal of Systems and Software, </journal> <volume> 24(3) </volume> <pages> 251-266, </pages> <year> 1994. </year>
Reference-contexts: Positively impacted by the use of a DSL are the source code maintainability attributes (modularity, encapsulation, cohesion, portability, understandability, etc), which many regard as the predominant maintainability factors <ref> [Pig97, OH94, p.289] </ref>. The most important properties are that the DSDs are much smaller than their general purpose language counterparts, and that the DSDs are more descriptive, avoiding the need for many comment lines in the DSDs, and thus reducing the chance of obsolete comment lines.
Reference: [Pig97] <author> T. M. Pigoski. </author> <title> Practical Software Maintenance Best Practices for Managing Your Software Investment. </title> <publisher> John Wiley and Sons, </publisher> <year> 1997. </year>
Reference-contexts: Whenever there was a new software system requiring information about products that was not provided in the existing methods, new methods had to be provided, sometimes requiring new data types or extensions to the Risla language. 3 The Maintenance Perspective 3.1 Maintainability Factors The literature on software maintenance (see, e.g., <ref> [Pig97] </ref> and the references cited there in) deals, among others, extensively with maintainability , defined as the ease with which a system can be kept in operation when modifications to the code become necessary [Pig97, p.274]. <p> Risla language. 3 The Maintenance Perspective 3.1 Maintainability Factors The literature on software maintenance (see, e.g., [Pig97] and the references cited there in) deals, among others, extensively with maintainability , defined as the ease with which a system can be kept in operation when modifications to the code become necessary <ref> [Pig97, p.274] </ref>. <p> Some of these maintainability factors (e.g., quality of the configuration management) are not affected by the use of a domain-specific language. Others are negatively influenced: The number of different languages used in the system <ref> [Pig97, p.283] </ref> increases, which in itself makes maintenance more difficult. Also, it may be difficult to find personnel fluent in this particular DSL (proper documentation of the use, design, and implementation of the DSL, will reduce this risk by making the DSL easy to learn). <p> The use of an explicit software maintenance model (who is performing which steps in what order) by the maintainers is considered an important factor for improving maintainability <ref> [Pig97, p.40] </ref>. Adopting a DSL affects only the actual steps taken: domain experts without much programming or maintenance experience now can inspect the consequences and quality of the modifications made by the maintainers (for the Risla case this is particularly important: the interest rate product implementations should correspond to reality). <p> Positively impacted by the use of a DSL are the source code maintainability attributes (modularity, encapsulation, cohesion, portability, understandability, etc), which many regard as the predominant maintainability factors <ref> [Pig97, OH94, p.289] </ref>. The most important properties are that the DSDs are much smaller than their general purpose language counterparts, and that the DSDs are more descriptive, avoiding the need for many comment lines in the DSDs, and thus reducing the chance of obsolete comment lines.
Reference: [Wal96] <author> L. Walton. </author> <title> Domain-specific design languages, </title> <note> 1996. URL http://- www.cse.ogi.edu/~walton/dsdls.html. </note>
Reference-contexts: We will use the following terminology (see also Figure 1): Domain-Specific Language (DSL) A small, usually declarative, language expressive over the distinguishing characteristics of a set of programs in a particular problem domain <ref> [Wal96] </ref>. Product Definition (DSD) DSL Compiler (DSP) IT Support for Product Domain-Specific Description (DSD) A "program" (specification, descrip tion, query, process, task, ...) written in a DSL. Domain-Specific Processor (DSP) A software tool for compiling, interpret ing, or analyzing domain-specific descriptions.
References-found: 19

