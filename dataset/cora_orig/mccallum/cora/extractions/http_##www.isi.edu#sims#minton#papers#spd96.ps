URL: http://www.isi.edu/sims/minton/papers/spd96.ps
Refering-URL: http://www.isi.edu/sims/minton/homepage.html
Root-URL: http://www.isi.edu
Email: fminton,philpotg@isi.edu  shawn@ptolemy.arc.nasa.gov  
Title: Specification-By-Demonstration: The ViCCS Interface  
Author: Steven Minton and Andrew Philpot Shawn Wolfe 
Address: 4676 Admiralty Way Marina Del Rey, CA, 90292, USA  MS 269-2 Moffett Field, CA, 94035, USA  
Affiliation: USC/ISI,  NASA ARC, Caelum Research,  
Abstract: Our goal is to make combinatorial problem-solving technology available to users who have no formal training in AI or OR. To achieve this aim, we have built a system, ViCSS (Visual Constraint Specification System) that enables users to specify problems graphically. To simplify the specification process, ViCSS relies heavily on programming-by-demonstration (PBD) techniques. We believe, however, that the key to making PBD succeed for our application is to constrain the generalization process so that the system makes only "simple", easy-to-understand generalizations. In this paper we describe several design decisions that enable us to achieve this end, and illustrate them in the context of an extended example. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Cypher, A. </author> <year> 1993. </year> <title> Watch What I Do: Programming by Demonstration. </title> <publisher> MIT Press. </publisher>
Reference-contexts: the interface is to relieve the user from having to know first-order logic. (Nevertheless, requiring a user to verify that a logical statement is the intended constraint would still be improvement over requiring the user to write the constraint himself.) Related Work This work was largely inspired by programming-by-demonstration techniques <ref> (Cypher 1993) </ref> and, in particular, the work on demonstrational interfaces (Myers 1992). In many cases, these systems are only capable of making relatively simple generalizations, but, as we have argued, this can be an advantage when one must interact with a user.
Reference: <author> Garey, M., and Johnson, D. </author> <year> 1979. </year> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Co. </publisher>
Reference-contexts: Are these structures enough for our purposes, or will we need a whole host of different graphical displays? We believe (and hope) that the former is the case; researchers have found these particular structures very useful for describing a wide variety of combinatorial problems <ref> (Garey & Johnson 1979) </ref>. Finally, consider the fourth point. Because the generalization language is limited to a few natural concepts for each type of graphical structure, the capability to change the domain description language by creating new structures is crucial.
Reference: <author> Minton, S., and Underwood, I. </author> <year> 1994. </year> <title> Small is beautiful: A brute-force approach to learning first-order formulas. </title> <booktitle> In Proceedings AAAI. </booktitle>
Reference-contexts: Why go to such an extent to simplify the generalization problem? Certainly, we could use an first-order learning method such as Minton and Under-wood's BFSF method <ref> (Minton & Underwood 1994) </ref> to learn the constraints from a series of examples. It's an intriguing possibility, but we can see two ways in which this would make life difficult for a user.
Reference: <author> Minton, S. </author> <year> 1993a. </year> <title> An analytic learning system for specializing heuristics. </title> <note> In IJCAI-93. </note>
Reference: <author> Minton, S. </author> <year> 1993b. </year> <title> Integrating heuristics for constraint satisfaction problems: A case study. </title> <booktitle> In AAAI-93. </booktitle>
Reference-contexts: Introduction Multi-tac <ref> (Minton 1993b) </ref> is a system for synthesizing combinatorial search programs. To use Multi-tac, one must provide a description of the problem constraints in predicate calculus. This limits the practical use of the system, since most potential users of the system are not fluent in predicate calculus. <p> As described in previous papers (Minton 1993a; 1993b) Multi-tac relies heavily on machine learning techniques to guide the synthesis process. In experiments with some NP-hard problems, we found that Multi-tac produced code that performed on par with, and occasionally better than, code produced by human programmers <ref> (Minton 1993b) </ref>. ViCSS Interface We will now describe how the same crew scheduling problem is formulated using ViCSS, in order to illustrate our Specification-by-Demonstration approach. ViCSS provides several varieties of graphical structures that can be used to display data, including lists, grids, graphs and sequences.
Reference: <author> Muggleton, S. </author> <year> 1992. </year> <title> Inductive Logic Progamming. </title> <publisher> Academic Press. </publisher>
Reference-contexts: There has also been a tremendous amount of work within the field of machine learning on induction and on learning program specifications from examples (e.g, <ref> (Muggleton 1992) </ref>), but the techniques explored in this literature are generally more powerful than we require.
Reference: <author> Myers, B. </author> <year> 1992. </year> <title> Demonstrational interfaces: A step beyond direct manipulation. </title> <booktitle> IEEE Computer 25(8). </booktitle>
Reference-contexts: The system then displays the constraint in pseudo-english "Every item in the grid Number of Tasks per Crew Member is less than or equal to 8", as shown in Figure 4. As this scenario illustrated, ViCSS employs both "programming-with-example" and "programming-by-example", as defined by Myers <ref> (Myers 1992) </ref>. Programming-with-examples is used in the first phase, when the user applies algebraic operations to create new graphical structures, such as the grid Number of Tasks per Crew Member. Here the user is explicitly applying operators (i.e., programming) and the system does not need to make any inductive inferences. <p> know first-order logic. (Nevertheless, requiring a user to verify that a logical statement is the intended constraint would still be improvement over requiring the user to write the constraint himself.) Related Work This work was largely inspired by programming-by-demonstration techniques (Cypher 1993) and, in particular, the work on demonstrational interfaces <ref> (Myers 1992) </ref>. In many cases, these systems are only capable of making relatively simple generalizations, but, as we have argued, this can be an advantage when one must interact with a user.
Reference: <author> Zloof, M. </author> <year> 1977. </year> <title> Query-by-example: A data base language. </title> <journal> IBM Systems Journal 16. </journal>
Reference-contexts: There has also been relevant work in the area of relational databases and spreadsheets, where the graphical displays are similar to the grids described here. Pioneering work in this area was IBM's early system Query-by-Example <ref> (Zloof 1977) </ref>. However, with regard to our application area, we know of no other work where "specification-by-demonstration" methods are being used as an interface to combinatorial problem solvers. We believe, however, that this is a very exciting application area, and the potential to produce useful systems is enormous.
References-found: 8

