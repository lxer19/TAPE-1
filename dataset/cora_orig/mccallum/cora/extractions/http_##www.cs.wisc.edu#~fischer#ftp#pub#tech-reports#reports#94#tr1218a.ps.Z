URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/94/tr1218a.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/94/
Root-URL: http://www.cs.wisc.edu
Email: fwiener,naughtong@cs.wisc.edu  
Title: Bulk Loading into an OODB: A Performance Study  
Author: Janet L. Wiener Jeffrey F. Naughton 
Address: 1210 W. Dayton St., Madison, WI 53706  
Affiliation: Department of Computer Sciences University of Wisconsin-Madison  
Abstract: Object-oriented database (OODB) users bring with them large quantities of legacy data (megabytes and even gigabytes). In addition, scientific OODB users continually generate new data. All this data must be loaded into the OODB. Every relational database system has a load utility, but most OODBs do not. The process of loading data into an OODB is complicated by inter-object references, or relationships, in the data. These relationships are expressed in the OODB as object identifiers, which are not known at the time the load data is generated; they may contain cycles; and there may be implicit system-maintained inverse relationships that must also be stored. We introduce seven algorithms for loading data into an OODB that examine different techniques for dealing with circular and inverse relationships. We present a performance study based on both an analytic model and an implementation of all seven algorithms on top of the Shore object repository. Our study demonstrates that it is important to choose a load algorithm carefully; in some cases the best algorithm achieved an improvement of one to two orders of magnitude over the naive algorithm.
Abstract-found: 1
Intro-found: 1
Reference: [Cat93] <author> R. G. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufman, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Many OODB support system-maintained inverse relationships [Obj92, Ont92, Ver93, OHMS92, WI93], and they are part of the ODMG standard <ref> [Cat93] </ref>. As an example, suppose that object A has an inverse relationship with object B. Then when B's OID is stored in A, A's OID should be stored in B. <p> In this schema, each Experiment object has a many-to-one relationship with an Input object and a one-to-one relationship with an Output object. Figure 1 defines the schema in the Object Definition Language proposed by ODMG <ref> [Cat93] </ref>. 2.2 Data file description Input (temperature, humidity) f 101: 27.2, 14; 103: 21.5, 66; Experiment (scientist, input, output) f 1: ``Lisa'', 101, 201; 2: ``Alex'', 103, 202; 3: ``Alex'', 101, 203; g Output (plant growth) f 201: 2.1; 203: 2.0; The data file is an ASCII text file describing the
Reference: [CDF + 94] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, and M. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 383-394, </pages> <year> 1994. </year>
Reference-contexts: We examine several techniques for dealing with circular and inverse relationships in our loading algorithms. We evaluate the performance of these algorithms with an analytic model and an implementation on top of the Shore object repository <ref> [CDF + 94] </ref>. We use the analytic model to explore a wide range of load file and system configurations. The implementation not only validates our analytic model, the performance of the algorithms also highlights several key advantages and disadvantages of using logical object identifiers. <p> However, we were only able to use about 16 Mb for any test run, due to operating system and daemon memory requirements. The database was stored under the Shore storage manager <ref> [CDF + 94] </ref> on a raw Seagate ST-12400N disk controlled exclusively by Shore. The data file resided on a separate disk on the local file system, and thus did not interfere with the database I/O. For these tests, we turned logging off.
Reference: [CMR92] <author> J. B. Cushing, D. Maier, and M. Rao. </author> <title> Computational Proxies: Modeling Scientific Applications in Object Databases. </title> <type> Technical Report 92-020, </type> <institution> Oregon Graduate Institute, </institution> <month> December </month> <year> 1992. </year> <note> Revised May, </note> <year> 1993. </year>
Reference-contexts: Users are currently spending too much time and effort just loading the data they want to examine. For example, Cushing reports that loading the experimental data was the most time-consuming part of analyzing a set of computational chemistry experiments <ref> [CMR92] </ref>. In addition, we know of another commercial OODB customer who currently spends 36 hours loading a single set of new data every month. A load utility takes a description of all the data to be created, usually in text format, and loads the corresponding objects into the database.
Reference: [DLP + 93] <author> R. Drach, S. Louis, G. Potter, G. Richmond, D. Rotem, H. Samet, A. Segev, and A. Shoshani. </author> <title> Optimizing Mass Storage Organization and Access for Multi-Dimensional Scientific Data. </title> <booktitle> In Proceedings of the IEEE Symposium on Mass Storage Systems, </booktitle> <address> Monterey, CA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: As an example, the climate modeling project at Lawrence Livermore National Laboratory has a very complex schema and generates single data points in the range of 20 to 150 Megabytes; a single data set typically contains 1 to 20 Gigabytes of data <ref> [DLP + 93] </ref>. Relational database systems provide a load utility to bypass the individual language statements; OODB need a similar facility. Users are currently spending too much time and effort just loading the data they want to examine.
Reference: [Mai94] <author> David Maier, </author> <month> January </month> <year> 1994. </year> <type> Personal communication. </type>
Reference-contexts: This is only possible with logical OIDs. We believe that any OODB that provides logical OIDs can also provide pre-assignment of OIDs; we know it is possible at the buffer manager level in GemStone <ref> [Mai94] </ref> and in Ontos, as well as in Shore. 2.5 Creating inverse relationships Whenever we find a relationship from object A to object B that has an inverse, we know we need to store the inverse relationship, i.e., store the OID for A in object B.
Reference: [Moh93a] <author> C. Mohan. </author> <title> A Survey of DBMS Research Issues in Supporting Very Large Tables. </title> <booktitle> In Proceedings of the International Conference on Foundations of Data Organization and Algorithms, </booktitle> <pages> pages 279-300, </pages> <address> Chicago, Il., 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A load utility takes a description of all the data to be created, usually in text format, and loads the corresponding objects into the database. Additionally, a load utility can group certain operations, such as integrity checks, to dramatically reduce their cost for the load <ref> [Moh93a] </ref>. Although a load utility is common in relational databases, we are aware of only one OODB load utility, in Objectivity/DB [Obj92], and it is limited in that it can only load data that already contains system-specific OIDs. <p> For relational integrity checking, it is known to be faster to load relations when integrity checking is deferred, because the integrity checks can be reordered to get better sequential I/O <ref> [Moh93a] </ref>. <p> The data file resided on a separate disk on the local file system, and thus did not interfere with the database I/O. For these tests, we turned logging off. It is important to be able to turn off logging when loading a lot of new data <ref> [Moh93a] </ref>; we found that when we used full logging, the log outgrew the database. It is unlikely that users have enough disk space to accomodate such a log. We used Shore as the underlying persistent object manager, even though Shore is still under development, for two reasons.
Reference: [Moh93b] <author> C. Mohan. </author> <title> IBM's Relational DBMS Products: Features and Technologies. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 445-448, </pages> <year> 1993. </year>
Reference-contexts: We feel that this is the best place for a load utility; the client-server communication overhead is greatly reduced. The implementors of DB2 experienced significantly better performance when the load utility interacted directly with the buffer manager, instead of as a client <ref> [Moh93b] </ref>. Additionally, the load algorithms have direct access to the server buffer pools and can determine what is in the buffer pool at any given time, which was needed by the algorithms that try to clear the todo list and inverse todo list.
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: We know of no other work involving loading data into an OODB. There are several published methods for mapping complex data structures to an ASCII or binary file, and then reading it back in again, including Snodgrass's Interface Description Language [Sno89], Pkl <ref> [Nel91] </ref> for Modula3 data, and Vegdahl's method for Smalltalk images [Veg86]. However, these methods do not address the problem of loading more data than can fit into virtual memory, and also ignore the performance issues that arise when the data to be loaded fits in virtual but not physical memory.
Reference: [Obj92] <institution> Objectivity, Inc. Objectivity/DB Documentation, </institution> <address> 2.0 edition, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Additionally, a load utility can group certain operations, such as integrity checks, to dramatically reduce their cost for the load [Moh93a]. Although a load utility is common in relational databases, we are aware of only one OODB load utility, in Objectivity/DB <ref> [Obj92] </ref>, and it is limited in that it can only load data that already contains system-specific OIDs. <p> Many OODB support system-maintained inverse relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>, and they are part of the ODMG standard [Cat93]. As an example, suppose that object A has an inverse relationship with object B. Then when B's OID is stored in A, A's OID should be stored in B.
Reference: [OHMS92] <author> J. Orenstein, S. Haradhvala, B. Margulies, and D. Sakahara. </author> <title> Query Processing in the ObjectStore Database System. </title> <editor> In M. Stonebreaker, editor, </editor> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 403-412, </pages> <year> 1992. </year>
Reference-contexts: Many OODB support system-maintained inverse relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>, and they are part of the ODMG standard [Cat93]. As an example, suppose that object A has an inverse relationship with object B. Then when B's OID is stored in A, A's OID should be stored in B.
Reference: [Ont92] <author> Ontos, Inc. </author> <note> Ontos DB Reference Manual, release 2.2 edition, February 1992. 22 </note>
Reference-contexts: Many OODB support system-maintained inverse relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>, and they are part of the ODMG standard [Cat93]. As an example, suppose that object A has an inverse relationship with object B. Then when B's OID is stored in A, A's OID should be stored in B.
Reference: [PG88] <author> N. W. Paton and P. M. D. Gray. </author> <title> Identification of Database Objects by Key. </title> <editor> In K. R. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems: 2nd International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 280-285, </pages> <address> Berlin, Germany, </address> <month> September </month> <year> 1988. </year> <note> Springer-Verlag. </note>
Reference-contexts: In this example, all the surrogates are integers, and they are unique in the data file. In general, however, the surrogates may be strings or numbers; if the class has a key they may even be part of the object's data <ref> [PG88] </ref>. The values for a collection relationship are listed inside curly brackets. Whenever one object references another object, the data file entry for the referencing object contains the surrogate for the referenced object.
Reference: [Sho93] <author> A. Shoshani. </author> <title> A Layered Apporach to Scientific Data Management at Lawrence Berkeley Laboratory. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 16(1) </volume> <pages> 4-8, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Scientific applications generate a large volume of data with many complex associations in the information structure <ref> [Sho93] </ref>. It is not uncommon for a single experiment to have input and output parameters that number in the hundreds and thousands, and must be loaded into the OODB for each experiment.
Reference: [Sno89] <author> R. Snodgrass. </author> <title> The Interface Description Language: Definition and Use. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: We know of no other work involving loading data into an OODB. There are several published methods for mapping complex data structures to an ASCII or binary file, and then reading it back in again, including Snodgrass's Interface Description Language <ref> [Sno89] </ref>, Pkl [Nel91] for Modula3 data, and Vegdahl's method for Smalltalk images [Veg86].
Reference: [Veg86] <author> S. R. Vegdahl. </author> <title> Moving Structures between Smalltalk Images. </title> <booktitle> In Proceedings of the International Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 466-471, </pages> <year> 1986. </year>
Reference-contexts: There are several published methods for mapping complex data structures to an ASCII or binary file, and then reading it back in again, including Snodgrass's Interface Description Language [Sno89], Pkl [Nel91] for Modula3 data, and Vegdahl's method for Smalltalk images <ref> [Veg86] </ref>. However, these methods do not address the problem of loading more data than can fit into virtual memory, and also ignore the performance issues that arise when the data to be loaded fits in virtual but not physical memory. The remainder of the paper is organized as follows.
Reference: [Ver93] <author> Versant Object Technology. </author> <title> Versant Object Database Management System C++Versant Manual, </title> <note> release 2 edition, </note> <month> July </month> <year> 1993. </year>
Reference-contexts: Many OODB support system-maintained inverse relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>, and they are part of the ODMG standard [Cat93]. As an example, suppose that object A has an inverse relationship with object B. Then when B's OID is stored in A, A's OID should be stored in B.
Reference: [WI93] <author> J. L. Wiener and Y. Ioannidis. </author> <title> A Moose and a Fox Can Aid Scientists with Data Management Problems. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <pages> pages 376-398, </pages> <address> New York, NY, 1993. </address> <publisher> Springer-Verlag. </publisher> <pages> 23 </pages>
Reference-contexts: Many OODB support system-maintained inverse relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>, and they are part of the ODMG standard [Cat93]. As an example, suppose that object A has an inverse relationship with object B. Then when B's OID is stored in A, A's OID should be stored in B. <p> We illustrate the data file format 1 Loading from binary data files would be similar. We chose to use ASCII files because they are transferrable across different 4 in Figure 2. Although we developed it for the Moose data model <ref> [WI93] </ref>, it fits a generic OO data model. Furthermore, any existing data file can be converted easily by a simple script to this format. Such conversions will be important for loading pre-existing data, such as the data many scientists have previously kept in flat files.
References-found: 17

