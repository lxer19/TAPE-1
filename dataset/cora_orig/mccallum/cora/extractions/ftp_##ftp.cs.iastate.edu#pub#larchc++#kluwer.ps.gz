URL: ftp://ftp.cs.iastate.edu/pub/larchc++/kluwer.ps.gz
Refering-URL: http://www.cs.iastate.edu/~leavens/larchc++.html
Root-URL: http://www.cs.iastate.edu
Title: An Overview of Larch/C++: Behavioral Specifications for C++ Modules  
Author: Gary T. Leavens TR #-e 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Date: February 1996, revised March, April 1996, January, July 1997, January 1999  
Abstract: Keywords: behavioral specification, model-based, behavioral interface specification language, Larch, C++, Larch/C++, Larch Shared Language, VDM, Z, correctness, verification, abstract data type, object-oriented, specification inheritance, example, checkable redundancy, behavioral subtype, informality, tunable formality. 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | Languages; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs | Assertions, invariants, pre- and post-conditions, specification techniques. Copyright c flKluwer Academic Publishers, 1996. Used by permission. An abbreviated and earlier version of this paper is chapter 8 in the book Specification of Behavioral Semantics in Object-Oriented Information Modeling , edited by Haim Kilov and William Harvey (Kluwer Academic Publishers, 1996), pages 121-142. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE: An object oriented Z environment. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91: European Conference on Object Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-199. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [25, 24], ZEST [10], Object-Z [41, 42], OOZE <ref> [1, 2, 3] </ref>, MooZ [37, 38], and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> The 3 FourSidedFigure (Scalar): trait includes PreVector (Scalar, Vector for Vec [T]), int, Val_Array (Vector) introduces isLoop: Arr [Vector] -&gt; Bool "&lt;__,__,__,__"&gt;: Vector, Vector, Vector, Vector -&gt; Arr [Vector] asserts "forall e: Arr [Vector], v1,v2,v3,v4:Vector isLoop (e) == (e [0] + e <ref> [1] </ref> + e [2] + e [3] = 0:Vector); "&lt;v1,v2,v3,v4"&gt; == assign (assign (assign (assign (create (4), 0,v1), 1,v2), 2,v3), 3,v4); implies "forall e: Arr [Vector], v1,v2,v3,v4:Vector size ("&lt;v1,v2,v3,v4"&gt;) == 4; ("&lt;v1,v2,v3,v4"&gt;)[0] == v1; ("&lt;v1,v2,v3,v4"&gt;)[2] == v3; allAllocated ("&lt;v1,v2,v3,v4"&gt;); converts isLoop:Arr [Vector] -&gt; Bool, "&lt;__,__,__,__"&gt;: Vector, Vector, Vector, Vector -&gt; Arr <p> //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ [25, 24], OOZE <ref> [1, 2, 3] </ref>, and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 . <p> IsaParallelogram (Scalar): trait includes FourSidedFigure (Scalar) introduces isaParallelogram: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaParallelogram (e) == isLoop (e) /" (e [0] + e [2] = 0:Vector); implies "forall e: Arr [Vector] isaParallelogram (e) == isLoop (e) /" (e <ref> [1] </ref> + e [3] = 0:Vector); in Object Orientation in Z [45]; whether this is a good idea for a design in C++ is debatable.) It inherits the specifications of each, including the ShearBy member function of Quadrilateral, and the invariant from ParallelShape (including the inherited invariant from QuadShape). <p> requires length (v1) = length (v2); //@ modifies edges, position; //@ ensures liberally edges' = "&lt;v1,v2,-v1,-v2"&gt; //@ /" position' = pos; //@ - IsaRhombus: trait includes IsaParallelogram introduces isaRhombus: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e <ref> [1] </ref>)); implies "forall e: Arr [Vector] isaRhombus (e) =&gt; isaParallelogram (e); isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e [2])); isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e [3])); points of similarity and difference. * The LSL traits specified in the examples correspond <p> - //@ requires v1 "cdot v2 = 0:Vector; //@ modifies edges, position; //@ ensures liberally edges' = "&lt;v1,v2,-v1,-v2"&gt; //@ /" position' = pos; //@ - IsaRectangle: trait includes IsaParallelogram introduces isaRectangle: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaRectangle (e) == isaParallelogram (e) /" (e [0] "cdot e <ref> [1] </ref> = 0); implies "forall e: Arr [Vector] isaRectangle (e) =&gt; isaParallelogram (e); isaRectangle (e) == isaParallelogram (e) /" (e [1] "cdot e [2] = 0); It is important that a formal specification language not require one to formalize every detail. <p> position' = pos; //@ - IsaRectangle: trait includes IsaParallelogram introduces isaRectangle: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaRectangle (e) == isaParallelogram (e) /" (e [0] "cdot e <ref> [1] </ref> = 0); implies "forall e: Arr [Vector] isaRectangle (e) =&gt; isaParallelogram (e); isaRectangle (e) == isaParallelogram (e) /" (e [1] "cdot e [2] = 0); It is important that a formal specification language not require one to formalize every detail.
Reference: [2] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE. </title> <editor> In Stepney et al. </editor> <volume> [45], </volume> <pages> pages 79-94. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [25, 24], ZEST [10], Object-Z [41, 42], OOZE <ref> [1, 2, 3] </ref>, MooZ [37, 38], and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> The 3 FourSidedFigure (Scalar): trait includes PreVector (Scalar, Vector for Vec [T]), int, Val_Array (Vector) introduces isLoop: Arr [Vector] -&gt; Bool "&lt;__,__,__,__"&gt;: Vector, Vector, Vector, Vector -&gt; Arr [Vector] asserts "forall e: Arr [Vector], v1,v2,v3,v4:Vector isLoop (e) == (e [0] + e [1] + e <ref> [2] </ref> + e [3] = 0:Vector); "&lt;v1,v2,v3,v4"&gt; == assign (assign (assign (assign (create (4), 0,v1), 1,v2), 2,v3), 3,v4); implies "forall e: Arr [Vector], v1,v2,v3,v4:Vector size ("&lt;v1,v2,v3,v4"&gt;) == 4; ("&lt;v1,v2,v3,v4"&gt;)[0] == v1; ("&lt;v1,v2,v3,v4"&gt;)[2] == v3; allAllocated ("&lt;v1,v2,v3,v4"&gt;); converts isLoop:Arr [Vector] -&gt; Bool, "&lt;__,__,__,__"&gt;: Vector, Vector, Vector, Vector -&gt; Arr [Vector] second part <p> //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ [25, 24], OOZE <ref> [1, 2, 3] </ref>, and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 . <p> IsaParallelogram (Scalar): trait includes FourSidedFigure (Scalar) introduces isaParallelogram: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaParallelogram (e) == isLoop (e) /" (e [0] + e <ref> [2] </ref> = 0:Vector); implies "forall e: Arr [Vector] isaParallelogram (e) == isLoop (e) /" (e [1] + e [3] = 0:Vector); in Object Orientation in Z [45]; whether this is a good idea for a design in C++ is debatable.) It inherits the specifications of each, including the ShearBy member function <p> IsaRhombus: trait includes IsaParallelogram introduces isaRhombus: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e [1])); implies "forall e: Arr [Vector] isaRhombus (e) =&gt; isaParallelogram (e); isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e <ref> [2] </ref>)); isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e [3])); points of similarity and difference. * The LSL traits specified in the examples correspond roughly to the Z specifications given in Chapter 2 of Object Orientation in Z [45]. <p> //@ - IsaRectangle: trait includes IsaParallelogram introduces isaRectangle: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaRectangle (e) == isaParallelogram (e) /" (e [0] "cdot e [1] = 0); implies "forall e: Arr [Vector] isaRectangle (e) =&gt; isaParallelogram (e); isaRectangle (e) == isaParallelogram (e) /" (e [1] "cdot e <ref> [2] </ref> = 0); It is important that a formal specification language not require one to formalize every detail.
Reference: [3] <author> A. J. Alencar and J. A. Goguen. </author> <title> Specification in OOZE with examples. </title> <booktitle> In Lano and Haughton [23], </booktitle> <pages> pages 158-183. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [25, 24], ZEST [10], Object-Z [41, 42], OOZE <ref> [1, 2, 3] </ref>, MooZ [37, 38], and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> For example, one can obtain the element at index 3 of an array value e by writing e <ref> [3] </ref>.) The LSL name for this type (sometimes called a sort) is Arr [Vector]. The trait Val Array has a type parameter, the type of its elements, and the actual parameter, Vector, replaces it. <p> The 3 FourSidedFigure (Scalar): trait includes PreVector (Scalar, Vector for Vec [T]), int, Val_Array (Vector) introduces isLoop: Arr [Vector] -&gt; Bool "&lt;__,__,__,__"&gt;: Vector, Vector, Vector, Vector -&gt; Arr [Vector] asserts "forall e: Arr [Vector], v1,v2,v3,v4:Vector isLoop (e) == (e [0] + e [1] + e [2] + e <ref> [3] </ref> = 0:Vector); "&lt;v1,v2,v3,v4"&gt; == assign (assign (assign (assign (create (4), 0,v1), 1,v2), 2,v3), 3,v4); implies "forall e: Arr [Vector], v1,v2,v3,v4:Vector size ("&lt;v1,v2,v3,v4"&gt;) == 4; ("&lt;v1,v2,v3,v4"&gt;)[0] == v1; ("&lt;v1,v2,v3,v4"&gt;)[2] == v3; allAllocated ("&lt;v1,v2,v3,v4"&gt;); converts isLoop:Arr [Vector] -&gt; Bool, "&lt;__,__,__,__"&gt;: Vector, Vector, Vector, Vector -&gt; Arr [Vector] second part says that the <p> //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ [25, 24], OOZE <ref> [1, 2, 3] </ref>, and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 . <p> IsaParallelogram (Scalar): trait includes FourSidedFigure (Scalar) introduces isaParallelogram: Arr [Vector] -&gt; Bool asserts "forall e: Arr [Vector] isaParallelogram (e) == isLoop (e) /" (e [0] + e [2] = 0:Vector); implies "forall e: Arr [Vector] isaParallelogram (e) == isLoop (e) /" (e [1] + e <ref> [3] </ref> = 0:Vector); in Object Orientation in Z [45]; whether this is a good idea for a design in C++ is debatable.) It inherits the specifications of each, including the ShearBy member function of Quadrilateral, and the invariant from ParallelShape (including the inherited invariant from QuadShape). <p> Arr [Vector] isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e [1])); implies "forall e: Arr [Vector] isaRhombus (e) =&gt; isaParallelogram (e); isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e [2])); isaRhombus (e) == isaParallelogram (e) /" (length (e [0]) = length (e <ref> [3] </ref>)); points of similarity and difference. * The LSL traits specified in the examples correspond roughly to the Z specifications given in Chapter 2 of Object Orientation in Z [45]. This says that LSL is roughly comparable to Z in terms of modeling power.
Reference: [4] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 31, 26, 36, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [11]. <p> As such, it has no "constructors" and therefore no objects will exist that 7 #ifndef QuadShape_h #define QuadShape_h #include "Vector.h" //@ uses FourSidedFigure; /*@ abstract @*/ class QuadShape - public: //@ spec Vector edges <ref> [4] </ref>; //@ spec Vector position; //@ invariant isLoop (edges"any); virtual Move (const Vector& v) throw (); //@ behavior - //@ requires assigned (v, pre); //@ requires redundantly assigned (edges, pre) //@ /" assigned (position, pre) /" isLoop (edges^); //@ modifies position; //@ trashes nothing; //@ ensures liberally position' = position^ +
Reference: [5] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioural subtyp-ing. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 31, 26, 36, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [11].
Reference: [6] <author> Alex Borgida, John Mylopoulos, and Rayomnd Reiter. </author> <title> On the frame problem in procedure specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10) </volume> <pages> 785-798, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: To illustrate most of the specification format, the behavioral specification of Move has seven clauses. The requires clause gives the function's precondition, the requires redundantly clause states a redundant property that must hold when the function is called, the modifies and trashes clauses form a frame axiom <ref> [6] </ref>, the ensures clause gives the function's post-condition, the example clause gives a redundant example of its execution, and the ensures redundantly clause states a redundant property of the specification. The postcondition, and the assertions in the example and ensures redundantly clauses, are predicates over two states.
Reference: [7] <author> Patrice Chalin. </author> <title> On the Language Design and Semantic Foundation of LCL, a Larch/C Interface Specification Language. </title> <type> PhD thesis, </type> <institution> Concordia University, 1455 de Maisonneuve Blvd. West, </institution> <address> Montreal, Quebec, Canada, </address> <month> October </month> <year> 1995. </year> <note> Available as CU/DCS TR 95-12, from the URL ftp://ftp.cs.concordia.ca/pub/chalin/tr.ps.Z. </note>
Reference-contexts: Having a distinction between modification and trashing may seem counterintuitive, but is important in helping shorten the specifications users have to write. In older versions of LCL and other Larch interface languages, these notions were not separated, which led to semantic problems <ref> [7, 8] </ref>. By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about whether objects are allocated and assigned in postconditions. <p> One semantic idea is the distinction between trashing and modification <ref> [7, 8] </ref>, which places the frame axiom of Larch-style specification languages on a firm semantic foundation. In Larch/C++ one can also specify such notions as whether storage is allocated or assigned.
Reference: [8] <author> Patrice Chalin, Peter Grogono, and T. Radhakrishnan. </author> <title> Identification of and solutions to shortcomings of LCL, a Larch/C interface specification language. </title> <editor> In Marie-Claude Gaudel and James Woodcock, editors, </editor> <booktitle> FME '96: Industrial Benefit and Advances in Formal Methods, volume 1051 of Lecture Notes in Computer Science, </booktitle> <pages> pages 385-404, </pages> <address> New York, N.Y., March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Having a distinction between modification and trashing may seem counterintuitive, but is important in helping shorten the specifications users have to write. In older versions of LCL and other Larch interface languages, these notions were not separated, which led to semantic problems <ref> [7, 8] </ref>. By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about whether objects are allocated and assigned in postconditions. <p> One semantic idea is the distinction between trashing and modification <ref> [7, 8] </ref>, which places the frame axiom of Larch-style specification languages on a firm semantic foundation. In Larch/C++ one can also specify such notions as whether storage is allocated or assigned.
Reference: [9] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> The Larch/Smalltalk interface specification language. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(3) </volume> <pages> 221-253, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Examples include LCL [16, Chapter 5] (for C), LM3 [16, Chapter 6] (for Modula-3), Larch/Ada [15] (for Ada), Larch/CLU [54, 53] (for CLU), Larch/Smalltalk <ref> [9] </ref> (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [22]. <p> //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ [25, 24], OOZE [1, 2, 3], and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk <ref> [9] </ref>, abstract models do not have to be given by specification variables 3 . For example, in Larch/C++, one can specify a supertype and a subtype and give both of them arbitrary models by writing an LSL trait for each. <p> In such a case, when one does not use specification variables to describe the abstract models of both the subtype and the supertype, giving a semantics to inherited specifications is a problem. See our other work <ref> [9, 27, 11] </ref> for how to handle such uncommon cases, and the Larch/C++ reference manual [30] for the details in Larch/C++.) The "constructor" specified for the class Quadrilateral has the same name as the class in C++.
Reference: [10] <editor> Elspeth Cusack and G. H. B. Rafsanjani. ZEST. In Stepney et al. </editor> <volume> [45], </volume> <pages> pages 113-126. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [25, 24], ZEST <ref> [10] </ref>, Object-Z [41, 42], OOZE [1, 2, 3], MooZ [37, 38], and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> trait PreVectorSpace, found in Figure 4, is used. (The trait DistributiveRingAction is found in [28], the other traits are from [16, Appendix A].) Now that we are done with the initial mathematical modeling, we can turn to the behavioral interface specifications. 2.2 Specification of QuadShape and Quadrilateral Following the ZEST <ref> [10] </ref> and Fresco [51] specifications of the shapes example, the first class to specify is an abstract class of four-sided figures, QuadShape. The reason for this is that, if we follow [45, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ [25, 24], OOZE [1, 2, 3], and ZEST <ref> [10] </ref>. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 . <p> Using the trait NoContainedObjects (Shear) is enough to tell Larch/C++ that the abstract values are explicitly specified. 3 Other Subtypes of QuadShape This section contains the specifications of the other subtypes of QuadShape described in Object Orientation in Z [45]. As in the ZEST specification of the shapes examples <ref> [10] </ref>, we start with the abstract type ParallelShape, which is shown in Figure 11.
Reference: [11] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses <ref> [11] </ref>. Thus we will follow the ZEST and Fresco specifications in using an abstract class without a shear operation as the superclass of Quadrilateral. The Larch/C++ specification of the abstract class QuadShape is given in Figure 5. <p> Technically, in Larch/C++ behavioral subtyping is forced by inheriting the specification of the supertype's invariant and virtual member functions in the subtype <ref> [11] </ref>. Since we have used specification variables in this example, and since these are inherited as in C++, the virtual member function specifications of the supertype, QuadShape, are easy to apply to the subtype. <p> In such a case, when one does not use specification variables to describe the abstract models of both the subtype and the supertype, giving a semantics to inherited specifications is a problem. See our other work <ref> [9, 27, 11] </ref> for how to handle such uncommon cases, and the Larch/C++ reference manual [30] for the details in Larch/C++.) The "constructor" specified for the class Quadrilateral has the same name as the class in C++. <p> In our other work <ref> [11, 30] </ref>, we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. However, the shapes example does permit direct comparison to the OO specification languages presented in Object Orientation in Z [45]. <p> Allowing the specification of several specification cases (an idea due to Wing [54, Section 4.1.4] and Wills [50, 51, 52]) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance <ref> [11] </ref>. Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [18].
Reference: [12] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Larch/C++ [30] is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ <ref> [12, 46] </ref> program module. 1.1 Model-Based Specification The idea of model-based specifications builds on two seminal papers by Hoare. Hoare's paper "An Axiomatic Basis for Computer Programming" [19], used two predicates over program states to specify a computation.
Reference: [13] <author> Kokichi Futatsugi, Joseph A. Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <booktitle> Principles of OBJ2. In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1985. </year>
Reference-contexts: (The first three assumed traits are found in [16, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in [28].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ <ref> [14, 13] </ref>. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. In the implies of PreVector, the naming of another trait, in this case PreVectorSig (T), says that the theory of that trait is included in this trait's theory.
Reference: [14] <author> Joseph A. Goguen. </author> <title> Parameterized programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: (The first three assumed traits are found in [16, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in [28].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ <ref> [14, 13] </ref>. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. In the implies of PreVector, the naming of another trait, in this case PreVectorSig (T), says that the theory of that trait is included in this trait's theory.
Reference: [15] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Examples include LCL [16, Chapter 5] (for C), LM3 [16, Chapter 6] (for Modula-3), Larch/Ada <ref> [15] </ref> (for Ada), Larch/CLU [54, 53] (for CLU), Larch/Smalltalk [9] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [22].
Reference: [16] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year> <month> 19 </month>
Reference-contexts: CCR-9803843. 1 in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [54, 53, 16] </ref>: * Although a mathematical toolkit is provided [16, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [16, Chapter 4]. <p> has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions [54, 53, 16]: * Although a mathematical toolkit is provided <ref> [16, Appendix A] </ref>, specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [16, Chapter 4]. <p> specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions [54, 53, 16]: * Although a mathematical toolkit is provided [16, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) <ref> [16, Chapter 4] </ref>. This allows users, if they desire, to create and use an abstract model at exactly the right level of abstraction; that is, one can either build an abstract model out of readily available parts, or one can build a model from scratch. <p> Examples include LCL <ref> [16, Chapter 5] </ref> (for C), LM3 [16, Chapter 6] (for Modula-3), Larch/Ada [15] (for Ada), Larch/CLU [54, 53] (for CLU), Larch/Smalltalk [9] (for Smalltalk) and Larch/C++. <p> Examples include LCL [16, Chapter 5] (for C), LM3 <ref> [16, Chapter 6] </ref> (for Modula-3), Larch/Ada [15] (for Ada), Larch/CLU [54, 53] (for CLU), Larch/Smalltalk [9] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [22]. <p> (See Section2.2 for the Larch/C++ interface specification.) 2.1 Vocabulary for Specifying Quadrilaterals Although LSL has the power to specify abstract models "from scratch," most abstract models are built using tuples (records), sets, and other standard mathematical tools that are either built-in to LSL or found in Guttag and Horning's Handbook <ref> [16, Appendix A] </ref>. A typical example is given in Figure 1. That figure specifies a theory in LSL, using a LSL module, which is called a trait . <p> One can attempt to formally prove that the theory stated in the implies section follows from the rest of the specification using a theorem prover, and that may be helpful in "debugging" the specification <ref> [16, Chapter 7] </ref>. In Object Orientation in Z [45], vectors are usually treated as a given set, meaning that their specification is of no interest. <p> In the assumes clause of PreVector, the type T is required to be a ring with a unit element, have a commutative multiplication operator (*), be totally ordered, and have conversions to and from the real numbers. (The first three assumed traits are found in <ref> [16, Appendix A] </ref>; the last trait, and the included trait Real that specifies the real numbers, are found in [28].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ [14, 13]. <p> However, note that the length operator is not so well-specified, and thus is not named in the converts clause. To push this mathematical modeling back to standard traits, the trait PreVectorSpace, found in Figure 4, is used. (The trait DistributiveRingAction is found in [28], the other traits are from <ref> [16, Appendix A] </ref>.) Now that we are done with the initial mathematical modeling, we can turn to the behavioral interface specifications. 2.2 Specification of QuadShape and Quadrilateral Following the ZEST [10] and Fresco [51] specifications of the shapes example, the first class to specify is an abstract class of four-sided figures, <p> Thus i is not considered an object within the specification. This is why i denotes an int value, and why notations such as i^ are not used <ref> [16, Chapter 5] </ref>. The invariant clause (found just before Move's specification) describes a property that must be true of each assigned object of type QuadShape in each visible state [40]; it can also be thought of as restricting the space of values for the class. <p> (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ [25, 24], OOZE [1, 2, 3], and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 <ref> [16, Chapter 6] </ref>, and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 . For example, in Larch/C++, one can specify a supertype and a subtype and give both of them arbitrary models by writing an LSL trait for each.
Reference: [17] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice--Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: A model-based specification language combines these ideas. That is, it specifies procedures (what C++ calls functions), using pre- and postconditions. The pre- and postcondi-tions use the vocabulary specified in an abstract model, which specifies the abstract values mathematically. The best-known model-based specification languages are VDM-SL [21] and Z <ref> [44, 43, 17] </ref>. Both come with a mathematical toolkit from which a user can assemble abstract models for use in specifying procedures.
Reference: [18] <author> Wim H. Hesselink. </author> <title> Programs, Recursion, and Unbounded Choice, </title> <booktitle> volume 27 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete <ref> [18] </ref>. The Larch approach of behavioral interface specification [54, 53], and the expressive features of Larch/C++ make it a step towards the more practical and useful formal documentation for object-oriented classes. 18 Acknowledgements This work was supported in part by NSF grants CCR-9503168 and CCR-9803843.
Reference: [19] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Hoare's paper "An Axiomatic Basis for Computer Programming" <ref> [19] </ref>, used two predicates over program states to specify a computation. The first predicate specifies the requirements on the state before the computation; it is called the computation's precondition. The second predicate specifies the desired final state; it is called the computation's postcondition. <p> More important, allowing the user to specify both total and partial correctness for functions gives to users a choice previously reserved by specification language designers; the use of partial correctness, for example, is necessary for succinct specification of functions that may fail due to the finiteness of various data structures <ref> [19] </ref>. Allowing the specification of several specification cases (an idea due to Wing [54, Section 4.1.4] and Wills [50, 51, 52]) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [11].
Reference: [20] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: The first predicate specifies the requirements on the state before the computation; it is called the computation's precondition. The second predicate specifies the desired final state; it is called the computation's postcondition. Hoare's paper "Proof of correctness of data representations" <ref> [20] </ref>, described the verification of abstract data type (ADT) implementations. In this paper Hoare introduced the use of an abstraction function that maps the implementation data structure (e.g., an array) to a mathematical value space (e.g., a set). The elements of this value space are thus called abstract values [35].
Reference: [21] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: A model-based specification language combines these ideas. That is, it specifies procedures (what C++ calls functions), using pre- and postconditions. The pre- and postcondi-tions use the vocabulary specified in an abstract model, which specifies the abstract values mathematically. The best-known model-based specification languages are VDM-SL <ref> [21] </ref> and Z [44, 43, 17]. Both come with a mathematical toolkit from which a user can assemble abstract models for use in specifying procedures.
Reference: [22] <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed <ref> [22] </ref>. This is of great practical benefit, because the details of the interface that need to be specified vary among programming languages.
Reference: [23] <author> K. Lano and H. Haughton, </author> <title> editors. Object-Oriented Specification Case Studies. The Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference: [24] <author> K. Lano and H. Haughton. </author> <title> Specifying a concept-recognition system in Z++. </title> <booktitle> In Lano and Haughton [23], chapter 7, </booktitle> <pages> pages 137-157. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ <ref> [25, 24] </ref>, ZEST [10], Object-Z [41, 42], OOZE [1, 2, 3], MooZ [37, 38], and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> position' = pos; //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ <ref> [25, 24] </ref>, OOZE [1, 2, 3], and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 .
Reference: [25] <editor> Kevin C. Lano. Z++. In Stepney et al. </editor> <volume> [45], </volume> <pages> pages 106-112. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ <ref> [25, 24] </ref>, ZEST [10], Object-Z [41, 42], OOZE [1, 2, 3], MooZ [37, 38], and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> position' = pos; //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ [37, 38], VDM++ [39], Z++ <ref> [25, 24] </ref>, OOZE [1, 2, 3], and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 .
Reference: [26] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 31, 26, 36, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [11].
Reference: [27] <author> Gary T. Leavens. </author> <title> Inheritance of interface specifications (extended abstract). </title> <booktitle> In Proceedings of the Workshop on Interface Definition Languages, volume 29(8) of ACM SIGPLAN Notices, </booktitle> <pages> pages 129-138, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: In such a case, when one does not use specification variables to describe the abstract models of both the subtype and the supertype, giving a semantics to inherited specifications is a problem. See our other work <ref> [9, 27, 11] </ref> for how to handle such uncommon cases, and the Larch/C++ reference manual [30] for the details in Larch/C++.) The "constructor" specified for the class Quadrilateral has the same name as the class in C++.
Reference: [28] <author> Gary T. Leavens. </author> <note> LSL math traits. http://www.cs.iastate.edu/~leavens/Math-traits.html, Jan 1996. </note>
Reference-contexts: ring with a unit element, have a commutative multiplication operator (*), be totally ordered, and have conversions to and from the real numbers. (The first three assumed traits are found in [16, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in <ref> [28] </ref>.) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ [14, 13]. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. <p> However, note that the length operator is not so well-specified, and thus is not named in the converts clause. To push this mathematical modeling back to standard traits, the trait PreVectorSpace, found in Figure 4, is used. (The trait DistributiveRingAction is found in <ref> [28] </ref>, the other traits are from [16, Appendix A].) Now that we are done with the initial mathematical modeling, we can turn to the behavioral interface specifications. 2.2 Specification of QuadShape and Quadrilateral Following the ZEST [10] and Fresco [51] specifications of the shapes example, the first class to specify is
Reference: [29] <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioral specifications for C++ modules. </title> <editor> In Haim Kilov and William Harvey, editors, </editor> <booktitle> Specification of Behavioral Semantics in Object-Oriented Information Modeling, chapter 8, </booktitle> <pages> pages 121-142. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1996. </year> <note> An extended version is TR #96-01d, </note> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011. </month>
Reference-contexts: This was done in the original version of this paper <ref> [29] </ref>, and can be seen in other examples below.) The invariant clause will be explained following the explanation of the member function specifications. 8 Each member function specification looks like a C++ member function declaration, followed by a specification of the function's behavior. <p> Informal terms, and their tight integration into Larch/C++, 3 Indeed, Larch/C++ is the only Larch-style BISL for which abstract models can be given by using specification variables. 12 //@ spec class Shear; //@ uses NoContainedObjects (Shear); //see a book on computer graphics is something that is new with Larch/C++ <ref> [29] </ref>. The type Shear is specified as a given set in Figure 10. In this example, no signature is given for the trait functions that operate on the type Shear, because that type is only used informally.
Reference: [30] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.25. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the World Wide Web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, January 1999. </note>
Reference-contexts: 1 Introduction Larch/C++ <ref> [30] </ref> is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ [12, 46] program module. 1.1 Model-Based Specification The idea of model-based specifications builds on two seminal papers by Hoare. <p> However, it was more convenient to think of the four edge vectors as components of some structure, so they are modeled as part of an array. Arrays are already modeled by a built-in trait of Larch/C++ <ref> [30, Section 11.7] </ref>, but it was convenient to define some vocabulary (operators) for creating an array of values, and for testing to see whether the vectors in such an array make a loop. In Larch/C++, such vocabulary is specified in a LSL trait. <p> The first of these gives part of the model for vectors, and will be discussed further below. The second of these gives a model for the C++ type int with appropriate auxiliary definitions for C++ <ref> [30, Section 11.1.5] </ref>. The last of these gives a model for the abstract values of C++ arrays of vectors [30, Section 11.7]. <p> The second of these gives a model for the C++ type int with appropriate auxiliary definitions for C++ [30, Section 11.1.5]. The last of these gives a model for the abstract values of C++ arrays of vectors <ref> [30, Section 11.7] </ref>. This model includes such operations as indexing into an array using the __ [__] operator. (LSL uses the notation __ to indicate the places where arguments to mixfix operators can be passed. <p> In Larch/C++, one could also specify QuadShape as a C++ template class with the types Vector and Scalar as type parameters <ref> [30, Chapter 8] </ref>, but the approach adopted here is more in keeping with the examples in Object Orientation in Z [45]. In the specification of QuadShape, the first thing to note is that the syntax that is not in comments is the same as in C++. <p> The box may also be empty. When the box empty, the object is said to be unassigned ; an object is assigned when it contains a proper value. C++ objects are formally modeled in Larch/C++ using various traits <ref> [30, Section 2.8] </ref>, and these traits allow one to write assigned (v, pre), as in the precondition of Move, to assert that the object v is allocated and assigned in the pre-state. (The pre-and post-states are reified in Larch/C++ using the keywords pre and post.) There is also a more useful <p> For example, the first two conjuncts of Move's requires redundantly clause say that the specification variables edges and position are assigned in the pre-state. (The notation /" means "and".) This highlights the semantics of Larch/C++, which implicitly requires that all data members be assigned in visible states <ref> [30, Section 6.2.2] </ref>. (The pre-state of a constructor, and the post-state of a destructor are not considered visible states, and so are exempt from this requirement.) The last conjunct says that the invariant holds in the pre-state. The requires redundantly clause is new with Larch/C++. <p> This is because, unless an object is named in the trashes clause, it must remain allocated if it was allocated in the pre-state, and if it was assigned in the pre-state, then it must also remain assigned in the post-state <ref> [30, Section 6.2.3] </ref>. An example clause adds checkable redundancy to a specification. There may be several examples listed in a single function specification in Larch/C++. For each example, what is checked is roughly that the example's assertion, together with the precondition should imply the postcondition [30, Section 6.8]. <p> An example clause adds checkable redundancy to a specification. There may be several examples listed in a single function specification in Larch/C++. For each example, what is checked is roughly that the example's assertion, together with the precondition should imply the postcondition <ref> [30, Section 6.8] </ref>. As far as we know, this idea of adding examples to formal function specifications is new in Larch/C++. Another instance of the checkable redundancy idea is the ensures redundantly clause. <p> For types like Vector, whose abstract values do not contain any objects, one can do this by simply including an instance of the trait NoContainedObjects <ref> [30, Section 7.5] </ref> to specify contained objects in a way that says there are no subobjects in the abstract values. The same trick for treating Vector as a given type is also used for the type Scalar. Its specification is given in Figure 7. <p> See our other work [9, 27, 11] for how to handle such uncommon cases, and the Larch/C++ reference manual <ref> [30] </ref> for the details in Larch/C++.) The "constructor" specified for the class Quadrilateral has the same name as the class in C++. Constructors in C++ really are initializers, and this constructor must set the post-state values of the specification variables to the appropriate abstract value. <p> This specification uses an instance of the Larch/C++ built-in trait NoInformationExecption <ref> [30, Section 6.10] </ref> to specify the abstract model of the type NoInterior. This trait is designed as an aid in specifying abstract models for exception types in which no significant information is being passed; it says that there is only one abstract value: theException. <p> In our other work <ref> [11, 30] </ref>, we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. However, the shapes example does permit direct comparison to the OO specification languages presented in Object Orientation in Z [45].
Reference: [31] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 31, 26, 36, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [11].
Reference: [32] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32(8) </volume> <pages> 705-778, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 31, 26, 36, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [11].
Reference: [33] <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifications. </title> <type> Technical Report 96-04d, </type> <institution> Iowa State University, Department of Computer Science, </institution> <month> September </month> <year> 1997. </year> <editor> In Michel Bidoit and Max Dauchet (editors), </editor> <booktitle> TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France. Volume 1214 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997, </year> <pages> pages 520-534. </pages> <note> Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: The specification of AnglePar illustrates how to specify exceptions to handle such cases. (By specifying an exception, the normal case is allowed to have a stronger precondition, and hence its precondition can protect the postcondition from undefinedness <ref> [33] </ref>.) Note first that the body of AnglePar has two pairs of pre- and postcondition specifications.
Reference: [34] <author> K. Rustan M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: An example of how to do this is shown in Figure 6. (Since the class Vector is declared using the keyword spec, an implementation does not have to declare it as a class, 2 Following Leino's work <ref> [34] </ref>, if an object o mentioned in a modifies clause has been declared to depend on some other object o 0 , then o 0 may also be modified. The same qualification is also applied to the trashes clause.
Reference: [35] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: In this paper Hoare introduced the use of an abstraction function that maps the implementation data structure (e.g., an array) to a mathematical value space (e.g., a set). The elements of this value space are thus called abstract values <ref> [35] </ref>. The idea is that one specifies the ADT using the abstract values, which allows clients of the ADT's operations to reason about calls without worrying about the details of the implementation. A model-based specification language combines these ideas.
Reference: [36] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 31, 26, 36, 32] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unimplementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public superclasses [11].
Reference: [37] <author> Silvio Lemos Meira and Ana Lucia C. Cavalcanti. </author> <title> MooZ case studies. </title> <editor> In Stepney et al. </editor> <volume> [45], </volume> <pages> pages 37-58. 20 </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [25, 24], ZEST [10], Object-Z [41, 42], OOZE [1, 2, 3], MooZ <ref> [37, 38] </ref>, and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> liberally edges' = "&lt;v1,v2,v3,v4"&gt; /" position' = pos; //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ <ref> [37, 38] </ref>, VDM++ [39], Z++ [25, 24], OOZE [1, 2, 3], and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 .
Reference: [38] <author> Silvio Lemos Meira, Ana Lucia C. Cavalcanti, and Cassio Souza Santos. </author> <title> The Unix filing system: </title>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [25, 24], ZEST [10], Object-Z [41, 42], OOZE [1, 2, 3], MooZ <ref> [37, 38] </ref>, and VDM++ [39]. However, apparently there are "variants of Fresco" [50, 52] that are "derived from C++ and Smalltalk" [51, p. 135]; these may permit more exact specification of interface details. <p> liberally edges' = "&lt;v1,v2,v3,v4"&gt; /" position' = pos; //@ - virtual void ShearBy (const Shear& s) throw (); //@ behavior - //@ requires assigned (s, pre); //@ modifies self; //@ ensures informally "self is sheared by s"; //@ - Quadrilateral.h). in other OO specification languages, including Object-Z [41, 42], MooZ <ref> [37, 38] </ref>, VDM++ [39], Z++ [25, 24], OOZE [1, 2, 3], and ZEST [10]. (In Larch/C++, and in other Larch-style BISLs, such as LM3 [16, Chapter 6], and Larch/Smalltalk [9], abstract models do not have to be given by specification variables 3 .
References-found: 38

