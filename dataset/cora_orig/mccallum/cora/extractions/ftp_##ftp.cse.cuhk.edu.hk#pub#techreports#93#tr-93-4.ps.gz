URL: ftp://ftp.cse.cuhk.edu.hk/pub/techreports/93/tr-93-4.ps.gz
Refering-URL: ftp://ftp.cs.cuhk.hk/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: bmtong@cuhk.hk, lhf@cuhk.hk  
Title: Concurrent Constraint Logic Programming on Massively Parallel SIMD Computers  
Author: Bo-Ming Tong and Ho-Fung Leung 
Date: July 8, 1993  
Address: Shatin, New Territories Hong Kong  
Affiliation: Department of Computer Science The Chinese University of Hong Kong  
Pubnum: Technical Report CS-TR-93/04  
Abstract: With the advent of cost-effective massively parallel computers, researchers conjecture that the future constraint logic programming system is composed of a massively parallel constraint solver as the back-end with a concurrent inference engine as the front-end [Coh90]. This paper represents an attempt to build a constraint logic programming system on a massively parallel SIMD computer. A concurrent constraint logic programming language called Firebird is presented in this paper. Firebird can handle finite domain constraints and supports both concurrency and data-parallelism. As a result, it is suitable for both multiprocessors and SIMD computers. Concurrency arises from the stream and-parallelism of committed-choice logic programming languages. In a nondeterministic derivation step, one of the domain variables is selected to create a choice point. All possible alternatives are attempted in parallel. Data-parallelism is exploited in the resulting or-parallel execution. Firebird is currently being implemented on a DECmpp 12000 Sx-100 1 massively parallel computer. On finding all the solutions to the 8-queens problem, Fire-bird on a MasPar MP-2 is about 20 times faster than CHIP [DVHS + 88] on a DECstation 3100. fl A slightly different version of this paper will appear in Proceedings of the International Logic Programming Symposium, Vancouver, 1993. 1 DECmpp 12000 Sx-100 is equivalent to MasPar MP-1. 
Abstract-found: 1
Intro-found: 1
Reference: [AK91] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The back-end is responsible for program execution, and the front-end workstation is used only for input and output. A compiler which employs the decision graph [KS90] compilation technique is used to generate Firebird Abstract Machine (FAM) code. FAM is very different from WAM <ref> [AK91] </ref>. Since 9 each processor element is very small and slow 3 , parallelism is easily counter-balanced by the slow execution of the processor elements. Memory operations are particularly slow. <p> For instance, the wide-tag memory architecture is a reminiscence of the `tag on data' representation. Both schemes make the differentiation between lists, structures and atoms unnecessary. They are also more suitable for decision graph compilation [KS90] than WAM <ref> [AK91] </ref>. We are unaware of any parallel execution schemes for constraint logic programming languages on massively parallel SIMD computers.
Reference: [Bla90] <author> T. Blank. </author> <title> The Maspar MP-1 architecture. </title> <booktitle> In Proceedings of the IEEE COMPCON Spring 1990, </booktitle> <pages> pages 20-24, </pages> <address> San Francisco, Febru-ary 1990. </address> <publisher> IEEE. </publisher>
Reference-contexts: After a clause commits, tell constraints are added to the store and body goals are spawned. Computation fails if the store becomes inconsistent. 1.3 The DECmpp Massively Parallel Computer The Firebird language is currently being implemented on a DECmpp <ref> [Bla90] </ref>, which consists of a front-end UNIX workstation and a back-end called the data-parallel unit. The data-parallel unit in turn consists of an array control unit (ACU), a processor element array (PE) and a inter-processor communication network which supports both mesh and arbitrary communication patterns.
Reference: [BM92] <author> J. Barklund and H. Millroth. </author> <title> Providing iteration and concurrency in logic programs through bounded quantifications. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 817-824, </pages> <publisher> ICOT, </publisher> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: They are also more suitable for decision graph compilation [KS90] than WAM [AK91]. We are unaware of any parallel execution schemes for constraint logic programming languages on massively parallel SIMD computers. However, there have been a number of SIMD implementations of logic programming languages <ref> [KB87, NT88a, NT88b, BM92] </ref>. 7 Future Work Each processor element in the back-end is much slower than the sequential front-end. Performance will be improved if sequential parts of the execution can be separated out and performed at the front-end.
Reference: [CG85] <author> K. L. Clark and S. Gregory. </author> <title> Notes on the implementation of Parlog. </title> <journal> The Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 17-42, </pages> <month> April </month> <year> 1985,. </year>
Reference-contexts: A clause is of the form H G j B; B 0 where G is a conjunction of constraints called the guard, B is a conjunction of atoms and B 0 a conjunction of constraints, assuming that all head matchings have been transformed to guard tests <ref> [CG85] </ref>. We define a goal G to be a multiset A of atoms plus a multiset C of constraints. G and its multiset of atoms and constraints are annotated by a (possibly empty) list of non-negative integers and subscripted by an integer i, i.e. G i = (A i ). <p> All unifications in the guard are first converted to Parlog-style synchronization primitives (=, &lt;=, ==) <ref> [CG85] </ref>. = is always evaluated at compile-time in order to postpone all term building after commitment. 5.5 Instructions The Firebird Abstract Machine does not have any unify instructions. There is a built-in procedure unify, which is treated indifferently just like user procedures, for body unifications.
Reference: [CG86] <author> K. L. Clark and S. Gregory. </author> <title> Parlog: Parallel programming in logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(1) </volume> <pages> 1-49, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: However, it is not applicable to certain domains, including the finite domain, where the notion of nondeterminism is inherent. We have built a prototype implementation of a concurrent constraint logic programming language called FD-Parlog [LTC93], which is similar to Firebird but is based on Parlog <ref> [CG86] </ref>. [LTC93] has a proof of soundness and conditional completeness of the Firebird Computation Model. Nondeterministic derivation in Firebird is inspired by the Andorra Computation Model [War90], but the semantics are fundamentally different.
Reference: [Chr90] <author> P. Christy. </author> <title> Software to support massively parallel computing on the Maspar MP-1. </title> <booktitle> In Proceedings of the IEEE COMPCON Spring 1990, </booktitle> <pages> pages 29-33, </pages> <address> San Francisco, </address> <month> February </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: One of the vector registers is reserved as the system-wide status word and p0 of each procedure is used as 32 single-bit registers. In order to support register windows, we do not use the MasPar Application Language (MPL) <ref> [Chr90] </ref> to implement our runtime libraries but assembly language is used instead. 5.3 Process Management A process structure resides on ACU.
Reference: [Cla78] <author> K. L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year> <month> 18 </month>
Reference-contexts: A 00 = ;. then G 0 has a successful derivation with a final constraint set C 0 i such that P fl ; D j= C ! 9y i (C 0 i ). Here P fl is the Clark's completion of P <ref> [Cla78] </ref>. 4 Exploitation of Data-Parallelism in Firebird Although each partition is an independent derivation sequence, the partitions can be executed in parallel on SIMD computers if, in an indeterministic derivation step, we choose an atom A in each A i in such a way that the principal functor and arity of
Reference: [Coh90] <author> J. Cohen. </author> <title> Constraint logic programming languages. </title> <journal> Communica--tions of the ACM, </journal> <volume> 33(7) </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Programs in CLP languages are thus both more declarative and efficient. With the advent of cost-effective massively parallel SIMD computers, researchers conjecture that the future constraint logic programming system is composed of a massively parallel constraint solver as the back-end with a concurrent inference engine as the front-end <ref> [Coh90] </ref>. This paper represents an attempt to build a constraint logic programming system on a massively parallel computer. Firebird is a language with finite domain constraint handling capabilities. It is designed to exploit both data-parallelism and concurrency. In many ways it resembles an ordinary committed-choice logic programming language.
Reference: [Cra90] <author> J. Crammond. </author> <title> The abstract machine and implementation of Parallel Parlog. </title> <type> Technical report, </type> <institution> Department of Computing, Imperial College, </institution> <address> London, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: Otherwise, the process has already been resumed by another assignment and can be ignored. It is not necessary to treat multi-suspend (a process suspends on more than one variable) as a special case like the hanger scheme in Parallel Parlog <ref> [Cra90] </ref>. The hanger scheme improves the efficiency of single-suspend, but for finite domain constraints, multi-suspend is more the rule than the exception. Moreover, single-suspend is difficult to implement on a SIMD computer.
Reference: [DVHS + 88] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 693-702, </pages> <address> Japan, 1988. </address> <publisher> ICOT. </publisher>
Reference-contexts: In this way, thousands of finite domain constraints can be solved in a single step. 1.1 Finite Domain Constraints Finite domain constraints are first incorporated into the constraint logic programming language CHIP (Constraint Handling In Prolog) <ref> [DVHS + 88] </ref>. A finite domain is a finite non-empty set of constants which is the allowed range of values for a domain variable, or simply a d-variable. Ordinary variables are termed h-variables (h stands for Herbrand). A d-variable with domain d is denoted by X d . <p> All the times shown are in milliseconds. n 4 5 6 7 8 MP-2 6.7 10.3 14.7 19.8 25.7 On finding all the solutions to 8-queens, our implementation on MasPar MP-2 is about 20 times faster than CHIP <ref> [DVHS + 88] </ref> on a DECstation 3100. 6 Related Work Firebird can be regarded as flat GHC [Ued85] extended with finite domain constraint handling capabilities. The consistency techniques used in Firebird are the same as those used in CHIP [VH89].
Reference: [Hil85] <author> W. D. Hillis. </author> <title> The Connection Machine. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: To build practical logic programming systems we need computers with fewer but individually more powerful processor elements. Moreover, since the original intention of the Connection Machine <ref> [Hil85] </ref> is to alleviate the memory-processor bottleneck, it is unreasonable for a cluster of several processor elements to share a memory port as in DECmpp.
Reference: [JL87] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <address> Munich, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint logic programming <ref> [JL87] </ref> generalized logic programming by replacing the first-order unification algorithm by a general mechanism called constraint satisfaction. In this way, constraints no longer need to be used passively with a generate-and-test strategy. Rather, they may be used actively to prune the search space in an a priori manner.
Reference: [KB87] <author> P. Kacsuk and A. Bale. </author> <title> DAP Prolog: A set-oriented approach to Prolog. </title> <journal> The Computer Journal, </journal> <volume> 30(5) </volume> <pages> 393-403, </pages> <year> 1987. </year>
Reference-contexts: They are also more suitable for decision graph compilation [KS90] than WAM [AK91]. We are unaware of any parallel execution schemes for constraint logic programming languages on massively parallel SIMD computers. However, there have been a number of SIMD implementations of logic programming languages <ref> [KB87, NT88a, NT88b, BM92] </ref>. 7 Future Work Each processor element in the back-end is much slower than the sequential front-end. Performance will be improved if sequential parts of the execution can be separated out and performed at the front-end.
Reference: [KS90] <author> S. Kliger and E. Shapiro. </author> <title> From decision trees to decision graphs. </title> <editor> In Saumya Debray and Manuel Hermenegildo, editors, </editor> <booktitle> Proceedings of the 1990 North American Conference on Logic Programming, </booktitle> <pages> pages 97-116, </pages> <address> Austin, 1990. </address> <publisher> ALP, MIT Press. </publisher>
Reference-contexts: The back-end is responsible for program execution, and the front-end workstation is used only for input and output. A compiler which employs the decision graph <ref> [KS90] </ref> compilation technique is used to generate Firebird Abstract Machine (FAM) code. FAM is very different from WAM [AK91]. Since 9 each processor element is very small and slow 3 , parallelism is easily counter-balanced by the slow execution of the processor elements. Memory operations are particularly slow. <p> The deadlock flag is a bit in the status word. In addition, there is an active flag in the status word to identify physical partitions which has not yet failed. 5.4 Guard Tests All guard tests are handled by the decision graph compilation procedure <ref> [KS90] </ref>. All unifications in the guard are first converted to Parlog-style synchronization primitives (=, &lt;=, ==) [CG85]. = is always evaluated at compile-time in order to postpone all term building after commitment. 5.5 Instructions The Firebird Abstract Machine does not have any unify instructions. <p> The Firebird Abstract Machine is influenced by the abstract machine of BinProlog [Tar92]. For instance, the wide-tag memory architecture is a reminiscence of the `tag on data' representation. Both schemes make the differentiation between lists, structures and atoms unnecessary. They are also more suitable for decision graph compilation <ref> [KS90] </ref> than WAM [AK91]. We are unaware of any parallel execution schemes for constraint logic programming languages on massively parallel SIMD computers.
Reference: [LTC93] <author> H. F. Leung, B. M. Tong, and K. L. Clark. </author> <title> The Firebird computation model for finite domain constraint solving in concurrent logic programming and its realization in FD-Parlog. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: For example, if the domain of variable X is f1,7g, then the guard X &gt; 6 will suspend until some other goal remove 1 from the domain of X. 2.2 The Firebird Computation Model The Firebird Computation Model <ref> [LTC93] </ref> is a new approach to handle finite domain constraints in concurrent logic programming languages. Unlike the An-dorra Computation Model [War90] in which nondeterministic goals are the basis for setting up choice points or the exploitation of or-parallelism, the Firebird Computation Model uses domain variables instead. <p> Intuitively, each partition resulting from a nondeterministic derivation step becomes an independent derivation sequence and resumes its operation using the Firebird Computation Model. We shall state without proof the following theorems. The proofs can be found in <ref> [LTC93] </ref>. 6 Theorem 1 (Soundness of Firebird Computation Model) Given a pro-gram P , if a query G 0 = (A 0 [ C 0 ) has a successful derivation with final constraint set C, then P; D j= C ! A 0 [ C 0 Theorem 2 (Conditional Completeness of <p> However, it is not applicable to certain domains, including the finite domain, where the notion of nondeterminism is inherent. We have built a prototype implementation of a concurrent constraint logic programming language called FD-Parlog <ref> [LTC93] </ref>, which is similar to Firebird but is based on Parlog [CG86]. [LTC93] has a proof of soundness and conditional completeness of the Firebird Computation Model. Nondeterministic derivation in Firebird is inspired by the Andorra Computation Model [War90], but the semantics are fundamentally different. <p> However, it is not applicable to certain domains, including the finite domain, where the notion of nondeterminism is inherent. We have built a prototype implementation of a concurrent constraint logic programming language called FD-Parlog <ref> [LTC93] </ref>, which is similar to Firebird but is based on Parlog [CG86]. [LTC93] has a proof of soundness and conditional completeness of the Firebird Computation Model. Nondeterministic derivation in Firebird is inspired by the Andorra Computation Model [War90], but the semantics are fundamentally different.
Reference: [LvE92] <author> J. H. M. Lee and M. van Emden. </author> <title> Adapting CLP to floating-point arithmetic. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 996-1003, </pages> <publisher> ICOT, </publisher> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: We are working on a massively parallel garbage collector, the borrowing algorithm, backtracking and a join algorithm for compilation. On the other hand, we shall investigate the possibility of other kinds of data-level parallelism. The work of <ref> [LvE92] </ref> is another viable candidate for massively parallel implementation. The Firebird Computation Model can be adapted to model the domain splitting operation. 8 Conclusion In this paper, we have proposed a new concurrent constraint logic programming language called Firebird and its computation model on massively parallel SIMD computers.
Reference: [Mah87] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: If f is a singleton fcg, both variables are bound to constant c. If f is empty, the unification fails [VHD86, VHD87]. 1.2 Concurrent Constraint Logic Programming ALPS <ref> [Mah87] </ref> is a language design to integrate constraint logic programming and concurrent logic programming. [Sar88] developed the ideas further by introducing the ask-tell metaphor. Under such schemes, a clause has three parts. <p> At the eager nondeterminism extreme, nondeterministic derivation always takes precedence. Our massively parallel implementation uses a control strategy which lies somewhere in between these two extremes. 4 3 Operational Semantics Our operational semantics will be based on the formalism of <ref> [Mah87] </ref>. The domain theory D allows constraints of finite set membership over constants. A domain variable x with domain ffi is represented by a variable x and a constraint x 2 ffi. A program P consists of one or more clauses. <p> If both the indeterministic derivation step and the nondeterministic derivation step are applicable, only one of them will be selected. 5 3.2 The Firebird Commit Law Following the flat GHC convention, the commit law of Firebird is simpler than that of ALPS <ref> [Mah87] </ref>: a clause H G j B; B 0 can be committed to only if the clause is validated. In the other words, given an atom A selected from A i , we must find a clause with a head-guard pair which satisfies the following condition. <p> The consistency techniques used in Firebird are the same as those used in CHIP [VH89]. The semantics of Firebird is based on that of the algorithmic programming language ALPS <ref> [Mah87] </ref>. The concepts 15 of ALPS can be applied to a large class of programs which arise in practice. However, it is not applicable to certain domains, including the finite domain, where the notion of nondeterminism is inherent.
Reference: [NT88a] <author> M. Nilsson and H. Tanaka. </author> <title> A flat GHC implementation for supercomputers. </title> <booktitle> In Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1337-1350, </pages> <address> Seattle, 1988. </address> <publisher> The MIT Press. </publisher> <pages> 19 </pages>
Reference-contexts: They are also more suitable for decision graph compilation [KS90] than WAM [AK91]. We are unaware of any parallel execution schemes for constraint logic programming languages on massively parallel SIMD computers. However, there have been a number of SIMD implementations of logic programming languages <ref> [KB87, NT88a, NT88b, BM92] </ref>. 7 Future Work Each processor element in the back-end is much slower than the sequential front-end. Performance will be improved if sequential parts of the execution can be separated out and performed at the front-end.
Reference: [NT88b] <author> M. Nilsson and H. Tanaka. </author> <title> Massively parallel implementation of flat GHC on the Connection Machine. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 1031-1040, </pages> <address> Japan, 1988. </address> <publisher> ICOT. </publisher>
Reference-contexts: They are also more suitable for decision graph compilation [KS90] than WAM [AK91]. We are unaware of any parallel execution schemes for constraint logic programming languages on massively parallel SIMD computers. However, there have been a number of SIMD implementations of logic programming languages <ref> [KB87, NT88a, NT88b, BM92] </ref>. 7 Future Work Each processor element in the back-end is much slower than the sequential front-end. Performance will be improved if sequential parts of the execution can be separated out and performed at the front-end.
Reference: [Sar88] <author> V. A. Saraswat. </author> <title> A somewhat logical formulation of CLP synchro-nisation primitives. </title> <booktitle> In Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1298-1314, </pages> <address> Seattle, 1988. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: If f is a singleton fcg, both variables are bound to constant c. If f is empty, the unification fails [VHD86, VHD87]. 1.2 Concurrent Constraint Logic Programming ALPS [Mah87] is a language design to integrate constraint logic programming and concurrent logic programming. <ref> [Sar88] </ref> developed the ideas further by introducing the ask-tell metaphor. Under such schemes, a clause has three parts.
Reference: [Tar92] <author> P. Tarau. </author> <title> WAM-optimizations in BinProlog: towards a realistic continuation passing Prolog engine. </title> <type> Technical Report 92-03, </type> <institution> Dept. d'Informatique, Univ. de Moncton, </institution> <year> 1992. </year>
Reference-contexts: Furthermore, with the sheer power of a massively parallel computer, sometimes it is advantageous to set up a choice point before deadlock. The Firebird Abstract Machine is influenced by the abstract machine of BinProlog <ref> [Tar92] </ref>. For instance, the wide-tag memory architecture is a reminiscence of the `tag on data' representation. Both schemes make the differentiation between lists, structures and atoms unnecessary. They are also more suitable for decision graph compilation [KS90] than WAM [AK91].
Reference: [Ued85] <author> K. Ueda. </author> <title> Guarded horn clauses. </title> <editor> In E. Wada, editor, </editor> <booktitle> Logic Programming '85 | Proceedings of the 4th Conference, Lecture Notes in Computer Science 221, </booktitle> <pages> pages 168-179, </pages> <address> Tokyo, July 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, it is 2-3 times slower than a normal memory operation 2 . 2 The Firebird Language Firebird is a constraint logic programming language tailored for massively parallel architectures. The syntax of Firebird is almost identical to flat GHC <ref> [Ued85] </ref>. Each clause consists of a head, a guard part and a body. <p> in milliseconds. n 4 5 6 7 8 MP-2 6.7 10.3 14.7 19.8 25.7 On finding all the solutions to 8-queens, our implementation on MasPar MP-2 is about 20 times faster than CHIP [DVHS + 88] on a DECstation 3100. 6 Related Work Firebird can be regarded as flat GHC <ref> [Ued85] </ref> extended with finite domain constraint handling capabilities. The consistency techniques used in Firebird are the same as those used in CHIP [VH89]. The semantics of Firebird is based on that of the algorithmic programming language ALPS [Mah87].
Reference: [VH89] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The consistency techniques used in Firebird are the same as those used in CHIP <ref> [VH89] </ref>. The semantics of Firebird is based on that of the algorithmic programming language ALPS [Mah87]. The concepts 15 of ALPS can be applied to a large class of programs which arise in practice.
Reference: [VHD86] <author> P. Van Hentenryck and M. Dincbas. </author> <title> Domains in logic programming. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <pages> pages 759-765, </pages> <address> Philadelphia, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: When two d-variables, X d and Y e , are unified, both of them are bound to the d-variable Z f where f = d " e. If f is a singleton fcg, both variables are bound to constant c. If f is empty, the unification fails <ref> [VHD86, VHD87] </ref>. 1.2 Concurrent Constraint Logic Programming ALPS [Mah87] is a language design to integrate constraint logic programming and concurrent logic programming. [Sar88] developed the ideas further by introducing the ask-tell metaphor. Under such schemes, a clause has three parts.
Reference: [VHD87] <author> P. Van Hentenryck and M. Dincbas. </author> <title> Forward checking in logic programming. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 229-256, </pages> <address> Melbourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: When two d-variables, X d and Y e , are unified, both of them are bound to the d-variable Z f where f = d " e. If f is a singleton fcg, both variables are bound to constant c. If f is empty, the unification fails <ref> [VHD86, VHD87] </ref>. 1.2 Concurrent Constraint Logic Programming ALPS [Mah87] is a language design to integrate constraint logic programming and concurrent logic programming. [Sar88] developed the ideas further by introducing the ask-tell metaphor. Under such schemes, a clause has three parts. <p> In this way, C will be resumed in all partitions and a higher degree of parallelism can be exploited. Many heuristics like the First Fail Principle <ref> [VHD87] </ref> is no longer applicable because each partition may have a different d-variable with the smallest domain. For instance, the scenario above is a deviation from generalized forward checking [VHD87]. <p> Many heuristics like the First Fail Principle <ref> [VHD87] </ref> is no longer applicable because each partition may have a different d-variable with the smallest domain. For instance, the scenario above is a deviation from generalized forward checking [VHD87]. Although more processor elements will be required, this will not lead to performance degradation as long as there are enough processor elements. 5 Implementation An implementation of Firebird on a DECmpp massively parallel computer is in progress.
Reference: [VHSD93] <author> P. Van Hentenryck, V. Saraswat, and Y. Deville. </author> <title> Design, implementation and evaluation of the constraint language cc(FD). </title> <type> Technical Report CS-93-02, </type> <institution> Department of Computer Science, Brown University, Providence, </institution> <year> 1993. </year>
Reference-contexts: However, it is not guaranteed to rule out all invalid values. Using the domain consistency technique, each combination of possible values of the domain variables is attempted. This is more effective in eliminating invalid values but consumes more execution time. Unlike cc (FD) <ref> [VHSD93] </ref> in that the programmer has to specify whether interval consistency or domain consistency is to be used, our Firebird implementation will be able to choose between the two (or some intermediaries) depending on processor elements availability.
Reference: [War90] <author> D. H. D. Warren. </author> <title> The extended Andorra model with implicit control. </title> <booktitle> Presented at ICLP '90 Workshop on Parallel Logic Programming, </booktitle> <address> Jerusalem, </address> <year> 1990. </year> <month> 20 </month>
Reference-contexts: Unlike the An-dorra Computation Model <ref> [War90] </ref> in which nondeterministic goals are the basis for setting up choice points or the exploitation of or-parallelism, the Firebird Computation Model uses domain variables instead. Intuitively, there are two kinds of derivation steps in Firebird, called the indeterministic derivation step and the nondeterministic derivation step. <p> Nondeterministic derivation in Firebird is inspired by the Andorra Computation Model <ref> [War90] </ref>, but the semantics are fundamentally different. Furthermore, with the sheer power of a massively parallel computer, sometimes it is advantageous to set up a choice point before deadlock. The Firebird Abstract Machine is influenced by the abstract machine of BinProlog [Tar92].
References-found: 27

