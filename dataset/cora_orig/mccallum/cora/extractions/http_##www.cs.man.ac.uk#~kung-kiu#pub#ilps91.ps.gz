URL: http://www.cs.man.ac.uk/~kung-kiu/pub/ilps91.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kkl@cs.man.ac.uk  
Title: Synthesis of a Family of Recursive Sorting Procedures  
Author: Kung-Kiu Lau, Steven D. Prestwich 
Address: Oxford Road, Manchester M13 9PL, England  
Affiliation: Department of Computer Science, University of Manchester  
Abstract: In an earlier paper, we described a method for synthesising recursive logic procedures from their first-order logic specifications. The method is practical because it is strictly top-down and has been implemented as part of a user-guided synthesis system in Prolog. We have used the system to synthe-sise procedures for a wide variety of algorithms, including a large family of recursive sorting procedures. In this paper we describe the synthesis of this family of procedures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Bitton, D.J. DeWitt, D.K. Hsiao, and J. Menon. </author> <title> A taxonomy of parallel sorting. </title> <journal> Computing Surveys, </journal> <volume> 16(3) </volume> <pages> 289-318, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: We shall call such a list a block list , or simply a b-list , and call each member list a block and derive procedures for block sorting algorithms (see <ref> [1] </ref> for instance) from this adapted specification. <p> Procedures for similar parallel (block) sorting algorithms (see <ref> [1] </ref>) can be synthesised from procedures for other comparison-based list sorting algorithms. 5 Conclusion In [12] we described a logic program synthesis system which can be used to derive recursive logic procedures from their first order logic specifications.
Reference: [2] <author> K.L. Clark and J. Darlington. </author> <title> Algorithm classification through synthesis. </title> <journal> The Computer Journal, </journal> <volume> 23(1) </volume> <pages> 61-65, </pages> <year> 1980. </year>
Reference-contexts: y; l) means x; y are both members of l and x occurs before y in l; and mem and before are 2 We use the standard definition of a logic procedure as a set of clauses with the same positive predicate in the head. 3 This is adapted from <ref> [2] </ref>, and assumes there are no repeated elements in a. specified (recursively) as follows: 4 mem (x; [ ]) $ ? mem (x; b^c) $ mem (x; b) _ mem (x; c) before (x; y; [ ]) $ ? before (x; y; [a]) $ ? before (x; y; b^c) $ before <p> Also, our synthesis of procedures for the distributive sorting algorithms, radix exchange sort and distribution sort , and the block sorting algorithms, external merge sort and block bubble sort , has no parallel in related work in sorting algorithm synthesis such as <ref> [2] </ref> (see also [10, 11]). It would be easy to synthesise more sorting procedures. Particularly interesting ones include those for other parallel (block) sorting algorithms and algorithms for sorting other data structures such as trees. An initial attempt at a recursive tree sort is currently underway.
Reference: [3] <author> K.L. Clark and S. Sickel. </author> <title> Predicate logic: A calculus for deriving programs. </title> <booktitle> In Proc. IJCAI-77, </booktitle> <pages> pages 419-420, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Although much theoretical work has been done in logic program derivation, most notably by Clark, Hansson, Hogger, and Tarnlund <ref> [3, 4, 7, 9] </ref>, there has been relatively little work in mechanising logic program synthesis. The recent work of Sato and Tamaki [15, 14] is one of the few examples. Independently, we worked on designing and implementing a practical system for mechanised program synthesis.
Reference: [4] <author> K.L. Clark and S.- A. </author> <title> Tarnlund. A first order theory of data and programs. </title> <booktitle> In Proc. IFIP 77, </booktitle> <pages> pages 939-944. </pages> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: 1 Introduction Although much theoretical work has been done in logic program derivation, most notably by Clark, Hansson, Hogger, and Tarnlund <ref> [3, 4, 7, 9] </ref>, there has been relatively little work in mechanising logic program synthesis. The recent work of Sato and Tamaki [15, 14] is one of the few examples. Independently, we worked on designing and implementing a practical system for mechanised program synthesis.
Reference: [5] <author> M.S. Feather. </author> <title> A system for assisting program transformation. </title> <journal> ACM TOPLAS, </journal> <volume> 4(1) </volume> <pages> 1-20, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: form of an incomplete implication: 6 ? sort (a 1 ^a 2 ; b) sort (a 1 ; c) sort (a 2 ; d) (1) 4 We shall use &gt; and ? to denote the truth values true and false respectively; and `^' is the list concatenation operator. 5 Feather <ref> [5] </ref> used a similar idea for pattern-directed unfold-fold transformational development of recursion equation programs. 6 In [12], we call such a goal a folding problem, e.g. for goal (1) the corresponding folding problem would be fold (sort (a 1 ^a 2 ; b); z; fsort (a 1 ; c); sort (a
Reference: [6] <author> L. </author> <title> Fribourg. Extracting logic programs from proofs that use extended Prolog execution and induction. </title> <editor> In D.H.D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 685-699. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The ability to derive these procedures from a common specification is a promising result for our system, and moreover it gives us a neat taxonomy of these sorting algorithms (see [10, 11]). Furthermore, compared to recent work in logic program synthesis (e.g. <ref> [6, 15, 16] </ref>), our system seems to be the only one that has been applied successfully to the synthesis of large families of nontrivial procedures.
Reference: [7] <author> A. Hansson and S.- A. </author> <title> Tarnlund. A natural programming calculus. </title> <booktitle> In Proc. IJCAI-79, </booktitle> <pages> pages 348-355, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Although much theoretical work has been done in logic program derivation, most notably by Clark, Hansson, Hogger, and Tarnlund <ref> [3, 4, 7, 9] </ref>, there has been relatively little work in mechanising logic program synthesis. The recent work of Sato and Tamaki [15, 14] is one of the few examples. Independently, we worked on designing and implementing a practical system for mechanised program synthesis.
Reference: [8] <author> A. Hansson and S.- A. </author> <title> Tarnlund. Program transformation by data structure mapping. In K.L. </title> <editor> Clark and S.- A. Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 117-122. </pages> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Following merge sort for lists, we set the goal ? bsort (a 1 ^a 2 ; b) bsort (a 1 ; c) bsort (a 2 ; d) 14 This is an example of data structure mapping as exemplified in <ref> [8] </ref>. to split the input b-list.
Reference: [9] <author> C.J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> J. ACM, </journal> <volume> 28(2) </volume> <pages> 372-392, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Although much theoretical work has been done in logic program derivation, most notably by Clark, Hansson, Hogger, and Tarnlund <ref> [3, 4, 7, 9] </ref>, there has been relatively little work in mechanising logic program synthesis. The recent work of Sato and Tamaki [15, 14] is one of the few examples. Independently, we worked on designing and implementing a practical system for mechanised program synthesis.
Reference: [10] <author> K.K. Lau. </author> <title> A note on synthesis and classification of sorting algorithms. </title> <journal> Acta Informatica, </journal> <volume> 27 </volume> <pages> 73-80, </pages> <year> 1989. </year>
Reference-contexts: This tree is the largest known in the literature (as far as we can ascertain) and provides a more comprehensive taxonomy of sorting algorithms than any previous work in algorithm synthesis and classification. This is described from an algorithmic point of view in <ref> [10, 11] </ref>. In this paper, we describe the synthesis of this family of recursive logic procedures on the system from a logic programming perspective. In Section 2 we define the language used for specifying logic procedures. <p> The ability to derive these procedures from a common specification is a promising result for our system, and moreover it gives us a neat taxonomy of these sorting algorithms (see <ref> [10, 11] </ref>). Furthermore, compared to recent work in logic program synthesis (e.g. [6, 15, 16]), our system seems to be the only one that has been applied successfully to the synthesis of large families of nontrivial procedures. <p> Also, our synthesis of procedures for the distributive sorting algorithms, radix exchange sort and distribution sort , and the block sorting algorithms, external merge sort and block bubble sort , has no parallel in related work in sorting algorithm synthesis such as [2] (see also <ref> [10, 11] </ref>). It would be easy to synthesise more sorting procedures. Particularly interesting ones include those for other parallel (block) sorting algorithms and algorithms for sorting other data structures such as trees. An initial attempt at a recursive tree sort is currently underway.
Reference: [11] <author> K.K. Lau. </author> <title> Top-down synthesis of sorting algorithms. </title> <journal> The Computer Journal, </journal> <volume> 35:A001-A007, </volume> <year> 1992. </year>
Reference-contexts: This tree is the largest known in the literature (as far as we can ascertain) and provides a more comprehensive taxonomy of sorting algorithms than any previous work in algorithm synthesis and classification. This is described from an algorithmic point of view in <ref> [10, 11] </ref>. In this paper, we describe the synthesis of this family of recursive logic procedures on the system from a logic programming perspective. In Section 2 we define the language used for specifying logic procedures. <p> The ability to derive these procedures from a common specification is a promising result for our system, and moreover it gives us a neat taxonomy of these sorting algorithms (see <ref> [10, 11] </ref>). Furthermore, compared to recent work in logic program synthesis (e.g. [6, 15, 16]), our system seems to be the only one that has been applied successfully to the synthesis of large families of nontrivial procedures. <p> Also, our synthesis of procedures for the distributive sorting algorithms, radix exchange sort and distribution sort , and the block sorting algorithms, external merge sort and block bubble sort , has no parallel in related work in sorting algorithm synthesis such as [2] (see also <ref> [10, 11] </ref>). It would be easy to synthesise more sorting procedures. Particularly interesting ones include those for other parallel (block) sorting algorithms and algorithms for sorting other data structures such as trees. An initial attempt at a recursive tree sort is currently underway.
Reference: [12] <author> K.K. Lau and S.D. Prestwich. </author> <title> Top-down synthesis of recursive logic procedures from first-order logic specifications. </title> <editor> In D.H.D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 667-684. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Independently, we worked on designing and implementing a practical system for mechanised program synthesis. The result is a method for top-down synthesis of recursive logic procedures from their specifications in first-order logic, which we presented in <ref> [12] </ref>. This method has been implemented in Prolog, and the resulting system has been applied to the synthesis of recursive procedures for a wide variety of algorithms. In particular, a large family of logic procedures for sorting has been derived. <p> 1 ; c) sort (a 2 ; d) (1) 4 We shall use &gt; and ? to denote the truth values true and false respectively; and `^' is the list concatenation operator. 5 Feather [5] used a similar idea for pattern-directed unfold-fold transformational development of recursion equation programs. 6 In <ref> [12] </ref>, we call such a goal a folding problem, e.g. for goal (1) the corresponding folding problem would be fold (sort (a 1 ^a 2 ; b); z; fsort (a 1 ; c); sort (a 2 ; d)g) where z is a meta-variable which will become instantiated to the body of <p> Each recursive step follows the above scheme. Full details of goal decomposition and subsolution composition under various circumstances, in particular where quantifiers are involved, are given in <ref> [12] </ref>. 4 Top-down Synthesis of Recursive Sorting Proce dures From the above specification for sort, we can use the system to solve different goals to yield the corresponding procedures for sorting. <p> Procedures for similar parallel (block) sorting algorithms (see [1]) can be synthesised from procedures for other comparison-based list sorting algorithms. 5 Conclusion In <ref> [12] </ref> we described a logic program synthesis system which can be used to derive recursive logic procedures from their first order logic specifications. <p> This is under investigation, as well as the more theoretical issues of completeness mentioned above and in <ref> [12] </ref>. Acknowledgements We would like to thank the referees for their helpful comments and for pointing out minor errors.
Reference: [13] <author> S.D. Prestwich. </author> <title> A Semi-automatic Logic Programming System for Algorithm Synthesis. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, University of Manchester, </institution> <year> 1989. </year>
Reference: [14] <author> T. Sato. </author> <title> A first order unfold/fold system. </title> <type> Technical Report TR-90-17, </type> <institution> Electrotechnical Laboratory, Ibaraki, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction Although much theoretical work has been done in logic program derivation, most notably by Clark, Hansson, Hogger, and Tarnlund [3, 4, 7, 9], there has been relatively little work in mechanising logic program synthesis. The recent work of Sato and Tamaki <ref> [15, 14] </ref> is one of the few examples. Independently, we worked on designing and implementing a practical system for mechanised program synthesis. The result is a method for top-down synthesis of recursive logic procedures from their specifications in first-order logic, which we presented in [12]. <p> The result of a synthesis is also an implication which is then transformed into the corresponding procedure. Definitions are chosen for their expressiveness. In our experience, we have found them adequate for expressing everything we wanted. This is echoed by the latest work of Sato and Tamaki <ref> [15, 14] </ref> who have independently used similar forms for specifying predicates. Typically, a specification for a procedure with head p will consist of a definition with head p, together with definitions/implications for all other literals that appear in the body of this definition.
Reference: [15] <author> T. Sato and H. Tamaki. </author> <title> First order compiler: A deterministic logic program synthesis algorithm. </title> <journal> J. Symbolic Computation, </journal> <volume> 8 </volume> <pages> 605-627, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Although much theoretical work has been done in logic program derivation, most notably by Clark, Hansson, Hogger, and Tarnlund [3, 4, 7, 9], there has been relatively little work in mechanising logic program synthesis. The recent work of Sato and Tamaki <ref> [15, 14] </ref> is one of the few examples. Independently, we worked on designing and implementing a practical system for mechanised program synthesis. The result is a method for top-down synthesis of recursive logic procedures from their specifications in first-order logic, which we presented in [12]. <p> The result of a synthesis is also an implication which is then transformed into the corresponding procedure. Definitions are chosen for their expressiveness. In our experience, we have found them adequate for expressing everything we wanted. This is echoed by the latest work of Sato and Tamaki <ref> [15, 14] </ref> who have independently used similar forms for specifying predicates. Typically, a specification for a procedure with head p will consist of a definition with head p, together with definitions/implications for all other literals that appear in the body of this definition. <p> The ability to derive these procedures from a common specification is a promising result for our system, and moreover it gives us a neat taxonomy of these sorting algorithms (see [10, 11]). Furthermore, compared to recent work in logic program synthesis (e.g. <ref> [6, 15, 16] </ref>), our system seems to be the only one that has been applied successfully to the synthesis of large families of nontrivial procedures.
Reference: [16] <author> Y. Takayama. </author> <title> Writing programs as qj proof and compiling into prolog programs. </title> <booktitle> In Proc. Sym. Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pages 278-286. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: The ability to derive these procedures from a common specification is a promising result for our system, and moreover it gives us a neat taxonomy of these sorting algorithms (see [10, 11]). Furthermore, compared to recent work in logic program synthesis (e.g. <ref> [6, 15, 16] </ref>), our system seems to be the only one that has been applied successfully to the synthesis of large families of nontrivial procedures.
References-found: 16

