URL: http://www.tns.lcs.mit.edu/~djw/library/brian.mm96.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: jjg@cse.ucsc.edu  
Title: The Case For Reliable Concurrent Multicasting Using Shared Ack Trees  
Author: Brian Neil Levine David B. Lavo J.J. Garcia-Luna-Aceves fbrian, lavo, 
Keyword: Reliable Concurrent Multicast, Performance Evaluation, Transport Protocols, Collaboration, Internet  
Address: Santa Cruz, CA 95064  
Affiliation: Department of Computer Engineering University of California  
Abstract: Such interactive, distributed multimedia applications as shared whiteboards, group editors, and simulations require reliable concurrent multicast services, i.e., the reliable dissemination of information from multiple sources to all the members of a group. Furthermore, it makes sense to offer that service on top of the increasingly available IP multicast service, which offers unreliable multi-casting. This paper establishes that concurrent reliable multicast-ing over the Internet should be based on reliable multicast protocols based on a shared acknowledgment tree. First, we show that organizing the receivers of a reliable multicast group into an acknowledgment tree and using NAK-avoidance with periodic polling in local groups inside such a tree provides the highest maximum throughput among all classes of reliable multicast protocols proposed to date. Second, we introduce Lorax, which demonstrates the viability of implementing a reliable multicasting approach in the Internet based on acknowledgment trees in a scalable manner. Lorax is the first known protocol that constructs and maintains a single acknowledgment tree for reliable concurrent multicasting, eliminates the need to maintain an acknowledgment tree for each source of a reliable multicast group, and can be used in combination with any of several tree-based reliable multicast protocols proposed to date. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Deering, RFC-1112: </author> <title> Host extension for ip multicasting. Request For Comments, </title> <month> August </month> <year> 1989. </year>
Reference-contexts: The development and implementation of end-to-end protocols for reliable concurrent multicasting over the Internet is being enabled by the increasing availability of multicast routing in Internet routers. IP-Multicast routers permit sources to transmit data unreliably to multiple receivers <ref> [1] </ref>. <p> E [Y p ] + E [Y f ] + E [Y ] E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E [M r jM r &gt; 2] 2) E [Y t ] (7) It follows from the distribution of M r that [8] E <ref> [M r jM r &gt; 1] </ref> E [Y t ] = (2 p)=(1 p) (8) Therefore, noting that P robfM r &gt; 2g = p 2 , we derive the expected cost as E [Y ] = E [M ](1 p) E [Y p ] + E [Y f ] + <p> As in [8, 9], let ! [R], be the speed of the processor that can support at most R receivers under protocol !, where ! 2 fA; N 1; N 2; R; H1; H2g representing sender-initiated, receiver-initiated, RINA, ring-based, tree-based, and tree-NAPP, respectively. If we set A <ref> [1] </ref> = 1 as a baseline it is shown in [8] that E [X ] fi fi = A [1] 1 p 3 p The speedup of tree-NAPP protocols can be calculated as the ratio of their expected cost (Eq. 13) to the baseline [R] = E [X A ] H2 <p> If we set A <ref> [1] </ref> = 1 as a baseline it is shown in [8] that E [X ] fi fi = A [1] 1 p 3 p The speedup of tree-NAPP protocols can be calculated as the ratio of their expected cost (Eq. 13) to the baseline [R] = E [X A ] H2 = E [X A ] 2 3 2p 2) In [8, 10], the number of supportable receivers derived for
Reference: 2. <author> S. Ramakrishnan and B. N. Jain, </author> <title> A negative acknowledgment with periodic polling protocol for multicast over lan, </title> <booktitle> in Proc. IEEE Infocom, </booktitle> <pages> pp. 502511, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: A considerable amount of work has been reported in the recent past on how to cope with or eliminate the ACK-implosion problem <ref> [2] </ref> [16]. However, the design of reliable multicast protocols is complex and there is no consensus yet on which is the best approach for the implementation of protocols for scalable, reliable concurrent multicasting over the Internet. <p> Because the source may experience NAK-implosion if many receivers detect transmission errors, previous work on receiver-initiated protocols ([8, 11]) adopts the NAK-avoidance scheme first proposed in <ref> [2] </ref>: upon detection of a lost packet, receivers schedule a NAK for a random time in the near future. During that time the receiver listens for a NAK by another multicast group member for the same packet. If another NAK is heard, the transmission is scheduled for a subsequent time. <p> Several tree-based protocol possibilities are discussed in [4], and have been fully developed as the Reliable Multicast Transport Protocol (RMTP) [5]. 2.5 Tree-NAPP Protocols Tree-NAPP protocols are a subclass of tree-based protocols. The utilization of NAK-avoidance and periodic polling described in <ref> [2] </ref> by the local groups in a tree-based protocol defines this subclass. NAKS alone are not sufficient to guarantee reliability with finite memory, so receivers send a periodic positive (hierarchical) acknowledgment to their parents so that the cw may be advanced. <p> The expected number of transmissions per packet is <ref> [2, 8] </ref> E [M ] = i=1 B i+1 1 (3) It is shown in [9] that H B H B ln p ; where H B = P B i=1 1=i, the harmonic numbers. <p> &gt; 2g M r 1 X Y t (i) (6) Taking expectations of Eq. 6, E [Y ] = E [M ](1 p) E [Y p ] + E [Y f ] + E [Y ] E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E <ref> [M r jM r &gt; 2] </ref> 2) E [Y t ] (7) It follows from the distribution of M r that [8] E [M r jM r &gt; 1] E [Y t ] = (2 p)=(1 p) (8) Therefore, noting that P robfM r &gt; 2g = p 2 , we
Reference: 3. <author> J.-M. Chang and N. F. Maxemchuk, </author> <title> Reliable broadcast protocols, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 251273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: The scalable reliable multicasting (SRM) protocol [11] and the log-based receiver-reliable multicast (LBRM) protocol [12] are examples of RINA protocols. 2.3 Ring-Based Protocols Our generic description of ring-based protocols is based on the Reliable Multicast Protocol (RMP) [7], which is based on the Token Ring Protocol (TRP) <ref> [3] </ref>. Ring-based protocols work by organizing the receivers into a ring, with a rotating token site designated as the only node to ACK back to the source for the current packet. The source deletes packets only when an ACK/token is received.
Reference: 4. <author> S. Paul, K. K. Sabnani, and D. K. Kristol, </author> <title> Multicast transport protocols for high speed networks, </title> <booktitle> in International Conference on Network Protocols, </booktitle> <pages> pp. 414, </pages> <year> 1994. </year>
Reference-contexts: We assume a selective repeat strategy is used, so that once a packet is received correctly, it is never rebroadcast to the local group again. Several tree-based protocol possibilities are discussed in <ref> [4] </ref>, and have been fully developed as the Reliable Multicast Transport Protocol (RMTP) [5]. 2.5 Tree-NAPP Protocols Tree-NAPP protocols are a subclass of tree-based protocols. The utilization of NAK-avoidance and periodic polling described in [2] by the local groups in a tree-based protocol defines this subclass.
Reference: 5. <author> J. C. Lin and S. Paul, RMTP: </author> <title> A reliable multicast transport protocol, </title> <booktitle> in Proc. IEEE Infocom, </booktitle> <pages> pp. 14141425, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Lorax eliminates the need to maintain an ACK tree for each source of a reliable multicast group, and can be used in combination with any of several tree-based reliable multicast protocols proposed to date (e.g., <ref> [5, 6] </ref>). Section 6 compares our approach with related work and discusses why Lorax and tree-NAPP protocols are the best approach to date for the provision of scalable, reliable concurrent multicasting services in the Internet. <p> We assume a selective repeat strategy is used, so that once a packet is received correctly, it is never rebroadcast to the local group again. Several tree-based protocol possibilities are discussed in [4], and have been fully developed as the Reliable Multicast Transport Protocol (RMTP) <ref> [5] </ref>. 2.5 Tree-NAPP Protocols Tree-NAPP protocols are a subclass of tree-based protocols. The utilization of NAK-avoidance and periodic polling described in [2] by the local groups in a tree-based protocol defines this subclass.
Reference: 6. <author> R. Yavatkar, J. Griffioen, and M. Sudan, </author> <title> A reliable dissemination protocol for interactive collaborative applications, </title> <booktitle> in Proc. ACM Multimedia, </booktitle> <pages> pp. 33344, </pages> <year> 1995. </year>
Reference-contexts: Second, Section 4 presents a simple extension of any ACK tree-based reliable multicast protocol. This extension allows the source to safely deallocate packets from memory when the ACK tree needs to be modified. 1 These results are consistent with the experimental results reported in <ref> [6] </ref>. Finally, we note that it is not reasonable to set up an ACK tree for every source in a concurrent multicast session, and that the ACK tree should adapt to changes in the constituency of either the receiver set or the multicast routing tree (s). <p> Lorax eliminates the need to maintain an ACK tree for each source of a reliable multicast group, and can be used in combination with any of several tree-based reliable multicast protocols proposed to date (e.g., <ref> [5, 6] </ref>). Section 6 compares our approach with related work and discusses why Lorax and tree-NAPP protocols are the best approach to date for the provision of scalable, reliable concurrent multicasting services in the Internet. <p> Note that the setting of timers needed for NAK avoidance is done entirely on the local group scale, so it is scalable. An implementation of tree-NAPPing can be found in the Tree-based Multicast Transport Protocol (TMTP) <ref> [6] </ref>. <p> Allowing off-tree nodes to freely multicast until they find a parent may cause the underlying multicast routing tree to become congested with search messages. This method is similar to the single-source tree construction method presented in <ref> [6] </ref>. Lorax solves this problem by limiting the scope of ERS multicasts needed to reach the ACK tree. More specifically, consider an off-tree node that joins the multicast session and call it orphan node o.
Reference: 7. <author> B. Whetten, S. Kaplan, and T. Montgomery, </author> <title> A high performance totally ordered multicast protocol. </title> <note> Available from research.ivv.nasa.gov by ftp /pub/doc/RMP/RMP dagstuhl.ps, </note> <month> August </month> <year> 1994. </year>
Reference-contexts: We refer to this protocol subclass as RINA (for Receiver-Initiated with NAK-Avoidance). The scalable reliable multicasting (SRM) protocol [11] and the log-based receiver-reliable multicast (LBRM) protocol [12] are examples of RINA protocols. 2.3 Ring-Based Protocols Our generic description of ring-based protocols is based on the Reliable Multicast Protocol (RMP) <ref> [7] </ref>, which is based on the Token Ring Protocol (TRP) [3]. Ring-based protocols work by organizing the receivers into a ring, with a rotating token site designated as the only node to ACK back to the source for the current packet.
Reference: 8. <author> S. Pingali, D. Towsley, and J. F. Kurose, </author> <title> A comparison of sender-initiated and receiver-initiated reliable multicast protocols, in Performance Evaluation Review, </title> <journal> vol. </journal> <volume> 22, </volume> <pages> pp. 221 230, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: within a local group of an ACK tree consists of using a multicast address for each local group of the ACK tree. 3 MAXIMUM THROUGHPUT ANALYSIS To analyze the relative maximum throughput of reliable multicast protocols, we continue to use the same model used in [10] and first introduced in <ref> [8] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> For clarity, we assume a single ACK tree rooted at the source. All loss events at any node in the multicast are mutually independent, the probability of packet loss is p for any node, and no ACK is ever lost. Following the notation in <ref> [8] </ref> and [10], we place a superscript H2 on any variables relating to the generic tree-NAPP protocol. Additional notation and variables are introduced as needed in the analysis; quick reference. <p> Additional notation and variables are introduced as needed in the analysis; quick reference. The following paragraphs derive the maximum throughput for tree-based protocols with local NAPP; the maximum throughputs for the rest of the classes are derived in <ref> [8, 10] </ref>. Assuming a finite amount of memory at every node, it is easy to show [10] that the generic sender-initiated, ring-based, and tree-based protocols are free of deadlocks and deliver packets reliably, while RINA protocols incur deadlocks. <p> The expected number of transmissions per packet is <ref> [2, 8] </ref> E [M ] = i=1 B i+1 1 (3) It is shown in [9] that H B H B ln p ; where H B = P B i=1 1=i, the harmonic numbers. <p> Using this result, assuming all operations (e.g. X f and X p ) are of constant cost, and taking into account that H B 2 O (ln B), it is shown in <ref> [8] </ref> that B Branching factor of a tree, the group size. R Size of the receiver set. X f Time to feed in new packet from the higher protocol layer. X p Time to process the transmission of a packet. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 correctness Sender-initiated <ref> [8] </ref> O 1p ) O (R ln R) ! O (R) safe and live Receiver-initiated NAK-avoidance [8] O p ln R O (ln R) ! O (1) not correct Ring-based (unicast retrans.) [10] O (R1)p O (R) ! O (1) safe and live Tree-based [10] O (B (1 p) + pB <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 correctness Sender-initiated <ref> [8] </ref> O 1p ) O (R ln R) ! O (R) safe and live Receiver-initiated NAK-avoidance [8] O p ln R O (ln R) ! O (1) not correct Ring-based (unicast retrans.) [10] O (R1)p O (R) ! O (1) safe and live Tree-based [10] O (B (1 p) + pB ln B) O (1) ! O (1) safe and live Tree-based with local NAPP O 1p+p <p> ](1 p) E [Y p ] + E [Y f ] + E [Y ] E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E [M r jM r &gt; 2] 2) E [Y t ] (7) It follows from the distribution of M r that <ref> [8] </ref> E [M r jM r &gt; 1] E [Y t ] = (2 p)=(1 p) (8) Therefore, noting that P robfM r &gt; 2g = p 2 , we derive the expected cost as E [Y ] = E [M ](1 p) E [Y p ] + E [Y f <p> Figure 3 (a) compares the relative throughputs of the protocols described in Section 2. The graph represents the inverse of Eq. 13 as the exact expected throughput for tree-NAPP protocols as well as the throughput equations derived in <ref> [8, 10] </ref> for all other classes. The top, middle and bottom graphs correspond to increasing probabilities of packet loss, 1%, 10%, and 25%, respectively. <p> A smaller branching factor would also increase throughput at the cost of a longer path that retransmissions must traverse to an expecting receiver. of the different classes, relative to processor speed requirements. This number is obtained by normalizing all classes to a baseline processor. As described in <ref> [8, 9] </ref>, the baseline uses a sender-initiated protocol and can support exactly one receiver. As in [8, 9], let ! [R], be the speed of the processor that can support at most R receivers under protocol !, where ! 2 fA; N 1; N 2; R; H1; H2g representing sender-initiated, receiver-initiated, <p> This number is obtained by normalizing all classes to a baseline processor. As described in <ref> [8, 9] </ref>, the baseline uses a sender-initiated protocol and can support exactly one receiver. As in [8, 9], let ! [R], be the speed of the processor that can support at most R receivers under protocol !, where ! 2 fA; N 1; N 2; R; H1; H2g representing sender-initiated, receiver-initiated, RINA, ring-based, tree-based, and tree-NAPP, respectively. <p> If we set A [1] = 1 as a baseline it is shown in <ref> [8] </ref> that E [X ] fi fi = A [1] 1 p 3 p The speedup of tree-NAPP protocols can be calculated as the ratio of their expected cost (Eq. 13) to the baseline [R] = E [X A ] H2 = E [X A ] 2 3 2p 2) In <p> that E [X ] fi fi = A [1] 1 p 3 p The speedup of tree-NAPP protocols can be calculated as the ratio of their expected cost (Eq. 13) to the baseline [R] = E [X A ] H2 = E [X A ] 2 3 2p 2) In <ref> [8, 10] </ref>, the number of supportable receivers derived for sender-and receiver-initiated, RINA, ring-based, and tree-based protocols are shown to be [R] = E [X A ] [R] = E [X A ] [R] = E [X A ] [R] = E [X A ] 3 + (1 p) [R] = E <p> [X A ] [R] = E [X A ] [R] = E [X A ] [R] = E [X A ] 3 + (1 p) [R] = E [X A ] Because the exact value of E [M ] is difficult to compute for large values of R, as in <ref> [8, 9] </ref>, we use the following approximation E [M ] a + ln (p) where a is the value of E [M ] for R = 35 and H k is the harmonic series.
Reference: 9. <author> S. Pingali, </author> <title> Protocol and Real-Time Scheduling Issues for Multimedia Applications. </title> <type> PhD thesis, </type> <institution> University of Massachusetts Amherst, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: The expected number of transmissions per packet is [2, 8] E [M ] = i=1 B i+1 1 (3) It is shown in <ref> [9] </ref> that H B H B ln p ; where H B = P B i=1 1=i, the harmonic numbers. From the known inequality ln (1 + p) 1+p , it follows that ln p &lt; p1 p . Using this result, assuming all operations (e.g. <p> A smaller branching factor would also increase throughput at the cost of a longer path that retransmissions must traverse to an expecting receiver. of the different classes, relative to processor speed requirements. This number is obtained by normalizing all classes to a baseline processor. As described in <ref> [8, 9] </ref>, the baseline uses a sender-initiated protocol and can support exactly one receiver. As in [8, 9], let ! [R], be the speed of the processor that can support at most R receivers under protocol !, where ! 2 fA; N 1; N 2; R; H1; H2g representing sender-initiated, receiver-initiated, <p> This number is obtained by normalizing all classes to a baseline processor. As described in <ref> [8, 9] </ref>, the baseline uses a sender-initiated protocol and can support exactly one receiver. As in [8, 9], let ! [R], be the speed of the processor that can support at most R receivers under protocol !, where ! 2 fA; N 1; N 2; R; H1; H2g representing sender-initiated, receiver-initiated, RINA, ring-based, tree-based, and tree-NAPP, respectively. <p> [X A ] [R] = E [X A ] [R] = E [X A ] [R] = E [X A ] 3 + (1 p) [R] = E [X A ] Because the exact value of E [M ] is difficult to compute for large values of R, as in <ref> [8, 9] </ref>, we use the following approximation E [M ] a + ln (p) where a is the value of E [M ] for R = 35 and H k is the harmonic series.
Reference: 10. <author> B. N. Levine and J.J. Garcia-Luna-Aceves, </author> <title> A comparison of known classes of reliable multicast protocols, </title> <booktitle> in Proc. IEEE International Conference on Network Protocols, </booktitle> <month> Octo-ber </month> <year> 1996. </year>
Reference-contexts: future work are offered in Section 8. 2 BACKGROUND To provide a summary of known classes of reliable multicast protocols, we use a taxonomy that decouples the definition of the mechanisms needed for the pacing of data transmission from the mechanisms needed for the allocation of memory at the source <ref> [10] </ref>. <p> In all classes, packets are multicast unreliably from the source directly to all receivers. The protocol classes differ on how acknowledgments flow from the receivers back to the source. A more detailed description of all generic protocols can be found in <ref> [10] </ref>. 2.1 Sender-Initiated Protocols A sender-initiated reliable multicast protocol is one that requires the source to receive ACKs from all members of a known receiver set before it is allowed to release memory for the data associated with the ACKs. <p> One approach to implement NAK-avoidance within a local group of an ACK tree consists of using a multicast address for each local group of the ACK tree. 3 MAXIMUM THROUGHPUT ANALYSIS To analyze the relative maximum throughput of reliable multicast protocols, we continue to use the same model used in <ref> [10] </ref> and first introduced in [8], which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> For clarity, we assume a single ACK tree rooted at the source. All loss events at any node in the multicast are mutually independent, the probability of packet loss is p for any node, and no ACK is ever lost. Following the notation in [8] and <ref> [10] </ref>, we place a superscript H2 on any variables relating to the generic tree-NAPP protocol. Additional notation and variables are introduced as needed in the analysis; quick reference. <p> Additional notation and variables are introduced as needed in the analysis; quick reference. The following paragraphs derive the maximum throughput for tree-based protocols with local NAPP; the maximum throughputs for the rest of the classes are derived in <ref> [8, 10] </ref>. Assuming a finite amount of memory at every node, it is easy to show [10] that the generic sender-initiated, ring-based, and tree-based protocols are free of deadlocks and deliver packets reliably, while RINA protocols incur deadlocks. <p> The following paragraphs derive the maximum throughput for tree-based protocols with local NAPP; the maximum throughputs for the rest of the classes are derived in [8, 10]. Assuming a finite amount of memory at every node, it is easy to show <ref> [10] </ref> that the generic sender-initiated, ring-based, and tree-based protocols are free of deadlocks and deliver packets reliably, while RINA protocols incur deadlocks. Table 2 summarizes the results on maximum throughput and correctness reported in [10], together with the tree-NAPP throughput result derived next. 3.1 Throughput of Tree-NAPP Protocol To bound the <p> Assuming a finite amount of memory at every node, it is easy to show <ref> [10] </ref> that the generic sender-initiated, ring-based, and tree-based protocols are free of deadlocks and deliver packets reliably, while RINA protocols incur deadlocks. Table 2 summarizes the results on maximum throughput and correctness reported in [10], together with the tree-NAPP throughput result derived next. 3.1 Throughput of Tree-NAPP Protocol To bound the overall system throughput in the generic tree-NAPP protocol, we first derive and bound the expected cost at the source, hop, and leaf nodes. <p> Taking expectations, we have E [X ] = E [X f ] + E [M ] E [X p ] Following our previous analysis for tree-based protocols <ref> [10] </ref>, we derive the value of M , given that the source has a local receiver subset of size B from which to collect NAKs and retransmit packets to. <p> No subscript denotes overall system throughput. protocol processor requirements p as a constant p ! 0 correctness Sender-initiated [8] O 1p ) O (R ln R) ! O (R) safe and live Receiver-initiated NAK-avoidance [8] O p ln R O (ln R) ! O (1) not correct Ring-based (unicast retrans.) <ref> [10] </ref> O (R1)p O (R) ! O (1) safe and live Tree-based [10] O (B (1 p) + pB ln B) O (1) ! O (1) safe and live Tree-based with local NAPP O 1p+p ln B+p 2 (14p) O (1) ! O (1) safe and live E [M ] 2 <p> constant p ! 0 correctness Sender-initiated [8] O 1p ) O (R ln R) ! O (R) safe and live Receiver-initiated NAK-avoidance [8] O p ln R O (ln R) ! O (1) not correct Ring-based (unicast retrans.) <ref> [10] </ref> O (R1)p O (R) ! O (1) safe and live Tree-based [10] O (B (1 p) + pB ln B) O (1) ! O (1) safe and live Tree-based with local NAPP O 1p+p ln B+p 2 (14p) O (1) ! O (1) safe and live E [M ] 2 O 1 + 1 p Using Eq. 4, we can bound Eq. <p> Figure 3 (a) compares the relative throughputs of the protocols described in Section 2. The graph represents the inverse of Eq. 13 as the exact expected throughput for tree-NAPP protocols as well as the throughput equations derived in <ref> [8, 10] </ref> for all other classes. The top, middle and bottom graphs correspond to increasing probabilities of packet loss, 1%, 10%, and 25%, respectively. <p> that E [X ] fi fi = A [1] 1 p 3 p The speedup of tree-NAPP protocols can be calculated as the ratio of their expected cost (Eq. 13) to the baseline [R] = E [X A ] H2 = E [X A ] 2 3 2p 2) In <ref> [8, 10] </ref>, the number of supportable receivers derived for sender-and receiver-initiated, RINA, ring-based, and tree-based protocols are shown to be [R] = E [X A ] [R] = E [X A ] [R] = E [X A ] [R] = E [X A ] 3 + (1 p) [R] = E <p> However, RINA protocols suffer from a number of limitations. First, the RINA protocols that have been proposed to date (e.g., SRM [11] and LBRM [12]) have no mechanism for the source to know when it can safely release data from memory <ref> [10] </ref>. LBRM uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server. Using log servers is feasible only for applications that can afford the servers and leaves many issues unresolved.
Reference: 11. <author> S. Floyd, V. Jacobson, S. McCanne, C.-G. Liu, and L. Zhang, </author> <title> A reliable multicast framework for light-weight sessions and application level framing, </title> <booktitle> in Proc. ACM SIGCOMM'95., </booktitle> <pages> pp. 342356, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: It is hoped that only one NAK is sent by the whole group to the parent for a lost packet. We refer to this protocol subclass as RINA (for Receiver-Initiated with NAK-Avoidance). The scalable reliable multicasting (SRM) protocol <ref> [11] </ref> and the log-based receiver-reliable multicast (LBRM) protocol [12] are examples of RINA protocols. 2.3 Ring-Based Protocols Our generic description of ring-based protocols is based on the Reliable Multicast Protocol (RMP) [7], which is based on the Token Ring Protocol (TRP) [3]. <p> Two additional advantages are that the source is not supposed to know the receiver set and and the receivers pace the source. However, RINA protocols suffer from a number of limitations. First, the RINA protocols that have been proposed to date (e.g., SRM <ref> [11] </ref> and LBRM [12]) have no mechanism for the source to know when it can safely release data from memory [10]. LBRM uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server. <p> The simulation results are graphed in Figure 7. The type of topologies considered in <ref> [11] </ref> to analyze SRM's performance correspond to the case in which Lorax produces optimum ACK trees, and Lorax with a tree-NAPP protocol should provide performance better than or at least equal to the best performance that can be expected from SRM.
Reference: 12. <author> H. Holbrook, S. K. Singhal, and D. R. Cheriton, </author> <title> Log-based receiver-reliable multicast for distributed interactive simulation, </title> <booktitle> in Proc. ACM SIGCOMM'95, </booktitle> <pages> pp. 328341, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: It is hoped that only one NAK is sent by the whole group to the parent for a lost packet. We refer to this protocol subclass as RINA (for Receiver-Initiated with NAK-Avoidance). The scalable reliable multicasting (SRM) protocol [11] and the log-based receiver-reliable multicast (LBRM) protocol <ref> [12] </ref> are examples of RINA protocols. 2.3 Ring-Based Protocols Our generic description of ring-based protocols is based on the Reliable Multicast Protocol (RMP) [7], which is based on the Token Ring Protocol (TRP) [3]. <p> Two additional advantages are that the source is not supposed to know the receiver set and and the receivers pace the source. However, RINA protocols suffer from a number of limitations. First, the RINA protocols that have been proposed to date (e.g., SRM [11] and LBRM <ref> [12] </ref>) have no mechanism for the source to know when it can safely release data from memory [10]. LBRM uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server.
Reference: 13. <author> W. T. Strayer, B. Dempsey, and A. Weaver, XTP: </author> <title> The Xpress Transfer Protocol. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: The receivers are not organized into any structure, and may contact the source directly. An example of this type of protocols is presented in <ref> [13] </ref>. It is well known this scheme suffers from the ACK-implosion problem. Whether the source or the receivers are in charge of pacing the source and scheduling retransmissions is unimportant for our taxonomy.
Reference: 14. <author> A. Koifman and S. Zabele, RAMP: </author> <title> A reliable adaptive mul-ticast protocol, </title> <booktitle> in IEEE Infocom'96, </booktitle> <pages> pp. 14421451, </pages> <month> March </month> <year> 1996. </year>
Reference: 15. <author> M. Grossglauser, </author> <title> Optimal deterministic timeouts for reliable scalable multicast, </title> <booktitle> in IEEE Infocom'96, </booktitle> <pages> pp. 14251441, </pages> <month> March </month> <year> 1996. </year>
Reference: 16. <author> Y. Ofek and B. Yener, </author> <title> Reliable concurrent multicast from bursty sources, </title> <booktitle> in IEEE Infocom'96, </booktitle> <pages> pp. 14331441, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: A considerable amount of work has been reported in the recent past on how to cope with or eliminate the ACK-implosion problem [2] <ref> [16] </ref>. However, the design of reliable multicast protocols is complex and there is no consensus yet on which is the best approach for the implementation of protocols for scalable, reliable concurrent multicasting over the Internet.
Reference: 17. <author> S. Deering and D. Cheriton, </author> <title> Multicast routing in datagram inter-networks and extended lans, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 8, </volume> <pages> pp. 85110, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: the highest maximum throughput among all reliable multicast protocol classes proposed to date. 1 In a tree-NAPP protocol, the receivers of a reliable multicast group are organized into an acknowledgment tree (ACK tree) built on top of the multicast routing tree (s) provided by such multicast routing protocols as DVMRP <ref> [17] </ref>, PIM [18], CBT [19], or OCBT [20]. A source multicasts packets to all the receivers through the multicast routing tree, and responsibility for retransmissions is delegated to the receivers. <p> In the Internet, these trees will be built using such protocols as Distance Vector Multicast Routing Protocol (DVMRP) <ref> [17] </ref>, Core Based Trees (CBT) [19], Ordered Core Based Trees (OCBT) [20], or Protocol Independent Multicast (PIM) [18]. To construct the ACK tree, Lorax utilizes a combination of root-based and off-tree schemes to grow the tree.
Reference: 18. <author> S. Deering, D. Estrin, D. Farinacci, V. Jacobson, and others., </author> <title> An architecture for wide-area multicast routing, </title> <booktitle> in Proc. ACM SIGCOMM'94, </booktitle> <pages> pp. 126135, </pages> <year> 1994. </year>
Reference-contexts: maximum throughput among all reliable multicast protocol classes proposed to date. 1 In a tree-NAPP protocol, the receivers of a reliable multicast group are organized into an acknowledgment tree (ACK tree) built on top of the multicast routing tree (s) provided by such multicast routing protocols as DVMRP [17], PIM <ref> [18] </ref>, CBT [19], or OCBT [20]. A source multicasts packets to all the receivers through the multicast routing tree, and responsibility for retransmissions is delegated to the receivers. <p> In the Internet, these trees will be built using such protocols as Distance Vector Multicast Routing Protocol (DVMRP) [17], Core Based Trees (CBT) [19], Ordered Core Based Trees (OCBT) [20], or Protocol Independent Multicast (PIM) <ref> [18] </ref>. To construct the ACK tree, Lorax utilizes a combination of root-based and off-tree schemes to grow the tree. These schemes are based on the common expanding ring search (ERS) technique over the underlying multicast routing tree (s) and mechanisms intended to limit the cost of each ERS.
Reference: 19. <author> T. Ballardie, P. Francis, and J. Crowcroft, </author> <title> Core based trees (CBT): An architecture for scalable inter-domain multicast routing, </title> <booktitle> in Proc. ACM SIGCOMM'93, </booktitle> <pages> pp. 8595, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: among all reliable multicast protocol classes proposed to date. 1 In a tree-NAPP protocol, the receivers of a reliable multicast group are organized into an acknowledgment tree (ACK tree) built on top of the multicast routing tree (s) provided by such multicast routing protocols as DVMRP [17], PIM [18], CBT <ref> [19] </ref>, or OCBT [20]. A source multicasts packets to all the receivers through the multicast routing tree, and responsibility for retransmissions is delegated to the receivers. <p> In the Internet, these trees will be built using such protocols as Distance Vector Multicast Routing Protocol (DVMRP) [17], Core Based Trees (CBT) <ref> [19] </ref>, Ordered Core Based Trees (OCBT) [20], or Protocol Independent Multicast (PIM) [18]. To construct the ACK tree, Lorax utilizes a combination of root-based and off-tree schemes to grow the tree.
Reference: 20. <author> C. Shields, </author> <title> Ordered core based trees, </title> <type> Master's thesis, </type> <institution> University of California Santa Cruz, Santa Cruz, California, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: multicast protocol classes proposed to date. 1 In a tree-NAPP protocol, the receivers of a reliable multicast group are organized into an acknowledgment tree (ACK tree) built on top of the multicast routing tree (s) provided by such multicast routing protocols as DVMRP [17], PIM [18], CBT [19], or OCBT <ref> [20] </ref>. A source multicasts packets to all the receivers through the multicast routing tree, and responsibility for retransmissions is delegated to the receivers. <p> In the Internet, these trees will be built using such protocols as Distance Vector Multicast Routing Protocol (DVMRP) [17], Core Based Trees (CBT) [19], Ordered Core Based Trees (OCBT) <ref> [20] </ref>, or Protocol Independent Multicast (PIM) [18]. To construct the ACK tree, Lorax utilizes a combination of root-based and off-tree schemes to grow the tree.
Reference: 21. <author> Dr. Seuss, </author> <title> The Lorax. Random House, </title> <year> 1971. </year>
Reference: 22. <author> Jon B. Postel, ed., RFC-793: </author> <title> Transmission control protocol. Request For Comments, </title> <month> September </month> <year> 1981. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory allocation (e.g., TCP <ref> [22] </ref>) or separate windows (e.g., NETBLT [23]). In all classes, packets are multicast unreliably from the source directly to all receivers. The protocol classes differ on how acknowledgments flow from the receivers back to the source.
Reference: 23. <author> D. D. Clark, M. L. Lambert, and L. Zhang, NETBLT: </author> <title> A high throughput transport protocol, </title> <booktitle> in Proc. ACM SIGCOMM'93, </booktitle> <pages> pp. 353359, </pages> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory allocation (e.g., TCP [22]) or separate windows (e.g., NETBLT <ref> [23] </ref>). In all classes, packets are multicast unreliably from the source directly to all receivers. The protocol classes differ on how acknowledgments flow from the receivers back to the source.
Reference: 24. <author> D. Summerville, J. Delgado-Frias, and S. Vassiliadis, </author> <title> A high performance pattern associative oblivious router for tree topologies, </title> <booktitle> in Proc. Eighth International Parallel Processing Symposium, </booktitle> <pages> pp. 541545, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: To remedy this, Lorax supports the proper dissemination of all acknowledgments in a multicast group along a single shared ACK tree of the concurrent multicast session. The routing scheme used in Lorax is adapted from a technique developed for the routing of messages between multiple processor elements described in <ref> [24] </ref>. Consider an ACK tree created for one original source, in which nodes have at most B children. The tree can be re-hung as an acknowledgment tree with any other node as the root, and all nodes will still have at most B children. <p> One such labeling scheme is presented in [25], but the algorithm requires the entire tree to be relabeled when any node is added or deleted. Our adaptation of <ref> [24] </ref> involves only two nodes for a completely new addition (the added node and its parent), and deletions require re-labeling of the subtree of the deleted node when patched back into the ACK tree. First we describe the construction of the shared ACK tree, then the labeling and routing scheme.
Reference: 25. <author> N. Santoro and R. Khatib, </author> <title> Labeling and implicit routing in networks, </title> <journal> The Computer Journal, </journal> <volume> vol. 28, </volume> <pages> pp. 58, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: All packets from a source include this label, from which receivers can infer to which child or parent to route towards that source. One such labeling scheme is presented in <ref> [25] </ref>, but the algorithm requires the entire tree to be relabeled when any node is added or deleted.
References-found: 25

