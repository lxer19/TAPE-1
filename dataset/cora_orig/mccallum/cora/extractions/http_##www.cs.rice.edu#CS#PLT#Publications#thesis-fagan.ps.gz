URL: http://www.cs.rice.edu/CS/PLT/Publications/thesis-fagan.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Soft Typing: An Approach to Type Checking for Dynamically Typed Languages  
Author: by Mike Fagan Robert S. Cartwright, Chairman Matthias Felleisen Bruce Duba 
Degree: A Thesis Submitted in Partial Fulfillment of the Requirements for the Degree Doctor of Philosophy Approved, Thesis Committee:  Professor of Computer Science  Assistant Professor of Computer Science Richard Tapia Professor  
Date: August, 1992  
Address: Houston, Texas  
Affiliation: RICE UNIVERSITY  of Mathematical Sciences  Research Associate of Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <booktitle> In Proceedings of the Sixteenth POPL Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: In these static systems, 1 and nil belong to different types. Example 1.4 A similar problem exists with the function: (x:cons (1; x)) [true; false] The expression builds the list <ref> [1; true; false] </ref>. Again, no run-time error results from the execution of this expression. The elements of the construction, however, belong to different types. Some are integer, some are boolean. In Curry static systems, non-uniform lists are systemically rejected. <p> Supposing P 0 = let x = e 0 1 in e 2 , by the induction hypothesis, E [[e 1 ]] = E [[e 0 136 Consequently, [x E [[e 1 ]]] = <ref> [x E [[e 0 So, 1 ] </ref>]] which means E [[let x = e 0 The other case is similarly straightforward. An obvious corollary gives the desired semantic preservation property. Corollary 4.1 Let P 0 be an ec-replacement of P . Then E [[P ]] = E [[P 0 ]]. <p> Supposing P 0 = let x = e 0 1 in e 2 , by the induction hypothesis, E [[e 1 ]] = E [[e 0 136 Consequently, [x E [[e 1 ]]] = [x E <ref> [[e 0 So, 1 ] </ref>]] which means E [[let x = e 0 The other case is similarly straightforward. An obvious corollary gives the desired semantic preservation property. Corollary 4.1 Let P 0 be an ec-replacement of P . Then E [[P ]] = E [[P 0 ]]. <p> The static typing literature that had the most influence on the thesis are analyzed in section 5.1.2 5.1.1 Philosophically Similar Work In 1989, Abadi, Cardelli, Pierce, and Plotkin <ref> [1] </ref> devised a statically typed language containing two new language elements, typecase, and dynamic and a new type, Dynamic. These purpose of these new elements was to add dynamic typing features to a statically typed language.
Reference: [2] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Amadio and Cardelli <ref> [2] </ref> derive a similar inference system to address the problems of subtyping and recursive types. 2.5 The Semantics of Regular Types In order to make meaningful statements about type expressions, and their relation to program expressions, we need a semantics for type expressions. <p> Since the intended programming language is Prolog, however, there are no function types. The type assignment method used for this system, however, also recognizes the usefulness of restricting types to be discriminative. Similarly, Amadio and Cardelli <ref> [2] </ref> describe an inference system accommodating both recursive types and subtypes. Their system makes use of rational trees in the inference process. By using intersection (conjunctions) instead of unions, Coppo,Dezani-Ciancaglini, and Venneri [13] develop a type system that assigns a type to all lambda calculus normal forms.
Reference: [3] <author> M.A. Arbib and Y. Give'on. </author> <title> Algebra automata i: Parallel programming as a prolegomena to the categorical approach. </title> <journal> Information and Control, </journal> <volume> 12, </volume> <year> 1968. </year>
Reference-contexts: Section 2.4.3 further explains the anomaly for functional types. 28 2.4.1 A Review of Regular Tree Expressions The primary source for this treatment of regular tree expressions, can be found in Geceg and Steinby [25]. Some further sources are Thatcher and Wright, Brainerd, Arbib, and Goguen <ref> [48, 5, 3, 47] </ref>. Some aspects of the theory may be derived from universal algebra, as in Burris [6] This section is expository. The proofs for these results can be found in the cited references.
Reference: [4] <editor> Henk Barendregt and Kees Hemerik. </editor> <booktitle> Types in lambda calculi and programming languages. In 3rd ESOP, </booktitle> <year> 1990. </year>
Reference-contexts: ML is the canonical example of such a language [34, 17]. Other members of the family include Hope [7] and Miranda [51]. These languages may be viewed as variants of the simply typed lambda calculus. 3 Barendregt <ref> [4] </ref> calls this family of languages the implicitly typed lambda calculi , or the Curry family. The key property of the Curry family is that the type checking method does not require type declarations.
Reference: [5] <author> Walter S. Brainerd. </author> <title> The minimalization of tree automata. </title> <journal> Information and Control, </journal> <volume> 13, </volume> <year> 1968. </year>
Reference-contexts: Section 2.4.3 further explains the anomaly for functional types. 28 2.4.1 A Review of Regular Tree Expressions The primary source for this treatment of regular tree expressions, can be found in Geceg and Steinby [25]. Some further sources are Thatcher and Wright, Brainerd, Arbib, and Goguen <ref> [48, 5, 3, 47] </ref>. Some aspects of the theory may be derived from universal algebra, as in Burris [6] This section is expository. The proofs for these results can be found in the cited references.
Reference: [6] <author> Stan Burris and H. P. Sankappanavar. </author> <title> A Course in Universal Algebra. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Some further sources are Thatcher and Wright, Brainerd, Arbib, and Goguen [48, 5, 3, 47]. Some aspects of the theory may be derived from universal algebra, as in Burris <ref> [6] </ref> This section is expository. The proofs for these results can be found in the cited references. A regular tree expression defines a set of terms, so one should clarify what is meant by a term.
Reference: [7] <author> Burstall, MacQueen, and Sannella. </author> <title> Hope: An experimental applicative language. </title> <booktitle> In Proceedings of the first international LISP conference, </booktitle> <year> 1980. </year>
Reference-contexts: There are several static type checkers that do not require type information from the user. The most notable such checker is a component of many modern functional languages. ML is the canonical example of such a language [34, 17]. Other members of the family include Hope <ref> [7] </ref> and Miranda [51]. These languages may be viewed as variants of the simply typed lambda calculus. 3 Barendregt [4] calls this family of languages the implicitly typed lambda calculi , or the Curry family.
Reference: [8] <author> W. Buttner. </author> <title> Unification in the data structure sets. </title> <booktitle> In Proceedings of the 8th International Conference on Automated Deduction, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: Consequently, a solution method for equations over an associative, commutative, idempotent algebra is required. The solution of equations over various algebraic theories is the subject of general unification theory [43]. For an associative, commutative, idempotent theory, general unification theory provides ACI unification <ref> [8, 30] </ref>. In principle, ACI unification could be used to generate solutions to regular type equations. This method, however, also has drawbacks: 1. There are multiple unifiers, as opposed to standard unification's single unifier. Hence, there are no principle types. 2.
Reference: [9] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. B. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: These systems are especially interesting for soft typing considerations because the object oriented data, namely "records" and "variants", possess a property greatly resembling subtyping. This property is called inheritance in that body of literature. The first discernable "object-oriented" type system originates with Cardelli <ref> [9] </ref>. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer [44], Wand [53, 55, 56], Jategaonkar-Mitchell [29] and Remy [39].
Reference: [10] <author> Robert Cartwright. </author> <title> A constructive alternative to axiomatic data type definitions. </title> <booktitle> In Proceedings of 1980 LISP Conference, </booktitle> <year> 1980. </year> <month> 164 </month>
Reference-contexts: The view of first order 17 data taken here is the constructive view established in Cartwright <ref> [10] </ref>. A similar view is taken by Mishra and Reddy [35]. The constructive view considers all first order data to be built from constructors. Furthermore, a constructor may restrict its arguments to be of a certain construction (in a crude form of dynamic typing). <p> The specification of the constructors, the valid constructions for arguments to the constructor, and the names of the associated selectors make up a constructive definition, or, first order specification. We consider the first order specification to be an integral part of the language specification. The notation in <ref> [10] </ref> gives a nice, succinct notation for the necessary information in a first order specification.
Reference: [11] <author> Robert Cartwright. </author> <title> Types as intervals. </title> <type> Technical report, </type> <institution> Rice Univesity, </institution> <year> 1984-1985. </year>
Reference-contexts: See Cartwright <ref> [11] </ref> for a discussion of other possible choices 37 Theorem 2.2 (I is a lattice) I is a complete lattice under (set inclusion) or (set containment).
Reference: [12] <author> Alain Colmerauer. </author> <title> Prolog and infinite trees. </title> <editor> In K. L. Clark and S. A. Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 231-251. </pages> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Rational trees share an important property of finite trees. This property is the existence of an algorithm to solve systems of equations. For finite trees, Robinson's unification algorithm computes the most general solution. For rational trees, there is a variant of ordinary unification, called "circular" unification <ref> [14, 12, 33] </ref> that computes most general solutions. This algorithm makes rational trees viable for solving type constraint equations. One must take care, however, to examine carefully the consequences of using a different algebra as a solution space. Changing solution spaces requires a change in the type language.
Reference: [13] <author> M. Coppo, M. Dezani, and B. Venneri. </author> <title> Principal type scheme and -calculus semantics. </title> <editor> In J. P. Hindley and J. R. Seldin, editors, To H. B. </editor> <booktitle> Curry. Essays on Combinatory Logic, -Calculus and Formalism. </booktitle> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Similarly, Amadio and Cardelli [2] describe an inference system accommodating both recursive types and subtypes. Their system makes use of rational trees in the inference process. By using intersection (conjunctions) instead of unions, Coppo,Dezani-Ciancaglini, and Venneri <ref> [13] </ref> develop a type system that assigns a type to all lambda calculus normal forms. The system, however, is undecidable. Systems with general subtyping By viewing subtyping as coercion application, Mitchell [36] introduced a type system with an extremely liberal view of subtyping. <p> Some preliminary analysis indicates that the typing can be improved by inserting some special coercions. It remains to be seen if the method can be automated and generalized. Another promising area of research involves adding some conjunctive typing to the type system. One must be careful, as Coppo <ref> [13] </ref> has shown that conjunctive typing is, in general, undecidable. Perhaps some compromise along the lines proposed by Ghosh-Roy [26]. Concerning the coercion insertion method of chapter 4, we need to determine the "optimality" of the method.
Reference: [14] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25(2) </volume> <pages> 95-169, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: Rational trees share an important property of finite trees. This property is the existence of an algorithm to solve systems of equations. For finite trees, Robinson's unification algorithm computes the most general solution. For rational trees, there is a variant of ordinary unification, called "circular" unification <ref> [14, 12, 33] </ref> that computes most general solutions. This algorithm makes rational trees viable for solving type constraint equations. One must take care, however, to examine carefully the consequences of using a different algebra as a solution space. Changing solution spaces requires a change in the type language.
Reference: [15] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> Xerox PARC, </note> <year> 1990. </year>
Reference-contexts: The primary advocates of the retained inequalities method are Mitchell [36], Fuh and Mishra [21, 22, 23], and Curtis <ref> [15] </ref>. In this approach, some inequality constraints are retained as part of the type expression. <p> In spite of some success in reducing the number of constraints, types are still overly complicated 2. There is no parametric polymorphism 160 3. The decidable portion of this theory does not support functions as elements of types that may include non-functional objects Pavel Curtis's thesis <ref> [15] </ref> develops a similar idea that he calls "constrained quantification". He retains the constraints as part of the type. In contrast to the Fuh-Mishra system, Curtis allows parametric polymorphism. The decidability of the system in its general form, however, is still an open question.
Reference: [16] <author> O. J. Dahl, C. A. R. Hoare, and E. W. Dijkstra. </author> <title> Structured Programming. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: The intuitive reason for the failure of these examples derives from the view of type embedded in the Curry tradition. Curry style languages ascribe to the view that a value has exactly one type. The Curry principle was popularized as the Hoare-Dahl-Dijkstra view of types <ref> [16] </ref>. Every value belongs to one and only one type In contrast, programmers using a dynamically typed language (like Scheme) expect values to be uniquely constructed, but they frequently define functions that work on different kinds of data.
Reference: [17] <author> Luis Damas and Robin Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: There are several static type checkers that do not require type information from the user. The most notable such checker is a component of many modern functional languages. ML is the canonical example of such a language <ref> [34, 17] </ref>. Other members of the family include Hope [7] and Miranda [51]. These languages may be viewed as variants of the simply typed lambda calculus. 3 Barendregt [4] calls this family of languages the implicitly typed lambda calculi , or the Curry family. <p> suc); constructor nil; constructor cons (hd:0 [ suc [ cons [ nil [ !; tail:nil [ cons) Example 2.2 indicates that cons may take any kind of value whatsoever as its first argument. 2.2 The Programming Language Exp The prototypical programming language family is related Exp family introduced by Milner <ref> [17, 34] </ref>. Our version of Exp lacks the if construct. Branching is accomplished by special constants. Note that the language family is parameterized by the set of allowed constants. <p> Associated with the inference system is the type assignment algorithm, often called "algorithm W" in the literature. The version given by Damas and Milner <ref> [17] </ref> uses the unification algorithm of Robinson [40]. The symbol U denotes this unification algorithm. For further notational convenience A (t) = 8ff 1 : : : ff n :t where the ff i are free in t, but not in A.
Reference: [18] <author> Luis Manuel Martins Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: Let I i be the ideal T [[t i ]]-. Then a value v : T [[]] in valuation if for every choice of monotypes t i : v 2 T [[t]]-[ff 1 I 1 ; ff n I n ] Damas <ref> [18] </ref> proves a useful lemma. This lemma presumes that type schemes are equivalent up to renaming of quantified variables. <p> Let be an environ ment respecting A, and let beany valuation. Then E [[e]] : T [[]]- Proof By structural induction on the last step of the inference. Details in section 2.8. As perspective, all the cases in theorem 2.9 are virtually identical to the original proof in <ref> [34, 18] </ref>. The only difference is the rules of definition 2.30 have one additional element, namely rule Sub. The semantics of rule Sub are very intuitive | any type can be replaced by a supertype. The effect of such a simple change is surprising. <p> The algorithm fails whenever any of the above conditions are not met. Damas <ref> [18] </ref> proves two theorems concerning algorithm W. Theorem 3.1 (Syntactic Soundness ) If W (A; e) succeeds with (S; t ), then there is a derivation using the Milner rules of SA ` e : t .
Reference: [19] <author> Bruce F. Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: To simplify the analysis, we restrict ourselves to functional languages, but we expect to be able to extend our ideas to non-functional constructs in a similar manner to Tofte [50] or Duba <ref> [19] </ref>. The family of functional languages adopted herein is parameterized by the set of constants, or primitives. The set of constants, in turn, is guided by the data used by the program. Program data is a design consideration, and, as such is programmer-directed.
Reference: [20] <author> James Dugundji. Topoloy. Allyn and Bacon, </author> <year> 1966. </year>
Reference-contexts: number 0 r &lt; 1 such that for all x; x 0 2 X d (f (x); f (x 0 )) rd (x; x 0 ) If we relax the restriction on r so that 0 r 1 then the map f is termed non-expansive The Banach fixed point theorem <ref> [20] </ref> summarizes the importance of contractive maps. Theorem 2.4 (Banach fixed point theorem) Let X be a complete metric space. Let f : X ! X be contractive.
Reference: [21] <author> You-Chin Fuh. </author> <title> Design and Implementation of a Functional Language with Sub-types. </title> <type> PhD thesis, </type> <institution> State University of New York at Stony Brook, </institution> <year> 1989. </year>
Reference-contexts: The primary advocates of the retained inequalities method are Mitchell [36], Fuh and Mishra <ref> [21, 22, 23] </ref>, and Curtis [15]. In this approach, some inequality constraints are retained as part of the type expression. <p> Consequently, the type expressions in his system included the inequalities as part of the type as in: t; fff fi; (ff ! fi) tg ` x:x : t Fuh and Mishra [22, 23] improve on Mitchell's methods, and Fuh's thesis <ref> [21] </ref> addresses the problem of the actual insertion of the coercions necessary to support the supplied typing. These systems have three problem drawbacks when considered as possible soft typing systems 1. The type expressions are unintuitive and somewhat unwieldy.
Reference: [22] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Type inference with subtypes. </title> <booktitle> In Conference Record of the European Symposium on Programming, </booktitle> <year> 1988. </year>
Reference-contexts: The primary advocates of the retained inequalities method are Mitchell [36], Fuh and Mishra <ref> [21, 22, 23] </ref>, and Curtis [15]. In this approach, some inequality constraints are retained as part of the type expression. <p> He was the first to note that systems with subtypes cannot have principal types in the Milner sense. Consequently, the type expressions in his system included the inequalities as part of the type as in: t; fff fi; (ff ! fi) tg ` x:x : t Fuh and Mishra <ref> [22, 23] </ref> improve on Mitchell's methods, and Fuh's thesis [21] addresses the problem of the actual insertion of the coercions necessary to support the supplied typing. These systems have three problem drawbacks when considered as possible soft typing systems 1. The type expressions are unintuitive and somewhat unwieldy.
Reference: [23] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In TAPSOFT, </booktitle> <year> 1989. </year> <month> 165 </month>
Reference-contexts: The primary advocates of the retained inequalities method are Mitchell [36], Fuh and Mishra <ref> [21, 22, 23] </ref>, and Curtis [15]. In this approach, some inequality constraints are retained as part of the type expression. <p> He was the first to note that systems with subtypes cannot have principal types in the Milner sense. Consequently, the type expressions in his system included the inequalities as part of the type as in: t; fff fi; (ff ! fi) tg ` x:x : t Fuh and Mishra <ref> [22, 23] </ref> improve on Mitchell's methods, and Fuh's thesis [21] addresses the problem of the actual insertion of the coercions necessary to support the supplied typing. These systems have three problem drawbacks when considered as possible soft typing systems 1. The type expressions are unintuitive and somewhat unwieldy.
Reference: [24] <author> Gannon. </author> <title> An experimental evaluation of data type conventions. </title> <journal> Communications of ACM, </journal> <month> August </month> <year> 1977. </year>
Reference-contexts: Clerical and simple conceptual errors often lead to type errors detectable by the type checker. Experimental results estimate the number of errors due to detectable type faults as something between 30% and 80% of all program errors <ref> [24] </ref>. * Assigning types to program variables and operations provides a succinct, intelligible form of program documentation, making programs easier to read and understand. Moreover, the type checker certifies that the type documentation is consistent. 2 * Type information is useful in program optimization.
Reference: [25] <author> Ferenc Geceg and Magnus Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: The discussion in section 2.4.2 continues with the design of the type language. Section 2.4.3 further explains the anomaly for functional types. 28 2.4.1 A Review of Regular Tree Expressions The primary source for this treatment of regular tree expressions, can be found in Geceg and Steinby <ref> [25] </ref>. Some further sources are Thatcher and Wright, Brainerd, Arbib, and Goguen [48, 5, 3, 47]. Some aspects of the theory may be derived from universal algebra, as in Burris [6] This section is expository. The proofs for these results can be found in the cited references. <p> These presentations use regular tree grammars instead of regular tree expressions as the primary formalism. Both points of view are equivalent. Again, see Geceg and Steinby <ref> [25] </ref> 29 1. The special symbol ; is a regular tree expression 2. If x 2 X, x 2 R (F; X). Similarly, if f 2 F; Arity (f ) = 0, then f 2 R (F; X). 3. <p> E 2 R (F; X); x 2 X, then ((E) flx ) = (E) flx The following theorem, proved in <ref> [25] </ref>, justifies the interest in regular tree expres sions Theorem 2.1 (Decidability of Emptyness,Finiteness, and Subset ) Let E be a regular type expression. There is an algorithm to determine if (E) is empty, or if it is finite.
Reference: [26] <author> R. Ghosh-Roy. </author> <title> Conjunction type standard ml polymorphism. Lisp and Symbolic Computation, </title> <address> 3(IV):381-410, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Another promising area of research involves adding some conjunctive typing to the type system. One must be careful, as Coppo [13] has shown that conjunctive typing is, in general, undecidable. Perhaps some compromise along the lines proposed by Ghosh-Roy <ref> [26] </ref>. Concerning the coercion insertion method of chapter 4, we need to determine the "optimality" of the method. We need to determine if the number of coercions inserted can be made smaller or not. If it cannot, we should show this.
Reference: [27] <author> John Hopcroft and Jeffrey Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: In other words, all basic questions about regular sets are decidable. For a complete account of regular expressions, see <ref> [27] </ref>. As discussed above, the theory of regular expressions is based on sets of strings. The general regularity theory is based on sets of terms or trees.
Reference: [28] <author> Gerard Huet. </author> <type> Resolution d'equations dans les langages d'ordre 1; 2; : : : ; !. PhD thesis, </type> <institution> Universite Paris, </institution> <month> 7 </month> <year> 1976. </year>
Reference-contexts: The natural question to ask, then, is do syntactic soundness and completeness still hold for Algorithm W with the new type language ? In the case of rational trees, the answer is yes. Remy [39], building on results of Huet <ref> [28] </ref>, proves that both syntactic soundness and syntactic completeness are valid for algorithm W, even when the type language is the rational trees over (C; X) and standard unification is replaced by circular unification. 71 To summarize, the Milner type assignment method can be viewed as two distinct processes: the generation
Reference: [29] <author> Lalita A. Jategaonkar and John C. Mitchell. </author> <title> Type inference with subtypes. </title> <booktitle> In Proceedings of the 1988 Conference on LISP and Functional Programming, </booktitle> <year> 1988. </year>
Reference-contexts: The first discernable "object-oriented" type system originates with Cardelli [9]. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer [44], Wand [53, 55, 56], Jategaonkar-Mitchell <ref> [29] </ref> and Remy [39]. As evidenced in chapters 3 and 4, the Remy work provided a clear basis for the research in this thesis. The Remy work provided two attractive features in comparison to others: 1.
Reference: [30] <author> Patrick Lincoln and Jim Christian. </author> <title> Adventures in associative-commutative unification. </title> <booktitle> In Proceedings of the 9th International Conference on Automated Deduction, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Consequently, a solution method for equations over an associative, commutative, idempotent algebra is required. The solution of equations over various algebraic theories is the subject of general unification theory [43]. For an associative, commutative, idempotent theory, general unification theory provides ACI unification <ref> [8, 30] </ref>. In principle, ACI unification could be used to generate solutions to regular type equations. This method, however, also has drawbacks: 1. There are multiple unifiers, as opposed to standard unification's single unifier. Hence, there are no principle types. 2.
Reference: [31] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: The formal definition for the type language appears later in the section. The set of types proposed in this section is called the regular types. The semantics for type language, appearing in section 2.5 employs the ideal model for types. The ideal model is explained in <ref> [31, 32] </ref>. A brief review of these results prefaces the actual semantic definition for the type language. <p> If a type can be structure free, then there may be no good way to define new types from old. When using domains (countably based, algebraic, complete, partial orders), one successful semantics for types introduced by MacQueen et al <ref> [31] </ref> uses the ideals of the domain to interpret type expressions. The definition of an ideal is: Definition 2.20 (Ideals of D) Let D be a domain with order relation v, and let I D. Then I is an ideal iff: 1. I is downward closed. <p> Since d is an ultra metric, a multi-argument function is contractive iff it is contractive in all arguments separately. 6. If f (u; v) is contractive, then f is contractive. This subject is discussed in more detail by MacQueen et al <ref> [31, 32] </ref>. 39 2.5.2 Semantics of Regular Types The definition of semantics for a type language is quite similar to the definition of semantics for a programming language.
Reference: [32] <author> D. B. MacQueen and Ravi Sethi. </author> <title> A semantic model of types for applicative languages. </title> <booktitle> In Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: The formal definition for the type language appears later in the section. The set of types proposed in this section is called the regular types. The semantics for type language, appearing in section 2.5 employs the ideal model for types. The ideal model is explained in <ref> [31, 32] </ref>. A brief review of these results prefaces the actual semantic definition for the type language. <p> Since d is an ultra metric, a multi-argument function is contractive iff it is contractive in all arguments separately. 6. If f (u; v) is contractive, then f is contractive. This subject is discussed in more detail by MacQueen et al <ref> [31, 32] </ref>. 39 2.5.2 Semantics of Regular Types The definition of semantics for a type language is quite similar to the definition of semantics for a programming language.
Reference: [33] <author> Michael Maher. </author> <title> Complete axiomatizations of finite, rational, and infinite trees. </title> <booktitle> In 3rd Logic In Computer Science Conference, </booktitle> <year> 1988. </year>
Reference-contexts: Rational trees share an important property of finite trees. This property is the existence of an algorithm to solve systems of equations. For finite trees, Robinson's unification algorithm computes the most general solution. For rational trees, there is a variant of ordinary unification, called "circular" unification <ref> [14, 12, 33] </ref> that computes most general solutions. This algorithm makes rational trees viable for solving type constraint equations. One must take care, however, to examine carefully the consequences of using a different algebra as a solution space. Changing solution spaces requires a change in the type language.
Reference: [34] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <year> 1978. </year>
Reference-contexts: There are several static type checkers that do not require type information from the user. The most notable such checker is a component of many modern functional languages. ML is the canonical example of such a language <ref> [34, 17] </ref>. Other members of the family include Hope [7] and Miranda [51]. These languages may be viewed as variants of the simply typed lambda calculus. 3 Barendregt [4] calls this family of languages the implicitly typed lambda calculi , or the Curry family. <p> suc); constructor nil; constructor cons (hd:0 [ suc [ cons [ nil [ !; tail:nil [ cons) Example 2.2 indicates that cons may take any kind of value whatsoever as its first argument. 2.2 The Programming Language Exp The prototypical programming language family is related Exp family introduced by Milner <ref> [17, 34] </ref>. Our version of Exp lacks the if construct. Branching is accomplished by special constants. Note that the language family is parameterized by the set of allowed constants. <p> Let be an environ ment respecting A, and let beany valuation. Then E [[e]] : T [[]]- Proof By structural induction on the last step of the inference. Details in section 2.8. As perspective, all the cases in theorem 2.9 are virtually identical to the original proof in <ref> [34, 18] </ref>. The only difference is the rules of definition 2.30 have one additional element, namely rule Sub. The semantics of rule Sub are very intuitive | any type can be replaced by a supertype. The effect of such a simple change is surprising. <p> In fact, the importance is codified in the Minimal-Text Principle of chapter 1. Consequently, this chapter presents an automatic type assignment method for RegType, the type language of chapter 2. The automatic type assignment algorithm presented in this chapter is based on Milner's type assignment algorithm <ref> [34] </ref> The Milner type assignment method can be decomposed into two separate tasks. First, all expressions are assigned a unique type variable, and the inference system generates a set of equality constraints necessary for the type inference to be valid. This task resembles generating verification conditions for programs.
Reference: [35] <author> Prateek Mishra and Uday S. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1984. </year> <month> 166 </month>
Reference-contexts: The view of first order 17 data taken here is the constructive view established in Cartwright [10]. A similar view is taken by Mishra and Reddy <ref> [35] </ref>. The constructive view considers all first order data to be built from constructors. Furthermore, a constructor may restrict its arguments to be of a certain construction (in a crude form of dynamic typing). <p> Furthermore, the decision procedure that answers the subset question for regular tree expressions constitutes a ready-made system for reasoning about sub types relations. A similar type system was developed by Mishra and Reddy <ref> [35] </ref>. A type system based on general regularity theory contains a rich set of types. For example, it is possible to distinguish even and odd integers, and to prove that even (or odd) is a subtype of regular integers. Regrettably, the correspondence between types and regular trees is not perfect. <p> Example 3.6 (Using discriminative slack variables) In this example, a is a 1-ary type constructor, b, and c are 0-ary type constructors, and x; y are variables. Then the inequality x a (b) + c 15 This terminology is derived from a similar notion by Mishra and Reddy <ref> [35] </ref>, which is discussed in chapter 5. 76 has the following three solutions x = a (b) x = a (b) + c These solutions are obtained by simply eliminating components from the upper bound a (b) + c, and solving the corresponding equation. <p> All systems considered had some potential relevance to the soft typing problem. The following remarks indicate the salient features of a good cross section of the systems scrutinized during the course of this thesis. Systems with similar constructs Mishra and Reddy <ref> [35] </ref> develop a type system for Prolog programs that includes both union types and recursive types. Since the intended programming language is Prolog, however, there are no function types. The type assignment method used for this system, however, also recognizes the usefulness of restricting types to be discriminative.
Reference: [36] <author> John C. Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: The primary advocates of the retained inequalities method are Mitchell <ref> [36] </ref>, Fuh and Mishra [21, 22, 23], and Curtis [15]. In this approach, some inequality constraints are retained as part of the type expression. <p> By using intersection (conjunctions) instead of unions, Coppo,Dezani-Ciancaglini, and Venneri [13] develop a type system that assigns a type to all lambda calculus normal forms. The system, however, is undecidable. Systems with general subtyping By viewing subtyping as coercion application, Mitchell <ref> [36] </ref> introduced a type system with an extremely liberal view of subtyping. He was the first to note that systems with subtypes cannot have principal types in the Milner sense.
Reference: [37] <author> A. M. Morshedi and R. A. Tapia. </author> <title> Karmarkar as a classical method. </title> <institution> Mathematical Sciences 87-7, Rice University, </institution> <month> Aug </month> <year> 1987. </year>
Reference-contexts: The slack variable approach introduces auxiliary variables to "take up the slack" in the inequalities. To 14 The idea of slack variables appears to be very old. The interested reader, however, may wish to examine Tapia's account of this technique in a different context from typechecking <ref> [46, 37] </ref> 73 see specifically how this applies to type inequalities, suppose a generated constraint requires X Y Using the slack variable technique, the constraint may be expressed Y = X [ S for S some new variable. S is the slack variable.
Reference: [38] <author> Neal Nelson. </author> <title> Primitive recursive functionals with dependent types. </title> <type> Private communication, </type> <month> Feb </month> <year> 1990. </year>
Reference-contexts: ! cons (Z) 29; 31; App Line 32 above states T 0 ` deep : 0 + suc ! cons (fix t:z + cons (t)) rewriting the abbreviation for Z. 51 Example 2.9 (A tautology checking function ) This example was presented to us by Jim Hook and Neal Nelson <ref> [38] </ref> 13 . The purpose is very simple. Given a curried function f that takes some arbitrary number of boolean arguments, decide if f is a tautology or not. That is, is f (x 1 ; x 2 ; : : : ; x n ) always true.
Reference: [39] <author> Dider Remy. </author> <title> Typechecking records and variants in a natural extension of ml. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: The natural question to ask, then, is do syntactic soundness and completeness still hold for Algorithm W with the new type language ? In the case of rational trees, the answer is yes. Remy <ref> [39] </ref>, building on results of Huet [28], proves that both syntactic soundness and syntactic completeness are valid for algorithm W, even when the type language is the rational trees over (C; X) and standard unification is replaced by circular unification. 71 To summarize, the Milner type assignment method can be viewed <p> The first discernable "object-oriented" type system originates with Cardelli [9]. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer [44], Wand [53, 55, 56], Jategaonkar-Mitchell [29] and Remy <ref> [39] </ref>. As evidenced in chapters 3 and 4, the Remy work provided a clear basis for the research in this thesis. The Remy work provided two attractive features in comparison to others: 1. The technique encoded inheritance as standard parametric polymorphism, so that a standard Milner technique was applicable 2.
Reference: [40] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution principle. </title> <journal> Journal of ACM, </journal> <month> December </month> <year> 1965. </year>
Reference-contexts: Associated with the inference system is the type assignment algorithm, often called "algorithm W" in the literature. The version given by Damas and Milner [17] uses the unification algorithm of Robinson <ref> [40] </ref>. The symbol U denotes this unification algorithm. For further notational convenience A (t) = 8ff 1 : : : ff n :t where the ff i are free in t, but not in A.
Reference: [41] <author> David A Schmidt. </author> <title> Denotational Semantics. </title> <publisher> Allyn and Bacon,Inc, </publisher> <year> 1986. </year>
Reference-contexts: The set K is determined by a first order specification S, and an (optional) set of auxiliary constants. 21 2.3 Semantics of Exp To give meaning to the programming language requires a semantics. The semantics for Exp employs the well understood denotational model illustrated in <ref> [45, 41, 42] </ref> and many others. The first requirement for any denotational semantics is a data domain, as described in section 2.3.1. The remaining sections comprise the denotational definition of Exp.
Reference: [42] <author> Dana Scott. </author> <title> Data types as lattices. </title> <journal> Siam Journal of Computing, </journal> <year> 1976. </year>
Reference-contexts: The set K is determined by a first order specification S, and an (optional) set of auxiliary constants. 21 2.3 Semantics of Exp To give meaning to the programming language requires a semantics. The semantics for Exp employs the well understood denotational model illustrated in <ref> [45, 41, 42] </ref> and many others. The first requirement for any denotational semantics is a data domain, as described in section 2.3.1. The remaining sections comprise the denotational definition of Exp.
Reference: [43] <author> Jorg H Siekmann. </author> <title> Unification theory. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7(3 and 4), </volume> <year> 1989. </year>
Reference-contexts: The + operator is associative, commutative, and idempotent. Consequently, a solution method for equations over an associative, commutative, idempotent algebra is required. The solution of equations over various algebraic theories is the subject of general unification theory <ref> [43] </ref>. For an associative, commutative, idempotent theory, general unification theory provides ACI unification [8, 30]. In principle, ACI unification could be used to generate solutions to regular type equations. This method, however, also has drawbacks: 1. There are multiple unifiers, as opposed to standard unification's single unifier.
Reference: [44] <author> Ryan Stansifer. </author> <title> Type inference with subtypes. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: This property is called inheritance in that body of literature. The first discernable "object-oriented" type system originates with Cardelli [9]. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer <ref> [44] </ref>, Wand [53, 55, 56], Jategaonkar-Mitchell [29] and Remy [39]. As evidenced in chapters 3 and 4, the Remy work provided a clear basis for the research in this thesis. The Remy work provided two attractive features in comparison to others: 1.
Reference: [45] <author> Joseph Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <year> 1979. </year>
Reference-contexts: The set K is determined by a first order specification S, and an (optional) set of auxiliary constants. 21 2.3 Semantics of Exp To give meaning to the programming language requires a semantics. The semantics for Exp employs the well understood denotational model illustrated in <ref> [45, 41, 42] </ref> and many others. The first requirement for any denotational semantics is a data domain, as described in section 2.3.1. The remaining sections comprise the denotational definition of Exp.
Reference: [46] <author> R. A. Tapia. </author> <title> On the role of slack variables in quasi-newton methods for constrained optimization. </title> <editor> In L.C.W. Dixon and G. P. Szego, editors, </editor> <booktitle> Numerical Optimization of Dynamic Systems, </booktitle> <pages> pages 235-246. </pages> <publisher> North-Holland Publishing Company, </publisher> <year> 1980. </year>
Reference-contexts: The slack variable approach introduces auxiliary variables to "take up the slack" in the inequalities. To 14 The idea of slack variables appears to be very old. The interested reader, however, may wish to examine Tapia's account of this technique in a different context from typechecking <ref> [46, 37] </ref> 73 see specifically how this applies to type inequalities, suppose a generated constraint requires X Y Using the slack variable technique, the constraint may be expressed Y = X [ S for S some new variable. S is the slack variable.
Reference: [47] <author> J. W. Thatcher. </author> <title> Characterizing derivation trees of context free grammars through a generalization of finite automata theory. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 1, </volume> <year> 1967. </year> <month> 167 </month>
Reference-contexts: Section 2.4.3 further explains the anomaly for functional types. 28 2.4.1 A Review of Regular Tree Expressions The primary source for this treatment of regular tree expressions, can be found in Geceg and Steinby [25]. Some further sources are Thatcher and Wright, Brainerd, Arbib, and Goguen <ref> [48, 5, 3, 47] </ref>. Some aspects of the theory may be derived from universal algebra, as in Burris [6] This section is expository. The proofs for these results can be found in the cited references.
Reference: [48] <author> J.W. Thatcher and J.B. Wright. </author> <title> Generalized finite automata theory with an application to a decision problem of second-order logic. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2(1), </volume> <year> 1966. </year>
Reference-contexts: Section 2.4.3 further explains the anomaly for functional types. 28 2.4.1 A Review of Regular Tree Expressions The primary source for this treatment of regular tree expressions, can be found in Geceg and Steinby [25]. Some further sources are Thatcher and Wright, Brainerd, Arbib, and Goguen <ref> [48, 5, 3, 47] </ref>. Some aspects of the theory may be derived from universal algebra, as in Burris [6] This section is expository. The proofs for these results can be found in the cited references.
Reference: [49] <author> Sattish Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Proceedings of the Seventeenth POPL Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: To maintain the integrity of the static typing, the system must include a wall to separate the dynamic capabilities from the static ones. As such, the properties of the type Dynamic language differ significantly from the desired properties of a softly typed language. Thatte <ref> [49] </ref> considers a system he calls "Quasi-static typing" to accommodate a merger of static and dynamic typing. The salient features of his system are: 1. A type , such that any type t .
Reference: [50] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: To simplify the analysis, we restrict ourselves to functional languages, but we expect to be able to extend our ideas to non-functional constructs in a similar manner to Tofte <ref> [50] </ref> or Duba [19]. The family of functional languages adopted herein is parameterized by the set of constants, or primitives. The set of constants, in turn, is guided by the data used by the program. Program data is a design consideration, and, as such is programmer-directed. <p> All of these constructs are present in Standard ML of New Jersey, as well as Scheme. Consequently, we would like to extend our type system to accommodate these programming language features, in much the same way as Tofte <ref> [50] </ref> for statically typed languages. In addition, the module constructs of ML are worthy of some attention. As for improving the type methods, we see at least two interesting avenues for exploration. First, the inferior type assigned to the deep function merits attention.
Reference: [51] <author> David A. Turner. </author> <title> Miranda a non-strict functional language with polymorphic types. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1985. </year>
Reference-contexts: There are several static type checkers that do not require type information from the user. The most notable such checker is a component of many modern functional languages. ML is the canonical example of such a language [34, 17]. Other members of the family include Hope [7] and Miranda <ref> [51] </ref>. These languages may be viewed as variants of the simply typed lambda calculus. 3 Barendregt [4] calls this family of languages the implicitly typed lambda calculi , or the Curry family. The key property of the Curry family is that the type checking method does not require type declarations.
Reference: [52] <author> Mitchell Wand. </author> <title> A types-as-sets semantics for milner-style polymorphism. </title> <booktitle> In 11th POPL, </booktitle> <year> 1984. </year>
Reference-contexts: Routines with this property accept as input a wide variety of different, but structurally similar data, and the output type 3 Some researchers believe that these languages forced fundamental extensions to the typed lambda calculus to accommodate polymorphic function definitions, but Wand's <ref> [52] </ref> research indicates this is not necessary. 9 of such a routine depends on the input type in a uniform way. The type behavior of parametrically polymorphic routines can be uniformly characterized by type variables (the type parameter). A few examples will clarify this concept.
Reference: [53] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the Second Symposium on Logic in Computer Science, </booktitle> <year> 1987. </year>
Reference-contexts: The first discernable "object-oriented" type system originates with Cardelli [9]. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer [44], Wand <ref> [53, 55, 56] </ref>, Jategaonkar-Mitchell [29] and Remy [39]. As evidenced in chapters 3 and 4, the Remy work provided a clear basis for the research in this thesis. The Remy work provided two attractive features in comparison to others: 1.
Reference: [54] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamenta Informatica, </journal> <volume> X:115-122, </volume> <year> 1987. </year>
Reference-contexts: In algorithm W, the solution method is term unification. To clarify the mechanics of this view of type assignment, consider example 3.1. This example indicates the constraint generation process in an informal way. For a more systemic treatment, see Wand <ref> [54] </ref>. Example 3.1 (Constraint generation ) Consider the S combinator. S = x:y:z:xz (yz) Initially, assign type t 0 to S.
Reference: [55] <author> Mitchell Wand. </author> <title> Corrigendum:complete type inference for simple objects. </title> <booktitle> In Proceedings of the Third Symposium on Logic in Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: The first discernable "object-oriented" type system originates with Cardelli [9]. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer [44], Wand <ref> [53, 55, 56] </ref>, Jategaonkar-Mitchell [29] and Remy [39]. As evidenced in chapters 3 and 4, the Remy work provided a clear basis for the research in this thesis. The Remy work provided two attractive features in comparison to others: 1.
Reference: [56] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In 4th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: The first discernable "object-oriented" type system originates with Cardelli [9]. This work introduces the notions of records and variants, and provides a type-checking algorithm for a simple language including the new constructs. Researchers building on this work include Stansifer [44], Wand <ref> [53, 55, 56] </ref>, Jategaonkar-Mitchell [29] and Remy [39]. As evidenced in chapters 3 and 4, the Remy work provided a clear basis for the research in this thesis. The Remy work provided two attractive features in comparison to others: 1.
References-found: 56

