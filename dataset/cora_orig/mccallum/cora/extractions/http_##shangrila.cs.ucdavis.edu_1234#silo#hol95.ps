URL: http://shangrila.cs.ucdavis.edu:1234/silo/hol95.ps
Refering-URL: http://shangrila.cs.ucdavis.edu:1234/silo/
Root-URL: http://www.cs.ucdavis.edu
Email: email: fzhang, beckerb, heckman, levitt, olssong@cs.ucdavis.edu  
Title: A Hierarchical Method for Reasoning about Distributed Programming Languages  
Author: Cui Zhang, Brian R. Becker, Mark R. Heckman Karl Levitt and Ron A. Olsson 
Address: CA 95616  
Affiliation: Department of Computer Science University of California, Davis,  
Abstract: This paper presents a technique for specifying and reasoning about the operational semantics of distributed programming languages. We formalize the concept of "vertical stacking" of distributed systems, an extension of Joyce's, Windley's and Curzon's stacking methodologies for sequential systems and of the CLI "short stack" which stacks interpreters for object code, assembly code, and a high-level sequential language. We use a state transition model to account for the issues of atomicity, con-currency and nondeterminism at all levels in our stack. A correctness definition is given, which for each pair of adjacent language semantics and mappings between them, produces proof obligations corresponding to the correctness of the language implementation. We present an application of the method to a two-level stack: the microSR distributed programming language and a multi-processor instruction set, which is the target language for a compiler for microSR. We also present the development of a verified programming logic for microSR, using the same microSR semantic specification. The HOL system is used for the specifi cation and the proofs.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and L. Lamport, </author> <title> The Existence of Refinement Mappings, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 82, pp.253-284, </volume> <year> 1992. </year>
Reference-contexts: Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions <ref> [1] </ref>. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method. <p> The compiler, including the "translation" of instructions and semantic domains, has to be specified as mappings between the two languages' semantic specifications. Its correctness has to be verified with respect to the pair of semantics. Like most of the work in concurrent program verification <ref> [1, 4, 6, 11] </ref>, our research is based on a state transition model. We claim that distributed programming languages, whether higher-level programming languages, lower-level instruction sets for multi-computer systems, or a network interface wherein processes communicate through the exchange of packets, can be formalized under the state transition model.
Reference: 2. <author> G.R. Andrews and R.A. Olsson, </author> <title> The SR Programming Language: Concurrency in Practice, </title> <publisher> Benjamin/Cummings Publishing Company, Inc. </publisher> <address> Redwood City, CA, </address> <year> 1993. </year>
Reference-contexts: As claimed, our technique works for any stacking of distributed programming languages. In this paper, we apply our methodology to two levels. MicroSR, a derivative of the SR language <ref> [2] </ref>, is used as the higher-level distributed programming language. MP, a multiple processor instruction set architecture, is used as the lower-level implementation language.
Reference: 3. <author> W.R. Bevier, W.A. Hunt, J.S. Moore, and W.D. Young, </author> <title> An approach to systems verification, </title> <journal> Journal of Automated Reasoning, </journal> <month> 5 </month> <year> (1989) </year> <month> 411-428. </month>
Reference-contexts: There has been much research related to our work. CLI's work on the "short stack" has shown the feasibility of full sequential computer system verification using a vertical-layer proof technique <ref> [3] </ref>. Joyce's work has provided a HOL-based method to verify a sequential programming language implementation [10]. Wind-ley has developed a method to specify instruction set architectures and a generic interpreter model for verifying microprocessors by layered proof [13, 14]. <p> Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions [1]. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method. Similar to <ref> [3, 5, 10, 13, 14] </ref>, which provide mechanized methodologies and techniques that work very well for verifying the implementation of sequential languages (or instruction sets) but are not sufficient for distributed language implementation, we focus on the verification of programming language implementation ("compilation" or "translation"), taking a very general view of
Reference: 4. <author> M. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation of Programming Logic. </title> <publisher> Addison-Wesley Publishing Company, Inc. </publisher> <year> 1988. </year>
Reference-contexts: The compiler, including the "translation" of instructions and semantic domains, has to be specified as mappings between the two languages' semantic specifications. Its correctness has to be verified with respect to the pair of semantics. Like most of the work in concurrent program verification <ref> [1, 4, 6, 11] </ref>, our research is based on a state transition model. We claim that distributed programming languages, whether higher-level programming languages, lower-level instruction sets for multi-computer systems, or a network interface wherein processes communicate through the exchange of packets, can be formalized under the state transition model.
Reference: 5. <author> P. Curzon, </author> <title> Deriving Correctness Properties of Compiled Code, in Higher Order Logic Theorem Proving and Its Applications, </title> <journal> pp327-346, IFIP Transactions, </journal> <volume> A-20, </volume> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: Cur-zon's work provides a method to combine a derived programming logic with a ? This work was sponsored by ARPA under contract USN N00014-93-1-1322 with the Office of Naval Research and by the National Security Agency's UR Program. verified compiler for an assembly language <ref> [5] </ref>. von Wright has verified the cor-rectness of refinement rules for developing programs from higher-level specifications into efficient implementations, based on the weakest precondition calculus [12]. <p> Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions [1]. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method. Similar to <ref> [3, 5, 10, 13, 14] </ref>, which provide mechanized methodologies and techniques that work very well for verifying the implementation of sequential languages (or instruction sets) but are not sufficient for distributed language implementation, we focus on the verification of programming language implementation ("compilation" or "translation"), taking a very general view of
Reference: 6. <author> N. Francez, </author> <title> Program Verification, </title> <publisher> Addison-Wesley publishing Company Inc, </publisher> <address> Eng-land, </address> <year> 1992. </year>
Reference-contexts: The compiler, including the "translation" of instructions and semantic domains, has to be specified as mappings between the two languages' semantic specifications. Its correctness has to be verified with respect to the pair of semantics. Like most of the work in concurrent program verification <ref> [1, 4, 6, 11] </ref>, our research is based on a state transition model. We claim that distributed programming languages, whether higher-level programming languages, lower-level instruction sets for multi-computer systems, or a network interface wherein processes communicate through the exchange of packets, can be formalized under the state transition model. <p> The State represents the semantic domain of the language. The other four components in the framework are definitions of relations which are necessary to specify concurrency and nondeterminism. Similar to <ref> [6] </ref>, the Continuation is the relation that formalizes intra-process syntactic continuation, representing the "rest" of the computation that still has to be executed in the process at a given state.
Reference: 7. <author> M. J. C. Gordon.: </author> <title> Mechanizing Programming Logics in Higher Order Logic. In: Current Trends in Hardware Verification and Automated Theorem Proving. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Our technique not only makes the specification of distributed programming languages a step-by-step task, but also eases the verification of the language implementation and the verification of a prover for distributed programs, the latter an extension of Gordon's work <ref> [7] </ref>. As claimed, our technique works for any stacking of distributed programming languages. In this paper, we apply our methodology to two levels. MicroSR, a derivative of the SR language [2], is used as the higher-level distributed programming language.
Reference: 8. <author> M. J. C. Gordon and T. F. Melham, </author> <title> Introduction to HOL: A theorem proving environment for higher order logic, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: The MP machine is also responsible for scheduling the execution of instructions by the various VMachines. At present, this is a very simple scheduler but will be made more realistic in future work. Our work has been performed in HOL <ref> [8] </ref>. In Section 2, we describe our state transition model with support for atomicity, concurrency, and nondeterminism. Section 3 presents our framework, clarifying the definitions that need to be made to specify distributed programming languages in general and how to define them in HOL.
Reference: 9. <author> P. V. Homeier and D. F. Martin, </author> <title> Trusworthy Tool for Trustworthy Programs: A Verified Conditional Generator, in Higher Order Logic Theorem Proving and Its Applications, </title> <publisher> No.859 in LNCS, pp269-284, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: only the abstract syntax and the semantics of the microSR are specified in HOL, but also the abstract syntax of an assertional language is defined by Type Definition in HOL, and substitution, which is the major operation on assertions in the programming logic, is defined recursively on the syntactic structure. <ref> [9] </ref> has shown how to formalize, in HOL, an assertional language and the substitution for a programming logic of a while loop language.
Reference: 10. <author> J.J. Joyce, </author> <title> Totally Verified Systems: Linking verified software to verified hardware. </title> <editor> In M. Leeser and G. Brown, Eds., </editor> <title> Specification, Verification and synthesis: Mathematical Aspects, </title> <publisher> Springer-Verlag, </publisher> <year> 1989 </year>
Reference-contexts: There has been much research related to our work. CLI's work on the "short stack" has shown the feasibility of full sequential computer system verification using a vertical-layer proof technique [3]. Joyce's work has provided a HOL-based method to verify a sequential programming language implementation <ref> [10] </ref>. Wind-ley has developed a method to specify instruction set architectures and a generic interpreter model for verifying microprocessors by layered proof [13, 14]. <p> Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions [1]. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method. Similar to <ref> [3, 5, 10, 13, 14] </ref>, which provide mechanized methodologies and techniques that work very well for verifying the implementation of sequential languages (or instruction sets) but are not sufficient for distributed language implementation, we focus on the verification of programming language implementation ("compilation" or "translation"), taking a very general view of
Reference: 11. <author> A. U. Shankar, </author> <title> An Introduction to Assertional Reasoning for Concurrent Systems, </title> <journal> ACM Computing Surveys, Vol.25, No.3, </journal> <volume> pp225-262, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: The compiler, including the "translation" of instructions and semantic domains, has to be specified as mappings between the two languages' semantic specifications. Its correctness has to be verified with respect to the pair of semantics. Like most of the work in concurrent program verification <ref> [1, 4, 6, 11] </ref>, our research is based on a state transition model. We claim that distributed programming languages, whether higher-level programming languages, lower-level instruction sets for multi-computer systems, or a network interface wherein processes communicate through the exchange of packets, can be formalized under the state transition model.
Reference: 12. <author> J. von Wright, J.Hekanaho, P. Luostarinen and T. Langbacka, </author> <title> Mechanising some Advanced Refinement Concepts, in Higher Order Logic Theorem Proving and Its Applications, </title> <journal> pp307-326, IFIP Transactions, </journal> <volume> A-20, </volume> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: ARPA under contract USN N00014-93-1-1322 with the Office of Naval Research and by the National Security Agency's UR Program. verified compiler for an assembly language [5]. von Wright has verified the cor-rectness of refinement rules for developing programs from higher-level specifications into efficient implementations, based on the weakest precondition calculus <ref> [12] </ref>. Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions [1]. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method.
Reference: 13. <author> P. J. Windley, </author> <title> A theory of generic interpreters, in Correct Hardware Design and Verification Method, No. </title> <booktitle> 683 in LNCS, </booktitle> <address> pp122-134, </address> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Joyce's work has provided a HOL-based method to verify a sequential programming language implementation [10]. Wind-ley has developed a method to specify instruction set architectures and a generic interpreter model for verifying microprocessors by layered proof <ref> [13, 14] </ref>. <p> Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions [1]. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method. Similar to <ref> [3, 5, 10, 13, 14] </ref>, which provide mechanized methodologies and techniques that work very well for verifying the implementation of sequential languages (or instruction sets) but are not sufficient for distributed language implementation, we focus on the verification of programming language implementation ("compilation" or "translation"), taking a very general view of
Reference: 14. <author> P. J. Windley, </author> <title> Specifying Instruction-Set Architectures in HOL: A Primer, in Higher Order Logic Theorem Proving and Its Applications, </title> <publisher> No.859 in LNCS, pp440-455, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Joyce's work has provided a HOL-based method to verify a sequential programming language implementation [10]. Wind-ley has developed a method to specify instruction set architectures and a generic interpreter model for verifying microprocessors by layered proof <ref> [13, 14] </ref>. <p> Abadi and Lamport's work has shown a theoretical completeness result on the existence of a refinement mapping when one system specification implements another, under reasonable assumptions [1]. These works provide us with insights into the specification of semantics and the verification of implementations, using a compositional method. Similar to <ref> [3, 5, 10, 13, 14] </ref>, which provide mechanized methodologies and techniques that work very well for verifying the implementation of sequential languages (or instruction sets) but are not sufficient for distributed language implementation, we focus on the verification of programming language implementation ("compilation" or "translation"), taking a very general view of
Reference: 15. <author> C. Zhang, R. Shaw, R. Olsson, K. Levitt, M. Archer, M.Heckman, and G. Benson, </author> <title> Mechanizing a Programming Logic for the Concurrent Programming Language microSR in HOL, in Higher Order Logic Theorem Proving and Its Applications, </title> <publisher> No.780 in LNCS, pp31-44, Springer-Verlag, </publisher> <year> 1994. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: All axioms and inference rules in the logic are formally proved as theorems in HOL. Compared with our early exercise on mechanizing a smaller programming logic for an early version of microSR in HOL <ref> [15] </ref>, this work differs mainly in the following aspects, besides the enhancements to both the language and the mechanized programming logic. Reflecting our new framework, concurrency and nondeterminism have been completely handled in the semantic specification for microSR, of which the mechanized programming logic is the logical implication.
References-found: 15

