URL: ftp://ftp.cs.brown.edu/pub/techreports/89/cs89-19.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-89-19.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [Alb85] <author> Antonio Albano, Luca Cardelli, and Renzo Orsini. </author> <title> Galileo: A Strongly-Typed, Interactive Conceptual Language. </title> <journal> Communications of the ACM, </journal> <volume> 10(2) </volume> <pages> 230-260, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Early extensions relaxed the first normal form requirement of the relational model, allowing set-valued attributes ([Jae82], [Dad86]). The relational model has also been extended with abstract data types ([Row87], [Mai87], [Ban87a], <ref> [Alb85] </ref>) allowing the modelling of more complex types, where components or attributes of objects can be other database objects. We extend the relational data model similarly, and also succeed in applying relational types of algebraic operations to the model. <p> Osborn notes [Osb88] that the creation of new objects means that responses to a query cannot be identical. We propose new definitions for query equivalence that consider data as well as identifier equality (see Section 7). Many object-oriented database systems (e.g. [Mai87], <ref> [Alb85] </ref>, [Ban88]) only support selection of objects already existing in the database. We recognize that many relationships requested by queries will exist in the database objects, but also feel that existing objects in the database may not necessarily reflect all relationships requested by a query.
Reference: [Ban87a] <author> Francois Bancilhon et al. </author> <title> FAD, a Powerful and Simple Database Language. </title> <booktitle> In Proceedings of the 13th VLDB Conference, </booktitle> <pages> pages 97-105, </pages> <year> 1987. </year>
Reference-contexts: Such databases attempt to combine the modelling power of object-based programming models with traditional database concepts such as persistence, data sharing, consistency, resiliency and optimized query access. A number of object-oriented data models and languages have been proposed ([Shi81], <ref> [Ban87a] </ref>, [Ban87b], [Row87], [Mai87], [Lec88], [Car88]), but no single model or language has emerged as a standard for object-oriented databases. Our model supports object identity, abstract data types with 1 type inheritance, and encapsulation of behavior and state, as modelling ca-pabilities present in most object-oriented systems. <p> Unlike other languages proposed for object-oriented databases (e.g. [Zan83], [Car88], [Osb88], <ref> [Ban87a] </ref>, [Ban88], [Mai87]) we support all of these concepts and still provide full associative access to the database, including a unique join capability. <p> Early extensions relaxed the first normal form requirement of the relational model, allowing set-valued attributes ([Jae82], [Dad86]). The relational model has also been extended with abstract data types ([Row87], [Mai87], <ref> [Ban87a] </ref>, [Alb85]) allowing the modelling of more complex types, where components or attributes of objects can be other database objects. We extend the relational data model similarly, and also succeed in applying relational types of algebraic operations to the model. <p> Most systems make the distinction between data equality and identifier equality by providing operators testing identity, deep equality and, possibly, shallow equality (e.g. <ref> [Ban87a] </ref>, [Lec88], [Osb88], [Car88]). Two objects are identical when they are the same object, shallow equal when they have the same value, and deep equal when they have the same type and a recursive traversal of the objects eventually finds identical values (see [Kho86]). <p> A major aspect in the development of query languages is the potential for optimization. Query algebras can support optimization through syntactic transformations (e.g., [Osb88], <ref> [Ban87a] </ref>). However, the implementation of abstract data types involves the introduction of new operations, making optimization more complicated [Zdo89]. Syntactic transformations are not sufficient for such systems, and may need to be combined with optimization strategies for encapsulated behaviors (see [Gra88] for example).
Reference: [Ban87b] <author> Jay Banerjee et al. </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year> <month> 25 </month>
Reference-contexts: Such databases attempt to combine the modelling power of object-based programming models with traditional database concepts such as persistence, data sharing, consistency, resiliency and optimized query access. A number of object-oriented data models and languages have been proposed ([Shi81], [Ban87a], <ref> [Ban87b] </ref>, [Row87], [Mai87], [Lec88], [Car88]), but no single model or language has emerged as a standard for object-oriented databases. Our model supports object identity, abstract data types with 1 type inheritance, and encapsulation of behavior and state, as modelling ca-pabilities present in most object-oriented systems.
Reference: [Ban88] <author> Jay Banerjee, Won Kim, and Kyung-Chang Kim. </author> <title> Queries in Object-Oriented Databases. </title> <booktitle> In Proceedings 4th Intl. Conf. on Data Engineering, </booktitle> <pages> pages 31-38. </pages> <publisher> IEEE, </publisher> <month> Feb </month> <year> 1988. </year>
Reference-contexts: Unlike other languages proposed for object-oriented databases (e.g. [Zan83], [Car88], [Osb88], [Ban87a], <ref> [Ban88] </ref>, [Mai87]) we support all of these concepts and still provide full associative access to the database, including a unique join capability. <p> Osborn notes [Osb88] that the creation of new objects means that responses to a query cannot be identical. We propose new definitions for query equivalence that consider data as well as identifier equality (see Section 7). Many object-oriented database systems (e.g. [Mai87], [Alb85], <ref> [Ban88] </ref>) only support selection of objects already existing in the database. We recognize that many relationships requested by queries will exist in the database objects, but also feel that existing objects in the database may not necessarily reflect all relationships requested by a query.
Reference: [Car88] <author> Michael J. Carey, David J. DeWitt, and Scott L. </author> <note> Vandenberg. </note>
Reference-contexts: Such databases attempt to combine the modelling power of object-based programming models with traditional database concepts such as persistence, data sharing, consistency, resiliency and optimized query access. A number of object-oriented data models and languages have been proposed ([Shi81], [Ban87a], [Ban87b], [Row87], [Mai87], [Lec88], <ref> [Car88] </ref>), but no single model or language has emerged as a standard for object-oriented databases. Our model supports object identity, abstract data types with 1 type inheritance, and encapsulation of behavior and state, as modelling ca-pabilities present in most object-oriented systems. <p> Unlike other languages proposed for object-oriented databases (e.g. [Zan83], <ref> [Car88] </ref>, [Osb88], [Ban87a], [Ban88], [Mai87]) we support all of these concepts and still provide full associative access to the database, including a unique join capability. <p> We also assume that the collections of stored objects are supported by, but separate from, the type structure. This model is most similar to the models of GemStone [Mai87] and EXODUS <ref> [Car88] </ref>, although our algebra is more general than the former and our approach to the operations and object identity differs from that of the latter. We consider the type of every object to be an abstract data type. <p> Most systems make the distinction between data equality and identifier equality by providing operators testing identity, deep equality and, possibly, shallow equality (e.g. [Ban87a], [Lec88], [Osb88], <ref> [Car88] </ref>). Two objects are identical when they are the same object, shallow equal when they have the same value, and deep equal when they have the same type and a recursive traversal of the objects eventually finds identical values (see [Kho86]). <p> These tuples are complex objects with well-defined types and unique identities. The creation of these tuples as statically-typed objects is supported by the existence of parameterized types in the data model. Our algebra can simulate the join of the Excess query language <ref> [Car88] </ref> and the unnest join of Korth [Kor88], but not the Combine operation of Osborn [Osb88] since it does not necessarily maintain the integrity of abstract data types. A major aspect in the development of query languages is the potential for optimization.
References-found: 5

