URL: ftp://theory.lcs.mit.edu/pub/people/oded/gmw2.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/gmw.html
Root-URL: 
Title: How to Solve any Protocol Problem words, participating in the protocol is equivalent to getting
Author: by Oded Goldreich, Silvio Micali and Avi Wigderson. 
Note: In other  his counterparts.  
Abstract: Remark: A version identical in contents, but very different in form has appeared in the proceedings of the 19th STOC, pp. 218-229, 1987. This version was produced, from an old draft (dating to 1986), by automatic convertion of a old troff file into a latex file. The output was not carefully checked; hopefully, it does not contain too many typos. ABSTRACT: This extended abstract present a general theorem in the field of fault tolerant distributed computing. Following is a simplified description of a special case of this theorem. Loosely speaking, a protocol problem is a multi-argument function f and its solution is a multi-party fault-tolerant protocol having the following two properties: (1) Correctness: The protocol allows each party to obtain the value of the function on arguments scattered among all the parties. Namely, the local input of party P i is x i , and his local output (obtained by execution of the protocol) is f (x 1 ; x 2 ; :::; x n ). (2) Privacy: Whatever a party (P i ) can efficiently compute after participating in the protocol, he can also efficiently compute from his local input (x i ) and his local output (i.e. f (x 1 ; x 2 ; :::; x n )). Assuming the existence of secure encryption functions, it will be shown that every protocol problem has a solution with complexity polynomial in the complexity of the problem. Furthermore, we present an efficient algorithm that, on input a Turing machine description of a function, outputs an efficient solution for this problem. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar] <author> Barrington, D.A., </author> <title> "Bounded-Width Polynomial-Size Branching Programs Recognize Exactly Those Languages in N C 1 ", Proc. </title> <booktitle> 18th STOC, </booktitle> <year> 1986, </year> <pages> pp. 1-5. </pages>
Reference-contexts: Without loss of generality, we assume that this circuit has maximum fanin 2, and contains only AN D and N OT gates. Our original construction made use of Barrington's result <ref> [Bar] </ref> that Boolean circuits can be simulated by straightline programs in permutation groups. The construction was carried out on such straightline programs. Instead, using ideas of Stuart Haber, we present here a simpler construction which views Boolean circuits as straightline programs over GF (2).
Reference: [Blu] <author> Blum, M., </author> <title> "Coin Flipping by Phone", </title> <booktitle> IEEE Spring COMPCOM, </booktitle> <pages> pp. 133-137, </pages> <month> February </month> <year> 1982. </year>
Reference: [BD] <author> Broder, A.Z., and D. Dolev, </author> <title> "Flipping Coins in Many Pockets (Byzantine Agreement on Uniformly Random Values", </title> <booktitle> Proc. 25th FOCS, </booktitle> <year> 1984, </year> <pages> pp. 157-170. </pages>
Reference: [CGMA] <author> Chor, B., S. Goldwasser, S. Micali, and B. Awerbuch, </author> <title> "Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults", </title> <booktitle> Proc. 26th FOCS, </booktitle> <year> 1985, </year> <pages> pp. 383-395. </pages>
Reference-contexts: Such parties have only the choice to either participat in the protocol or not participat and be detected as faulty parties. This choice has to be made without any knowledge of the local inputs of non-faulty parties. Using the notion of verifiable secret sharing <ref> [CGMA] </ref>, it is easy to present a correct fault-tolerant protocol for computing the sum function. Let each party verifiably share his input with all other parties, and next (if this phase is completed to the satisfaction of all parties) let each party broadcast his input. <p> Other essential ingredients are the notions of verifiable secret sharing and simultaneous broadcast proposed and first implemented by Chor, Goldwasser, Micali and Awerbuch <ref> [CGMA] </ref>. 2. How to Generate Maximum Privacy Protocols for Semi-Honest Parties Given a Turing Machine program and its inputs, we can easily constract an functionally equivalent polynomial-size Boolean circuit. <p> But in such a case, they do so obliviously of the private inputs of the non-faulty parties, and furthermore they will be detected. The notion of a verifiable secret sharing, presented by Chor, Goldwasser, Micali and Awerbuch <ref> [CGMA] </ref>, plays a central role in phase one of our protocols. Loosely speaking, a verifiable secret sharing is a n + 1-party protocol through which a sender (S) can distribute to the receivers (R i 's) pieces of a secret s recognizable through an a-priori known "encryption" g (s). <p> The certified random input is generated using a distributive coin flip protocol. Such a protocol is easily constructable using the abstraction of simultanous broadcast (see Chor, Goldwasser, Micali and Awerbuch <ref> [CGMA] </ref>). As long as a majority of the processors are non-faulty, the string generated so are guaranteed to be indistinguishable from truely random strings. Implementing simultanous broadcast was reduced to verifiable secret sharing in [CGMA]. <p> protocol is easily constructable using the abstraction of simultanous broadcast (see Chor, Goldwasser, Micali and Awerbuch <ref> [CGMA] </ref>). As long as a majority of the processors are non-faulty, the string generated so are guaranteed to be indistinguishable from truely random strings. Implementing simultanous broadcast was reduced to verifiable secret sharing in [CGMA]. The second phase of the compiled protocol consists of a "certified simulation" of the original protocol. Note that the messages sent in the original protocol are computed in polynomial-time when given the private and random inputs of their sender and all the messages he has received.
Reference: [Coh] <author> Cohen, J.D., </author> <title> "Secret Sharing Homomorphisms: Keeping Shares of a Secret Secret", </title> <type> technical report YALEU/DCS/TR-453, </type> <institution> Yale University, Dept. of Computer Science, </institution> <month> Feb. </month> <year> 1986. </year> <note> Presented in Crypto86, </note> <year> 1986. </year>
Reference-contexts: The inputs of parties which did not broacast properly are revealed by the honest share holders. However, this protocol does not offer any privacy. A correct fault-tolerant protocol which offers the maximum degree of privacy allowed by the sum function was recently presented by Cohen <ref> [Coh] </ref>. <p> P i2N x i ). Equivalently, all they learnt about the local inputs of the other processors is their sum P i2N x i , and this of course can not be avoided. The ideas suggested by Cohen <ref> [Coh] </ref> do not extend to any other function (except multiplication), since they heavily rely on the homomorphism of the secret sharing scheme with respect to the function f .
Reference: [DH] <author> Diffie, W., and M.E. Hellman, </author> <title> "New Directions in Cryptography", </title> <journal> IEEE Trans. on Inform. Theory, </journal> <volume> Vol. IT-22, No. 6, </volume> <month> November </month> <year> 1976, </year> <pages> pp. 644-654. </pages>
Reference: [EGL] <author> Even, S., O. Goldreich, and A. Lempel, </author> <title> "A Randomized Protocol for Signing Contracts", </title> <journal> CACM, </journal> <volume> Vol. 28, No. 6, </volume> <year> 1985, </year> <pages> pp. 637-647. </pages>
Reference-contexts: In fact, using a new "Oblivious Transfer" protocol (which in turn uses ideas from <ref> [EGL] </ref>), a protocol satisfying the above conditions exists under more general condition: the existence of trapdoor encryption functions. The proof that the above n party protocol offers the maximum possible privacy, is omitted from this extended abstract. 3.
Reference: [GMW] <author> Goldreich, O., S. Micali, and A. Wigderson, </author> <title> "Proofs that Yield Nothing But their Validity and a Methodology of Cryptographic Protocol Design", </title> <booktitle> Proc. 27th FOCS, </booktitle> <year> 1986, </year> <pages> pp. 174-187. </pages>
Reference-contexts: The second step of our construction makes primary use of the result that all NP languages have zero-knowledge interactive proofs and that the prover in these interactions may be a probabilistic polynomial-time machine which gets a "witness for membership" as an auxiliary input <ref> [GMW] </ref>. Other essential ingredients are the notions of verifiable secret sharing and simultaneous broadcast proposed and first implemented by Chor, Goldwasser, Micali and Awerbuch [CGMA]. 2. <p> Assuming the existence of arbitrary one-way permutations, a conceptually simple solution allowing u = l + 1 n was presented in <ref> [GMW] </ref>. During the first phase of the compiled protocol each party will generate a "certified random input" and will use verifiable secret sharing with a threshold of n=2 to share both his private input and his certified random input. <p> Note that the messages sent in the original protocol are computed in polynomial-time when given the private and random inputs of their sender and all the messages he has received. Using the result in <ref> [GMW] </ref>, the sender can prove in zero-knowledge that the message he sends was properly computed. The proof that the compiled protocol preserves the correctness and privacy of the original protocol, is omitted from this extended abstract. 4.
Reference: [GM] <author> Goldwasser, S., and S. Micali, </author> <title> "Probabilistic Encryption", </title> <journal> JCSS, </journal> <volume> Vol. 28, No. 2, </volume> <year> 1984, </year> <pages> pp. 270-299. </pages>
Reference: [GMR] <author> Goldwasser, S., S. Micali, and C. Rackoff, </author> <title> "Knowledge Complexity of Interactive Proofs", </title> <booktitle> Proc. 17th STOC, </booktitle> <year> 1985, </year> <pages> pp. 291-304. </pages>
Reference: [R] <author> Rabin, M.O., </author> <title> "How to Exchange Secrets by Oblivious Transfer", </title> <type> unpublished manuscript, </type> <year> 1981. </year>
Reference: [Y1] <author> Yao, </author> <title> A.C., "Theory and Applications of Trapdoor Functions", </title> <booktitle> Proc. of the 23rd IEEE Symp. on Foundation of Computer Science, </booktitle> <year> 1982, </year> <pages> pp. 80-91. </pages>
Reference: [Y2] <author> Yao, </author> <title> A.C., "How to Generate and Exchange Secrets", </title> <booktitle> Proc. 27th FOCS, </booktitle> <year> 1986, </year> <pages> pp. 162-167. </pages>
Reference-contexts: The core of the first step of our construction is a method for computing through a Boolean circuit, while manipulating the intermediate values distributively in a secret sharing manner. An important ingredient in this method is a generalization of a Theorem due to Yao <ref> [Y2] </ref>. This generalization states that, for every polynomial-time computable function f , there exist a two-party cryptographic protocol for correctly computing f in a manner which offers the maximum degree of privacy allowed by f , as long as the parties are semi-honest. <p> Note that ( i=1 n X d j ) = ( i=1 X (c i d j + c j d i ) = i=1 j=1 Assuming that factoring is intractable, a protocol satisfying the above three conditions is implicit in Yao's work <ref> [Y2] </ref>. In fact, using a new "Oblivious Transfer" protocol (which in turn uses ideas from [EGL]), a protocol satisfying the above conditions exists under more general condition: the existence of trapdoor encryption functions.
References-found: 13

