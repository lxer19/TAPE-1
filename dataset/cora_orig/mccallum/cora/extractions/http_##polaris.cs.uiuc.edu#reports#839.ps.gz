URL: http://polaris.cs.uiuc.edu/reports/839.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: Event Synchronization Analysis for Debugging Parallel Programs  
Author: Perry A. Emrath Sanjoy Ghosh David A. Padua 
Keyword: [Keywords: Debugging, Nondeterminacy, Parallel Programming, Parallel Processing, Race Detection, Software Tools, Synchronization]  
Address: Street Urbana, Illinois 61801  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign 305 Talbot Laboratory 104 South Wright  
Abstract: This paper discusses this problem and presents a method for automatically detecting non-determinacy in parallel programs that utilize event style synchronization instructions, using the Post, Wait, and Clear primitives. With event style synchronization, especially when there are many references to the same event, the difficulty lies in computing the execution order that is guaranteed given the synchronization instructions and the sequential components of the program. The main result in this paper is an algorithm that computes such an execution order and yields a Task Graph upon which a nondeterminacy detection algorithm can be applied. We have focused on events because they are a frequently used synchronization mechanism in parallel versions of Fortran, including Cray [Cray87], IBM [IBM88], Cedar [GPHL88], and PCF Fortran [PCF88]. fl This work was supported in part by the National Science Foundation under Grant No. US NSF MIP84-10110, the US Department of Energy under Grant No. US DOE DE FG02-85ER25001, and a donation from the IBM Corporation, and Concurrent Computer Corporation. 
Abstract-found: 1
Intro-found: 1
Reference: [Alli85] <institution> FX/Series Architecture Manual Concur-rency Supplement, Alliant Computer Systems Corp., </institution> <month> April </month> <year> 1985. </year>
Reference-contexts: The parallel construct in this program is the cdoacross loop in which the iterations are ex-ecuted in parallel, and cascade synchronization, from lower to higher iterations, is allowed. This synchronization may be achieved by means of the advance () and await () <ref> [Alli85] </ref> instructions. Advance (x) waits until the value of x is equal to the current iteration count and then increments x by 1. Await (x,y) waits until the value of x plus the value of y is greater than or equal to the current iteration count.
Reference: [AlPa87] <author> Todd R. Allen, and David A. Padua. </author> <title> Debugging Fortran on a Shared Memory Machine, </title> <booktitle> Proceedings of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pp. 721-727, </pages> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: This paper is a report on a continuing research effort at the University of Illinois <ref> [AlPa87] </ref>, [EmPa88], the goal of which is to develop a debugging tool for use on programs originally written as parallel programs 3 . The tool is intended to detect race conditions through a combination of static (compile-time) and trace (run-time) analysis. <p> Instead of deluging the user with that many messages, the races could be "folded" into one message and the race between adjacent iterations of the cdoall presented in a compact fashion. A race may cause other races to either manifest themselves or not, in a random manner. <ref> [AlPa87] </ref> defines the "hides" relationship between races. Two races are related by the "hides" relation if the outcome of the first can affect the occurrence of the second.
Reference: [Bane88] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: In many cases it is possible to detect races by static analysis alone, which resembles analysis for data dependences <ref> [Bane88] </ref>. Statements that execute in parallel and access the same location are identified. If there is no guaranteed ordering between two or more of these instances, of which at least one is a write, then a race has been detected [EmPa88]. <p> In cases similar to that of Program 1 above, complete compile-time detection of nondeterminacy is easy. In more complicated cases involving loops and arrays, subscript analysis <ref> [Bane88] </ref> might be necessary. Analogously to situations where dependence analysis fails to give a definite dependence relation between two statement instances 4 , static analysis for race detection may fail to give a definite answer.
Reference: [CaSu88] <author> David Callahan, and Jaspal Subhlok. </author> <title> Static Analysis of Low-level Synchronization, </title> <booktitle> Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 100-111, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: With no path, the execution order of the two references is not guaranteed. Any races that are found are reported to the user. 7 Related Work Other groups have also studied the problem discussed in this paper. In <ref> [CaSu88] </ref> a data flow formulation is presented for race detection by static analysis. This formulation does not deal with loops. The principal synchronization primitive considered is the event, which is one of the two primitives we handle. However, they do not handle the Clear operation.
Reference: [Cray87] <institution> Cray X-MP Multitasking Programmer's Reference Manual, Cray Research, Inc., </institution> <year> 1987. </year>
Reference: [EmPa88] <author> Perry A. Emrath, and David A. Padua. </author> <title> Automatic Detection of Nondeterminacy in Parallel Programs, </title> <booktitle> Proceedings, Work--shop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 89-99, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: This paper is a report on a continuing research effort at the University of Illinois [AlPa87], <ref> [EmPa88] </ref>, the goal of which is to develop a debugging tool for use on programs originally written as parallel programs 3 . The tool is intended to detect race conditions through a combination of static (compile-time) and trace (run-time) analysis. <p> Statements that execute in parallel and access the same location are identified. If there is no guaranteed ordering between two or more of these instances, of which at least one is a write, then a race has been detected <ref> [EmPa88] </ref>. In cases similar to that of Program 1 above, complete compile-time detection of nondeterminacy is easy. In more complicated cases involving loops and arrays, subscript analysis [Bane88] might be necessary.
Reference: [GPHL88] <author> M. D. Guzzi, D. A. Padua, J. P. Hoe-flinger, and D. H. Lawrie. </author> <title> Cedar Fortran and Other Vector and Parallel Fortran Dialects, </title> <booktitle> Proceedings SUPERCOMPUTING '88, </booktitle> <pages> pp. 114-121, </pages> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: The tool is intended to detect race conditions through a combination of static (compile-time) and trace (run-time) analysis. Communication between asynchronous tasks takes place through a shared address space and by the use of explicit synchronization instructions. The current implementation is designed for use with Cedar Fortran <ref> [GPHL88] </ref>, a Fortran dialect that runs on the Cedar multiprocessor [KDLS86] under development at the University of Illinois. However, the approach described is applicable to languages other than Cedar Fortran. 2 Race Detection We describe our approach to the detection of races using a combination of static and trace analysis. <p> The information contained in the log file includes the operation performed, task number, program line number, value of the variable, address, etc. Cedar Fortran has several ways to achieve parallel execution. One way is to use the ctskstart () and ctskwait () instructions <ref> [GPHL88] </ref>. The instruction tskid = ctskstart (subr) spawns a new task to execute subroutine subr and returns an integer to identify it in tskid. Call ctskwait (tskid) suspends the calling task until the task whose identifier is tskid completes execution.
Reference: [IBM88] <institution> IBM Parallel FORTRAN Language and Library Reference, IBM Corp., </institution> <month> March </month> <year> 1988. </year>
Reference: [KDLS86] <author> D. Kuck, E. Davidson, D. Lawrie, and A. Sameh. </author> <title> Parallel supercomputing today and the Cedar approach, </title> <journal> Science, </journal> <volume> vol. 231, </volume> <pages> pp. 967-974, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Communication between asynchronous tasks takes place through a shared address space and by the use of explicit synchronization instructions. The current implementation is designed for use with Cedar Fortran [GPHL88], a Fortran dialect that runs on the Cedar multiprocessor <ref> [KDLS86] </ref> under development at the University of Illinois. However, the approach described is applicable to languages other than Cedar Fortran. 2 Race Detection We describe our approach to the detection of races using a combination of static and trace analysis.
Reference: [MiCh88] <author> Barton P. Miller, </author> <title> and Jong-Deok Choi. </title>
Reference-contexts: In [CaSu88] a data flow formulation is presented for race detection by static analysis. This formulation does not deal with loops. The principal synchronization primitive considered is the event, which is one of the two primitives we handle. However, they do not handle the Clear operation. In <ref> [MiCh88] </ref> a system is described that aids the user in debugging parallel programs. While the paper discusses synchronization edges and their use in detecting races, it does not describe any procedure to compute these edges. We feel that this is the main contribution of our paper.
References-found: 10

