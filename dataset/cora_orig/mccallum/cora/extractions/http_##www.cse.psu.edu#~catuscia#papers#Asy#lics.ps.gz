URL: http://www.cse.psu.edu/~catuscia/papers/Asy/lics.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/references.html
Root-URL: http://www.cse.psu.edu
Title: Asynchronous Communication in Process Algebra (Extended Abstract)  
Author: Frank S. de Boer Jan Willem Klop yz Catuscia Palamidessi yx 
Abstract: We study the paradigm of asynchronous process communication, as contrasted with the synchronous communication mechanism which is present in process algebra frameworks such as CCS, CSP and ACP. We investigate semantics and axiomatizations with respect to various observability criteria: bisimulation, traces and abstract traces. Our aim is to develop a process theory which can be regarded as a kernel for languages based on asynchronous communication, like data flow, concurrent logic languages and concurrent constraint programming. 
Abstract-found: 1
Intro-found: 1
Reference: [BHR84] <author> S.D. Brookes, C.A.R. Hoare, and W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of ACM, </journal> <volume> 31 </volume> <pages> 499-560, </pages> <year> 1984. </year>
Reference: [BK86] <author> J.A. Bergstra and J.W. Klop. </author> <title> Process algebra: specification and verification in bisimulation semantics. </title> <booktitle> In Mathematics and Computer Science II, CWI Monographs, </booktitle> <pages> pp. 61 - 94. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference: [BKO88] <author> J.A. Bergstra, J.W. Klop, and E.-R. Olderog. </author> <title> Readies and failures in the algebra of communicating processes. </title> <journal> SIAM J. on Computing, </journal> <volume> 17(6):1134 - 1177, </volume> <year> 1988. </year>
Reference-contexts: relation j T as the maximal trace-respecting congruence, i.e. x j T y iff 8C [ ]: C [x] T C [y]: In the rest of this section we will investigate a concrete model corresponding to this congru ence, and its axiomatization. 3.1 Failure semantics It has been shown in <ref> [BKO88] </ref> that in the synchronous case of ACP with one-to-one communication failure semantics ([BHR84]) is fully abstract with respect to trace equivalence. We will show how to modify it so that this property is maintained. <p> semantics has been obtained by adding to the theory of ACP the ready axioms and the failure axiom (<ref> [BKO88] </ref>) which, restricted to the case of aprPA ffi , are respectively the axioms R and S in Table 3. Our failure semantics is at least as abstract as that semantics in [BKO88], in fact it can be retrieved by considering (only) those pairs in which the refusal set contains all independent actions. Therefore the axioms R and S are valid in our semantics. <p> communication (<ref> [BKO88] </ref>) are, of course, still valid in our asynchronous case. Restricted to the case of action prefixing only (i.e. no general sequential composition) these axioms are the ones shown in Table 4. Note that the presence of T1 and T2 makes the axiom S of Table 3 superfluous (cf. [BKO88]). However, these axioms for o -abstraction are not complete in the presence of independent actions. When o is prefixed to an independent action i, it can be deleted. Formally, this is captured by the axiom in Table 5.
Reference: [BKPR91] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> The failure of failures: Towards a paradigm for asynchronous communication. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proc. of CONCUR 91, </booktitle> <volume> LNCS 527, </volume> <pages> pp. 111 - 126. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In fact, recent studies have shown that several languages based on asynchronous communication have linear models: see for instance [Jon85, Jos90] for data flow, [BP90] for concurrent logic languages, [BP91] for concurrent constraint programming and <ref> [BKPR91] </ref> for a general semantic framework based on reactive sequences. The explanation of this apparent contradiction is that also these last models encode some hidden refusal information.
Reference: [BKT85] <author> J.A. Bergstra, J.W. Klop, and J.V. Tucker. </author> <title> Process algebra with asynchronous communication mechanisms. In S.D. </title> <editor> Brookes, A.W. Roscoe, and G. Winskel, editors, </editor> <booktitle> Proc. Seminar on Concurrency, </booktitle> <volume> LNCS 197, </volume> <pages> pp. 76 - 95. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In this paper we have opted for a model in which the refusals are explicitly represented because it facilitates the proof of the completeness of the axiomatization. 2 Bisimulation semantics for asynchronous communication In this section, that is the basis of our paper, our starting point is <ref> [BKT85] </ref>. <p> Examples of bisimilar processes are the pairs (i), (ii) and (v) in Figure 4. 2.3 Axioms The bisimulation equivalence $ is a congruence and it is completely axiomatized by the system aprPA ffi; in Table 2, which is the one from <ref> [BKT85] </ref> restricted to action prefixing. In our paper we don't consider sequential composition, just for reasons of technical convenience.
Reference: [BP90] <author> F.S. de Boer and C. Palamidessi. </author> <title> Concurrent logic languages: Asynchronism and language comparison. </title> <booktitle> In Proc. of the North American Conference on Logic Programming, </booktitle> <pages> pp. 175-194. </pages> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In fact, recent studies have shown that several languages based on asynchronous communication have linear models: see for instance [Jon85, Jos90] for data flow, <ref> [BP90] </ref> for concurrent logic languages, [BP91] for concurrent constraint programming and [BKPR91] for a general semantic framework based on reactive sequences. The explanation of this apparent contradiction is that also these last models encode some hidden refusal information.
Reference: [BP91] <author> F.S. de Boer and C. Palamidessi. </author> <title> A fully abstract model for Concurrent Constraint Programming. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proc. of TAP-SOFT/CAAP, </booktitle> <volume> LNCS 493, </volume> <pages> pp. 296-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In fact, recent studies have shown that several languages based on asynchronous communication have linear models: see for instance [Jon85, Jos90] for data flow, [BP90] for concurrent logic languages, <ref> [BP91] </ref> for concurrent constraint programming and [BKPR91] for a general semantic framework based on reactive sequences. The explanation of this apparent contradiction is that also these last models encode some hidden refusal information.
Reference: [vGla90] <author> R.J. </author> <title> van Glabbeek The linear time branching time spectrum. </title> <editor> In J.C.M. Baeten and J.W. Klop, editors, </editor> <booktitle> Proc. of CONCUR 90, </booktitle> <volume> LNCS 458, </volume> <pages> pp. 278 - 297. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Note that if we generalize i in the axiom I to be any action we obtain a system equivalent to the one presented in <ref> [vGla90] </ref> as the axiomatization of (completed) trace semantics for aprPA ffi .
Reference: [Jon85] <author> B. Jonsson. </author> <title> A model and a proof system for asynchronous processes. </title> <booktitle> In Proc. of the 4th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 49-58, </pages> <year> 1985. </year>
Reference-contexts: In fact, recent studies have shown that several languages based on asynchronous communication have linear models: see for instance <ref> [Jon85, Jos90] </ref> for data flow, [BP90] for concurrent logic languages, [BP91] for concurrent constraint programming and [BKPR91] for a general semantic framework based on reactive sequences. The explanation of this apparent contradiction is that also these last models encode some hidden refusal information.
Reference: [Jos90] <author> M.B. Josephs. </author> <title> Receptive process theory. </title> <type> Tech. rep. CS 90/8, </type> <institution> Eindhoven University of Technology, </institution> <year> 1990. </year> <note> To appear in Acta Informatica. </note>
Reference-contexts: In fact, recent studies have shown that several languages based on asynchronous communication have linear models: see for instance <ref> [Jon85, Jos90] </ref> for data flow, [BP90] for concurrent logic languages, [BP91] for concurrent constraint programming and [BKPR91] for a general semantic framework based on reactive sequences. The explanation of this apparent contradiction is that also these last models encode some hidden refusal information.
Reference: [JHJ90] <author> M.B. Josephs, </author> <title> C.A.R. Hoare, and He Jifeng. A theory of asynchronous processes. </title> <type> Tech. rep., </type> <institution> Oxford University Computing Laboratories, </institution> <year> 1990. </year>
Reference-contexts: A priori this was to be expected since a bag in itself is already an `abstraction' of a queue. 1.1 Comparison with related work A theory for asynchronous communication has also been developed in <ref> [JHJ90] </ref>. That theory is more abstract than ours; the main reasons are that in [JHJ90] there are, first, some restrictions on processes to be composed in parallel, and, second, communication is modeled in such a way that when a process receives an item from a buffer, that item remains available for <p> A priori this was to be expected since a bag in itself is already an `abstraction' of a queue. 1.1 Comparison with related work A theory for asynchronous communication has also been developed in <ref> [JHJ90] </ref>. That theory is more abstract than ours; the main reasons are that in [JHJ90] there are, first, some restrictions on processes to be composed in parallel, and, second, communication is modeled in such a way that when a process receives an item from a buffer, that item remains available for the other processes. <p> Such a mechanism can be implemented in our language by means of a copying process; therefore all the contexts which can be specified in <ref> [JHJ90] </ref> can be specified also in our language. On the other hand, some of our contexts cannot be defined in [JHJ90] (i.e. our congruence is strictly less coarse). <p> Such a mechanism can be implemented in our language by means of a copying process; therefore all the contexts which can be specified in <ref> [JHJ90] </ref> can be specified also in our language. On the other hand, some of our contexts cannot be defined in [JHJ90] (i.e. our congruence is strictly less coarse). The relatively `low degree of abstraction' of our language has the advantage that we can regard it as a kernel for the axiomatization of other languages based on asynchronous communication.
Reference: [Kah74] <author> G. Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <booktitle> In Information Processing 74: Proc. of IFIP Congress, </booktitle> <pages> pages 471-475, </pages> <address> New York, 1974. </address> <publisher> North-Holland. </publisher>
Reference-contexts: It is possible to show, in fact, that with respect to both observability criteria we have considered in this paper our axioms are correct for data flow <ref> [Kah74] </ref>, concurrent logic programming [Sha89], and concurrent constraint programming [Sar89]. In other words, the communication mechanisms of those languages can be implemented in ours. Completeness can then be obtained by adding some specific axioms.
Reference: [Sar89] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1989. </year> <note> To be published by The MIT Press. </note>
Reference-contexts: It is possible to show, in fact, that with respect to both observability criteria we have considered in this paper our axioms are correct for data flow [Kah74], concurrent logic programming [Sha89], and concurrent constraint programming <ref> [Sar89] </ref>. In other words, the communication mechanisms of those languages can be implemented in ours. Completeness can then be obtained by adding some specific axioms.
Reference: [Sha89] <author> E.Y. Shapiro. </author> <title> The family of Concurrent Logic Programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 412-510, </pages> <year> 1989. </year> <month> 17 </month>
Reference-contexts: It is possible to show, in fact, that with respect to both observability criteria we have considered in this paper our axioms are correct for data flow [Kah74], concurrent logic programming <ref> [Sha89] </ref>, and concurrent constraint programming [Sar89]. In other words, the communication mechanisms of those languages can be implemented in ours. Completeness can then be obtained by adding some specific axioms.
References-found: 14

