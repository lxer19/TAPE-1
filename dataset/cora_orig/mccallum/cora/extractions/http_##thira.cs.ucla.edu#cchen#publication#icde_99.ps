URL: http://thira.cs.ucla.edu/cchen/publication/icde_99.ps
Refering-URL: http://www.cs.ucla.edu/~cchen/research.html
Root-URL: http://www.cs.ucla.edu
Email: cchen@cs.ucla.edu zaniolo@cs.ucla.edu  
Title: Universal Temporal Extensions for Database Languages  
Author: Cindy Xinmin Chen and Carlo Zaniolo 
Address: Los Angeles Los Angeles, CA 90095  
Affiliation: Computer Science Department University of California at  
Note: ICDE'99 Submission Number: U057  
Abstract: Temporal reasoning and temporal query languages present difficult research problems of theoretical interest and practical importance. One source of these problems is the chasm between point-based temporal reasoning and interval-based reasoning, as different approaches prefer one or the other. The second problem area is the lack of robustness and universality in many proposed solutions, whereby temporal extensions designed for one language cannot be easily applied to other query languages|e.g., extensions proposed for SQL cannot be applied to QBE or Datalog. In this paper, we provide a simple solution to both problems by observing that all query languages support both single-value based reasoning and aggregate-based reasoning, and these two kinds of reasoning can be naturally extended to support, respectively, point-based and interval-based temporal reasoning. In our development, we follow TSQL2, insofar as practical requirements are concerned, and show how its functionality can be captured by simpler constructs that can be applied uniformly to Datalog, QBE and SQL. Then, we show that the problem of efficient implementation can be achieved by mapping into a different storage representation, and discuss a prototype built along these lines using the LDL++ system with extended aggregates. 
Abstract-found: 1
Intro-found: 1
Reference: [ADS97] <author> C. Zaniolo, S. Ceri, C. Faloutsos, R. Snodgrass, and R. Zicari, </author> <title> Advanced Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1997 </year>
Reference-contexts: Because of space limitations, we only discuss valid time in this paper, although our approach can be extended to handle transaction time. 2 2 TSQL2 To illustrate some of the issues with TSQL2, consider a patient database with the history of prescriptions given to patients as in <ref> [ADS97] </ref>. The schema and sample TSQL2 queries are as follows: 1. Schema definition Example 1 Define the Prescription relation CREATE TABLE Prescription (Name CHAR (30), Physician CHAR (30), Drug CHAR (30), Dosage CHAR (30), Frequency INTERVAL MINUTE) AS VALID STATE DAY The Prescription relation is a valid time relation.
Reference: [AHV95] <author> S. Abiteboul, R. Hull and V. Vianu. </author> <title> Foundations of Databases, </title> <publisher> Addison-Wesley, </publisher> <year> 1995 </year>
Reference-contexts: G. drug P. date Conditions LENGTH. date &gt; 240 Of particular interest, is the "G" appearing in the first column and the third column of the first table, denoting that name and drug will serve as group-by columns for other variables, such as date defined in the row without "G" <ref> [AHV95, Ram98] </ref>. For Datalog T language we will use the head-aggregation syntax of LDL++ [ZW98].
Reference: [All83] <author> J.F. Allen. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> In Communications of the ACM, Vol.26, </journal> <volume> No.11, </volume> <pages> pages 832-843, </pages> <year> 1983 </year>
Reference-contexts: Physician Drug Dosage Frequency VTime Melanie P. drug P. date query2 (Drug; Date) calendar (1996; ; ; Date); prescription (`Melanie`; ; Drug; ; ; Date): 4 Interval-Oriented Reasoning An obvious requirement of all temporal languages is to support Allen's interval operators such as overlaps, precedes, contains, equals, meets, and intersects <ref> [All83] </ref>. Temporal languages that are based on temporal intervals [LM97] rely on these operators to express temporal joins. In this kind of languages, the query of Example 2 would be expressed 7 by the condition 'P1 OVERLAPS P2'.
Reference: [BCS96] <author> M.H. Bohlen, J. Chomicki, R.T. Snodgrass and D. Toman. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <booktitle> In Proceedings of the 5th Conference on Extended Database Technology, </booktitle> <pages> pages 325-341, </pages> <year> 1996 </year>
Reference-contexts: TQuel requires some syntactic overhead to express temporal join, and cannot express temporal negation directly. Compared with Chronolog and TQuel, TSQL2 [Sno95] provides the richest functionality as far as valid-time queries are concerned. Indeed, having reached a consensus on the desirable functionality represents an important achievement of TSQL2. Moreover, <ref> [BCS96] </ref> proposed a possible unification between TSQL2 and temporal logic and demonstrated that the expressive power of temporal logic is equal to a syntactically defined subset of TSQL2.
Reference: [BM96] <author> M.H. Bohlen and R. Marti. </author> <note> ChronoLog Version 4.0. http://www.cs.auc.dk/~boehlen/Software/ChronoLog4.0/, 1996 </note>
Reference-contexts: The more formal aspects of the problem were studied in [Cho93] which also discusses query languages based on logic programs and [JS96] which discusses the semantics of temporal databases. A short overview of previous work most relevant to this paper should start with TSQL2 20 [Sno95], and Chronolog <ref> [BM96] </ref>. Chronolog is a temporal deductive database language that uses database facts annotated with a time interval to indicate their perceived time of validity in the real world, and uses deduction rules to express temporal dependencies between stored or derived facts.
Reference: [BBJ98] <author> M.H. Bohlen, R. Busatto and C.S. Jensen. </author> <title> Point- Versus Interval-based Temporal Data Models. </title> <booktitle> In Proceedings of the 14th International Conference on Data Engineering, </booktitle> <pages> pages 192-200, </pages> <year> 1998 </year>
Reference-contexts: For in stance, many approaches model valid time states using temporal intervals, while the point-based approach models the database as a sequence of snapshots <ref> [Tom96, BBJ98] </ref>. The major drawback 1 of the interval-based data model is the need of coalescing time intervals when a projection is taken, whereas point-based data models are free from this problem. On the other hand, many temporal queries can be expressed naturally using intervals, e.g., using Allen's interval operators. <p> In this kind of languages, the query of Example 2 would be expressed 7 by the condition 'P1 OVERLAPS P2'. No explicit use of overlaps operator is needed in point--based semantics since two intervals overlap if and only if they share some common points <ref> [Tom96, BBJ98] </ref>. This conclusion also hold for TSQL2, where equality between time points is assumed as default condition when no other temporal condition is given. In TSQL2, however, the user must use explicit constructs to specify all the remaining Allen's operators. <p> This conclusion further supports the soundness of TSQL2 from the viewpoint of functionality, although the lack of a clear formalization makes it hard to characterize its expressive power. In [Tom96] and <ref> [BBJ98] </ref>, the pros and cons of interval-based temporal models and point-based models were discussed. The advantages of point-based models as conceptual data models are (i) automatic coalescing, and (ii) representation independence.
Reference: [BSS96] <author> M.H. Bohlen, R.T. Snodgrass and M.D. Soo. </author> <title> Coalescing in Temporal Databases. </title> <booktitle> In Proceedings of the 22nd International Conference on Very Large Databases, </booktitle> <pages> pages 180-191, </pages> <year> 1996 </year>
Reference-contexts: In TSQL2, time columns cannot be explicitly referred in the SELECT and WHERE clauses of a query: thus, we say that TSQL2 has an implicit-time data model. By keeping time implicit, TSQL2 eliminates the need for a user to have to specify coalescing of time periods <ref> [BSS96] </ref>. However, implicit time makes the semantics of TSQL2 more obscure and difficult to formalize. Furthermore, the fact that one cannot work directly with time, makes certain queries hard to express and requires the introduction of special temporal constructs to achieve the same goal indirectly.
Reference: [Cho93] <author> J. Chomicki. </author> <title> Temporal Databases. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-16, </pages> <year> 1993 </year>
Reference-contexts: Similar considerations hold for interval-based representations. 8 Related Work Temporal support is important for many database applications. A survey to the extensive research on temporal databases can be found in [OS95] and [SAA94]. The more formal aspects of the problem were studied in <ref> [Cho93] </ref> which also discusses query languages based on logic programs and [JS96] which discusses the semantics of temporal databases. A short overview of previous work most relevant to this paper should start with TSQL2 20 [Sno95], and Chronolog [BM96].
Reference: [CZ98] <author> C.X. Chen and C. Zaniolo. </author> <title> Universal Temporal Data Languages. </title> <booktitle> To appear in Proceedings of the 6th International Workshop on Deductive Databases and Logic Programming, </booktitle> <year> 1998 </year>
Reference-contexts: Thus we must use pairs of events that have the same period number. In a nutshell, the mapping of queries on the point-based representation to the event-based representation is simply accomplished by using few and well-behaved operators <ref> [CZ98] </ref>. Similar considerations hold for interval-based representations. 8 Related Work Temporal support is important for many database applications. A survey to the extensive research on temporal databases can be found in [OS95] and [SAA94].
Reference: [Jen94] <author> C.S. Jensen, et al. </author> <title> A Consensus Glossary of Temporal Database Concepts. </title> <booktitle> In SIGMOD Record, Vol.23, No.1, </booktitle> <pages> pages 52-64, </pages> <year> 1994 </year>
Reference-contexts: Furthermore, intervals provide an efficient representation for the physical storage of the data, while point-based conceptual models must be mapped into different representations for storage efficiency. The language TSQL2 [Sno95] introduced a consensus extension to SQL-92 that supports a Bi-temporal Conceptual Data Model <ref> [Jen94] </ref> and handles both valid time and transaction time. In TSQL2, time columns cannot be explicitly referred in the SELECT and WHERE clauses of a query: thus, we say that TSQL2 has an implicit-time data model.
Reference: [JS96] <author> C.S. Jensen and R.T. Snodgrass. </author> <title> Semantics of Time-Varying Information. </title> <booktitle> In Information Systems, Vol.21, No.4, </booktitle> <pages> pages 311-352, </pages> <year> 1996 </year>
Reference-contexts: A survey to the extensive research on temporal databases can be found in [OS95] and [SAA94]. The more formal aspects of the problem were studied in [Cho93] which also discusses query languages based on logic programs and <ref> [JS96] </ref> which discusses the semantics of temporal databases. A short overview of previous work most relevant to this paper should start with TSQL2 20 [Sno95], and Chronolog [BM96].
Reference: [LM97] <author> N.A. Lorentzos and Y.G. Mitsopoulos. </author> <title> SQL Extension for Interval Data. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, Vol.9, </journal> <volume> No.3, </volume> <pages> pages 480-499, </pages> <year> 1997 </year>
Reference-contexts: Temporal languages that are based on temporal intervals <ref> [LM97] </ref> rely on these operators to express temporal joins. In this kind of languages, the query of Example 2 would be expressed 7 by the condition 'P1 OVERLAPS P2'.
Reference: [OS95] <author> G. Ozsoyoglu and R.T. Snodgrass. </author> <title> Temporal and Real-Time Databases: A Survey. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, Vol.7, </journal> <volume> No.4, </volume> <pages> pages 513-532, </pages> <year> 1995 </year>
Reference-contexts: Similar considerations hold for interval-based representations. 8 Related Work Temporal support is important for many database applications. A survey to the extensive research on temporal databases can be found in <ref> [OS95] </ref> and [SAA94]. The more formal aspects of the problem were studied in [Cho93] which also discusses query languages based on logic programs and [JS96] which discusses the semantics of temporal databases.
Reference: [Ram98] <author> R. Ramakrishnan. </author> <title> Database Management Systems, </title> <address> WCB/McGraw-Hill, </address> <year> 1998 </year>
Reference-contexts: G. drug P. date Conditions LENGTH. date &gt; 240 Of particular interest, is the "G" appearing in the first column and the third column of the first table, denoting that name and drug will serve as group-by columns for other variables, such as date defined in the row without "G" <ref> [AHV95, Ram98] </ref>. For Datalog T language we will use the head-aggregation syntax of LDL++ [ZW98].
Reference: [SAA94] <author> R.T. Snodgrass, I. Ahn, G. Ariav, D. Batory, et al. </author> <title> A TSQL2 Tutorial. </title> <booktitle> In SIGMOD Record, Vol.23, No.3, </booktitle> <pages> pages 27-33, </pages> <year> 1994 </year>
Reference-contexts: Similar considerations hold for interval-based representations. 8 Related Work Temporal support is important for many database applications. A survey to the extensive research on temporal databases can be found in [OS95] and <ref> [SAA94] </ref>. The more formal aspects of the problem were studied in [Cho93] which also discusses query languages based on logic programs and [JS96] which discusses the semantics of temporal databases. A short overview of previous work most relevant to this paper should start with TSQL2 20 [Sno95], and Chronolog [BM96].
Reference: [Sno87] <author> R.T. Snodgrass. </author> <title> The Temporal Query Language TQuel. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 204-212, </pages> <year> 1987 </year>
Reference-contexts: Chronolog's close relationship with Prolog makes it easier to define its temporal semantics. However, Chronolog cannot completely resolve the temporal reducibility problem [Tom96]. TQuel <ref> [Sno87, Sno93] </ref> is a superset of Quel and supports three temporal dimensions (valid time, transaction time and user-defined time).
Reference: [Sno93] <author> R.T. Snodgrass. </author> <title> An Overview of TQuel. In Temporal Databases: Theory, Design and Implementations (A. Tansel, </title> <editor> et al., </editor> <booktitle> eds.), </booktitle> <pages> pages 141-182, </pages> <address> Benjamin/Cumming, </address> <year> 1993 </year>
Reference-contexts: Chronolog's close relationship with Prolog makes it easier to define its temporal semantics. However, Chronolog cannot completely resolve the temporal reducibility problem [Tom96]. TQuel <ref> [Sno87, Sno93] </ref> is a superset of Quel and supports three temporal dimensions (valid time, transaction time and user-defined time).
Reference: [Sno95] <author> R.T. Snodgrass, et al. </author> <title> The TSQL2 Temporal Query Language, </title> <publisher> Kluwer, </publisher> <year> 1995 </year>
Reference-contexts: On the other hand, many temporal queries can be expressed naturally using intervals, e.g., using Allen's interval operators. Furthermore, intervals provide an efficient representation for the physical storage of the data, while point-based conceptual models must be mapped into different representations for storage efficiency. The language TSQL2 <ref> [Sno95] </ref> introduced a consensus extension to SQL-92 that supports a Bi-temporal Conceptual Data Model [Jen94] and handles both valid time and transaction time. In TSQL2, time columns cannot be explicitly referred in the SELECT and WHERE clauses of a query: thus, we say that TSQL2 has an implicit-time data model. <p> SELECT Name FROM Prescription (Name, Drug) (PERIOD) AS P WHERE CAST (VALID (P) AS INTERVAL DAY) &gt; INTERVAL `240` DAY 13 This solution suffers from several problems including the fact that (i) partitioning violates the TSQL2's data model <ref> [Sno95] </ref> and (ii) we do not know how to extend this construct to query languages where there is no FROM clause. Again, TSQL2's problem can be simply solved using a new aggregate called period which basically enumerates the periods in ascending temporal order. <p> The more formal aspects of the problem were studied in [Cho93] which also discusses query languages based on logic programs and [JS96] which discusses the semantics of temporal databases. A short overview of previous work most relevant to this paper should start with TSQL2 20 <ref> [Sno95] </ref>, and Chronolog [BM96]. Chronolog is a temporal deductive database language that uses database facts annotated with a time interval to indicate their perceived time of validity in the real world, and uses deduction rules to express temporal dependencies between stored or derived facts. <p> TQuel requires some syntactic overhead to express temporal join, and cannot express temporal negation directly. Compared with Chronolog and TQuel, TSQL2 <ref> [Sno95] </ref> provides the richest functionality as far as valid-time queries are concerned. Indeed, having reached a consensus on the desirable functionality represents an important achievement of TSQL2.
Reference: [Sno98] <author> R.T. Snodgrass, M.H. Bohlen, C.S. Jensen and A. </author> <title> Steiner. Transitioning Temporal Support in TSQL2 to SQL3. In Temporal Databases: Research and Practice (O. Etzion, </title> <editor> et al., eds.), </editor> <publisher> Springer-Verlag, </publisher> <pages> pages 211-237, </pages> <year> 1998 </year>
Reference: [Tan93] <author> A. Tansel, et al. </author> <title> Temporal Databases: Theory, Design and Implementation, </title> <address> Ben-jamin/Cumming, </address> <year> 1993 </year> <month> 23 </month>
Reference-contexts: 1 Introduction Extensive research has been focusing on temporal databases <ref> [Tan93] </ref> because many applications require support of temporal queries and reasoning on databases. However difficult issues on tem poral databases appear at both the physical level where specialized data structures have been used, and at the conceptual level where different temporal models have been proposed.
Reference: [Tom96] <author> D. Toman. </author> <title> Point vs. Interval-based Query Languages for Temporal Databases. </title> <booktitle> In Proceedings of the 15th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 58-67, </pages> <year> 1996 </year>
Reference-contexts: For in stance, many approaches model valid time states using temporal intervals, while the point-based approach models the database as a sequence of snapshots <ref> [Tom96, BBJ98] </ref>. The major drawback 1 of the interval-based data model is the need of coalescing time intervals when a projection is taken, whereas point-based data models are free from this problem. On the other hand, many temporal queries can be expressed naturally using intervals, e.g., using Allen's interval operators. <p> In this kind of languages, the query of Example 2 would be expressed 7 by the condition 'P1 OVERLAPS P2'. No explicit use of overlaps operator is needed in point--based semantics since two intervals overlap if and only if they share some common points <ref> [Tom96, BBJ98] </ref>. This conclusion also hold for TSQL2, where equality between time points is assumed as default condition when no other temporal condition is given. In TSQL2, however, the user must use explicit constructs to specify all the remaining Allen's operators. <p> Chronolog's close relationship with Prolog makes it easier to define its temporal semantics. However, Chronolog cannot completely resolve the temporal reducibility problem <ref> [Tom96] </ref>. TQuel [Sno87, Sno93] is a superset of Quel and supports three temporal dimensions (valid time, transaction time and user-defined time). <p> This conclusion further supports the soundness of TSQL2 from the viewpoint of functionality, although the lack of a clear formalization makes it hard to characterize its expressive power. In <ref> [Tom96] </ref> and [BBJ98], the pros and cons of interval-based temporal models and point-based models were discussed. The advantages of point-based models as conceptual data models are (i) automatic coalescing, and (ii) representation independence.
Reference: [Tom97] <author> D. Toman. </author> <title> A Point-Based Temporal Extension of SQL. </title> <booktitle> In Proceedings of the 6th International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 103-121, </pages> <year> 1997 </year>
Reference-contexts: In [Tom96] and [BBJ98], the pros and cons of interval-based temporal models and point-based models were discussed. The advantages of point-based models as conceptual data models are (i) automatic coalescing, and (ii) representation independence. Thus, <ref> [Tom97, Tom98] </ref> proposed a temporal extension to SQL-92 named SQL/TP, which uses time points and achieves efficient query evaluation through a compilation that translates the point-based SQL/TP queries to equivalent SQL-92 queries over interval-based concrete temporal databases. <p> Thus, [Tom97, Tom98] proposed a temporal extension to SQL-92 named SQL/TP, which uses time points and achieves efficient query evaluation through a compilation that translates the point-based SQL/TP queries to equivalent SQL-92 queries over interval-based concrete temporal databases. The approach proposed in this paper generalizes that of <ref> [Tom97] </ref> and covers several important aspects not addressed by that work. The use of temporal aggregates for expressing Allen's temporal operators and TSQL2's partitioning represents a first contribution of this paper. A second is universality, i.e., the generalization of every concept and construct to different query languages.
Reference: [Tom98] <author> D. Toman. </author> <title> Point-Based Temporal Extensions of SQL and their Efficient Implementation. In Temporal Databases: Research and Practice (O. Etzion, </title> <editor> et al., eds.), </editor> <publisher> Springer-Verlag, </publisher> <pages> pages 211-237, </pages> <year> 1998 </year>
Reference-contexts: In [Tom96] and [BBJ98], the pros and cons of interval-based temporal models and point-based models were discussed. The advantages of point-based models as conceptual data models are (i) automatic coalescing, and (ii) representation independence. Thus, <ref> [Tom97, Tom98] </ref> proposed a temporal extension to SQL-92 named SQL/TP, which uses time points and achieves efficient query evaluation through a compilation that translates the point-based SQL/TP queries to equivalent SQL-92 queries over interval-based concrete temporal databases.
Reference: [Wan98] <author> H. Wang. </author> <title> User Defined Aggregates in LDL++. </title> <note> http://www.cs.ucla.edu/~hxwang/ldl/aggregate, 1998 </note>
Reference-contexts: In a similar fashion, we can implement the period aggregate assuming that the intervals are sorted in ascending start-time order: once a maximal interval is determined, the running count (rather than sum) is incremented. Also, the contains operator can be implemented in linear time once intervals are sorted <ref> [Wan98] </ref>. 18 7.2 Event-Based Implementation In the event based representation, we represent changes between states, rather than the intervals in which the states hold. Thus, the following four entries, prescript ('Melaine', 'Dr. Frank', 'Proventil', 3mgs, 360, ins (21,11,1996)). prescript ('Melaine', 'Dr. Frank', 'Proventil', 3mgs, 360, del (28,11,1996)). prescript ('Melaine', 'Dr.
Reference: [WZ98] <author> H. Wang and C. Zaniolo. </author> <title> User Defined Aggregates for Datamining and other Advanced Database Applications. </title> <note> Submitted to ICDE'99. </note>
Reference-contexts: A third novelty is the investigation of an implementation based on events, in addition to that based on intervals; this event-based implementation appears to be preferable from several viewpoints. Finally, this paper clarifies the important role that the new extended aggregates 21 proposed in <ref> [WZ98] </ref> can have in mapping from conceptual to physical representations and in the efficient implementation of queries. Because of space limitations, we only discussed valid time.
Reference: [Zan96] <author> C. Zaniolo. </author> <title> A Short Overview of LDL++: A Second-Generation Deductive Database System. </title> <booktitle> In Computational Logic, Vol.3, No.1, </booktitle> <pages> pages 87-93, </pages> <year> 1996 </year>
Reference-contexts: The reserved keyword VTime must be used to denote the name of the valid-time column|a relation can have at most one of these columns. Similar conventions apply to the schemas defined in QBE or to Datalog languages such as LDL++ <ref> [Zan96, Zan98] </ref> (these are so obvious that we can hereby dispense with the examples). <p> Thus the second rule reconstruct the correct valid time Date for each Name. In general, the limitations caused by implicit group-by attributes in LDL++ are easily overcome given the great flexibility of user-defined aggregates in LDL++, Version 5 <ref> [Zan96, Zan98] </ref>. In particular, we have defined a binary aggregate called contains which is true when one set of time points contains all the time points in the other set.
Reference: [Zan98] <author> C. Zaniolo, et al. </author> <note> LDL++ Version 5. http://www.cs.ucla.edu/~czdemo/ldlwww/, 1998 </note>
Reference-contexts: The reserved keyword VTime must be used to denote the name of the valid-time column|a relation can have at most one of these columns. Similar conventions apply to the schemas defined in QBE or to Datalog languages such as LDL++ <ref> [Zan96, Zan98] </ref> (these are so obvious that we can hereby dispense with the examples). <p> Thus the second rule reconstruct the correct valid time Date for each Name. In general, the limitations caused by implicit group-by attributes in LDL++ are easily overcome given the great flexibility of user-defined aggregates in LDL++, Version 5 <ref> [Zan96, Zan98] </ref>. In particular, we have defined a binary aggregate called contains which is true when one set of time points contains all the time points in the other set. <p> On the other hand, contains returns zero arguments, it simply evaluates to either true or false. Only the Drug values for which contains&lt;Date2, Date1&gt; evaluates to true are returned. The flexibility of having zero, one, or several values returned is supported in version 5 of LDL++ <ref> [Zan98] </ref>. 7 Implementation In this section, we discuss two alternative implementations of our universal temporal languages. One implementation is based on storing temporal intervals, and the other on storing events. <p> Therefore, queries expressed against the point-based conceptual model must be translated into equivalent queries against an interval-based representation or an event-based representation. We will base our description on an implementation built at UCLA, where Datalog T is supported on top of the LDL++ system using extended aggregates <ref> [Zan98, ZW98] </ref>. 16 7.1 Interval-based implementation Using an interval-based relation to implement Datalog T solves the space efficiency problem associated with the point-based data model. In interval-based relations, all tuples are timestamped with two time instants: one indicates the start-point and the other the end-point of the interval.
Reference: [ZW98] <author> C. Zaniolo and H. Wang. </author> <title> Logic-Based User-Defined Aggregates for the Next Generation of Database Systems. In The Logic Programming Paradigm: Current Trends and Future Directions (K.R. </title> <editor> Apt, et al., eds.), </editor> <publisher> Springer Verlag, </publisher> <year> 1998. </year> <month> 24 </month>
Reference-contexts: For Datalog T language we will use the head-aggregation syntax of LDL++ <ref> [ZW98] </ref>. <p> Therefore, queries expressed against the point-based conceptual model must be translated into equivalent queries against an interval-based representation or an event-based representation. We will base our description on an implementation built at UCLA, where Datalog T is supported on top of the LDL++ system using extended aggregates <ref> [Zan98, ZW98] </ref>. 16 7.1 Interval-based implementation Using an interval-based relation to implement Datalog T solves the space efficiency problem associated with the point-based data model. In interval-based relations, all tuples are timestamped with two time instants: one indicates the start-point and the other the end-point of the interval.
References-found: 28

