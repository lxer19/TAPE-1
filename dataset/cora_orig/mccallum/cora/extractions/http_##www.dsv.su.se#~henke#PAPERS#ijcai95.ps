URL: http://www.dsv.su.se/~henke/PAPERS/ijcai95.ps
Refering-URL: http://www.dsv.su.se/~henke/Welcome.html
Root-URL: 
Email: henke@dsv.su.se  
Title: Covering vs. Divide-and-Conquer for Top-Down Induction of Logic Programs  
Author: Henrik Bostrom 
Address: Electrum 230, 164 40 Kista, Sweden  
Affiliation: Dept. of Computer and Systems Sciences Stockholm University  
Abstract: covering has been formalized and used extensively. In this work, the divide-and-conquer technique is formalized as well and compared to the covering technique in a logic programming framework. Covering works by repeatedly specializing an overly general hypothesis, on each iteration focusing on finding a clause with a high coverage of positive examples. Divide-and-conquer works by specializing an overly general hypothesis once, focusing on discriminating positive from negative examples. Experimental results are presented demonstrating that there are cases when more accurate hypotheses can be found by divide-and-conquer than by covering. Moreover, since covering considers the same alternatives repeatedly it tends to be less efficient than divide-and-conquer, which never considers the same alternative twice. On the other hand, covering searches a larger hypothesis space, which may result in that more compact hypotheses are found by this technique than by divide-and-conquer. Furthermore, divide-and-conquer is, in contrast to covering, not applicable to learn ing recursive definitions.
Abstract-found: 1
Intro-found: 1
Reference: [ Bergadano and Giordana,1988 ] <author> Bergadano F. and Giordana A., </author> <title> "A Knowledge Intensive Approach to Concept Induction", </title> <booktitle> Proceedings of the Fifth International Conference on Machine Learning, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> CA (1988) 305-317 </address>
Reference-contexts: This formalization is in fact a reformulation of the algorithm spectre [ Bostrom and Idestam-Almquist,1994 ] , and can also be viewed as a generalization of the technique used in ml-smart <ref> [ Bergadano and Giordana,1988 ] </ref> . In the next section, the two search techniques are formalized and analysed in a logic programming framework.
Reference: [ Bostrom, 1995 ] <author> Bostrom H., </author> <title> "Specialization of Recursive Predicates", </title> <booktitle> Proceedings of the Eighth European Conference on Machine Learning, </booktitle> <publisher> Springer-Verlag (1995) </publisher>
Reference-contexts: It should be noted that although divide-and-conquer is not applicable to recursive predicates, it does not mean that recursive definitions can not be found by applying unfolding and clause removal. On the contrary, a technique for achieving this is presented in <ref> [ Bostrom, 1995 ] </ref> . Covering, on the other hand, can be easily extended to deal with recursive predicates.
Reference: [ Bostrom and Idestam-Almquist,1994 ] <author> Bostrom H. and Idestam-Almquist P., </author> <title> "Specialization of Logic Programs by Pruning SLD-Trees", </title> <booktitle> Proceedings of the 4th International Workshop on Inductive Logic Programming, volume 237 of GMD-Studien, </booktitle> <institution> Gesellschaft fur Mathematik und Datenverarbeitung MBH (1994) 31-48 </institution>
Reference-contexts: This work contributes to the above long term goal by giving a formalization of divide-and-conquer in a logic programming framework. This formalization is in fact a reformulation of the algorithm spectre <ref> [ Bostrom and Idestam-Almquist,1994 ] </ref> , and can also be viewed as a generalization of the technique used in ml-smart [ Bergadano and Giordana,1988 ] . In the next section, the two search techniques are formalized and analysed in a logic programming framework. <p> As for covering, it should be noted that the non-deterministic choices (in this case of which literals to unfold upon) are crucial for the result. Again, the optimal choices can be approximated by selecting the specialization that maximizes the information gain, as is done in <ref> [ Bostrom and Idestam-Almquist,1994 ] </ref> (cf. id3 [ Quinlan,1986 ] ). 2.5 The Hypothesis Spaces Let O be an overly general hypothesis and B be back ground predicates. <p> However, since the first clause can not be removed or specialized, it means this sub-part of the problem can not be treated separately according to the divide-and-conquer principle. One solution to this problem is to transform the overly general hypothesis into an equivalent non-recursive hypothesis, as proposed in <ref> [ Bostrom and Idestam-Almquist,1994 ] </ref> . However, although this transformation allows divide-and-conquer to be applied, it prevents recursive hypotheses from being found.
Reference: [ Bratko,1990 ] <author> Bratko I., </author> <title> Prolog Programming for Artificial Intelligence, (2nd edition), </title> <publisher> Addison-Wesley (1990) </publisher>
Reference-contexts: The third domain considers natural language parsing using a definite clause grammar and is taken from <ref> [ Bratko,1990 ] </ref> . The example sets in the UCI repository are represented by attribute vectors, and have to be transformed into atoms in order to be used together with the algorithms. <p> The set of positive examples in the third domain consists of all sentences of up to seven words that can be generated by the grammar in <ref> [ Bratko,1990, p 455 ] </ref> , i.e. 565 sentences. The set of negative examples is generated by randomly selecting one word in each correct sentence and replacing it by a randomly selected word that leads to an incorrect sentence. Thus the number of negative examples is also 565.
Reference: [ Cohen,1991 ] <author> Cohen W. W., </author> <title> "The Generality of Over-generality", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 490-494 </publisher>
Reference-contexts: However, of the two search techniques used in propositional learning, only covering has been formalized and used extensively for top-down induction of logic programs (e.g. in mis [ Shapiro,1983 ] , foil [ Quinlan,1990 ] , ana-ebl <ref> [ Cohen,1991 ] </ref> , focl [ Pazzani et al,1991 ] , gren-del [ Cohen,1992 ] and focl-frontier [ Pazzani and Brunk,1993 ] ). This work contributes to the above long term goal by giving a formalization of divide-and-conquer in a logic programming framework. <p> Various restrictions are normally also put on the variables in the literals (e.g. at least one of the variables should appear elsewhere in the clause [ Quinlan,1990 ] ). Goal reduction is another specialization operator that has been used in several approaches (e.g. <ref> [ Cohen,1991; Pazzani et al,1991 ] </ref> ). By this operator, a clause is spe cialized by resolving upon a literal in the body using one of the background clauses. <p> The number of examples is 3196 in the first domain (of which 52.2% are positive) and 958 in the second domain (of which 65.3% are positive). Since the algorithms also require overly general hypotheses as input, such are constructed for the two first domains in the following way (cf. <ref> [ Cohen,1991 ] </ref> ). A new target predicate is defined with as many arguments as the number of attributes, and for each attribute a new background predicate is defined to determine the possible values of the attribute.
Reference: [ Cohen,1992 ] <author> Cohen W. W., </author> <title> "Compiling Prior Knowledge Into an Explicit Bias", </title> <booktitle> Machine Learning: Proceedings of the Ninth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1992) 102-110 </publisher>
Reference-contexts: However, of the two search techniques used in propositional learning, only covering has been formalized and used extensively for top-down induction of logic programs (e.g. in mis [ Shapiro,1983 ] , foil [ Quinlan,1990 ] , ana-ebl [ Cohen,1991 ] , focl [ Pazzani et al,1991 ] , gren-del <ref> [ Cohen,1992 ] </ref> and focl-frontier [ Pazzani and Brunk,1993 ] ). This work contributes to the above long term goal by giving a formalization of divide-and-conquer in a logic programming framework. <p> It should be noted that any specialization obtained by goal reduction can also be obtained by literal addition (not necessarily in one step). On the other hand, it is also possible to define predicates that may introduce any literal (cf. <ref> [ Cohen,1992 ] </ref> ), which makes any clause obtainable by literal addition also obtainable by goal reduction. <p> Since it is computation-ally expensive to find the optimal choices, these are often approximated. In several approaches this has been done by selecting the refinement that maximizes the information gain <ref> [ Quinlan,1990; Pazzani et al,1991; Cohen,1992 ] </ref> . 2.4 Divide-and-Conquer The divide-and-conquer principle can be applied in a logic programming framework in the following way. Each clause in the overly general hypothesis covers a subset of the positive and negative examples.
Reference: [ Kanamori and Kawamura,1988 ] <author> Kanamori T. and Kawamura T., </author> <title> "Preservation of Stronger Equivalence in Unfold/Fold Logic Program Transformation (II)", </title> <type> ICOT Technical Report TR-403, </type> <address> Japan (1988) </address>
Reference-contexts: On the other hand, when using divide-and-conquer, the number of SLD-refutations of the positive examples is the same for both the overly general and the resulting hypothesis. This follows from the fact that the number of SLD-refutations does not increase when unfolding is applied (proven in <ref> [ Kanamori and Kawamura,1988 ] </ref> ).
Reference: [ Lloyd,1987 ] <author> Lloyd J. W., </author> <booktitle> Foundations of Logic Programming, (2nd edition), </booktitle> <publisher> Springer-Verlag (1987) </publisher>
Reference-contexts: Finally, concluding remarks are given in section four. In the following, we assume the reader to be familiar with the standard terminology in logic programming <ref> [ Lloyd,1987 ] </ref> . 2 Top-Down Induction of Logic Programs In this section, we first define the top-down induction problem in a logic programming framework. We then present two common specialization operators and show how covering and divide-and-conquer can be formalized using one of these.
Reference: [ Michalski,1980 ] <author> Michalski R. S., </author> <title> "Pattern Recognition as Rule-Guided Inductive Inference", </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <month> 2 </month> <year> (1980) </year> <month> 349-361 </month>
Reference-contexts: In propositional learning, two search techniques for top-down induction have been proposed: covering and divide-and-conquer. Covering, which has been used in e.g. the aq family <ref> [ Michalski,1980 ] </ref> , constructs a hypothesis by repeatedly specializing an overly general hypothesis, on each iteration selecting a disjunct that satisfies a subset of the positive examples and no negative examples, until all positive examples are satisfied by the selected disjuncts.
Reference: [ Pazzani and Brunk,1993 ] <author> Pazzani M. and Brunk C., </author> <title> "Finding Accurate Frontiers: A Knowledge-Intensive Approach to Relational Learning", </title> <booktitle> Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann (1993) 328-334 </publisher>
Reference-contexts: search techniques used in propositional learning, only covering has been formalized and used extensively for top-down induction of logic programs (e.g. in mis [ Shapiro,1983 ] , foil [ Quinlan,1990 ] , ana-ebl [ Cohen,1991 ] , focl [ Pazzani et al,1991 ] , gren-del [ Cohen,1992 ] and focl-frontier <ref> [ Pazzani and Brunk,1993 ] </ref> ). This work contributes to the above long term goal by giving a formalization of divide-and-conquer in a logic programming framework.
Reference: [ Pazzani et al,1991 ] <author> Pazzani M., Brunk C. and Silver-stein G., </author> <title> "A Knowledge-Intensive Approach to Learning Relational Concepts", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <address> Mor-gan Kaufmann (1991) 432-436 </address>
Reference-contexts: However, of the two search techniques used in propositional learning, only covering has been formalized and used extensively for top-down induction of logic programs (e.g. in mis [ Shapiro,1983 ] , foil [ Quinlan,1990 ] , ana-ebl [ Cohen,1991 ] , focl <ref> [ Pazzani et al,1991 ] </ref> , gren-del [ Cohen,1992 ] and focl-frontier [ Pazzani and Brunk,1993 ] ). This work contributes to the above long term goal by giving a formalization of divide-and-conquer in a logic programming framework. <p> The reason for this assumption is discussed in section 2.6. 2.2 Specialization Operators Literal addition is a specialization operator that has been used in several approaches for top-down induction of logic programs (e.g. <ref> [ Shapiro,1983; Quinlan,1990; Pazzani et al,1991 ] </ref> ). By this operator, a clause is specialized by adding a literal to the body, where the literal usually is restricted to be an instance of a background predicate. <p> Various restrictions are normally also put on the variables in the literals (e.g. at least one of the variables should appear elsewhere in the clause [ Quinlan,1990 ] ). Goal reduction is another specialization operator that has been used in several approaches (e.g. <ref> [ Cohen,1991; Pazzani et al,1991 ] </ref> ). By this operator, a clause is spe cialized by resolving upon a literal in the body using one of the background clauses. <p> Since it is computation-ally expensive to find the optimal choices, these are often approximated. In several approaches this has been done by selecting the refinement that maximizes the information gain <ref> [ Quinlan,1990; Pazzani et al,1991; Cohen,1992 ] </ref> . 2.4 Divide-and-Conquer The divide-and-conquer principle can be applied in a logic programming framework in the following way. Each clause in the overly general hypothesis covers a subset of the positive and negative examples.
Reference: [ Quinlan,1986 ] <author> Quinlan J. R., </author> <title> "Induction of Decision Trees", </title> <note> Machine Learning 1 (1986) 81-106 </note>
Reference-contexts: Divide-and-conquer, which has been used in e.g. id3 <ref> [ Quinlan,1986 ] </ref> , constructs a hypothesis by dividing an overly general hypothesis into a set of hypotheses, which correspond to disjoint subsets of the examples. It then continues recursively with those hypotheses for which the corresponding subsets contain both positive and negative examples. <p> Again, the optimal choices can be approximated by selecting the specialization that maximizes the information gain, as is done in [ Bostrom and Idestam-Almquist,1994 ] (cf. id3 <ref> [ Quinlan,1986 ] </ref> ). 2.5 The Hypothesis Spaces Let O be an overly general hypothesis and B be back ground predicates.
Reference: [ Quinlan,1990 ] <author> Quinlan J. R., </author> <title> "Learning Logical Definitions from Relations", </title> <note> Machine Learning 5 (1990) 239-266 </note>
Reference-contexts: However, of the two search techniques used in propositional learning, only covering has been formalized and used extensively for top-down induction of logic programs (e.g. in mis [ Shapiro,1983 ] , foil <ref> [ Quinlan,1990 ] </ref> , ana-ebl [ Cohen,1991 ] , focl [ Pazzani et al,1991 ] , gren-del [ Cohen,1992 ] and focl-frontier [ Pazzani and Brunk,1993 ] ). This work contributes to the above long term goal by giving a formalization of divide-and-conquer in a logic programming framework. <p> The reason for this assumption is discussed in section 2.6. 2.2 Specialization Operators Literal addition is a specialization operator that has been used in several approaches for top-down induction of logic programs (e.g. <ref> [ Shapiro,1983; Quinlan,1990; Pazzani et al,1991 ] </ref> ). By this operator, a clause is specialized by adding a literal to the body, where the literal usually is restricted to be an instance of a background predicate. <p> Various restrictions are normally also put on the variables in the literals (e.g. at least one of the variables should appear elsewhere in the clause <ref> [ Quinlan,1990 ] </ref> ). Goal reduction is another specialization operator that has been used in several approaches (e.g. [ Cohen,1991; Pazzani et al,1991 ] ). By this operator, a clause is spe cialized by resolving upon a literal in the body using one of the background clauses. <p> Since it is computation-ally expensive to find the optimal choices, these are often approximated. In several approaches this has been done by selecting the refinement that maximizes the information gain <ref> [ Quinlan,1990; Pazzani et al,1991; Cohen,1992 ] </ref> . 2.4 Divide-and-Conquer The divide-and-conquer principle can be applied in a logic programming framework in the following way. Each clause in the overly general hypothesis covers a subset of the positive and negative examples.
Reference: [ Shapiro,1983 ] <author> Shapiro E. Y., </author> <title> Algorithmic Program Debugging, </title> <publisher> MIT Press (1983) </publisher>
Reference-contexts: However, of the two search techniques used in propositional learning, only covering has been formalized and used extensively for top-down induction of logic programs (e.g. in mis <ref> [ Shapiro,1983 ] </ref> , foil [ Quinlan,1990 ] , ana-ebl [ Cohen,1991 ] , focl [ Pazzani et al,1991 ] , gren-del [ Cohen,1992 ] and focl-frontier [ Pazzani and Brunk,1993 ] ). <p> The reason for this assumption is discussed in section 2.6. 2.2 Specialization Operators Literal addition is a specialization operator that has been used in several approaches for top-down induction of logic programs (e.g. <ref> [ Shapiro,1983; Quinlan,1990; Pazzani et al,1991 ] </ref> ). By this operator, a clause is specialized by adding a literal to the body, where the literal usually is restricted to be an instance of a background predicate.
Reference: [ Tamaki and Sato,1984 ] <author> Tamaki H. and Sato T., </author> <title> "Unfold/Fold Transformations of Logic Programs", </title> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <institution> Uppsala University, Uppsala, </institution> <month> Swe-den </month> <year> (1984) </year> <month> 127-138 </month>
Reference-contexts: This means that a clause that covers both positive and negative examples should be split into a number of clauses, that taken together are equivalent to the clause that is split. This can be achieved by applying the transformation rule unfolding 3 <ref> [ Tamaki and Sato,1984 ] </ref> . This technique is formalized in Figure 3. Example Consider again the overly general hypothesis, background predicates and examples in the previous example.
References-found: 15

