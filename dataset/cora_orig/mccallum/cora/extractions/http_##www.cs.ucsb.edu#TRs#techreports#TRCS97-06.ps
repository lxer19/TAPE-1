URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS97-06.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Processor Lower Bounds for Array Computations with Linear Schedules  
Author: Peter Cappello and Omer Egecioglu 
Keyword: Parallel processing, array computation, lower bound, linear schedule, Diophantine equation, generating function.  
Address: fomer; cappellog@cs:ucsb:edu  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract: Using a directed acyclic graph (dag) model of algorithms, this paper treats a problem related to precedence-constrained multiprocessor schedules for array computations: Given a dag and a valid linear schedule for it, compute a lower bound on the number of processors required by the schedule. This is an important practical problem: A good schedule uses time efficiently; a good mapping of nodes to processors uses energy efficiently. The lower bounds obtained are good; we know of no case where they are not exactly tight. Actually, a harder problem is solved: Given a parametrized family of dags and a correspondingly parametrized valid linear schedule, symbolically generate a processor lower bound formula. To visualize the method for computing this formula, the nodes, representing computational tasks, are viewed as a set of lattice points in a convex polyhedron. The number of tasks that are scheduled for execution during any given time step of a linear schedule is the number of non-negative integer solutions to a set of linear Diophantine equations parametrized by the number of nodes of the dag. An algorithm, based on construction of generating functions, is presented for computing these numbers. This is the first such algorithm to be reported. Using this algorithm and a symbolic algebra package, formulas for processor lower bounds are obtained automatically. The algorithm has been implemented as a Mathematica program. Example runs for Matrix-Vector Product, and Triangular Matrix Product problems are given. While widely applicable and elegant, it has worst case exponential running time. This is not surprising however; the simpler computation: "Are any processors scheduled for a particular time step?", which is equivalent to "Is a particular coefficient of the generating function nonzero?" is already known to be an NP-complete problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Peter R. Cappello. </author> <title> VLSI Architectures for Digital Signal Processing. </title> <type> PhD thesis, </type> <institution> Princeton University, Princeton, NJ, </institution> <month> Oct </month> <year> 1982. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs. <p> A is the input matrix, x is the input vector, and y = A x is the output vector. We index the entries of an n-dimensional vector v by v [0]; v <ref> [1] </ref>; : : : ; v [n 1]. for i = 0 to n 1 do: for j = 0 to n 1 do: endfor; endfor; Computation is "located" at certain index pairs defined by the for loop limits, namely all pairs (i; j) satisfying: 0 i n 1 (3) Clearly, <p> the augmented Diophantine system in (4) can be written in the form (8) where a = 6 1 1 0 0 0 1 0 1 7 2 4 1 3 5 ; c = 6 1 1 7 3.1 Sample Run for the n fi n Matrix-Vector Multiplication Example: In <ref> [1] </ref>:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In [7]:= formulaN [10] Out [7]= 10 For <p> 7 3.1 Sample Run for the n fi n Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C <ref> [n, 1] </ref> Power Formula : n In [7]:= formulaN [10] Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b + c where a = 6 6 1 1 1 0 0 0 0 1 1 0 1 0 3 7 5 <p> = N b + c where a = 6 6 1 1 1 0 0 0 0 1 1 0 1 0 3 7 5 2 6 4 2 0 7 7 (10) 3.2 Sample Run for the n fi n Triangular Matrix Product Example (n = 2N ): In <ref> [1] </ref>:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In [3]:= b = -3, 2, 0, 0-; In [5]:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In [6]:= formula Binomial Formula : C [1 + n, 2] n
Reference: [2] <author> Peter R. Cappello and Kenneth Steiglitz. </author> <title> Unifying VLSI array design with geometric transformations. </title> <editor> In H. J. Siegel and Leah Siegel, editors, </editor> <booktitle> Proc. Int. Conf. on Parallel Processing, </booktitle> <pages> pages 448-457, </pages> <address> Bellaire, MI, </address> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs. <p> in (4) can be written in the form (8) where a = 6 1 1 0 0 0 1 0 1 7 2 4 1 3 5 ; c = 6 1 1 7 3.1 Sample Run for the n fi n Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In <ref> [2] </ref>:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In [7]:= formulaN [10] Out [7]= 10 For n fi n Triangular <p> c where a = 6 6 1 1 1 0 0 0 0 1 1 0 1 0 3 7 5 2 6 4 2 0 7 7 (10) 3.2 Sample Run for the n fi n Triangular Matrix Product Example (n = 2N ): In [1]:= &lt;< DiophantineGF.m In <ref> [2] </ref>:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In [3]:= b = -3, 2, 0, 0-; In [5]:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In [6]:= formula Binomial Formula : C [1 + n, 2] n (1 + n) Power <p> = 2N ): In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In [3]:= b = -3, 2, 0, 0-; In [5]:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In [6]:= formula Binomial Formula : C <ref> [1 + n, 2] </ref> n (1 + n) Power Formula : --------- 2 When n = 2N + 1, the Mathematica run results in the same generating function computed above for the case n = 2N .
Reference: [3] <author> Peter R. Cappello and Kenneth Steiglitz. </author> <title> Unifying VLSI array design with linear transformations of space-time. </title> <editor> In Franco P. Preparata, editor, </editor> <booktitle> Advances in Computing Research, volume 2: VLSI theory, </booktitle> <pages> pages 23-65. </pages> <publisher> JAI Press, Inc., </publisher> <address> Greenwich, CT, </address> <year> 1984. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs. <p> 0 1 0 3 7 5 2 6 4 2 0 7 7 (10) 3.2 Sample Run for the n fi n Triangular Matrix Product Example (n = 2N ): In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In <ref> [3] </ref>:= b = -3, 2, 0, 0-; In [5]:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In [6]:= formula Binomial Formula : C [1 + n, 2] n (1 + n) Power Formula : --------- 2 When n = 2N + 1, the Mathematica run results in
Reference: [4] <author> Alain Darte, Leonid Khachiyan, and Yves Robert. </author> <title> Linear scheduling is close to optimal. </title> <editor> In Jose Fortes, Edward Lee, and Teresa Meng, editors, </editor> <booktitle> Application Specific Array Processors, </booktitle> <pages> pages 37-46. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs. <p> 6 1 1 0 0 0 1 0 1 7 2 4 1 3 5 ; c = 6 1 1 7 3.1 Sample Run for the n fi n Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In <ref> [4] </ref>:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In [7]:= formulaN [10] Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b +
Reference: [5] <author> Bradley R. Engstrom and Peter R. Cappello. </author> <title> The SDEF programming system. </title> <journal> J. of Parallel and Distributed Computing, </journal> <volume> 7 </volume> <pages> 201-231, </pages> <year> 1989. </year>
Reference-contexts: No such algorithm has ever been reported. Our use of linear Diophantine equations, we believe, is well-motivated: the computations of an inner loop are typically defined over a set of indices that can be described as the lattice points 4 in a convex polyhedron. Indeed, in two languages, SDEF <ref> [5] </ref> and Alpha [24], one expressly de-fines domains of computation as the integer points contained in some programmer-specified convex polyhedron. <p> 0 1 7 2 4 1 3 5 ; c = 6 1 1 7 3.1 Sample Run for the n fi n Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In <ref> [5] </ref>:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In [7]:= formulaN [10] Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b + c where a = 6 6 1 <p> 4 2 0 7 7 (10) 3.2 Sample Run for the n fi n Triangular Matrix Product Example (n = 2N ): In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In [3]:= b = -3, 2, 0, 0-; In <ref> [5] </ref>:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In [6]:= formula Binomial Formula : C [1 + n, 2] n (1 + n) Power Formula : --------- 2 When n = 2N + 1, the Mathematica run results in the same generating function computed above for the <p> Sample Run for the n fi n Triangular Matrix Product Example (n = 2N ): In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In [3]:= b = -3, 2, 0, 0-; In <ref> [5] </ref>:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In [6]:= formula Binomial Formula : C [1 + n, 2] n (1 + n) Power Formula : --------- 2 When n = 2N + 1, the Mathematica run results in the same generating function computed above for the case n = 2N .
Reference: [6] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference-contexts: ; c = 6 1 1 7 3.1 Sample Run for the n fi n Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In <ref> [6] </ref>:= formula; Binomial Formula : C [n, 1] Power Formula : n In [7]:= formulaN [10] Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b + c where a = 6 6 1 1 1 0 0 0 0 1 1 <p> n Triangular Matrix Product Example (n = 2N ): In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 1, 0, 0, 0-, -0,-1, 1, 0, 1, 0-, In [3]:= b = -3, 2, 0, 0-; In [5]:= DiophantineGF [a, b, c] t Out [5]= -------- (1 - t) In <ref> [6] </ref>:= formula Binomial Formula : C [1 + n, 2] n (1 + n) Power Formula : --------- 2 When n = 2N + 1, the Mathematica run results in the same generating function computed above for the case n = 2N . <p> Translating the polyhedron, and omitting superfluous constraints ( i.e., not in their transitive reduction) reduces the algorithm's work. Additional preprocessing may be possible (e.g., via unitary transforms). Moreover, even answering the question "Are any processors scheduled for this time step?" is known to be NP-complete <ref> [20, 6] </ref>. This computational complexity is further ameliorated by the observation that, since a formula can be automatically produced from the generating function, it needs to be constructed only once for a given algorithm.
Reference: [7] <author> Gene H. Golub and Charles F. Van Loan. </author> <title> Matrix Computations, 2nd Edition, </title> <publisher> The Johns Hopkins University Press, </publisher> <address> Baltimore, </address> <year> 1990. </year>
Reference-contexts: EXAMPLE 2: n fi n Triangular Matrix Product An algorithm for matrix product C = A B, where A and B are given n fi n upper triangular matrices is given below. The main body of this algorithm is taken from <ref> [7] </ref>. for i = 0 to n 1 do: for k = i to j do: endfor; endfor; endfor; The computational nodes are defined by non-negative integral triplets (i; j; k) satisfying i n 1 i j n 1 However, fewer than 5 constraints are needed to define this polyhedron. <p> fi n Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In <ref> [7] </ref>:= formulaN [10] Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b + c where a = 6 6 1 1 1 0 0 0 0 1 1 0 1 0 3 7 5 2 6 4 2 0 7 7 <p> Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In <ref> [7] </ref>:= formulaN [10] Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b + c where a = 6 6 1 1 1 0 0 0 0 1 1 0 1 0 3 7 5 2 6 4 2 0 7 7 (10) 3.2 Sample Run
Reference: [8] <author> Richard M. Karp, Richard E. Miller, and Shmuel Winograd. </author> <title> Properties of a model for parallel computations: Determinacy, termination, queueing. </title> <journal> SIAM J. Appl. Math, </journal> <volume> 14 </volume> <pages> 1390-1411, </pages> <year> 1966. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs.
Reference: [9] <author> Richard M. Karp, Richard E. Miller, and Shmuel Winograd. </author> <title> The organization of computations for uniform recurrence equations. </title> <journal> J. ACM, </journal> <volume> 14 </volume> <pages> 563-590, </pages> <year> 1967. </year> <month> 11 </month>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations <ref> [9] </ref>. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., [8, 11, 10, 1, 17, 2, 3, 18, 19, 4]).
Reference: [10] <author> H.-T. Kung and Charles E. Leiserson. </author> <title> Algorithms for VLSI processor arrays. </title> <booktitle> In Introduction to VLSI Systems, </booktitle> <pages> pages 271-292. </pages> <publisher> Addison-Wesley Publishing Co, </publisher> <address> Menlo Park, CA, </address> <year> 1980. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs. <p> Matrix-Vector Multiplication Example: In [1]:= &lt;< DiophantineGF.m In [2]:= a = --1, 1, 0, 0-, -0, 1, 0, 1--; In [4]:= c = --1, -1, -1-; In [5]:= DiophantineGF [a, b, c] t 2 In [6]:= formula; Binomial Formula : C [n, 1] Power Formula : n In [7]:= formulaN <ref> [10] </ref> Out [7]= 10 For n fi n Triangular Matrix Product problem the Diophantine system is az = N b + c where a = 6 6 1 1 1 0 0 0 0 1 1 0 1 0 3 7 5 2 6 4 2 0 7 7 (10) 3.2
Reference: [11] <author> Leslie Lamport. </author> <title> The parallel execution of Do-Loops. </title> <journal> Comm. of the ACM, </journal> <volume> 17(2) </volume> <pages> 83-93, </pages> <month> Feb. </month> <year> 1974. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs.
Reference: [12] <author> Percy A. MacMahon. </author> <title> Memoir on the Theory of the Partitions of Numbers- Part II, in Collected Papers, Vol. I, Combinatorics, </title> <editor> George E. Andrews, Editor, </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, MASS, </address> <year> 1978, </year> <pages> pp. 1138-1188. </pages>
Reference-contexts: Individual terms arising from this product are of the form ff 1 2ff 2 2 t ff 1 2 ; (12) where ff 1 ; ff 2 are non-negative integers. Following Cayley, MacMahon <ref> [12] </ref> makes use of the operator = which picks out those terms (12) in the power series expansion whose exponents of 1 and 2 are both equal to zero (this is the -free part of the expansion).
Reference: [13] <editor> Percy A. MacMahon. </editor> <booktitle> Memoir on the Theory of the Partitions of Numbers- Part IV, in Collected Papers, </booktitle> <volume> Vol. I, </volume> <editor> Combinatorics, George E. Andrews, Editor, </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, MASS, </address> <year> 1978, </year> <pages> pp. 1292-1314. </pages>
Reference: [14] <author> Percy A. MacMahon. </author> <title> Application of the Partition Analysis to the study of the properties of any system of consecutive integers. in Collected Papers, Vol. I, Combinatorics, </title> <editor> George E. Andrews, Editor, </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, MASS, </address> <year> 1978, </year> <pages> pp. 1189-1211. </pages>
Reference: [15] <author> Percy A. MacMahon. </author> <title> The Diophantine Inequality x y. in Collected Papers, Vol. I, Combinatorics, </title> <editor> George E. Andrews, Editor, </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, MASS, </address> <year> 1978, </year> <pages> pp. 1212-1232. </pages>
Reference: [16] <author> Percy A. MacMahon. </author> <title> Note on the The Diophantine Inequality x y. in Collected Papers, Vol. I, Combinatorics, </title> <editor> George E. Andrews, Editor, </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, MASS, </address> <year> 1978, </year> <pages> pp. 1233-1246. </pages>
Reference: [17] <author> Dan I. Moldovan. </author> <title> On the design of algorithms for VLSI systolic arrays. </title> <journal> Proc. IEEE, </journal> <volume> 71(1) </volume> <pages> 113-120, </pages> <month> Jan. </month> <year> 1983. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs.
Reference: [18] <author> Patrice Quinton. </author> <title> Automatic synthesis of systolic arrays from uniform recurrent equations. </title> <booktitle> In Proc. 11th Ann. Symp. on Computer Architecture, </booktitle> <pages> pages 208-214, </pages> <year> 1984. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs.
Reference: [19] <author> Sanjay V. Rajopadhye, S. Purushothaman, and Richard M. Fujimoto. </author> <title> On synthesizing systolic arrays from recurrence equations with linear dependencies. </title> <editor> In K. V. Nori, editor, </editor> <booktitle> Lecture Notes in Computer Science, number 241: Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 488-503. </pages> <publisher> Springer Verlag, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: 1 INTRODUCTION We consider array computations, often referred to as systems of uniform recurrence equations [9]. Parallel execution of uniform recurrence equations has been studied extensively, from at least as far back as 1966 (see, e.g., <ref> [8, 11, 10, 1, 17, 2, 3, 18, 19, 4] </ref>). In such computations, the tasks to be computed are viewed as the nodes of a directed acyclic graph, where the data dependencies are represented as arcs.
Reference: [20] <author> Sartaj Sahni. </author> <title> Computational related problems. </title> <journal> SIAM J. Comput., </journal> <volume> 3 </volume> <pages> 262-279, </pages> <year> 1974. </year>
Reference-contexts: Translating the polyhedron, and omitting superfluous constraints ( i.e., not in their transitive reduction) reduces the algorithm's work. Additional preprocessing may be possible (e.g., via unitary transforms). Moreover, even answering the question "Are any processors scheduled for this time step?" is known to be NP-complete <ref> [20, 6] </ref>. This computational complexity is further ameliorated by the observation that, since a formula can be automatically produced from the generating function, it needs to be constructed only once for a given algorithm.
Reference: [21] <institution> Chris Scheiman Mapping Fundamental Algorithms onto Multiprocessor Architectures. </institution> <type> Ph.D. Thesis, </type> <institution> UC Santa Barbara, Dept. of Computer Science, </institution> <month> Dec., </month> <year> 1993. </year>
Reference: [22] <author> Richard P. </author> <title> Stanley Linear homogeneous diophantine equations and magic labelings of graphs. </title> <journal> Duke Math. J., </journal> <volume> 40 </volume> <pages> 607-632, </pages> <year> 1973. </year>
Reference-contexts: Since X n 2 t n = 1 1 2 t the generating function f (t) is obtained by applying the operator = to the crude generating function F = (1 1 2 )(1 2 1 2 : (16) Now, we make use of the identity that appears in Stanley <ref> [22] </ref> for the computation of the homo geneous case above, namely 1 = (1 AB)(1 A) 1 1 AB We demonstrate the usage of this identity on the example at hand.
Reference: [23] <author> Richard P. </author> <title> Stanley Enumerative Combinatorics, Volume I , Wadsworth & Brooks/Cole, </title> <address> Mon-terey, CA 1986. </address>
Reference: [24] <author> H. Le Verge, C. Mauras, and P. </author> <title> Quinton. The ALPHA language and its use for the design of systolic arrays. </title> <journal> J. VLSI Signal Processing, </journal> <volume> 3 </volume> <pages> 173-182, </pages> <year> 1991. </year> <month> 12 </month>
Reference-contexts: Our use of linear Diophantine equations, we believe, is well-motivated: the computations of an inner loop are typically defined over a set of indices that can be described as the lattice points 4 in a convex polyhedron. Indeed, in two languages, SDEF [5] and Alpha <ref> [24] </ref>, one expressly de-fines domains of computation as the integer points contained in some programmer-specified convex polyhedron.
References-found: 24

