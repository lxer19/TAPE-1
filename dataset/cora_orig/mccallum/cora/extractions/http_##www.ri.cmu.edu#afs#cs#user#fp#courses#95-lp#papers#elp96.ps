URL: http://www.ri.cmu.edu/afs/cs/user/fp/courses/95-lp/papers/elp96.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/courses/95-lp/papers/
Root-URL: 
Email: e-mail: filianojfpg@cs.cmu.edu  e-mail: hodas@cs.hmc.edu  
Phone: 2  
Title: Efficient Resource Management  
Author: Cervesato Joshua S. Hodas and Frank Pfenning 
Affiliation: Computer Science Department, Harvey Mudd College  
Address: Pittsburgh, PA 15213-3891, USA  Claremont, CA 91711, USA  
Note: Iliano  
Abstract: This paper has been submitted to the 1996 International Workshop on Extensions of Logic Programming, Liepzig, Germany, March 28-30 1996. Comments are welcome. for Linear Logic Proof Search Abstract. The design of linear logic programming languages and theorem provers opens a number of new implementation challenges not present in more traditional logic languages such as Horn clauses (Prolog) and hereditary Harrop formulas (Prolog). Among these, the problem of efficiently managing the linear context when solving a goal is of crucial importance for the use of these systems in large-scale applications. This paper studies this problem in the case of Lolli [6] (though its results have application to other systems). We first give a proof-theoretic presentation of the operational semantics of this language as a resolution system. We then present a series of resource management systems designed to eliminate the non-determinism in the distribution of linear formulas that undermines the efficiency of a direct implementation of this system.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J.M. Andreoli and R. Pareschi. </author> <title> Linear Objects: Logical Processes with Built-in Inheritance. </title> <booktitle> New Generation Computing 9 </booktitle> <pages> 3-4, </pages> <year> 1991. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have been released only for Lolli [6] and Lygon [3]. <p> every proof in L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [11]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs are focused <ref> [1] </ref>). Proofs with both properties are called uniform. Hodas and Miller capture this behavior in the system L 0 which eliminates the left-hand rules of the logic in favor of a single rule for backchaining . In Fig. 1 we present a new resolution system [13], called R, for LHHF.
Reference: 2. <author> J.-Y. Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-101, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [2] </ref> views logical assumptions as consumable resources. This allows elegant and concise formalizations of a number of problems which are difficult to represent in traditional logics. In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category.
Reference: 3. <author> James Harland and David Pym. </author> <title> The uniform proof-theoretic foundation of linear logic programming. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <address> San Diego, California, </address> <month> October </month> <year> 1991, </year> <editor> V. Saraswat and K. Ueda, </editor> <booktitle> eds., </booktitle> <pages> pp. 304-318. </pages>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have been released only for Lolli [6] and Lygon [3]. <p> Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have been released only for Lolli [6] and Lygon <ref> [3] </ref>. Linear logic programming languages offer the implementor new challenges not present in more traditional logic languages such as Prolog or Prolog. <p> We will focus our attention on the language Lolli [5, 6], that we used to test the techniques described below. However, our results apply equally well to implementations of Lygon <ref> [3] </ref> and also form the basis of a prototype for a programming language based on Miller's specification logic Forum [10]. It is possible to adapt these techniques to the development of theorem provers for linear logic as well.
Reference: 4. <author> James Harland and Michael Winikoff. </author> <title> Deterministic resource management for the linear logic programming language Lygon. </title> <type> Technical Report TR 94/23, </type> <institution> Melbourne University, Department of Computer Science, </institution> <year> 1994. </year> <month> 14 </month>
Reference-contexts: To our knowledge, the only other authors who have been concerned with the issue of efficiency in context management for linear logic programming languages are the authors of Lygon. In their most recent publication <ref> [4] </ref>, they built on the work of Hodas and Miller and independently developed a system with the characteristics of Hodas' efficient handling of &gt;.
Reference: 5. <author> Joshua S. Hodas, </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, De--sign, and Implementation, </title> <type> Ph.D. </type> <institution> Dissertation from University of Pennsylvania, Department of Computer and Information Science, </institution> <month> May </month> <year> 1994. </year> <note> Available electronically at http://www.cs.hmc.edu/~hodas/papers/. </note>
Reference-contexts: In this paper, we will provide a deterministic solution to this problem, as well as to less apparent issues in context management involving the additive connectives and constants. We will focus our attention on the language Lolli <ref> [5, 6] </ref>, that we used to test the techniques described below. However, our results apply equally well to implementations of Lygon [3] and also form the basis of a prototype for a programming language based on Miller's specification logic Forum [10]. <p> We do not provide proofs of the soundness and completeness theorems that relate these systems. We believe these results are simple enough to be reconstructed by the reader, who is referred to Hodas' dissertation <ref> [5] </ref> for proofs relevant to the first two systems. 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli [5, 6] is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. <p> We believe these results are simple enough to be reconstructed by the reader, who is referred to Hodas' dissertation [5] for proofs relevant to the first two systems. 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli <ref> [5, 6] </ref> is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. The connective is called intuitionistic implication and is defined as A B !A ffi B. <p> Hodas and Miller initially underestimated the importance of this issue [6]. However the subsequent development of sample applications to accompany the first public release of Lolli showed this problem to be critical in practice. The solution we describe is adapted from Hodas' dissertation <ref> [5] </ref>, and was incorporated into that implementation.
Reference: 6. <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic Programming in a Fragment of Linear Logic. </title> <journal> Journal of Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have been released only for Lolli [6] and Lygon [3]. <p> Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have been released only for Lolli <ref> [6] </ref> and Lygon [3]. Linear logic programming languages offer the implementor new challenges not present in more traditional logic languages such as Prolog or Prolog. <p> In this paper, we will provide a deterministic solution to this problem, as well as to less apparent issues in context management involving the additive connectives and constants. We will focus our attention on the language Lolli <ref> [5, 6] </ref>, that we used to test the techniques described below. However, our results apply equally well to implementations of Lygon [3] and also form the basis of a prototype for a programming language based on Miller's specification logic Forum [10]. <p> We believe these results are simple enough to be reconstructed by the reader, who is referred to Hodas' dissertation [5] for proofs relevant to the first two systems. 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli <ref> [5, 6] </ref> is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. The connective is called intuitionistic implication and is defined as A B !A ffi B. <p> Hodas and Miller discuss a proof system, L, for LHHF based on sequents of this form <ref> [6] </ref>. They also prove the soundness and completeness of L with 3 In this and all subsequent proof systems, the right introduction rule for universal quantification is assumed to carry the usual proviso that the introduced constant does not appear free in the lower sequent. <p> The rules in the bottom section of Fig. 1 describe how to reduce non-atomic goal formulas. They stem from the right introduction rules of linear logic, and are essentially identical to the right rules for L 0 <ref> [6] </ref>. R differs from L 0 in the treatment of atomic goal formulas. In order to solve these goals, Hodas and Miller rely on the function k k, which converts a formula in the program to a (possibly infinite) set of clauses, each defining a single ground atom. <p> Assume that contains n formulas. Then there are 2 n possible splits. In the worst case, finding a workable split (or determining that none exists) will require trying them all. This problem was given a deterministic solution by Hodas and Miller in <ref> [6] </ref> in what they called the I/O model of execution for Lolli. <p> In their original paper, Hodas and Miller write this judgment IfGgO, with G being the goal formula, and I and O being the input and the output contexts respectively <ref> [6] </ref>. The main difference with respect to our judgment is that in their presentation I and O are lists of items that can be either program formulas or the special constant del. This is very close to the original ML implementation of Lolli. <p> If it contains n formulas we are left with 2 n possible output contexts O that might be passed to the remaining computation. Hodas and Miller initially underestimated the importance of this issue <ref> [6] </ref>. However the subsequent development of sample applications to accompany the first public release of Lolli showed this problem to be critical in practice. The solution we describe is adapted from Hodas' dissertation [5], and was incorporated into that implementation.
Reference: 7. <author> Keehang Kwon. </author> <title> Towards a Verified Abstract Machine for a Logic Programming Language with a Notion of Scope. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Duke University, </institution> <month> December </month> <year> 1994. </year> <note> Available as Technical Report CS-1994-36. </note>
Reference-contexts: Our analysis was motivated primarily the goal of building an efficient interpreter, but should also be applicable to the design of compilers which, of course, will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [8] and Prolog <ref> [12, 7] </ref> may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [10] and have based a prototype implementation on it.
Reference: 8. <author> Timothy G.Lindholm and Richard A. O'Keefe. </author> <title> Efficient Implementation of a Defensible Semantics for Dynamic Prolog Code. </title> <booktitle> Proceedings of the Fourth International Conference on Logic Programming, J.L. Lassez, </booktitle> <publisher> ed., </publisher> <pages> pp 21-39, </pages> <publisher> MIT Press 1987. </publisher>
Reference-contexts: Our analysis was motivated primarily the goal of building an efficient interpreter, but should also be applicable to the design of compilers which, of course, will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog <ref> [8] </ref> and Prolog [12, 7] may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic.
Reference: 9. <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In P. Schroder-Heister editor, </editor> <booktitle> Proceedings of the International Workshop on Proof-Theoretical Extensions of Logic Programming, </booktitle> <pages> pages 253-281, </pages> <address> Tubingen, Gemany, 1989, </address> <publisher> Springer-Verlag LNAI 475. </publisher>
Reference-contexts: This issue is particularly simple in Prolog : The only predicates that can modify the program are the extra-logical (assert and retract) which have global effect. In languages admitting implications in goals, Prolog <ref> [9] </ref> and Elf [13] for example, the use of scoped assumptions causes the program to grow and contract like a stack. The matter is more complicated in the case of linear languages due to the strict rules the logic places on the use and reuse of assumptions.
Reference: 10. <author> Dale Miller. </author> <title> A Multiple-Conclusion Meta-Logic. </title> <booktitle> Proceedings of the 1994 Symposium on Logics in Computer Science, </booktitle> <editor> S. Abramsky, </editor> <publisher> ed., </publisher> <pages> pp. 272-281. </pages>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in the last five years <ref> [1, 3, 6, 10] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have been released only for Lolli [6] and Lygon [3]. <p> We will focus our attention on the language Lolli [5, 6], that we used to test the techniques described below. However, our results apply equally well to implementations of Lygon [3] and also form the basis of a prototype for a programming language based on Miller's specification logic Forum <ref> [10] </ref>. It is possible to adapt these techniques to the development of theorem provers for linear logic as well. We do not provide proofs of the soundness and completeness theorems that relate these systems. <p> The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum <ref> [10] </ref> and have based a prototype implementation on it. They should extend just as easily to Lygon, which can be seen as a fragment of Forum. And, since Forum is complete for all of classical linear logic, they are also clearly applicable to the design of theorem provers.
Reference: 11. <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming, </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: Most importantly, they proved that LHHF possesses the necessary computational properties to be considered an abstract logic programming language <ref> [11] </ref>. In particular, every proof in L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [11]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs <p> Most importantly, they proved that LHHF possesses the necessary computational properties to be considered an abstract logic programming language <ref> [11] </ref>. In particular, every proof in L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [11]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs are focused [1]). Proofs with both properties are called uniform.
Reference: 12. <author> Gopalan Nadathur, Bharat Jayaraman, and Keehang Kwon. </author> <title> Scoping constructs in logic programming: Implementation problems and their solution. </title> <type> Technical Report CS-1994-35, </type> <institution> Department of Computer Science, Duke University, </institution> <month> October </month> <year> 1994. </year> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: Our analysis was motivated primarily the goal of building an efficient interpreter, but should also be applicable to the design of compilers which, of course, will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [8] and Prolog <ref> [12, 7] </ref> may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [10] and have based a prototype implementation on it.
Reference: 13. <author> Frank Pfenning. </author> <title> Computation and Deduction, </title> <note> draft notes for a course given at Carnegie Mellon University during the Spring semester of 1994. 15 </note>
Reference-contexts: This issue is particularly simple in Prolog : The only predicates that can modify the program are the extra-logical (assert and retract) which have global effect. In languages admitting implications in goals, Prolog [9] and Elf <ref> [13] </ref> for example, the use of scoped assumptions causes the program to grow and contract like a stack. The matter is more complicated in the case of linear languages due to the strict rules the logic places on the use and reuse of assumptions. <p> Proofs with both properties are called uniform. Hodas and Miller capture this behavior in the system L 0 which eliminates the left-hand rules of the logic in favor of a single rule for backchaining . In Fig. 1 we present a new resolution system <ref> [13] </ref>, called R, for LHHF. This system is different from but equivalent to the system L 0 . It is easy to show that the judgment ; =) G is provable in R if and only if the sequent ; ! G is provable in L 0 .
References-found: 13

