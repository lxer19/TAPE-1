URL: ftp://ftp.cs.washington.edu/tr/1994/03/UW-CSE-94-03-07.PS.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/cip/kaleidoscope-ecoop-94.html
Root-URL: 
Email: bnfb@scs.carleton.ca  
Title: Constraints and Object Identity  
Author: Gus Lopez, Bjrn Freeman-Benson and Alan Borning 
Note: To appear in Proceedings of ECOOP94  
Date: 23 March 1994  July 1994  
Address: Seattle, Washington 98195  rhus, Denmark. Current address:  514 Herzberg Building, 1125 Colonel By Drive, Ottawa, Ontario, Canada, K1S 0G9,  Italy,  
Affiliation: Department of Computer Science and Engineering University of Washington  1 rhus University,  Carleton University, School of Computer Science,  Bologna,  
Pubnum: Technical Report 94-03-07  
Abstract: Constraint imperative programming is an integration of declarative constraints and imperative object-oriented programming. The primary goal of this integration is to use constraints to express relations among objects explicitly relations that were implicit in the code in previous languages. However, one of the fundamental concepts of object-oriented programming, object identity, can result in implicit relations, even when explicit identity constraints are supported. We analyze the problem and propose a solu-tionidentity constraintswhich we have implemented in our Kaleidoscope93 language. This solution is understandable, efficiently implementable, and compatible with the Kaleidoscope constraint model. 
Abstract-found: 1
Intro-found: 1
Reference: [Borning et al. 92] <author> Alan Borning, Bjorn Freeman-Benson, and Molly Wilson. </author> <title> Constraint Hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5(3): </volume> <pages> 223-270, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: A read-only annotation on a variable indicates that constraint may not affect the value of that variable, so that operationally, the satisfier must change another variable or variables instead to satisfy the constraint. (A declarative semantics for both read-only annotations and strengths is given in <ref> [Borning et al. 92] </ref>.) A strength of required indicates that the constraint must be satisfied, while other strengths indicate that the con FIGURE 3. <p> The system is perturbed, for example by an assignment or by a user input event; and the constraints are then re-satisfied. The refinement and perturbation models are compared at greater length in <ref> [Borning et al. 92] </ref>.
Reference: [Dahl & Nygaard 66] <author> Ole-Johan Dahl and Kristen Nygaard. </author> <title> SIMULA - An ALGOL-Based Simulation Language. </title> <journal> Communications of the ACM, </journal> <volume> 9(9): </volume> <pages> 671-678, </pages> <month> September </month> <year> 1966. </year>
Reference-contexts: Such languages are designed such that the behavior of a program is independent of the underlying implementation strategy, and more specifically, independent of the order in which the constraints are 1. This perspective on object-oriented programming has been articulated strongly by the designers of Simula <ref> [Dahl & Nygaard 66, Krogdahl & Olsen 86] </ref> and Beta [Madsen et al. 93]. FIGURE 1.
Reference: [Freeman-Benson et al. 90] <author> Bjorn Freeman-Benson, John Maloney, and Alan Borning. </author> <title> An Incremental Constraint Solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1): 5463, </volume> <month> January </month> <year> 1990. </year> <title> Constraints and Object Identity page 14 of 15 </title>
Reference-contexts: Identity Constraints. Specifying that a variable should refer to a specific object should be done using constraints. Insofar as possible, these identity constraints should be analogous to value con straints, and should be integrated smoothly with them. 2. See <ref> [Freeman-Benson et al. 90] </ref> or [Leler 87] for an overview of constraint systems and languages. Constraints and Object Identity page 3 of 15 5. Evolution. The object identity model should seem reasonable to a user of a standard object-ori ented language, and should be a natural evolutionary step. 6. Efficiency. <p> The identity-equality constraints are efficiently solved by our current incremental local propagation constraint hierarchy solver, CobaltBlue. (Further information on our local propagation algorithms can be found in <ref> [Freeman-Benson et al. 90, Sannella 93] </ref>.) Constraints and Object Identity page 10 of 15 Design Goal 6 states that identity constraints should be efficiently implementable. Our constraint solver is quite efficient (see [Sannella 93] for details).
Reference: [Freeman-Benson 91] <author> Bjorn N. Freeman-Benson. </author> <title> Constraint Imperative Programming. </title> <type> Ph.D. thesis, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> July </month> <year> 1991. </year> <note> Published as Department of Computer Science and Engineering Technical Report 91-07-02. </note>
Reference-contexts: Thus, a CIP language must both have object identity, and ensure that all relations are explicit. In previous work <ref> [Freeman-Benson 91, Lopez et al. 93] </ref>, we described the constraint imperative programming framework, and successive designs and implementations of CIP languages: Kaleido-scope90, Kaleidoscope91, and Kaleidoscope93.
Reference: [Freeman-Benson & Borning 92] <author> Bjorn Freeman-Benson and Alan Borning. </author> <title> Integrating Constraints with an Object-Oriented Language. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 268-286, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: We therefore propose the following goals for combining object identity and constraints: 1. Mutable State. The language should support objects with mutable state. 2. Constrained Values. The language should support constraints over object values. (An expanded list of goals for such constraints is given in a previous ECOOP paper <ref> [Freeman-Benson & Borning 92] </ref>; all of those goals remain important for our current design efforts.) 3. Object Identity. The language semantics should include object identity in addition to object equality. 4. Identity Constraints. Specifying that a variable should refer to a specific object should be done using constraints.
Reference: [Hogg 91] <author> John Hogg. </author> <title> Islands: Aliasing Protection In Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, Phoenix, Arizona, </booktitle> <pages> pages 271-285, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Khoshafian and Cope-land [Khoshafian and Copeland 86] relate the concept of object identity as used in programming languages and in databases. In object-oriented languages, the concept of islands is useful in protecting the user from some of the pitfalls of aliasing while supporting essential uses <ref> [Hogg 91] </ref>. Identity constraints serve as a form of alias advertisement [Hogg et al. 92], by making identity relationships explicit. There has also been a great deal of research on detection of aliases in the compiler community [Landi & Ryder 92].
Reference: [Hogg et al. 92] <author> John Hogg, Doug Lea, Alan Wills, Dennis deChampeaux, and Richard Holt. </author> <title> The Geneva Convention on the Treatment of Object Aliasing. </title> <journal> OOPS Messenger, </journal> <volume> 2(3): </volume> <pages> 11-16, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In object-oriented languages, the concept of islands is useful in protecting the user from some of the pitfalls of aliasing while supporting essential uses [Hogg 91]. Identity constraints serve as a form of alias advertisement <ref> [Hogg et al. 92] </ref>, by making identity relationships explicit. There has also been a great deal of research on detection of aliases in the compiler community [Landi & Ryder 92]. Static detection of aliases facilitates code optimizations for cases where code can guarantee no aliasing.
Reference: [Horn 92] <author> Bruce Horn. </author> <title> Constraint Patterns as a Basis for Object-Oriented Constraint Programming. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Vancouver, British Columbia, </address> <pages> pages 218-233, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Other CIP languages, e.g., Siri <ref> [Horn 92, Horn 93] </ref>, have a traditional notion of object identity, but restrict constraints to operate within the bounds of their defining object. As described in the introduction, we now believe that a CIP language should fully support a notion of object identity in its semantics. <p> In CIP languages, Kaleidoscope90 used equality constraints in place of object identity; object identity was regarded as an implementation technique for equality and was not considered to be a part of the language semantics. In other work on CIP languages, Siri <ref> [Horn 92, Horn 93] </ref> has a traditional notion of object identity, but restrict constraints to operate within the bounds of their defining object. Lis language [Li 92] provides always and for-now constraints rather than always and once.
Reference: [Horn 93] <author> Bruce Horn. </author> <title> Constrained Objects. </title> <type> PhD Thesis, </type> <institution> Carnegie-Mellon University, Computer Science Department, </institution> <month> November </month> <year> 1993. </year> <note> Published as Carnegie Mellon School of Computer Science TR CMU-CS-93-154. </note>
Reference-contexts: Other CIP languages, e.g., Siri <ref> [Horn 92, Horn 93] </ref>, have a traditional notion of object identity, but restrict constraints to operate within the bounds of their defining object. As described in the introduction, we now believe that a CIP language should fully support a notion of object identity in its semantics. <p> In CIP languages, Kaleidoscope90 used equality constraints in place of object identity; object identity was regarded as an implementation technique for equality and was not considered to be a part of the language semantics. In other work on CIP languages, Siri <ref> [Horn 92, Horn 93] </ref> has a traditional notion of object identity, but restrict constraints to operate within the bounds of their defining object. Lis language [Li 92] provides always and for-now constraints rather than always and once.
Reference: [Hudak 89] <author> Paul Hudak. </author> <title> Conception, Evolution, and Application of Functional Programming Languages. </title> <journal> Computing Surveys, </journal> <volume> 21(3): 359411, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: An different approach to the problems introduced by object identity is simply to outlaw it. This is the approach taken, for example, in pure functional programming languages, such as Miranda or Haskell <ref> [Hudak 89] </ref>. Similarly, in pure logic programming languages, there is no notion of object identity as such: if variables x and y refer to two ground atoms or terms, it is of no concern to the programmer whether in the implementation there is one shared term or two equal terms.
Reference: [Jaffar & Lassez 87] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Principles of Programming Languages Conference, Munich, </booktitle> <pages> pages 111-119, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: terms containing variables unifying two logic programming objects is best regarded as setting up an equality constraint between them; again, whether structure is shared or not should not be visible to the programmer. (Indeed, one can show that pure Prolog is an instance of the Constraint Logic Programming language scheme <ref> [Jaffar & Lassez 87] </ref>, where the domain of the constraints is the Herbrand Universe.) Constraints and Object Identity page 13 of 15 In concurrent logic programming languages [Shapiro 89] and in the cc (concurrent constraint) languages [Saraswat 89], it is possible to model object-oriented programming, including state, by representing objects as
Reference: [Kahn 89] <author> Kenneth Kahn. </author> <title> Objects A Fresh Look. </title> <booktitle> In Proceedings of the 1989 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 207-223, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: constraints is the Herbrand Universe.) Constraints and Object Identity page 13 of 15 In concurrent logic programming languages [Shapiro 89] and in the cc (concurrent constraint) languages [Saraswat 89], it is possible to model object-oriented programming, including state, by representing objects as perpetual processes that consume a stream of messages <ref> [Kahn 89] </ref>. In these languages, each reference to an object is represented as a message stream.
Reference: [Khoshafian & Copeland 86] <author> Setrag Khoshafian and George Copeland. </author> <title> Object Identity. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, Portland, Oregon, </booktitle> <pages> pages 406-416, </pages> <month> September-October </month> <year> 1986. </year>
Reference: [Klarlund & Schwartzbach 93] <author> Nils Klarlund and Michael Schwartzbach. </author> <title> Graph Types. </title> <booktitle> In Proceedings of the 1993 ACM Principles of Programming Languages Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Constraints and Object Identity page 9 of 15 4.5 Type Invariants Besides addressing our goals, identity constraints enforce particular categories of invariants on instances of a class, similar to Klarlund and Schwartzbachs graph types <ref> [Klarlund & Schwartzbach 93] </ref>. <p> In CIP languages, the ability to bypass expensive constraint operations by compiling imperative code to perform these operations is enhanced by detection of aliasing. Utilizing these techniques will improve performance of generated code for constraint satisfaction. Graph types are a declarative means of describing invariants on object structure <ref> [Klarlund & Schwartzbach 93] </ref>. Identity constraints are similar to graph types in their ability to maintain invariants on structure such as preserving doubly linked list invariants while performing list surgery on doubly linked lists. Unlike identity constraints, graph types do not tie one particular variable to another.
Reference: [Krogdahl & Olsen 86] <author> S. Krogdahl and K.A. Olsen. </author> <title> Modular and Object-Oriented Programming. </title> <journal> DataTid No. </journal> <volume> 9, </volume> <month> Sept. </month> <note> 1986 (in Norwegian). </note>
Reference-contexts: Such languages are designed such that the behavior of a program is independent of the underlying implementation strategy, and more specifically, independent of the order in which the constraints are 1. This perspective on object-oriented programming has been articulated strongly by the designers of Simula <ref> [Dahl & Nygaard 66, Krogdahl & Olsen 86] </ref> and Beta [Madsen et al. 93]. FIGURE 1.
Reference: [Lampson et al. 81] <author> Butler Lampson, James Horning, Ralph London, James Mitchell, and Gerald Popek. </author> <title> Report on the Programming Language Euclid. </title> <type> Technical Report CSL-81-12, </type> <institution> XEROX Palo Alto Research Center, </institution> <month> October </month> <year> 1981. </year>
Reference: [Landi & Ryder 92] <author> William Landi and Barbara Ryder. </author> <title> A Safe Approximate Algorithm for Interprocedural Pointer Aliasing. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, California, </address> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Identity constraints serve as a form of alias advertisement [Hogg et al. 92], by making identity relationships explicit. There has also been a great deal of research on detection of aliases in the compiler community <ref> [Landi & Ryder 92] </ref>. Static detection of aliases facilitates code optimizations for cases where code can guarantee no aliasing. In CIP languages, the ability to bypass expensive constraint operations by compiling imperative code to perform these operations is enhanced by detection of aliasing.
Reference: [Leler 87] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Identity Constraints. Specifying that a variable should refer to a specific object should be done using constraints. Insofar as possible, these identity constraints should be analogous to value con straints, and should be integrated smoothly with them. 2. See [Freeman-Benson et al. 90] or <ref> [Leler 87] </ref> for an overview of constraint systems and languages. Constraints and Object Identity page 3 of 15 5. Evolution. The object identity model should seem reasonable to a user of a standard object-ori ented language, and should be a natural evolutionary step. 6. Efficiency.
Reference: [Li 92] <author> Jiarong Li. </author> <title> Integrating constraints into existing graphical programs. </title> <type> Unpublished manuscript. </type> <institution> Swedish Institute of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: In other work on CIP languages, Siri [Horn 92, Horn 93] has a traditional notion of object identity, but restrict constraints to operate within the bounds of their defining object. Lis language <ref> [Li 92] </ref> provides always and for-now constraints rather than always and once. The active duration of a for-now constraint is until another for-now constraint is enforced on the same variable, i.e., its active duration is the same as its effective duration.
Reference: [Lopez et al. 93] <author> Gus Lopez, Bjorn Freeman-Benson, and Alan Borning. </author> <title> Kaleidoscope: A Constraint Imperative Programming Language. </title> <institution> University of Washington Computer Science & Engineering Technical Report 93-09-04, </institution> <month> September </month> <year> 1993. </year> <note> To appear in Constraint Programming, </note> <editor> B. Mayoh, R. Tugu, J. Penjam (Eds.), </editor> <booktitle> NATO Advanced Study Institute Series, Series F: Computer and System Sciences, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <title> Constraints and Object Identity page 15 of 15 </title>
Reference-contexts: Because a constraint imperative programming (CIP) language, such as Kaleidoscope93 <ref> [Lopez et al. 93] </ref>, is at once both a constraint language and an imperative object-oriented language, it should include the fundamental and essential concepts of each. Thus, a CIP language must both have object identity, and ensure that all relations are explicit. <p> Thus, a CIP language must both have object identity, and ensure that all relations are explicit. In previous work <ref> [Freeman-Benson 91, Lopez et al. 93] </ref>, we described the constraint imperative programming framework, and successive designs and implementations of CIP languages: Kaleido-scope90, Kaleidoscope91, and Kaleidoscope93. <p> On the other hand, identity constraints differ from graph types since they allow one variable to track another variable for some limited duration of time. 5 Implementation In the Kaleidoscope93 VICS constraint framework <ref> [Lopez et al. 93] </ref>, constraints are grouped and solved according to their type: class/type constraints, identity constraints, and value/structure constraints. This independence allows Kaleidoscope to use a different specialized solver for each group, rather than a single more general, but less efficient, algorithm that can handle all kinds of constraints.
Reference: [Madsen et al. 93] <author> Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: This perspective on object-oriented programming has been articulated strongly by the designers of Simula [Dahl & Nygaard 66, Krogdahl & Olsen 86] and Beta <ref> [Madsen et al. 93] </ref>. FIGURE 1.
Reference: [Sannella 93] <author> Michael Sannella. </author> <title> The SkyBlue Constraint Solver. </title> <type> Technical Report 92-07-02, </type> <institution> Department of Computer Science & Engineering, University of Washington, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The identity-equality constraints are efficiently solved by our current incremental local propagation constraint hierarchy solver, CobaltBlue. (Further information on our local propagation algorithms can be found in <ref> [Freeman-Benson et al. 90, Sannella 93] </ref>.) Constraints and Object Identity page 10 of 15 Design Goal 6 states that identity constraints should be efficiently implementable. Our constraint solver is quite efficient (see [Sannella 93] for details). <p> Our constraint solver is quite efficient (see <ref> [Sannella 93] </ref> for details). However, given the ubiquitous nature of constraints in Kaleidoscope (many of which are trivial), higher performance can be achieved by not using the solver at all.
Reference: [Saraswat 89] <author> Vijay Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD Thesis, </type> <institution> Carnegie-Mellon University, Computer Science Department, </institution> <month> January </month> <year> 1989. </year> <title> A revised version is published as Vijay Saraswat, Concurrent Constraint Programming, </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: show that pure Prolog is an instance of the Constraint Logic Programming language scheme [Jaffar & Lassez 87], where the domain of the constraints is the Herbrand Universe.) Constraints and Object Identity page 13 of 15 In concurrent logic programming languages [Shapiro 89] and in the cc (concurrent constraint) languages <ref> [Saraswat 89] </ref>, it is possible to model object-oriented programming, including state, by representing objects as perpetual processes that consume a stream of messages [Kahn 89]. In these languages, each reference to an object is represented as a message stream.
Reference: [Saraswat et al. 94] <author> Vijay Saraswat, Radha Jagadeesan, and Vineet Gupta. </author> <title> Timed Concurrent Constraint Programming. </title> <note> To appear in Constraint Programming, </note> <editor> B. Mayoh, R. Tugu, J. Penjam (Eds.), </editor> <booktitle> NATO Advanced Study Institute Series, Series F: Computer and System Sciences, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Recently, Saraswat and others have generalized the cc paradigm to timed concurrent constraint (tcc) programming <ref> [Saraswat et al. 94] </ref>, permitting the programming of reactive real-time systems.
Reference: [Shapiro 89] <author> Ehud Shapiro. </author> <title> The Family of Concurrent Logic Programming Languages. </title> <journal> Computing Surveys, </journal> <volume> 21(3): 412510, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: not be visible to the programmer. (Indeed, one can show that pure Prolog is an instance of the Constraint Logic Programming language scheme [Jaffar & Lassez 87], where the domain of the constraints is the Herbrand Universe.) Constraints and Object Identity page 13 of 15 In concurrent logic programming languages <ref> [Shapiro 89] </ref> and in the cc (concurrent constraint) languages [Saraswat 89], it is possible to model object-oriented programming, including state, by representing objects as perpetual processes that consume a stream of messages [Kahn 89]. In these languages, each reference to an object is represented as a message stream.
References-found: 25

