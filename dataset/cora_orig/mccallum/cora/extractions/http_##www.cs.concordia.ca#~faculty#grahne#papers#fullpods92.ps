URL: http://www.cs.concordia.ca/~faculty/grahne/papers/fullpods92.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/papers/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Knowledgebase Transformations  
Author: Gosta Grahne Alberto O. Mendelzon and Peter Z. Revesz 
Abstract: We propose a language that expresses uniformly queries and updates on knowl-edgebases consisting of finite sets of relational structures. The language contains an operator that "inserts" arbitrary first-order sentences into a knowledgebase. The semantics of the insertion is based on the notion of update formalized by Katsuno and Mendelzon in the context of belief revision theory. Our language can express, among other things, hypothetical queries and queries on recursively indefinite databases. The expressive power of our language lies between existential second-order and general second-order queries. The data complexity is in general within polynomial space, although it can be lowered to co-NP and to polynomial time by restricting the form of queries and updates.
Abstract-found: 1
Intro-found: 1
Reference: [AbG85] <author> S. Abiteboul & G. Grahne. </author> <title> Update semantics for incomplete databases. </title> <booktitle> In: Proceedings of the 11th International Conference on Very Large Databases, </booktitle> <pages> pages 1-12, </pages> <year> 1985 </year>
Reference-contexts: Note that, for example, positive existential relational calculus formulas are already expressive enough to formulate updates that can have multiple results. As observed in <ref> [AbG85] </ref>, updates with multiple results are the source of indefiniteness in databases. Considerable expressive power is achieved by the combination of first-order logic and the minimization operator implicit in the KM notion of update and the Winslett order.
Reference: [ASV90] <author> S. Abiteboul, E. Simon & V. Vianu. </author> <title> Non-deterministic languages to express deterministic transformations. </title> <booktitle> In: Proceedings of the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 218-229, </pages> <year> 1990. </year>
Reference-contexts: Abiteboul, Simon and Vianu <ref> [ASV90] </ref> have studied restrictions of the update languages that we mentioned at the beginning of this section and characterized their expressive power in terms of complexity classes. <p> Since the t operator corresponds naturally to possibility semantics and u to certainty, it seems that the languages of <ref> [ASV90] </ref> should be closely connected to various subclasses of ST transformations, but we have not yet explored this in detail. 6 Conclusions and Open Problems We propose in this paper a simple and versatile language that unifies queries and updates.
Reference: [AV87] <author> S. Abiteboul & V. Vianu. </author> <title> A transaction language complete for database update and specification. </title> <booktitle> In: Proceedings of the Sixth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year>
Reference-contexts: In the sequel we shall leave out extra parenthesis symbols wherever there is no risk of confusion. 7 2.1 Comparison with Related Work At this point it is possible to compare our approach with some previous work on update languages. Abiteboul and Vianu <ref> [AV87, AV88] </ref> define a class of non-deterministic transformations on databases that they call updates. This class is similar to our transformations in that it includes queries and modifications of the database state as special cases.
Reference: [AV88] <author> S. Abiteboul & V. Vianu. </author> <title> Procedural and declarative database update languages. </title> <booktitle> In: Proceedings of the Seventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 240-250, </pages> <year> 1987. </year>
Reference-contexts: In the sequel we shall leave out extra parenthesis symbols wherever there is no risk of confusion. 7 2.1 Comparison with Related Work At this point it is possible to compare our approach with some previous work on update languages. Abiteboul and Vianu <ref> [AV87, AV88] </ref> define a class of non-deterministic transformations on databases that they call updates. This class is similar to our transformations in that it includes queries and modifications of the database state as special cases. <p> As we noted in Section 2, the transformations described by expressions in this class fall within the class of deterministic updates defined by Abiteboul and Vianu. It follows immediately that every query in ST is expressible in their languages detTL and detDL, which are shown in <ref> [AV88] </ref> to express all deterministic updates. It follows from Theorem 5.2 below that this inclusion is proper, since ST does not go beyond the second order queries SO.
Reference: [AGM85] <author> C. E. Alchourron, P. Gardenfors & D. Makinson. </author> <title> On the logic of theory change: partial meet contraction and revision functions. </title> <journal> Journal of Symbolic Logic, </journal> <volume> (50) 510-530, </volume> <year> 1985. </year>
Reference-contexts: The common fundamental question is: What should be the result of changing a theory T with a sentence ? The departure point of belief revision theory is the rationality postulates proposed by Alchourron, Gardenfors and Makinson <ref> [AGM85] </ref>, and colloquially known as fl This work was supported by the Institute for Robotics and Intelligent Systems and the Natural Sciences and Engineering Council of Canada. A preliminary version of this paper appears in [GMR92]. y Department of Computer Science, University of Helsinki, Teollisuuskatu 23, SF-00510 Helsinki, grahne@cs.helsinki.fi.
Reference: [ABW88] <author> K. R. Apt, H. Blair & A Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In: J. Minker (Ed.), </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, Chapter 2. </booktitle> <publisher> Morgan Kaufman Publishers, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: As is demonstrated in [IN88] such intended models might force the programmer to express his or her intentions in a cumbersome way. We do however note that the iterative fixpoint <ref> [ABW88] </ref> of a stratified program can be obtained in our language by sequentially updating the database with the strata of the program in their hierarchical order.
Reference: [BS81] <author> F. Bancilhon & N. Spyratos. </author> <title> Update semantics of relational views. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> (4) 557-575, </volume> <year> 1981. </year>
Reference-contexts: 1 Introduction It is a fact in database theory that as soon as the data model becomes slightly more general than a simple relational structure -for example, if one allows views in addition to stored relations- it becomes difficult to give meaning to updates <ref> [BS81, FUV83, FKUV86] </ref>. For a typical example, suppose the database is represented by the theory fA; B; A ^ B ! Cg. Let the update request be the "insertion" of the sentence :C. Then simply adding :C to the theory results in inconsistency.
Reference: [Bon88] <author> A. J. Bonner. </author> <title> Hypothetical Datalog: complexity and expressibility. </title> <booktitle> In: Proceedings of the Second International Conference on Database Theory, </booktitle> <pages> pages 144-160, </pages> <year> 1988. </year>
Reference-contexts: We do however note that the iterative fixpoint [ABW88] of a stratified program can be obtained in our language by sequentially updating the database with the strata of the program in their hierarchical order. It is also interesting to note that hypothetical queries <ref> [Bon88, Gab85] </ref> and queries on re 8 cursively indefinite databases [Mey90] can be expressed through updates. The connection between hypothetical queries and updates is explored in [GM95]. 3 Sample Transformations In this section we present seven example transformations.
Reference: [CH82] <author> A. K. Chandra & D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (25) 99-28, </volume> <year> 1982. </year>
Reference-contexts: Considerable expressive power is achieved by the combination of first-order logic and the minimization operator implicit in the KM notion of update and the Winslett order. It turns out that, for example, all fixpoint queries <ref> [CH82] </ref> are expressible in our transformation language. It is well-known that "inserting" a datalog program into an "extensional database" produces a unique minimal model, which model also can be characterized as a least fixpoint of the program. <p> For other complexity theoretic issues in belief revision and updates we refer the reader to [EG92, EG93, GM95]. 5 Expressive Power Let YF, SF, and SO be the class of all transformations from databases to databases expressible, respectively, by fixpoint queries, existential second-order queries, and second-order queries, as defined in <ref> [CH82, Var82] </ref>. It is well-known that YF is properly included in SF and that SF is also included in SO [Var82].
Reference: [EG92] <author> T. Eiter & G. Gottlob. </author> <title> On the Complexity of Propositional Knowledge Base Revision, Updates, and Counterfactuals. </title> <booktitle> In: Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year> <month> 24 </month>
Reference-contexts: The quantifier-free case of our language does not have subjunctive implication operators in it, otherwise it would be a proper superset of the language in [GM95]. For other complexity theoretic issues in belief revision and updates we refer the reader to <ref> [EG92, EG93, GM95] </ref>. 5 Expressive Power Let YF, SF, and SO be the class of all transformations from databases to databases expressible, respectively, by fixpoint queries, existential second-order queries, and second-order queries, as defined in [CH82, Var82].
Reference: [EG93] <author> T. Eiter & G. Gottlob. </author> <title> The Complexity of Nested Counterfactuals and Iterated Knowledge Base Revisions. </title> <booktitle> In: Proceedings of International Joint Conference on Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference-contexts: The quantifier-free case of our language does not have subjunctive implication operators in it, otherwise it would be a proper superset of the language in [GM95]. For other complexity theoretic issues in belief revision and updates we refer the reader to <ref> [EG92, EG93, GM95] </ref>. 5 Expressive Power Let YF, SF, and SO be the class of all transformations from databases to databases expressible, respectively, by fixpoint queries, existential second-order queries, and second-order queries, as defined in [CH82, Var82].
Reference: [FUV83] <author> R. Fagin, J. D. Ullman & M. Y. Vardi. </author> <title> On the semantics of updates in databases. </title> <booktitle> In: Proceedings of the Second ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 352-365, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction It is a fact in database theory that as soon as the data model becomes slightly more general than a simple relational structure -for example, if one allows views in addition to stored relations- it becomes difficult to give meaning to updates <ref> [BS81, FUV83, FKUV86] </ref>. For a typical example, suppose the database is represented by the theory fA; B; A ^ B ! Cg. Let the update request be the "insertion" of the sentence :C. Then simply adding :C to the theory results in inconsistency. <p> In Section 5, we consider a class of fi expressions that falls within this subclass: those expressible by a transformation of the form (bt [ t ) fl , where each b is one of u or t. The work of Fagin et al. <ref> [FUV83, FKUV86] </ref> considers updates of logical databases, where the database is described by a set of sentences. The essential idea in [FUV83] is to consider all maximal subsets of the set of sentences in the database that is consistent with the sentence that is inserted. <p> The work of Fagin et al. [FUV83, FKUV86] considers updates of logical databases, where the database is described by a set of sentences. The essential idea in <ref> [FUV83] </ref> is to consider all maximal subsets of the set of sentences in the database that is consistent with the sentence that is inserted. Although this definition seems intuitive, we do not follow this because it does not satisfy the Katsuno-Mendelzon postulates for updates. <p> This is in fact one of the harder postulates to satisfy and in [KM91a, KM91b] it is shown that several other update operator proposals also do not satisfy this principle. Another difference between the update operator in <ref> [FUV83] </ref> and in this paper is that in the former priorities, that is integer numbers, are assigned to sentences and these are also taken into account in the definition of maximum consistent subset. Furthermore, [FUV83] considered inserting only a single sentence into the database. <p> Another difference between the update operator in <ref> [FUV83] </ref> and in this paper is that in the former priorities, that is integer numbers, are assigned to sentences and these are also taken into account in the definition of maximum consistent subset. Furthermore, [FUV83] considered inserting only a single sentence into the database. This limitation was removed by [FKUV86] that defined the flock semantics for updates that allows insertion of a group of sentences.
Reference: [FKUV86] <author> R. Fagin, G. Kuper, J. D. Ullman & M. Y. Vardi. </author> <title> Updating logical databases. </title> <booktitle> In: Advances in Computing Research, </booktitle> <volume> Vol. 3, </volume> <editor> P. C. Kanellakis and F. Preparata eds., </editor> <address> pages 1-18, </address> <publisher> JAI Press, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction It is a fact in database theory that as soon as the data model becomes slightly more general than a simple relational structure -for example, if one allows views in addition to stored relations- it becomes difficult to give meaning to updates <ref> [BS81, FUV83, FKUV86] </ref>. For a typical example, suppose the database is represented by the theory fA; B; A ^ B ! Cg. Let the update request be the "insertion" of the sentence :C. Then simply adding :C to the theory results in inconsistency. <p> In Section 5, we consider a class of fi expressions that falls within this subclass: those expressible by a transformation of the form (bt [ t ) fl , where each b is one of u or t. The work of Fagin et al. <ref> [FUV83, FKUV86] </ref> considers updates of logical databases, where the database is described by a set of sentences. The essential idea in [FUV83] is to consider all maximal subsets of the set of sentences in the database that is consistent with the sentence that is inserted. <p> Furthermore, [FUV83] considered inserting only a single sentence into the database. This limitation was removed by <ref> [FKUV86] </ref> that defined the flock semantics for updates that allows insertion of a group of sentences. Our update operator also allows the simultaneous insertion of a group of sentences by treating each group of sentences as the conjunction of the sentences.
Reference: [FR79] <author> J. Ferrante, C.W. Rackoff. </author> <title> The Computational Complexity of Logical Theories, </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: That is, we want S-; o to be true if and only if the binary number o is the successor of -, in shorthand - + 1 = o. The successor function can be expressed by a sentence of size O (n) as described in <ref> [FR79] </ref>. Similarly, we use the 2n + 1-ary relation M to describe the next tape position after the machine moves one tape cell in direction m.
Reference: [Gab85] <author> D. M. Gabbay. N-Prolog: </author> <title> an extension of Prolog with hypothetical implications. II. Logical foundations and negation as failure. </title> <journal> Journal of Logic Programming. </journal> <volume> (2) 251-283, </volume> <year> 1985. </year>
Reference-contexts: We do however note that the iterative fixpoint [ABW88] of a stratified program can be obtained in our language by sequentially updating the database with the strata of the program in their hierarchical order. It is also interesting to note that hypothetical queries <ref> [Bon88, Gab85] </ref> and queries on re 8 cursively indefinite databases [Mey90] can be expressed through updates. The connection between hypothetical queries and updates is explored in [GM95]. 3 Sample Transformations In this section we present seven example transformations.
Reference: [Gar88] <author> P. Gardenfors. </author> <title> Knowledge in Flux: Modeling the Dynamics of Epistemic States. </title> <publisher> Bradford Books, MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: The update problem is not unique to database theory. One also encounters it in Artificial Intelligence [Rei92] and in belief revision theory <ref> [Mak85, Gar88] </ref>. <p> Suppose now we want to define a language for expressing updates to databases. It seems that in defining such a language we have first to decide whether to use update or revision, or both. But, as it turns out, Gardenfors <ref> [Gar88] </ref> has shown that if a logic has a semantics built upon Boolean algebra, then there is no way of defining a language based on revision that does not lead to triviality.
Reference: [GJ79] <author> M.R. Garey, D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: Namely, we can prove that the data complexity of fi is 62 NP [ co-NP and its expression complexity is 62 NEXPTIME [ co-NEXPTIME, assuming the standard hypothesis in complexity theory that NP and NEXPTIME are not closed under complement <ref> [GJ79] </ref>. <p> Proof: This follows by a reduction from the problem of satisfiability of propositional formulas <ref> [GJ79] </ref>. Take the case when db and kb both contain a single zero-ary relation r 0 that is assigned to be true (i.e., contains the empty tuple). Any propositional formula can be expressed by a sentence 0 using zero-ary relation symbols different from R 0 .
Reference: [Gra91] <author> G. Grahne. </author> <title> Updates and counterfactuals. </title> <booktitle> In: Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 269-276, </pages> <year> 1991. </year>
Reference-contexts: But, as it turns out, Gardenfors [Gar88] has shown that if a logic has a semantics built upon Boolean algebra, then there is no way of defining a language based on revision that does not lead to triviality. On the other hand, Grahne <ref> [Gra91] </ref> has axiomatized a nontrivial logic in which update is an operator in the object language. We shall therefore choose update as the notion of change. The KM postulates do not prescribe any particular update operator; they characterize a class of acceptable operators.
Reference: [GM95] <author> G. Grahne & A. O. Mendelzon. </author> <title> Updates and subjunctive queries. </title> <booktitle> Information and Computation 116 (1995), </booktitle> <pages> 241-252. </pages>
Reference-contexts: It is also interesting to note that hypothetical queries [Bon88, Gab85] and queries on re 8 cursively indefinite databases [Mey90] can be expressed through updates. The connection between hypothetical queries and updates is explored in <ref> [GM95] </ref>. 3 Sample Transformations In this section we present seven example transformations. First we show that the common queries of transitive closure (Example 1) and parity (Example 6) can be expressed. We also show that the robots query described in the introduction can also be expressed (Example 4). <p> Similarly to Theorem 4.5 this leads to the conclusion that the problem is not in NP [ co-NP unless NP is closed under complement. 2 Remark: Grahne and Mendelzon <ref> [GM95] </ref> have studied the complexity of evaluating subjunctive queries in a propositional language, and found the data complexity of such a language to be in PTIME and the expression complexity to be in PSPACE. <p> The quantifier-free case of our language does not have subjunctive implication operators in it, otherwise it would be a proper superset of the language in <ref> [GM95] </ref>. <p> The quantifier-free case of our language does not have subjunctive implication operators in it, otherwise it would be a proper superset of the language in [GM95]. For other complexity theoretic issues in belief revision and updates we refer the reader to <ref> [EG92, EG93, GM95] </ref>. 5 Expressive Power Let YF, SF, and SO be the class of all transformations from databases to databases expressible, respectively, by fixpoint queries, existential second-order queries, and second-order queries, as defined in [CH82, Var82].
Reference: [GMR92] <author> G. Grahne, A. O. Mendelzon, & P. Z. Revesz. </author> <title> Knowledgebase Transformations. </title> <booktitle> In: Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 246-260, </pages> <year> 1992. </year>
Reference-contexts: A preliminary version of this paper appears in <ref> [GMR92] </ref>. y Department of Computer Science, University of Helsinki, Teollisuuskatu 23, SF-00510 Helsinki, grahne@cs.helsinki.fi.
Reference: [IN88] <author> T. Imielinski & S. Naqvi. </author> <title> Explicit control of logic programs through rule algebra. </title> <booktitle> In: Proceedings of the Seventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 103-116, </pages> <year> 1988. </year>
Reference-contexts: This is in contrast to the more common approach to designate one of the models, or some other relational structure, as the "intended model" of the program. As is demonstrated in <ref> [IN88] </ref> such intended models might force the programmer to express his or her intentions in a cumbersome way.
Reference: [KM91a] <author> H. Katsuno & A. O. Mendelzon. </author> <title> On the difference between updating a knowledge base and revising it. </title> <booktitle> In: Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 387-394, </pages> <year> 1991. </year>
Reference-contexts: For example: the new fact must be a consequence of the revised theory. And: if the new fact is consistent with T , then the result should be logically equivalent to T [ fg. However, Katsuno and Mendelzon point out in <ref> [KM91a] </ref> that all of these postulates are not universally desirable for all kinds of belief revision applications. In particular, Katsuno and Mendelzon distinguish two kinds of theory change operations, update and revision. Update consists of bringing the knowledgebase up to date when the world described by it changes. <p> But upon reflection it becomes clear that this is incorrect. After V has landed, all we know is that V has landed ; there is no reason to conclude that W has not. The correct answer should be fvg. The authors of <ref> [KM91a] </ref> came to the conclusion that the AGM postulates describe only revision, and gave a modified set of postulates that characterize update operators (the KM postulates). Suppose now we want to define a language for expressing updates to databases. <p> It similarly can be checked that the standard selection operation is also expressible in our transformation language. In general, it turns out that the following properties, corresponding to the KM-postulates <ref> [KM91a] </ref> for update, hold. <p> This is in fact one of the harder postulates to satisfy and in <ref> [KM91a, KM91b] </ref> it is shown that several other update operator proposals also do not satisfy this principle.
Reference: [KM91b] <author> H. Katsuno & A. O. Mendelzon. </author> <title> Propositional knowledgebase revision and minimal change. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> (52) 263-294, </pages> <year> 1991. </year>
Reference-contexts: This is in fact one of the harder postulates to satisfy and in <ref> [KM91a, KM91b] </ref> it is shown that several other update operator proposals also do not satisfy this principle.
Reference: [Mak85] <author> D. Makinson. </author> <title> How to give it up: A survey of some formal aspects of the logic of theory change. </title> <journal> Synthese, </journal> <volume> (62) 347-363, </volume> <year> 1985 </year>
Reference-contexts: The update problem is not unique to database theory. One also encounters it in Artificial Intelligence [Rei92] and in belief revision theory <ref> [Mak85, Gar88] </ref>.
Reference: [McC80] <author> J. McCarthy. </author> <title> Circumscription | a form of non-monotonic reasoning. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> (13) 27-39, </pages> <year> 1980. </year> <month> 25 </month>
Reference-contexts: the form i j u t , then the corresponding second-order query is x 1 x 2 : : : x k :8R 0 i n : ((R 0 i n ) ^ min (; : : :)) ! R 0 Note the similarity between these second-order queries and circumscription <ref> [McC80] </ref>.
Reference: [Mey90] <author> R. van der Meyden. </author> <title> Recursively indefinite databases. </title> <booktitle> In: Proceedings of the Third International Conference on Database Theory, </booktitle> <pages> pages 364-378, </pages> <year> 1990. </year>
Reference-contexts: It is also interesting to note that hypothetical queries [Bon88, Gab85] and queries on re 8 cursively indefinite databases <ref> [Mey90] </ref> can be expressed through updates. The connection between hypothetical queries and updates is explored in [GM95]. 3 Sample Transformations In this section we present seven example transformations. First we show that the common queries of transitive closure (Example 1) and parity (Example 6) can be expressed. <p> Example 3. Suppose now that we would like to know whether a certain set of edges belongs to every transitive reduction of a graph. This query can be expressed in the language of recursively indefinite databases <ref> [Mey90] </ref>. The query can also be formulated as a transformation expression. Suppose that the relation r 3 describes the set of edges in question.
Reference: [Rei78] <author> R. Reiter. </author> <title> On closed world databases. </title> <editor> In: H. Gallaire & J. Minker, (Eds.), </editor> <title> Logic and Databases, </title> <publisher> Plenum Press, </publisher> <address> New York 1978, </address> <pages> pages 55-76. </pages>
Reference-contexts: We follow the closed world assumption: only the facts that are explicitly stored are true in a database <ref> [Rei78] </ref>. Having settled on a data model and a notion of update, we propose a language that will allow both queries and updates to be expressed uniformly. In fact, in our language there is no formal distinction between queries and updates; they are both regarded as transformations.
Reference: [Rei92] <author> R. Reiter. </author> <title> On specifying database updates. </title> <booktitle> In: Proceedings of the Third International Conference on Extending Database Technology, to appear in 1992. </booktitle>
Reference-contexts: Reasonable ways to incorporate the request could result in fA; A ^ B ! C; :Cg, fB; A ^ B ! C; :Cg, fA; B; :Cg, or the disjunction of the three. The update problem is not unique to database theory. One also encounters it in Artificial Intelligence <ref> [Rei92] </ref> and in belief revision theory [Mak85, Gar88].
Reference: [Var82] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In: Proceedings of the Fourteenth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 137-145, </pages> <year> 1982. </year>
Reference-contexts: For other complexity theoretic issues in belief revision and updates we refer the reader to [EG92, EG93, GM95]. 5 Expressive Power Let YF, SF, and SO be the class of all transformations from databases to databases expressible, respectively, by fixpoint queries, existential second-order queries, and second-order queries, as defined in <ref> [CH82, Var82] </ref>. It is well-known that YF is properly included in SF and that SF is also included in SO [Var82]. <p> It is well-known that YF is properly included in SF and that SF is also included in SO <ref> [Var82] </ref>. In order to relate our language to the above classes of transformations, we shall restrict ourselves to the case where all input knowledgebases are singletons, i.e. databases, and we will restrict the language so that all output knowledgebases are also singletons. <p> The size of x could be smaller if we added extra projection operations.) By the standard definition <ref> [Var82] </ref> the image of this query under a database hD; r 1 ; : : : ; r n i is fd 2 D jxj : there is a relation r n+1 D a such that (d) is true in (D; r 1 ; : : : ; r n+1 )g. <p> Instead of a fixed domain as in <ref> [Var82] </ref>, we take D to be the set of constants in and in the input relations r 1 ; : : : ; r n . Therefore the possible values of r n+1 are finite and can be listed.
Reference: [Win89] <author> M. Winslett. </author> <title> Reasoning about action using a possible models approach. </title> <booktitle> In: Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 89-93, </pages> <year> 1988. </year>
Reference-contexts: The theory that describes all models obtained in this way is the result of the change operation. Choosing an update operator then reduces to choosing a notion of closeness of models. In this paper, we adopt Winslett's possible models approach <ref> [Win89] </ref>. <p> This corresponds to the way interpretations are compared in Winslett's possible models approach <ref> [Win89] </ref>. If the schemas of db 1 and db 2 are proper supersets of db, the comparison will proceed in two stages. First, we try to keep the relations in db invariant.
References-found: 30

