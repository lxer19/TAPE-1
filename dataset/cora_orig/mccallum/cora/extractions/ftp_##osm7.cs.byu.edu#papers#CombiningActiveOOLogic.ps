URL: ftp://osm7.cs.byu.edu/papers/CombiningActiveOOLogic.ps
Refering-URL: http://osm7.cs.byu.edu/Papers.html
Root-URL: 
Email: (embley@cs.byu.edu)  (liddle@byu.edu)  (ng@cs.byu.edu)  
Title: On Harmonically Combining Active, Object-Oriented, and Deductive Databases (Extended Abstract)  
Author: David W. Embleyz Stephen W. Liddley Yiu-Kai Ngz 
Address: Provo, UT 84602  
Affiliation: yInformation Systems Group zDepartment of Computer Science Brigham Young University  
Abstract: Although there are a number of issues to resolve, active databases, object-oriented databases, and deductive databases can be smoothly integrated. We present the integration challenges, provide a resolution to the issues, and show how to achieve this integration by describing the active, object-oriented, and deductive features of a model/language called Harmony. Harmony lets us see these integration issues in a different light, because it provides an alternative way of modeling an application. It thus lets us give an alternate solution for smoothly combining event-condition-action rules, object orientation, and logic, that better supports the development of advanced applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Ariein, J. Gava, N. Gehani, and D. Lieuwen, </author> <title> Ode 4.1 Ode&lt;EOS&gt; User Manual, </title> <institution> AT&T Bell Laboratories, </institution> <address> Murry Hill, New Jersey, </address> <year> 1996. </year>
Reference-contexts: Several object-oriented database systems have become commerically available (e.g., [4, 21]) and efforts have been made to unify this integration [6]. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., [17, 18]) and active object-oriented databases (e.g., 1 <ref> [1, 9] </ref>). Integration issues have been plentiful and there is a wide variety of solutions rang-ing from obviously ad hoc (e.g., early embedding of SQL in C) to formal and sophisticated (e.g., [12]). The integration issues are highly complex, especially for combining all three types: active, object-oriented, and deductive.
Reference: [2] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, and S. Zdonik. </author> <title> The Object-Oriented Database System Manifesto. </title> <booktitle> Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pp. 223-240, </pages> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year> <title> Reprinted in Building an Object-Oriented Database System: The Story of O2, </title> <editor> F. Bancilhon, C. Delobel, and P. Kanellakis, (eds.), </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1992. </year> <month> 16 </month>
Reference-contexts: The question with respect to object identity is not so much whether Harmony has traditional deductive database semantics | it clearly does | but whether Harmony really has object identity. Our answer is that our system exhibits the fundamental concepts of object identity as presented in traditional object-oriented discussions <ref> [2, 10] </ref>. In Harmony an object has an existence independent of its value.
Reference: [3] <author> F. Bancilhon and R. Ramakrishnan, </author> <title> "Performance Evaluation of Data Intensive Logic Programs," Foundations of Deductive Databases and Logic Programming, </title> <editor> J. Minker, (ed.), </editor> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, California, </address> <year> 1988. </year>
Reference-contexts: Facts consist of objects and relationships in a Harmony application model. Logic rules are clauses of the form head :- body where head is a single n-ary atom, n 1, and body is a conjunction of one or more literals. Rules must be range-restricted <ref> [3] </ref>, Harmony logic programs must be stratified [19], and all variables in a rule must be limited (i.e., finite [19]).
Reference: [4] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis (eds.), </editor> <title> Building an Object-Oriented Database System: The Story of O2, </title> <publisher> Morgan Kaufman Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Over the past decade, there has been growing interest in combining object-oriented languages, logic languages, and active event-condition-action processing with database sys tems. Progress has been made on several fronts. Several object-oriented database systems have become commerically available (e.g., <ref> [4, 21] </ref>) and efforts have been made to unify this integration [6]. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., [17, 18]) and active object-oriented databases (e.g., 1 [1, 9]).
Reference: [5] <author> A.J. Bonner and M. Kifer, </author> <title> "An Overview of Transaction Logic," </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 133, </volume> <pages> pp. 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: (3) Extensible, dynamic type systems interfere with query formulation and query optimization [20]. (4) Imperative components have side effects that incrementally change the state of a system, but logic components do not have such side effects [23]. (5) The absence of declarative processing semantics prevents logic systems from behaving procedurally <ref> [5] </ref>. (6) Ad-hoc integration lacks a unified formal foundation [12]. Commonly accepted definitions of active, object-oriented, and deductive databases are mostly inadequate for smoothly resolving these issues and usually lead to partially, if not completely, ad-hoc solutions. <p> In this paper we propose an alternative way of thinking about active, object-oriented, and deductive databases, and show how this alternative resolves these issues. To resolve the impedance-mismatch problems, we treat variables as being set-valued rather than scalar 1 <ref> [5, 11, 12] </ref> is an exception, but we take a different approach, basing our formalism on a temporal first-order predicate calculus rather than on a new non-standard logic. 2 valued. To resolve the object-identity and query-language issues, our alternative replaces the instance-variables view of object orientation by an object-relationship view.
Reference: [6] <author> R.G.G. Cattell (ed.), </author> <title> The Object Database Standard: ODMG-93, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, California, </address> <year> 1994. </year>
Reference-contexts: Progress has been made on several fronts. Several object-oriented database systems have become commerically available (e.g., [4, 21]) and efforts have been made to unify this integration <ref> [6] </ref>. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., [17, 18]) and active object-oriented databases (e.g., 1 [1, 9]).
Reference: [7] <author> S.W. Clyde, D.W. Embley, </author> <title> and S.N. Woodfield, "The Complete Formal Definition for the Syntax and Semantics of OSA," </title> <type> Technical Report BYU-CS-92-2, </type> <institution> Computer Science Department, Brigham Young University, </institution> <year> 1992. </year>
Reference-contexts: Both the model and language are formally defined in a model-theoretic way <ref> [7] </ref> and both are com-putationally complete [15]. An advantage of being model-equivalent is that the declarative aspects of the model tend to be more procedural while at the same time the procedural aspects of the language tend to be more declarative, making integration easier, more understandable, and more easily formalizable.
Reference: [8] <author> D.W. Embley, </author> <title> B.D. Kurtz, and S.N. Woodfield, Object-Oriented Systems Analysis: A Model-Driven Approach, </title> <publisher> Yourdon Press Series, Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: The model also has both a graphical and a textual representation, which are equivalent in every respect. We originally designed the model as an ontological, object-oriented systems analysis model called OSA (Object-oriented Systems Analysis) <ref> [8] </ref>, and we later extended it to be a model for all phases of the development process and called it OSM (Object-oriented Systems Model) [16]. To make the model fully executable, we added a low-level language component called Melody [13] and provided a fully textual version of the model [15].
Reference: [9] <author> S. Gatziu, H. Fritschi, and A. Vaduva, </author> <title> SAMOS an Active Object-Oriented Database System: Manual, </title> <type> Technical Report 96.02, </type> <institution> Computer Science Department, University of Zurich, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: Several object-oriented database systems have become commerically available (e.g., [4, 21]) and efforts have been made to unify this integration [6]. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., [17, 18]) and active object-oriented databases (e.g., 1 <ref> [1, 9] </ref>). Integration issues have been plentiful and there is a wide variety of solutions rang-ing from obviously ad hoc (e.g., early embedding of SQL in C) to formal and sophisticated (e.g., [12]). The integration issues are highly complex, especially for combining all three types: active, object-oriented, and deductive.
Reference: [10] <author> S. </author> <title> Khoshafian and G.P. Copeland, "Object Identity," </title> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <pages> pp. 406-416, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: code fragment above, Person (x).Account Balance is a singleton object set used in a scalar context, and 100 is a singleton object set that looks like a scalar. 3.2 Object Identity Object identity is the property of objects that divorces identity from physical attributes such as content, location, and addressability <ref> [10] </ref>. Thus, in systems with object identity, two objects are the same only if they have the same identity, regardless of any other object 9 properties such as the value of an object's attributes. <p> The question with respect to object identity is not so much whether Harmony has traditional deductive database semantics | it clearly does | but whether Harmony really has object identity. Our answer is that our system exhibits the fundamental concepts of object identity as presented in traditional object-oriented discussions <ref> [2, 10] </ref>. In Harmony an object has an existence independent of its value.
Reference: [11] <author> M. Kifer, G. Lausen, and J. Wu, </author> <title> "Logical Foundations of Object-oriented and Frame-based Languages," </title> <journal> Journal of the ACM, </journal> <month> May </month> <year> 1995. </year>
Reference-contexts: In this paper we propose an alternative way of thinking about active, object-oriented, and deductive databases, and show how this alternative resolves these issues. To resolve the impedance-mismatch problems, we treat variables as being set-valued rather than scalar 1 <ref> [5, 11, 12] </ref> is an exception, but we take a different approach, basing our formalism on a temporal first-order predicate calculus rather than on a new non-standard logic. 2 valued. To resolve the object-identity and query-language issues, our alternative replaces the instance-variables view of object orientation by an object-relationship view.
Reference: [12] <author> M. Kifer, </author> <title> "Deductive and Object Data Languages: A Quest for Integration," </title> <booktitle> Proceedings of the 4th International Conference on Deductive and Object-Oriented Databases, </booktitle> <address> Singapore, </address> <month> December </month> <year> 1995, </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> no. 1013, </volume> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: Integration issues have been plentiful and there is a wide variety of solutions rang-ing from obviously ad hoc (e.g., early embedding of SQL in C) to formal and sophisticated (e.g., <ref> [12] </ref>). The integration issues are highly complex, especially for combining all three types: active, object-oriented, and deductive. These issuses warrant further investigation. The eventual goal is an elegant, fully integrated, formally defined active and deductive object-oriented database system. <p> and query optimization [20]. (4) Imperative components have side effects that incrementally change the state of a system, but logic components do not have such side effects [23]. (5) The absence of declarative processing semantics prevents logic systems from behaving procedurally [5]. (6) Ad-hoc integration lacks a unified formal foundation <ref> [12] </ref>. Commonly accepted definitions of active, object-oriented, and deductive databases are mostly inadequate for smoothly resolving these issues and usually lead to partially, if not completely, ad-hoc solutions. <p> In this paper we propose an alternative way of thinking about active, object-oriented, and deductive databases, and show how this alternative resolves these issues. To resolve the impedance-mismatch problems, we treat variables as being set-valued rather than scalar 1 <ref> [5, 11, 12] </ref> is an exception, but we take a different approach, basing our formalism on a temporal first-order predicate calculus rather than on a new non-standard logic. 2 valued. To resolve the object-identity and query-language issues, our alternative replaces the instance-variables view of object orientation by an object-relationship view.
Reference: [13] <author> S.W. Liddle, </author> <title> "Object-Oriented Systems Implementation: A Model-Equivalent Approach," </title> <type> Ph.D. Dissertation, </type> <institution> Computer Science Department, Brigham Young University, </institution> <year> 1995. </year>
Reference-contexts: To make the model fully executable, we added a low-level language component called Melody <ref> [13] </ref> and provided a fully textual version of the model [15]. Taken all together and presented either graphically, textually, or as a mixture of graphics and text, we call the model/language Harmony.
Reference: [14] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, "Integrating Object-Oriented Type Systems and Data Models in Harmony," </title> <note> manuscript submitted for review. </note>
Reference-contexts: Moreover, we provide these operators without violating the principle of encapsulation. We do so by fundamentally reexamining encapsulation and reconstituting it as object integrity, implementation independence, and information grouping and visibility <ref> [14] </ref>.
Reference: [15] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, "Unifying Modeling and Programming through an Active, Object-Oriented, </title> <booktitle> Model-Equivalent Programming Language," 17 Proceedings of the 14th International Conference on Object-Oriented and Entity--Relationship Modeling, </booktitle> <pages> pp. 55-64, </pages> <address> Gold Coast, Australia, </address> <month> December </month> <year> 1995, </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> no. 1021, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: To make the model fully executable, we added a low-level language component called Melody [13] and provided a fully textual version of the model <ref> [15] </ref>. Taken all together and presented either graphically, textually, or as a mixture of graphics and text, we call the model/language Harmony. We proceed as follows to show how Harmony provides a point of view that smoothly resolves the integration issues that have been raised. <p> Both the model and language are formally defined in a model-theoretic way [7] and both are com-putationally complete <ref> [15] </ref>. An advantage of being model-equivalent is that the declarative aspects of the model tend to be more procedural while at the same time the procedural aspects of the language tend to be more declarative, making integration easier, more understandable, and more easily formalizable. <p> Harmony's remove statement deletes facts from the system in an analogous way. Harmony's assignment statement takes the form container := query; and is a convenient shorthand for combining common sequences of add/remove statements in a single transaction <ref> [15] </ref>. 3 Discussion 3.1 Impedance Mismatches There is a fundamental mismatch between set-oriented processing in database and logic programming systems and scalar-oriented processing in imperative programming languages. The result of a query, whether it is a relational query or a deductive query, is a set.
Reference: [16] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, "A Seamless Model for Object-Oriented Systems Development," </title> <booktitle> Proceedings of the International Symposium on Object-Oriented Methodologies and Systems, ISOOMS 94, </booktitle> <pages> pp. 123-131, </pages> <address> Palermo, Italy, </address> <month> September </month> <year> 1994, </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> no. 858, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: We originally designed the model as an ontological, object-oriented systems analysis model called OSA (Object-oriented Systems Analysis) [8], and we later extended it to be a model for all phases of the development process and called it OSM (Object-oriented Systems Model) <ref> [16] </ref>. To make the model fully executable, we added a low-level language component called Melody [13] and provided a fully textual version of the model [15]. Taken all together and presented either graphically, textually, or as a mixture of graphics and text, we call the model/language Harmony.
Reference: [17] <author> M. Liu and W. Yu, </author> <title> The ROL System User Manual, Release 1.0, </title> <institution> Department of Computer Science, University of Regina, Regina, Saskatchewan, </institution> <month> January, </month> <year> 1996. </year>
Reference-contexts: Progress has been made on several fronts. Several object-oriented database systems have become commerically available (e.g., [4, 21]) and efforts have been made to unify this integration [6]. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., <ref> [17, 18] </ref>) and active object-oriented databases (e.g., 1 [1, 9]). Integration issues have been plentiful and there is a wide variety of solutions rang-ing from obviously ad hoc (e.g., early embedding of SQL in C) to formal and sophisticated (e.g., [12]).
Reference: [18] <institution> Transaction Logic Prototype, http://www.db.toronto.edu:8020/people/bonner/tr.html, University of Toronto, Toronto, </institution> <address> Ontario, Canada, </address> <year> 1996. </year>
Reference-contexts: Progress has been made on several fronts. Several object-oriented database systems have become commerically available (e.g., [4, 21]) and efforts have been made to unify this integration [6]. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., <ref> [17, 18] </ref>) and active object-oriented databases (e.g., 1 [1, 9]). Integration issues have been plentiful and there is a wide variety of solutions rang-ing from obviously ad hoc (e.g., early embedding of SQL in C) to formal and sophisticated (e.g., [12]).
Reference: [19] <author> J.D. Ullman, </author> <title> Principles of Database and Knowledge-Base Systems, Volume I, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1988. </year>
Reference-contexts: Logic rules are clauses of the form head :- body where head is a single n-ary atom, n 1, and body is a conjunction of one or more literals. Rules must be range-restricted [3], Harmony logic programs must be stratified <ref> [19] </ref>, and all variables in a rule must be limited (i.e., finite [19]). We say that the rules for a predicate p are partially rectified if all their heads are identical up to variable renaming, the rules are range-restricted, and no constants appear in a rule head. <p> Rules must be range-restricted [3], Harmony logic programs must be stratified <ref> [19] </ref>, and all variables in a rule must be limited (i.e., finite [19]). We say that the rules for a predicate p are partially rectified if all their heads are identical up to variable renaming, the rules are range-restricted, and no constants appear in a rule head. We require Harmony rules to be partially rectified. 3 Updates.
Reference: [20] <author> J.D. Ullman, </author> <title> "A Comparison between Deductive and Object-Oriented Database Systems," </title> <booktitle> Proceedings of the 2nd International Conference on Deductive and Object-Oriented Databases, Lecture Notes in Computer Science, </booktitle> <volume> no. 566, </volume> <pages> pp. 263-277, </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The research community has identified several issues that inhibit the integration of active, object-oriented, and deductive databases. (1) Impedance mismatches occur between declarative database systems and imperative programming systems [24]. (2) Object identity conflicts with least-fixed-point semantics <ref> [20] </ref>. (3) Extensible, dynamic type systems interfere with query formulation and query optimization [20]. (4) Imperative components have side effects that incrementally change the state of a system, but logic components do not have such side effects [23]. (5) The absence of declarative processing semantics prevents logic systems from behaving procedurally <p> The research community has identified several issues that inhibit the integration of active, object-oriented, and deductive databases. (1) Impedance mismatches occur between declarative database systems and imperative programming systems [24]. (2) Object identity conflicts with least-fixed-point semantics <ref> [20] </ref>. (3) Extensible, dynamic type systems interfere with query formulation and query optimization [20]. (4) Imperative components have side effects that incrementally change the state of a system, but logic components do not have such side effects [23]. (5) The absence of declarative processing semantics prevents logic systems from behaving procedurally [5]. (6) Ad-hoc integration lacks a unified formal foundation [12]. <p> Two objects could have the same attribute values, but may still be distinct because of object identity. Ullman pointed to a potential problem related to object identity in the following example from <ref> [20] </ref>: r 1 : path (X,Y) :- arc (X,Y). r 2 : path (X,Y) :- path (X,Z) & arc (Z,Y). The claim is that if we treat object identity seriously, then path facts proved in different ways should have distinct identities.
Reference: [21] <institution> UniSQL/X Application Program Interface Reference Guide, UniSQL, Inc., Austin, Texas, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Over the past decade, there has been growing interest in combining object-oriented languages, logic languages, and active event-condition-action processing with database sys tems. Progress has been made on several fronts. Several object-oriented database systems have become commerically available (e.g., <ref> [4, 21] </ref>) and efforts have been made to unify this integration [6]. Also, several recent prototypes have been made available for both deduc tive objected-oriented databases (e.g., [17, 18]) and active object-oriented databases (e.g., 1 [1, 9]).
Reference: [22] <author> Y. Wand, </author> <title> "A Proposal for a Formal Model of Objects," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F.H. Lochovsky (eds.), </editor> <booktitle> pp. </booktitle> <pages> 537-559, </pages> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: We use this Family Information application model throughout this paper to illustrate our approach. Objects and Relationships. Our definition of object takes an ontological perspective <ref> [22] </ref>: an object is an identifiable thing with properties. An object has object identity and is a member of one or more object sets (e.g., Family Information, Person, Name); membership in object sets may change dynamically.
Reference: [23] <author> P. Wegner, </author> <title> "Tradeoffs between Reasoning and Modeling," Research Directions in Concurrent Object-Oriented Programming, </title> <editor> G. Agha, P. Wegner, and Akinori Yonezawa (eds.), </editor> <booktitle> pp. </booktitle> <pages> 22-41, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1993. </year>
Reference-contexts: systems and imperative programming systems [24]. (2) Object identity conflicts with least-fixed-point semantics [20]. (3) Extensible, dynamic type systems interfere with query formulation and query optimization [20]. (4) Imperative components have side effects that incrementally change the state of a system, but logic components do not have such side effects <ref> [23] </ref>. (5) The absence of declarative processing semantics prevents logic systems from behaving procedurally [5]. (6) Ad-hoc integration lacks a unified formal foundation [12]. <p> to support adequate query optimization. 12 Traditional query optimization techniques can be used directly to optimize deductive queries in Harmony. 3.4 Side Effects Wegner identifies software components as reactive units, capable of responding to stimuli and creating visible side-effects, and logic components as retractive, since logic computation must be revocable <ref> [23] </ref>. That is, since a logic computation must be able to back up and try a different resolution path, any side effects of the computation must be reversible and invisible.
Reference: [24] <author> S.B. Zdonik and D. Maier, </author> <title> "Fundamentals of Object-oriented Databases," Readings in Object-Oriented Database Systems, S.B. </title> <editor> Zdonik and D. Maier (eds.), </editor> <booktitle> pp. </booktitle> <pages> 1-32, </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: The eventual goal is an elegant, fully integrated, formally defined active and deductive object-oriented database system. The research community has identified several issues that inhibit the integration of active, object-oriented, and deductive databases. (1) Impedance mismatches occur between declarative database systems and imperative programming systems <ref> [24] </ref>. (2) Object identity conflicts with least-fixed-point semantics [20]. (3) Extensible, dynamic type systems interfere with query formulation and query optimization [20]. (4) Imperative components have side effects that incrementally change the state of a system, but logic components do not have such side effects [23]. (5) The absence of declarative
Reference: [25] <institution> OSM Lab Home Page, </institution> <note> World Wide Web URL http://osm7.cs.byu.edu. 18 </note>
Reference-contexts: The Composer also provides a platform for integrating other tools to assist in the development of Harmony-based systems. For example, we have a rapid-prototyping component, a graphical query language, and a database design assistant. Other related projects are also planned or under way (see <ref> [25] </ref>). We have implemented a subset of the Harmony language, and we are continuing to enlarge the implementation. Currently, we can create, store, and parse Harmony programs. We have implemented the core of our initial Harmony interpreter, and we can execute some parsed Harmony programs.
References-found: 25

