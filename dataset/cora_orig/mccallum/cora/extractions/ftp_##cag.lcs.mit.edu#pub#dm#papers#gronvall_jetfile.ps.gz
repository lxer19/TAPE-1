URL: ftp://cag.lcs.mit.edu/pub/dm/papers/gronvall:jetfile.ps.gz
Refering-URL: http://www.pdos.lcs.mit.edu/~dm/
Root-URL: 
Email: steveg@sics.se  
Title: A Multicast-based Distributed File System for the Internet  
Author: Bjorn Gronvall, Ian Marsh, and Stephen Pink 
Address: fbg, ianm,  
Affiliation: Swedish Institute of Computer Science  
Abstract: JetFile is a file system designed with multicast as its distribution mechanism. The goal is to support a large number of clients in an environment such as the Internet where hosts are attached to both high and low speed networks, sometimes over long distances. JetFile is designed for reduced reliance on servers by allowing client-to-client updates using scalable reliable multicast. Clients on high speed networks prefetch large numbers of files. On low speed networks such as wireless, special caching policies are used to decrease file access latency. The prototype implementation of JetFile is on the JetStream gigabit local area network which provides hardware support for many multicast addresses. The multicast Internet backbone (Mbone) is the wide area testbed for JetFile.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas E. Anderson, Michael D. Dahlin, Jeanna M. Neefe, David A Patterson, Drew S. Roselli, Ran-dolph, Y. Wang. </author> <title> Serverless Network File Systems. </title> <booktitle> 15th Symposium on Operating Systems Principles, ACM Transactions on Computer Systems, </booktitle> <year> 1995. </year>
Reference-contexts: The client/server approach is for a client to first locate the server, open up a connection, and retrieve the file. There are, however, scaling problems with centralized systems. These problems include overloading of the server by clients, network congestion, and reliability. xFS <ref> [1] </ref> solves these problems with a "serverless" implementation. We think that there are advantages to having a server and that the major scaling problems can be overcome by using a multicast model of communication. <p> the file manager as a combination of a file system cache in kernel space that is maintained by a user space process is similar to the implementation of the Coda cache managar that is separated into Venus (the user space process) and the MiniCache [16]. 10 Related Work In xFS <ref> [1] </ref> servers have been almost eliminated by making all writes to distributed striped logs. The design philosophy is "anything anywhere" which should make the system scalable. Unfortunately this also implies that all components of the system mutually trust each other.
Reference: [2] <author> Mary G. Baker, John Hartman, Michael D. Kupfer, Ken W. Shirriff, John Ousterhout. </author> <title> Measurements of a Distributed File System. </title> <booktitle> Proceedings of the Thirteenth ACM Symposium on Operating System Principles, </booktitle> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Eventually, when the file is "stable", it will be replicated on the storage server. Current trends in research indicate delayed writes to be beneficial. <ref> [2] </ref> reports that between 65% and 80% of all written files are deleted (or truncated to zero length) within 30 seconds. Furthermore, it is shown that between 70% and 95% of the written bytes are overwritten or deleted within 2 hours.
Reference: [3] <author> David Banks, Costas Calamvokis, Chris Dalton, Aled Edwards, John Lumley, Greg Watson. </author> <title> AAL5 at a Gigabit for a Kilobuck. </title> <journal> Journal of High Speed Networks, </journal> <volume> 3(2), </volume> <pages> pages 127-145, </pages> <year> 1994. </year>
Reference-contexts: There are however 2 112 multicast addresses in IPv6 so this should not happen frequently. Many new local area networks provide increased hardware support for multicast communication. For example, the network on which JetFile is being implemented, JetStream <ref> [3] </ref> has hardware support for more than 16,000 multicast addresses. This makes it feasible to do hardware multicast filtering at file granularity. The hardware multicast filters prevent the host and its system software from being interrupted by packets relevant only to files that are not cached on that host.
Reference: [4] <author> D. Cheriton and Steve Deering. </author> <title> Multicast Routing in Datagram Internetworks and Extended LANs. </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 85-111, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: This makes it feasible to do hardware multicast filtering at file granularity. The hardware multicast filters prevent the host and its system software from being interrupted by packets relevant only to files that are not cached on that host. On the Internet level, multicast routing protocols <ref> [4, 5] </ref> are designed to protect local networks from packets destined to group addresses for which there are no subscribers. IP multicast [7] is however not a reliable transfer protocol.
Reference: [5] <author> S. Deering, D. Estrin, D. Farinacci, Van Jacobson, C.G. Liu, L. </author> <title> Wei . An Architecture for Wide-Area Multicasting Routing. </title> <booktitle> ACM SIGCOMM 1994, </booktitle> <address> London, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: This makes it feasible to do hardware multicast filtering at file granularity. The hardware multicast filters prevent the host and its system software from being interrupted by packets relevant only to files that are not cached on that host. On the Internet level, multicast routing protocols <ref> [4, 5] </ref> are designed to protect local networks from packets destined to group addresses for which there are no subscribers. IP multicast [7] is however not a reliable transfer protocol.
Reference: [6] <author> Steve Deering and R. Hinden. </author> <title> IP Version 6 Addressing Architecture. </title> <type> RFC 1883, </type> <institution> Xerox PARC, Ipsilon Networks, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: DVMRP [8] prunes away portions of an internetwork from a multicast, protecting segments of the network with no group member hosts from unnecessary transmissions. PIM establishes rendezvous points in the internetwork for senders and sparsely positioned receivers to meet. We will use IPv6 addressing <ref> [6] </ref> and can thus limit the scope of our transmissions effectively as this new protocol allows multicasts to be scoped to the local node, link, site, or organization. Since multicast scoping is encoded in the IPv6 multicast address itself, multicast addresses can be reused across different scopes.
Reference: [7] <author> Steve Deering. </author> <title> Host Extensions for IP Multicasting. Request For Comments 1112, </title> <institution> Stanford, CA: Computer Science Department, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: On the Internet level, multicast routing protocols [4, 5] are designed to protect local networks from packets destined to group addresses for which there are no subscribers. IP multicast <ref> [7] </ref> is however not a reliable transfer protocol.
Reference: [8] <author> Steve Deering, Craig Partridge, D. Waitzman. </author> <title> Distance Vector Multicast Routing Protocol, </title> <type> RFC 1075, </type> <institution> BBN STC, Stanford University, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: Also, JetFile makes use of IP multicast routing protocols such as DVMRP (Distance Vector Multicast Routing Protocol) and sparse-mode PIM (Protocol Independent Multicast). DVMRP <ref> [8] </ref> prunes away portions of an internetwork from a multicast, protecting segments of the network with no group member hosts from unnecessary transmissions. PIM establishes rendezvous points in the internetwork for senders and sparsely positioned receivers to meet.
Reference: [9] <author> Sally Floyd, Van Jacobson, Steve McCanne, Ching-Gung Liu, Lixia Zhang. </author> <title> A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing. </title> <booktitle> ACM SIGCOMM, </booktitle> <pages> Pages 342-356, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: IP multicast [7] is however not a reliable transfer protocol. To provide reliability of data transfer we use a version of the "Scalable Reliable Multicast" (SRM) algorithm described in <ref> [9] </ref>. 3 Reliable Multicast Distribution By substituting SRM for the classical client/server remote procedure call paradigm, we make communication reliable and move many of the classic server roles to the clients, henceforth referred to as managers.
Reference: [10] <author> James J. Kistler and M. Satyanarayanan. </author> <title> Disconnected Operation in the Coda File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1), </volume> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Prefetching, in the form of file hoarding, however, has been shown to be useful for distributed file system clients that are mobile <ref> [10] </ref>. Hoarding allows the user to operate more effectively while disconnected from the server. JetFile will attempt to combine these two policies.
Reference: [11] <author> Anders Klemets and Stephen Pink. </author> <title> Low Latency File Access in a High Bandwidth Environment. </title> <booktitle> Proceedings of the Sixth ACM European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: For a distributed file system such as JetFile this means that fetching large portions of a user's working file set will eliminate round-trip delays to other managers or servers that are snooping on the multicast addresses for those files. <ref> [11] </ref>. We intend to perform aggressive prefetching on networks with high bandwidth/delay products such as parts of the Internet that connect high speed local area networks such as JetStream via high bandwidth backbones.
Reference: [12] <author> Thomas M. Kroeger, Darrell D.E. </author> <title> Long. Predicting File Actions from Prior Events. </title> <booktitle> Proceedings of the 1996 Usenix Winter Technical Conference, </booktitle> <address> San Diego. </address>
Reference-contexts: We intend to perform aggressive prefetching on networks with high bandwidth/delay products such as parts of the Internet that connect high speed local area networks such as JetStream via high bandwidth backbones. By recording previous file access patterns it is possible to predict future file references <ref> [12] </ref> and to retrieve those files in advance so that when they are actually used they will already be available locally. After an initial open, related file opens are recorded for the file that was initially accessed.
Reference: [13] <editor> Flexible and Safe Resolution of File Conflicts. Kumar, P., Satyanarayanan, M. </editor> <booktitle> Proceedings of the USENIX Winter 1995 Technical Conference Jan. 1995, </booktitle> <address> New Orleans, LA </address>
Reference-contexts: Should two applications unknowingly update a file almost simultaneously the conflicting files will be assigned different version numbers, this makes it possible to later resolve the conflict with an application specific resolver as is done in Coda <ref> [13] </ref> and Ficus [15]. Version number request and repair messages are sent to the multicast group associated to the particular file. Thus, all interested managers know when a new version number has been assigned to a file. Managers may not always be aware of the current version of a file.
Reference: [14] <editor> Craig Partridge.Gigabit Networking. </editor> <publisher> Addison-Wesley. </publisher> <year> 1994. </year>
Reference-contexts: The last bit of the message, of course, arrives sooner on the high speed network than on the low speed <ref> [14] </ref>. For a distributed file system such as JetFile this means that fetching large portions of a user's working file set will eliminate round-trip delays to other managers or servers that are snooping on the multicast addresses for those files. [11].
Reference: [15] <author> Peter Reiher, John Heidemann, David Ratner, Greg Skinner, </author> <booktitle> Gerald Popek Resolving File Conflicts in the Ficus File System Proceedings of the 1994 Usenix Summer Technical Conference, </booktitle> <address> Boston MA. </address>
Reference-contexts: Should two applications unknowingly update a file almost simultaneously the conflicting files will be assigned different version numbers, this makes it possible to later resolve the conflict with an application specific resolver as is done in Coda [13] and Ficus <ref> [15] </ref>. Version number request and repair messages are sent to the multicast group associated to the particular file. Thus, all interested managers know when a new version number has been assigned to a file. Managers may not always be aware of the current version of a file.
Reference: [16] <author> David C. Steere, James J. Kistler, M. </author> <title> Satyanarayanan Efficient User-Level File Cache Management on the Sun Vnode Interface Proceedings of the 1990 Summer USENIX Conference June 1990, </title> <address> Anaheim, CA. </address>
Reference-contexts: Our implementation of the file manager as a combination of a file system cache in kernel space that is maintained by a user space process is similar to the implementation of the Coda cache managar that is separated into Venus (the user space process) and the MiniCache <ref> [16] </ref>. 10 Related Work In xFS [1] servers have been almost eliminated by making all writes to distributed striped logs. The design philosophy is "anything anywhere" which should make the system scalable. Unfortunately this also implies that all components of the system mutually trust each other.
References-found: 16

