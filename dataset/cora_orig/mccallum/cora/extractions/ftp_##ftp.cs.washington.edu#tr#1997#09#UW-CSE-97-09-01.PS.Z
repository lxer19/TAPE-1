URL: ftp://ftp.cs.washington.edu/tr/1997/09/UW-CSE-97-09-01.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-date.html
Root-URL: http://www.cs.washington.edu
Title: Strands: An Efficient and Extensible Thread Management Architecture  
Author: Emin Gun Sirer Przemys law Pardyak Brian N. Bershad 
Date: May 15, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [Accetta et al. 86] <author> Accetta, M. J., Baron, R. V., Bolosky, W., Golub, D. B., Rashid, R. F., Teva-nian, Jr., A., and Young, M. W. </author> <title> Mach: A New Kernel Foundation for Unix Development. </title> <booktitle> In Proceedings of the 1986 Summer USENIX Conference, </booktitle> <pages> pages 93-113, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: We have implemented the strands architecture in the context of SPIN, which is an extensible operating system being developed at the University of Washington. Using strands, we have implemented several threads packages, including CThreads [Cooper & Draves 88], Mach kernel threads <ref> [Accetta et al. 86] </ref> and UNIX processes [Ritchie & Thompson 74], as well as low overhead synchronization primitives [Bershad et al. 92], application-specific schedulers [Zahorjan & McCann 0 This research was sponsored by the Advanced Research Projects Agency, the National Science Foundation (Grants no.
Reference: [Anderson et al. 92] <author> Anderson, T. E., Bershad, B. N., Lazowska, E. D., and Levy, H. M. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: In prior systems, specialization has been accomplished through a partitioning of service across the user-kernel boundary. The kernel provides some basic control flow services while user code implements the specialized interface. This approach, though, has been shown to suffer from poor performance or poor integration <ref> [Anderson et al. 92] </ref>. In this paper, we describe a new architecture for thread and scheduling subsystems that provides correct, extensible and efficient thread management for applications. The strand architecture enables applications to place their specialized thread management code in the kernel address space. <p> As a result, user-level thread systems may exhibit incorrect behavior in the face of I/O or asynchronous events such as page faults. Finally, user-upcall based schemes such as scheduler activations <ref> [Anderson et al. 92] </ref> and shared threads [Marsh et al. 91] have been proposed as a way of combining the desirable aspects of user and kernel thread systems.
Reference: [Bershad 93] <author> Bershad, B. N. </author> <title> Practical Considerations for Non-Blocking Concurrent Objects. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 264-274, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: instance, on a single processor, it is possible to implement CAS2 by executing application-specific code on each thread preemption that checks the pc and either resets it to the beginning of the CAS region if no writes have been performed, or rolls it forward from within the context save routine <ref> [Bershad 93] </ref>. This optimistic software implementation of CAS is roughly five times faster than the equivalent implemented with hardware primitives.
Reference: [Bershad et al. 88] <author> Bershad, B., Lazowska, E., and Levy, H. </author> <title> Presto: A system for object-oriented parallel programming. </title> <journal> Software: Practice and Experience, </journal> <volume> 18(8), </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: Further, a kernel thread implementation must be sufficiently general purpose in order to support the needs of a diverse range of applications. The lack of extensibility in kernel-threads combined with their general purpose nature has forced applications to seek more flexible and higher performance alternatives. User-level threads <ref> [Bershad et al. 88, Cormack 88] </ref> have been suggested as a means of addressing the lack of extensibility in traditional, static thread systems. User-level threads multiplex a number of application threads on top of a single kernel thread.
Reference: [Bershad et al. 92] <author> Bershad, B. N., Redell, D. D., and Ellis, J. R. </author> <title> Fast Mutual Exclusion for Uniprocessors. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural 11 Support for Programming Languages and Operating Systems (ASPLOS-V), pages 223--233, </booktitle> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Using strands, we have implemented several threads packages, including CThreads [Cooper & Draves 88], Mach kernel threads [Accetta et al. 86] and UNIX processes [Ritchie & Thompson 74], as well as low overhead synchronization primitives <ref> [Bershad et al. 92] </ref>, application-specific schedulers [Zahorjan & McCann 0 This research was sponsored by the Advanced Research Projects Agency, the National Science Foundation (Grants no. CDA-9123308 and CCR-9200832) and by an equipment grant from Digital Equipment Corporation. Bershad was partially supported by a National Science Foundation Presidential Faculty Fellowship. <p> Hence, strand packages can have complete control over both the scheduling policies that govern their strands, and the exact responses of their strands to system events. For instance, it is possible to implement fast synchronization primitives based on restartable atomic sequences <ref> [Bershad et al. 92] </ref> by writing a strand handler that will readjust the user program counter when a thread is preempted within a critical section. Strand packages execute in the kernel's address space, which enables low-overhead communication between the operating system and application-specific thread managers.
Reference: [Bershad et al. 95] <author> Bershad, B. N., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M., Becker, D., Eggers, S., and Chambers, C. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Bershad was partially supported by a National Science Foundation Presidential Faculty Fellowship. Sirer was supported by an IBM Graduate Student Fellowship. 1 90, Marsh et al. 91], debugging tools [Redell 88] and sampling profilers. In a related publica-tion <ref> [Bershad et al. 95] </ref>, we briefly described the performance of some of the threads packages. In this paper, we focus on the strand architecture, and provide more detailed information about performance. 1.1 Prior Work Application-specific thread management has been a commonly recurring theme in many systems projects.
Reference: [Brinch Hansen 70] <author> Brinch Hansen, P. </author> <title> The nucleus of a multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4) </volume> <pages> 238-250, </pages> <month> April </month> <year> 1970. </year>
Reference-contexts: The lesson from prior work is that flexible and fast thread management is difficult to provide. Kernel threads <ref> [Dijkstra 66, Brinch Hansen 70] </ref>, where the operating system directly supports a thread management interface, suffer from lack of extensibility. Since the thread implementation resides in the kernel, it cannot be specialized or extended by applications.
Reference: [Cooper & Draves 88] <author> Cooper, E. C. and Draves, R. P. </author> <title> C Threads. </title> <type> Technical Report CMU-CS-88-154, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: We have implemented the strands architecture in the context of SPIN, which is an extensible operating system being developed at the University of Washington. Using strands, we have implemented several threads packages, including CThreads <ref> [Cooper & Draves 88] </ref>, Mach kernel threads [Accetta et al. 86] and UNIX processes [Ritchie & Thompson 74], as well as low overhead synchronization primitives [Bershad et al. 92], application-specific schedulers [Zahorjan & McCann 0 This research was sponsored by the Advanced Research Projects Agency, the National Science Foundation (Grants no.
Reference: [Cormack 88] <author> Cormack, G. V. </author> <title> A Microkernel for Concurrency in C. </title> <journal> Software|Practice and Experience, </journal> <volume> 18(5) </volume> <pages> 485-491, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Further, a kernel thread implementation must be sufficiently general purpose in order to support the needs of a diverse range of applications. The lack of extensibility in kernel-threads combined with their general purpose nature has forced applications to seek more flexible and higher performance alternatives. User-level threads <ref> [Bershad et al. 88, Cormack 88] </ref> have been suggested as a means of addressing the lack of extensibility in traditional, static thread systems. User-level threads multiplex a number of application threads on top of a single kernel thread.
Reference: [Davis et al. 93] <author> Davis, P.-B., McNamee, D., Vaswani, R., and Lazowska, E. </author> <title> Adding Scheduler Activations to Mach 3.0. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium, </booktitle> <pages> pages 119-136, </pages> <address> Santa Fe, NM, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The Firefly implementation of upcalls for scheduler activations, for example, required 2.4 milliseconds per kernel upcall alone, on a roughly 1 MIP machine. An alternative implementation based on the Mach microkernel required up to .915 milliseconds per upcall on a Sequent <ref> [Davis et al. 93] </ref>.
Reference: [Dijkstra 66] <author> Dijkstra, E. W. </author> <title> The Structure of the THE Multiprogramming System. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 341-346, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: The lesson from prior work is that flexible and fast thread management is difficult to provide. Kernel threads <ref> [Dijkstra 66, Brinch Hansen 70] </ref>, where the operating system directly supports a thread management interface, suffer from lack of extensibility. Since the thread implementation resides in the kernel, it cannot be specialized or extended by applications.
Reference: [Gosling & McGilton ] <author> Gosling, J. and McGilton, H. </author> <title> The Java Language Environment: </title> <note> A White Paper. http://java.sun.com. </note>
Reference: [Hsieh et al. 96] <author> Hsieh, W. C., Fiuczynski, M. E., Garrett, C., Savage, S., Becker, D., and Bershad, B. N. </author> <title> Language Support for Extensible Systems. </title> <booktitle> In First Annual Workshop on Compiler Support for System Software, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: This limits the adverse effects of the failure of any handler to the user threads managed by that handler. Failures in handlers are turned into language exceptions by the runtime, which can be caught and appropriately handled <ref> [Hsieh et al. 96] </ref>. Hence, a program error in an application-specific thread package causes the failure of the corresponding user strand, but does not compromise system integrity. It is important to note that a failure of a strand handler to relinquish the processor does not cause system failure.
Reference: [Marsh et al. 91] <author> Marsh, B., Scott, M., LeBlanc, T., and Markatos, E. </author> <title> First-Class User-Level Threads. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 110-121, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: As a result, user-level thread systems may exhibit incorrect behavior in the face of I/O or asynchronous events such as page faults. Finally, user-upcall based schemes such as scheduler activations [Anderson et al. 92] and shared threads <ref> [Marsh et al. 91] </ref> have been proposed as a way of combining the desirable aspects of user and kernel thread systems. In approaches based on user-upcalls, the kernel manages the threads cooperatively with user-level handlers by making upcalls to user space in response to kernel scheduling events.
Reference: [Nelson 91] <author> Nelson, G., </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: As a result of being located in the kernel, user code can contact system services and other application-specific code via regular procedure calls and share data by passing references. Application supplied upcall handlers that execute within the kernel are restricted in their memory accesses. A typesafe language, Modula-3 <ref> [Nelson 91] </ref>, restricts applications from issuing illegal reads, writes and jumps. A safe linker prohibits applications from accessing interfaces for which access has not been explicitly granted [Sirer et al. 96]. <p> Once linked, applications can name kernel services directly and without any overhead. The typesafety of code is ensured by only permitting code written in the safe subset of Modula-3 <ref> [Nelson 91] </ref>, which prohibits pointer arithmetic, validates all array accesses and forbids arbitrary pointer casting. The linker validates all accesses to interfaces against a capability list presented by the application, to ensure that no application can access a kernel interface unless authorized to do so.
Reference: [Ousterhout 94] <author> Ousterhout, J. K. </author> <title> Tcl and the TK Toolkit. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: Dynamic linking is necessary to install and remove new strands packages into and from the kernel. An in-kernel firewall makes it possible to run user code within the kernel without compromising system integrity. Typesafe languages are not the only mechanism for implementing firewalls. Alternative strategies include interpreted languages <ref> [Gosling & McGilton , Ousterhout 94] </ref> and software based fault 6 isolation techniques [Wahbe et al. 93]. 4.1 Low-Overhead Communication We colocate application-specific thread packages within the kernel to achieve high performance for strand upcalls. Colocation enables the kernel to perform application upcalls without crossing architectural protection boundaries.
Reference: [Pardyak & Bershad 96] <author> Pardyak, P. and Bershad, B. </author> <title> Dynamic Binding for Extensible Systems. </title> <note> Submitted to 1996 OSDI, </note> <month> May </month> <year> 1996. </year>
Reference-contexts: In order to deliver high performance, our strand implementation takes advantage of the extension, integration and protection services offered by SPIN. First, we reduce upcall overhead by placing application-specific thread packages in the same address space as the kernel. We further optimize strand upcall dispatch through run-time code generation <ref> [Pardyak & Bershad 96] </ref>. In order to reduce the latency of user-kernel boundary crossings, we delay scheduling actions until they are necessary. Finally, we expose machine dependent architectural events to applications, and allow applications to handle low-level trap events.
Reference: [Redell 88] <author> Redell, D. </author> <title> Experience with Topaz Teledebugging. </title> <booktitle> In Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <month> October </month> <year> 1988. </year>
Reference-contexts: CDA-9123308 and CCR-9200832) and by an equipment grant from Digital Equipment Corporation. Bershad was partially supported by a National Science Foundation Presidential Faculty Fellowship. Sirer was supported by an IBM Graduate Student Fellowship. 1 90, Marsh et al. 91], debugging tools <ref> [Redell 88] </ref> and sampling profilers. In a related publica-tion [Bershad et al. 95], we briefly described the performance of some of the threads packages.
Reference: [Ritchie & Thompson 74] <author> Ritchie, D. M. and Thompson, K. </author> <title> The UNIX Time-Sharing System. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: We have implemented the strands architecture in the context of SPIN, which is an extensible operating system being developed at the University of Washington. Using strands, we have implemented several threads packages, including CThreads [Cooper & Draves 88], Mach kernel threads [Accetta et al. 86] and UNIX processes <ref> [Ritchie & Thompson 74] </ref>, as well as low overhead synchronization primitives [Bershad et al. 92], application-specific schedulers [Zahorjan & McCann 0 This research was sponsored by the Advanced Research Projects Agency, the National Science Foundation (Grants no. CDA-9123308 and CCR-9200832) and by an equipment grant from Digital Equipment Corporation.
Reference: [Sirer et al. 96] <author> Sirer, E. G., Fiuczynski, M., Pardyak, P., and Bershad, B. N. </author> <title> Safe Dynamic Linking in an Extensible Operating System. </title> <booktitle> In First Annual Workshop on Compiler Support for System Software, </booktitle> <month> January </month> <year> 1996. </year> <month> 12 </month>
Reference-contexts: Application supplied upcall handlers that execute within the kernel are restricted in their memory accesses. A typesafe language, Modula-3 [Nelson 91], restricts applications from issuing illegal reads, writes and jumps. A safe linker prohibits applications from accessing interfaces for which access has not been explicitly granted <ref> [Sirer et al. 96] </ref>. Combined, a typesafe language and a safe linker provide the same level of isolation for application code in a shared address space as is normally provided by separate hardware based address spaces. <p> The linker validates all accesses to interfaces against a capability list presented by the application, to ensure that no application can access a kernel interface unless authorized to do so. Hence, SPIN provides compile and link time facilities to draw firewalls around code in a single privileged address space <ref> [Sirer et al. 96] </ref>. 4.2 Efficient Upcall Dispatch Application-specific handlers that implement the strand interface need to be bound to the strand upcalls in order to be invoked. Our implementation relies on the SPIN event dispatcher to establish this binding.
Reference: [Wahbe et al. 93] <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient Software--Based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: An in-kernel firewall makes it possible to run user code within the kernel without compromising system integrity. Typesafe languages are not the only mechanism for implementing firewalls. Alternative strategies include interpreted languages [Gosling & McGilton , Ousterhout 94] and software based fault 6 isolation techniques <ref> [Wahbe et al. 93] </ref>. 4.1 Low-Overhead Communication We colocate application-specific thread packages within the kernel to achieve high performance for strand upcalls. Colocation enables the kernel to perform application upcalls without crossing architectural protection boundaries.
Reference: [Zahorjan & McCann 90] <author> Zahorjan, J. and McCann, C. </author> <title> Processor Scheduling in Shared Memory Multiprocessors. </title> <booktitle> In Proceedings of the ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 214-225, </pages> <month> May </month> <year> 1990. </year> <month> 13 </month>
References-found: 22

