URL: http://www.daimi.aau.dk/~lnx/Master/oopslaarticle.ps
Refering-URL: http://www.daimi.aau.dk/~lnx/
Root-URL: http://www.daimi.aau.dk
Email: e-mail: fagerbo j cornilsg@daimi.aau.dk  
Title: How to preserve the benefits of Design Patterns  
Author: Ellen Agerbo Aino Cornils 
Address: Aarhus, Denmark.  
Affiliation: Computer Science Department, University of  
Abstract: DRAFT: This paper has been accepted at OOPSLA '98. Abstract The rapid evolution of Design Patterns has hampered the benefits gained from using Design Patterns. The increase in the number of Design Patterns makes a common vocabulary unmanageable, and the tracing problem obscures the documentation that should be enhanced by using Design Patterns. We present an analysis of Design Patterns that will strongly reduce the number of Fundamental Design Patterns and show how strong language abstractions can solve the tracing problem and thereby enhance the documentation. 
Abstract-found: 1
Intro-found: 1
Reference: [Agerbo97] <author> Ellen Agerbo and Aino Cornils (1997): </author> <title> Theory of Language Support for Design Patterns. </title> <institution> Department of Computer Science, Aarhus University. </institution>
Reference-contexts: We do believe, however, that the criteria form a sound starting point in a much needed discussion on the quality of the Design Patterns. In <ref> [Agerbo97] </ref> we have shown that by using the guidelines of this analysis, we have evaluated the Design Patterns so that out of the original 23 Design Patterns in [Gamma et al. 95] only 12 Design Patterns qualify as Fundamental Design Patterns. <p> We give some examples of how the guidelines of the analysis are applied on a few of the Design Patterns | for the complete analysis we refer to <ref> [Agerbo97] </ref>. 2.1 The Analysis We present an analysis whose purpose it is to define Fundamental Design Patterns. As mentioned above, we believe it is better to have a conservative analysis, that will accept too many Design Patterns rather than unfairly reject some Design Patterns. <p> For the obvious reasons of space, we will not present the evaluations of all 23 Design Patterns in this paper, but instead we present an example of the application of each guideline on a Design Pattern. For the detailed analysis of all the Design Patterns we refer to <ref> [Agerbo97] </ref>. 2.2.1 Factory Method The purpose of this Design Pattern is to create objects whose exact classes are unknown until runtime. <p> We conclude that the Strategy idea should not be a Design Pattern according to Guideline 3. 2.2.4 Results For each of the Design Patterns in [Gamma et al. 95], we have in <ref> [Agerbo97] </ref> discussed whether it is covered by a known object oriented language construct (and thereby an LDDP), an application of another Design Pattern (an RDP) or an inherent way of thinking in object-oriented programming. <p> Using multiple inheritance this distinction will not be as easily made. 3.2 Implementing the LDPs In <ref> [Agerbo97] </ref> we have discussed how and to what extent the Fundamental Design Patterns could be placed in a library of Design Patterns. In this article we show an example of these discussions to illustrate what we believe could be possible and profitable to keep in a library. <p> This automatic annotation is a very important contribution to the documentation of software systems. A number of the language features in Beta prove themselves especially useful in connection to the LDPs by supporting genericity and reuse of models. This is further elaborated on in <ref> [Agerbo97] </ref> where we show how the intent of a Design Pattern could be encapsulated as an LDP for 10 out of the 12 Fundamental Design Patterns, and that it in 6 out of these 10 cases is due to virtual classes and nested classes. <p> This taxonomy was presented as a workshop paper at ECOOP'97, and it needs a more thorough argumentation for its classifications, which we have discussed in depth in <ref> [Agerbo97] </ref>. Their resulting taxonomy is difficult to compare to ours directly, since they allow the same Design Pattern to appear in several categories, and their reasonings are somewhat fuzzy at places. <p> This is described in detail in <ref> [Agerbo97] </ref>, where we have shown that out of the 12 Fundamental Design Patterns, 10 can be implemented as LDPs preserving the intent of the Design Pattern.
Reference: [Alpert et al. 98] <author> Sherman R. Alpert, Kyle Brown and Bobby Woolf (1998): </author> <title> The Design Patterns Smalltalk Companion. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference-contexts: In either case the Design Patterns will have lost their ability to provide a common vocabulary between object oriented designers regardless of their background. An example of this can be found in <ref> [Alpert et al. 98, p. 3] </ref> where the authors justify the need for gathering the Design Patterns from [Gamma et al. 95] in a Smalltalk version with the following: "The Gang of Four's Design Patterns presents design issues and solutions from a C ++ perspective. <p> For all three categories of the Design Patterns the actual implementations will vary from one language to another, and it could therefore be useful to collect implementation hints in language specific catalogues (as it is done in eg. <ref> [Alpert et al. 98] </ref>). But it is important to keep the design ideas as far from actual languages as possible, such that all designers can gain from them regardless of background.. 2.2 Applying the analysis We have applied the analysis on the Design Patterns in [Gamma et al. 95].
Reference: [Bosch97] <author> Jan Bosch (1997): </author> <title> Design Patterns & Frameworks: </title> <booktitle> On the Issue of Language Support. Workshop on Language Support for Design Patterns and Object-Oriented Frameworks (LSDF), ECOOP '97. </booktitle>
Reference-contexts: Thereby reducing the implementation overhead ; a problem connected to the use of Design Patterns identified by Jan Bosch in <ref> [Bosch97] </ref>. <p> That it in this way is possible to reuse enough of a Design Pattern for it to be applied directly from an LDP while keeping the intent of the Design Pattern intact reduces the implementation overhead, a problem connected to the use of Design Patterns identified by Jan Bosch in <ref> [Bosch97] </ref>. The fact that it is possible to make a useful LDP out of a Design Pattern proves that it is possible to make a reusable implementation of it.
Reference: [Bosch98] <author> Jan Bosch (1998): </author> <title> Design Patterns as Language Constructs. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> May 98 pp. 18-32. </pages>
Reference-contexts: This problem is known as the Tracing Problem and has been discussed in <ref> [Bosch98] </ref> and [Soukup95]. A proposal to solve this problem is to use "Library Design Patterns" (in short LDPs). When using LDPs in the application code, it will be possible to trace from which Design Pattern the implementation ideas came.
Reference: [Baumer et al. 96] <author> Dirk Baumer and Dirk Riehle (1996): </author> <title> Late Creation: </title> <journal> A Creational Pattern. </journal> <volume> PLoP '96. </volume>
Reference: [Coplien94] <author> J.O. </author> <title> Coplien (1994): Advanced C++: Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: An example of this is found in <ref> [Coplien94] </ref>, that contains a collection of C ++ idioms.
Reference: [Dyson et al. 96] <author> Paul Dyson and Bruce Anderson (1996): </author> <title> State Patterns. </title> <address> PLoP '96. </address>
Reference: [Gamma et al. 95] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1995): </author> <title> Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference-contexts: In this thesis we propose a set of guidelines to follow when evaluating a Design Pattern, and we present the results of these guidelines applied to the Design Patterns of <ref> [Gamma et al. 95] </ref>. <p> We will in this paper present an analysis in the form of a set of criteria, that we have used for an evaluation of the Design Patterns that are presented in <ref> [Gamma et al. 95] </ref>. <p> The Design Patterns that are not judged to be Fundamental are then either classified differently or rejected completely. It is important to note that we do not believe our analysis to be the analysis of Design Patterns. It has evolved from our work with the Design Patterns from <ref> [Gamma et al. 95] </ref>, which means that the criteria are based on a rather narrow set of Design Patterns. <p> In [Agerbo97] we have shown that by using the guidelines of this analysis, we have evaluated the Design Patterns so that out of the original 23 Design Patterns in <ref> [Gamma et al. 95] </ref> only 12 Design Patterns qualify as Fundamental Design Patterns. <p> Our analysis is therefore based on three guidelines on when not to accept a prospective Design Pattern as an FDP. It will be possible to make a stricter analysis by adding further guidelines without changing the original guidelines. 2.1.1 Design Patterns vs. language con structs In <ref> [Gamma et al. 95] </ref> the authors state that one person's Design Pattern can be another person's primitive building block, because the point of view affects one's interpretation of what is and what is not a Design Pattern. And the point of view is influenced by the choice of programming language. <p> And the point of view is influenced by the choice of programming language. In <ref> [Gamma et al. 95, p. 4] </ref> it is said: "The choice of programming language is important, because it influences one's point of view. Our patterns assume Smalltalk/C ++ level language features, and that choice determines what can and cannot be implemented easily. <p> If we assumed procedural languages, we might have included design patterns called "Inheritance", "Encapsulation", and "Polymorphism". Similarly, some of our patterns are supported directly by less common object-oriented languages." Thus, they believe that Design Patterns do not need to be language independent. We agree with <ref> [Gamma et al. 95] </ref> so far that the Design Patterns extracted from various applications will always be dictated by the programming language used in the application; things that are easy to do will not be worth forming into a Design Pattern. But where [Gamma et al. 95] seem to believe that <p> We agree with <ref> [Gamma et al. 95] </ref> so far that the Design Patterns extracted from various applications will always be dictated by the programming language used in the application; things that are easy to do will not be worth forming into a Design Pattern. But where [Gamma et al. 95] seem to believe that Design Patterns should emerge from each programming language, we are of the conviction that the Fundamental Design Patterns should not be covered by any generally accepted language construct. <p> An example of this can be found in [Alpert et al. 98, p. 3] where the authors justify the need for gathering the Design Patterns from <ref> [Gamma et al. 95] </ref> in a Smalltalk version with the following: "The Gang of Four's Design Patterns presents design issues and solutions from a C ++ perspective. It illustrates patterns for the most part with C ++ code and considers issues germane to a C ++ implementation. <p> However, since it must be assumed that the programmers, who use the Design Patterns, all are schooled in the object oriented line of thought, they posses a common ground of knowledge, that will let them know the answers to certain problems without too much thought. In <ref> [Gamma et al. 95] </ref> the authors have an introductory section containing good advice as to how to apply the object oriented concepts to build flexible, reusable software. It is among other things here explained when to use class inheritance as opposed to when to use composition. <p> But it is important to keep the design ideas as far from actual languages as possible, such that all designers can gain from them regardless of background.. 2.2 Applying the analysis We have applied the analysis on the Design Patterns in <ref> [Gamma et al. 95] </ref>. The Design Patterns presented in this collection are probably the best known patterns in the area, which should enable the readers of this paper to focus on the analysis and its results instead of on the functionalities of the Design Patterns. <p> For the detailed analysis of all the Design Patterns we refer to [Agerbo97]. 2.2.1 Factory Method The purpose of this Design Pattern is to create objects whose exact classes are unknown until runtime. This is done in <ref> [Gamma et al. 95] </ref> by instantiating the objects in virtual methods that can be bound at runtime as shown in Figure 1. product = FactoryMethod ..... <p> To show how the use of virtual classes will solve the problem behind Factory Method, we need an expansion of the OMT-based notation that has been used in <ref> [Gamma et al. 95] </ref>. We have chosen to use the notation in Figure 2 for a further binding of a virtual class. <p> Each behaviour can be placed in its own class, thus building a simple hierarchy of behaviours. The structure of the Strategy Design Pattern is shown in figure 6. When comparing the applicability of the Strategy Design Pattern with the intent of the State Design Pattern in <ref> [Gamma et al. 95, pp. 305] </ref>, it will appear as if State solves the same problem as Strategy, thus making Strategy redundant. <p> It is thus obvious that there is a fundamental difference between the two Design Patterns, but it is not one that is visible from the structures of the Design Patterns as presented in <ref> [Gamma et al. 95] </ref>; in fact the close connections in the purposes of the two Design Patterns is mirrored in almost identical structures of the Design Patterns. Evaluating the Strategy Design Pattern we believe that announcing this as a Design Pattern is stretching the concept of Design Patterns too far. <p> We conclude that the Strategy idea should not be a Design Pattern according to Guideline 3. 2.2.4 Results For each of the Design Patterns in <ref> [Gamma et al. 95] </ref>, we have in [Agerbo97] discussed whether it is covered by a known object oriented language construct (and thereby an LDDP), an application of another Design Pattern (an RDP) or an inherent way of thinking in object-oriented programming. <p> Some of the Design Patterns that will fall into this category are obvious variants of Design Patterns, such as "State Patterns" ([Dyson et al. 96]) and "Variations on the Visitor Pattern" ([Nordberg96]) where the authors propose several variations on the Design Patterns from <ref> [Gamma et al. 95] </ref>. Other Design Patterns will only after thorough reading prove to be variations on existing patterns. An example is the Design Pattern "Late Creation" ([Baumer et al. 96]) which in fact is a variation on the Abstract Factory Design Pattern. <p> 1: Covered by Procedure classes Interpreter RDP 2: Application of Composite Iterator FDP Mediator FDP Memento FDP Observer RDP 2: Application of Mediator State FDP Strategy ffi 3: Dynamic dispatch Template method LDDP 1: Covered by Complete block structure Visitor LDDP 1: Covered by Multiple dispatch the Implementation section of <ref> [Gamma et al. 95] </ref> as Defining extensible factories. Finally there is some likelihood that some of the designers of Patterns over the years will have come up with almost identical ideas and solutions, but have named the resulting Design Patterns according to their own taste. <p> <ref> [Gamma et al. 95] </ref> as Defining extensible factories. Finally there is some likelihood that some of the designers of Patterns over the years will have come up with almost identical ideas and solutions, but have named the resulting Design Patterns according to their own taste. This is already acknowledged in [Gamma et al. 95] where each Design Pattern has a section with the name Also Known As. Concludingly, the Design Patterns left as good design ideas seen from a general object oriented view are the twelve marked as an FDP in the table in Figure 7. <p> Seen from a modelling point of view, it is of course just as good to copy the idea of the Design Patterns directly from <ref> [Gamma et al. 95] </ref>, but this solution places a bigger demand on the designer of the application. There are naturally also costs to pay when using LDPs. <p> The following discussions are based on the descriptions of the Design Patterns found in <ref> [Gamma et al. 95] </ref>, and require the book at hand for full understanding. 3.2.1 Flyweight The application-dependent issues to consider when making an LDP out of Flyweight are the following: * What kind of object is a key? * How does a key identify a flyweight-object? * How is the state <p> The fact that it is possible to make a useful LDP out of a Design Pattern proves that it is possible to make a reusable implementation of it. And since the Design Patterns in <ref> [Gamma et al. 95] </ref> formulate good design- or implementation-ideas, the language features that support them must be considered flexible and useful in relation to reuse of design. 4 Related Work Most efforts concerning Design Patterns have so far been put into discovering new Design Patterns and investigating their usefulness. <p> The only other critical evaluation of Design Patterns we have found is the article "Design Patterns vs. Language Design" ([Gil et al. 97]) where Joseph Gil and David H. Lorenz have offered a taxonomy of the Design Patterns from <ref> [Gamma et al. 95] </ref> based on how far they are from becoming actual language features. They have partitioned the Design Patterns as either cliches, idioms or cadets, which correspond to an application of Guideline 1 and 3 from our analysis on the Design Patterns. <p> By partitioning the Design Patterns into Fundamental Design Patterns, Language Dependant Design Patterns, and Related Design Patterns, we have a core of the Design Patterns | the Fundamental Design Patterns | which fully provides the benefits of Design Patterns. 12 of the 23 Design Patterns from <ref> [Gamma et al. 95] </ref> are classified as Fundamental Design Patterns following these criteria.
Reference: [Gil et al. 97] <author> Joseph Gil and David H. </author> <title> Lorenz (1997): Design Patterns vs. Language Design. Workshop on Language Support for Design Patterns and Object-Oriented Frameworks (LSDF), </title> <booktitle> ECOOP '97. </booktitle>
Reference-contexts: However, the fact that the two categorisations are not identical shows that it will be hard to obtain a consensus on any one evaluation of Design Patterns; especially will it be hard to agree on what Design Patterns are formalisations over inherent object oriented ways of thinking | <ref> [Gil et al. 97] </ref> claims that three of the Design Patterns fall into this category, none of which we have categorised in the same way.
Reference: [Hedin97] <author> Gorel Hedin (1997): </author> <title> Language Support for Design Patterns usign Attribute Extension. Workshop on Language Support for Design Patterns and Object-Oriented Frameworks (LSDF), </title> <booktitle> ECOOP '97. </booktitle>
Reference: [Madsen89] <author> O. L. Madsen, B. </author> <month> Moller-Pedersen </month> <year> (1989): </year> <title> Virtual classes: A powerful mechanism in object-oriented programming. </title> <booktitle> Proceeding of OOPSLA '89. </booktitle>
Reference-contexts: FactoryMethod () Operation () Creator o FactoryMethod () ConcreteCreatorA ConcreteCreatorB FactoryMethod () ProductBProductA AbstractProduct In a language with virtual classes the goal of this Design Pattern can be achieved quite differently. The concept of virtual classes is explained in depth in <ref> [Madsen89] </ref>, is implemented in Beta ([Beta93]) and has been proposed as an extension to Java ([Thorup97]). To show how the use of virtual classes will solve the problem behind Factory Method, we need an expansion of the OMT-based notation that has been used in [Gamma et al. 95].
Reference: [Madsen92] <author> O. L. Madsen, B. </author> <month> Moller-Pedersen </month> <year> (1992): </year> <title> Part-objects and their location. </title> <booktitle> Proceeding of TOOLS '92 pp. </booktitle> <pages> 283-297. </pages>
Reference: [Beta93] <author> O. L. Madsen, B. Moller-Pedersen, K. </author> <title> Nygaard (1993): Object-Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference: [Nordberg96] <author> Martin E. </author> <title> Nordberg III (1996): </title> <journal> Variations on the Visitor Pattern. </journal> <volume> PLoP '96. </volume>
Reference: [Soukup95] <author> Jiri Soukup (1995): </author> <title> Implementing Patterns. Pattern Languages of Program Design. </title> <editor> Eds. Coplien and Schmidt. </editor> <publisher> Addison-Wesley 1995. </publisher>
Reference-contexts: This problem is known as the Tracing Problem and has been discussed in [Bosch98] and <ref> [Soukup95] </ref>. A proposal to solve this problem is to use "Library Design Patterns" (in short LDPs). When using LDPs in the application code, it will be possible to trace from which Design Pattern the implementation ideas came.
Reference: [Thorup97] <author> K. K. </author> <title> Thorup (1997): Genericity in Java with Virtual Types. </title> <booktitle> Proceedings of ECOOP '97 pp. </booktitle> <pages> 444-469. </pages> <publisher> Springer-Verlag. </publisher>
References-found: 16

