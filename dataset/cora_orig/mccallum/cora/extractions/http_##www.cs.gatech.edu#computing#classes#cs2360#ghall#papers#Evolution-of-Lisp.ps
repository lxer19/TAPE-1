URL: http://www.cs.gatech.edu/computing/classes/cs2360/ghall/papers/Evolution-of-Lisp.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs2360/ghall/lisp.html
Root-URL: 
Email: E-mail: gls@think.com  E-mail: rpg@lucid.com  
Title: The Evolution of Lisp  
Phone: Phone: (617) 234-2860 FAX: (617) 234-4444  Phone: (415) 329-8400 FAX: (415) 329-8480  
Author: Guy L. Steele Jr. Richard P. Gabriel 
Address: 245 First Street Cambridge, Massachusetts 02142  707 Laurel Street Menlo Park, California 94025  
Affiliation: Thinking Machines Corporation  Lucid, Inc.  
Abstract: Lisp is the world's greatest programming language|or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the "hacker culture" than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians. We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp. 
Abstract-found: 1
Intro-found: 1
Reference: [Abelson, 1985] <author> Abelson, Harold, and Gerald Jay Sussman with Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year> <note> ISBN 0-262-01077-1. </note>
Reference-contexts: Most of these groups were started by MIT or Indiana graduates who joined the faculty at these schools. At MIT, under the guidance of Gerry Sussman and Hal Abelson, Scheme was adopted for teaching undergraduate computing. The book Structure and Interpretation of Computer Programs <ref> [Abelson, 1985] </ref> became a classic and vaulted Scheme to notoriety in a larger community. Several companies sprang up that made commercial implementations of Scheme. Cadence Research Systems was started by R. Kent Dybvig; its Chez Scheme ran on various workstations. <p> of the great advantage of Lisp-like languages: They have very few ways of forming compound expressions, and almost no syntactic structure: : : : After a short time we forget about syntactic details of the language (because there are none) and get on with the real issues. |Abelson and Sussman <ref> [Abelson, 1985, p. xvii] </ref> Syntactic sugar causes cancer of the semicolon. |Alan Perlis What I like about Lisp is that you can feel the bits between your toes. |Drew McDermott [McDermott, 1977] Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task. <p> Thus parsing technology plays almost no role in Lisp programs, and the construction of language processors is rarely an impediment to the rate of growth and change of large Lisp systems. |Alan Perlis (forward to <ref> [Abelson, 1985] </ref>) APL is like a beautiful diamond|flawless, beautifully symmetrical. But you can't add anything to it. If you try to glue on another diamond, you don't get a bigger diamond. Lisp is like a ball of mud. <p> Add more and it's still a ball of mud|it still looks like Lisp. |Joel Moses [Moses?, 1978?] Pascal is for building pyramids|imposing, breathtaking, static structures built by armies pushing heavy blocks into place. Lisp is for building organisms: : : : |Alan Perlis (forward to <ref> [Abelson, 1985] </ref>) Lisp is the medium of choice for people who enjoy free style and flexibility. |Gerald Jay Sussman (introduction to [Friedman, 1987], p. ix) Hey, Quux: Let's quit hacking this paper and hack Lisp instead! |rpg (the final edit) [Gabriel, 1992] Steele and Gabriel, Evolution of Lisp 70
Reference: [Abrahams, 1966] <author> Abrahams, Paul W., Jeffrey A. Barnett, Erwin Book, Donna Firth, Stanley L. Kemeny, Clark Weissman, Lowell Hawkinson, Michael I. Levin, and Robert A. Saunders. </author> <booktitle> The LISP 2 programming language and system. In Proceedings of the 1966 AFIPS Fall Joint Computer Conference, </booktitle> <volume> volume 29, </volume> <pages> pp. 661-676, </pages> <address> San Francisco, California, </address> <month> November </month> <year> 1966. </year> <booktitle> American Federation of Information Processing Societies. </booktitle> <publisher> Spartan Books, </publisher> <address> Washington, D. C., </address> <year> 1966. </year>
Reference-contexts: During this period there was a good deal of experimentation with implementation strategies. There was little thought of consolidation, partly because of the pioneering feeling that each laboratory embodied. An exception to all this was the LISP 2 project <ref> [Abrahams, 1966] </ref>, a concerted language development effort that was funded by ARPA and represented a radical departure from Lisp 1.5. <p> In some cases this was driven by the desire to emulate styles of programming found in ALGOL-like languages <ref> [Abrahams, 1966] </ref> and by the fact that, although some compilers would sometimes optimize tail-recursive calls, the programmer could not rely on this until the era of good Scheme and Common Lisp compilers in the 1980's, so performance was an issue. <p> Picky, picky|but nowadays we do try to be careful about that sort of thing. Macros of this kind were an integral part of the design of Lisp 2. Abrahams et al. remark that by 1966 macros were an accepted part of Lisp 1.5 as well <ref> [Abrahams, 1966] </ref>. A similar sort of computed macro appeared in the MIT PDP-6 Lisp, but macros calls were expanded on the fly as they were encountered by the compiler or the interpreter. <p> The ARPA-supported LISP 2 project aimed at providing Lisp with a syntax resembling that of ALGOL 60, citing the advantage that "ALGOL algorithms can be utilized with little change" <ref> [Abrahams, 1966] </ref>. LISP 2 code for UNION in the style of our running example would look like this: SYMBOL FUNCTION UNION (X, Y); SYMBOL X, Y; IF NULL X THEN Y ELSE IF MEMBER (CAR X, Y) THEN UNION (CDR X, Y) ELSE CAR X .
Reference: [ACM AIPL, 1977] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the Artificial Intelligence and Programming Languages Conference, </booktitle> <address> Rochester, New York, </address> <month> August </month> <year> 1977. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 12:8, </volume> <month> August </month> <year> 1977. </year> <journal> ACM SIGART Newsletter, </journal> <volume> 64, </volume> <month> August </month> <year> 1977. </year>
Reference: [ACM LFP, 1982] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Pittsburgh, Pennsylvania, </address> <month> August </month> <year> 1982. </year> <note> ISBN 0-89791-082-6. </note>
Reference: [ACM LFP, 1984] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year> <note> ISBN 0-89791-142-3. </note>
Reference: [ACM LFP, 1986] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Cambridge, Massachusetts, </address> <month> August </month> <year> 1986. </year> <note> ISBN 0-89791-200-4. </note>
Reference: [ACM LFP, 1988] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988. </year> <note> ISBN 0-89791-273-X. </note>
Reference: [ACM OOPSLA, 1986] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the ACM Conference on Objected-Oriented Programming, Systems, Languages, and Applications (OOPSLA '86), </booktitle> <address> Portland, Ore-gon, </address> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21:11, </volume> <month> November </month> <year> 1986. </year> <note> ISBN 0-89791-204-7. </note>
Reference: [ACM PLDI, 1990] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the 1990 ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN Notices 25:6, </journal> <month> June </month> <year> 1990. </year> <note> ISBN 0-89791-364-7. </note>
Reference: [ACM PSDE, 1984] <editor> Association for Computing Machinery. </editor> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <address> Pittsburgh, Pennsylvania, </address> <month> April </month> <year> 1984. </year> <journal> ACM SIGPLAN Notices, </journal> <note> 19:5, May 1984; also ACM Software Engineering Notes, 9:3, May 1984. ISBN 0-89791-131-8. </note>
Reference: [Backus, 1978] <author> Backus, John. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21:8, </volume> <pages> pp. 613-641, </pages> <month> August </month> <year> 1978. </year> <note> 1977 ACM Turing Award Lecture. </note>
Reference: [Baker, 1978] <author> Baker, Henry B., Jr. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21:4, </volume> <pages> pp. 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: Such copying back and forth to disk was equivalent Steele and Gabriel, Evolution of Lisp 14 to a slow, manually triggered copying garbage collector. (While there was a great deal of theoretical work on interleaved and concurrent garbage collection during the 1970's <ref> [Steele, 1975; Gries, 1977; Baker, 1978; Cohen, 1981] </ref>, continuous garbage collection was not universally accepted until David Moon's invention of ephemeral garbage collection and its implementation on Lisp Machines [Moon, 1984]. <p> Originally the 3600 was to have a Baker-style incremental stop-and-copy collector <ref> [Baker, 1978] </ref>, but because the address space was so large, ordinary programs did not exhaust memory for several days and intensive ones could run for about 8 hours.
Reference: [Bartley, 1986] <author> Bartley, David H., and John C. Jensen. </author> <title> The implementation of PC Scheme. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 86-93. </pages>
Reference: [Bawden, 1988] <author> Bawden, Alan, and Jonathan Rees. </author> <title> Syntactic closures. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 86-95. </pages>
Reference-contexts: Syntactic closures were proposed in 1988 by Alan Bawden and Jonathan Rees <ref> [Bawden, 1988] </ref>. Their idea bears a strong resemblance to the expansion-passing technique of Dybvig, Friedman, and Haynes [Dybvig, 1986] but is more general.
Reference: [Berkeley, 1964] <author> Berkeley, Edmund C., and Daniel G. Bobrow, eds. </author> <title> The Programming Language LISP: Its Operation and Applications. </title> <booktitle> Information International, </booktitle> <publisher> Inc., and MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1964. </year>
Reference-contexts: Henneman's work does not appear to have directly influenced Teitelman; at least, Teitelman does not cite it, though he cites other papers in the same collection containing Henneman's paper <ref> [Berkeley, 1964] </ref>.) The spelling corrector and DWIM were designed to compensate for human foibles. When a symbol had no value (or no function definition), the Interlisp spelling corrector [Teitelman, 1974] was invoked, because the symbol might have been misspelled.
Reference: [Black, 1964] <author> Black, Fischer. </author> <title> Styles of programming in LISP. </title> <booktitle> In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 96-107. </pages>
Reference-contexts: both generate only one word of code.] we have provided fast versions of memb, last, nth, assoc, and length, which compile open and terminate on NIL checks : : : Fischer Black commented as early as 1964 on the difference between NIL and () as a matter of programming style <ref> [Black, 1964] </ref>.
Reference: [Bobrow, 1964] <author> Bobrow, Daniel G. METEOR: </author> <title> A LISP interpreter for string transformations. </title> <booktitle> In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 161-190. </pages>
Reference-contexts: But Lisp made it convenient to try out little ideas with a small amount of overhead, as well as tackling grand revampings requiring many man-months of effort.) One of the earliest Lisp-based languages was METEOR <ref> [Bobrow, 1964] </ref>, a version of COMIT with Lisp syntax.
Reference: [Bobrow, 1972] <author> Bobrow, Robert J., Richard R. Burton, and Daryle Lewis. </author> <title> UCI-LISP Manual (An Extended Stanford LISP 1.6 System). </title> <institution> Information and Computer Science Technical Report 21, University of California, </institution> <address> Irvine, Irvine, California, </address> <month> October </month> <year> 1972. </year> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 71 </booktitle>
Reference-contexts: The early adaptation was rewritten by John Allen and Lynn Quam; later compiler improvements were made by Whit Diffie. Lisp 1.6 disappeared during the mid-1970's, one of the last remnants of the Lisp 1.5 era. UCI Lisp <ref> [Bobrow, 1972] </ref> was an extended version of Lisp 1.6 in which an Interlisp style editor and other programming environment improvements were made. UCI Lisp was used by some folks at Stanford during the early to mid-1970's, as well as at other institutions.
Reference: [Bobrow, 1973] <author> Bobrow, Daniel G., and Ben Wegbreit. </author> <title> A model and stack implementation of multiple environments. </title> <journal> Communications of the ACM, </journal> <volume> 16:10, </volume> <pages> pp. 591-603, </pages> <month> October </month> <year> 1973. </year>
Reference-contexts: One of the most innovative of the language extensions introduced by Interlisp was the spaghetti stack <ref> [Bobrow, 1973] </ref>. The problem of retention (by closures) of the dynamic function-definition environment in the presence of special variables was never completely solved until spaghetti stacks were invented. <p> This design was strongly influenced by the "spaghetti stack" model introduced by Daniel Bobrow and Ben Wegbreit <ref> [Bobrow, 1973] </ref> and implemented in BBN-Lisp (later to be known as Interlisp).
Reference: [Bobrow, 1986] <author> Bobrow, Daniel G., Kenneth Kahn, Gregor Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and object-oriented programming. </title> <booktitle> In [ACM OOPSLA, </booktitle> <year> 1986], </year> <pages> pp. 17-29. </pages>
Reference-contexts: In 1986 four groups began to vie for defining the object-oriented programming part of Common Lisp: New Flavors (Symbolics) [Symbolics, 1985], CommonLoops (Xerox) <ref> [Bobrow, 1986] </ref>, Object Lisp (LMI) [Drescher, 1987], and Common Objects (HP) [Kempf, 1987]. After a six-month battle, a group was formed to write the standard for CLOS based on CommonLoops and New Flavors. This group was David A. Moon (Symbolics), Daniel G. <p> For example, we have seen data-driven paradigms [Sussman, 1971], possible-worlds paradigms [McDermott, 1974], and object-oriented paradigms [Moon, 1986] <ref> [Bobrow, 1986] </ref> implemented in Lisp in such a way that the seams between Lisp and these new paradigms are essentially invisible. Its interactive and incremental nature.
Reference: [Boehm, 1986] <author> Boehm, Hans-J., Robert Cartwright, Mark Riggle, and Michael J. O'Donnell. </author> <title> Exact real arithmetic: A case study in higher order programming. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 162-173. </pages>
Reference-contexts: It has been used in symbolic algebra systems [Mathlab Group, 1977], but has not become a fixture of Lisp dialects. Lisp is often used as a platform for this kind of research because having bignums gets you 2/3 of the way there <ref> [Boehm, 1986; Vuillemin, 1988] </ref>. The MacLisp functions HAULONG and HAIPART were introduced to support Macsyma's bigfloat arithmetic; these became the Common Lisp functions INTEGER-LENGTH and (by way of Lisp-Machine Lisp) LDB.
Reference: [Brooks, 1982a] <author> Brooks, Rodney A., Richard P. Gabriel, and Guy L. Steele Jr. </author> <title> S-1 Common Lisp implementation. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1982], </year> <pages> pp. 108-113. </pages>
Reference-contexts: NIL was a large Lisp, and efficiency concerns were paramount in the minds of its MacLisp-oriented implementors; soon its implementation was centered around a large VAX assembly-language base. In 1978, Gabriel and Steele set out to implement NIL <ref> [Brooks, 1982a] </ref> on the S-1 Mark IIA, a supercomputer being designed and built by the Lawrence Livermore National Laboratory [Correll, 1979; Hailpern, 1979]. Close cooperation on this project was aided by the fact that Steele rented a room in Gabriel's home. <p> Another line of experimentation in Lisp is in the area of parallelism. While early developments included facilities for interrupt handling and multiprogramming, true multiprocessing evolved only with the availability of appropriate hardware facilities (in some cases built for the purpose). S-1 Lisp <ref> [Brooks, 1982a] </ref> was designed to use the multiple processors of an S-1 system, but (like so many other features of S-1 Lisp) that part never really worked. Some of the most important early "real" parallel Lisp implementations were Multilisp, Qlisp, and Butterfly PSL.
Reference: [Brooks, 1982b] <author> Brooks, Rodney A., Richard P. Gabriel, and Guy L. Steele Jr. </author> <title> An optimizing compiler for lexically scoped LISP. </title> <booktitle> In Proceedings of the 1982 Symposium on Compiler Construction, </booktitle> <pages> pp. 261-275, </pages> <address> Boston, </address> <month> June </month> <year> 1982. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 17:6, </volume> <month> June </month> <year> 1982. </year> <note> ISBN 0-89791-074-5. </note>
Reference-contexts: This Lisp was never completely functional, but served as a testbed for adapting advanced compiler techniques to Lisp implementation. In particular, the work generalized the numerical computation techniques of the MacLisp compiler and unified them with mainstream register allocation strategies <ref> [Brooks, 1982b] </ref>. In France in the mid-1970's, Patrick Greussay developed an interpreter-based Lisp called Vlisp [Greussay, 1977]. <p> The evaluator and garbage collector, in particular, were written in T and not in machine language. The T project Steele and Gabriel, Evolution of Lisp 20 started with a version of the S-1 Lisp compiler <ref> [Brooks, 1982b] </ref> and made substantial improvements; in the course of their work they identified several bugs in the S-1 compiler and in the original report on RABBIT [Steele, 1978a]. <p> The project received advice from W. Kahan in the design of its floating-point arithmetic, so it ended up being quite similar to the eventual IEEE standard. It seemed appropriate to refine the techniques of the MacLisp compiler to produce good numerical code in S-1 Lisp <ref> [Brooks, 1982b] </ref>. The S-1 offered four different floating-point formats (18, 36, 72, and 144 bits) [Correll, 1979]. Influenced by S-1 Lisp, Common Lisp provides an expanded system of floating-point data types to accommodate such architectural variation.
Reference: [Brooks, 1984] <author> Brooks, Rodney A., and Richard P. Gabriel. </author> <title> A critique of Common Lisp. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 1-8. </pages>
Reference-contexts: The self-adopted name for the group was the "Quinquevirate" or, more informally, the "Gang of Five". 2.10.3 The Critique of Common Lisp At the 1984 ACM Symposium on Lisp and Functional Programming, Rod Brooks and Gabriel broke rank and delivered the stunning opening paper, "A Critique of Common Lisp" <ref> [Brooks, 1984] </ref>. This was all the more stunning because Gabriel and Brooks were founders of a company whose business Steele and Gabriel, Evolution of Lisp 25 plan was to become the premier Common Lisp company. Fahlman, on hearing the speech delivered by Gabriel, called it traitorous.
Reference: [Burke, 1983] <author> Burke, G. S., G. J. Carrette, and C. R. Eliot. </author> <title> NIL Reference Manual. </title> <type> Report MIT/LCS/TR-311, </type> <institution> MIT Laboratory for Computer Science, Cambridge, Massachusetts, </institution> <year> 1983. </year>
Reference-contexts: Fateman and his students started with a PDP-11 version of Lisp written at Harvard, and extended it into a MacLisp-like Lisp that eventually ran on virtually all Unix-based computers, thanks to the fact that Franz Lisp is written almost entirely in C. NIL <ref> [Burke, 1983] </ref>, intended to be the successor to MacLisp, was designed by Jon L White, Steele, and others at MIT, under the influence of Lisp-Machine Lisp, also developed at MIT.
Reference: [Burstall, 1971] <author> Burstall, R. M., J. S. Collins, and R. J. Popplestone, eds. </author> <title> Programming in POP-2. </title> <publisher> Edinburgh University Press, </publisher> <year> 1971. </year>
Reference-contexts: Those that were not embedded usually had a syntax related to that of Algol, while including some of the other features of Lisp (such as symbolic data structures and recursive functions). Among these were POP-2 <ref> [Burstall, 1971] </ref>, SAIL [Feldman, 1972], and the Pascal-based TELOS [Travis, 1977]. <p> is not to say that it actually is a bad idea, or that some variation cannot eliminate its disadvantages; here we wish merely to emphasize the similarity of thinking among many independent researchers.) Among the most notable efforts that did produce actual implementations before eventual abandonment are SEUS and POP-2 <ref> [Burstall, 1971] </ref>.
Reference: [Campbell, 1984] <author> Campbell, J. A., ed. </author> <title> Implementations of Prolog. </title> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, 1984. ISBN 0-470-20045-6. </address> <publisher> Also published by John Wiley & Sons, </publisher> <address> New York. </address>
Reference: [Church, 1941] <author> Church, Alonzo. </author> <title> The Calculi of Lambda Conversion. </title> <booktitle> Annals of Mathematics Studies 6. </booktitle> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1941. </year> <title> Reprinted by Klaus Reprint Corp., </title> <address> New York, </address> <year> 1965. </year>
Reference-contexts: A great deal in all these papers was not new; their main contribution was to bridge the gap between the models used by theoreticians (studying actors and the lambda calculus <ref> [Church, 1941] </ref>) and practicians (Lisp implementors and users). Scheme made theoretical contributions in such areas as denotational semantics much more accessible to Lisp hackers; it also provided a usable operational platform for experimentation by theoreticians. <p> Their technique is called, appropriately enough, "macros that work" [Clinger, 1991]. The key insight may be explained by analogy to reduction in the lambda calculus <ref> [Church, 1941] </ref>. Sometimes the rule of ff-conversion must be applied to rename variables in a lambda-calculus expression so that a subsequent fi-reduction will not produce a name clash.
Reference: [Clark, 1982] <editor> Clark, K. L., and S. A. Tarnlund, eds. </editor> <booktitle> Logic Programming. </booktitle> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1982. </year>
Reference: [Clinger, 1984] <author> Clinger, William. </author> <title> The Scheme 311 compiler: An exercise in denotational semantics. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 356-364. </pages>
Reference-contexts: Like Standard Lisp but even smaller and simpler, Scheme could be put up on top of some other Lisp system in a very short time. Local implementations and dialects sprang up at many other sites (one good example is Scheme 311 at Indiana University <ref> [Fessenden, 1983; Clinger, 1984] </ref>); it was several years before anyone made a serious attempt to produce a portable stand-alone Scheme system. Extensive work on Scheme implementations was carried on at Yale and later at MIT by Jonathan Rees, Norman Adams, and others.
Reference: [Clinger, 1985a] <author> Clinger, William (ed.). </author> <title> The Revised Revised Report on Scheme; or, An Uncommon Lisp. </title> <type> AI Memo 848, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> August </month> <year> 1985. </year>
Reference-contexts: Steele and Gabriel, Evolution of Lisp 19 Subsequently Steele and Sussman wrote a revised report on Scheme [Steele, 1978c]; the title of the report was intended as a tribute to Algol but in turn inspired another increasingly silly series of titles <ref> [Clinger, 1985a; Clinger, 1985b; Rees, 1986] </ref>. Shortly thereafter they wrote an extended monograph, whose title was a play on The Art of the Fugue, illustrating numerous small Lisp interpreters with variations. The monograph was never finished; only parts Zero, One, and Two were published [Steele, 1978b].
Reference: [Clinger, 1985b] <author> Clinger, William (ed.). </author> <title> The Revised Revised Report on Scheme; or, An Uncommon Lisp. </title> <institution> Computer Science Department Technical Report 174, Indiana University, Bloomington, </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: Steele and Gabriel, Evolution of Lisp 19 Subsequently Steele and Sussman wrote a revised report on Scheme [Steele, 1978c]; the title of the report was intended as a tribute to Algol but in turn inspired another increasingly silly series of titles <ref> [Clinger, 1985a; Clinger, 1985b; Rees, 1986] </ref>. Shortly thereafter they wrote an extended monograph, whose title was a play on The Art of the Fugue, illustrating numerous small Lisp interpreters with variations. The monograph was never finished; only parts Zero, One, and Two were published [Steele, 1978b]. <p> They regard the construction (if (car x) (+ (car x) 1)) as a bad pun, preferring the more explicit (if (not (null (car x))) (+ (car x) 1)) The Revised Revised Report on Scheme <ref> [Clinger, 1985b] </ref> defined three distinct quantities nil (just another symbol); (), the empty list; and #!false, the boolean false value (along with #!true, the boolean true value).
Reference: [Clinger, 1988] <author> Clinger, William D., Anne H. Hartheimer, and Eric M. </author> <title> Ost. Implementation strategies for continuations. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 124-131. </pages>
Reference: [Clinger, 1990] <author> Clinger, William D. </author> <title> How to read floating point numbers accurately. </title> <booktitle> In [ACM PLDI, </booktitle> <year> 1990], </year> <pages> pp. 92-101. </pages>
Reference: [Clinger, 1991] <author> Clinger, William, and Jonathan Rees. </author> <title> Macros that work. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 155-162, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year> <institution> Association for Computing Machinery. </institution> <note> ISBN 0-89791-419-8. </note>
Reference-contexts: Their technique is called, appropriately enough, "macros that work" <ref> [Clinger, 1991] </ref>. The key insight may be explained by analogy to reduction in the lambda calculus [Church, 1941]. Sometimes the rule of ff-conversion must be applied to rename variables in a lambda-calculus expression so that a subsequent fi-reduction will not produce a name clash.
Reference: [CLTL1, 1984] <institution> Common Lisp: </institution> <note> The Language. </note> <author> By Guy L. Steele Jr., Scott E. Fahlman, Richard P. Gabriel, David A. Moon, and Daniel L. </author> <title> Weinreb. </title> <publisher> Digital Press, </publisher> <address> Burlington, Massachusetts, </address> <year> 1984. </year> <note> ISBN 0-932376-41-X. </note>
Reference-contexts: Virtually all technical decisions were completed by early 1983, but it was almost a year before the book Common Lisp: The Language would be available, even with a fast publishing job by Digital Press. The declared goals of the Common Lisp Group, paraphrased from <ref> [CLTL1, 1984] </ref>: * Commonality: Common Lisp originated in an attempt to focus the work of several implementation groups, each of which was constructing successor implementations of MacLisp for different computers. <p> Second, the intense rivalry between MacLisp and InterLisp over the years would seem to have prevented their ever working together. 2.12 Standards Development: 1984-1992 The period just after the release of Common Lisp: The Language <ref> [CLTL1, 1984] </ref> marked the beginning of an era of unprecedented Lisp popularity. In large part this popularity was coupled with the popularity of AI, but not entirely. <p> The result was a compromise. The first definition of Common Lisp <ref> [CLTL1, 1984] </ref> included a loop macro with absolutely minimal functionality: it permitted no special keywords and was good only for expressing endless repetition of a sequence of subforms. It was understood to be a placeholder, reserving the name loop for possible extension to some full-blown iteration syntax.
Reference: [CLTL2, 1990] <institution> Common Lisp: </institution> <note> The Language (Second Edition). </note> <author> By Guy L. Steele Jr., Scott E. Fahlman, Richard P. Gabriel, David A. Moon, Daniel L. Weinreb, Daniel G. Bobrow, Linda G. DeMichiel, Sonya E. Keene, Gregor Kiczales, Crispin Perdue, Kent M. Pitman, Richard C. Waters, and Jon L White. </author> <title> Digital Press, </title> <institution> Bedford, Massachusetts, </institution> <year> 1990. </year> <note> ISBN 1-55558-041-6. </note> <author> Steele and Gabriel, </author> <title> Evolution of Lisp 72 </title>
Reference-contexts: It was understood to be a placeholder, reserving the name loop for possible extension to some full-blown iteration syntax. ANSI committee X3J13 did eventually agree upon and adopt a slightly cleaned-up version of loop <ref> [CLTL2, 1990] </ref> based on the one used at MIT and on Lisp Machines (which was not very much different from the one in Interlisp). <p> In the process X3J13 also considered two other approaches to iteration that had cropped up in the meantime: series (put forward by Richard Waters) and generators and gatherers (by Pavel Curtis and Crispin Perdue) <ref> [CLTL2, 1990; Waters, 1984; Waters, 1989a; Waters, 1989b] </ref>. The example Fortran DO loop shown above would be rendered using series as (collect-sum (choose-if #'plusp (#M (lambda (j) (a j)) (scan-range :start 0 :below 100))) The call to scan-range generates a series of integers from 0 (inclusive) to 100 (exclusive). <p> They were needed for symbolic algebra programs such as REDUCE [Hearn, 1971] and MACSYMA [Mathlab Group, 1977]. Nowadays the handling of bignums is a distinguishing feature of Lisp, though not an absolute requirement. Both the Scheme Standard [IEEE, 1991] and Common Lisp <ref> [CLTL2, 1990] </ref> require them. Usually the algorithms detailed in Knuth Volume 2 are used [Knuth, 1969; Knuth, 1981].
Reference: [Cohen, 1981] <author> Cohen, Jacques. </author> <title> Garbage collection of linked data structures. </title> <journal> ACM Computing Surveys, </journal> <volume> 13:3, </volume> <pages> pp. 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: Such copying back and forth to disk was equivalent Steele and Gabriel, Evolution of Lisp 14 to a slow, manually triggered copying garbage collector. (While there was a great deal of theoretical work on interleaved and concurrent garbage collection during the 1970's <ref> [Steele, 1975; Gries, 1977; Baker, 1978; Cohen, 1981] </ref>, continuous garbage collection was not universally accepted until David Moon's invention of ephemeral garbage collection and its implementation on Lisp Machines [Moon, 1984].
Reference: [Correll, 1979] <author> Correll, Steven. </author> <title> S-1 uniprocessor architecture (SMA-4). In The S-1 Project 1979 Annual Report, volume I, </title> <type> chapter 4. </type> <institution> Lawrence Livermore Laboratory, Livermore, California, </institution> <year> 1979. </year>
Reference-contexts: In 1978, Gabriel and Steele set out to implement NIL [Brooks, 1982a] on the S-1 Mark IIA, a supercomputer being designed and built by the Lawrence Livermore National Laboratory <ref> [Correll, 1979; Hailpern, 1979] </ref>. Close cooperation on this project was aided by the fact that Steele rented a room in Gabriel's home. This Lisp was never completely functional, but served as a testbed for adapting advanced compiler techniques to Lisp implementation. <p> It seemed appropriate to refine the techniques of the MacLisp compiler to produce good numerical code in S-1 Lisp [Brooks, 1982b]. The S-1 offered four different floating-point formats (18, 36, 72, and 144 bits) <ref> [Correll, 1979] </ref>. Influenced by S-1 Lisp, Common Lisp provides an expanded system of floating-point data types to accommodate such architectural variation. The inclusion of complex numbers in Common Lisp was also an inheritance from the S-1. This was something of a sticking point with Scott Fahlman. <p> However, it was a major incompatible change from MacLisp and Zetalisp, which left Common Lisp open to quite some criticism. Of course, this left Common Lisp without a truncating integer division operation, which is occasionally useful. Inspired by the many rounding modes of the S-1 <ref> [Correll, 1979; Hailpern, 1979] </ref> (which were influenced in turn by Kahan), Steele added four versions of the integer division operation to Common Lisp|truncate, round, ceiling, and floor, each of which accepts either Steele and Gabriel, Evolution of Lisp 53 one or two arguments and returns a quotient and remainder|thus bettering even
Reference: [Davies, 1984] <author> Davies, J. POPLER: </author> <title> Implementation of a POP-2-based PLANNER. </title> <editor> In [Campbell, </editor> <year> 1984], </year> <pages> pp. 28-49. </pages>
Reference-contexts: was designed to match two patterns, each of which might contain variables, but did not use a complete unification algorithm. (Much later, Sussman, on learning about Prolog, remarked to Steele that Prolog appeared to be the first correct implementation of Micro-Planner.) A version of Planner was also implemented in POP-2 <ref> [Davies, 1984] </ref>. The language Muddle (later MDL) was an extended version of Lisp and in some ways a competitor, designed and used by the Dynamic Modeling Group at MIT, which was separate from the MIT AI Laboratory but in the same building at 545 Technology Square.
Reference: [DEC, 1964] <institution> Digital Equipment Corporation, Maynard, Massachusetts. Programmed Data Processor-6 Handbook, </institution> <year> 1964. </year>
Reference-contexts: In 1973, not long after the time that SDS was acquired by Xerox and renamed Xerox Data Systems, the maintenance of BBN Lisp was shared by BBN and Xerox Palo Alto Research Center and the name of the Lisp was changed to Interlisp [Teitelman, 1974]. The PDP-6 <ref> [DEC, 1964] </ref> and PDP-10 [DEC, 1969] computers were, by design, especially suited for Lisp, with 36-bit words and 18-bit addresses. This allowed a CONS cell|a pair of pointers or addresses|to be stored efficiently in a single word.
Reference: [DEC, 1969] <institution> Digital Equipment Corporation, Maynard, Massachusetts. </institution> <note> PDP-10 Reference Handbook, </note> <year> 1969. </year>
Reference-contexts: The PDP-6 [DEC, 1964] and PDP-10 <ref> [DEC, 1969] </ref> computers were, by design, especially suited for Lisp, with 36-bit words and 18-bit addresses. This allowed a CONS cell|a pair of pointers or addresses|to be stored efficiently in a single word. There were half-word instructions that made manipulating the CAR and CDR of CONS cells very fast.
Reference: [DEC, 1981] <institution> Digital Equipment Corporation, Maynard, Massachusetts. VAX Architecture Handbook, </institution> <note> 1981. </note> <author> [de Kleer, 1978a] de Kleer, Johan, Jon Doyle, Charles Rich, Guy L. Steele Jr., and Gerald Jay Sussman. AMORD: </author> <title> A Deductive Procedure System. </title> <type> AI Memo 435, </type> <institution> MIT Artificial Intelligence Laboratory, Cam-bridge, Massachusetts, </institution> <month> January </month> <year> 1978. </year> <editor> [de Kleer, 1978b] de Kleer, Johan, and Gerald Jay Sussman. </editor> <title> Propagation of Constraints Applied to Circuit Synthesis. </title> <type> AI Memo 485, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1978. </year> <note> Also in Circuit Theory and Applications, </note> <month> 8, </month> <pages> pp. 127-144, </pages> <year> 1980. </year>
Reference-contexts: One response to the address space problem was to construct special-purpose Lisp machines (see section 2.6). The other response was to use commercial computers (stock hardware) with larger address spaces; the first of these was the VAX <ref> [DEC, 1981] </ref>. Vaxen presented both opportunities and problems for Lisp implementors. The VAX instruction set provided some good opportunities for implementing the low level Lisp primitives efficiently, though it required clever|perhaps too clever|design of the data structures.
Reference: [Deutsch, 1964] <author> Deutsch, L. Peter, and Edmund C. </author> <title> Berkeley. </title> <booktitle> The LISP implementation for the PDP-1 computer. In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 326-375. </pages>
Reference-contexts: Peter Deutsch (at that time a high school student) implemented a Lisp similar to Lisp 1.5 on the PDP-1 at Bolt Beranek and Newman (BBN) <ref> [Deutsch, 1964] </ref>. This Lisp was called Basic PDP-1 Lisp. By 1964 a version of Lisp 1.5 was running in the Electrical Engineering Department at MIT on an IBM 7094 computer, running the Compatible Time Sharing System (CTSS). <p> community is motivated, in part, by a attitude of superiority to the competition, which might be another programming language or another dialect of Lisp.) 3.4 Numerical Facilities In Lisp 1.6 and through PDP-6 Lisp, most Lisp systems offered at most single-word fixnums (integers) and single-word flonums (floating-point numbers). (PDP-1 Lisp <ref> [Deutsch, 1964] </ref> had only fixnums; apparently the same is true of the M-460 Lisp [Hart, 1964].
Reference: [Deutsch, 1973] <author> Deutsch, L. Peter. </author> <title> A LISP machine with very compact programs. </title> <booktitle> In [IJCAI, </booktitle> <year> 1973], </year> <pages> pp. 697-703. </pages>
Reference-contexts: been research and prototyping projects for Lisp machines, and at the end of the decade it appeared that Lisp machines were the wave of the future. 2.6 Lisp Machines Though ideas for a Lisp machine had been informally discussed before, Peter Deutsch seems to have published the first concrete proposal <ref> [Deutsch, 1973] </ref>. Deutsch outlined the basic vision of a single-user minicomputer-class machine that would be specially microcoded to run Lisp and support Steele and Gabriel, Evolution of Lisp 13 a Lisp development environment. <p> The machine proved to be underpowered for the large Interlisp environment, even with all the code density tricks discussed by Deutsch in <ref> [Deutsch, 1973] </ref>, so it was not widely accepted by users. The Alto was also used to build the first Smalltalk environment|the "interim Dynabook"|and here it was relatively successful.
Reference: [Deutsch, 1976] <author> Deutsch, L. Peter, and Daniel G Bobrow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Communications of the ACM, </journal> <volume> 19:9, </volume> <pages> pp. 522-526, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: Because the names of these three machines all began with the letter "D", they became collectively known as the "D-machines." All the Xerox Lisp machines used a reference-count garbage collector <ref> [Deutsch, 1976] </ref> that was incremental: a few steps of the garbage collection process would execute each time storage was allocated. Therefore there was a short, bounded amount of work done for garbage collection per unit time.
Reference: [Drescher, 1987] <author> Drescher, Gary. </author> <title> ObjectLISP User Manual. </title> <booktitle> LMI (LISP Machine, </booktitle> <publisher> Inc.), </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1987. </year>
Reference-contexts: In 1986 four groups began to vie for defining the object-oriented programming part of Common Lisp: New Flavors (Symbolics) [Symbolics, 1985], CommonLoops (Xerox) [Bobrow, 1986], Object Lisp (LMI) <ref> [Drescher, 1987] </ref>, and Common Objects (HP) [Kempf, 1987]. After a six-month battle, a group was formed to write the standard for CLOS based on CommonLoops and New Flavors. This group was David A. Moon (Symbolics), Daniel G.
Reference: [Dybvig, 1986] <author> Dybvig, R. Kent, Daniel P. Friedman, and Christopher T. Haynes. </author> <title> Expansion-passing style: Beyond conventional macros. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 143-150. </pages>
Reference-contexts: Both approaches involve the use of special syntactic environments to ensure that references are properly matched to definitions. A related line of work allows the programmer to control the expansion process by explicitly passing around and manipulating expander functions <ref> [Dybvig, 1986] </ref>. All of these were intended as macro facilities for Scheme, previous methods being regarded as too deeply flawed for adoption into such an otherwise elegant language. Hygienic macros were developed in 1986 by Eugene Kohlbecker with assistance from Daniel Friedman, Matthias Felleisen, and Bruce Duba [Kohlbecker, 1986a]. <p> Syntactic closures were proposed in 1988 by Alan Bawden and Jonathan Rees [Bawden, 1988]. Their idea bears a strong resemblance to the expansion-passing technique of Dybvig, Friedman, and Haynes <ref> [Dybvig, 1986] </ref> but is more general.
Reference: [Eastlake, 1968] <author> Eastlake, D., R. Greenblatt, J. Holloway, T. Knight, and S. Nelson. </author> <title> ITS 1.5 Reference Manual. </title> <type> AI Memo 161, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> June </month> <year> 1968. </year> <note> Revised as AI Memo 161A, </note> <month> July </month> <year> 1969. </year>
Reference-contexts: This Lisp was the first program written on the PDP-6. Also, this Lisp was the ancestor of MacLisp, the Lisp written to run under the Incompatible Timesharing System (ITS) <ref> [Eastlake, 1968; Eastlake, 1972] </ref> at MIT on the PDP-6 and later on the PDP-10.
Reference: [Eastlake, 1972] <author> Eastlake, Donald E. </author> <title> ITS Status Report. </title> <type> AI Memo 238, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> April </month> <year> 1972. </year>
Reference-contexts: This Lisp was the first program written on the PDP-6. Also, this Lisp was the ancestor of MacLisp, the Lisp written to run under the Incompatible Timesharing System (ITS) <ref> [Eastlake, 1968; Eastlake, 1972] </ref> at MIT on the PDP-6 and later on the PDP-10.
Reference: [Fateman, 1973] <author> Fateman, Richard J. </author> <title> Reply to an editorial. </title> <journal> ACM SIGSAM Bulletin, </journal> <volume> 25, </volume> <pages> pp. 9-11, </pages> <month> March </month> <year> 1973. </year> <title> This reports the results of a test in which a compiled MacLisp floating-point program was faster than equivalent Fortran code. The numerical portion of the code was identical and MacLisp used a faster subroutine-call protocol. </title>
Reference-contexts: Inspired by the needs of the MIT Artificial Intelligence Laboratory, whose needs covered the numeric computations done in vision and robotics, several new ways of representing and compiling numeric code resulted in numeric performance of compiled MacLisp on a near par with FORTRAN compilers <ref> [Fateman, 1973] </ref>. Bignums|arbitrary precision integer arithmetic|were added circa 1971 to meet the needs of Macsyma users. The code was a more or less faithful transcription of the algorithms in [Knuth, 1969]. <p> The first good numerical Lisp compiler was developed for the MACSYMA group [Golden, 1970; Steele, 1977b; Steele, 1977c]; it was important to them and their users that numerical code be both fast and compact. The result was a Lisp compiler that was competitive with the DEC PDP-10 FORTRAN compiler <ref> [Fateman, 1973] </ref>. The S-1 was initially intended to be a fast signal processor. One of the envisioned applications was detection of submarines, which seemed to require a mix of numerical signal processing and artificial intelligence techniques. The project received advice from W.
Reference: [Feldman, 1972] <author> Feldman, J. A., J. R. Low, D. C. Swinehart, and R. H. Taylor. </author> <booktitle> Recent developments in SAIL. In Proceedings of the 1972 AFIPS Fall Joint Computer Conference, </booktitle> <volume> volume 41, </volume> <pages> pp. 1193-1202, </pages> <address> Stanford, California, </address> <month> November </month> <year> 1972. </year> <booktitle> American Federation of Information Processing Societies. </booktitle>
Reference-contexts: Those that were not embedded usually had a syntax related to that of Algol, while including some of the other features of Lisp (such as symbolic data structures and recursive functions). Among these were POP-2 [Burstall, 1971], SAIL <ref> [Feldman, 1972] </ref>, and the Pascal-based TELOS [Travis, 1977].
Reference: [Fessenden, 1983] <author> Fessenden, Carol, William Clinger, Daniel P. Friedman, and Christopher Haynes. </author> <title> Scheme 311 Version 4 Reference Manual. </title> <type> Technical Report 137, </type> <institution> Indiana University, </institution> <month> February </month> <year> 1983. </year>
Reference-contexts: Like Standard Lisp but even smaller and simpler, Scheme could be put up on top of some other Lisp system in a very short time. Local implementations and dialects sprang up at many other sites (one good example is Scheme 311 at Indiana University <ref> [Fessenden, 1983; Clinger, 1984] </ref>); it was several years before anyone made a serious attempt to produce a portable stand-alone Scheme system. Extensive work on Scheme implementations was carried on at Yale and later at MIT by Jonathan Rees, Norman Adams, and others.
Reference: [Foderaro, 1982] <author> Foderaro, J. K., and K. L. Sklower. </author> <title> The FRANZ Lisp Manual. </title> <institution> University of California, Berkeley, California, </institution> <month> April </month> <year> 1982. </year>
Reference-contexts: The primary VAX Lisp dialects developed in the late 1970's were VAX Interlisp, PSL (ported to the VAX), Franz Lisp, and NIL. Steele and Gabriel, Evolution of Lisp 12 Franz Lisp <ref> [Foderaro, 1982] </ref> was written to enable research on symbolic algebra to continue at the University of California at Berkeley, under the supervision of Richard J. Fateman, who was one of the principal implementors of Macsyma at MIT.
Reference: [Forgy, 1977] <author> Forgy, C., and J. McDermott. OPS, </author> <title> a domain-independent production system language. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence (IJCAI-77), </booktitle> <pages> pp. 933-935, </pages> <address> Cambridge, Massachusetts, </address> <month> August </month> <year> 1977. </year> <booktitle> International Joint Council on Artificial Intelligence. Steele and Gabriel, Evolution of Lisp 73 </booktitle>
Reference-contexts: COMIT [MIT RLE, 1962a; MIT RLE, 1962b; Yngve, 1972] was a pattern-matching language that repeatedly matched a set of rules against the contents of a flat, linear workspace of symbolic tokens; it was a precursor of SNOBOL and an ancestor of such rule-based languages as OPS5 <ref> [Forgy, 1977] </ref>. METEOR was embedded within the MIT Lisp 1.5 system that ran on the IBM 7090. The Lisp code for METEOR is a little under 300 80-column cards (some with more whitespace than others).
Reference: [Friedman, 1975] <author> Friedman, Daniel P., and David S. Wise. </author> <title> CONS Should Not Evaluate Its Arguments. </title> <type> Technical Report 44, </type> <institution> Indiana University, </institution> <month> November </month> <year> 1975. </year>
Reference-contexts: Some of their results were summarized in The Art of the Interpreter [Steele, 1978b]. A particular point of interest was comparison of call-by-name and call-by-value parameters; in this they were influenced by work at Indiana University discussed in the paper CONS Should Not Evaluate Its Arguments <ref> [Friedman, 1975] </ref>. Besides being itself susceptible to rapid mutation, Scheme has also served as an implementation base for rapid prototyping of yet other languages.
Reference: [Friedman, 1987] <author> Friedman, Daniel P., and Matthias Felleisen. </author> <title> The Little LISPer. Trade edition. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1987. </year> <note> ISBN 0-262-56038-0. Also published by Science Research Associates, Chicago, Third Edition, 1989. ISBN 0-574-24005-5. </note>
Reference-contexts: Lisp is for building organisms: : : : |Alan Perlis (forward to [Abelson, 1985]) Lisp is the medium of choice for people who enjoy free style and flexibility. |Gerald Jay Sussman (introduction to <ref> [Friedman, 1987] </ref>, p. ix) Hey, Quux: Let's quit hacking this paper and hack Lisp instead! |rpg (the final edit) [Gabriel, 1992] Steele and Gabriel, Evolution of Lisp 70
Reference: [Gabriel, 1982] <author> Gabriel, Richard P., and Larry M. Masinter. </author> <title> Performance of Lisp systems. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1982], </year> <pages> pp. 123-142. </pages>
Reference: [Gabriel, 1984a] <author> Gabriel, Richard P., and Martin E. Frost. </author> <title> A programming environment for a timeshared system. </title> <booktitle> In [ACM PSDE, </booktitle> <year> 1984], </year> <pages> pp. 185-192. </pages>
Reference-contexts: MacLisp was the host for a variety of language development and features over the years, including MicroPlanner, Conniver, Scheme, Flavors, Frames, Extends, Qlisp, and various vision-processing features. The last major piece of research in MacLisp was the multi-program programming environment done by Martin E. Frost and Gabriel at Stanford <ref> [Gabriel, 1984a] </ref>. This environment defined a protocol that allowed MacLisp and E, the Stanford display editor which had operating-system support, to communicate over a mailbox-style operating system mechanism.
Reference: [Gabriel, 1984b] <author> Gabriel, Richard P., and John McCarthy. </author> <booktitle> Queue-based multiprocessing Lisp. In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 25-44. </pages>
Reference-contexts: MultiScheme, a descendant of Multilisp, was later implemented for the BBN Butterfly [Miller, 1987]. Butterfly PSL [Swanson, 1988] was an implementation of Portable Standard Lisp [Griss, 1982] on the BBN Butterfly. It also relied entirely on futures for the spawning of parallel processes. Qlisp <ref> [Gabriel, 1984b; Goldman, 1988] </ref> was developed by Richard Gabriel and John McCarthy at Stanford. It extended Common Lisp with a number of parallel control structures that parallel (pun intended) existing Common Lisp control constructs, notably qlet, qlambda, and qcatch.
Reference: [Gabriel, 1985] <author> Gabriel, Richard P. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year> <note> ISBN 0-262-07093-6. </note>
Reference: [Gabriel, 1988] <author> Gabriel, Richard P., and Kent M. </author> <title> Pitman. Technical issues of separation in function cells and value cells. </title> <booktitle> Lisp and Symbolic Computation, 1:1, </booktitle> <pages> pp. 81-101, </pages> <month> June </month> <year> 1988. </year> <pages> ISSN 0892-4635. </pages>
Reference-contexts: The new dialect was to have the following basic features: * Lexical scoping, including full closures * Multiple values, like those in Lisp-Machine Lisp, but perhaps with some modifications for single-value-forcing situations * Separate value and function cells (a Lisp-2) <ref> [Gabriel, 1988] </ref> (see section 2.12.4) * DEFSTRUCT * SETF * Fancy floating point numbers, including complex and rational numbers (this was the primary influence of S-1 Lisp) * Complex lambda-list declarations, similar to those of Lisp-Machine Lisp * No dynamic closures (closures over "special" variables, whioch are dynamically bound; also called <p> The other front was to try to convince the Scheme community that this was a good idea. On the first front, Gabriel and Kent Pitman produced a report detailing the technical issues involved in macros <ref> [Gabriel, 1988] </ref>. Several technical solutions appeared around the same time, the most promising being described in Kohlbecker's dissertation [Kohlbecker, 1986b].
Reference: [Gabriel, 1992] <author> Gabriel, Richard P. </author> <title> Personal communication to Guy L. </title> <editor> Steele Jr., </editor> <month> November 30, </month> <title> 1992 (two hours before handing off this manuscript to Federal Express). </title>
Reference-contexts: for building organisms: : : : |Alan Perlis (forward to [Abelson, 1985]) Lisp is the medium of choice for people who enjoy free style and flexibility. |Gerald Jay Sussman (introduction to [Friedman, 1987], p. ix) Hey, Quux: Let's quit hacking this paper and hack Lisp instead! |rpg (the final edit) <ref> [Gabriel, 1992] </ref> Steele and Gabriel, Evolution of Lisp 70
Reference: [Galley, 1975] <author> Galley, S.W., and Greg Pfister. </author> <title> The MDL Language. Programming Technology Division Document SYS.11.01, MIT Project MAC, </title> <address> Cambridge, Massachusetts, </address> <month> November </month> <year> 1975. </year>
Reference-contexts: As this project progressed, language features were selectively retrofitted into PDP-10 MacLisp as the two projects cross-fertilized. Complex lambda lists partly arose by influence from Muddle (later called MDL <ref> [Galley, 1975] </ref>), which was a language for the Dynamic Modeling Group at MIT. It ran on a PDP-10 located in the same machine room as the AI and Mathlab machines. <p> T replaced the traditional -P suffix with universal use of the question mark; thus numberp became number? and null became null?. Similarly, every destructive operation had a name ending with an exclamation point; thus nconc, the MacLisp name for the destructive version of append, became append!. (Muddle <ref> [Galley, 1975] </ref> had introduced the use of question mark to indicate predicates and Sussman had used this convention over the years in some of his writing. <p> Indeed, pattern matching and template methodologies were a pervasive topic in the development of languages for Artificial Intelligence throughout the 1960's and 1970's; see section 4. We will return to the topic of template-based macros below. Muddle <ref> [Galley, 1975] </ref>, not surprisingly, had a macro facility very much like that of PDP-6 Lisp, with one slight difference. The macro expansion function, rather than being called with the macro form as its argument, was applied to the CDR of the form. <p> It was designed ": : : as a successor to Lisp, a candidate vehicle for the Dynamic Modeling System, and a possible base for implementation of Planner-70." <ref> [Galley, 1975] </ref> To some extent the competition between Muddle and Lisp, and the fact that Suss-man had a foot in each camp, resulted in cross-fertilization.
Reference: [Geschke, 1977] <author> Geschke, Charles M., James H. Morris Jr., and Edwin H. Satterthwaite. </author> <title> Early experience with Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 20:8, </volume> <pages> pp. 540-553, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: of the Lisp version of Kay's vision was a simple reinvention of the object-oriented genesis of the idea. 2.6.2 Xerox Lisp Machines: 1973-1980 The Alto was a microcodable machine developed in 1973 [Thacker, 1982] and used for personal computing experimentation at Xerox, using Interlisp and other languages such as Mesa <ref> [Geschke, 1977] </ref>. The Alto version of the Interlisp environment first went into use at Xerox PARC and at Stanford University around 1975.
Reference: [Golden, 1970] <author> Golden, Jeffrey P. </author> <title> A User's Guide to the A. I. Group LISCOM Lisp Compiler: </title> <type> Interim Report. AI Memo 210, </type> <institution> MIT Project MAC, Cambridge, Massachusetts, </institution> <month> December </month> <year> 1970. </year>
Reference-contexts: The most significant development for MacLisp occurred in the early 1970's when the techniques in the prototype "fast arithmetic compiler" LISCOM <ref> [Golden, 1970] </ref> were incorporated into the MacLisp compiler by Jon L White, who had already been the principal MacLisp maintainer and developer for several years. (John Lyle White was commonly known by his login name JONL, which can be pronounced as either "jonnell" (to rhyme with "O'Donnell") or "john-ell" (two equally <p> The first good numerical Lisp compiler was developed for the MACSYMA group <ref> [Golden, 1970; Steele, 1977b; Steele, 1977c] </ref>; it was important to them and their users that numerical code be both fast and compact. The result was a Lisp compiler that was competitive with the DEC PDP-10 FORTRAN compiler [Fateman, 1973]. The S-1 was initially intended to be a fast signal processor.
Reference: [Goldman, 1988] <author> Goldman, Ron, and Richard P. Gabriel. </author> <title> Preliminary results with the initial implementation of Qlisp. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 143-152. </pages>
Reference-contexts: MultiScheme, a descendant of Multilisp, was later implemented for the BBN Butterfly [Miller, 1987]. Butterfly PSL [Swanson, 1988] was an implementation of Portable Standard Lisp [Griss, 1982] on the BBN Butterfly. It also relied entirely on futures for the spawning of parallel processes. Qlisp <ref> [Gabriel, 1984b; Goldman, 1988] </ref> was developed by Richard Gabriel and John McCarthy at Stanford. It extended Common Lisp with a number of parallel control structures that parallel (pun intended) existing Common Lisp control constructs, notably qlet, qlambda, and qcatch.
Reference: [Greenblatt, 1974] <author> Greenblatt, Richard. </author> <title> The LISP Machine. </title> <type> Working Paper 79, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> November </month> <year> 1974. </year>
Reference-contexts: As a part of this project he wrote the first truly comprehensive reference manual for Maclisp, which became familiarly known as "the Moonual" [Moon, 1974]. Richard Greenblatt started the MIT Lisp Machine project in 1974 <ref> [Greenblatt, 1974] </ref>; David Moon, Richard Stallman, and many other MIT AI Lab Lisp hackers eventually joined this project. As this project progressed, language features were selectively retrofitted into PDP-10 MacLisp as the two projects cross-fertilized. <p> Deutsch attributed the idea of dual functions to Alan Kay. 2.6.1 MIT Lisp Machines: 1974-1978 Richard Greenblatt started the MIT Lisp Machine project in 1974; his proposal <ref> [Greenblatt, 1974] </ref> cites the Deutsch paper. The project also included Thomas Knight, Jack Holloway, and Pitts Jarvis.
Reference: [Greussay, 1977] <author> Greussay, P. </author> <title> Contribution a la definition interpretive et a l'implementation des lambda-langages. </title> <institution> These d'Etat, Universite de Paris VI, </institution> <month> November </month> <year> 1977. </year>
Reference-contexts: In particular, the work generalized the numerical computation techniques of the MacLisp compiler and unified them with mainstream register allocation strategies [Brooks, 1982b]. In France in the mid-1970's, Patrick Greussay developed an interpreter-based Lisp called Vlisp <ref> [Greussay, 1977] </ref>. At the level of the base dialect of Interlisp, it introduced a couple of interesting concepts, such as the chronology, which is a sort of dynamic environment for implementing interrupts and environmental functions like trace and step, by creating different incarnations of the evaluator.
Reference: [Gries, 1977] <author> Gries, David. </author> <title> An exercise in proving parallel programs correct. </title> <journal> Communications of the ACM, </journal> <volume> 20:12, </volume> <pages> pp. 921-930, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: Such copying back and forth to disk was equivalent Steele and Gabriel, Evolution of Lisp 14 to a slow, manually triggered copying garbage collector. (While there was a great deal of theoretical work on interleaved and concurrent garbage collection during the 1970's <ref> [Steele, 1975; Gries, 1977; Baker, 1978; Cohen, 1981] </ref>, continuous garbage collection was not universally accepted until David Moon's invention of ephemeral garbage collection and its implementation on Lisp Machines [Moon, 1984].
Reference: [Griss, 1981] <author> Griss, Martin L., and Anthony C. Hearn. </author> <title> A portable LISP compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 11, </volume> <pages> pp. 541-605, </pages> <year> 1981. </year>
Reference-contexts: Later Hearn and his colleagues discovered that for good performance they needed more control over the environment and the compiler, so Portable Standard Lisp (PSL) was born. Standard Lisp attempted to piggyback on existing Lisps, while PSL was a complete, new Lisp implementation with a retargetable compiler <ref> [Griss, 1981] </ref>, an important pioneering effort in the evolution of Lisp compilation technology. By the end of the 1970's, PSL ran|and ran well|on more than a dozen different types of computers. Steele and Gabriel, Evolution of Lisp 11 PSL was implemented using two techniques.
Reference: [Griss, 1982] <author> Griss, Martin L., Eric Benson, and Gerald Q. Maguire Jr. </author> <title> PSL: A portable LISP system. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1982], </year> <pages> pp. 88-97. </pages>
Reference-contexts: Multilisp ran on the Concert multiprocessor, a collection of 32 Motorola 68000 processors. MultiScheme, a descendant of Multilisp, was later implemented for the BBN Butterfly [Miller, 1987]. Butterfly PSL [Swanson, 1988] was an implementation of Portable Standard Lisp <ref> [Griss, 1982] </ref> on the BBN Butterfly. It also relied entirely on futures for the spawning of parallel processes. Qlisp [Gabriel, 1984b; Goldman, 1988] was developed by Richard Gabriel and John McCarthy at Stanford.
Reference: [Guzman, 1966] <author> Guzman, Adolfo, and Harold V. McIntosh. </author> <title> CONVERT. AI Memo 99, MIT Project MAC, </title> <address> Cambridge, Massachusetts, </address> <month> June </month> <year> 1966. </year>
Reference-contexts: Another of the early pattern-matching languages built on Lisp was CONVERT <ref> [Guzman, 1966] </ref>. Whereas METEOR was pretty much a straight implementation of COMIT represented as Lisp data structures, CONVERT merged the pattern-matching features of COMIT with the recursive data structures of Lisp, allowing the matching of recursively defined patterns to arbitrary Lisp data structures.
Reference: [Hailpern, 1979] <author> Hailpern, Brent T., and Bruce L. Hitson. </author> <title> S-1 Architecture Manual. </title> <type> Technical Report 161 (STAN-CS-79-715), </type> <institution> Department of Electrical Engineering, Stanford University, Stanford, California, </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: In 1978, Gabriel and Steele set out to implement NIL [Brooks, 1982a] on the S-1 Mark IIA, a supercomputer being designed and built by the Lawrence Livermore National Laboratory <ref> [Correll, 1979; Hailpern, 1979] </ref>. Close cooperation on this project was aided by the fact that Steele rented a room in Gabriel's home. This Lisp was never completely functional, but served as a testbed for adapting advanced compiler techniques to Lisp implementation. <p> However, it was a major incompatible change from MacLisp and Zetalisp, which left Common Lisp open to quite some criticism. Of course, this left Common Lisp without a truncating integer division operation, which is occasionally useful. Inspired by the many rounding modes of the S-1 <ref> [Correll, 1979; Hailpern, 1979] </ref> (which were influenced in turn by Kahan), Steele added four versions of the integer division operation to Common Lisp|truncate, round, ceiling, and floor, each of which accepts either Steele and Gabriel, Evolution of Lisp 53 one or two arguments and returns a quotient and remainder|thus bettering even
Reference: [Halstead, 1984] <author> Halstead, Robert H., Jr. </author> <title> Implementation of Multilisp: Lisp on a multiprocessor. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 9-17. </pages>
Reference-contexts: S-1 Lisp [Brooks, 1982a] was designed to use the multiple processors of an S-1 system, but (like so many other features of S-1 Lisp) that part never really worked. Some of the most important early "real" parallel Lisp implementations were Multilisp, Qlisp, and Butterfly PSL. Multilisp <ref> [Halstead, 1984; Halstead, 1985] </ref> was the work of Bert Halstead and his students at MIT. Based on Scheme, it relied primarily on the notion of a future, which is a sort of laundry ticket, a promise to deliver a value later once it has been computed.
Reference: [Halstead, 1985] <author> Halstead, Robert H., Jr. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7:4, </volume> <pages> pp. 501-538, </pages> <month> October </month> <year> 1985. </year> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 74 </booktitle>
Reference-contexts: S-1 Lisp [Brooks, 1982a] was designed to use the multiple processors of an S-1 system, but (like so many other features of S-1 Lisp) that part never really worked. Some of the most important early "real" parallel Lisp implementations were Multilisp, Qlisp, and Butterfly PSL. Multilisp <ref> [Halstead, 1984; Halstead, 1985] </ref> was the work of Bert Halstead and his students at MIT. Based on Scheme, it relied primarily on the notion of a future, which is a sort of laundry ticket, a promise to deliver a value later once it has been computed.
Reference: [Harbison, 1991] <author> Harbison, Samuel P., and Guy L. Steele Jr. </author> <title> C: A Reference Manual. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, New Jersey, third edition, </address> <year> 1991. </year> <note> ISBN 0-13-110933-2. </note>
Reference-contexts: When substituted back into the program, a macro expansion could conceivably take on a quite surprising Steele and Gabriel, Evolution of Lisp 49 meaning depending on the local environment. (Macros in other languages|the C preprocessor <ref> [Kernighan, 1978; Harbison, 1991] </ref> is one example|have the same problem if they operate by straight substitution of text or tokens.) One practical way to avoid such problems is for the macro writer to try to choose names that the user is unlikely to stumble across, either by picking strange names such
Reference: [Hart, 1963] <author> Hart, Timothy P. </author> <title> MACRO Definitions for LISP. </title> <type> AI Memo 57, </type> <institution> MIT Artificial Intelligence Project|RLE and MIT Computation Center, Cambridge, Massachusetts, </institution> <month> October </month> <year> 1963. </year>
Reference-contexts: Hart in 1963 in a short MIT AI Memo <ref> [Hart, 1963] </ref>, which we quote here in its entirety (with permission): Steele and Gabriel, Evolution of Lisp 42 In LISP 1.5 special forms are used for three logically separate purposes: a) to reach the alist, b) to allow functions to have an indefinite number of arguments, and c) to keep arguments <p> Inspection of the MDEF function in the compiler code [Saunders, 1964a, p. 311] reveals that the error in processing PROG statements had been repaired: mdef [caddr [l]] was replaced by mdef [cddr [l]]. (In fact, this may be what Hart had originally intended; in <ref> [Hart, 1963] </ref> the "a" appears to have been written in by hand as a correction over another letter. <p> Primarily this is accomplished through the use of macros, which have been part of Lisp since 1963 <ref> [Hart, 1963] </ref>. Lisp macros, with their use of Lisp as a computation engine to compute expansions, have proved to be a more effective way to extend a language than the string-processing mechanisms of other languages.
Reference: [Hart, 1964] <author> Hart, Timothy P., and Thomas G. Evans. </author> <booktitle> Notes on implementing LISP for the M-460 computer. In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 191-203. </pages>
Reference-contexts: Hart and Thomas G. Evans implemented Lisp 1.5 on the Univac M 460, a military version of the Univac 490. It was bootstrapped from Lisp 1.5 on the IBM 7090 using a cross-compiler and a small amount of machine language code for the lowest levels of the Lisp implementation <ref> [Hart, 1964] </ref>. Robert Saunders and his colleagues at System Development Corporation implemented Lisp 1.5 on the IBM-built AN/FSQ-32/V computer, often called simply the Q-32 [Saunders, 1964b]. <p> might be another programming language or another dialect of Lisp.) 3.4 Numerical Facilities In Lisp 1.6 and through PDP-6 Lisp, most Lisp systems offered at most single-word fixnums (integers) and single-word flonums (floating-point numbers). (PDP-1 Lisp [Deutsch, 1964] had only fixnums; apparently the same is true of the M-460 Lisp <ref> [Hart, 1964] </ref>.
Reference: [Hearn, 1971] <author> Hearn, A. C. </author> <title> REDUCE 2: A system and language for algebraic manipulation. </title> <booktitle> In Proceedings of the Second Symposium on Symbolic and Algebraic Manipulation, </booktitle> <pages> pp. 128-133, </pages> <address> Los Angeles, </address> <month> March </month> <year> 1971. </year>
Reference-contexts: They seem to have appeared in MacLisp and Stanford Lisp 1.6 at roughly the same time, and perhaps also in Standard Lisp. They were needed for symbolic algebra programs such as REDUCE <ref> [Hearn, 1971] </ref> and MACSYMA [Mathlab Group, 1977]. Nowadays the handling of bignums is a distinguishing feature of Lisp, though not an absolute requirement. Both the Scheme Standard [IEEE, 1991] and Common Lisp [CLTL2, 1990] require them. Usually the algorithms detailed in Knuth Volume 2 are used [Knuth, 1969; Knuth, 1981].
Reference: [Henneman, 1964] <author> Henneman, William. </author> <title> An auxiliary language for more natural expression|The A-language. </title> <booktitle> In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 239-248. </pages>
Reference-contexts: In particular, it contains the roots of structure editing (as opposed to "text" or "tape" editing [Rudloe, 1962]), breakpointing, advice, and CLISP. (William Henneman in 1964 described a translator for the A-language <ref> [Henneman, 1964] </ref>, an English-like or Algol-like surface syntax for Lisp (see section 3.5.1), but it was not nearly as elaborate or as flexible as Steele and Gabriel, Evolution of Lisp 8 CLISP. <p> The earliest example of this|after M-expressions, of course|appears to have been Henneman's A-language <ref> [Henneman, 1964] </ref>. <p> However, if you omit all parentheses : : : you will not often go wrong. Compare this to Henneman's remark <ref> [Henneman, 1964] </ref>: The one great cause of most of the incorrect results obtained in practice is an incor rect precedence being assigned to a function.
Reference: [Hewitt, 1969] <author> Hewitt, Carl. </author> <title> PLANNER: A language for proving theorems in robots. </title> <booktitle> In Proceedings of the [First] International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pp. 295-301, </pages> <address> Washington, D. C., </address> <month> May </month> <year> 1969. </year> <booktitle> International Joint Council on Artificial Intelligence. </booktitle>
Reference-contexts: Carl Hewitt designed an extremely ambitious Lisp-like language for theorem-proving called Planner <ref> [Hewitt, 1969; Hewitt, 1972] </ref>. Its primary contributions consisted of advances in pattern-directed invocation and the use of automatic backtracking as an implementation mechanism for goal-directed search. It was never completely implemented as originally envisioned, but it spurred three other important developments in the history of Lisp: Micro-Planner, Muddle, and Conniver. <p> Hewitt and his student Brian Smith commented on the interaction of a number of research groups at the time [Smith, 1975]: The early work on PLANNER was done at MIT and published in IJCAI-69 <ref> [Hewitt, 1969] </ref>.
Reference: [Hewitt, 1972] <author> Hewitt, Carl. </author> <title> Description and Theoretical Analysis (Using Schemata) of PLANNER: A Language for Proving Theorems and Manipulating Models in a Robot. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> April </month> <year> 1972. </year> <institution> MIT Artificial Intelligence Laboratory TR-258. </institution>
Reference-contexts: Carl Hewitt designed an extremely ambitious Lisp-like language for theorem-proving called Planner <ref> [Hewitt, 1969; Hewitt, 1972] </ref>. Its primary contributions consisted of advances in pattern-directed invocation and the use of automatic backtracking as an implementation mechanism for goal-directed search. It was never completely implemented as originally envisioned, but it spurred three other important developments in the history of Lisp: Micro-Planner, Muddle, and Conniver.
Reference: [Hewitt, 1975] <author> Hewitt, Carl. </author> <title> How to use what you know. </title> <booktitle> In Proceedings of the Fourth International Joint Conference on Artificial Intelligence, </booktitle> <volume> volume 1, </volume> <pages> pp. 189-198, </pages> <address> Tbilisi, Georgia, USSR, </address> <month> September </month> <year> 1975. </year> <note> International Joint Council on Artificial Intelligence. Originally circulated as Working Paper 93, </note> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1975. </year>
Reference-contexts: This language was first called Planner-73 but the name was later changed to PLASMA (PLAnner-like System Modeled on Actors) <ref> [Smith, 1975; Hewitt, 1975] </ref>. While the syntax of PLASMA was recognizably Lisp-like, it made use of several kinds of parentheses and brackets (as did Muddle) as well as many other special characters.
Reference: [Hewitt, 1991] <author> Hewitt, Carl, and Jeff Inman. </author> <title> DAI betwixt and between: From "intelligent agents" to open systems science. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> 21:6, </volume> <pages> pp. 1409-1419, </pages> <month> November/December </month> <year> 1991. </year>
Reference-contexts: illustrates the many connections among different ideas floating around in the AI, Lisp, and other programming language communities; and because this particular point in the evolution of ideas represented a distillation that soon fed back quickly and powerfully into the evolution of Lisp itself. (For a more recent perspective, see <ref> [Hewitt, 1991] </ref>.) Hewitt and his students (notably Howie Shrobe, Brian Smith, Todd Matson, Roger Hale, Peter Bishop, Marilyn McLennan, Russ Atkinson, Mike Freiling, Ken Kahn, Keith Nishihara, Kathy Van Sant, Aki Yonizawa, Benjamin Kuipers, Richard Stieger, and Irene Greif) developed and implemented in MacLisp a new language to make concrete the
Reference: [Hieb, 1990] <author> Hieb, Robert, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In [ACM PLDI, </booktitle> <year> 1990], </year> <pages> pp. 66-77. </pages>
Reference: [IEEE, 1985] <author> IEEE, </author> <title> New York. IEEE Standard for Binary Floating-Point Arithmetic, </title> <address> ANSI/IEEE STD 754-1985, </address> <year> 1985. </year> <title> An American National Standard. </title>
Reference-contexts: The MacLisp functions HAULONG and HAIPART were introduced to support Macsyma's bigfloat arithmetic; these became the Common Lisp functions INTEGER-LENGTH and (by way of Lisp-Machine Lisp) LDB. In the 1980's the developers of Common Lisp grappled with the introduction of the IEEE floating-point standard <ref> [IEEE, 1985] </ref>. (It is notable that, as of this writing, most other high-level programming languages have not grappled seriously with the IEEE floating-point standard.
Reference: [IEEE, 1991] <institution> IEEE Computer Society, </institution> <address> New York. </address> <booktitle> IEEE Standard for the Scheme Programming Language, IEEE STD 1178-1990, </booktitle> <year> 1991. </year>
Reference-contexts: Attending this meeting were Bill Scherlis, Steve Squires, Gabriel, Daniel G. Bobrow, Gerry Sussman, and Scott Fahlman. In 1989, Scheme began an IEEE standardization process, which culminated in 1991 with both an IEEE and ANSI standard <ref> [IEEE, 1991] </ref>, the latter after a virtually unannounced public review period. The structure of the Scheme standards is that the official standard lags the informal R n Report, so that the standard corresponds to the R n1 Report when the R n Report is current. <p> The recently approved IEEE standard for Scheme specifies that #f and #t are the standard false and true values, and that all values except #f count as true, "including #t, the empty list, symbols, numbers, strings, vectors, and procedures" <ref> [IEEE, 1991] </ref>. So the Scheme community has, indeed, overcome long tradition and completely separated the three notions of the false value, the empty list, and the symbol NIL. Nevertheless the question continues to be debated. <p> prog and setq, there is also a perspicuous model free of side effects: (labels ((the-loop (lambda (var1 var2 ... varn) (cond (test . result) (t (progn . body) (the-loop step1 step2 ... stepn)))))) (the-loop init1 init2 ... initn)) Indeed, this is equivalent to the definition of do adopted by Scheme <ref> [IEEE, 1991] </ref>, which resolves an outstanding ambiguity by requiring that the variables be updated by binding rather than by side effect. Thus the entire iteration process is free of side effects. <p> The same is true of macros: it is necessary to intersperse renaming with macro expansion. The contribution of Clinger and Rees was to clarify this problem and provide a fast, complete solution. The Scheme standard <ref> [IEEE, 1991] </ref> was adopted without a macro facility, so confusion still officially reigns on this point. Macros remain an active research topic. <p> They were needed for symbolic algebra programs such as REDUCE [Hearn, 1971] and MACSYMA [Mathlab Group, 1977]. Nowadays the handling of bignums is a distinguishing feature of Lisp, though not an absolute requirement. Both the Scheme Standard <ref> [IEEE, 1991] </ref> and Common Lisp [CLTL2, 1990] require them. Usually the algorithms detailed in Knuth Volume 2 are used [Knuth, 1969; Knuth, 1981].
Reference: [IJCAI, 1973] <editor> International Joint Council on Artificial Intelligence. </editor> <booktitle> Proceedings of the Third International Joint Conference on Artificial Intelligence (IJCAI3), </booktitle> <address> Stanford, California, </address> <month> August </month> <year> 1973. </year>
Reference: [Iverson, 1962] <author> Iverson, Kenneth E. </author> <title> A Programming Language. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: Stallman, in which the number 0 rather than the symbol NIL was used as the empty list and as false. Compare this to the use of 0 and 1 as false and true in APL <ref> [Iverson, 1962] </ref>, or the use of 0 as false and as the null pointer in C [Kernighan, 1978]. Both of these languages have provoked the same kinds of comments about puns and bad programming practice that McCarthy made about Lisp.
Reference: [Jensen, 1974] <author> Jensen, Kathleen, and Niklaus Wirth. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: Sussman thought it was absolutely crazy to have to tell students that the quotient of 10.0 and 4.0 was 2.5 but the quotient of 10 and 4 was 2. Of course, nearly all other programming languages have the same problem (Pascal <ref> [Jensen, 1974] </ref> and its derivatives being notable exceptions), but that is no excuse; Lisp aspires to better things, and centuries of mathematical precedent should outweigh the few decades of temporary aberration in the field of computers.
Reference: [Kahn, 1984] <author> Kahn, K. M., and M. Carlsson. </author> <title> How to implement Prolog on a LISP machine. </title> <editor> In [Campbell, </editor> <year> 1984], </year> <pages> pp. 117-134. </pages>
Reference-contexts: There have also been related attempts to integrate functional programming and Prolog. (All these should be contrasted with the use of Lisp as a convenient language for implementing Prolog, as exemplified by Komorowski's QLOG [Komorowski, 1982] and the work of Kahn and Carlsson <ref> [Kahn, 1984] </ref>.) We conjecture that this idea has not caught on in the Lisp community because of unification, the variable-matching process used in Prolog. Indeed one can easily design a language that has many of the features of Lisp but uses unification during procedure calls.
Reference: [Kempf, 1987] <author> Kempf, James, Warren Harris, Roy D'Souza, and Alan Snyder. </author> <title> Experience with Common-Loops. </title> <booktitle> In Proceedings of the ACM Conference on Objected-Oriented Programming Systems, Languages, and Applications (OOPSLA '87), </booktitle> <pages> pp. 214-226, </pages> <address> Orlando, Florida, </address> <month> October </month> <year> 1987. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 22:12, </volume> <month> December </month> <year> 1987. </year> <note> ISBN 0-89791-247-0. </note>
Reference-contexts: In 1986 four groups began to vie for defining the object-oriented programming part of Common Lisp: New Flavors (Symbolics) [Symbolics, 1985], CommonLoops (Xerox) [Bobrow, 1986], Object Lisp (LMI) [Drescher, 1987], and Common Objects (HP) <ref> [Kempf, 1987] </ref>. After a six-month battle, a group was formed to write the standard for CLOS based on CommonLoops and New Flavors. This group was David A. Moon (Symbolics), Daniel G. Bobrow (Xerox), Gregor Kiczales (Xerox), Sonya Keene (Symbolics, a writer), Linda DeMichiel (Lucid), and Gabriel (Lucid).
Reference: [Kernighan, 1978] <author> Kernighan, Brian W., and Dennis Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: Compare this to the use of 0 and 1 as false and true in APL [Iverson, 1962], or the use of 0 as false and as the null pointer in C <ref> [Kernighan, 1978] </ref>. Both of these languages have provoked the same kinds of comments about puns and bad programming practice that McCarthy made about Lisp. This may seem to the reader to be a great deal of discussion to expend in this paper on such a small point of language design. <p> When substituted back into the program, a macro expansion could conceivably take on a quite surprising Steele and Gabriel, Evolution of Lisp 49 meaning depending on the local environment. (Macros in other languages|the C preprocessor <ref> [Kernighan, 1978; Harbison, 1991] </ref> is one example|have the same problem if they operate by straight substitution of text or tokens.) One practical way to avoid such problems is for the macro writer to try to choose names that the user is unlikely to stumble across, either by picking strange names such
Reference: [Knuth, 1969] <author> Knuth, Donald E. </author> <title> Seminumerical Algorithms, </title> <booktitle> volume 2 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1969. </year> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 75 </booktitle>
Reference-contexts: Bignums|arbitrary precision integer arithmetic|were added circa 1971 to meet the needs of Macsyma users. The code was a more or less faithful transcription of the algorithms in <ref> [Knuth, 1969] </ref>. Later Bill Gosper suggested some improvements, notably a version of GCD that combined the good features of the binary GCD algorithm with Lehmer's method for speeding up integer bignum division [Knuth, 1981, ex. 4.5.2-34]. <p> Nowadays the handling of bignums is a distinguishing feature of Lisp, though not an absolute requirement. Both the Scheme Standard [IEEE, 1991] and Common Lisp [CLTL2, 1990] require them. Usually the algorithms detailed in Knuth Volume 2 are used <ref> [Knuth, 1969; Knuth, 1981] </ref>. Jon L White wrote a paper about a set of primitives that allow one to code most of bignum arithmetic efficiently in Lisp, instead of having to code the whole thing in assembly language [White, 1986]. There is also a literature on BIGFLOAT arithmetic.
Reference: [Knuth, 1974] <author> Knuth, Donald E. </author> <title> Structured programming with GO TO statements. </title> <journal> Computing Surveys, </journal> <volume> 6:4, </volume> <pages> pp. 261-301, </pages> <month> December </month> <year> 1974. </year>
Reference-contexts: The second list mentions variables that may be introduced by the macro expansion but are intended to interact with the argument forms. For example, consider an implementation (using the Scheme call-with-current-continuation primitive) of a slight generalization of the n + 1 2 loop attributed to Dahl <ref> [Knuth, 1974] </ref>; it executes statements repeatedly until its while clause (if any) fails or until exit is used. (extend-syntax (loop while repeat) (exit) ((loop e1 e2 ... repeat) (call/cc (lambda (exit) ((label foo (lambda () e1 e2 ... (foo))))))) ((loop e1 ... while p e2 ... repeat) (call/cc (lambda (exit) ((label
Reference: [Knuth, 1981] <author> Knuth, Donald E. </author> <title> Seminumerical Algorithms (Second Edition), </title> <booktitle> volume 2 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1981. </year> <note> ISBN 0-201-03822-6. </note>
Reference-contexts: The code was a more or less faithful transcription of the algorithms in [Knuth, 1969]. Later Bill Gosper suggested some improvements, notably a version of GCD that combined the good features of the binary GCD algorithm with Lehmer's method for speeding up integer bignum division <ref> [Knuth, 1981, ex. 4.5.2-34] </ref>. In 1973 and 1974, David Moon led an effort to implement MacLisp on the Honeywell 6180 under Multics. As a part of this project he wrote the first truly comprehensive reference manual for Maclisp, which became familiarly known as "the Moonual" [Moon, 1974]. <p> Nowadays the handling of bignums is a distinguishing feature of Lisp, though not an absolute requirement. Both the Scheme Standard [IEEE, 1991] and Common Lisp [CLTL2, 1990] require them. Usually the algorithms detailed in Knuth Volume 2 are used <ref> [Knuth, 1969; Knuth, 1981] </ref>. Jon L White wrote a paper about a set of primitives that allow one to code most of bignum arithmetic efficiently in Lisp, instead of having to code the whole thing in assembly language [White, 1986]. There is also a literature on BIGFLOAT arithmetic.
Reference: [Knuth, 1986] <author> Knuth, Donald E. </author> <title> The METAFONT Book, volume C of Computers and Typesetting. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year> <note> ISBN 0-201-13445-4. </note>
Reference-contexts: Add a new arithmetic operator to the language similar to the one for Pythagorean addition in Knuth's Metafont language <ref> [Knuth, 1986] </ref>: a++b computes p a 2 + b 2 .
Reference: [Kohlbecker, 1986a] <author> Kohlbecker, Eugene, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 151-161. </pages>
Reference-contexts: All of these were intended as macro facilities for Scheme, previous methods being regarded as too deeply flawed for adoption into such an otherwise elegant language. Hygienic macros were developed in 1986 by Eugene Kohlbecker with assistance from Daniel Friedman, Matthias Felleisen, and Bruce Duba <ref> [Kohlbecker, 1986a] </ref>. The idea is to label the occurrences of variables with a tag indicating whether it appeared in the original source code or was introduced as a result of macro expansion; if multiple macro expansions occur, the tag must indicate which expansion step was involved.
Reference: [Kohlbecker, 1986b] <author> Kohlbecker, Jr., Eugene E. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> Technical Report 109, </type> <institution> Indiana University, </institution> <month> August </month> <year> 1986. </year> <type> Ph.D. thesis. </type>
Reference-contexts: On the first front, Gabriel and Kent Pitman produced a report detailing the technical issues involved in macros [Gabriel, 1988]. Several technical solutions appeared around the same time, the most promising being described in Kohlbecker's dissertation <ref> [Kohlbecker, 1986b] </ref>. <p> The technique renames variables so that a variable reference cannot refer to a binding introduced at a different step. Kohlbecker's Ph.D. dissertation <ref> [Kohlbecker, 1986b] </ref> carried this a step further by proposing a pattern matching and template substitution language for defining macros; the underlying mechanism automatically used hygienic macro expansion to avoid name clashes.
Reference: [Komorowski, 1982] <author> Komorowski, H. J. QLOG: </author> <title> The programming environment for PROLOG in LISP. </title> <editor> In [Clark, </editor> <year> 1982], </year> <pages> pp. 315-322. </pages>
Reference-contexts: There have also been related attempts to integrate functional programming and Prolog. (All these should be contrasted with the use of Lisp as a convenient language for implementing Prolog, as exemplified by Komorowski's QLOG <ref> [Komorowski, 1982] </ref> and the work of Kahn and Carlsson [Kahn, 1984].) We conjecture that this idea has not caught on in the Lisp community because of unification, the variable-matching process used in Prolog.
Reference: [Kranz, 1986] <author> Kranz, David, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the 1986 ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pp. 219-233, </pages> <address> Palo Alto, California, </address> <month> June </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21:7, </volume> <month> July </month> <year> 1986. </year> <note> ISBN 0-89791-197-0. </note>
Reference-contexts: Like the S-1 Lisp compiler, it relied heavily on optimization strategies from the mainstream compiler literature, most notably the work by Wulf and others on the BLISS-11 compiler [Wulf, 1975]. A second generation of T compiler, called ORBIT <ref> [Kranz, 1986] </ref>, integrated a host of mainstream and Lisp-specific optimization strategies, resulting in a truly production-quality Scheme environment. RABBIT was organized around a principle of translating Lisp code by performing a source-to-source conversion into "continuation-passing style" (CPS); ORBIT generalized and extended this strategy to handle assignments to variables. <p> Thus the entire iteration process is free of side effects. With the advent of good Scheme compilers such as ORBIT <ref> [Kranz, 1986] </ref> and good Common Lisp compilers, compiling the result of this side-effect-free translation produces exactly the same efficient machine-language code one would expect from the PROG-and-SETQ model. 3.3 Macros Macros appear to have been introduced into Lisp by Timothy P.
Reference: [Landin, 1964] <author> Landin, Peter J. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6:4, </volume> <year> 1964. </year>
Reference-contexts: When the IBM 370 came out, Lisp370 implementation began. Lisp370 was later called Lisp/VM. Lisp360 was basically a batch Lisp, and it was used fairly extensively for teaching in universities. Lisp370 began with the definition of a core Lisp based on a formal semantics expressed in the SECD model <ref> [Landin, 1964] </ref>. This definition fit on one or two pages. The Lisp370 project was under the direction of Fred Blair (who developed the SECD definition) at the IBM Thomas J. Watson Research Center in Yorktown Heights, New York. Other members of the group included Richard W.
Reference: [Landin, 1965] <author> Landin, Peter J. </author> <title> A correspondence between ALGOL 60 and Church's lambda-notation. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 2-3, </pages> <month> February-March </month> <year> 1965. </year>
Reference-contexts: Lambda: The Ultimate Imperative [Steele, 1976a] demonstrated how a wide variety of control structure ideas could be modeled in Scheme. Some of the models drew on earlier work by Peter Landin, John Reynolds, and others <ref> [Landin, 1965; Reynolds, 1972; Fried-man, 1975] </ref>.
Reference: [Lisp Archive] <institution> LISP ARCHIV. </institution> <note> On-line archive of MacLisp release notes, 1969-1981, with entries by Jon L White, </note> <author> Guy L. Steele Jr., Howard I. Cannon, Richard P. Gabriel, Richard M. Stallman, Eric C. Rosen, Richard Greenblatt, and Robert W. </author> <month> Kerns. </month>
Reference-contexts: Unfortunately, this use of ERRSET also quietly trapped unexpected errors, making programs harder to debug. A new pair of primitives, CATCH and THROW, was introduced into MacLisp <ref> [Lisp Archive, May 3, 1972, item 2] </ref> so that ERRSET could be reserved for its intended use of error trapping. The lesson of ERRSET and CATCH is important. <p> Steele soon took responsibility for maintaining the MacLisp interpreter and runtime system, allowing Jon L to concentrate almost full time on compiler improvements. The resulting new MacLisp compiler, NCOMPLR <ref> [Moon, 1974; Lisp Archive; Pitman, 1983] </ref>, became a standard against which all other Lisp compilers were measured in terms of the speed of running code.
Reference: [Lisp Conference, 1980] <institution> Conference Record of the 1980 LISP Conference, Stanford, California, </institution> <month> August </month> <year> 1980. </year> <institution> Republished by Association for Computing Machinery. </institution>
Reference: [Malachi, 1984] <author> Malachi, Yonathan, Zohar Manna, and Richard Waldinger. </author> <title> TABLOG: </title> <booktitle> The deductive-tableau programming language. In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 323-330. </pages>
Reference-contexts: Such efforts were particularly a feature of the software side of the Japanese Fifth Generation project. Examples of this are Robinson's LOGLISP [Robinson, 1982], the TAO project [Takeuchi, 1983; Okuno, 1984], and TABLOG <ref> [Malachi, 1984] </ref>.
Reference: [Marti, 1979] <author> Marti, J., A. C. Hearn, M. L. Griss, and C. Griss. </author> <title> Standard lisp report. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 14:10, </volume> <pages> pp. 48-68, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: Most were more similar to MacLisp than to Interlisp. The two most widely used dialects were Standard Lisp <ref> [Marti, 1979] </ref> and Portable Standard Lisp [Utah, 1982]. Standard Lisp was defined by Anthony Hearn and Martin Griss, along with their students and colleagues.
Reference: [Mathlab Group, 1977] <author> Mathlab Group, </author> <title> The. MACSYMA Reference Manual (Version Nine). </title> <institution> MIT Laboratory for Computer Science, Cambridge, Massachusetts, </institution> <year> 1977. </year>
Reference-contexts: They seem to have appeared in MacLisp and Stanford Lisp 1.6 at roughly the same time, and perhaps also in Standard Lisp. They were needed for symbolic algebra programs such as REDUCE [Hearn, 1971] and MACSYMA <ref> [Mathlab Group, 1977] </ref>. Nowadays the handling of bignums is a distinguishing feature of Lisp, though not an absolute requirement. Both the Scheme Standard [IEEE, 1991] and Common Lisp [CLTL2, 1990] require them. Usually the algorithms detailed in Knuth Volume 2 are used [Knuth, 1969; Knuth, 1981]. <p> There is also a literature on BIGFLOAT arithmetic. It has been used in symbolic algebra systems <ref> [Mathlab Group, 1977] </ref>, but has not become a fixture of Lisp dialects. Lisp is often used as a platform for this kind of research because having bignums gets you 2/3 of the way there [Boehm, 1986; Vuillemin, 1988].
Reference: [McAllester, 1978] <author> McAllester, David A. </author> <title> A Three Valued Truth Maintenance System. </title> <type> AI Memo 473, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: After Scheme, a few new Lisp-based languages were developed in this direction by Sussman and his students, including constraint-based systems [Sussman, 1975a; Stallman, 1976; Steele, 1979; de Kleer, 1978b] and truth maintenance systems <ref> [de Kleer, 1978a; McAllester, 1978] </ref> based on non-monotonic logic. The technique of dependency-directed backtracking eliminated the "giant nest of FORALL loops" effect of chronological backtracking.
Reference: [McCarthy, 1962] <author> McCarthy, John, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, and Michael I. Levin. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1962. </year>
Reference-contexts: in Lisp 1.5, APPLY took a third argument, an environment (regarded nowadays as something of a mistake that resulted in dynamic binding rather than the lexical scoping needed for a faithful reflection of the lambda calculus); and (b) "EVALQUOTE is capable of handling special forms as a sort of exception" <ref> [McCarthy, 1962] </ref>. <p> Lisp 1.5 on the 7090 had floating-point <ref> [McCarthy, 1962] </ref>, as did Q-32 Lisp [Saunders, 1964b] and PDP-6 Lisp [PDP-6 Lisp, 1967].) We are still a little uncertain about the origin of bignums (a data type that uses a variable amount of storage so as to represent arbitrarily large integer values, subject to the total size of the heap,
Reference: [McCarthy, 1980] <author> McCarthy, John. </author> <title> Lisp: Notes on its past and future. </title> <booktitle> In [Lisp Conference, </booktitle> <year> 1980], </year> <pages> pp. </pages> <month> v-viii. </month>
Reference-contexts: Actual implementation began in the fall of 1958. In 1978 McCarthy related the early history of the language [McCarthy, 1981], taking it approximately to just after Lisp 1.5. See also <ref> [McCarthy, 1980] </ref>. We begin our story where McCarthy left off. 2.1 From Lisp 1.5 to PDP-6 Lisp: 1960-1965 During this period, Lisp spread rapidly to a variety of computers, either by bootstrapping from an existing Lisp on another computer or by a new implementation.
Reference: [McCarthy, 1981] <author> McCarthy, John. </author> <title> History of LISP. </title> <editor> In Wexelblat, Richard L., ed., </editor> <booktitle> History of Programming Languages, ACM Monograph Series, chapter IV, </booktitle> <pages> pp. 173-197. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1981. </year> <booktitle> (Final published version of the Proceedings of the ACM SIGPLAN History of Programming Languages Conference, </booktitle> <address> Los Angeles, California, </address> <month> June </month> <year> 1978.) </year> <note> ISBN 0-12-745040-8. </note>
Reference-contexts: The choice of topics presented here necessarily reflects our own experiences and biases. We apologize if your favorite corner of the sprawling Lisp community has gone unmentioned. Section 2 discusses the history of Lisp in terms of projects and people, from where McCarthy left off <ref> [McCarthy, 1981] </ref> up through the efforts to produce official standards for Lisp dialects within IEEE, ANSI, and ISO. Section 3 examines a number of technical themes and traces separately their chronological evolution; here the emphasis is on the flow of ideas for each topic. <p> Actual implementation began in the fall of 1958. In 1978 McCarthy related the early history of the language <ref> [McCarthy, 1981] </ref>, taking it approximately to just after Lisp 1.5. See also [McCarthy, 1980]. <p> In some texts on Lisp one will find descriptions of special forms that speak of a special form "quoting its arguments" when in fact a special form has a special rule for determining its meaning and that rule involves not evaluating some forms [Pitman, 1980]. McCarthy <ref> [McCarthy, 1981] </ref> noted that the original Lisp interpreter was regarded as a universal Turing machine: It could perform any computation given a set of instructions (a function) and the initial input on its tape (arguments). <p> The UNION function in M-expression notation looks like this: union [x;y] = [null [x]!y; member [car [x];y]!union [cdr [x];y]; T!cons [car [x];union [cdr [x];y]]] But as McCarthy noted <ref> [McCarthy, 1981] </ref>: The unexpected appearance of an interpreter tended to freeze the form of the language: : : . The project of defining M-expressions precisely: : : was neither finalized nor completely abandoned.
Reference: [McDermott, 1974] <author> McDermott, Drew V., and Gerald Jay Sussman. </author> <title> The CONNIVER Reference Manual. </title> <institution> AI Memo 295a, MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1974. </year>
Reference-contexts: The complete example might be rendered as (let ((num (generator (scan-range :start 0 :below 100)))) (gathering ((result collect-sum)) (loop (let ((j (next-in num (return result)))) (if (plusp j) (next-out result j)))))) This reminds one of the possibilities lists of Conniver <ref> [McDermott, 1974] </ref> or of the generators of Alphard [Shaw, 1981], though we know of no direct connection. Generators and gatherers emphasize use of control structure rather than functional relationships. <p> For example, we have seen data-driven paradigms [Sussman, 1971], possible-worlds paradigms <ref> [McDermott, 1974] </ref>, and object-oriented paradigms [Moon, 1986] [Bobrow, 1986] implemented in Lisp in such a way that the seams between Lisp and these new paradigms are essentially invisible. Its interactive and incremental nature.
Reference: [McDermott, 1977] <author> McDermott, Drew V. </author> <booktitle> Oral remark at the ACM Symposium on Artificial Intelligence and Programming Languages, </booktitle> <address> Rochester, New York, </address> <month> August </month> <year> 1977, </year> <note> as recollected by Guy L. Steele Jr. </note>
Reference-contexts: about syntactic details of the language (because there are none) and get on with the real issues. |Abelson and Sussman [Abelson, 1985, p. xvii] Syntactic sugar causes cancer of the semicolon. |Alan Perlis What I like about Lisp is that you can feel the bits between your toes. |Drew McDermott <ref> [McDermott, 1977] </ref> Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task.
Reference: [McDermott, 1980] <author> McDermott, Drew. </author> <title> An efficient environment allocation scheme in an interpreter for a lexically-scoped LISP. </title> <booktitle> In [Lisp Conference, </booktitle> <year> 1980], </year> <pages> pp. 154-162. </pages> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 76 </booktitle>
Reference: [Mellish, 1984] <author> Mellish, C., and S. Hardy. </author> <title> Integrating Prolog in the POPLOG environment. </title> <editor> In [Campbell, </editor> <year> 1984], </year> <pages> pp. 147-162. </pages>
Reference-contexts: POP-2 was regarded by its designers as an AI language, one of the many produced in the late 1960's and early 1970's, rather than as a variant of Lisp; it enjoyed quite some popularity in Europe and was used to implement the logic programming language POPLOG <ref> [Mellish, 1984] </ref>. 3.5.3 Logic Programming and Unification During the 1970's and on into the 1980's there have been a number of attempts to integrate the advantages of the two perhaps foremost AI programming language families, Lisp and Prolog, into a single language.
Reference: [Miller, 1987] <author> Miller, James Slocum. MultiScheme: </author> <title> A Parallel Processing System Mased on MIT Scheme. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Thus pcall provides a certain structured discipline for the use of futures that is adequate for many purposes. Multilisp ran on the Concert multiprocessor, a collection of 32 Motorola 68000 processors. MultiScheme, a descendant of Multilisp, was later implemented for the BBN Butterfly <ref> [Miller, 1987] </ref>. Butterfly PSL [Swanson, 1988] was an implementation of Portable Standard Lisp [Griss, 1982] on the BBN Butterfly. It also relied entirely on futures for the spawning of parallel processes. Qlisp [Gabriel, 1984b; Goldman, 1988] was developed by Richard Gabriel and John McCarthy at Stanford.
Reference: [MIT RLE, 1962a] <institution> MIT Research Laboratory of Electronics. MIT Press, Cambridge, Massachusetts. </institution> <note> COMIT Programmers Reference Manual, </note> <month> June </month> <year> 1962. </year>
Reference-contexts: But Lisp made it convenient to try out little ideas with a small amount of overhead, as well as tackling grand revampings requiring many man-months of effort.) One of the earliest Lisp-based languages was METEOR [Bobrow, 1964], a version of COMIT with Lisp syntax. COMIT <ref> [MIT RLE, 1962a; MIT RLE, 1962b; Yngve, 1972] </ref> was a pattern-matching language that repeatedly matched a set of rules against the contents of a flat, linear workspace of symbolic tokens; it was a precursor of SNOBOL and an ancestor of such rule-based languages as OPS5 [Forgy, 1977].
Reference: [MIT RLE, 1962b] <institution> MIT Research Laboratory of Electronics. MIT Press, Cambridge, Massachusetts. </institution> <note> An Introduction to COMIT Programming, </note> <month> June </month> <year> 1962. </year>
Reference-contexts: But Lisp made it convenient to try out little ideas with a small amount of overhead, as well as tackling grand revampings requiring many man-months of effort.) One of the earliest Lisp-based languages was METEOR [Bobrow, 1964], a version of COMIT with Lisp syntax. COMIT <ref> [MIT RLE, 1962a; MIT RLE, 1962b; Yngve, 1972] </ref> was a pattern-matching language that repeatedly matched a set of rules against the contents of a flat, linear workspace of symbolic tokens; it was a precursor of SNOBOL and an ancestor of such rule-based languages as OPS5 [Forgy, 1977].
Reference: [Moon, 1974] <author> Moon, David A. </author> <title> MacLISP Reference Manual. MIT Project MAC, </title> <address> Cambridge, Massachusetts, </address> <month> April </month> <year> 1974. </year>
Reference-contexts: Steele soon took responsibility for maintaining the MacLisp interpreter and runtime system, allowing Jon L to concentrate almost full time on compiler improvements. The resulting new MacLisp compiler, NCOMPLR <ref> [Moon, 1974; Lisp Archive; Pitman, 1983] </ref>, became a standard against which all other Lisp compilers were measured in terms of the speed of running code. <p> In 1973 and 1974, David Moon led an effort to implement MacLisp on the Honeywell 6180 under Multics. As a part of this project he wrote the first truly comprehensive reference manual for Maclisp, which became familiarly known as "the Moonual" <ref> [Moon, 1974] </ref>. Richard Greenblatt started the MIT Lisp Machine project in 1974 [Greenblatt, 1974]; David Moon, Richard Stallman, and many other MIT AI Lab Lisp hackers eventually joined this project. As this project progressed, language features were selectively retrofitted into PDP-10 MacLisp as the two projects cross-fertilized.
Reference: [Moon, 1984] <author> Moon, David A. </author> <title> Garbage collection in a large Lisp system. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 235-246. </pages>
Reference-contexts: copying garbage collector. (While there was a great deal of theoretical work on interleaved and concurrent garbage collection during the 1970's [Steele, 1975; Gries, 1977; Baker, 1978; Cohen, 1981], continuous garbage collection was not universally accepted until David Moon's invention of ephemeral garbage collection and its implementation on Lisp Machines <ref> [Moon, 1984] </ref>. Ephemeral garbage collection was subsequently adapted for use on stock hardware.) The early MIT Lisp-Machine Lisp dialect [Weinreb, 1978] was very similar to MacLisp. It lived up to its stated goal of supporting MacLisp programs with only minimal porting effort. <p> Ephemeral garbage collection <ref> [Moon, 1984] </ref> is similar but maintains a few consing areas representing generations and a list of regions of memory where pointers to objects in the consing areas were created, and those regions are scanned in a stop-and-copy operation, moving from one generation to the other.
Reference: [Moon, 1986] <author> Moon, David A. </author> <title> Object-oriented programming with flavors. </title> <booktitle> In [ACM OOPSLA, </booktitle> <year> 1986], </year> <pages> pp. 1-8. </pages>
Reference-contexts: For example, we have seen data-driven paradigms [Sussman, 1971], possible-worlds paradigms [McDermott, 1974], and object-oriented paradigms <ref> [Moon, 1986] </ref> [Bobrow, 1986] implemented in Lisp in such a way that the seams between Lisp and these new paradigms are essentially invisible. Its interactive and incremental nature.
Reference: [Moore, 1976] <author> Moore, J. </author> <title> Strother II. The InterLISP Virtual Machine Specification. </title> <type> Technical Report CSL 76-5, </type> <institution> Xerox Palo Alto Research Center, Palo Alto, California, </institution> <month> September </month> <year> 1976. </year>
Reference-contexts: The Dorado was specifically designed to interpret byte codes produced by compilers and this is how the Dorado ran Alto software. The Dorado was basically an emulation machine. Interlisp was ported to this machine using the Interlisp virtual machine model <ref> [Moore, 1976] </ref>. The Dorado running Interlisp was faster than a KL-10 running single-user Interlisp and it would have proved a very nice Lisp machine if it had been made widely available commercially.
Reference: [Moses, 1970] <author> Moses, Joel. </author> <title> The Function of FUNCTION in LISP. </title> <type> AI Memo 199, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> June </month> <year> 1970. </year>
Reference-contexts: The toy Lisp would provide the necessary primitives for implementing the internal behavior of primitive actors. Because Sussman had just been studying Algol [Naur, 1963], he suggested starting with a lexically scoped dialect of Lisp. (Some of the issues and necessary mechanisms had already been explored by Joel Moses <ref> [Moses, 1970] </ref>.) It appeared that such a mechanism would be needed anyway for keeping track of acquaintances for actors. Lexical scoping allowed actors and functions to be created by almost identical mechanisms.

Reference: [Naur, 1963] <editor> Naur, Peter (ed.), et al. </editor> <title> Revised report on the algorithmic language ALGOL 60. </title> <journal> Communications of the ACM, </journal> <volume> 6:1, </volume> <pages> pp. 1-20, </pages> <month> January </month> <year> 1963. </year>
Reference-contexts: Using MacLisp as a working environment, they wrote a tiny Lisp interpreter and then add the necessary mechanisms for creating actors and sending messages. The toy Lisp would provide the necessary primitives for implementing the internal behavior of primitive actors. Because Sussman had just been studying Algol <ref> [Naur, 1963] </ref>, he suggested starting with a lexically scoped dialect of Lisp. (Some of the issues and necessary mechanisms had already been explored by Joel Moses [Moses, 1970].) It appeared that such a mechanism would be needed anyway for keeping track of acquaintances for actors.
Reference: [Okuno, 1984] <author> Okuno, Hiroshi G., Ikuo Takeuchi, Nobuyasu Osato, Yasushi Hibino, and Kazufumi Watan-abe. TAO: </author> <title> A fast interpreter-centered Lisp system on Lisp machine ELIS. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1984], </year> <pages> pp. 140-149. </pages>
Reference-contexts: Such efforts were particularly a feature of the software side of the Japanese Fifth Generation project. Examples of this are Robinson's LOGLISP [Robinson, 1982], the TAO project <ref> [Takeuchi, 1983; Okuno, 1984] </ref>, and TABLOG [Malachi, 1984].
Reference: [Organick, 1972] <author> Organick, Elliot I. </author> <title> The Multics System: An Examination of Its Structure. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1972. </year>
Reference-contexts: Other important Lisp work at the Lab during this period included Lisp-Machine Lisp (later named Zetalisp) and Scheme. MacLisp is usually identified with the PDP-10 computer, but MacLisp also ran on another machine, the Honeywell 6180, under the Multics operating system <ref> [Organick, 1972] </ref>. Steele and Gabriel, Evolution of Lisp 4 2.2.1 Early MacLisp The distinguishing feature of the MacLisp/Interlisp era is the attention to production quality or near production quality implementations. This period saw a consolidation of implementation techniques, with great attention to detail.
Reference: [Padget, 1986] <editor> Padget, Julian, et al. </editor> <booktitle> Desiderata for the standardisation of Lisp. In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 54-66. </pages>
Reference: [PDP-6 Lisp, 1967] <institution> PDP-6 LISP (LISP 1.6). AI Memo 116, MIT Project MAC, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1967. </year> <note> Revised as Memo 116A, </note> <month> April </month> <year> 1967. </year> <title> The report does not bear the author's name, </title> <editor> but Jeffrey P. Golden [Golden, </editor> <title> 1970] attributes it to Jon L White. </title>
Reference-contexts: This Lisp was called Basic PDP-1 Lisp. By 1964 a version of Lisp 1.5 was running in the Electrical Engineering Department at MIT on an IBM 7094 computer, running the Compatible Time Sharing System (CTSS). This Lisp and Basic PDP-1 Lisp were the main influences on the PDP-6 Lisp <ref> [PDP-6 Lisp, 1967] </ref> implemented Steele and Gabriel, Evolution of Lisp 3 by DEC and some members of MIT's Tech Model Railroad Club in the spring of 1964. This Lisp was the first program written on the PDP-6. <p> The example given in the PDP-6 Lisp memo <ref> [PDP-6 Lisp, 1967] </ref> was Steele and Gabriel, Evolution of Lisp 44 (DEFPROP CONSCONS (LAMBDA (A) (COND ((NULL (CDDR A)) (CADR A)) ((LIST (QUOTE CONS) (CADR A) (CONS (CAR A) (CDDR A))))) MACRO) This defined a macro equivalent in effect to the Common Lisp function list*. <p> Lisp 1.5 on the 7090 had floating-point [McCarthy, 1962], as did Q-32 Lisp [Saunders, 1964b] and PDP-6 Lisp <ref> [PDP-6 Lisp, 1967] </ref>.) We are still a little uncertain about the origin of bignums (a data type that uses a variable amount of storage so as to represent arbitrarily large integer values, subject to the total size of the heap, which is where bignums are stored).
Reference: [Pitman, 1980] <author> Pitman, Kent M. </author> <title> Special forms in Lisp. </title> <booktitle> In [Lisp Conference, </booktitle> <year> 1980], </year> <pages> pp. 179-187. </pages>
Reference-contexts: In some texts on Lisp one will find descriptions of special forms that speak of a special form "quoting its arguments" when in fact a special form has a special rule for determining its meaning and that rule involves not evaluating some forms <ref> [Pitman, 1980] </ref>. McCarthy [McCarthy, 1981] noted that the original Lisp interpreter was regarded as a universal Turing machine: It could perform any computation given a set of instructions (a function) and the initial input on its tape (arguments). <p> In 1980 Kent Pitman wrote a very good summary of the advantages of macros over FEXPR's in defining new language syntax <ref> [Pitman, 1980] </ref>. Not every macro was easy to express in this new format, however. Consider the INC macro discussed above. As of November 1978, the Lisp Machine DEFMACRO destructuring was not quite rich enough to handle "optional" argument forms: (DEFUN INC MACRO (VAR .
Reference: [Pitman, 1983] <author> Pitman, Kent M. </author> <note> The Revised MacLISP Manual. MIT/LCS/TR 295, </note> <institution> MIT Laboratory for Computer Science, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: Steele soon took responsibility for maintaining the MacLisp interpreter and runtime system, allowing Jon L to concentrate almost full time on compiler improvements. The resulting new MacLisp compiler, NCOMPLR <ref> [Moon, 1974; Lisp Archive; Pitman, 1983] </ref>, became a standard against which all other Lisp compilers were measured in terms of the speed of running code.
Reference: [Pratt, 1973] <author> Pratt, Vaughan R. </author> <title> Top down operator precedence. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 41-51, </pages> <address> Boston, </address> <month> October </month> <year> 1973. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: EXPR UNION (X,Y); %MLISP version of UNION IF :X THEN Y ELSE IF X [1] * Y THEN UNION (Xfi1,Y) ELSE X [1] CONS UNION (Xfi1,Y); Vaughan Pratt developed an Algol-style notation for Lisp called CGOL <ref> [Pratt, 1973] </ref>. Rather than embedding algebraic syntax within S-expressions, CGOL employed a separate full-blown to-kenizer and parser. This was first implemented for Stanford Lisp 1.6 in 1970 when Pratt was at Stanford; at this time there was an exchange of ideas with the MLISP project.
Reference: [Pratt, 1976] <author> Pratt, Vaughan R. CGOL: </author> <title> An Alternative External Representation for LISP Users. </title> <type> AI Working Paper 121, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> March </month> <year> 1976. </year> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 77 </booktitle>
Reference-contexts: This was first implemented for Stanford Lisp 1.6 in 1970 when Pratt was at Stanford; at this time there was an exchange of ideas with the MLISP project. After Pratt went to MIT shortly thereafter, he implemented a version for MacLisp <ref> [Pratt, 1976] </ref>. Versions of this parser Steele and Gabriel, Evolution of Lisp 56 were also used in the symbolic algebra systems SCRATCHPAD at IBM Yorktown and MACSYMA at MIT's Project MAC; Fred Blair, who also developed LISP370, did the reimplementation for SCRATCHPAD, while Michael Genesereth did it for MACSYMA. <p> It is not obvious that this is the best choice; Henneman chose to give CONS (in the form of CONNECT : : : TO : : : ) higher precedence than UNION. Pratt remarked <ref> [Pratt, 1976] </ref>: If you want to use the CGOL notation but don't want to have anything to do with binding powers, simply parenthesize every CGOL expression as though you were writing in Lisp. However, if you omit all parentheses : : : you will not often go wrong.
Reference: [Quam, 1972] <author> Quam, Lynn H., and Whitfield Diffie. </author> <title> Stanford LISP 1.6 Manual. SAIL Operating Note 28.6, </title> <institution> Stanford Artificial Intelligence Laboratory, Stanford, California, </institution> <year> 1972. </year>
Reference-contexts: This version of PSL and Nmode was commercialized by Hewlett-Packard in the mid-1980's. At Stanford in the 1960's, an early version of MacLisp was adapted for their PDP-6; this Lisp was called Lisp 1.6 <ref> [Quam, 1972] </ref>. The early adaptation was rewritten by John Allen and Lynn Quam; later compiler improvements were made by Whit Diffie. Lisp 1.6 disappeared during the mid-1970's, one of the last remnants of the Lisp 1.5 era.
Reference: [Raymond, 1991] <author> Raymond, Eric, ed. </author> <title> The New Hacker's Dictionary. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year> <note> ISBN 0-262-68069-6. </note>
Reference-contexts: Nowadays such an exception is referred to as a kluge <ref> [Raymond, 1991] </ref>. (Note, however, that MacLisp's APPLY function supported this same kluge.) MacLisp introduced the LEXPR, which is a type of function that takes any number of arguments and puts them on the stack; the single parameter of the function is bound to the number of arguments passed. <p> Interlisp ran on PDP-10's, Vaxen (plural of VAX <ref> [Raymond, 1991] </ref>), and a variety of special-purpose Lisp machines developed by Xerox and BBN. The most commonly available Interlisp machines were the Dolphin, the Dorado, and the Dandelion (collectively known as D-machines). The Dorado was the fastest of the three and the Dandelion the most commonly used. <p> Once the process began, the approach to the problem changed from just a consolidation of existing dialects, which was the obvious direction to take, to trying to design The Right Thing <ref> [Raymond, 1991] </ref>. Some people took the view that this was a good time to rethink some issues and to abandon the goal of strict MacLisp compatibility, which was so important to the early Lisp-Machine Lisp designs. <p> the same as the symbol NIL. (A running joke was that NIL (New Implementation of Lisp) unburdened NIL of its role as the empty list so that it would be free to serve as the name of the language!) Eventually the desire to be compatible with the past, however crufty <ref> [Raymond, 1991] </ref>, carried the day. It is worth noting that Lisp implementors have not been tempted to identify NIL with the number 0 (as opposed to the internal address 0), with one notable exception, a Lisp system for the PDP-11 written in the 1970's by Richard M. <p> Therefore, there is little compile-time type checking, there are few module systems, there is little safety or discipline built into the language. It is an "anarchic" language, while most other languages are "fascist" (as hackers would have it <ref> [Raymond, 1991] </ref>). Here are how some others have put it: LISP is unusual, in the sense that it clearly deviates from every other type of programming language that has ever been developed: : : . The theoretical concepts and implications of LISP far transcend its practical usage. |Jean E.
Reference: [Rees, 1982] <author> Rees, Jonathan A., and Norman I. Adams IV. </author> <title> T: A dialect of Lisp; or, LAMBDA: The ultimate software tool. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1982], </year> <pages> pp. 114-122. </pages>
Reference-contexts: This resulted in the dialect of Scheme known as T; this name was a good joke all around, since T was to Scheme approximately what the NIL dialect was to MacLisp. The goal was to be a simple dialect with an especially efficient implementation <ref> [Rees, 1982] </ref>: T centers around a small core language, free of complicated features, thus easy to learn: : : : [We] have refrained from supporting features that we didn't feel completely right about.
Reference: [Rees, 1986] <editor> Rees, Jonathan, William Clinger, et al. </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21:12, </volume> <pages> pp. 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Steele and Gabriel, Evolution of Lisp 19 Subsequently Steele and Sussman wrote a revised report on Scheme [Steele, 1978c]; the title of the report was intended as a tribute to Algol but in turn inspired another increasingly silly series of titles <ref> [Clinger, 1985a; Clinger, 1985b; Rees, 1986] </ref>. Shortly thereafter they wrote an extended monograph, whose title was a play on The Art of the Fugue, illustrating numerous small Lisp interpreters with variations. The monograph was never finished; only parts Zero, One, and Two were published [Steele, 1978b]. <p> Programmers accustomed to other dialects of Lisp should beware that Scheme has already done away with the nonsense that identifies the empty list with the symbol nil. The Revised 3 Report on the Algorithmic Language Scheme <ref> [Rees, 1986] </ref> shortened #!false and #!true to #f and #t, and made a remark that is similar but more refined (in both senses): The empty list counts as false for compatibility with existing programs and imple mentations that assume this to be the case.
Reference: [Reynolds, 1972] <author> Reynolds, John C. </author> <title> Definitional interpreters for higher order programming languages. </title> <booktitle> In Proceedings of the ACM National Conference, </booktitle> <pages> pp. 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Lambda: The Ultimate Imperative [Steele, 1976a] demonstrated how a wide variety of control structure ideas could be modeled in Scheme. Some of the models drew on earlier work by Peter Landin, John Reynolds, and others <ref> [Landin, 1965; Reynolds, 1972; Fried-man, 1975] </ref>.
Reference: [Robinson, 1982] <author> Robinson, J. A., and E. E. Sibert. LOGLISP: </author> <title> Motivation, design, and implementation. </title> <editor> In [Clark, </editor> <year> 1982], </year> <pages> pp. 299-313. </pages>
Reference-contexts: Such efforts were particularly a feature of the software side of the Japanese Fifth Generation project. Examples of this are Robinson's LOGLISP <ref> [Robinson, 1982] </ref>, the TAO project [Takeuchi, 1983; Okuno, 1984], and TABLOG [Malachi, 1984].
Reference: [Roylance, 1988] <author> Roylance, Gerald. </author> <title> Expressing mathematical subroutines constructively. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 8-13. </pages>
Reference-contexts: Steele broke an implementation or two on the trade-show floor with this three-part test. Gerald Sussman and his students (including Gerald Roylance and Matthew Halfant) became interested in numerical applications and in the use of Lisp to generate and transform numerical programs <ref> [Sussman, 1988; Roylance, 1988] </ref>. Sussman also spent a fair amount of time at MIT teaching Lisp to undergraduates. Sussman thought it was absolutely crazy to have to tell students that the quotient of 10.0 and 4.0 was 2.5 but the quotient of 10 and 4 was 2.
Reference: [Rudloe, 1962] <author> Rudloe, H. </author> <title> Tape Editor. </title> <institution> Program Write-up BBN-101, Bolt Beranek and Newman Inc., Cambridge, Massachusetts, </institution> <month> January </month> <year> 1962. </year>
Reference-contexts: The origin of these ideas can be found in Warren Teitelman's PhD dissertation on man-computer symbiosis [Teitelman, 1966]. In particular, it contains the roots of structure editing (as opposed to "text" or "tape" editing <ref> [Rudloe, 1962] </ref>), breakpointing, advice, and CLISP. (William Henneman in 1964 described a translator for the A-language [Henneman, 1964], an English-like or Algol-like surface syntax for Lisp (see section 3.5.1), but it was not nearly as elaborate or as flexible as Steele and Gabriel, Evolution of Lisp 8 CLISP.
Reference: [Sabot, 1988] <author> Sabot, Gary W. </author> <title> The Paralation Model: Architecture-Independent Parallel Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year> <note> ISBN 0-262-19277-2. </note>
Reference: [Sammet, 1969] <author> Jean E. Sammet. </author> <title> Programming Languages: History and Fundamentals. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1969. </year>
Reference-contexts: There appears to have been some hope that this design would supersede Lisp 1.5 and bring symbolic processing closer to ALGOL 60. (See section 3.5 for an example of Lisp 2 code.) Lisp 2 was implemented for the Q-32 computer but never achieved wide acceptance. Jean Sammet remarked <ref> [Sammet, 1969, p. 596] </ref>: : : : in contrast to most languages, in which the language is first designed and then implemented : : : it was facetiously said of LISP 2 that is was "an implementation in search of a language". <p> Here are how some others have put it: LISP is unusual, in the sense that it clearly deviates from every other type of programming language that has ever been developed: : : . The theoretical concepts and implications of LISP far transcend its practical usage. |Jean E. Sammet <ref> [Sammet, 1969, p. 406] </ref> This is one of the great advantage of Lisp-like languages: They have very few ways of forming compound expressions, and almost no syntactic structure: : : : After a short time we forget about syntactic details of the language (because there are none) and get on with
Reference: [Saunders, 1964a] <author> Saunders, Robert A. </author> <title> The LISP listing for the Q-32 compiler, and some samples. </title> <booktitle> In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 290-317. </pages>
Reference-contexts: Hart's macro language was subsequently used in the Lisp system for the Q-32 [Saunders, 1964b]. Inspection of the MDEF function in the compiler code <ref> [Saunders, 1964a, p. 311] </ref> reveals that the error in processing PROG statements had been repaired: mdef [caddr [l]] was replaced by mdef [cddr [l]]. (In fact, this may be what Hart had originally intended; in [Hart, 1963] the "a" appears to have been written in by hand as a correction over
Reference: [Saunders, 1964b] <author> Saunders, Robert A. </author> <title> The LISP system for the Q-32 computer. </title> <booktitle> In [Berkeley, </booktitle> <year> 1964], </year> <pages> pp. 220-238. </pages>
Reference-contexts: Robert Saunders and his colleagues at System Development Corporation implemented Lisp 1.5 on the IBM-built AN/FSQ-32/V computer, often called simply the Q-32 <ref> [Saunders, 1964b] </ref>. The implementation was bootstrapped from the IBM 7090 and PDP-1 computers at Stanford University. (The PDP-1 Lisp at Stanford was implemented by John McCarthy and Steve Russell.) In 1963, L. <p> Finally, Hart achieved an amazing increase in expressive power with a deceptively simple change to the language, by encouraging the user to exploit the power of Lisp to serve as its own metalanguage. Hart's macro language was subsequently used in the Lisp system for the Q-32 <ref> [Saunders, 1964b] </ref>. <p> Lisp 1.5 on the 7090 had floating-point [McCarthy, 1962], as did Q-32 Lisp <ref> [Saunders, 1964b] </ref> and PDP-6 Lisp [PDP-6 Lisp, 1967].) We are still a little uncertain about the origin of bignums (a data type that uses a variable amount of storage so as to represent arbitrarily large integer values, subject to the total size of the heap, which is where bignums are stored).
Reference: [Shaw, 1981] <author> Shaw, Mary, Wm. A. Wulf, and Ralph L. </author> <title> London. Abstraction and verification in Alphard: Iteration and generators. </title> <editor> In Shaw, Mary, ed., </editor> <title> ALPHARD: Form and Content, </title> <booktitle> chapter 3, </booktitle> <pages> pp. 73-116. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year> <note> ISBN 0-387-90663-0. </note>
Reference-contexts: The complete example might be rendered as (let ((num (generator (scan-range :start 0 :below 100)))) (gathering ((result collect-sum)) (loop (let ((j (next-in num (return result)))) (if (plusp j) (next-out result j)))))) This reminds one of the possibilities lists of Conniver [McDermott, 1974] or of the generators of Alphard <ref> [Shaw, 1981] </ref>, though we know of no direct connection. Generators and gatherers emphasize use of control structure rather than functional relationships. After much debate, X3J13 applauded the development of series and generators but rejected them for standardization purposes, preferring to subject them first to the test of time.
Reference: [Smith, 1970] <author> Smith, David Canfield. MLISP. </author> <type> Technical Report AIM-135, </type> <institution> Stanford Artificial Intelligence Project, </institution> <month> October </month> <year> 1970. </year>
Reference-contexts: MLISP was an Algol-like syntax for Lisp, first implemented for the IBM 360 by Horace Enea and then re-implemented for the PDP-10 under Stanford Lisp 1.6 <ref> [Smith, 1970] </ref>. It provided infix operators; a complex FOR construct for iteration; various subscripting notations such as A (1,3) (element of a two-dimensional array) and L [1,3,2] (equivalent to (cadr (caddr (car L)))); "vector" operations (a concise notation for MAPCAR); and destructuring assignment.
Reference: [Smith, 1973] <author> Smith, David Canfield, and Horace J. Enea. </author> <title> Backtracking in MLISP2: An efficient backtracking method for LISP. </title> <booktitle> In [IJCAI, </booktitle> <year> 1973], </year> <pages> pp. 677-685. </pages>
Reference: [Smith, 1975] <author> Smith, Brian C., and Carl Hewitt. </author> <title> A PLASMA Primer. </title> <type> Working Paper 92, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> October </month> <year> 1975. </year>
Reference-contexts: The under-the-table activity brought out by Conniver was made even more explicit in this model; everything was message-passing, everything ran on continuations. Hewitt and his student Brian Smith commented on the interaction of a number of research groups at the time <ref> [Smith, 1975] </ref>: The early work on PLANNER was done at MIT and published in IJCAI-69 [Hewitt, 1969]. <p> This language was first called Planner-73 but the name was later changed to PLASMA (PLAnner-like System Modeled on Actors) <ref> [Smith, 1975; Hewitt, 1975] </ref>. While the syntax of PLASMA was recognizably Lisp-like, it made use of several kinds of parentheses and brackets (as did Muddle) as well as many other special characters.
Reference: [Sobalvarro, 1988] <author> Sobalvarro, Patrick G. </author> <title> A Lifetime-based Garbage Collector for LISP Systems on General-Purpose Computers. </title> <type> Bachelor's Thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, Mas-sachusetts, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Also in 1989, the first non-intrusive garbage collectors appeared from the companies Lucid and Franz. The Lucid collector is an ephemeral garbage collector based on a combination of ideas from Smalltalk generation scavengers and the Symbolics ephemeral garbage collector <ref> [Sobalvarro, 1988] </ref>. The appearance of these collectors seemed to have the effect of increasing the legitimacy of stock-hardware Lisp companies to the same or higher level than the Lisp machine companies.
Reference: [Stallman, 1976] <author> Stallman, Richard M., and Gerald Jay Sussman. </author> <title> Forward Reasoning and Dependency-Directed Backtracking in a System for Computer-Aided Circuit Analysis. </title> <type> AI Memo 380, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1976. </year> <note> Also in Artificial Intelligence, </note> <month> 9, </month> <pages> pp. 135-196, </pages> <year> 1977. </year>
Reference-contexts: After Scheme, a few new Lisp-based languages were developed in this direction by Sussman and his students, including constraint-based systems <ref> [Sussman, 1975a; Stallman, 1976; Steele, 1979; de Kleer, 1978b] </ref> and truth maintenance systems [de Kleer, 1978a; McAllester, 1978] based on non-monotonic logic. The technique of dependency-directed backtracking eliminated the "giant nest of FORALL loops" effect of chronological backtracking.
Reference: [Steele, 1975] <author> Steele, Guy Lewis, Jr. </author> <title> Multiprocessing compactifying garbage collection. </title> <journal> Communications of the ACM, </journal> <volume> 18:9, </volume> <pages> pp. 495-508, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: Such copying back and forth to disk was equivalent Steele and Gabriel, Evolution of Lisp 14 to a slow, manually triggered copying garbage collector. (While there was a great deal of theoretical work on interleaved and concurrent garbage collection during the 1970's <ref> [Steele, 1975; Gries, 1977; Baker, 1978; Cohen, 1981] </ref>, continuous garbage collection was not universally accepted until David Moon's invention of ephemeral garbage collection and its implementation on Lisp Machines [Moon, 1984].
Reference: [Steele, 1976a] <author> Steele, Guy Lewis, Jr., and Gerald Jay Sussman. </author> <title> LAMBDA: The Ultimate Imperative. </title> <type> AI Memo 353, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> March </month> <year> 1976. </year> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 78 </booktitle>
Reference-contexts: In 1976 Sussman and Steele wrote two more papers that explored programming language semantics using Scheme as a framework. Lambda: The Ultimate Imperative <ref> [Steele, 1976a] </ref> demonstrated how a wide variety of control structure ideas could be modeled in Scheme. Some of the models drew on earlier work by Peter Landin, John Reynolds, and others [Landin, 1965; Reynolds, 1972; Fried-man, 1975].
Reference: [Steele, 1976b] <author> Steele, Guy Lewis, Jr. </author> <title> LAMBDA: The Ultimate Declarative. </title> <type> AI Memo 379, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> November </month> <year> 1976. </year>
Reference-contexts: catalog of control structures. (This paper was also notable as the first in a long series of "Lambda: The Ultimate X " papers, a running gag that is as well-known in the Lisp community as the "X Considered Harmful" titles are in the broader programming-languages community.) Lambda: The Ultimate Declarative <ref> [Steele, 1976b] </ref> concentrated on the nature of lambda as a renaming construct; it also provided a more extensive comparison of Scheme and Hewitt's PLASMA (see section 4), relating object-oriented programming generally and actors specifically to closures.
Reference: [Steele, 1977a] <author> Steele, Guy Lewis, Jr. </author> <title> Compiler Optimization Based on Viewing LAMBDA as Rename plus Goto. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1977. </year> <note> Published as [Steele, </note> <year> 1978a]. </year>
Reference: [Steele, 1977b] <author> Steele, Guy Lewis, Jr. </author> <title> Data representations in PDP-10 MacLISP. </title> <booktitle> In Proceedings of the 1977 MACSYMA Users' Conference, </booktitle> <pages> pp. 203-214, </pages> <address> Washington, D. C., </address> <month> July </month> <year> 1977. </year> <institution> NASA Scientific and Technical Information Office. </institution> <note> Also published as AI Memo 420, </note> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1977. </year>
Reference-contexts: The first good numerical Lisp compiler was developed for the MACSYMA group <ref> [Golden, 1970; Steele, 1977b; Steele, 1977c] </ref>; it was important to them and their users that numerical code be both fast and compact. The result was a Lisp compiler that was competitive with the DEC PDP-10 FORTRAN compiler [Fateman, 1973]. The S-1 was initially intended to be a fast signal processor.
Reference: [Steele, 1977c] <author> Steele, Guy Lewis, Jr. </author> <title> Fast arithmetic in maclisp. </title> <booktitle> In Proceedings of the 1977 MACSYMA Users' Conference, </booktitle> <pages> pp. 215-224, </pages> <address> Washington, D. C., </address> <month> July </month> <year> 1977. </year> <institution> NASA Scientific and Technical Information Office. </institution> <note> Also published as AI Memo 421, </note> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1977. </year>
Reference-contexts: The first good numerical Lisp compiler was developed for the MACSYMA group <ref> [Golden, 1970; Steele, 1977b; Steele, 1977c] </ref>; it was important to them and their users that numerical code be both fast and compact. The result was a Lisp compiler that was competitive with the DEC PDP-10 FORTRAN compiler [Fateman, 1973]. The S-1 was initially intended to be a fast signal processor.
Reference: [Steele, 1977d] <author> Steele, Guy L., Jr. </author> <title> Macaroni is better than spaghetti. </title> <booktitle> In [ACM AIPL, </booktitle> <year> 1977], </year> <pages> pp. 60-66. </pages>
Reference-contexts: Like spaghetti stacks, Conniver provided separate notions of a data environment and a control environment and the possibility or creating closures over either. (Later work with the Scheme language brought out the point that data environments and control environments do not play symmetrical roles in the interpretation of Lisp-like languages <ref> [Steele, 1977d] </ref>.) Conniver differed from spaghetti stacks in ways stemming primarily from implementation considerations.
Reference: [Steele, 1977e] <author> Steele, Guy Lewis, Jr. </author> <title> Debunking the `expensive procedure call' myth; or, Procedure call implementations considered harmful; or, LAMBDA: The ultimate GOTO. </title> <booktitle> In Proceedings of the ACM National Conference, </booktitle> <pages> pp. 153-162, </pages> <address> Seattle, </address> <month> October </month> <year> 1977. </year> <institution> Association for Computing Machinery. </institution> <note> Revised version published as AI Memo 443, </note> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> October </month> <year> 1977. </year>
Reference: [Steele, 1978a] <author> Steele, Guy Lewis, Jr. RABBIT: </author> <title> A Compiler for SCHEME (A Study in Compiler Optimization). </title> <type> Technical Report 474, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1978. </year> <note> This is a revised version of the author's master's thesis [Steele, </note> <year> 1977a]. </year>
Reference-contexts: This in turn suggested a set of techniques for constructing a practical compiler for Scheme, which this paper outlined in some detail. This paper was a thesis proposal; the resulting dissertation discussed a Scheme compiler called RABBIT <ref> [Steele, 1978a] </ref>. Mitchell Wand and Daniel Friedman were doing similar work at Indiana University [Wand, 1977] and they exchanged papers with Sussman and Steele during this period. <p> The T project Steele and Gabriel, Evolution of Lisp 20 started with a version of the S-1 Lisp compiler [Brooks, 1982b] and made substantial improvements; in the course of their work they identified several bugs in the S-1 compiler and in the original report on RABBIT <ref> [Steele, 1978a] </ref>. Like the S-1 Lisp compiler, it relied heavily on optimization strategies from the mainstream compiler literature, most notably the work by Wulf and others on the BLISS-11 compiler [Wulf, 1975]. <p> However, none of these techniques provides an iron-glad guarantee. Steele pointed out that careful use of thunks could provably eliminate the problem, though not in all situations <ref> [Steele, 1978a] </ref>. The proponents of Scheme regarded all of these arrangements as too flawed or too clumsy for "official" adoption into Scheme. The result was that Scheme diversified in the 1980's. Nearly every implementation had some kind of macro facility but no two were alike.
Reference: [Steele, 1978b] <author> Steele, Guy Lewis, Jr., and Gerald Jay Sussman. </author> <title> The Art of the Interpreter; or, The Modularity Complex (Parts Zero, One, and Two). </title> <type> AI Memo 453, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: Shortly thereafter they wrote an extended monograph, whose title was a play on The Art of the Fugue, illustrating numerous small Lisp interpreters with variations. The monograph was never finished; only parts Zero, One, and Two were published <ref> [Steele, 1978b] </ref>. Part Zero introduced a tiny first-order dialect of Lisp modeled on recursion equations. Part One discussed procedures as data and explored lexical and dynamic binding. Part Two addressed the decomposition of state and the meaning of side effects. <p> For examples of interpreters that solve the third problem in about 100 lines of code, see <ref> [Steele, 1978c; Steele, 1978b] </ref>. Steele and Gabriel, Evolution of Lisp 61 There is a rich tradition of experimenting with augmentations of Lisp, ranging from "let's add just one new feature" to inventing completely new languages using Lisp as an implementation language. <p> This allowed for extremely rapid experimentation with language and implementation ideas; at one point Sussman and Steele were testing and measuring as many as ten new interpreters a week. Some of their results were summarized in The Art of the Interpreter <ref> [Steele, 1978b] </ref>. A particular point of interest was comparison of call-by-name and call-by-value parameters; in this they were influenced by work at Indiana University discussed in the paper CONS Should Not Evaluate Its Arguments [Friedman, 1975].
Reference: [Steele, 1978c] <author> Steele, Guy Lewis, Jr., and Gerald Jay Sussman. </author> <title> The Revised Report on SCHEME: A Dialect of LISP. </title> <type> AI Memo 452, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1978. </year>
Reference-contexts: Mitchell Wand and Daniel Friedman were doing similar work at Indiana University [Wand, 1977] and they exchanged papers with Sussman and Steele during this period. Steele and Gabriel, Evolution of Lisp 19 Subsequently Steele and Sussman wrote a revised report on Scheme <ref> [Steele, 1978c] </ref>; the title of the report was intended as a tribute to Algol but in turn inspired another increasingly silly series of titles [Clinger, 1985a; Clinger, 1985b; Rees, 1986]. <p> For examples of interpreters that solve the third problem in about 100 lines of code, see <ref> [Steele, 1978c; Steele, 1978b] </ref>. Steele and Gabriel, Evolution of Lisp 61 There is a rich tradition of experimenting with augmentations of Lisp, ranging from "let's add just one new feature" to inventing completely new languages using Lisp as an implementation language.
Reference: [Steele, 1979] <author> Steele, Guy Lewis, Jr., and Gerald Jay Sussman. </author> <title> Constraints. </title> <booktitle> In Proceedings of the APL 79 Conference, </booktitle> <pages> pp. 208-225, </pages> <address> Rochester, New York, </address> <month> June </month> <year> 1979. </year> <journal> Association for Computing Machinery. APL Quote Quad, </journal> <volume> 9:4, </volume> <month> June </month> <year> 1979. </year> <note> Also published as AI Memo 502, </note> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> November </month> <year> 1978. </year>
Reference-contexts: After Scheme, a few new Lisp-based languages were developed in this direction by Sussman and his students, including constraint-based systems <ref> [Sussman, 1975a; Stallman, 1976; Steele, 1979; de Kleer, 1978b] </ref> and truth maintenance systems [de Kleer, 1978a; McAllester, 1978] based on non-monotonic logic. The technique of dependency-directed backtracking eliminated the "giant nest of FORALL loops" effect of chronological backtracking.
Reference: [Steele, 1980] <author> Steele, Guy Lewis, Jr., and Gerald Jay Sussman. </author> <title> The dream of a lifetime: A lazy variable extent mechanism. </title> <booktitle> In [Lisp Conference, </booktitle> <year> 1980], </year> <pages> pp. 163-172. </pages>
Reference: [Steele, 1982] <author> Steele, Guy L., Jr. </author> <title> An overview of Common Lisp. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1982], </year> <pages> pp. 98-107. </pages>
Reference-contexts: Scott Fahlman said, "The MacLisp community is not in a state of chaos. It consists of four well-defined groups going in four well-defined directions." There was a moment's pause for the laughter to subside <ref> [Steele, 1982] </ref>. Gabriel attended the Interlisp pow-wow the day before the ARPA meeting, and he also witnessed the spectacle of the MacLisp community at the meeting.
Reference: [Steele, 1986] <author> Steele, Guy L., Jr., and W. Daniel Hillis. </author> <title> Connection Machine Lisp: Fine-grained parallel symbolic processing. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 279-297. </pages>
Reference-contexts: Qlisp was implemented on the Alliant FX8 and was the first compiled parallel Lisp implementation. Connection Machine Lisp <ref> [Steele, 1986] </ref> was a dialect of Common Lisp extended with a new data structure, the xapping intended to support fine-grain data parallelism. A xapping was imple-mentationally a strange hybrid of array, hash table, and association list; semantically it is a set of ordered index-value pairs.
Reference: [Steele, 1990a] <author> Steele, Guy L., Jr. </author> <title> Making asynchronous parallelism safe for the world. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 218-231, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year> <institution> Association for Computing Machinery. </institution> <note> ISBN 0-89791-343-4. </note>
Reference: [Steele, 1990b] <author> Steele, Guy L., Jr., and Jon L White. </author> <title> How to print floating-point numbers accurately. </title> <booktitle> In [ACM PLDI, </booktitle> <year> 1990], </year> <pages> pp. 112-126. </pages>
Reference: [Sussman, 1971] <author> Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. </author> <title> Micro-PLANNER Reference Manual. </title> <institution> AI Memo 203A, MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> December </month> <year> 1971. </year>
Reference-contexts: It was never completely implemented as originally envisioned, but it spurred three other important developments in the history of Lisp: Micro-Planner, Muddle, and Conniver. Gerald Jay Sussman, Drew McDermott, and Eugene Charniak implemented a subset of Planner called Micro-Planner <ref> [Sussman, 1971] </ref>, which was embedded within the MIT PDP-6 Lisp system that eventually became MacLisp. The semantics of the language as implemented were not completely formalized. <p> Of course, other languages have had this mechanism, but in Lisp the data typing mechanism combines with the powerful macro facility and the functional nature of the language to allow entirely new computing paradigms to be built in Lisp. For example, we have seen data-driven paradigms <ref> [Sussman, 1971] </ref>, possible-worlds paradigms [McDermott, 1974], and object-oriented paradigms [Moon, 1986] [Bobrow, 1986] implemented in Lisp in such a way that the seams between Lisp and these new paradigms are essentially invisible. Its interactive and incremental nature.
Reference: [Sussman, 1972a] <author> Sussman, Gerald Jay, and Drew Vincent McDermott. </author> <title> From PLANNER to CONNIVER| A genetic approach. </title> <booktitle> In Proceedings of the 1972 Fall Joint Computer Conference, </booktitle> <pages> pp. 1171-1179, </pages> <address> Montvale, New Jersey, </address> <month> August </month> <year> 1972. </year> <note> AFIPS Press. This is the published version of [Sussman, 1972b]. </note> <author> Steele and Gabriel, </author> <title> Evolution of Lisp 79 </title>
Reference-contexts: The language Conniver was designed by Drew McDermott and Gerald Jay Sussman in 1972 in reaction to perceived limitations of Micro-Planner and in particular of its control structure. In the classic paper Why Conniving Is Better Than Planning <ref> [Sussman, 1972b; Sussman, 1972a] </ref>, they argued that automatic nested backtracking was merely an overly complicated way to express a set of FORALL loops used to perform exhaustive search: It is our contention that the backtrack control structure that is the backbone of Planner is more of a hindrance in the solution
Reference: [Sussman, 1972b] <author> Sussman, Gerald Jay, and Drew Vincent McDermott. </author> <title> Why Conniving is Better than Planning. </title> <institution> AI Memo 255A, MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> April </month> <year> 1972. </year>
Reference-contexts: The language Conniver was designed by Drew McDermott and Gerald Jay Sussman in 1972 in reaction to perceived limitations of Micro-Planner and in particular of its control structure. In the classic paper Why Conniving Is Better Than Planning <ref> [Sussman, 1972b; Sussman, 1972a] </ref>, they argued that automatic nested backtracking was merely an overly complicated way to express a set of FORALL loops used to perform exhaustive search: It is our contention that the backtrack control structure that is the backbone of Planner is more of a hindrance in the solution
Reference: [Sussman, 1975a] <author> Sussman, Gerald Jay, and Richard M Stallman. </author> <title> Heuristic Techniques in Computer-Aided Circuit Analysis. </title> <type> AI Memo 328, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> March </month> <year> 1975. </year>
Reference-contexts: After Scheme, a few new Lisp-based languages were developed in this direction by Sussman and his students, including constraint-based systems <ref> [Sussman, 1975a; Stallman, 1976; Steele, 1979; de Kleer, 1978b] </ref> and truth maintenance systems [de Kleer, 1978a; McAllester, 1978] based on non-monotonic logic. The technique of dependency-directed backtracking eliminated the "giant nest of FORALL loops" effect of chronological backtracking.
Reference: [Sussman, 1975b] <author> Sussman, Gerald Jay, and Guy Lewis Steele Jr. </author> <title> SCHEME: An Interpreter for Extended Lambda Calculus. </title> <type> AI Memo 349, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> December </month> <year> 1975. </year>
Reference-contexts: The initial report on Scheme <ref> [Sussman, 1975b] </ref> describes a very spare language, with a minimum of primitive constructs, one per concept. (Why take two when one will do?) There was a function constructor lambda, a fixpoint operator labels, a condition if, a side effect aset, a continuation accessor catch, function application, variable references, and not too
Reference: [Sussman, 1988] <author> Sussman, Gerald Jay, and Matthew Halfant. </author> <title> Abstraction in numerical methods. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 1-7. </pages>
Reference-contexts: Steele broke an implementation or two on the trade-show floor with this three-part test. Gerald Sussman and his students (including Gerald Roylance and Matthew Halfant) became interested in numerical applications and in the use of Lisp to generate and transform numerical programs <ref> [Sussman, 1988; Roylance, 1988] </ref>. Sussman also spent a fair amount of time at MIT teaching Lisp to undergraduates. Sussman thought it was absolutely crazy to have to tell students that the quotient of 10.0 and 4.0 was 2.5 but the quotient of 10 and 4 was 2.
Reference: [Swanson, 1988] <author> Swanson, Mark R., Robert R. Kessler, and Gary Lindstrom. </author> <title> An implementation of Portable Standard Lisp on the BBN Butterfly. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 132-142. </pages>
Reference-contexts: Thus pcall provides a certain structured discipline for the use of futures that is adequate for many purposes. Multilisp ran on the Concert multiprocessor, a collection of 32 Motorola 68000 processors. MultiScheme, a descendant of Multilisp, was later implemented for the BBN Butterfly [Miller, 1987]. Butterfly PSL <ref> [Swanson, 1988] </ref> was an implementation of Portable Standard Lisp [Griss, 1982] on the BBN Butterfly. It also relied entirely on futures for the spawning of parallel processes. Qlisp [Gabriel, 1984b; Goldman, 1988] was developed by Richard Gabriel and John McCarthy at Stanford.
Reference: [Swinehart, 1972] <author> Swinehart, D. C., and R. F. Sproull. SAIL. </author> <title> SAIL Operating Note 57.2, </title> <institution> Stanford Artificial Intelligence Laboratory, Stanford, California, </institution> <year> 1972. </year>
Reference: [Symbolics, 1985] <institution> Symbolics, Inc., Cambridge, Massachusetts. </institution> <note> Reference Guide to Symbolics-Lisp, </note> <month> March </month> <year> 1985. </year>
Reference-contexts: In 1986 four groups began to vie for defining the object-oriented programming part of Common Lisp: New Flavors (Symbolics) <ref> [Symbolics, 1985] </ref>, CommonLoops (Xerox) [Bobrow, 1986], Object Lisp (LMI) [Drescher, 1987], and Common Objects (HP) [Kempf, 1987]. After a six-month battle, a group was formed to write the standard for CLOS based on CommonLoops and New Flavors. This group was David A. Moon (Symbolics), Daniel G.
Reference: [Takeuchi, 1983] <author> Takeuchi, Ikuo, Hirochi Okuno, and Nobuyasu Ohsato. TAO: </author> <title> A harmonic mean of Lisp, Prolog, and Smalltalk. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 18:7, </volume> <pages> pp. 65-74, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Such efforts were particularly a feature of the software side of the Japanese Fifth Generation project. Examples of this are Robinson's LOGLISP [Robinson, 1982], the TAO project <ref> [Takeuchi, 1983; Okuno, 1984] </ref>, and TABLOG [Malachi, 1984].
Reference: [Teitelman, 1966] <author> Teitelman, Warren. </author> <title> PILOT: A Step toward Man-Computer Symbiosis. </title> <type> Technical Report MAC-TR-32, </type> <institution> MIT Project MAC, </institution> <month> September </month> <year> 1966. </year> <type> Ph.D. thesis. </type>
Reference-contexts: The most visible of these ideas are embodied in programming tools, such as the spelling corrector, the file package, DWIM, CLISP, the structure editor, and MASTERSCOPE. The origin of these ideas can be found in Warren Teitelman's PhD dissertation on man-computer symbiosis <ref> [Teitelman, 1966] </ref>.
Reference: [Teitelman, 1971] <author> Teitelman, W., D. G. Bobrow, A. K. Hartley, and D. L. Murphy. BBN-LISP: </author> <title> TENEX Reference Manual. </title> <institution> Bolt Beranek and Newman Inc., Cambridge, Massachusetts, </institution> <year> 1971. </year>
Reference-contexts: L. Murphy. A further upward-compatible version was written for the PDP-10 by Alice Hartley and Murphy, and this Lisp was called BBN Lisp <ref> [Teitelman, 1971] </ref>. In 1973, not long after the time that SDS was acquired by Xerox and renamed Xerox Data Systems, the maintenance of BBN Lisp was shared by BBN and Xerox Palo Alto Research Center and the name of the Lisp was changed to Interlisp [Teitelman, 1974]. <p> While expanding the call to si:displaced is not free, it is presumably cheaper than continually re-expanding the original macro call (if not, then the macro writer shouldn't use displace). The Lisp Machine pretty-printer recognizes calls to si:displace and prints only the original macro call. BBN Lisp <ref> [Teitelman, 1971] </ref> had three kinds of macro: open, computed, and substitution (described below). A macro definition was stored in the property list of its name under the MACRO property; the form of the property value determined which of three types of macro it was.
Reference: [Teitelman, 1973] <author> Teitelman, Warren. CLISP: </author> <title> Conversational LISP. </title> <booktitle> In [IJCAI, </booktitle> <year> 1973], </year> <pages> pp. 686-690. </pages>
Reference-contexts: Here is a simple program to print all the prime numbers p in the range m p n: (FOR P FROM M TO N DO (PRINT P) WHILE (PRIMEP P)) CLISP, DWIM, and the spelling corrector could work together to recognize the following as a valid definition of FACTORIAL <ref> [Teitelman, 1973] </ref>: DEFINEQ ((FACTORIAL (LAMBDA (N) (IFFN=0 THENN 1 ESLE N*8FACTTORIALNN-1)))) Interlisp eventually "corrects" this mangled definition into the valid form shown previously. Note that shift-8 is left parenthesis on the Model 33 teletype, which had a bit-paired keyboard.
Reference: [Teitelman, 1974] <author> Teitelman, Warren, et al. </author> <title> InterLISP Reference Manual. </title> <institution> Xerox Palo Alto Research Center, Palo Alto, California, </institution> <year> 1974. </year> <title> First revision. </title>
Reference-contexts: In 1973, not long after the time that SDS was acquired by Xerox and renamed Xerox Data Systems, the maintenance of BBN Lisp was shared by BBN and Xerox Palo Alto Research Center and the name of the Lisp was changed to Interlisp <ref> [Teitelman, 1974] </ref>. The PDP-6 [DEC, 1964] and PDP-10 [DEC, 1969] computers were, by design, especially suited for Lisp, with 36-bit words and 18-bit addresses. This allowed a CONS cell|a pair of pointers or addresses|to be stored efficiently in a single word. <p> When a symbol had no value (or no function definition), the Interlisp spelling corrector <ref> [Teitelman, 1974] </ref> was invoked, because the symbol might have been misspelled. The spelling corrector compared a possibly misspelled symbol with a list of known words. The user had options for controlling the behavior of the system with respect to spelling correction. <p> ECL might have survived longer if Wegbreit had not left Harvard for Xerox in the middle of the project. As it was, ECL was used for research and course work at Harvard throughout the 1970's. We have already discussed Teitelman's CLISP (Conversational Lisp), which was part of Interlisp <ref> [Teitelman, 1974] </ref>.
Reference: [Teitelman, 1978] <author> Teitelman, Warren, et al. </author> <title> InterLISP Reference Manual. </title> <institution> Xerox Palo Alto Research Center, Palo Alto, California, </institution> <month> October </month> <year> 1978. </year> <title> Third revision. </title>
Reference-contexts: Interlisp split the difference, giving the programmer a choice of speed or safety <ref> [Teitelman, 1978, p. 2.2] </ref>: Although most lists terminate in NIL, the occasional list that ends in an atom, e.g., (A B . C), or worse, a number or string, could cause bizarre effects. <p> Macros are expanded at function definition time, rather than on the fly as a function is interpreted or compiled. Note the switching off between S-expression and M-expression syntax. The STASH macro is the equivalent of the PUSH macro found in Interlisp <ref> [Teitelman, 1978] </ref> and later in Common Lisp by way of Lisp-Machine Lisp; the verb "stash" was commonly used in the 1960's. <p> A macro definition was stored in the property list of its name under the MACRO property; the form of the property value determined which of three types of macro it was. Originally all three types were effective only in compiled code. Eventually, however, after BBN Lisp became Interlisp <ref> [Teitelman, 1978] </ref>, a DWIM hack called MACROTRAN was added that made all three types of macro effective in interpreted code. If interpreting a function call resulted in an "undefined function" error, the DWIM system would step in. MACROTRAN would gain control, expand the macro, and evaluate the resulting expansion.
Reference: [Tesler, 1973] <author> Tesler, Lawrence G., Horace J. Enea, and David C. Smith. </author> <title> The LISP70 pattern matching system. </title> <booktitle> In [IJCAI, </booktitle> <year> 1973], </year> <pages> pp. 671-676. </pages>
Reference: [Thacker, 1982] <author> Thacker, C. P., E. M. McCreight, B. W. Lampson, R. F. Sproull, and D. R. Boggs. </author> <title> Alto: A personal computer. </title> <editor> In Siewiorek, Daniel P., C. Gordon Bell, and Allen Newell, eds., </editor> <booktitle> Computer Structures: Principles and Examples, Computer Science Series, chapter 33, </booktitle> <pages> pp. 549-572. </pages> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1982. </year> <note> ISBN 0-07-057302-6. </note>
Reference-contexts: Reading and writing are both methods that an object can support, and the CLOS adaptation of the Lisp version of Kay's vision was a simple reinvention of the object-oriented genesis of the idea. 2.6.2 Xerox Lisp Machines: 1973-1980 The Alto was a microcodable machine developed in 1973 <ref> [Thacker, 1982] </ref> and used for personal computing experimentation at Xerox, using Interlisp and other languages such as Mesa [Geschke, 1977]. The Alto version of the Interlisp environment first went into use at Xerox PARC and at Stanford University around 1975.
Reference: [Travis, 1977] <author> Travis, Larry, Masahiro Honda, Richard LeBlanc, and Stephen Zeigler. </author> <title> Design rationale for TELOS, a PASCAL-based AI language. </title> <booktitle> In [ACM AIPL, </booktitle> <year> 1977], </year> <pages> pp. 67-76. </pages>
Reference-contexts: Those that were not embedded usually had a syntax related to that of Algol, while including some of the other features of Lisp (such as symbolic data structures and recursive functions). Among these were POP-2 [Burstall, 1971], SAIL [Feldman, 1972], and the Pascal-based TELOS <ref> [Travis, 1977] </ref>.
Reference: [Ungar, 1984] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In [ACM PSDE, </booktitle> <year> 1984], </year> <pages> pp. 157-167. </pages>
Reference-contexts: The incremental garbage collector was released several years after the first 3600's. It proved to have relatively bad performance, possibly due to paging problems. Instead, Moon developed an ephemeral garbage collector that is similar to the Ungar generation scavenger collector developed for Smalltalk <ref> [Ungar, 1984] </ref>. With generation scavenging, objects are promoted from one generation to the next by a stop-and-copy process. After several generations objects are promoted (tenured) to long-term storage.
Reference: [Utah, 1982] <author> Utah Symbolic Computation Group. </author> <title> The Portable Standard LISP Users Manual. </title> <type> Technical Report TR-10, </type> <institution> Department of Computer Science, University of Utah, </institution> <address> Salt Lake City, </address> <month> January </month> <year> 1982. </year>
Reference-contexts: Most were more similar to MacLisp than to Interlisp. The two most widely used dialects were Standard Lisp [Marti, 1979] and Portable Standard Lisp <ref> [Utah, 1982] </ref>. Standard Lisp was defined by Anthony Hearn and Martin Griss, along with their students and colleagues. The motivation was to define a subset of Lisp 1.5 and other Lisp dialects that could serve as a medium for porting Lisp programs, most particularly the symbolic algebra system REDUCE.
Reference: [Vuillemin, 1988] <author> Vuillemin, Jean. </author> <title> Exact real computer arithmetic with continued fractions. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1988], </year> <pages> pp. 14-27. </pages>
Reference-contexts: It has been used in symbolic algebra systems [Mathlab Group, 1977], but has not become a fixture of Lisp dialects. Lisp is often used as a platform for this kind of research because having bignums gets you 2/3 of the way there <ref> [Boehm, 1986; Vuillemin, 1988] </ref>. The MacLisp functions HAULONG and HAIPART were introduced to support Macsyma's bigfloat arithmetic; these became the Common Lisp functions INTEGER-LENGTH and (by way of Lisp-Machine Lisp) LDB.
Reference: [Wand, 1977] <author> Wand, Mitchell, and Daniel P. Friedman. </author> <title> Compiling Lambda Expressions Using Continuations and Factorization. </title> <type> Technical Report 55, </type> <institution> Indiana University, </institution> <month> July </month> <year> 1977. </year> <editor> Steele and Gabriel, </editor> <booktitle> Evolution of Lisp 80 </booktitle>
Reference-contexts: This paper was a thesis proposal; the resulting dissertation discussed a Scheme compiler called RABBIT [Steele, 1978a]. Mitchell Wand and Daniel Friedman were doing similar work at Indiana University <ref> [Wand, 1977] </ref> and they exchanged papers with Sussman and Steele during this period.
Reference: [Waters, 1984] <author> Waters, Richard C. </author> <title> Expressional loops. </title> <booktitle> In Proceedings of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 1-10, </pages> <address> Salt Lake City, Utah, </address> <month> January </month> <year> 1984. </year> <institution> Association for Computing Machinery. </institution> <note> ISBN 0-89791-125-3. </note>
Reference-contexts: In the process X3J13 also considered two other approaches to iteration that had cropped up in the meantime: series (put forward by Richard Waters) and generators and gatherers (by Pavel Curtis and Crispin Perdue) <ref> [CLTL2, 1990; Waters, 1984; Waters, 1989a; Waters, 1989b] </ref>. The example Fortran DO loop shown above would be rendered using series as (collect-sum (choose-if #'plusp (#M (lambda (j) (a j)) (scan-range :start 0 :below 100))) The call to scan-range generates a series of integers from 0 (inclusive) to 100 (exclusive).
Reference: [Waters, 1989a] <author> Waters, Richard C. </author> <title> Optimization of Series Expressions, Part I: User's Manual for the Series Macro Package. </title> <type> AI Memo 1082, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: In the process X3J13 also considered two other approaches to iteration that had cropped up in the meantime: series (put forward by Richard Waters) and generators and gatherers (by Pavel Curtis and Crispin Perdue) <ref> [CLTL2, 1990; Waters, 1984; Waters, 1989a; Waters, 1989b] </ref>. The example Fortran DO loop shown above would be rendered using series as (collect-sum (choose-if #'plusp (#M (lambda (j) (a j)) (scan-range :start 0 :below 100))) The call to scan-range generates a series of integers from 0 (inclusive) to 100 (exclusive).
Reference: [Waters, 1989b] <author> Waters, Richard C. </author> <title> Optimization of Series Expressions, Part II: Overview of the Theory and Implementation. </title> <type> AI Memo 1083, </type> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: In the process X3J13 also considered two other approaches to iteration that had cropped up in the meantime: series (put forward by Richard Waters) and generators and gatherers (by Pavel Curtis and Crispin Perdue) <ref> [CLTL2, 1990; Waters, 1984; Waters, 1989a; Waters, 1989b] </ref>. The example Fortran DO loop shown above would be rendered using series as (collect-sum (choose-if #'plusp (#M (lambda (j) (a j)) (scan-range :start 0 :below 100))) The call to scan-range generates a series of integers from 0 (inclusive) to 100 (exclusive).
Reference: [Wegbreit, 1970] <author> Wegbreit, Ben. </author> <title> Studies in Extensible Programming Languages. </title> <type> PhD thesis, </type> <institution> Harvard University, Cambridge, Massachusetts, </institution> <year> 1970. </year>
Reference-contexts: Z; RETURN Z; END; (Of course, this version produces a result that is different when regarded as a list, although the same when regarded as a set.) Steele and Gabriel, Evolution of Lisp 55 The EL1 language was designed by Ben Wegbreit as part of his Ph.D. research <ref> [Wegbreit, 1970] </ref>. It may be loosely characterized as a Lisp with an Algol-like surface syntax and strong data typing. A complete programming system called ECL was built around EL1 at Harvard in the early 1970's [Wegbreit, 1971; Wegbreit, 1972; Wegbreit, 1974].
Reference: [Wegbreit, 1971] <author> Wegbreit, Ben. </author> <title> The ECL programming system. </title> <booktitle> In Proceedings of the 1971 Fall Joint Computer Conference, </booktitle> <pages> pp. 253-262, </pages> <address> Montvale, New Jersey, </address> <month> August </month> <year> 1971. </year> <note> AFIPS Press. </note>
Reference-contexts: It may be loosely characterized as a Lisp with an Algol-like surface syntax and strong data typing. A complete programming system called ECL was built around EL1 at Harvard in the early 1970's <ref> [Wegbreit, 1971; Wegbreit, 1972; Wegbreit, 1974] </ref>.
Reference: [Wegbreit, 1972] <author> Wegbreit, Ben, Ben Brosgol, Glenn Holloway, Charles Prenner, and Jay Spitzen. </author> <title> ECL Programmer's Manual. </title> <type> Technical Report 21-72, </type> <institution> Harvard University Center for Research in Computing Technology, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1972. </year>
Reference-contexts: It may be loosely characterized as a Lisp with an Algol-like surface syntax and strong data typing. A complete programming system called ECL was built around EL1 at Harvard in the early 1970's <ref> [Wegbreit, 1971; Wegbreit, 1972; Wegbreit, 1974] </ref>.
Reference: [Wegbreit, 1974] <author> Wegbreit, Ben, Glenn Holloway, Jay Spitzen, and Judy Townley. </author> <title> ECL Programmer's Manual. </title> <type> Technical Report 23-74, </type> <institution> Harvard University Center for Research in Computing Technology, Cambridge, Massachusetts, </institution> <month> December </month> <year> 1974. </year>
Reference-contexts: It may be loosely characterized as a Lisp with an Algol-like surface syntax and strong data typing. A complete programming system called ECL was built around EL1 at Harvard in the early 1970's <ref> [Wegbreit, 1971; Wegbreit, 1972; Wegbreit, 1974] </ref>.
Reference: [Weinreb, 1978] <author> Weinreb, Daniel, and David Moon. </author> <title> LISP Machine Manual, </title> <note> Preliminary Version. </note> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> November </month> <year> 1978. </year>
Reference-contexts: Ephemeral garbage collection was subsequently adapted for use on stock hardware.) The early MIT Lisp-Machine Lisp dialect <ref> [Weinreb, 1978] </ref> was very similar to MacLisp. It lived up to its stated goal of supporting MacLisp programs with only minimal porting effort. The most important extensions beyond MacLisp included: * An improved programming environment, consisting primarily of a resident compiler, debugging facilities, and a text editor.
Reference: [Weinreb, 1981] <author> Weinreb, Daniel, and David Moon. </author> <title> LISP Machine Manual, Third Edition. </title> <institution> MIT Artificial Intelligence Laboratory, Cambridge, Massachusetts, </institution> <month> March </month> <year> 1981. </year>
Reference-contexts: Moon and integrated into parts of the Lisp Machine programming environment (the window system, in particular, was written using Flavors <ref> [Weinreb, 1981] </ref>). * SETF, a facility for generalized variables The use of SETF throughout Common Lisp|a later and the most popular dialect of Lisp|can be traced through Symbolics Zetalisp and MacLisp to the influence of MIT Lisp-Machine Lisp and then back through Greenblatt's proposal to Peter Deutsch and thence to Alan
Reference: [White, 1980] <author> White, Jon L. </author> <title> Address/memory management for a gigantic LISP environment; or, GC considered harmful. </title> <booktitle> In [Lisp Conference, </booktitle> <year> 1980], </year> <pages> pp. 119-127. </pages>
Reference: [White, 1986] <author> White, Jon L. </author> <title> Reconfigurable, retargetable bignums: A case study in efficient, portable Lisp system building. </title> <booktitle> In [ACM LFP, </booktitle> <year> 1986], </year> <pages> pp. 174-191. </pages>
Reference-contexts: Usually the algorithms detailed in Knuth Volume 2 are used [Knuth, 1969; Knuth, 1981]. Jon L White wrote a paper about a set of primitives that allow one to code most of bignum arithmetic efficiently in Lisp, instead of having to code the whole thing in assembly language <ref> [White, 1986] </ref>. There is also a literature on BIGFLOAT arithmetic. It has been used in symbolic algebra systems [Mathlab Group, 1977], but has not become a fixture of Lisp dialects.
Reference: [Wulf, 1971] <author> Wulf, </author> <title> W.A., D.B. Russell, and A.N. Habermann. Bliss: A language for systems programming. </title> <journal> Communications of the ACM, </journal> <volume> 14:12, </volume> <pages> pp. 780-790, </pages> <month> December </month> <year> 1971. </year>
Reference-contexts: OPS5 was one of the better-known rule-based languages of this period; XCON (an expert system for configuring VAX installations, developed by Carnegie-Mellon University for Digital Equipment Corporation) was its premier application success story. OPS5 was first implemented in Lisp; later it was recoded for efficiency in BLISS <ref> [Wulf, 1971] </ref> (a CMU-developed and DEC-supported systems implementation language at about the same semantic level as C). Another important category of AI languagess was frame-based; a good example was KRL (Knowledge Representation Language), which was implemented in Interlisp. Another line of experimentation in Lisp is in the area of parallelism.
Reference: [Wulf, 1975] <author> Wulf, William, Richard K. Johnsson, Charles B. Weinstock, Steven O. Hobbs, and Charles M. Geschke. </author> <title> The Design of an Optimizing Compiler, </title> <booktitle> volume 2 of Programming Language Series. </booktitle> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1975. </year> <note> ISBN 0-444-00164-6. </note>
Reference-contexts: Like the S-1 Lisp compiler, it relied heavily on optimization strategies from the mainstream compiler literature, most notably the work by Wulf and others on the BLISS-11 compiler <ref> [Wulf, 1975] </ref>. A second generation of T compiler, called ORBIT [Kranz, 1986], integrated a host of mainstream and Lisp-specific optimization strategies, resulting in a truly production-quality Scheme environment.
Reference: [Yngve, 1972] <author> Yngve, Victor H. </author> <title> Computer Programming with COMIT II. </title> <publisher> MIT Press, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1972. </year> <note> ISBN 0-262-74007-9. </note>
Reference-contexts: But Lisp made it convenient to try out little ideas with a small amount of overhead, as well as tackling grand revampings requiring many man-months of effort.) One of the earliest Lisp-based languages was METEOR [Bobrow, 1964], a version of COMIT with Lisp syntax. COMIT <ref> [MIT RLE, 1962a; MIT RLE, 1962b; Yngve, 1972] </ref> was a pattern-matching language that repeatedly matched a set of rules against the contents of a flat, linear workspace of symbolic tokens; it was a precursor of SNOBOL and an ancestor of such rule-based languages as OPS5 [Forgy, 1977].
References-found: 205

