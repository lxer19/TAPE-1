URL: http://www.cs.wisc.edu/wpis/papers/tcs96a.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: On the Computational Complexity of Dynamic Graph Problems  
Author: G. RAMALINGAM and THOMAS REPS 
Affiliation: University of Wisconsin-Madison  
Abstract: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh A common way to evaluate the time complexity of an algorithm is to use asymptotic worst-case analysis and to express the cost of the computation as a function of the size of the input. However, for an incremental algorithm this kind of analysis is sometimes not very informative. (By an incremental algorithm, we mean an algorithm for a dynamic problem.) When the cost of the computation is expressed as a function of the size of the (current) input, several incremental algorithms that have been proposed run in time asymptotically no better, in the worst-case, than the time required to perform the computation from scratch. Unfortunately, this kind of information is not very helpful if one wishes to compare different incremental algorithms for a given problem. This paper explores a different way to analyze incremental algorithms. Rather than express the cost of an incremental computation as a function of the size of the current input, we measure the cost in terms of the sum of the sizes of the changes in the input and the output. This change in approach allows us to develop a more informative theory of computational complexity for dynamic problems. An incremental algorithm is said to be bounded if the time taken by the algorithm to perform an update can be bounded by some function of the sum of the sizes of the changes in the input and the output. A dynamic problem is said to be unbounded with respect to a model of computation if it has no bounded incremental algorithm within that model of computation. The paper presents new upper-bound results as well as new lower-bound results with respect to a class of algorithms called the locally persistent algorithms. Our results, together with some previously known ones, shed light on the organization of the complexity hierarchy that exists when dynamic problems are classified according to their incremental complexity with respect to locally persistent algorithms. In particular, these results separate the classes of polynomially bounded problems, inherently exponentially bounded problems, and unbounded problems. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alpern, B., Hoover, R., Rosen, B.K., Sweeney, P.F., and Zadeck, F.K., </author> <title> Incremental evaluation of computational circuits, pp. </title> <booktitle> 32-42 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1990). </address>
Reference-contexts: the circuit-annotation problem is shown to have an O (2 | | d || ) incremental algorithm 1 . (2) We establish several new lower-bound results, where the lower bounds are established with respect to the class of locally persistent algorithms, which was originally defined by Alpern et al. in <ref> [1] </ref>. Whereas Alpern et al. show the existence of a problem that has an exponential lower bound in || d || , we are able to demonstrate that more difficult problems exist (from the standpoint of incremental computation). <p> x, y: vertices preconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin <ref> [1] </ref> if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ <p> heap of vertices preconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin <ref> [1] </ref> Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if <p> Procedure DeleteUpdate is presented in Figure 5. DeleteUp date is very similar to DeleteEdge SSSP&gt;0 , but eliminates the two problems discussed above. DeleteUpdate does not delete any edges; the deletion of edge v fi w is performed in DeleteEdge APSP&gt;0 itself (see line <ref> [1] </ref> of Figure 6). <p> z: the sink vertex of G WorkSet, AffectedVertices: sets of vertices a, b, c, u, v, w, x, y: vertices PriorityQueue: a heap of vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin <ref> [1] </ref> AffectedVertices := [2] if there does not exist any vertex x Succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := <p> Thus, while the value dist G (u, v) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DeleteEdge APSP&gt;0 (G, v fi w) declare G: a directed graph v fi w: an edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin <ref> [1] </ref> Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each <p> has been inserted in G z: the sink vertex of G WorkSet: a set of edges VisitedVertices: a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin <ref> [1] </ref> WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x <p> - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure InsertEdge APSP&gt;0 (G, v fi w, c) declare G: a directed graph v fi w: an edge to be inserted in G c: a positive real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin <ref> [1] </ref> Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, <p> The circuit-annotation problem, also known as the circuit-value problem, is to compute the output value associated with each vertex. Alpern et al. show that the incremental circuit-annotation problem has a lower bound of W (2 | | d | | ) under a certain model of incremental computation <ref> [1] </ref>. In this section we develop an algorithm for the incremental circuit-annotation problem that runs in time O (2 || d || ), under the assumption that the evaluation of each function F u takes unit time 3 . <p> the inductive hypothesis, all the predecessors of v are correct. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure UpdateCircuit (G, u) declare G : an annotated circuit u : the modified vertex in G WorkSet, ApparentlyAffected, PotentiallyAffected : sets of vertices v: a vertex preconditions Every vertex in V (G) except possibly u is consistent begin <ref> [1] </ref> WorkSet := - u - [2] u.originalValue := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for <p> This leads to an O (2 || d || ) algorithm for general circuits. 4. LOWER-BOUND RESULTS: PROBLEMS THAT ARE NON-INCREMENTAL FOR LOCALLY PERSISTENT ALGORITHMS The class of locally persistent algorithms was introduced by Alpern et al. in <ref> [1] </ref>. What follows is their description of this class of algorithms, paraphrased to be applicable to general graph problems. <p> the algorithm he gave for the problem is asymptotically optimal. ([31] is also the first paper that we are aware of in which an incremental algorithm is analyzed in terms of the parameter || d || .) The concept of a locally persistent algorithm is due to Alpern et al. <ref> [1] </ref>. Alpern et al. also established two results concerning the performance of incremental algorithms in terms of the parameter || d || . Their results concerned two problems: the dynamic circuit-annotation problem and the problem of maintaining a priority ordering in a DAG. <p> In the dynamic priority-ordering problem, as the DAG is modified the goal is to maintain priorities on the graph vertices such that if there is a path from v to w then - 29 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh UNBOUNDED EXPONENTIAL POLYNOMIAL CIRCUIT-ANNOTATION PROBLEM <ref> [1] </ref>, [Section 3.3] ATTRIBUTE UPDATING [31] PRIORITY ORDERING [1] ALL-PAIRS SHORTEST PATH (&gt; 0) [Section 3.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt; 0) [Section 3.1] MEET-SEMILATTICE DATA-FLOW ANALYSIS PROBLEMS [Section 4.3] SINGLE-SOURCE/SINK CLOSED-SEMIRING PATH PROBLEMS [Section 4.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt;= 0) [Section 4.2] SINGLE-SOURCE/SINK REACHABILITY [Section 4.1] d |||| d |||| WEIGHTED <p> In the dynamic priority-ordering problem, as the DAG is modified the goal is to maintain priorities on the graph vertices such that if there is a path from v to w then - 29 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh UNBOUNDED EXPONENTIAL POLYNOMIAL CIRCUIT-ANNOTATION PROBLEM <ref> [1] </ref>, [Section 3.3] ATTRIBUTE UPDATING [31] PRIORITY ORDERING [1] ALL-PAIRS SHORTEST PATH (&gt; 0) [Section 3.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt; 0) [Section 3.1] MEET-SEMILATTICE DATA-FLOW ANALYSIS PROBLEMS [Section 4.3] SINGLE-SOURCE/SINK CLOSED-SEMIRING PATH PROBLEMS [Section 4.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt;= 0) [Section 4.2] SINGLE-SOURCE/SINK REACHABILITY [Section 4.1] d |||| d |||| WEIGHTED CIRCUIT-ANNOTATION PROBLEM ([29]) d |||| hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (In the <p> Priority Ordering and the Circuit-Value Problem A paper by Alpern et al. <ref> [1] </ref> concerning the dynamic circuit-value problem and the problem of maintaining a priority ordering in a DAG presents results on the incremental complexity of both problems in terms of the parameter || d || . <p> In this paper all lower-bound results apply to the locally persistent algorithms, a model of incremental computation that was defined by Alpern et al. <ref> [1] </ref>.
Reference: 2. <editor> Ausiello, G., Italiano, G.F., Spaccamela, A.M., and Nanni, U., </editor> <title> Incremental algorithms for minimal length paths, pp. </title> <booktitle> 12-21 in Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 22-24, </pages> <year> 1990), </year> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1990). </address>
Reference-contexts: For instance, Ausiello et al. use amortized-cost analysis to obtain a better bound on the time complexity of a semi-dynamic algorithm they present for maintaining shortest paths in a graph as the graph undergoes a sequence of edge insertions <ref> [2] </ref>. However, in the fully dynamic version of the shortest-path problem, where both edge insertions and edge deletions are allowed, pathological input changes can occur frequently in a sequence of input changes. <p> shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] if v fi w SP (G) then <ref> [2] </ref> Remove edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices <p> subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) <ref> [2] </ref> length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist <p> In the previous two paragraphs, we have been speaking very roughly. In particular, because DeleteEdge SSSP&gt;0 as stated in Figure 1 actually performs the deletion of edge v fi w from graph G (see lines <ref> [2] </ref> and [33]), a few changes in DeleteEdge SSSP&gt;0 are necessary for it to be called multiple times in the manner suggested above. There is also a more serious problem with using procedure DeleteEdge SSSP&gt;0 from Figure 1 in conjunction with the ideas outlined above. <p> vertex of G WorkSet, AffectedVertices: sets of vertices a, b, c, u, v, w, x, y: vertices PriorityQueue: a heap of vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] AffectedVertices := <ref> [2] </ref> if there does not exist any vertex x Succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - <p> the value dist G (u, v) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure DeleteEdge APSP&gt;0 (G, v fi w) declare G: a directed graph v fi w: an edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Remove edge v fi w from E (G) <ref> [2] </ref> Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, <p> Though similar bounded algorithms have been previously proposed for this problem (see Rohnert [38], Even and Gazit [15], Lin and Chang [21], and Ausiello et al. <ref> [2] </ref>), we present the algorithm for the sake of completeness. Note that the algorithms described by Rohnert, Lin and Chang, and Ausiello et al. all maintain a shortest-path-tree data structure for each vertex, the maintenance of which can make the processing of an edge-deletion more expensive (and unbounded). <p> vertex of G WorkSet: a set of edges VisitedVertices: a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - <ref> [2] </ref> VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length <p> c) declare G: a directed graph v fi w: an edge to be inserted in G c: a positive real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) <ref> [2] </ref> Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x <p> of v are correct. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure UpdateCircuit (G, u) declare G : an annotated circuit u : the modified vertex in G WorkSet, ApparentlyAffected, PotentiallyAffected : sets of vertices v: a vertex preconditions Every vertex in V (G) except possibly u is consistent begin [1] WorkSet := - u - <ref> [2] </ref> u.originalValue := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) <p> Previous to this work no bounded algorithm was known for updating the solution to the all-pairs shortest-path problem after the deletion of an edge. Though they do not use the concept of boundedness, Rohnert [38], Even and Gazit [15], Lin and Chang [21], and Ausiello et al. <ref> [2] </ref> do provide bounded algorithms for updating the solution to the all-pairs shortest-path problem after the insertion of an edge.
Reference: 3. <author> Berman, A.M., Paull, M.C., and Ryder, B.G., </author> <title> Proving relative lower bounds for incremental algorithms, </title> <note> Acta Informatica 27 pp. </note> <month> 665-683 </month> <year> (1990). </year>
Reference-contexts: size of the input), it has even been possible to show a lower-bound result for the problem itself, demonstrating that no incremental algorithm (subject to certain restrictions) for the problem can, in the worst case, run in time asymptotically better than the time required to perform the computation from scratch <ref> [3, 15, 43] </ref>. For these reasons, worst-case analysis with costs expressed as a function of the size of the input is often not of much help in making comparisons between different incremental algorithms. This paper explores a different way to analyze the computational complexity of incremental algorithms. <p> We maintain outdegree SP (x), the number of SP edges going out of vertex x, so that the tests in lines <ref> [3] </ref> and [12] can be performed in constant time. We have not discussed how the subgraph SP (G) is maintained. <p> the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) <ref> [3] </ref> if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u <p> outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c <ref> [3] </ref> PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w <p> heap of vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] AffectedVertices := [2] if there does not exist any vertex x Succ G (v) such that SP (v, x, z) then <ref> [3] </ref> /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices <p> (G, v fi w) declare G: a directed graph v fi w: an edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh <ref> [3] </ref> AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od [6] for each vertex x AffectedSources do DeleteUpdate <p> of edges VisitedVertices: a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - <ref> [3] </ref> AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist <p> to be inserted in G c: a positive real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) <ref> [3] </ref> length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for <p> hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure UpdateCircuit (G, u) declare G : an annotated circuit u : the modified vertex in G WorkSet, ApparentlyAffected, PotentiallyAffected : sets of vertices v: a vertex preconditions Every vertex in V (G) except possibly u is consistent begin [1] WorkSet := - u - [2] u.originalValue := u.value <ref> [3] </ref> loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v <p> Previous Work on Classifying Incremental Problems The problem of classifying dynamic problems has been addressed in two previous papers, one by Reif [30] and one by Berman, Paull, and Ryder <ref> [3] </ref>. One aspect of our work that sets it apart from both of these papers is that we analyze incremental complexity in terms of the adaptive parameter || d || , rather than in terms of the size of the current input. <p> On the other hand, it is not clear that it would make sense to measure the complexity of dynamic decision problems in terms of || d || . A different approach to the problem of classifying dynamic problems was proposed in a paper by Berman, Paull, and Ryder <ref> [3] </ref>. Berman, Paull, and Ryder classify dynamic problems through the notion of an incremental relative lower bound (IRLB). An IRLB relates the worst-case time required for an dynamic problem to the running time of the time-optimal algorithm for the batch problem. <p> However, only one other paper has ever examined the question of whether incremental data-flow analysis is, in any sense, an intrinsically hard problem: Berman, Paull, and Ryder show that a number of incremental data-flow analysis problems have O (1) IRLB's <ref> [3] </ref>, which puts them in the class of problems with the poorest incremental behavior (in the sense of Berman, Paull, and Ryder). <p> What is unsatisfactory about these models of incremental computation is that, at best, only very limited use of auxiliary storage is permitted. Berman, Paull, and Ryder do discuss a model of incremental computation that has somewhat fewer restrictions on the use of auxiliary storage <ref> [3] </ref>; however, in their model the cost of initializing any auxiliary storage used must be less than the cost of running the optimal-time batch algorithm for the problem. <p> There are certainly reasonable dynamic algorithms that, because of the amount of auxiliary information that the algorithms store and maintain, lie outside the class of algorithms covered by Berman, Paull, and Ryder's model. (For instance, see Section 3.3 of <ref> [3] </ref>.) Thus, a desirable goal for future research is to develop a better model of incremental computation that better addresses the issue of the use and maintenance of auxiliary storage by dynamic algorithms.
Reference: 4. <author> Cai, J. and Paige, R., </author> <title> Binding performance at language design time, pp. </title> <booktitle> 85-97 in Conference Record of the Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Munich, </address> <publisher> W. </publisher> <address> Germany, </address> <month> January </month> <year> 1987), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1987). </address>
Reference-contexts: (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then <ref> [4] </ref> /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such <p> is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := <ref> [4] </ref> if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) <p> dist G (b, c)) (dist G (a, c) ) begin [1] AffectedVertices := [2] if there does not exist any vertex x Succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ <ref> [4] </ref> /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for <p> edge to be deleted from G AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh <ref> [4] </ref> AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od [6] for each vertex x AffectedSources do DeleteUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 17 - stored at vertex u of graph <p> a set of vertices u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := <ref> [4] </ref> while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] <p> real number indicating the length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c <ref> [4] </ref> length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh <p> UpdateCircuit (G, u) declare G : an annotated circuit u : the modified vertex in G WorkSet, ApparentlyAffected, PotentiallyAffected : sets of vertices v: a vertex preconditions Every vertex in V (G) except possibly u is consistent begin [1] WorkSet := - u - [2] u.originalValue := u.value [3] loop <ref> [4] </ref> for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet <p> Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige <ref> [4, 5] </ref> and by Gurevitch and Shelah [17]. In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output.
Reference: 5. <author> Cai, J. and Paige, R., </author> <title> Languages polynomial in the input plus output, </title> <booktitle> in Proceedings of the Second International Conference on Algebraic Methodology and Software Technology (AMAST), </booktitle> <address> (Iowa City, Iowa, </address> <month> May 22-25, </month> <year> 1991), (1991). </year>
Reference-contexts: if v fi w SP (G) then [2] Remove edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ <ref> [5] </ref> WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and <p> In effect, the algorithm avoids constructing the unshaded part of the tree T in Figure 3. During this process, the set of all affected vertices is identified and every affected vertex is assigned its correct value finally. If v is affected, it is assigned its correct value in line <ref> [5] </ref>; any other affected vertex x will be assigned its correct value in line [18]. Simultaneously, the algorithm also updates the set of edges SP (G) as follows. If v is unaffected but v fi w becomes an SP edge, it is added to SP (G) in line [8]. <p> v V (G), dist (v) is the length of the shortest path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then <ref> [5] </ref> dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u <p> ) begin [1] AffectedVertices := [2] if there does not exist any vertex x Succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ <ref> [5] </ref> WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP <p> G begin [1] Remove edge v fi w from E (G) [2] Remove edge w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) <ref> [5] </ref> for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od [6] for each vertex x AffectedSources do DeleteUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 17 - stored at vertex u of graph G is the length of the shortest path from u to v in G, the value <p> u, x, y: vertices SP (a, b, c) (dist G (a, c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do <ref> [5] </ref> Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y <p> This permits InsertUpdate to do a (partial) backward traversal of this DAG, visiting only affected vertices or their predecessors. For instance, consider the edge x fi u selected in line <ref> [5] </ref> of Figure 7. Vertex x is the vertex to be visited next during the traversal described above. <p> length of edge v fi w AffectedSinks, AffectedSources: sets of vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh <ref> [5] </ref> AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh vertices such <p> This set is precisely the set of all affected vertices for the single-source shortest-path problem with v as the source, i.e. the set Affec-tedVertices computed by the call InsertUpdate (G hh ,w fi v,v). This is how InsertEdge APSP&gt;0 determines the set AffectedSinks (see line <ref> [5] </ref> of Figure 8); InsertUpdate is then invoked repeatedly, once for each member of AffectedSinks. The update to graph G hh is performed in an analogous fashion. We now consider the time complexity of InsertEdge APSP&gt;0 . <p> Thus, the total running time of line [7] in procedure InsertEdge APSP&gt;0 is O ( || d || 1 ). Similarly, line [8] takes time O ( || d || 1 ). Line <ref> [5] </ref> takes time O ( || AFFECTED v || 1,G hh ); line [6] takes time O ( || AFFECTED w || 1,G ). Thus, the total running time of procedure InsertEdge APSP&gt;0 is O ( || d || 1 ). 3.3. <p> In each itera tion of the loop in lines [3]-[12] the values of all the vertices in WorkSet are recomputed in a relative topological-sort ordering. The set of all vertices in WorkSet that have a value different from their original value is identified in line <ref> [5] </ref>. These vertices are said to be apparently affectedsome of these vertices may not be affected but just have a wrong value temporarily assigned to them. The set of all successors of the apparently affected vertices, the potentially affected vertices, is identified in line [6]. <p> in G WorkSet, ApparentlyAffected, PotentiallyAffected : sets of vertices v: a vertex preconditions Every vertex in V (G) except possibly u is consistent begin [1] WorkSet := - u - [2] u.originalValue := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od <ref> [5] </ref> ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet [10] v.originalValue := v.value [11] od [12] end loop end postconditions Every vertex in <p> Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige <ref> [4, 5] </ref> and by Gurevitch and Shelah [17]. In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output.
Reference: 6. <author> Carroll, M. and Ryder, B., </author> <title> Incremental data flow update via attribute and dominator updates, pp. </title> <booktitle> 274-284 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1988). </address>
Reference-contexts: For example, when the cost of the computation is expressed as a function of the size of the (current) input, the worst-case complexity of several incremental graph algorithms is no better than that of an algorithm that performs the computation from scratch <ref> [6, 8, 19, 24, 46] </ref>. <p> then [2] Remove edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - <ref> [6] </ref> AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if <p> path from v to sink (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) <ref> [6] </ref> InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed <p> if there does not exist any vertex x Succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - <ref> [6] </ref> while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then <p> w fi v from E (G hh [3] AffectedSinks := the set AffectedVertices from Phase 1 of DeleteUpdate (G hh [4] AffectedSources := the set AffectedVertices from Phase 1 of DeleteUpdate (G, v fi w, w) [5] for each vertex x AffectedSinks do DeleteUpdate (G, v fi w, x) od <ref> [6] </ref> for each vertex x AffectedSources do DeleteUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 17 - stored at vertex u of graph G is the length of the shortest path from u to v in G, the value dist G hh length of the shortest path from v to u in G. <p> c) = length G (a fi b) + dist G (b, c)) (dist G (a, c) ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet <ref> [6] </ref> if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices <p> Except in the case when edge x fi u is v fi w, vertex u is an affected vertex and is the successor of x in a shortest path from x to v. The test in line <ref> [6] </ref> determines if x itself is an affected vertex. If it is, its distance information is updated, and its predecessors in the shortest-path DAG to sink v are added to the workset for subsequent processing, unless they have already been visited. <p> vertices v, w, x: vertices of G begin [1] Insert edge v fi w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh <ref> [6] </ref> AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh vertices such that the length of the shortest path from x to <p> Thus, the total running time of line [7] in procedure InsertEdge APSP&gt;0 is O ( || d || 1 ). Similarly, line [8] takes time O ( || d || 1 ). Line [5] takes time O ( || AFFECTED v || 1,G hh ); line <ref> [6] </ref> takes time O ( || AFFECTED w || 1,G ). Thus, the total running time of procedure InsertEdge APSP&gt;0 is O ( || d || 1 ). 3.3. <p> These vertices are said to be apparently affectedsome of these vertices may not be affected but just have a wrong value temporarily assigned to them. The set of all successors of the apparently affected vertices, the potentially affected vertices, is identified in line <ref> [6] </ref>. The algorithm halts if all the potentially affected vertices are already in WorkSet. Otherwise, the potentially affected ver tices are added to WorkSet and the algorithm iterates through this process again. Proposition 4. Procedure UpdateCircuit computes a correct annotation of G. Proof. <p> a vertex preconditions Every vertex in V (G) except possibly u is consistent begin [1] WorkSet := - u - [2] u.originalValue := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - <ref> [6] </ref> PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet [10] v.originalValue := v.value [11] od [12] end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the <p> In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis <ref> [6, 23, 24, 39, 40, 46] </ref>. <p> For instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice [19]; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder <ref> [6] </ref> performs well in practice [41]; Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 [11].
Reference: 7. <author> Carroll, </author> <title> M.D., Data flow update via dominator and attribute updates, </title> <type> Ph.D. dissertation, </type> <institution> Rutgers University, </institution> <address> New Brunswick, NJ (May 1988). </address>
Reference-contexts: as Carroll observes, An algorithm with bad worst-case complexity will have good amortized complexity only if there is something about the problem being updated, or about the way in which we update it, or about the kinds of updates which we allow, that pre cludes pathological updates from happening frequently <ref> [7] </ref>. For instance, Ausiello et al. use amortized-cost analysis to obtain a better bound on the time complexity of a semi-dynamic algorithm they present for maintaining shortest paths in a graph as the graph undergoes a sequence of edge insertions [2]. <p> edge v fi w from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := <ref> [7] </ref> while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) <p> (G) begin [1] Insert edge v fi w into E (G) [2] length (v fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) <ref> [7] </ref> else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set <p> exist any vertex x Succ G (v) such that SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do <ref> [7] </ref> Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet <p> ) begin [1] WorkSet := - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then <ref> [7] </ref> Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet [12] Insert y into VisitedVertices [13] fi [15] <p> w into E (G) [2] Insert edge w fi v into E (G hhhh ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) <ref> [7] </ref> for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od [8] for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh vertices such that the length of the shortest path from x to y changes following the insertion of edge v fi w. <p> Insert-Update does essentially a simple traversal of the graph &lt;N (AFFECTED x )&gt;, in time O ( || AFFECTED x || ). Thus, the total running time of line <ref> [7] </ref> in procedure InsertEdge APSP&gt;0 is O ( || d || 1 ). Similarly, line [8] takes time O ( || d || 1 ). Line [5] takes time O ( || AFFECTED v || 1,G hh ); line [6] takes time O ( || AFFECTED w || 1,G ). <p> in V (G) except possibly u is consistent begin [1] WorkSet := - u - [2] u.originalValue := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) <ref> [7] </ref> if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet [10] v.originalValue := v.value [11] od [12] end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the case that v is not <p> The proof of the time complexity follows. We first show that the algorithm adds at least one affected vertex to WorkSet in each of the iterations except possibly the last two. Assume that after the execution of line <ref> [7] </ref> in the i-th iteration of the outer loop (lines [3]-[12]), every vertex in PotentiallyAffected-WorkSet is an unaffected vertex. In other words, all the vertices that are added to WorkSet in the i-th iteration of the outer loop are assumed to be unaffected vertices.
Reference: 8. <author> Cheston, </author> <title> G.A., Incremental algorithms in graph theory, </title> <type> Ph.D. dissertation and Tech. Rep. 91, </type> <institution> Dept. of Computer Science, University of Toronto, Toronto, </institution> <address> Canada (March 1976). </address>
Reference-contexts: For example, when the cost of the computation is expressed as a function of the size of the (current) input, the worst-case complexity of several incremental graph algorithms is no better than that of an algorithm that performs the computation from scratch <ref> [6, 8, 19, 24, 46] </ref>. <p> from SP (G) and from E (G) and decrement outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do <ref> [8] </ref> Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert <p> Simultaneously, the algorithm also updates the set of edges SP (G) as follows. If v is unaffected but v fi w becomes an SP edge, it is added to SP (G) in line <ref> [8] </ref>. Similarly any edge x fi u that becomes an SP edge, while x is unaffected, is identified and added to SP (G) in line [21]. For any affected vertex u, an edge u fi x directed away from u can change its SP edge status. <p> fi w) := c [3] PriorityQueue := [4] if length (v fi w) + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then <ref> [8] </ref> Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] <p> SP (v, x, z) then [3] /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet <ref> [8] </ref> Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od [13] /* Phase 2: Determine new <p> - v fi w - [2] VisitedVertices := - v - [3] AffectedVertices := [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices <ref> [8] </ref> dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet [12] Insert y into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the <p> ) [3] length G (v fi w) := c [4] length G hh [5] AffectedSinks := the set AffectedVertices from InsertUpdate (G hh [6] AffectedSources := the set AffectedVertices from InsertUpdate (G, v fi w, w) [7] for each vertex x AffectedSinks do InsertUpdate (G, v fi w, x) od <ref> [8] </ref> for each vertex x AffectedSources do InsertUpdate (G hh end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh vertices such that the length of the shortest path from x to y changes following the insertion of edge v fi w. <p> Insert-Update does essentially a simple traversal of the graph &lt;N (AFFECTED x )&gt;, in time O ( || AFFECTED x || ). Thus, the total running time of line [7] in procedure InsertEdge APSP&gt;0 is O ( || d || 1 ). Similarly, line <ref> [8] </ref> takes time O ( || d || 1 ). Line [5] takes time O ( || AFFECTED v || 1,G hh ); line [6] takes time O ( || AFFECTED w || 1,G ). <p> begin [1] WorkSet := - u - [2] u.originalValue := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi <ref> [8] </ref> for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet [10] v.originalValue := v.value [11] od [12] end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the case that v is not in WorkSet hhhhhhh . <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov [37], Halder [18], Pape [27], Hsieh et al. [20], Cheston <ref> [8] </ref>, Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is made, none of the algorithms presented in these papers turns
Reference: 9. <author> Cheston, G.A. and Corneil, D.G., </author> <title> Graph property update algorithms and their application to distance matrices, </title> <note> INFOR 20(3) pp. </note> <month> 178-201 (August </month> <year> 1982). </year>
Reference-contexts: outdegree SP (v) [3] if outdegree SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet <ref> [9] </ref> Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* <p> + dist (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) <ref> [9] </ref> fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert <p> /* Phase 1: Identify vertices in AFFECTED (the vertices whose shortest distance to z has increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices <ref> [9] </ref> for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices <p> [4] while WorkSet do [5] Select and remove an edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) <ref> [9] </ref> for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet [12] Insert y into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the description of InsertEdge SSSP&gt;0 given in Section 3.1.2. <p> := u.value [3] loop [4] for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do <ref> [9] </ref> Insert v into WorkSet [10] v.originalValue := v.value [11] od [12] end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the case that v is not in WorkSet hhhhhhh . <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov [37], Halder [18], Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil <ref> [9] </ref>; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is made, none of the algorithms presented in these papers turns out to be bounded. 6.4.
Reference: 10. <author> Cormen, T.H., Leiserson, C.E., and Rivest, </author> <title> R.L., Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA (1990). </address>
Reference-contexts: SP (v) = 0 then [4] /* Phase 1: Identify the affected vertices and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices <ref> [10] </ref> for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* Phase 2: Determine new distances from <p> The algorithm works by using an adaptation of Dijkstra's algorithm to construct the part of the tree T restricted to the affected vertices (the shaded part of T in Figure 3) in lines [3]-[6], <ref> [10] </ref>, [11], and [16]- [19]. As in Dijkstra's algorithm, the keys of vertices in PriorityQueue indicate distances from u to v. <p> (w) &lt; dist (v) then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi <ref> [10] </ref> while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi <p> We can do this by dynamically expanding and contracting these arrays using the well-known doubling/halving technique (see Section 18.4 of <ref> [10] </ref>, for example). Assume the distance matrix is maintained as a collection of n vectors (of equal size), where n is the number of vertices in the graph. Whenever a new vertex is inserted, a new vector is allocated. <p> increased). */ [4] /* Set AffectedVertices equal to AFFECTED. */ [5] WorkSet := - v - [6] while WorkSet do [7] Select and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do <ref> [10] </ref> if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist <p> Predicate SP (a, b, c) answers the question Is edge a fi b an SP edge when vertex c is the sink?. This check can be done in constant time. The use of predicate SP (a, b, c) makes it important that the test in line <ref> [10] </ref> be carefully implemented. Recall that Phase 1 is similar to a (reverse) topological order traversal in the SP DAG for sink z. We are interested in determining in line [10] if every successor of x in the SP DAG has already been visited and placed in AffectedVertices; if so, then <p> The use of predicate SP (a, b, c) makes it important that the test in line <ref> [10] </ref> be carefully implemented. Recall that Phase 1 is similar to a (reverse) topological order traversal in the SP DAG for sink z. We are interested in determining in line [10] if every successor of x in the SP DAG has already been visited and placed in AffectedVertices; if so, then x can be placed in AffectedVertices too. <p> Since we cannot afford to maintain a similar count (across updates to the graph), we need to perform the check in line <ref> [10] </ref> differently. Note that the check in line [10] can be performed multiple times for the same vertex x. In fact, a vertex x can be checked outdegree (x) times. If we examine all successors of vertex x each time, the cost of the repeated checks in line [10] for a <p> Since we cannot afford to maintain a similar count (across updates to the graph), we need to perform the check in line <ref> [10] </ref> differently. Note that the check in line [10] can be performed multiple times for the same vertex x. In fact, a vertex x can be checked outdegree (x) times. If we examine all successors of vertex x each time, the cost of the repeated checks in line [10] for a particular vertex x can be quadratic in the <p> in line <ref> [10] </ref> differently. Note that the check in line [10] can be performed multiple times for the same vertex x. In fact, a vertex x can be checked outdegree (x) times. If we examine all successors of vertex x each time, the cost of the repeated checks in line [10] for a particular vertex x can be quadratic in the number of successors it has. Instead, the same total cost can be made linear in outdegree (x ) by using the following strategy. The first time vertex x is checked in line [10] we count the number of vertices y <p> cost of the repeated checks in line <ref> [10] </ref> for a particular vertex x can be quadratic in the number of successors it has. Instead, the same total cost can be made linear in outdegree (x ) by using the following strategy. The first time vertex x is checked in line [10] we count the number of vertices y in (Succ (x) AffectedVertices) that satisfy SP (x,y,z). Whenever vertex x is subsequently checked in line [10] we decrement its count. We add x to the WorkSet when its count falls to zero. <p> The first time vertex x is checked in line <ref> [10] </ref> we count the number of vertices y in (Succ (x) AffectedVertices) that satisfy SP (x,y,z). Whenever vertex x is subsequently checked in line [10] we decrement its count. We add x to the WorkSet when its count falls to zero. Even this trick does not make the algorithm bounded in || d || 1 . The reason is that the vertex x checked in line [10] is not necessarily a member of AFFECTED, but <p> Whenever vertex x is subsequently checked in line <ref> [10] </ref> we decrement its count. We add x to the WorkSet when its count falls to zero. Even this trick does not make the algorithm bounded in || d || 1 . The reason is that the vertex x checked in line [10] is not necessarily a member of AFFECTED, but we are forced to examine all successors of x. However, even if the tested vertex x is not a member of AFFECTED it is guaranteed to be a predecessor of a member of AFFECTED. <p> edge x fi u from WorkSet [6] if length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do <ref> [10] </ref> if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet [12] Insert y into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the description of InsertEdge SSSP&gt;0 given in Section 3.1.2. <p> for every vertex v WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet <ref> [10] </ref> v.originalValue := v.value [11] od [12] end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the case that v is not in WorkSet hhhhhhh .
Reference: 11. <author> Dionne, R., </author> <title> Etude et extension d'un algorithme de Murchland, </title> <note> INFOR 16(2) pp. </note> <month> 132-146 (June </month> <year> 1978). </year>
Reference-contexts: and remove the affected edges from SP (G) */ [5] WorkSet := - v - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do <ref> [11] </ref> Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := <p> The algorithm works by using an adaptation of Dijkstra's algorithm to construct the part of the tree T restricted to the affected vertices (the shaded part of T in Figure 3) in lines [3]-[6], [10], <ref> [11] </ref>, and [16]- [19]. As in Dijkstra's algorithm, the keys of vertices in PriorityQueue indicate distances from u to v. <p> Appropriate adjustments are made in line [6]the key for vertex v is 0and in line [19]the key for vertex u is dist (x ) - dist (u). When the vertex u is selected from PriorityQueue in line <ref> [11] </ref>, its priority is nothing but dist (u,v). <p> We now analyze the time complexity of InsertEdge SSSP&gt;0 . The loop in lines [10]-[24] iterates once for every affected vertex u. Each iteration takes time O (log | AFFECTED | ) for line <ref> [11] </ref> and time O ( || -u- || ) for lines [12]-[23]. Note that the AdjustHeap operation in line [19] either inserts a vertex into the heap or decreases the key of a vertex in the heap. Hence it costs only O (1) time. <p> then [5] dist (v) := length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do <ref> [11] </ref> u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) <p> and remove a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi <ref> [11] </ref> od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) <p> length G (x fi u) + dist G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then <ref> [11] </ref> Insert y fi x into WorkSet [12] Insert y into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the description of InsertEdge SSSP&gt;0 given in Section 3.1.2. InsertEdge SSSP&gt;0 makes use of an adaptation of Dijkstra's algorithm to identify shortest paths to sink v and update distance information. <p> WorkSet in relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet [10] v.originalValue := v.value <ref> [11] </ref> od [12] end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the case that v is not in WorkSet hhhhhhh . <p> There have been three previous papers on handling edge deletion in APSP&gt;0by Dionne <ref> [11] </ref>, Rohnert [38], and Even and Gazit [15]in which the analysis might be misinterpreted, on first reading, as demonstrating that the algorithms are bounded. In fact, the algorithms given in all three papers have - 34 - unbounded incremental complexity in general. <p> instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice [19]; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder [6] performs well in practice [41]; Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 <ref> [11] </ref>.
Reference: 12. <author> Driscoll, J.R., Gabow, H.N., Shrairman, R., and Tarjan, R.E., </author> <title> Relaxed heaps: An alternative to Fibonacci heaps with applications to parallel computation, </title> <journal> Communications of the ACM 31(11) pp. </journal> <month> 1343-1354 </month> <year> (1988). </year> <month> - 36 </month> - 
Reference-contexts: We maintain outdegree SP (x), the number of SP edges going out of vertex x, so that the tests in lines [3] and <ref> [12] </ref> can be performed in constant time. We have not discussed how the subgraph SP (G) is maintained. <p> - [6] AffectedVertices := [7] while WorkSet do [8] Select and remove a vertex u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) <ref> [12] </ref> if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length <p> The complexity of Phase 2 depends on the type of heap we use. We assume that PriorityQueue is implemented as a relaxed heap (see <ref> [12] </ref>). Both insertion of an item into a relaxed heap and decreasing the key of an item in a relaxed heap cost O (1) time, while finding and deleting the item with the minimum key costs O (log p) time, where p is the number of items in the heap. <p> length (v fi w) + dist (w) [6] InsertHeap (PriorityQueue, v, 0) [7] else if length (v fi w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) <ref> [12] </ref> Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) <p> G (u,z) &lt; dist G (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet <ref> [12] </ref> Insert y into VisitedVertices [13] fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the description of InsertEdge SSSP&gt;0 given in Section 3.1.2. InsertEdge SSSP&gt;0 makes use of an adaptation of Dijkstra's algorithm to identify shortest paths to sink v and update distance information. <p> relative topological-sort order do recompute v.value od [5] ApparentlyAffected := - v WorkSet : v.value v.originalValue - [6] PotentiallyAffected := Succ (ApparentlyAffected) [7] if PotentiallyAffected WorkSet then exit loop fi [8] for every vertex v (PotentiallyAffected - WorkSet) do [9] Insert v into WorkSet [10] v.originalValue := v.value [11] od <ref> [12] </ref> end loop end postconditions Every vertex in G is consistent hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 22 - Now consider the case that v is not in WorkSet hhhhhhh .
Reference: 13. <author> Edmonds, J. and Karp, </author> <title> R.M., Theoretical improvements in algorithmic efficiency for network flow problems, </title> <journal> J. </journal> <note> ACM 19 pp. 248-264 (1972). As cited in reference [45]. </note>
Reference-contexts: u from WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi <ref> [13] </ref> od [15] /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b <p> w) + dist (w) = dist (v) then [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 <ref> [13] </ref> for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi [15] od [16] for every vertex x Pred (u) do [17] if length (x fi u) + <p> These generalizations are based on the technique of Edmonds and Karp for transforming the length of every edge in a graph to a non-negative real without changing the graph's shortest paths <ref> [13, 44] </ref>, and are described in [28, 29]. <p> a vertex u from WorkSet [8] Insert vertex u into AffectedVertices [9] for each vertex x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od <ref> [13] </ref> /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b <p> (x,z) then [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet [12] Insert y into VisitedVertices <ref> [13] </ref> fi [15] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the description of InsertEdge SSSP&gt;0 given in Section 3.1.2. InsertEdge SSSP&gt;0 makes use of an adaptation of Dijkstra's algorithm to identify shortest paths to sink v and update distance information.
Reference: 14. <author> Even, S. and Shiloach, Y., </author> <title> An on-line edge-deletion problem, </title> <journal> J. ACM 28(1) pp. </journal> <month> 1-4 (January </month> <year> 1981). </year>
Reference-contexts: [8] Insert v fi w into SP (G) and increment outdegree SP (v) [9] fi [10] while PriorityQueue do [11] u := FindAndDeleteMin (PriorityQueue) [12] Remove all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do <ref> [14] </ref> if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi [15] od [16] for every vertex x Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist <p> x Pred G (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ <ref> [14] </ref> PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap
Reference: 15. <author> Even, S. and Gazit, H., </author> <title> Updating distances in dynamic graphs, </title> <note> pp. 271-388 in IX Symposium on Operations Research, </note> <author> (Osna-brueck, W. Ger., </author> <month> Aug. </month> <pages> 27-29, </pages> <year> 1984), </year> <journal> Methods of Operations Research, </journal> <volume> Vol. 49, </volume> <editor> ed. P. Brucker and R. </editor> <publisher> Pauly,Verlag Anton Hain (1985). </publisher>
Reference-contexts: size of the input), it has even been possible to show a lower-bound result for the problem itself, demonstrating that no incremental algorithm (subject to certain restrictions) for the problem can, in the worst case, run in time asymptotically better than the time required to perform the computation from scratch <ref> [3, 15, 43] </ref>. For these reasons, worst-case analysis with costs expressed as a function of the size of the input is often not of much help in making comparisons between different incremental algorithms. This paper explores a different way to analyze the computational complexity of incremental algorithms. <p> WorkSet [9] Insert vertex u into AffectedVertices [10] for every vertex x such that x fi u SP (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od <ref> [15] </ref> /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - <p> all edges of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi <ref> [15] </ref> od [16] for every vertex x Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + <p> (u) such that SP (x, u, z) do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := <ref> [15] </ref> for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap (PriorityQueue, a, dist <p> Though similar bounded algorithms have been previously proposed for this problem (see Rohnert [38], Even and Gazit <ref> [15] </ref>, Lin and Chang [21], and Ausiello et al. [2]), we present the algorithm for the sake of completeness. <p> [7] Insert x into AffectedVertices [8] dist G (x,z) := length G (x fi u) + dist G (u,z) [9] for every vertex y Pred G (x) do [10] if SP (y,x,v) and y VisitedVertices then [11] Insert y fi x into WorkSet [12] Insert y into VisitedVertices [13] fi <ref> [15] </ref> fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Recall the description of InsertEdge SSSP&gt;0 given in Section 3.1.2. InsertEdge SSSP&gt;0 makes use of an adaptation of Dijkstra's algorithm to identify shortest paths to sink v and update distance information. <p> for a problem with an O (1) IRLB (thereby leading to a way out of the conundrum). hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 The arguments that Berman, Paull, and Ryder use to establish relative lower bounds for various problems are similar to the ones used by Spira and Pan [43] and Even and Gazit <ref> [15] </ref> to establish that no incremental algorithm for the all-pairs shortest-path problem can do better in the worst case than the best batch algorithm for the problem. - 32 - Although knowing that a problem has an IRLB of O (1) is certainly a property of interest (since the knowledge that <p> Previous to this work no bounded algorithm was known for updating the solution to the all-pairs shortest-path problem after the deletion of an edge. Though they do not use the concept of boundedness, Rohnert [38], Even and Gazit <ref> [15] </ref>, Lin and Chang [21], and Ausiello et al. [2] do provide bounded algorithms for updating the solution to the all-pairs shortest-path problem after the insertion of an edge. There have been three previous papers on handling edge deletion in APSP&gt;0by Dionne [11], Rohnert [38], and Even and Gazit [15]in which
Reference: 16. <author> Goto, S. and Sangiovanni-Vincentelli, A., </author> <title> A new shortest path updating algorithm, Networks 8(4) pp. </title> <month> 341-372 </month> <year> (1978). </year>
Reference-contexts: (G) do [11] Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ <ref> [16] </ref> PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue <p> The algorithm works by using an adaptation of Dijkstra's algorithm to construct the part of the tree T restricted to the affected vertices (the shaded part of T in Figure 3) in lines [3]-[6], [10], [11], and <ref> [16] </ref>- [19]. As in Dijkstra's algorithm, the keys of vertices in PriorityQueue indicate distances from u to v. <p> of SP (G) directed away from u and set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi [15] od <ref> [16] </ref> for every vertex x Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) <p> do [10] if for all y Succ G (x) such that SP (x, y, z), y AffectedVertices then Insert x into WorkSet fi [11] od [13] /* Phase 2: Determine new distances to z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do <ref> [16] </ref> dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi [18] od [19] <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov [37], Halder [18], Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. <ref> [16] </ref>, Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is made, none of the algorithms presented in these papers turns out to be bounded.
Reference: 17. <author> Gurevich, Y. and Shelah, S., </author> <title> Time polynomial in input or output, </title> <journal> J. Symbolic Logic 54(3) pp. </journal> <month> 1083-1088 (September </month> <year> 1989). </year>
Reference-contexts: Remove edge x fi u from SP (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := <ref> [17] </ref> for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do [22] a <p> set outdegree SP (u) = 0 [13] for every vertex x Succ (u) do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi [15] od [16] for every vertex x Pred (u) do <ref> [17] </ref> if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) = dist (x) then [21] Insert x fi <p> z for all vertices in AffectedVertices. */ [14] PriorityQueue := [15] for each vertex a AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) <ref> [17] </ref> if dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi [18] od [19] while PriorityQueue do [20] a := FindAndDeleteMin (PriorityQueue) [21] for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) <p> Other Related Work For batch algorithms, the concept of measuring the complexity of an algorithm in terms of the sum of the sizes of the input and the output has been explored by Cai and Paige [4, 5] and by Gurevitch and Shelah <ref> [17] </ref>. In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis [6, 23, 24, 39, 40, 46].
Reference: 18. <author> Halder, </author> <title> A.K., The method of competing links, </title> <note> Transportation Science 4 pp. </note> <month> 36-51 </month> <year> (1970). </year>
Reference-contexts: (G) and decrement outdegree SP (x) [12] if outdegree SP (x) = 0 then Insert vertex x into WorkSet fi [13] od [15] /* Phase 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do <ref> [18] </ref> dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex <p> During this process, the set of all affected vertices is identified and every affected vertex is assigned its correct value finally. If v is affected, it is assigned its correct value in line [5]; any other affected vertex x will be assigned its correct value in line <ref> [18] </ref>. Simultaneously, the algorithm also updates the set of edges SP (G) as follows. If v is unaffected but v fi w becomes an SP edge, it is added to SP (G) in line [8]. <p> do [14] if length (u fi x) + dist (x) = dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi [15] od [16] for every vertex x Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then <ref> [18] </ref> dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) = dist (x) then [21] Insert x fi u into SP (G) and increment outdegree SP (x) [22] fi [24] od <p> AffectedVertices do [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi <ref> [18] </ref> od [19] while PriorityQueue do [20] a := FindAndDeleteMin (PriorityQueue) [21] for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G <p> Our procedures DeleteEdge APSP&gt;0 and InsertEdge APSP&gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov [37], Halder <ref> [18] </ref>, Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is made, none
Reference: 19. <author> Hoover, R., </author> <title> Incremental graph evaluation, </title> <type> Ph.D. dissertation and Tech. Rep. 87-836, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <address> Ithaca, NY (May 1987). </address>
Reference-contexts: For example, when the cost of the computation is expressed as a function of the size of the (current) input, the worst-case complexity of several incremental graph algorithms is no better than that of an algorithm that performs the computation from scratch <ref> [6, 8, 19, 24, 46] </ref>. <p> 2: Determine new distances from affected vertices to sink (G) and update SP (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) <ref> [19] </ref> if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) <p> The algorithm works by using an adaptation of Dijkstra's algorithm to construct the part of the tree T restricted to the affected vertices (the shaded part of T in Figure 3) in lines [3]-[6], [10], [11], and [16]- <ref> [19] </ref>. As in Dijkstra's algorithm, the keys of vertices in PriorityQueue indicate distances from u to v. However, unlike in Dijkstra's algorithm, these distances are available only indirectly; the distance annotation at u (i.e., dist (u)) indicates the distance from u to sink (G), not that from u to v. <p> The loop in lines [10]-[24] iterates once for every affected vertex u. Each iteration takes time O (log | AFFECTED | ) for line [11] and time O ( || -u- || ) for lines [12]-[23]. Note that the AdjustHeap operation in line <ref> [19] </ref> either inserts a vertex into the heap or decreases the key of a vertex in the heap. Hence it costs only O (1) time. <p> dist (u) then Insert u fi x into SP (G) and increment outdegree SP (u) fi [15] od [16] for every vertex x Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) <ref> [19] </ref> AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) = dist (x) then [21] Insert x fi u into SP (G) and increment outdegree SP (x) [22] fi [24] od postconditions SP (G) is the shortest-paths subgraph of G " v <p> [16] dist G (a, z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi [18] od <ref> [19] </ref> while PriorityQueue do [20] a := FindAndDeleteMin (PriorityQueue) [21] for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) <p> For instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice <ref> [19] </ref>; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder [6] performs well in practice [41]; Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 [11].
Reference: 20. <author> Hsieh, W., Kershenbaum, A., and Golden, B., </author> <title> Constrained routing in large sparse networks, pp. </title> <booktitle> 38.14-38.18 in Proceedings of IEEE International Conference on Communications, </booktitle> , <address> Philadelphia, PA (1976). </address>
Reference-contexts: update SP (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi <ref> [20] </ref> od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex <p> (G) and increment outdegree SP (u) fi [15] od [16] for every vertex x Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) <ref> [20] </ref> else if length (x fi u) + dist (u) = dist (x) then [21] Insert x fi u into SP (G) and increment outdegree SP (x) [22] fi [24] od postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of <p> z) := min (- length G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi [18] od [19] while PriorityQueue do <ref> [20] </ref> a := FindAndDeleteMin (PriorityQueue) [21] for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] AdjustHeap ( PriorityQueue, <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov [37], Halder [18], Pape [27], Hsieh et al. <ref> [20] </ref>, Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is made, none of the algorithms presented in these
Reference: 21. <author> Lin, C.-C. and Chang, R.-C., </author> <title> On the dynamic shortest path problem, </title> <journal> Journal of Information Processing 13(4)(1990). </journal>
Reference-contexts: (G). */ [16] PriorityQueue := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od <ref> [21] </ref> while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred <p> If v is unaffected but v fi w becomes an SP edge, it is added to SP (G) in line [8]. Similarly any edge x fi u that becomes an SP edge, while x is unaffected, is identified and added to SP (G) in line <ref> [21] </ref>. For any affected vertex u, an edge u fi x directed away from u can change its SP edge status. These changes are identified and made to SP (G) in lines [12]-[15]. <p> Pred (u) do [17] if length (x fi u) + dist (u) &lt; dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) = dist (x) then <ref> [21] </ref> Insert x fi u into SP (G) and increment outdegree SP (x) [22] fi [24] od postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) <p> G (a fi b) + dist G (b, z) | a fi b E (G) and b (V (G) - AffectedVertices) - - -) [17] if dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi [18] od [19] while PriorityQueue do [20] a := FindAndDeleteMin (PriorityQueue) <ref> [21] </ref> for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] AdjustHeap ( PriorityQueue, c, dist G (c, z)) <p> Though similar bounded algorithms have been previously proposed for this problem (see Rohnert [38], Even and Gazit [15], Lin and Chang <ref> [21] </ref>, and Ausiello et al. [2]), we present the algorithm for the sake of completeness. <p> Previous to this work no bounded algorithm was known for updating the solution to the all-pairs shortest-path problem after the deletion of an edge. Though they do not use the concept of boundedness, Rohnert [38], Even and Gazit [15], Lin and Chang <ref> [21] </ref>, and Ausiello et al. [2] do provide bounded algorithms for updating the solution to the all-pairs shortest-path problem after the insertion of an edge.
Reference: 22. <author> Loubal, P., </author> <title> A network evaluation procedure, </title> <journal> Highway Research Record 205 pp. </journal> <month> 96-109 </month> <year> (1967). </year>
Reference-contexts: := [17] for every vertex a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do <ref> [22] </ref> a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length <p> In particular, affected vertices that can no longer reach the sink vertex will not be processed. Each iteration takes O ( || a-||) time for lines [23]-[29], and O (log | AFFECTED | ) time for the heap operation in line <ref> [22] </ref>. Hence, the running time of Phase 2 is O ( || AFFECTED || + | AFFECTED | log | AFFECTED | ). <p> dist (x) then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) = dist (x) then [21] Insert x fi u into SP (G) and increment outdegree SP (x) <ref> [22] </ref> fi [24] od postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh <p> dist G (a, z) then InsertHeap (PriorityQueue, a, dist G (a, z)) fi [18] od [19] while PriorityQueue do [20] a := FindAndDeleteMin (PriorityQueue) [21] for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do <ref> [22] </ref> dist G (c, z) := length G (c fi a) + dist G (a, z) [23] AdjustHeap ( PriorityQueue, c, dist G (c, z)) [24] od [26] fi hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 16 - information is obtained when needed (in constant time) via the predicate SP (a, b, c ): SP (a, <p> Our procedures DeleteEdge APSP&gt;0 and InsertEdge APSP&gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal <ref> [22] </ref>, Rodionov [37], Halder [18], Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an
Reference: 23. <author> Marlowe, T.J., </author> <title> Data flow analysis and incremental iteration, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> DCS-TR-255, Rutgers University, </institution> <address> New Brunswick, NJ (October 1989). </address>
Reference-contexts: a AffectedVertices do [18] dist (a) := min (- length (a fi b) + dist (b) | a fi b E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) <ref> [23] </ref> for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist <p> while PriorityQueue do [20] a := FindAndDeleteMin (PriorityQueue) [21] for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) <ref> [23] </ref> AdjustHeap ( PriorityQueue, c, dist G (c, z)) [24] od [26] fi hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 16 - information is obtained when needed (in constant time) via the predicate SP (a, b, c ): SP (a, b, c) (dist (a, c) = length (a fi b) + dist (b, c)) (dist (a, <p> Some data-flow analysis algorithms also assume that the data-flow graph is a - 28 - reducible one. With either of these restrictions on input instances, the above reduction of SS-REACHABILITY to problem P is no longer valid. However, we follow Marlowe <ref> [23] </ref>, who argued that these assumptions should be dropped for studies of incremental data-flow analysis (see Section 3.3.1 of [23]). The second possible restriction on input instances relates to the mapping M. <p> With either of these restrictions on input instances, the above reduction of SS-REACHABILITY to problem P is no longer valid. However, we follow Marlowe <ref> [23] </ref>, who argued that these assumptions should be dropped for studies of incremental data-flow analysis (see Section 3.3.1 of [23]). The second possible restriction on input instances relates to the mapping M. Is it possible that realistic flow-graphs will never have a labeling corresponding to the difficult input instances shown to exist above? We argue below that this is not so. <p> In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis <ref> [6, 23, 24, 39, 40, 46] </ref>.
Reference: 24. <author> Marlowe, T.J. and Ryder, B.G., </author> <title> An efficient hybrid algorithm for incremental data flow analysis, pp. </title> <booktitle> 184-196 in Conference Record of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 17-19, </pages> <address> 1990), </address> <publisher> ACM, </publisher> <address> New York, NY (1990). </address>
Reference-contexts: For example, when the cost of the computation is expressed as a function of the size of the (current) input, the worst-case complexity of several incremental graph algorithms is no better than that of an algorithm that performs the computation from scratch <ref> [6, 8, 19, 24, 46] </ref>. <p> E (G) and b AffectedVertices) - - -) [19] if dist (a) then InsertHeap (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do <ref> [24] </ref> Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, <p> then [18] dist (x) := length (x fi u) + dist (u) [19] AdjustHeap (PriorityQueue, x, dist (x) - dist (v)) [20] else if length (x fi u) + dist (u) = dist (x) then [21] Insert x fi u into SP (G) and increment outdegree SP (x) [22] fi <ref> [24] </ref> od postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3.1.3. <p> for every vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] AdjustHeap ( PriorityQueue, c, dist G (c, z)) <ref> [24] </ref> od [26] fi hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 16 - information is obtained when needed (in constant time) via the predicate SP (a, b, c ): SP (a, b, c) (dist (a, c) = length (a fi b) + dist (b, c)) (dist (a, c ) ). <p> In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis <ref> [6, 23, 24, 39, 40, 46] </ref>.
Reference: 25. <author> Murchland, J.D., </author> <title> The effect of increasing or decreasing the length of a single arc on all shortest distances in a graph, </title> <type> Tech. Rep. </type> <institution> LBS-TNT-26, London Business School, Transport Network Theory Unit, </institution> <address> London, UK (1967). </address>
Reference-contexts: (PriorityQueue, a, dist (a)) fi [20] od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) <ref> [25] </ref> od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) [29] od [31] fi [32] else Remove edge v fi w <p> Our procedures DeleteEdge APSP&gt;0 and InsertEdge APSP&gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland <ref> [25, 26] </ref>, Loubal [22], Rodionov [37], Halder [18], Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore,
Reference: 26. <author> Murchland, J.D., </author> <title> A fixed matrix method for all shortest distances in a directed graph and for the inverse problem, </title> <type> Doctoral dissertation, </type> <institution> Universita .. t Karlsruhe, Karlsruhe, W. Germany </institution> (). 
Reference-contexts: dist (a)) fi [20] od [21] while PriorityQueue do [22] a := FindAndDeleteMin (PriorityQueue) [23] for every vertex b Succ (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od <ref> [26] </ref> for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) [29] od [31] fi [32] else Remove edge v fi w from E <p> vertex c Pred G (a) such that length G (c fi a) + dist G (a, z) &lt; dist G (c, z) do [22] dist G (c, z) := length G (c fi a) + dist G (a, z) [23] AdjustHeap ( PriorityQueue, c, dist G (c, z)) [24] od <ref> [26] </ref> fi hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 16 - information is obtained when needed (in constant time) via the predicate SP (a, b, c ): SP (a, b, c) (dist (a, c) = length (a fi b) + dist (b, c)) (dist (a, c ) ). <p> Our procedures DeleteEdge APSP&gt;0 and InsertEdge APSP&gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland <ref> [25, 26] </ref>, Loubal [22], Rodionov [37], Halder [18], Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore,
Reference: 27. <editor> Pape, U., Netzwerk-veraenderungen und korrektur kuerzester weglaengen von einer wurzelmenge zu allen anderen knoten, </editor> <booktitle> Computing 12 pp. </booktitle> <month> 357-362 </month> <year> (1974). </year>
Reference-contexts: (a) such that length (a fi b) + dist (b) = dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do <ref> [27] </ref> dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) [29] od [31] fi [32] else Remove edge v fi w from E (G) [33] fi postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is <p> Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov [37], Halder [18], Pape <ref> [27] </ref>, Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is made, none of the
Reference: 28. <author> Ramalingam, G. and Reps, T., </author> <title> On the computational complexity of incremental algorithms, </title> <institution> TR-1033, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1991). </note>
Reference-contexts: dist (a) do [24] Insert edge a fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) <ref> [28] </ref> AdjustHeap ( PriorityQueue, c, dist (c)) [29] od [31] fi [32] else Remove edge v fi w from E (G) [33] fi postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) <p> These generalizations are based on the technique of Edmonds and Karp for transforming the length of every edge in a graph to a non-negative real without changing the graph's shortest paths [13, 44], and are described in <ref> [28, 29] </ref>. The above techniques for updating the solution to the SSSP-Cycle&gt;0 problem fail for only one type of input change, namely the insertion of an edge u fi v that creates a path from u to the sink vertex where no path existed before.
Reference: 29. <author> Ramalingam, G., </author> <title> Bounded Incremental Computation, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> TR-1172, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1993). </note>
Reference-contexts: of this paper due to length considerations, including a generalization of the above-mentioned lower bound proofs to a much more powerful model of computation than the class of locally persistent algorithms, and a generalization of the incremental algorithm for the shortest-path problem to a more general class of problems. (See <ref> [29] </ref>.) The remainder of the paper is organized into five sections. Section 2 introduces terminology and notation. Section 3 presents bounded incremental algorithms for three problems: SSSP&gt;0, APSP&gt;0, and the circuit-annotation problem. Section 4 concerns lower-bound results, where lower bounds are established with respect to locally persistent algorithms. <p> Under less restricted assumptions, the circuit-annotation problem has an O ( || d || 2 || d || ) incremental algorithm <ref> [29] </ref>. - 5 - A directed graph G = (V (G), E (G)) consists of a set of vertices V (G) and a set of edges E (G), where E (G) V (G) V (G). <p> fi b into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) <ref> [29] </ref> od [31] fi [32] else Remove edge v fi w from E (G) [33] fi postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is <p> These generalizations are based on the technique of Edmonds and Karp for transforming the length of every edge in a graph to a non-negative real without changing the graph's shortest paths [13, 44], and are described in <ref> [28, 29] </ref>. The above techniques for updating the solution to the SSSP-Cycle&gt;0 problem fail for only one type of input change, namely the insertion of an edge u fi v that creates a path from u to the sink vertex where no path existed before. <p> However, even such an input modification can be handled in time O ( || d || . | d | ) by using an adaptation of the Bellman-Ford algorithm for the shortest-paths problem. (See <ref> [29] </ref>.) 3.2. The Dynamic All-Pairs Shortest-Path Problem This section concerns a bounded incremental algorithm for a version of the dynamic all-pairs shortest-path problem with positive-length edges (APSP&gt;0). We will assume that the vertices of G are indexed from 1 . . | V (G) | . <p> A variant of the incremental algorithm presented in this section runs in O ( || d || 2 . 2 || d || 2 ) time under this assumption. We do not describe the variant here due to space limitations. See <ref> [29] </ref> - 20 - algorithm for the dynamic circuit-annotation problem was known. Consider a circuit whose vertices are annotated with (output) values. The value annotating vertex u will be denoted by u.value. <p> Such changes improve the average-case performance, but the worst-case complexity would still be exponential in || d || . Experimental results show that with such improvements, the above algorithm is actually a practical one, at least in some contexts such as language-sensitive editors. See <ref> [29] </ref>. End Aside. - 23 - Note that even if the circuit G is not binary, UpdateCircuit will compute the correct annotation of G. However, it may not do so in time bounded by any function of || d || . <p> These lower bound results also hold with respect to a more powerful model of computation (a restricted pointer machine model), but we present only the proof for the class of locally persistent algorithms due to space considerations. The more general proof may be found in <ref> [29] </ref> - 24 - Throughout the section, unless explicitly noted otherwise, the term unbounded is shorthand for unbounded for the class of locally persistent algorithms. 4.1. <p> This model of incremental computation is flawed because it excludes from consideration any algorithm that makes use of locally stored pointers. These lower bound results, however, do hold with respect to more powerful models of computation. (See <ref> [29] </ref>.) We believe that the class of unbounded problems provides an example of the kind of characterization of the problems with inherently poor incremental performance that one should look for in other (as yet unspecified) models of incremental computation. 6.2.
Reference: 30. <author> Reif, J.H., </author> <title> A topological approach to dynamic graph connectivity, </title> <note> Information Processing Letters 25(1) pp. </note> <month> 65-70 </month> <year> (1987). </year>
Reference-contexts: The remainder of this section discusses how our results relate to previous work on incremental computation and incremental algorithms. 6.1. Previous Work on Classifying Incremental Problems The problem of classifying dynamic problems has been addressed in two previous papers, one by Reif <ref> [30] </ref> and one by Berman, Paull, and Ryder [3]. One aspect of our work that sets it apart from both of these papers is that we analyze incremental complexity in terms of the adaptive parameter || d || , rather than in terms of the size of the current input. <p> The paper by Reif primarily concerns an algorithm for the connectivity problem in undirected graphs when edge deletions but not edge insertions are permitted <ref> [30] </ref>. 5 At the end of the paper, Reif lists a number of dynamic problems . . . with linear time sequential RAM algorithms on a single input instance, but which seem to require a complete recomputation in the worst case if a single symbol of the input is modified.
Reference: 31. <author> Reps, T., </author> <title> Optimal-time incremental semantic analysis for syntax-directed editors, pp. </title> <booktitle> 169-176 in Conference Record of the Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NM, </address> <month> January 25-27, </month> <year> 1982), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1982). </address>
Reference-contexts: into SP (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) [29] od <ref> [31] </ref> fi [32] else Remove edge v fi w from E (G) [33] fi postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length <p> The problem of incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation trees after a restructuring operation has been applied to the treewas shown by Reps to be linear in || d || <ref> [31] </ref> (see also [32] and [33]). Thus, the algorithm he gave for the problem is asymptotically optimal. ([31] is also the first paper that we are aware of in which an incremental algorithm is analyzed in terms of the parameter || d || .) The concept of a locally persistent algorithm <p> In the dynamic priority-ordering problem, as the DAG is modified the goal is to maintain priorities on the graph vertices such that if there is a path from v to w then - 29 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh UNBOUNDED EXPONENTIAL POLYNOMIAL CIRCUIT-ANNOTATION PROBLEM [1], [Section 3.3] ATTRIBUTE UPDATING <ref> [31] </ref> PRIORITY ORDERING [1] ALL-PAIRS SHORTEST PATH (&gt; 0) [Section 3.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt; 0) [Section 3.1] MEET-SEMILATTICE DATA-FLOW ANALYSIS PROBLEMS [Section 4.3] SINGLE-SOURCE/SINK CLOSED-SEMIRING PATH PROBLEMS [Section 4.2] SINGLE-SOURCE/SINK SHORTEST PATH (&gt;= 0) [Section 4.2] SINGLE-SOURCE/SINK REACHABILITY [Section 4.1] d |||| d |||| WEIGHTED CIRCUIT-ANNOTATION PROBLEM ([29]) d |||| <p> Attribute Updating The first paper that we are aware of in which an incremental algorithm is analyzed in terms of || d || is a paper by Reps <ref> [31] </ref> (see also [32] and [33]). 7 The problem discussed in that paper is incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation tree after a restructuring operation (such as the replacement of a subtree) has been applied to the tree.
Reference: 32. <author> Reps, T., Teitelbaum, T., and Demers, A., </author> <title> Incremental context-dependent analysis for language-based editors, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 5(3) pp. </pages> <month> 449-477 (July </month> <year> 1983). </year>
Reference-contexts: (G) and increment outdegree SP (a) [25] od [26] for every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) [29] od [31] fi <ref> [32] </ref> else Remove edge v fi w from E (G) [33] fi postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the <p> The problem of incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation trees after a restructuring operation has been applied to the treewas shown by Reps to be linear in || d || [31] (see also <ref> [32] </ref> and [33]). <p> Attribute Updating The first paper that we are aware of in which an incremental algorithm is analyzed in terms of || d || is a paper by Reps [31] (see also <ref> [32] </ref> and [33]). 7 The problem discussed in that paper is incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation tree after a restructuring operation (such as the replacement of a subtree) has been applied to the tree.
Reference: 33. <author> Reps, T., </author> <title> Generating Language-Based Environments, </title> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA (1984). </address>
Reference-contexts: every vertex c Pred (a) such that length (c fi a) + dist (a) &lt; dist (c) do [27] dist (c) := length (c fi a) + dist (a) [28] AdjustHeap ( PriorityQueue, c, dist (c)) [29] od [31] fi [32] else Remove edge v fi w from E (G) <ref> [33] </ref> fi postconditions SP (G) is the shortest-paths subgraph of G " v V (G), outdegree SP (v) is the outdegree of vertex v in the shortest-paths subgraph SP (G) " v V (G), dist (v) is the length of the shortest path from v to sink (G) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 9 <p> In the previous two paragraphs, we have been speaking very roughly. In particular, because DeleteEdge SSSP&gt;0 as stated in Figure 1 actually performs the deletion of edge v fi w from graph G (see lines [2] and <ref> [33] </ref>), a few changes in DeleteEdge SSSP&gt;0 are necessary for it to be called multiple times in the manner suggested above. There is also a more serious problem with using procedure DeleteEdge SSSP&gt;0 from Figure 1 in conjunction with the ideas outlined above. <p> The problem of incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation trees after a restructuring operation has been applied to the treewas shown by Reps to be linear in || d || [31] (see also [32] and <ref> [33] </ref>). <p> Attribute Updating The first paper that we are aware of in which an incremental algorithm is analyzed in terms of || d || is a paper by Reps [31] (see also [32] and <ref> [33] </ref>). 7 The problem discussed in that paper is incremental attribute evaluation for noncircular attribute grammarshow to reevaluate the attributes of an attributed derivation tree after a restructuring operation (such as the replacement of a subtree) has been applied to the tree. <p> Subsequently, other optimal algorithms were given for a variety of attribute-grammar subclasses, e.g., absolutely noncircular grammars <ref> [33] </ref> and ordered attribute grammars [36, 45]. All of the algorithms cited above are locally persistent.
Reference: 34. <author> Reps, T., Marceau, C., and Teitelbaum, T., </author> <title> Remote attribute updating for language-based editors, pp. </title> <booktitle> 1-13 in Conference Record of the Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (St. Petersburg, FL, </address> <month> Jan. </month> <pages> 13-15, </pages> <address> 1986), </address> <publisher> ACM, </publisher> <address> New York, NY (1986). </address>
Reference-contexts: There are also a variety of other attribute-updating algorithms described in the literature, including one that handles k simultaneous subtree replacements in an n-node tree and runs in amortized time O (( || d || + k ) . log n) <ref> [34] </ref>, and another that permits unit-cost, random-access cursor motion for noncircular attribute grammars and runs in amortized time O ( || d || . dd n ) [35].
Reference: 35. <author> Reps, T., </author> <title> Incremental evaluation for attribute grammars with unrestricted movement between tree modifications, </title> <journal> Acta Informa-tica, </journal> <pages> pp. </pages> <month> 155-178 </month> <year> (1988). </year>
Reference-contexts: simultaneous subtree replacements in an n-node tree and runs in amortized time O (( || d || + k ) . log n) [34], and another that permits unit-cost, random-access cursor motion for noncircular attribute grammars and runs in amortized time O ( || d || . dd n ) <ref> [35] </ref>. These algorithms have hybrid complexity measures, in the sense that the running time is a function of the size of the current input as well as || d || (i.e., the running time is of the form O (f ( | input | , || d || )).
Reference: 36. <author> Reps, T. and Teitelbaum, T., </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: Subsequently, other optimal algorithms were given for a variety of attribute-grammar subclasses, e.g., absolutely noncircular grammars [33] and ordered attribute grammars <ref> [36, 45] </ref>. All of the algorithms cited above are locally persistent.
Reference: 37. <author> Rodionov, V., </author> <title> The parametric problem of shortest distances, </title> <journal> U.S.S.R. Computational Math. and Math. Phys. </journal> <pages> 8(5) pp. </pages> <month> 336-343 </month> <year> (1968). </year>
Reference-contexts: Our procedures DeleteEdge APSP&gt;0 and InsertEdge APSP&gt;0 can be generalized to maintain one shortest path between any pair of vertices without increasing their asymptotic time complexity. Other previous work on how to maintain shortest paths in graphs incrementally includes papers by Murchland [25, 26], Loubal [22], Rodionov <ref> [37] </ref>, Halder [18], Pape [27], Hsieh et al. [20], Cheston [8], Goto et al. [16], Cheston and Corneil [9]; however, none of the papers in this group analyze either the single-source or the all-pairs problem in terms of the parameter || d || , and furthermore, when such an analysis is
Reference: 38. <author> Rohnert, H., </author> <title> A dynamization of the all pairs least cost path problem, pp. </title> <booktitle> 279-286 in Proceedings of STACS 85: Second Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <editor> (Saarbruecken, W. Ger., </editor> <month> Jan. </month> <pages> 3-5, </pages> <year> 1985), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 182, </volume> <editor> ed. K. Mehlhorn,Springer-Verlag, </editor> <address> New York, NY (1985). </address> - <month> 37 </month> - 
Reference-contexts: Insertion of an Edge We now present a bounded incremental algorithm for the problem of updating the solution to APSP&gt;0 after an edge v fi w of length c is inserted into G. Though similar bounded algorithms have been previously proposed for this problem (see Rohnert <ref> [38] </ref>, Even and Gazit [15], Lin and Chang [21], and Ausiello et al. [2]), we present the algorithm for the sake of completeness. <p> Previous to this work no bounded algorithm was known for updating the solution to the all-pairs shortest-path problem after the deletion of an edge. Though they do not use the concept of boundedness, Rohnert <ref> [38] </ref>, Even and Gazit [15], Lin and Chang [21], and Ausiello et al. [2] do provide bounded algorithms for updating the solution to the all-pairs shortest-path problem after the insertion of an edge. There have been three previous papers on handling edge deletion in APSP&gt;0by Dionne [11], Rohnert [38], and Even <p> boundedness, Rohnert <ref> [38] </ref>, Even and Gazit [15], Lin and Chang [21], and Ausiello et al. [2] do provide bounded algorithms for updating the solution to the all-pairs shortest-path problem after the insertion of an edge. There have been three previous papers on handling edge deletion in APSP&gt;0by Dionne [11], Rohnert [38], and Even and Gazit [15]in which the analysis might be misinterpreted, on first reading, as demonstrating that the algorithms are bounded. In fact, the algorithms given in all three papers have - 34 - unbounded incremental complexity in general.
Reference: 39. <author> Rosen, B.K., </author> <title> Linear cost is sometimes quadratic, pp. </title> <booktitle> 117-124 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis <ref> [6, 23, 24, 39, 40, 46] </ref>.
Reference: 40. <author> Ryder, B.G. and Paull, </author> <title> M.C., Incremental data flow analysis algorithms, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 10(1) pp. </pages> <month> 1-50 (January </month> <year> 1988). </year>
Reference-contexts: Together with some previously known results, our results help one to understand the complexity hierarchy that exists when dynamic problems are classified according to their incremental complexity with respect to locally persistent algorithms. Ryder and Paull have remarked about the inappropriateness of worst-case analysis for dynamic algorithms <ref> [40] </ref>; similar remarks have appeared in several other papers. However, our work shows that for some dynamic problems it is not that worst-case analysis is inappropriate, but rather that an analysis carried out in terms of the parameter | input | is inappropriate. <p> In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis <ref> [6, 23, 24, 39, 40, 46] </ref>.
Reference: 41. <author> Ryder, B.G., Landi, W., and Pande, H.D., </author> <title> Profiling an incremental data flow analysis algorithm, </title> <journal> IEEE Transactions on Software Engineering SE-16(2)(February 1990). </journal>
Reference-contexts: For instance, Hoover presents evidence that his unbounded algorithm for the circuit-value problem performs well in practice [19]; Ryder, Landi, and Pande present evidence that the unbounded incremental data-flow analysis algorithm of Carroll and Ryder [6] performs well in practice <ref> [41] </ref>; Dionne reports excellent performance for some unbounded algorithms for APSP&gt;0 [11].
Reference: 42. <author> Sedgewick, R., </author> <title> Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983). </address>
Reference-contexts: v V (G), dist (v) is the length of the shortest path from v to sink (G) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 9 - Phase 2: Determining new distances for affected vertices and updating SP (G) Phase 2 of DeleteEdge SSSP&gt;0 is an adaptation of Dijkstra's batch shortest-path algorithm that uses priority-first search <ref> [42] </ref> to compute the new dist values for the affected vertices. Consider Figure 2. Assume that for every vertex y in set A the length of the shortest path from y to the sink is known and is given by dist (y ).
Reference: 43. <author> Spira, P.M. and Pan, A., </author> <title> On finding and updating spanning trees and shortest paths, </title> <note> SIAM J. Computing 4(3) pp. 375-380 (Sep-tember 1975). </note>
Reference-contexts: size of the input), it has even been possible to show a lower-bound result for the problem itself, demonstrating that no incremental algorithm (subject to certain restrictions) for the problem can, in the worst case, run in time asymptotically better than the time required to perform the computation from scratch <ref> [3, 15, 43] </ref>. For these reasons, worst-case analysis with costs expressed as a function of the size of the input is often not of much help in making comparisons between different incremental algorithms. This paper explores a different way to analyze the computational complexity of incremental algorithms. <p> Spira and Pan <ref> [43] </ref>, in fact, show that no incremental algorithm for the shortest path problem with positive edge lengths can do better than the best batch algorithm, under the assumption that the incremental algorithm retains only the shortest-paths information. <p> way to compare different algorithms for a problem with an O (1) IRLB (thereby leading to a way out of the conundrum). hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 The arguments that Berman, Paull, and Ryder use to establish relative lower bounds for various problems are similar to the ones used by Spira and Pan <ref> [43] </ref> and Even and Gazit [15] to establish that no incremental algorithm for the all-pairs shortest-path problem can do better in the worst case than the best batch algorithm for the problem. - 32 - Although knowing that a problem has an IRLB of O (1) is certainly a property of
Reference: 44. <author> Tarjan, R.E., </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA (1983). </address>
Reference-contexts: These generalizations are based on the technique of Edmonds and Karp for transforming the length of every edge in a graph to a non-negative real without changing the graph's shortest paths <ref> [13, 44] </ref>, and are described in [28, 29].
Reference: 45. <author> Yeh, D., </author> <title> On incremental evaluation of ordered attributed grammars, </title> <note> BIT 23 pp. </note> <month> 308-320 </month> <year> (1983). </year>
Reference-contexts: Subsequently, other optimal algorithms were given for a variety of attribute-grammar subclasses, e.g., absolutely noncircular grammars [33] and ordered attribute grammars <ref> [36, 45] </ref>. All of the algorithms cited above are locally persistent.
Reference: 46. <author> Zadeck, F.K., </author> <title> Incremental data flow analysis in a structured program editor, </title> <booktitle> Proceedings of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(6) pp. </journal> <month> 132-143 (June </month> <year> 1984). </year>
Reference-contexts: For example, when the cost of the computation is expressed as a function of the size of the (current) input, the worst-case complexity of several incremental graph algorithms is no better than that of an algorithm that performs the computation from scratch <ref> [6, 8, 19, 24, 46] </ref>. <p> In this paper, we measure the complexity of an dynamic algorithm in terms of the sum of the sizes of the changes in the input and the output. A number of papers in the literature on dynamic algorithms concern incremental data-flow analysis <ref> [6, 23, 24, 39, 40, 46] </ref>.
References-found: 46

