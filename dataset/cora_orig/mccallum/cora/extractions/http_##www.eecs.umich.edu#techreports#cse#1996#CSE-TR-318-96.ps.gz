URL: http://www.eecs.umich.edu/techreports/cse/1996/CSE-TR-318-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse96.html
Root-URL: http://www.eecs.umich.edu
Email: fsdawson,farnam,mittong@eecs.umich.edu  
Title: ORCHESTRA: A Fault Injection Environment for Distributed Systems  
Author: Scott Dawson, Farnam Jahanian, and Todd Mitton 
Keyword: fault injection, distributed systems, communication protocols, real-time systems.  
Address: Ann Arbor, MI 48109-2122 USA  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: This paper reports on orchestra, a portable fault injection environment for testing implementations of distributed protocols. The paper focuses on architectural features of orchestra that provide portability, minimize intrusiveness on target protocols, and support testing of real-time systems. orchestra is based on a simple yet powerful framework, called script-driven probing and fault injection, for the evaluation and validation of the fault-tolerance and timing characteristics of distributed protocols. orchestra was initially developed on the Real-Time Mach operating system and later ported to other platforms including Solaris and SunOS, and has been used to conduct extensive experiments on several protocol implementations. A novel feature of the Real-Time Mach implementation of orchestra is that it utilizes certain features of the Real-Time Mach operating system to quantify and compensate for intrusiveness of the fault injection mechanism. In addition to describing the overall orchestra architecture and implementation, this paper also describes the experimental evaluation of two protocol implementations: a distributed group membership service on the Sun Solaris operating system, and a real-time audio-conferencing application on Real-Time Mach. This is a substantially expanded revision of a paper that appeared in the 26th International Symposium on Fault-Tolerant Computing (FTCS)[12]. This work is supported in part by a research grant from the U.S. Office of Naval Research, N0014-95-1-0261, and a research grant from Defense Advanced Research Projects Agency, monitored by the U.S. Air Force Rome Laboratory under Grant F30602-95-1-0044. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Arlat, M. Aguera, Y. Crouzet, J.-C. Fabre, E. Martins, and D. Powell. </author> <title> Experimental evaluation of the fault tolerance of an atomic multicast system. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The emphasis of this approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. <ref> [1] </ref>). Hence, the focus is on developing fault injection techniques that can be employed in studying three aspects of a target protocol: i) detecting design or implementation errors, ii) identifying violations of protocol specifications, and iii) obtaining insights into the design decisions made by the implementors. <p> Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [3, 13, 14, 18]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [1] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [36] in the presence of faults. Other work can be characterized as deterministic approaches to test generation [3, 13].
Reference: [2] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie. </author> <title> Fault injection for dependability validation of fault-tolerant computing systems. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: A recent survey paper [5] presents several fault injection studies, and also discusses several different tools that facilitate the application of fault injection in various environments. Hardware fault-injection (e.g. <ref> [2, 35] </ref>) and simulation approaches for injecting hardware failures (e.g. [8, 16]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34].
Reference: [3] <author> D. Avresky, J. Arlat, J. Laprie, and Y. Crouzet. </author> <title> Fault injection for the formal testing of fault tolerance. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [3, 13, 14, 18] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [1] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [36] in the presence of faults. Other work can be characterized as deterministic approaches to test generation <ref> [3, 13] </ref>. In [13], the evaluation of design fault coverage is based on a stochastic model. The authors of [3] propose a framework to conduct test sequences for identifying design and implementation faults in complex fault-tolerant protocols. <p> Other work can be characterized as deterministic approaches to test generation [3, 13]. In [13], the evaluation of design fault coverage is based on a stochastic model. The authors of <ref> [3] </ref> propose a framework to conduct test sequences for identifying design and implementation faults in complex fault-tolerant protocols.
Reference: [4] <author> R. Chillarege and N. S. Bowen. </author> <title> Understanding large system failures | a fault injection experiment. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection (e.g. [2, 35]) and simulation approaches for injecting hardware failures (e.g. [8, 16]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [4, 34] </ref>. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [3, 13, 14, 18]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [5] <author> J. A. Clark and D. K. Pradhan. </author> <title> Fault injection: A method for validating computer-system dependability. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 47-56, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: A detailed comparison on fault injection of the TCP protocol appears in [10]. (b) Fault injection techniques: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. A recent survey paper <ref> [5] </ref> presents several fault injection studies, and also discusses several different tools that facilitate the application of fault injection in various environments. Hardware fault-injection (e.g. [2, 35]) and simulation approaches for injecting hardware failures (e.g. [8, 16]) have received much attention in the past.
Reference: [6] <author> D. E. Comer and J. C. Lin. </author> <title> Probing TCP implementations. </title> <booktitle> In Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Furthermore, our approach requires that a filter be inserted at various levels in a protocol stack, unlike packet filters that are inserted on top of link-level device drivers and below the listening applications. Another closely related work is the active probing approach proposed by Comer and Lin <ref> [6] </ref> to study five TCP implementations. In addition to repeating TCP experiments similar to those reported in [6], our approach allows manipulation of messages as well as simulation of more complex failure models which are not possible with techniques that are based primarily on monitoring and gathering trace data. <p> Another closely related work is the active probing approach proposed by Comer and Lin <ref> [6] </ref> to study five TCP implementations. In addition to repeating TCP experiments similar to those reported in [6], our approach allows manipulation of messages as well as simulation of more complex failure models which are not possible with techniques that are based primarily on monitoring and gathering trace data.
Reference: [7] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 175-188, </pages> <year> 1991. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, (e.g. <ref> [7, 28, 31] </ref>). A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in ([22]), ensures that membership changes are seen in the same order by all non-faulty members.
Reference: [8] <author> E. Czeck and D. Siewiorek. </author> <title> Effects of transient gate-level faults on program behaviour. </title> <booktitle> In Proc. International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: A recent survey paper [5] presents several fault injection studies, and also discusses several different tools that facilitate the application of fault injection in various environments. Hardware fault-injection (e.g. [2, 35]) and simulation approaches for injecting hardware failures (e.g. <ref> [8, 16] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [3, 13, 14, 18].
Reference: [9] <author> S. Dawson and F. Jahanian. </author> <title> Deterministic Fault Injection of Distributed Systems. </title> <editor> In K. Birman, F. Mattern, and A. Shiper, editors, </editor> <booktitle> Lecture Notes in Computer Science # 938: Theory and Practice in Distributed Systems, </booktitle> <pages> pages 178-196. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: This paper reports on a software fault injection tool, called orchestra, for testing dependability and timing properties of distributed protocols. orchestra is based on a simple yet powerful framework, called script-driven probing and fault injection, first reported in <ref> [9, 10] </ref>. The emphasis of this approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. [1]).
Reference: [10] <author> S. Dawson and F. Jahanian. </author> <title> Probing and Fault Injection of Protocol Implementations. </title> <booktitle> Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pages 351-359, </pages> <month> May </month> <year> 1995. </year> <month> 28 </month>
Reference-contexts: This paper reports on a software fault injection tool, called orchestra, for testing dependability and timing properties of distributed protocols. orchestra is based on a simple yet powerful framework, called script-driven probing and fault injection, first reported in <ref> [9, 10] </ref>. The emphasis of this approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. [1]). <p> A detailed comparison on fault injection of the TCP protocol appears in <ref> [10] </ref>. (b) Fault injection techniques: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. A recent survey paper [5] presents several fault injection studies, and also discusses several different tools that facilitate the application of fault injection in various environments. <p> Although our implementation of orchestra described in this paper is fixed at the socket layer, the protocol independent nature of the PFICore allows the PFI layer to be moved around the protocol stack fairly easily. In a previous paper <ref> [10] </ref> we describe an x-kernel layer implementation which can be placed anywhere in an x-kernel protocol stack. We should note that the work on the EFA project has recently concentrated on automatic generation of fault cases to be injected. <p> The orchestra tool (and an earlier prototype implementa 27 tion) have been used to conduct extensive experiments on several commercial and research systems including six implementations of the TCP communication protocol <ref> [10] </ref>, a primary-backup replication protocol [11], a distributed group membership service, and a real-time audio-conferencing application, as reported in this paper. These experiments revealed major design/implementation errors as well as subtle violations of the protocol specifications.
Reference: [11] <author> S. Dawson, F. Jahanian, and T. Mitton. </author> <title> A Software Fault-Injection Tool on Real-Time Mach. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The main component of orchestra is the PFICore <ref> [11, 12] </ref>, which is responsible for all fault injection actions. The PFICore is the heart of the fault injection layer, and provides the mechanism for injecting faults into protocols, regardless of where the protocol resides in the protocol stack. <p> The orchestra tool (and an earlier prototype implementa 27 tion) have been used to conduct extensive experiments on several commercial and research systems including six implementations of the TCP communication protocol [10], a primary-backup replication protocol <ref> [11] </ref>, a distributed group membership service, and a real-time audio-conferencing application, as reported in this paper. These experiments revealed major design/implementation errors as well as subtle violations of the protocol specifications.
Reference: [12] <author> S. Dawson, F. Jahanian, and T. Mitton. </author> <title> Testing of Fault-Tolerant and Real-Time Distributed Systems via Protocol Fault Injection. </title> <booktitle> In International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 404-414, </pages> <address> Sendai, Japan, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The main component of orchestra is the PFICore <ref> [11, 12] </ref>, which is responsible for all fault injection actions. The PFICore is the heart of the fault injection layer, and provides the mechanism for injecting faults into protocols, regardless of where the protocol resides in the protocol stack.
Reference: [13] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [3, 13, 14, 18] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [1] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [36] in the presence of faults. Other work can be characterized as deterministic approaches to test generation <ref> [3, 13] </ref>. In [13], the evaluation of design fault coverage is based on a stochastic model. The authors of [3] propose a framework to conduct test sequences for identifying design and implementation faults in complex fault-tolerant protocols. <p> For example, the work reported in [1] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [36] in the presence of faults. Other work can be characterized as deterministic approaches to test generation [3, 13]. In <ref> [13] </ref>, the evaluation of design fault coverage is based on a stochastic model. The authors of [3] propose a framework to conduct test sequences for identifying design and implementation faults in complex fault-tolerant protocols.
Reference: [14] <author> K. Echtle and M. Leu. </author> <title> The EFA Fault Injector for Fault-Tolerant Distributed System Testing. </title> <booktitle> In Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pages 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [3, 13, 14, 18] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Hence, deterministic control on ordering of certain concurrent messages is a key to this approach. Finally, one significant distinguishing characteristic of our approach is the focus on real-time as well as fault tolerance characteristics of distributed systems. The Delayline [21] tool and the EFA fault injection environment reported in <ref> [14] </ref> are closest to the approach described in this paper. The Delayline tool allows the user to introduce delays 26 into user-level protocols.
Reference: [15] <author> K. Echtle and M. Leu. </author> <title> Test of fault tolerant distributed systems by fault injection. IEEE Fault Tolerant Parallel and Distributed Systems, </title> <month> June </month> <year> 1995. </year>
Reference-contexts: An attributed Petri net model is used to derive the fault cases by a reachability analysis. This is a very promising research avenue which has been reported in <ref> [15] </ref>. This approach differs from the work reported in this paper in that fault injection scripts in orchestra are hand-crafted by the user and this process is facilitated by a state-transition-based graphical user interface. <p> Last, the implementation of orchestra on Real-Time Mach takes advantage of some Real-Time Mach features to attempt to compensate for intrusiveness of the fault injection layer for real-time applications. The Petri net model used in <ref> [15] </ref> does allow for specification of real-time protocols.
Reference: [16] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behaviour under hardware faults. </title> <booktitle> In Proc. International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: A recent survey paper [5] presents several fault injection studies, and also discusses several different tools that facilitate the application of fault injection in various environments. Hardware fault-injection (e.g. [2, 35]) and simulation approaches for injecting hardware failures (e.g. <ref> [8, 16] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [3, 13, 14, 18].
Reference: [17] <author> V. Hadzilacos and S. Toueg. </author> <title> Fault-tolerant broadcasts and related problems. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1993. </year> <note> Second Edition. </note>
Reference-contexts: Instead, modifying and supporting a popular interpreted language with a collection of predefined libraries gives the user a very effective tool which allows him/her to write most scripts. It 3 A formal treatment of these failure models is beyond the scope of this presentation <ref> [17] </ref>. 7 also eases the burden of learning a new language for users already familiar with whatever interpreted language is chosen. As mentioned previously, we use Tcl [30] as the scripting language in the implementation of our tool.
Reference: [18] <author> S. Han, H. A. Rosenberg, and K. G. Shin. DOCTOR: </author> <title> An integrateD SOftware fault injeCTOn enviRonment. </title> <type> Technical report, </type> <institution> University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [3, 13, 14, 18] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> In [13], the evaluation of design fault coverage is based on a stochastic model. The authors of [3] propose a framework to conduct test sequences for identifying design and implementation faults in complex fault-tolerant protocols. The work reported in <ref> [18] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [19] <author> M. A. Hiltunen and R. D. Schlichting. </author> <title> Understanding membership. </title> <type> Technical Report TR 95-07, </type> <institution> University of Arizona, Tuscon, Arizona, </institution> <month> June </month> <year> 1995. </year>
Reference: [20] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(1) </volume> <pages> 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In the model underlying script-driven probing and fault injection, a distributed protocol can be viewed as an abstraction through which a collection of participants communicate by exchanging a set of messages, in the same spirit as the x-kernel <ref> [20] </ref>. Hence, no distinction is made between application-level protocols, communication protocols, or device layer protocols. In this approach, a protocol fault injection (PFI) layer is inserted below a target protocol to filter and manipulate the messages that are exchanged between participants. <p> covered, and methods of minimizing and compensating for intrusiveness are presented. 2.1 Approach: Script-Driven Probing and Fault Injection In script-driven probing and fault injection, a distributed protocol can be viewed as an abstraction through which a collection of participants communicate by exchanging a set of messages, as in the x-kernel <ref> [20] </ref>. Each layer provides an abstract communication service to higher layers, and there is no distinction made between particular layers of the protocol stack.
Reference: [21] <author> D. B. Ingham and G. D. Parrington. Delayline: </author> <title> A Wide-Area Network Emulation Tool. </title> <journal> Computing Systems, </journal> <volume> 7(3) </volume> <pages> 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: Hence, deterministic control on ordering of certain concurrent messages is a key to this approach. Finally, one significant distinguishing characteristic of our approach is the focus on real-time as well as fault tolerance characteristics of distributed systems. The Delayline <ref> [21] </ref> tool and the EFA fault injection environment reported in [14] are closest to the approach described in this paper. The Delayline tool allows the user to introduce delays 26 into user-level protocols.
Reference: [22] <author> F. Jahanian, R. Rajkumar, and S. Fakhouri. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, New Jersey, </address> <month> October </month> <year> 1993. </year>
Reference: [23] <author> H. Kopetz and G. Grunsteidl. </author> <title> TTP a protocol for fault-tolerant real-time systems. </title> <journal> IEEE Computer, </journal> <volume> 27(1) </volume> <pages> 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference: [24] <author> C. Lee, R. Rajkumar, and C. Mercer. </author> <title> Experiences with processor reservation and dynamic qos in real-time mach. </title> <booktitle> In Proceedings of Multimedia Japan 96, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: A closely related objective was to illustrate that by measuring the intrusiveness of the fault injection layer, one can compensate for timing perturbation with significant accuracy. RT-Phone is a distributed teleconferencing application with a telephone-pad-like Motif-based graphical interface <ref> [24] </ref>. A caller and a callee can establish a 2-way audio connection across the network using the graphical user interface shown in Figure 6. <p> The end-to-end delay of the audio stream is 3T + N etwork delay. (Note that the delay is not 4T + N etwork delay. 10 ) A typical value for T is 16 ms for a connection with 16KHz sampling and 1 byte/sample <ref> [24] </ref>. The list of experiments conducted on RT-Phone follows: Performance measurement of network delay component of end-to-end delay: In this experiment, orchestra was used to measure the network delay component of the end-to-end delay shown in being met.
Reference: [25] <author> S. McCanne and V. Jacobson. </author> <title> The BSD Packet Filter: A New Architecture for User-level Packet Capture. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [29], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [25] </ref>, and the Mach Packet Filter (MPF) [37] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [26] <author> M. J. McLennan. </author> <title> The new [incr Tcl]: Objects, mega-widgets, namespaces and more. </title> <booktitle> In USENIX Third Annual Tcl/Tk Workshop, </booktitle> <pages> pages 151-159, </pages> <address> Toronto, Canada, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Figure 11 shows a typical dialog box for the counter action. 5.3 Implementation of the Graphical Script Editor The graphical script editor was developed using [incr Tcl] <ref> [26] </ref> which is an object oriented version of Tcl. Because [incr Tcl] is based on Tk, it was relatively easy to create the application compared to using Motif. It is also much more portable, allowing the editor to run on platforms including UNIX, Windows 95/NT, and Macintosh.
Reference: [27] <author> C. W. Mercer, J. Zelenka, and R. Rajkumar. </author> <title> On Predictable Operating System Protocol Processing. </title> <type> Technical Report CMU-CS-94-165, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: For example, in the implementation of orchestra on Real-Time Mach, we exploit operating system support, such as scheduler feedback and capacity reservation <ref> [27] </ref>, to quantify intrusiveness on a target protocol and to compensate for it whenever possible. The remainder of this paper is organized as follows. Section 2 presents the overall orchestra framework, covering the script-driven probing and fault injection technique, the orchestra architecture, and specification of fault injection scripts. <p> For applications which are simply sending and receiving data, significant speedup (over the UX server implementation) has been achieved by using libsockets.a. In Real-Time Mach, user level sockets have been used in conjunction with processor reserves to achieve predictable protocol processing <ref> [27] </ref>. Protocol processing is made predictable by binding the protocol processing thread to a processor reserve so that sufficient time is set aside for communication. <p> This is clearly a system-dependent solution which must rely on appropriate support from a real-time operating system. The Real-Time Mach microkernel supports an abstraction called processor capacity reserve <ref> [27] </ref> which allows application threads to specify their CPU requirements in terms of their timing requirements. If the request is admitted by the kernel, the task is guaranteed to receive the requested CPU allocation. The kernel allows multiple threads to be bound to the same reserve.
Reference: [28] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <booktitle> In Second Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, (e.g. <ref> [7, 28, 31] </ref>). A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in ([22]), ensures that membership changes are seen in the same order by all non-faulty members.
Reference: [29] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [29] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [25], and the Mach Packet Filter (MPF) [37] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [30] <author> J. K. Ousterhout. </author> <title> Tcl: An embeddable command language. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 133-146, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Fault injection is done at the message-level by intercepting and manipulating incoming/outgoing messages of a target protocol, or by probing a participant by injecting spontaneous messages into the system. Furthermore, the orchestra engine interprets the fault injection test scripts written in the Tcl language <ref> [30] </ref> or via a state-transition-based graphical user interface. Because Tcl is interpreted, one can develop relatively complex scripts to modify existing experiments or to perform new tests without re-compiling the target protocol or the fault injection tool. <p> It 3 A formal treatment of these failure models is beyond the scope of this presentation [17]. 7 also eases the burden of learning a new language for users already familiar with whatever interpreted language is chosen. As mentioned previously, we use Tcl <ref> [30] </ref> as the scripting language in the implementation of our tool. Tcl allows users to define their own extensions, usually written in C, to the scripting language.
Reference: [31] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, (e.g. <ref> [7, 28, 31] </ref>). A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in ([22]), ensures that membership changes are seen in the same order by all non-faulty members.
Reference: [32] <author> A. Sah and J. Blow. </author> <title> A compiler for the Tcl language. </title> <booktitle> In Proceedings of the Tcl'93 Workshop, </booktitle> <address> Berkeley, California, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Standard deviations on these measurements were 35 and 36 s respectively. The fact that different scripts have differences in execution times on the order of hundreds of microseconds is due mainly to the fact that Tcl is interpreted. Work presented in <ref> [32] </ref> addresses this by providing a version of Tcl that accepts compiled scripts as input. Speedups of 8-12 times over the interpreted case were presented in this paper, which would bring our measurement differences down onto the order of tens of microseconds.
Reference: [33] <author> A. Schiper and A. Ricciardi. </author> <title> Virtually-synchronous communication based on a weak failure suspector. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 534-543, </pages> <month> June </month> <year> 1993. </year> <month> 29 </month>
Reference: [34] <author> Z. Segall et al. </author> <title> Fiat fault injection based automated testing environment. </title> <booktitle> In FTCS-18, </booktitle> <pages> pages 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection (e.g. [2, 35]) and simulation approaches for injecting hardware failures (e.g. [8, 16]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [4, 34] </ref>. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [3, 13, 14, 18]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [35] <author> K. G. Shin and Y. H. Lee. </author> <title> Measurement and application of fault latency. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-35(4):370-375, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: A recent survey paper [5] presents several fault injection studies, and also discusses several different tools that facilitate the application of fault injection in various environments. Hardware fault-injection (e.g. <ref> [2, 35] </ref>) and simulation approaches for injecting hardware failures (e.g. [8, 16]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [4, 34].
Reference: [36] <author> P. Verissimo, L. Rodrigues, and M. Batista. </author> <title> Amp: A highly parallel atomic multicast protocol. </title> <booktitle> In Proc. of ACM SIGCOMM, </booktitle> <pages> pages 83-93, </pages> <address> Austin, TX, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in [1] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol <ref> [36] </ref> in the presence of faults. Other work can be characterized as deterministic approaches to test generation [3, 13]. In [13], the evaluation of design fault coverage is based on a stochastic model.
Reference: [37] <author> M. Yuhara, B. N. Bershad, C. Maeda, and J. E. B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. 30 </note>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [29], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [25], and the Mach Packet Filter (MPF) <ref> [37] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
References-found: 37

