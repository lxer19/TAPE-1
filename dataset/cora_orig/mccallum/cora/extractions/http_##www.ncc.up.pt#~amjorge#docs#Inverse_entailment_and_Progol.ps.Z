URL: http://www.ncc.up.pt/~amjorge/docs/Inverse_entailment_and_Progol.ps.Z
Refering-URL: http://www.ncc.up.pt/~amjorge/Personal_Repository.html
Root-URL: 
Title: Inverse entailment and Progol  
Author: Stephen MUGGLETON 
Keyword: Learning, logic programming, induction, predicate invention, inverse resolution, inverse entailment, information compression.  
Address: Wolfson Building, Parks Road, Oxford, OX1 3QD, United Kingdom.  
Affiliation: Oxford University Computing Laboratory,  
Abstract: This paper firstly provides a re-appraisal of the development of techniques for inverting deduction, secondly introduces Mode-Directed Inverse Entailment (MDIE) as a generalisation and enhancement of previous approaches and thirdly describes an implementation of MDIE in the Progol system. Progol is implemented in C and available by anonymous ftp. The re-assessment of previous techniques in terms of inverse entailment leads to new results for learning from positive data and inverting implication between pairs of clauses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bain and S. Muggleton. </author> <title> Non-monotonic learning. </title> <editor> In D. Michie, editor, </editor> <booktitle> Machine Intelligence 12. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1991. </year>
Reference-contexts: Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution [37, 61, 54], inversion of clausal implication [22, 14, 40], predicate invention [36], closed-world specialisation <ref> [1] </ref> and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. <p> Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. <p> (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. C 0 also contains the infinite sequence of atoms member (3; [3; 3]), member (3; [3; 3; 3]); : : :. <p> any (Term) list ([]) list ([HjT ]) list (T ) T erm = T erm reverse ([]; []) append ([]; X; X) append ([HjT ]; L1; [HjL2]) append (T; L1; L2) Let h = 30 and i = 3 and let the example be as below. e = reverse (<ref> [1] </ref>; [1]) 20 C 0 0 k 0 reverse (D; E) fD=A; E=Ag 1 reverse (D; D) fD=Ag 1 2 ; 2 reverse (D; E) D = [F jG]; reverse (G; G) 6 reverse (D; E) D = [F jG]; reverse (G; H) [ fH=Cg 6 reverse (D; E) D = [F <p> ; 2 reverse (D; E) D = [F jG]; reverse (G; G) 6 reverse (D; E) D = [F jG]; reverse (G; H) [ fH=Cg 6 reverse (D; E) D = [F jG] 7 In this case ? i is as follows. ? i = reverse (A; A) A = <ref> [1] </ref>; A = [BjC]; B = 1; C = []; reverse (C; C); append (C; [B]; A) Let hC 0 ; 0 ; k 0 i be in (h2; ;; 1i).
Reference: [2] <author> I. Bratko, S. Muggleton, and A. Varsek. </author> <title> Learning qualitative models of dynamic systems. </title> <booktitle> In Proceedings of the Eighth International Machine Learning Workshop, </booktitle> <address> San Mateo, Ca, 1991. </address> <publisher> Morgan-Kaufmann. </publisher>
Reference-contexts: However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. <p> Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; [1; 2; 3]). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; <ref> [2; 3] </ref>) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. <p> Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. <p> (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. C 0 also contains the infinite sequence of atoms member (3; [3; 3]), member (3; [3; 3; 3]); : : :. <p> Negative examples were used to stop rlggs becoming over-general. 5.2 Application experience Golem was the first ILP system to be applied to a wide variety of real-world applications. These included the construction of a satellite fault diagnosis model [8], the design of a qualitative physics model <ref> [2] </ref>, finite-element mesh design [6], protein secondary structure prediction [39] and structure-activity prediction for drugs [18]. In the qualitative physics domain Golem was hampered in requiring a large tabulation of the QSIM simulator. The determinacy restriction was inappropriate in the finite element mesh design application.
Reference: [3] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. <p> However, this solution is neither restricted to single-depth resolutions, nor is the clause cardinality finitely bounded. Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. <p> Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; [1; 2; 3]). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; <ref> [2; 3] </ref>) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. <p> Example 6 Recursive list membership. Let C = member (X; [XjY ]) and D = member (2; [1; 2; 3]). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; <ref> [3] </ref>) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. <p> Let C = member (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. <p> (X; [XjY ]) and D = member (2; <ref> [1; 2; 3] </ref>). C ^ D j= member (2; [1; 2; 3]) j= member (1; [1; 2; 3]) j= member (2; [2; 3]) j= member (3; [3]) j= ::: Though the clause C 0 = member (2; [1; 2; 3]) member (1; [1; 2; 3]); :: maintains Relationship (3), there are at least 3 derivation steps to D. C 0 is -subsumed by all single-step resolution solutions. C 0 also contains the infinite sequence of atoms member (3; [3; 3]), member (3; [3; 3; 3]); : : :. <p> C 0 is -subsumed by all single-step resolution solutions. C 0 also contains the infinite sequence of atoms member (3; <ref> [3; 3] </ref>), member (3; [3; 3; 3]); : : :. Owing to the weak completeness results for the Duce inductive inference rules (Section 3.2) only absorption and intra-construction were implemented in Cigol. 4.1 Compression Like Duce, Cigol used Occam compression (Definition 4) to guide the choice of inverse resolution steps. <p> C 0 is -subsumed by all single-step resolution solutions. C 0 also contains the infinite sequence of atoms member (3; [3; 3]), member (3; <ref> [3; 3; 3] </ref>); : : :. Owing to the weak completeness results for the Duce inductive inference rules (Section 3.2) only absorption and intra-construction were implemented in Cigol. 4.1 Compression Like Duce, Cigol used Occam compression (Definition 4) to guide the choice of inverse resolution steps. <p> Headless clause constraints can be learned from ground headless unit clauses by use of a modeh for the predicate `false'. An example of this can be found in the Progol4.1 distribution dataset `animals.pl'. The standard library of primitive predicates described in Clocksin and Mellish <ref> [3] </ref> is built into Progol and available as background knowledge.
Reference: [4] <author> W. Cohen. </author> <title> Learnability of restricted logic programs. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Proceedings of the 3rd International Workshop on Inductive Logic Programming (Technical report IJS-DP-6707 of the Josef Stefan Institute, Ljubljana, Slovenia), </booktitle> <pages> pages 41-72, </pages> <year> 1993. </year>
Reference-contexts: However, the association of probability values with hypotheses requires the assumption of a prior probability distribution over the hypothesis language. Occam's razor can be taken as an instance of a distribution which assigns higher prior probability to simpler hypotheses. It has been shown <ref> [4] </ref> that without such distributional assumptions the class of all logic programs is not even PAC-predictable. On the other hand, it has recently been demonstrated [42] that the class of all time-bounded logic programs is polynomial-time learnable (U-learnable) under fairly broad families of prior probability distributions.
Reference: [5] <author> D. Conklin and I. Witten. </author> <title> Complexity-based induction. </title> <type> Technical report, </type> <institution> Dept. of Computing and Information Science, Queen's University, Kingston, </institution> <address> Ontario, Canada, </address> <year> 1992. </year>
Reference-contexts: Learning from positive examples. In [30] it was noted that the compression measure used in Cigol did not allow learning from only positive data since the simplest possible hypothesis, say 8X:p (X), will always be consistent. Alternative compression measures were suggested in <ref> [30, 44, 5, 9] </ref>. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses [55, 54, 31, 13].
Reference: [6] <author> B. Dolsak and S. Muggleton. </author> <title> The application of Inductive Logic Programming to finite element mesh design. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Inductive Logic Programming. </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1992. </year>
Reference-contexts: These included the construction of a satellite fault diagnosis model [8], the design of a qualitative physics model [2], finite-element mesh design <ref> [6] </ref>, protein secondary structure prediction [39] and structure-activity prediction for drugs [18]. In the qualitative physics domain Golem was hampered in requiring a large tabulation of the QSIM simulator. The determinacy restriction was inappropriate in the finite element mesh design application.
Reference: [7] <author> R. Dormer. </author> <title> An Inductive Logic Programming Implementation. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <year> 1993. </year>
Reference-contexts: It is shown in [20] that Shapiro's is not complete. It is also shown that there does not exist which is finite, proper and complete. Redundancy of refinement operators is investigated in <ref> [12, 7] </ref>. The refinement operator is redundant if and only if there exist clauses C; C 0 ; D in L such that D 2 (C) and D 2 (C 0 ) and C is not an alphabetic variant of C 0 .
Reference: [8] <author> C. Feng. </author> <title> Inducing temporal fault dignostic rules from a qualitative model. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Inductive Logic Programming. </booktitle> <publisher> Academic Press, </publisher> <address> Lon-don, </address> <year> 1992. </year>
Reference-contexts: Negative examples were used to stop rlggs becoming over-general. 5.2 Application experience Golem was the first ILP system to be applied to a wide variety of real-world applications. These included the construction of a satellite fault diagnosis model <ref> [8] </ref>, the design of a qualitative physics model [2], finite-element mesh design [6], protein secondary structure prediction [39] and structure-activity prediction for drugs [18]. In the qualitative physics domain Golem was hampered in requiring a large tabulation of the QSIM simulator.
Reference: [9] <author> D.A. Gillies. </author> <title> Confirmation theory and machine learning. </title> <booktitle> In Proceedings of the Second Inductive Logic Programming Workshop, </booktitle> <address> Tokyo, 1992. </address> <publisher> ICOT TM-1182. </publisher>
Reference-contexts: Learning from positive examples. In [30] it was noted that the compression measure used in Cigol did not allow learning from only positive data since the simplest possible hypothesis, say 8X:p (X), will always be consistent. Alternative compression measures were suggested in <ref> [30, 44, 5, 9] </ref>. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses [55, 54, 31, 13].
Reference: [10] <author> E.M. Gold. </author> <title> Language identification in the limit. </title> <journal> Information and Control, </journal> <volume> 10 </volume> <pages> 447-474, </pages> <year> 1967. </year>
Reference-contexts: Let E X be a set of m examples of H. Let jHj and jEj be the number of bits required to encode H and E. The positive-only 4 At first sight, this theorem appears to clash with the fundamental result of Gold <ref> [10] </ref> that not even the regular languages can be identified in the limit from positive data alone.
Reference: [11] <author> G. Gottlob. </author> <title> Subsumption and implication. </title> <journal> Information Processing Letters, </journal> <volume> 24(2) </volume> <pages> 109-111, </pages> <year> 1987. </year>
Reference-contexts: This is known as the problem of inverting implication between clauses. The inability to invert implication between clauses limits the completeness of inverse resolution and rlggs since -subsumption is used in place of clause implication in both. Gottlob <ref> [11] </ref> proves a number of properties concerning implication between clauses. The following lemma is notable. Lemma 12 Gottlob's lemma. Let C; D be two non-tautological clauses.
Reference: [12] <author> M. Grobelnik. </author> <title> Markus an optimized model inference system. </title> <booktitle> In Proceedings of the ECAI workshop on Logical Approaches to Machine Learning, </booktitle> <year> 1992. </year> <month> 30 </month>
Reference-contexts: It is shown in [20] that Shapiro's is not complete. It is also shown that there does not exist which is finite, proper and complete. Redundancy of refinement operators is investigated in <ref> [12, 7] </ref>. The refinement operator is redundant if and only if there exist clauses C; C 0 ; D in L such that D 2 (C) and D 2 (C 0 ) and C is not an alphabetic variant of C 0 .
Reference: [13] <author> P. Idestam-Almquist. </author> <title> Learning missing clauses by inverse resolution. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 610-617, </pages> <address> Tokyo, 1992. </address> <publisher> ICOT. </publisher>
Reference-contexts: Alternative compression measures were suggested in [30, 44, 5, 9]. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses <ref> [55, 54, 31, 13] </ref>. Clause saturation is closely related to the techniques of inverse entailment described in Section 7. However, since saturation is based on inverting resolution proof steps, it cannot deal with built-in predicates. Nevertheless, the interpretations of such predicates can be computed by calling C functions.
Reference: [14] <author> P. Idestam-Almquist. </author> <title> Generalisation of Clauses. </title> <type> PhD thesis, </type> <institution> Stockholm University, </institution> <year> 1993. </year>
Reference-contexts: Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution [37, 61, 54], inversion of clausal implication <ref> [22, 14, 40] </ref>, predicate invention [36], closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> Attempts were made to a) extend inverse resolution [33] and b) use a mixture of inverse resolution and lgg <ref> [14] </ref> to solve the problem. The extended inverse resolution method in [33] suffers from the same problems of non-determinacy as Cigol. Idestam-Almquist's [14] use of lgg suffers from the standard problem of intractably large clauses (see Section 5). <p> Attempts were made to a) extend inverse resolution [33] and b) use a mixture of inverse resolution and lgg <ref> [14] </ref> to solve the problem. The extended inverse resolution method in [33] suffers from the same problems of non-determinacy as Cigol. Idestam-Almquist's [14] use of lgg suffers from the standard problem of intractably large clauses (see Section 5). Both approaches are incomplete for inverting implication, though Idestam-Almquist's technique is complete for a restricted form of entailment called T - implication.
Reference: [15] <author> W.S. Jevons. </author> <title> On the mechanisation of deductive inference. </title> <journal> Philosophical Transactions of the Royal Society of London, </journal> <volume> 160 </volume> <pages> 497-518, 1870. </pages>
Reference-contexts: on inverting resolution in propositional logic was first discussed in [32] (originally a technical report from 1987) as an analysis of the inductive inference rules within the Duce system [29]. 2 George Boole's algebraic approach to deduction inspired Jevons to use truth-functional tabulations to design and build a logical calculator <ref> [15] </ref>. Jevons' mechanical Organon is complete for deciding satisfiability of propositional clauses in 4 variables, and can be found in the Museum of Scientific Instruments in Oxford. 3 3.1 Inductive inference rules Duce had six inductive inference rules. Four of these were concerned with definite clause propositional logic.
Reference: [16] <author> W.S. Jevons. </author> <title> The Principles of Science: a Treatise on Logic and Scientific Method. </title> <publisher> Macmillan, </publisher> <address> London, </address> <month> 1874. </month>
Reference-contexts: be avoided by dropping all but the restriction that B, H and E are arbitrary logic programs. 3 Inverse resolution in propositional logic The idea of carrying out induction by inverting deduction was first investigated in depth mathematically by the 19th century political economist and philosopher of science Stanley Jevons <ref> [16] </ref> 2 . Jevons solved by tabulation the "Inverse or Inductive Problem" involving two propositional symbols. The following quote from Jevons' book on inductive inference [16] is both modern-sounding and relevant to the problems addressed in this paper. <p> of carrying out induction by inverting deduction was first investigated in depth mathematically by the 19th century political economist and philosopher of science Stanley Jevons <ref> [16] </ref> 2 . Jevons solved by tabulation the "Inverse or Inductive Problem" involving two propositional symbols. The following quote from Jevons' book on inductive inference [16] is both modern-sounding and relevant to the problems addressed in this paper. Induction is, in fact, the inverse operation of deduction, and cannot be conceived to exist without the corresponding operation, so that the question of relative importance cannot arise.
Reference: [17] <author> A.C. Kakas, R.A. Kowalski, and F. Toni. </author> <title> Abductive logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2, </volume> <year> 1992. </year>
Reference-contexts: dog (X), pet (X), pet (X) dog (X). anim (X). hasbeak (X) bird (X). hasbeak (tweety). hasbeak (tweety); bird (tweety); bird (X) vulture (X). vulture (tweety). white (swan1). black (swan1). black (swan1), white (swan1). sentence ([],[]). sentence ([a,a,a],[]). sentence ([a,a,a],[]) sentence ([],[]). a general form of Kakas et al's abduction <ref> [17] </ref> and is of central interest in "theory revision" (alterations in theory revision range over all definitions within a hierarchical set of predicates which reference each other).
Reference: [18] <author> R. King, S. Muggleton R. Lewis, and M. Sternberg. </author> <title> Drug design by machine learning: The use of inductive logic programming to model the structure-activity relationships of trimethoprim analogues binding to dihydrofolate reductase. </title> <booktitle> Proceedings of the National Academy of Sciences, </booktitle> <volume> 89(23), </volume> <year> 1992. </year>
Reference-contexts: These included the construction of a satellite fault diagnosis model [8], the design of a qualitative physics model [2], finite-element mesh design [6], protein secondary structure prediction [39] and structure-activity prediction for drugs <ref> [18] </ref>. In the qualitative physics domain Golem was hampered in requiring a large tabulation of the QSIM simulator. The determinacy restriction was inappropriate in the finite element mesh design application.
Reference: [19] <author> V. Krishnamurthy. </author> <title> Combinatorics: theory and applications. </title> <publisher> Ellis Horwood, </publisher> <address> Chichester, England, </address> <year> 1986. </year>
Reference-contexts: ? i there will be no element of Progol's fl containing the clause mult (U; V; W ) dec (U; X); mult (X; V; Y ); plus (Y; V; W ): 9.3 Complexity of In order to analyse the complexity of we introduce an incremental variant of the Bell number <ref> [19] </ref> from combinatorics. The mth Bell number is the number of ways that a set S of cardinality m can be partitioned into non-empty equivalence classes. Lemma 31 Number of splits of a variable.
Reference: [20] <author> P.R. van der Laag and Nienhuys-Cheng. </author> <title> Subsumption and refinement in model inference. </title> <editor> In P. Brazdil, editor, </editor> <booktitle> Proceedings of the 6th European Conference on Machine Learning, volume 667 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 95-114. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: However, he also notes that C ! D does not imply C D, as shown by the following example. Example 11 Implication and subsumption. Consider the following clauses. C = nat (s (X)) nat (X) C ! D but not C D. Although efficient methods are known <ref> [20] </ref> for enumerating every clause C which -subsumes an arbitrary clause D, this is not the case for clauses C which imply D. This is known as the problem of inverting implication between clauses. <p> It is shown in <ref> [20] </ref> that Shapiro's is not complete. It is also shown that there does not exist which is finite, proper and complete. Redundancy of refinement operators is investigated in [12, 7].
Reference: [21] <author> P.R. van der Laag and Nienhuys-Cheng. </author> <title> Existence and nonexistence of complete refinement operators. </title> <editor> In Bergadano F. and De Raedt L., editors, </editor> <booktitle> Proceedings of the 7th European Conference on Machine Learning, volume 784 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 307-322. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Also 0 (C) = fCg and D 2 i (C) if and only if there exists D 0 2 i1 (C) and D = D 0 or D 2 (D 0 ). The closure fl (C) is 0 (C) [ 1 (C) [ ::. According to <ref> [21] </ref> is complete if and only if for each D in L there is an alphabetic variant of D in fl (2). is finite if and only if for all C 2 L the cardinality of (C) is finite. is proper if and only if for each clause C and D
Reference: [22] <author> S. Lapointe and S. Matwin. Sub-unification: </author> <title> a tool for efficient induction of recursive programs. </title> <booktitle> In Proceedings of the Ninth International Machine Learning Conference, </booktitle> <address> Los Altos, 1992. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution [37, 61, 54], inversion of clausal implication <ref> [22, 14, 40] </ref>, predicate invention [36], closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> C ! D implies that C + D + and C D . In an attempt to solve the inverting implication problem Lapointe and Matwin <ref> [22] </ref> introduced sub-unification, a process of matching sub-terms in D to produce C. They demonstrate that sub-unification is able to construct recursive clauses from fewer examples than would be required by ILP systems such as Golem [38] and FOIL [49].
Reference: [23] <author> C. Lee. </author> <title> A completeness theorem and a computer program for finding theorems derivable from given axioms. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1967. </year>
Reference-contexts: Although the operations described by Lapointe and Matwin are shown to work on a number of examples it is not clear how general the mechanism is. Various general properties of implication between clauses are investigated in [33]. In particular it is shown that Lee's subsumption lemma <ref> [23] </ref> has the following corollary. Corollary 13 Implication and recursion. Let C; D be clauses.
Reference: [24] <author> M. Li and P. Vitanyi. </author> <title> An introduction to Kolmogorov complexity and its applications. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year> <month> 31 </month>
Reference-contexts: Alternative compression measures were suggested in [30, 44, 5, 9]. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle <ref> [52, 24] </ref>. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses [55, 54, 31, 13]. Clause saturation is closely related to the techniques of inverse entailment described in Section 7.
Reference: [25] <author> C.X. Ling. </author> <title> Learning the past tense of english verbs: the symbolic pattern associators vs. connectionist models. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 1 </volume> <pages> 209-229, </pages> <year> 1994. </year>
Reference-contexts: When learning from only positive data, predictive accuracy will be maximised by choosing the most general consistent hypothesis since this will always agree with new data. However, in applications such as grammar learning <ref> [25, 50] </ref>, only positive data are available, though the grammar which produces all strings is not an acceptable hypothesis. Let us then suppose a modification to the U-learning setting given in Appendix B.
Reference: [26] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: The success of the subject lies partly in the choice of the core representation language of logic programs. Least Herbrand models of logic programs <ref> [26] </ref> fit neatly with the distinction between examples and conjectured theories in inductive inference. The syntax of logic programs provides modular blocks which, when added or removed, generalise or specialise the program. Depth-bounded Prolog interpreters, used for theorem-proving, allow efficient testing of hypothesised Horn clause theories.
Reference: [27] <author> B. Meltzer. </author> <title> Power amplification for automatic theorem proving. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 5, </booktitle> <pages> pages 165-179. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year>
Reference: [28] <author> R. Michalski and J. Larson. </author> <title> Incremental generation of vl1 hypotheses: the underlying methodology and the description of program AQ11. </title> <type> ISG 83-5, </type> <institution> Computer Science Department, Univ. of Illinois at Urbana-Champaign, </institution> <year> 1980. </year>
Reference-contexts: Clearly, for tractability i; j; c must be small constants. 10.2 Cover set algorithm Progol uses a simple cover set algorithm much like that employed in Michalski's AQ family of algorithms <ref> [28] </ref>. It repeatedly generalises examples in the order found in the Progol source file and adds the generalisation to the background knowledge. Examples which are redundant relative to the background knowledge are then removed (redundancy is based on Definition 35). The cover set algorithm is given in Appendix D.3.
Reference: [29] <author> S. Muggleton. Duce, </author> <title> an oracle based approach to constructive induction. </title> <booktitle> In IJCAI-87, </booktitle> <pages> pages 287-292. </pages> <publisher> Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: Inductive inference based on inverting resolution in propositional logic was first discussed in [32] (originally a technical report from 1987) as an analysis of the inductive inference rules within the Duce system <ref> [29] </ref>. 2 George Boole's algebraic approach to deduction inspired Jevons to use truth-functional tabulations to design and build a logical calculator [15].
Reference: [30] <author> S. Muggleton. </author> <title> A strategy for constructing new predicates in first order logic. </title> <booktitle> In Proceedings of the Third European Working Session on Learning, </booktitle> <pages> pages 123-130. </pages> <publisher> Pitman, </publisher> <year> 1988. </year>
Reference-contexts: Learning from positive examples. In <ref> [30] </ref> it was noted that the compression measure used in Cigol did not allow learning from only positive data since the simplest possible hypothesis, say 8X:p (X), will always be consistent. Alternative compression measures were suggested in [30, 44, 5, 9]. <p> Learning from positive examples. In [30] it was noted that the compression measure used in Cigol did not allow learning from only positive data since the simplest possible hypothesis, say 8X:p (X), will always be consistent. Alternative compression measures were suggested in <ref> [30, 44, 5, 9] </ref>. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses [55, 54, 31, 13]. <p> This contradicts the assumption and completes the proof. 2 4 f m provides the basis for a simplified version of the compression models defined in <ref> [30, 44] </ref>. Definition 9 Positive-only compression. Let H be a wff and G be a distribution over instance space X. Let E X be a set of m examples of H. Let jHj and jEj be the number of bits required to encode H and E.
Reference: [31] <author> S. Muggleton. </author> <title> Inductive logic programming. </title> <journal> New Generation Computing, </journal> <volume> 8(4) </volume> <pages> 295-318, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Since its inception in this journal <ref> [31] </ref> Inductive Logic Programming (ILP) has grown to become a substantial sub-area of both Machine Learning and Logic Programming (see [43]). The success of the subject lies partly in the choice of the core representation language of logic programs. <p> Since algebraic inversion of resolution has a complex non-deterministic solution only a restricted form of absorption was implemented in Cigol 3 . However, 3 logiC backwards. 6 it was shown independently in <ref> [31] </ref> and [54] that there is a unique most-specific solution for `V' inductive inference rules. That is C 0 # = (D [ l) where is such that C D. Rather than inverting the equations of resolution we might consider resolution from the model-theoretic point of view. <p> Alternative compression measures were suggested in [30, 44, 5, 9]. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses <ref> [55, 54, 31, 13] </ref>. Clause saturation is closely related to the techniques of inverse entailment described in Section 7. However, since saturation is based on inverting resolution proof steps, it cannot deal with built-in predicates. Nevertheless, the interpretations of such predicates can be computed by calling C functions.
Reference: [32] <author> S. Muggleton. </author> <title> Inverting the resolution principle. </title> <booktitle> In Machine Intellience 12. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1991. </year>
Reference-contexts: Robinson [53] was later to show that deductive inference in first-order predicate calculus could be effected by a single rule of inference, that of resolution. Inductive inference based on inverting resolution in propositional logic was first discussed in <ref> [32] </ref> (originally a technical report from 1987) as an analysis of the inductive inference rules within the Duce system [29]. 2 George Boole's algebraic approach to deduction inspired Jevons to use truth-functional tabulations to design and build a logical calculator [15]. <p> I is said to be weak complete for E and H if and only if for each H H there exists E E such that E ` I H. In <ref> [32] </ref> it was shown that I consisting of only absorption and intra-construction is weak complete under particular hypothesis and example language restrictions. Definition 3 Strong completeness.
Reference: [33] <author> S. Muggleton. </author> <title> Inverting implication. </title> <booktitle> In Proceedings of the Second Inductive Logic Programming Workshop, </booktitle> <address> Tokyo, </address> <year> 1992. </year> <note> ICOT (Technical report TM-1182). </note>
Reference-contexts: Although the operations described by Lapointe and Matwin are shown to work on a number of examples it is not clear how general the mechanism is. Various general properties of implication between clauses are investigated in <ref> [33] </ref>. In particular it is shown that Lee's subsumption lemma [23] has the following corollary. Corollary 13 Implication and recursion. Let C; D be clauses. <p> Attempts were made to a) extend inverse resolution <ref> [33] </ref> and b) use a mixture of inverse resolution and lgg [14] to solve the problem. The extended inverse resolution method in [33] suffers from the same problems of non-determinacy as Cigol. Idestam-Almquist's [14] use of lgg suffers from the standard problem of intractably large clauses (see Section 5). <p> Attempts were made to a) extend inverse resolution <ref> [33] </ref> and b) use a mixture of inverse resolution and lgg [14] to solve the problem. The extended inverse resolution method in [33] suffers from the same problems of non-determinacy as Cigol. Idestam-Almquist's [14] use of lgg suffers from the standard problem of intractably large clauses (see Section 5). Both approaches are incomplete for inverting implication, though Idestam-Almquist's technique is complete for a restricted form of entailment called T - implication.
Reference: [34] <author> S. Muggleton. </author> <title> Bayesian inductive logic programming. </title> <editor> In W. Cohen and H. Hirsh, editors, </editor> <booktitle> Proceedings of the Eleventh International Machine Learning Conference, </booktitle> <pages> pages 371-379, </pages> <address> San Mateo, CA, 1994. </address> <publisher> Morgan-Kaufmann. </publisher>
Reference: [35] <author> S. Muggleton. </author> <title> Inductive logic programming: derivations, successes and shortcomings. </title> <journal> SIGART Bulletin, </journal> <volume> 5(1) </volume> <pages> 5-11, </pages> <year> 1994. </year>
Reference-contexts: In the qualitative physics domain Golem was hampered in requiring a large tabulation of the QSIM simulator. The determinacy restriction was inappropriate in the finite element mesh design application. The restrictions of Golem and other ILP algorithms are discussed in <ref> [35] </ref>. 11 Golem was also applied to various list and number-theoretic learning tasks involving the construction of recursive theories. Learning recursive theories was awkward using Golem partly because intensional hypothesised base cases could not be used to augment the entirely extensional background knowledge.
Reference: [36] <author> S. Muggleton. </author> <title> Predicate invention and utilization. </title> <journal> Journal of Experimental and Theoretical Artificial Intelligence, </journal> <volume> 6(1) </volume> <pages> 127-130, </pages> <year> 1994. </year>
Reference-contexts: Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution [37, 61, 54], inversion of clausal implication [22, 14, 40], predicate invention <ref> [36] </ref>, closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas.
Reference: [37] <author> S. Muggleton and W. Buntine. </author> <title> Machine invention of first-order predicates by inverting resolution. </title> <booktitle> In Proceedings of the Fifth International Conference on Machine Learning, </booktitle> <pages> pages 339-352. </pages> <publisher> Kaufmann, </publisher> <year> 1988. </year> <month> 32 </month>
Reference-contexts: Most importantly, Turing-equivalence of logic programs is allowing a broader range of Machine Learning applications in ILP than was possible with more restrictive representations. Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution <ref> [37, 61, 54] </ref>, inversion of clausal implication [22, 14, 40], predicate invention [36], closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> When jEj jHj = 0 then p (HjE) = p (EjE). 2 The hypothesis with maximum posterior probability (H max ) has maximum expected predictive accuracy. 4 Inverse resolution in first-order logic Inverse resolution was lifted to first-order predicate calculus in <ref> [37] </ref>. This involved algebraic inversion of the equations of resolution below. D = (C [ C 0 ) 0 clauses on the arms.
Reference: [38] <author> S. Muggleton and C. Feng. </author> <title> Efficient induction of logic programs. </title> <booktitle> In Proceed--ings of the First Conference on Algorithmic Learning Theory, </booktitle> <address> Tokyo, 1990. </address> <publisher> Ohmsha. </publisher>
Reference-contexts: In an attempt to solve the inverting implication problem Lapointe and Matwin [22] introduced sub-unification, a process of matching sub-terms in D to produce C. They demonstrate that sub-unification is able to construct recursive clauses from fewer examples than would be required by ILP systems such as Golem <ref> [38] </ref> and FOIL [49]. Although the operations described by Lapointe and Matwin are shown to work on a number of examples it is not clear how general the mechanism is. Various general properties of implication between clauses are investigated in [33].
Reference: [39] <author> S. Muggleton, R. King, and M. Sternberg. </author> <title> Protein secondary structure prediction using logic-based machine learning. </title> <journal> Protein Engineering, </journal> <volume> 5(7) </volume> <pages> 647-657, </pages> <year> 1992. </year>
Reference-contexts: These included the construction of a satellite fault diagnosis model [8], the design of a qualitative physics model [2], finite-element mesh design [6], protein secondary structure prediction <ref> [39] </ref> and structure-activity prediction for drugs [18]. In the qualitative physics domain Golem was hampered in requiring a large tabulation of the QSIM simulator. The determinacy restriction was inappropriate in the finite element mesh design application.
Reference: [40] <author> S. </author> <title> Muggleton and C.D. Page. Self-saturation of definite clauses. </title> <editor> In S. Wro-bel, editor, </editor> <booktitle> Proceedings of the Fourth International Inductive Logic Programming Workshop, </booktitle> <pages> pages 161-174. </pages> <institution> Gesellschaft fur Mathematik und Datenver-arbeitung MBH, </institution> <year> 1994. </year> <note> GMD-Studien Nr 237. </note>
Reference-contexts: Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution [37, 61, 54], inversion of clausal implication <ref> [22, 14, 40] </ref>, predicate invention [36], closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> Idestam-Almquist's [14] use of lgg suffers from the standard problem of intractably large clauses (see Section 5). Both approaches are incomplete for inverting implication, though Idestam-Almquist's technique is complete for a restricted form of entailment called T - implication. In <ref> [40] </ref> it is shown that for certain recursive clauses D all the clauses C which imply D also -subsume a logically equivalent clause D 0 . Up to renaming of variables every clause D has at most one most specific form of D 0 in the - subsumption lattice. <p> Up to renaming of variables every clause D has at most one most specific form of D 0 in the - subsumption lattice. D 0 is called the self-saturation of D. The self-saturation of D in Example 11 is simply C [ D. However, it is shown in <ref> [40] </ref> that there exist definite clauses which have no finite self-saturation. 6.1 Inverting entailment between clauses This section gives a complete and efficient method for inverting implication between function-free definite clauses. The techniques used are based on inverting entailment using the deduction theorem. First we define definite sub-saturants.
Reference: [41] <author> S. Muggleton and D. </author> <title> Page. Beyond first-order learning: inductive learning with higher-order logic. </title> <type> Technical Report PRG-TR-13-94, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <year> 1994. </year>
Reference-contexts: A description of Progol doing qualitative regression can be found in <ref> [41] </ref>. Qualitative regression is carried out by using mode declarations to define a family of 3 different functions (linear, polynomial in one term and exponential) and using these in competition to fit the data. The equation solver is supplied as user-defined background knowledge.
Reference: [42] <author> S. Muggleton and D. </author> <title> Page. A learnability model for universal representations. </title> <type> Technical Report PRG-TR-3-94, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <year> 1994. </year>
Reference-contexts: Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution [37, 61, 54], inversion of clausal implication [22, 14, 40], predicate invention [36], closed-world specialisation [1] and U-learnability <ref> [42] </ref>. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> Occam's razor can be taken as an instance of a distribution which assigns higher prior probability to simpler hypotheses. It has been shown [4] that without such distributional assumptions the class of all logic programs is not even PAC-predictable. On the other hand, it has recently been demonstrated <ref> [42] </ref> that the class of all time-bounded logic programs is polynomial-time learnable (U-learnable) under fairly broad families of prior probability distributions. Appendix B gives more details of the relationship between data, posterior probabilities and U-learnability. <p> Then according to Shannon and Weaver [56] jP j is log 2 F (P ) and Note that since this is an exponential-decay distribution, in the situation in which the learner knows F (P ), the results in <ref> [42] </ref> show that the class of all time-bounded logic programs are polynomial-time learnable (U-learnable). However, note also that if the teacher's prior is known to the learner then on average theories chosen by the teacher have extremely low information content.
Reference: [43] <author> S. Muggleton and L. De Raedt. </author> <title> Inductive logic programming: Theory and methods. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:629-679, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Since its inception in this journal [31] Inductive Logic Programming (ILP) has grown to become a substantial sub-area of both Machine Learning and Logic Programming (see <ref> [43] </ref>). The success of the subject lies partly in the choice of the core representation language of logic programs. Least Herbrand models of logic programs [26] fit neatly with the distinction between examples and conjectured theories in inductive inference.
Reference: [44] <author> S. Muggleton, A. Srinivasan, and M. Bain. </author> <title> Compression, significance and accuracy. </title> <editor> In D. Sleeman and P. Edwards, editors, </editor> <booktitle> Proceedings of the Ninth International Machine Learning Conference, </booktitle> <pages> pages 338-347, </pages> <address> San Mateo, CA, 1992. </address> <publisher> Morgan-Kaufmann. </publisher>
Reference-contexts: Learning from positive examples. In [30] it was noted that the compression measure used in Cigol did not allow learning from only positive data since the simplest possible hypothesis, say 8X:p (X), will always be consistent. Alternative compression measures were suggested in <ref> [30, 44, 5, 9] </ref>. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses [55, 54, 31, 13]. <p> This contradicts the assumption and completes the proof. 2 4 f m provides the basis for a simplified version of the compression models defined in <ref> [30, 44] </ref>. Definition 9 Positive-only compression. Let H be a wff and G be a distribution over instance space X. Let E X be a set of m examples of H. Let jHj and jEj be the number of bits required to encode H and E.
Reference: [45] <author> N.J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Tioga, </publisher> <address> Palo Alto, CA, </address> <year> 1980. </year>
Reference-contexts: The details of this decoding process are omitted. 10 Searching the subsumption lattice To search the subsumption lattice Progol applies an A fl -like algorithm <ref> [45] </ref> to find a clause C, 2 C ? i , with maximal Occam compression (Definition 4). 23 The encoding measure is the total number of atom occurrences in a reduced logic program. Logic programs are reduced by eliminating redundant clauses. Definition 35 Redundant clauses.
Reference: [46] <author> G.D. Plotkin. </author> <title> A note on inductive generalisation. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 5, </booktitle> <pages> pages 153-163. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year>
Reference: [47] <author> G.D. Plotkin. </author> <title> Automatic Methods of Inductive Inference. </title> <type> PhD thesis, </type> <institution> Edin-burgh University, </institution> <month> August </month> <year> 1971. </year>
Reference-contexts: This approach to learning from positive data has the following problems. 1. Arbitrary background knowledge. Plotkin <ref> [47] </ref> showed that with unrestricted definite clause background knowledge B there may not be any finite rlgg B (E). 2. Extensional background knowledge. Suppose B and E consist of n and m ground unit clauses respectively. <p> Learning recursive theories was awkward using Golem partly because intensional hypothesised base cases could not be used to augment the entirely extensional background knowledge. Also Golem's search was through the subsumption lattice, rather than the lattice of implication between clauses. 6 Implication between clauses In <ref> [47] </ref> Plotkin noted that if clause C -subsumes clause D (or C D) then C ! D. However, he also notes that C ! D does not imply C D, as shown by the following example. Example 11 Implication and subsumption. Consider the following clauses.
Reference: [48] <author> R.J. Popplestone. </author> <title> An experiment in automatic induction. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 5, </booktitle> <pages> pages 203-215. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year>
Reference: [49] <author> J.R. Quinlan. </author> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5 </volume> <pages> 239-266, </pages> <year> 1990. </year>
Reference-contexts: They demonstrate that sub-unification is able to construct recursive clauses from fewer examples than would be required by ILP systems such as Golem [38] and FOIL <ref> [49] </ref>. Although the operations described by Lapointe and Matwin are shown to work on a number of examples it is not clear how general the mechanism is. Various general properties of implication between clauses are investigated in [33]. <p> This sub-lattice is bounded both above and below. The search is therefore better constrained than other general to specific searches, such as those in MIS [57] and FOIL <ref> [49] </ref>, in which the sub-lattice being searched is not bounded below. For the purposes of searching a lattice of clauses ordered by -subsumption Shapiro [57] introduced the concept of refinement operators. Suppose L is a (potentially infinite) set of clauses and C is an element of L. <p> The numbers of clauses in E + , E , B and H are also given for each dataset. Note that the datasets `animals', `exp', `family' and `set' involve learning a series of related predicates. These runtimes are comparable with those of FOIL <ref> [49] </ref>, despite the fact that FOIL does incomplete heuristic search to find clauses. FOIL also uses extensional background knowledge rather than the intensional background knowledge of Progol. 13 Conclusion This paper traces the line of development followed by the author in investigating induction as the inverse of deduction.
Reference: [50] <author> J.R. Quinlan. </author> <title> Past tenses of verbs and first-order learning. </title> <editor> In Zhang C., J. Debenham, and Lukose D., editors, </editor> <booktitle> Proceedings of the 7th Australian Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 13-20, </pages> <address> Singapore, 1993. </address> <publisher> World Scientific. </publisher>
Reference-contexts: When learning from only positive data, predictive accuracy will be maximised by choosing the most general consistent hypothesis since this will always agree with new data. However, in applications such as grammar learning <ref> [25, 50] </ref>, only positive data are available, though the grammar which produces all strings is not an acceptable hypothesis. Let us then suppose a modification to the U-learning setting given in Appendix B.
Reference: [51] <author> J.C. Reynolds. </author> <title> Transformational systems and the algebraic structure of atomic formulas. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 5, </booktitle> <pages> pages 135-151. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year>
Reference: [52] <author> J. Rissanen. </author> <title> Modeling by Shortest Data Description. </title> <journal> Automatica, </journal> <volume> 14 </volume> <pages> 465-471, </pages> <year> 1978. </year>
Reference-contexts: Alternative compression measures were suggested in [30, 44, 5, 9]. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle <ref> [52, 24] </ref>. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses [55, 54, 31, 13]. Clause saturation is closely related to the techniques of inverse entailment described in Section 7.
Reference: [53] <author> J.A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> JACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <month> January </month> <year> 1965. </year>
Reference-contexts: At the time of Jevons logicians, not yet persuaded of Boole's algebraic approach to logic, employed an array of inference rules derived from Aristotelian syllogisms. Robinson <ref> [53] </ref> was later to show that deductive inference in first-order predicate calculus could be effected by a single rule of inference, that of resolution.
Reference: [54] <author> C. </author> <title> Rouveirol. Extensions of inversion of resolution applied to theory completion. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Inductive Logic Programming. </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1992. </year>
Reference-contexts: Most importantly, Turing-equivalence of logic programs is allowing a broader range of Machine Learning applications in ILP than was possible with more restrictive representations. Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution <ref> [37, 61, 54] </ref>, inversion of clausal implication [22, 14, 40], predicate invention [36], closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas. <p> Since algebraic inversion of resolution has a complex non-deterministic solution only a restricted form of absorption was implemented in Cigol 3 . However, 3 logiC backwards. 6 it was shown independently in [31] and <ref> [54] </ref> that there is a unique most-specific solution for `V' inductive inference rules. That is C 0 # = (D [ l) where is such that C D. Rather than inverting the equations of resolution we might consider resolution from the model-theoretic point of view. <p> Alternative compression measures were suggested in [30, 44, 5, 9]. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses <ref> [55, 54, 31, 13] </ref>. Clause saturation is closely related to the techniques of inverse entailment described in Section 7. However, since saturation is based on inverting resolution proof steps, it cannot deal with built-in predicates. Nevertheless, the interpretations of such predicates can be computed by calling C functions. <p> C = f (K; N ) d (K; L); f (L; M ); m (K; M; N ): The following example demonstrates how clauses with function symbols, such as those in Example 11, can be dealt with as though they were function-free by using flattening <ref> [54] </ref>. Example 18 Flattening and inverse implication. The clause D = nat (s (s (X))) nat (X) can be flattened to the function-free clause D 0 = nat (V ) s (V; W ); s (W; X); nat (X) where s is defined as s (X; s (X)).
Reference: [55] <author> C. Rouveirol and J-F. Puget. </author> <title> A simple and general solution for inverting resolution. </title> <booktitle> In EWSL-89, </booktitle> <pages> pages 201-210, </pages> <address> London, 1989. </address> <publisher> Pitman. </publisher>
Reference-contexts: Alternative compression measures were suggested in [30, 44, 5, 9]. These measures are closely allied to Rissanen's Minimal De scription Length (MDL) Principle [52, 24]. The first problem was addressed by considering the inversion of multiple resolution steps by saturating clauses <ref> [55, 54, 31, 13] </ref>. Clause saturation is closely related to the techniques of inverse entailment described in Section 7. However, since saturation is based on inverting resolution proof steps, it cannot deal with built-in predicates. Nevertheless, the interpretations of such predicates can be computed by calling C functions.
Reference: [56] <author> C.E. Shannon and W. Weaver. </author> <title> The Mathematical Theory of Communication. </title> <publisher> University of Illinois Press, </publisher> <address> Urbana, </address> <year> 1963. </year>
Reference-contexts: F (P ) expresses the relative frequency with which the teacher chooses P as target concept. Assume the learner knows F (P ) and uses it as a prior distribution on H. Then according to Shannon and Weaver <ref> [56] </ref> jP j is log 2 F (P ) and Note that since this is an exponential-decay distribution, in the situation in which the learner knows F (P ), the results in [42] show that the class of all time-bounded logic programs are polynomial-time learnable (U-learnable).
Reference: [57] <author> E.Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <year> 1983. </year>
Reference-contexts: This sub-lattice is bounded both above and below. The search is therefore better constrained than other general to specific searches, such as those in MIS <ref> [57] </ref> and FOIL [49], in which the sub-lattice being searched is not bounded below. For the purposes of searching a lattice of clauses ordered by -subsumption Shapiro [57] introduced the concept of refinement operators. Suppose L is a (potentially infinite) set of clauses and C is an element of L. <p> The search is therefore better constrained than other general to specific searches, such as those in MIS <ref> [57] </ref> and FOIL [49], in which the sub-lattice being searched is not bounded below. For the purposes of searching a lattice of clauses ordered by -subsumption Shapiro [57] introduced the concept of refinement operators. Suppose L is a (potentially infinite) set of clauses and C is an element of L.
Reference: [58] <author> A. Srinivasan, S.H. Muggleton, R.D. King, and M.J.E. Sternberg. Mutagen-esis: </author> <title> Ilp experiments in a non-determinate biological domain. </title> <editor> In S. Wrobel, editor, </editor> <booktitle> Proceedings of the Fourth International Inductive Logic Programming Workshop. </booktitle> <institution> Gesellschaft fur Mathematik und Datenverarbeitung MBH, </institution> <year> 1994. </year> <note> GMD-Studien Nr 237. </note>
Reference-contexts: This allows implementation of low-level operations such as depth-bounding of the theorem prover and rapid virtual assertion and retraction of clauses into the clause set. 12 Results Results of a series of experiments involving Progol in learning to predict mu-tagenic molecules can be found in <ref> [58, 59, 60] </ref>. A description of Progol doing qualitative regression can be found in [41]. Qualitative regression is carried out by using mode declarations to define a family of 3 different functions (linear, polynomial in one term and exponential) and using these in competition to fit the data.
Reference: [59] <author> A. Srinivasan, S.H. Muggleton, R.D. King, and M.J.E. Sternberg. </author> <title> The effect of background knowledge in inductive logic programming: a case study. </title> <type> Technical Report PRG-TR-9-95, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <year> 1995. </year>
Reference-contexts: This allows implementation of low-level operations such as depth-bounding of the theorem prover and rapid virtual assertion and retraction of clauses into the clause set. 12 Results Results of a series of experiments involving Progol in learning to predict mu-tagenic molecules can be found in <ref> [58, 59, 60] </ref>. A description of Progol doing qualitative regression can be found in [41]. Qualitative regression is carried out by using mode declarations to define a family of 3 different functions (linear, polynomial in one term and exponential) and using these in competition to fit the data.
Reference: [60] <author> A. Srinivasan, S.H. Muggleton, R.D. King, and M.J.E. Sternberg. </author> <title> Theories for mutagenicity: a study of first-order and feature based induction. </title> <type> Technical Report PRG-TR-8-95, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <year> 1995. </year>
Reference-contexts: This allows implementation of low-level operations such as depth-bounding of the theorem prover and rapid virtual assertion and retraction of clauses into the clause set. 12 Results Results of a series of experiments involving Progol in learning to predict mu-tagenic molecules can be found in <ref> [58, 59, 60] </ref>. A description of Progol doing qualitative regression can be found in [41]. Qualitative regression is carried out by using mode declarations to define a family of 3 different functions (linear, polynomial in one term and exponential) and using these in competition to fit the data.
Reference: [61] <author> R. Wirth. </author> <title> Completing logic programs by inverse resolution. </title> <booktitle> In EWSL-89, </booktitle> <pages> pages 239-250, </pages> <address> London, 1989. </address> <publisher> Pitman. </publisher> <pages> 34 </pages>
Reference-contexts: Most importantly, Turing-equivalence of logic programs is allowing a broader range of Machine Learning applications in ILP than was possible with more restrictive representations. Recent research in ILP has spawned a variety of new theoretical topics. These include the problem of inverting resolution <ref> [37, 61, 54] </ref>, inversion of clausal implication [22, 14, 40], predicate invention [36], closed-world specialisation [1] and U-learnability [42]. As with any subject, the diversity of sub-topics can be better understood by following the development of a particular line of ideas.
References-found: 61

