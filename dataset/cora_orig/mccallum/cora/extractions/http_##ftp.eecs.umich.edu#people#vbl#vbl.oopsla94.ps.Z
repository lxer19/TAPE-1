URL: http://ftp.eecs.umich.edu/people/vbl/vbl.oopsla94.ps.Z
Refering-URL: http://ftp.eecs.umich.edu/people/vbl/
Root-URL: http://www.eecs.umich.edu
Email: fvbl,kgshing@eecs.umich.edu  
Title: Combining Contracts and Exemplar-Based Programming for Class Hiding and Customization  
Author: Victor B. Lortz Kang G. Shin 
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: For performance reasons, client applications often need to influence the implementation strategies of libraries whose services they use. If an object-oriented library contains multiple service classes customized for different usage patterns, applications can influence service implementations by instantiating the customized classes that match their needs. However, with many similar service classes, it can be difficult for applications to determine which classes to instantiate. Choosing the wrong class can result in very subtle errors since a customized class might use optimizations that work only over a restricted domain. In this paper, we show how client-side software contracts and exemplar-based class factories can be used to construct customized server objects. By expressing priorities and requirements in contracts, clients can delegate service class selection to the library and thereby avoid implicit dependencies on the library implementation. We have used this approach in the implementation of a real-time database system. fl The work reported in this paper was supported in part by the Office of Naval Research under grant N00014-92-J-1080, by the National Science Foundation Industry/University Cooperative Research Center at the Univ. of Michigan, and by the NSF under grant DDM-9313222. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Kiczales and J. Lamping, </author> <title> "Operating systems: Why object-oriented?," </title> <booktitle> in Proc. of IWOOOS, </booktitle> <pages> pp. 25-30, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: For example, an LRU paging strategy for a virtual memory system is optimal for clients that exhibit locality of reference and suboptimal for those that do not. Kiczales and Lamping call the problem of choosing a service implementation strategy a mapping dilemma <ref> [1] </ref>. Since the service provider cannot control client usage patterns, successful resolution of mapping dilemmas requires prior knowledge of client needs. In some cases, it is possible to collect historical usage patterns on a per-client basis and use that data to predict future usage. <p> Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols <ref> [1] </ref>. The techniques we describe in this paper com bine meta-protocols with class hiding through ab-stract class factories. Gamma et al. [8, 9] discuss using abstract class factories to hide concrete classes from applications.
Reference: [2] <author> V. B. Lortz, </author> <title> An Object-Oriented Real-Time Database System for Multiprocessors, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: This provides good incre-mentality since only those service methods that are being customized need to be reimplemented. Exemplar-based server construction also improves encapsulation by hiding part of the library's internal class hierarchy from applications. In our real-time database research <ref> [2] </ref>, we use this exemplar-based technique to customize database services according to the real-time and semantic characteristics of applications. The remainder of this paper is organized as follows. Section 2 discusses our use of contracts to communicate semantic information needed for server construction. <p> Section 3 describes our use of exemplar objects in more detail. For example, an application might declare a persistent array object as follows: MdartsArray&lt;int&gt; parts list ("parts_list", "persistent; range_checked; sparse; size=1000"); The prefix MDARTS is the acronym for our real-time database system <ref> [2] </ref>. In this case, the abstract factory class MdartsArray is specified along with the database name of the object and its contract string. Some constraints, such as "persistent", might be supported only by specialized subclasses that access a disk-based database system.
Reference: [3] <author> R. Wirfs-Brock and B. Wilkerson, </author> <title> "Object-oriented design: A responsibility-driven approach," </title> <booktitle> in Proc. of OOPSLA, </booktitle> <pages> pp. 71-75, </pages> <month> Oc-tober </month> <year> 1989. </year>
Reference-contexts: The software entities could be two interacting processes, an application and a software library, a server object and a client object or application, or a base class and a derived class. Wirfs-Brock et al. <ref> [3] </ref> and Meyer [4] consider software contracts to be properties of server classes. Since the server defines the contract, there is no way for an application to add clauses or establish its own contracts.
Reference: [4] <author> B. Meyer, </author> <title> "Applying "design by contract"," </title> <journal> IEEE Computer, </journal> <volume> vol. 25, no. 10, </volume> <pages> pp. 40-51, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The software entities could be two interacting processes, an application and a software library, a server object and a client object or application, or a base class and a derived class. Wirfs-Brock et al. [3] and Meyer <ref> [4] </ref> consider software contracts to be properties of server classes. Since the server defines the contract, there is no way for an application to add clauses or establish its own contracts. With our technique, applications can create client-side contracts to specify requirements and communicate application-dependent semantic information to servers.
Reference: [5] <author> R. N. Chang and C. V. Ravishankar, </author> <title> "A service acquisition mechanism for the client/service model in cygnus," </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 90-97, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: When contracts are used to select and configure the implementations of server objects, the contract becomes a declarative meta-protocol for those services. Selecting servers through contracts resembles service specification and acquisition in distributed computing systems <ref> [5, 6] </ref>, except our server objects are much lighter-weight and are constructed from local libraries rather than remote server processes.
Reference: [6] <author> K. Ravindran and K. K. Ramakrishnan, </author> <title> "A model for naming for fine-grained service specification in distributed systems," </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 98-105, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: When contracts are used to select and configure the implementations of server objects, the contract becomes a declarative meta-protocol for those services. Selecting servers through contracts resembles service specification and acquisition in distributed computing systems <ref> [5, 6] </ref>, except our server objects are much lighter-weight and are constructed from local libraries rather than remote server processes.
Reference: [7] <author> R. Helm and Y. S. Maarek, </author> <title> "Integrating in-formation retrieval and domain specific approaches for browsing and retrieval in object-oriented class libraries," </title> <booktitle> in Proc. of OOPSLA, </booktitle> <pages> pp. 47-61, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: If the single writer restriction is violated by the application, as could happen accidentally since the restriction is only implicit in the service implementation, the object is likely to become corrupted. Class browsing tools are often proposed to assist application writers in selecting classes <ref> [7] </ref>, but these tools expose the full complexity of the class hierarchy and do not enforce any semantic restrictions. Furthermore, applications that explicitly use concrete service classes in a customized class hier-archy can become dependent on the internal class structure of the library.
Reference: [8] <author> T. Eggenschwiler and E. Gamma, "ET++swapsmanager: </author> <title> Using object technology in the financial engineering domain," </title> <booktitle> in Proc. of OOPSLA, </booktitle> <pages> pp. 166-177, </pages> <year> 1992. </year>
Reference-contexts: The contract string is supplied as a parameter to an abstract service class constructor function. The abstract service class is equivalent to the "abstract factory" of <ref> [8, 9] </ref>. Multiple classes corresponding to concrete implementations of the abstract service can exist within the library, but applications need never know which concrete class will be used. <p> Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols [1]. The techniques we describe in this paper com bine meta-protocols with class hiding through ab-stract class factories. Gamma et al. <ref> [8, 9] </ref> discuss using abstract class factories to hide concrete classes from applications. We expand on this idea by showing how exemplar-based server construction allows applications to extend factories without modifying existing code.
Reference: [9] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlis-sides, </author> <title> "Design patterns: Abstraction and reuse of object-oriented design," </title> <booktitle> in Proc. of ECOOP, </booktitle> <pages> pp. 406-431, </pages> <year> 1993. </year>
Reference-contexts: The contract string is supplied as a parameter to an abstract service class constructor function. The abstract service class is equivalent to the "abstract factory" of <ref> [8, 9] </ref>. Multiple classes corresponding to concrete implementations of the abstract service can exist within the library, but applications need never know which concrete class will be used. <p> Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols [1]. The techniques we describe in this paper com bine meta-protocols with class hiding through ab-stract class factories. Gamma et al. <ref> [8, 9] </ref> discuss using abstract class factories to hide concrete classes from applications. We expand on this idea by showing how exemplar-based server construction allows applications to extend factories without modifying existing code.
Reference: [10] <author> K. Vidyasankar, </author> <title> "Concurrent reading while writing revisited," </title> <booktitle> Distributed Computing, </booktitle> <pages> pp. 81-85, </pages> <year> 1990. </year>
Reference-contexts: By declaring these hints, the application is expressing a willingness to abide by whatever restrictions are implicit in the hints. For example, single-writer concurrency control protocols can reduce locking delays compared to more general concurrency control methods <ref> [10] </ref>. However, a server object cannot control application behavior to ensure that the single-writer restriction is followed. With contracts, a single-writer service class would not be chosen unless the application explicitly indicated in the contract that it would avoid concurrent updates (by specifying a concur-rency constraint such as "exclusive update").
Reference: [11] <author> D. Ungar and R. B. Smith, </author> <title> "Self: The power of simplicity," </title> <booktitle> in Proc. of OOPSLA, </booktitle> <pages> pp. 227-242, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: For example, the Self language uses exemplars and delegation to dispense with classes altogether <ref> [11] </ref>. While exemplars in Self form the basis of a complete programming paradigm, exemplars can be useful in a class-based object-oriented context as well [12]. Coplien illustrates the use of exemplar-based programming in C++ [13].
Reference: [12] <author> W. R. LaLonde, D. A. Thomas, and J. R. Pugh, </author> <title> "An exemplar based smalltalk," </title> <booktitle> in Proc. of OOPSLA, </booktitle> <pages> pp. 322-330, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: For example, the Self language uses exemplars and delegation to dispense with classes altogether [11]. While exemplars in Self form the basis of a complete programming paradigm, exemplars can be useful in a class-based object-oriented context as well <ref> [12] </ref>. Coplien illustrates the use of exemplar-based programming in C++ [13]. In our implementation, we combine software contracts with Coplien's autonomous generic exemplar idiom (in which exemplars register themselves with a base class and object construction requests iterate over the exemplars).
Reference: [13] <author> J. O. Coplien, </author> <title> Advanced C++ Programming Styles and Idioms, </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: For example, the Self language uses exemplars and delegation to dispense with classes altogether [11]. While exemplars in Self form the basis of a complete programming paradigm, exemplars can be useful in a class-based object-oriented context as well [12]. Coplien illustrates the use of exemplar-based programming in C++ <ref> [13] </ref>. In our implementation, we combine software contracts with Coplien's autonomous generic exemplar idiom (in which exemplars register themselves with a base class and object construction requests iterate over the exemplars). Exemplars are special objects that are prototype representatives of an entire class. <p> By declaring a static pointer to the exemplar in the service class, C++ static member initialization can be used to automatically construct and register exactly one exemplar per class. This technique is borrowed from Coplien <ref> [13] </ref>. class MdartsArray: public Md Base f public: static MdartsArray fl make ( const char fl contract) f return (MdartsArray fl) ConstructServer (contract); g // public MdartsArray methods here ... protected: // constructor for array object MdartsArray (int s) f sdatap = shared memory malloc ( sizeof (shared data)+(s1)flsizeof (int) );
Reference: [14] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young, </author> <title> "Mach: A new kernel foundation for UNIX development," </title> <booktitle> in Proc. Summer 1986 USENIX Technical Conference and Exhibition, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Mach allows users to implement and replace some of the basic services of the operating system <ref> [14] </ref>. In [15], Krueger et al. present an approach to application-specific virtual memory management. Jones discusses tools for replacing system services by redirecting system calls to user code [16]. Anderson argues that operating systems should place as much functionality as possible under application control [17].
Reference: [15] <author> K. Krueger, D. Loftesness, A. Vahdat, and T. Anderson, </author> <title> "Tools for the development of application-specific virtual memory management," </title> <booktitle> in Proc. of OOPSLA, </booktitle> <pages> pp. 48-64, </pages> <year> 1993. </year>
Reference-contexts: Mach allows users to implement and replace some of the basic services of the operating system [14]. In <ref> [15] </ref>, Krueger et al. present an approach to application-specific virtual memory management. Jones discusses tools for replacing system services by redirecting system calls to user code [16]. Anderson argues that operating systems should place as much functionality as possible under application control [17].
Reference: [16] <author> M. B. Jones, </author> <title> "Transparently interposing user code at the system interface," </title> <booktitle> in Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 98-103, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Mach allows users to implement and replace some of the basic services of the operating system [14]. In [15], Krueger et al. present an approach to application-specific virtual memory management. Jones discusses tools for replacing system services by redirecting system calls to user code <ref> [16] </ref>. Anderson argues that operating systems should place as much functionality as possible under application control [17]. The trend toward application customization can also be seen in the domains of compilers (e.g., Open C++ [18], parallelizing compilers [19], and Traces in Scheme [20]), and window systems (Silica [21]).
Reference: [17] <author> T. E. Anderson, </author> <title> "The case for application-specific operating systems," </title> <booktitle> in Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 92-94, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In [15], Krueger et al. present an approach to application-specific virtual memory management. Jones discusses tools for replacing system services by redirecting system calls to user code [16]. Anderson argues that operating systems should place as much functionality as possible under application control <ref> [17] </ref>. The trend toward application customization can also be seen in the domains of compilers (e.g., Open C++ [18], parallelizing compilers [19], and Traces in Scheme [20]), and window systems (Silica [21]).
Reference: [18] <author> S. Chiba and T. Masuda, </author> <title> "Designing an extensible distributed language with a meta-level architecture," </title> <booktitle> in Proc. of ECOOP, </booktitle> <pages> pp. 482-501, </pages> <year> 1993. </year>
Reference-contexts: Jones discusses tools for replacing system services by redirecting system calls to user code [16]. Anderson argues that operating systems should place as much functionality as possible under application control [17]. The trend toward application customization can also be seen in the domains of compilers (e.g., Open C++ <ref> [18] </ref>, parallelizing compilers [19], and Traces in Scheme [20]), and window systems (Silica [21]). Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols [1].
Reference: [19] <author> L. H. R. Jr., </author> <title> "A study on the viability of a production-quality metaobject protocol-based statically parallelizing compiler," </title> <booktitle> in Proc. of the Int'l Workshop on New Models for Software Architecture, </booktitle> <pages> pp. 107-112, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Anderson argues that operating systems should place as much functionality as possible under application control [17]. The trend toward application customization can also be seen in the domains of compilers (e.g., Open C++ [18], parallelizing compilers <ref> [19] </ref>, and Traces in Scheme [20]), and window systems (Silica [21]). Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols [1]. The techniques we describe in this paper com bine meta-protocols with class hiding through ab-stract class factories.
Reference: [20] <author> G. Kiczales, </author> <title> "Traces (a cut at the "make isn't generic") problem," </title> <booktitle> in Proc. of the Int'l Symposium on Object Technologies for Advanced Software, </booktitle> <pages> pp. 27-43, </pages> <year> 1993. </year>
Reference-contexts: Anderson argues that operating systems should place as much functionality as possible under application control [17]. The trend toward application customization can also be seen in the domains of compilers (e.g., Open C++ [18], parallelizing compilers [19], and Traces in Scheme <ref> [20] </ref>), and window systems (Silica [21]). Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols [1]. The techniques we describe in this paper com bine meta-protocols with class hiding through ab-stract class factories.
Reference: [21] <author> R. Rao, </author> <title> "Implementational reflection in silica," </title> <booktitle> in Proc. of ECOOP, </booktitle> <pages> pp. 251-267, </pages> <year> 1991. </year>
Reference-contexts: Anderson argues that operating systems should place as much functionality as possible under application control [17]. The trend toward application customization can also be seen in the domains of compilers (e.g., Open C++ [18], parallelizing compilers [19], and Traces in Scheme [20]), and window systems (Silica <ref> [21] </ref>). Kiczales and Lamping examine the trend toward service customization and identify the key themes of mapping dilemmas and meta-protocols [1]. The techniques we describe in this paper com bine meta-protocols with class hiding through ab-stract class factories.
References-found: 21

