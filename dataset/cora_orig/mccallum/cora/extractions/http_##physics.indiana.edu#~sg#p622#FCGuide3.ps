URL: http://physics.indiana.edu/~sg/p622/FCGuide3.ps
Refering-URL: http://physics.indiana.edu/~sg/p621.html
Root-URL: http://www.cs.indiana.edu
Title: Guide to FeynCalc 1.0  
Author: Rolf Mertig Physikalisches 
Date: March 1992  
Address: Am Hubland Universitat Wurzburg 8700 Wurzburg, Germany  
Affiliation: Institut  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. K ublbeck, M. B ohm and A. </author> <title> Denner, </title> <journal> Comp. Phys. Comm. </journal> <volume> 60 (1990) 165. </volume>
Reference-contexts: The basic idea of FeynCalc is to provide convenient tools for radiative corrections in the standard model. The input for FeynCalc, the analytical expressions for the diagrams, can be entered by hand or can be taken directly from the output of another package, FeynArts <ref> [1] </ref>, which produces all diagrams for a given process. The user can provide certain additional information about the process under consideration, i.e., the kinematics and the choice of the standard matrix elements may be defined. <p> Thus FeynCalcForm is similar to the Mathematica OutputForm, but specialized to the new objects defined in FeynCalc. Enter a scalar product p q. This is the FeynCalcForm. In <ref> [1] </ref>:= ScalarProduct [p, q] Out [1]= p.q This is the input for g -. In [2]:= MetricTensor [mu, nu] Out [2]= g [mu, nu] A metric tensor g fffi in D dimensions is entered in this way. The dimension is displayed as an index. <p> Thus FeynCalcForm is similar to the Mathematica OutputForm, but specialized to the new objects defined in FeynCalc. Enter a scalar product p q. This is the FeynCalcForm. In <ref> [1] </ref>:= ScalarProduct [p, q] Out [1]= p.q This is the input for g -. In [2]:= MetricTensor [mu, nu] Out [2]= g [mu, nu] A metric tensor g fffi in D dimensions is entered in this way. The dimension is displayed as an index. <p> The . may also be used as a delimiter instead of the , within the functions DiracMatrix, DiracSlash and GellMannMatrix. In the output with FeynCalcForm the . as noncommutative multiplication operator is suppressed. This is how you enter (p= + q= + m) fl . In <ref> [1] </ref>:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . <p> In the output with FeynCalcForm the . as noncommutative multiplication operator is suppressed. This is how you enter (p= + q= + m) fl . In <ref> [1] </ref>:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix [ro, 5, mu, 6, al, 7] Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. <p> Contract [expr] contracts double Lorentz indices The function for contraction of tensors. Contract g fffi p fi . In <ref> [1] </ref>:= Contract [MetricTensor [a, b] FourVector [p, b]] Out [1]= p [a] Contract q ff (p q) ff . In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . <p> Contract [expr] contracts double Lorentz indices The function for contraction of tensors. Contract g fffi p fi . In <ref> [1] </ref>:= Contract [MetricTensor [a, b] FourVector [p, b]] Out [1]= p [a] Contract q ff (p q) ff . In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . <p> As an example expand (a + b) (c 2d). In <ref> [1] </ref>:= ExpandScalarProduct [ScalarProduct [a + b, c - 2 d]] Out [1]= a.c - 2 a.d + b.c - 2 b.d Consider again q ff (p q) ff . In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. <p> As an example expand (a + b) (c 2d). In <ref> [1] </ref>:= ExpandScalarProduct [ScalarProduct [a + b, c - 2 d]] Out [1]= a.c - 2 a.d + b.c - 2 b.d Consider again q ff (p q) ff . In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. <p> Both functions take as expr either subsequent DiracMatrix or DiracSlash separated by "," or any expression with "." as the noncommutative multiplication operator between Dirac matrices or Dirac slashes. Order the product fl fi fl ff ! 2 g fffi fl ff fl fi . In <ref> [1] </ref>:= DiracOrder [DiracMatrix [be, al]] Out [1]= 2 g [al, be] - ga [al] ga [be] Anticommute back to fl fi fl ff . <p> Order the product fl fi fl ff ! 2 g fffi fl ff fl fi . In <ref> [1] </ref>:= DiracOrder [DiracMatrix [be, al]] Out [1]= 2 g [al, be] - ga [al] ga [be] Anticommute back to fl fi fl ff . In [2]:= DiracOrder [%, -be, al-] Out [2]= ga [be] ga [al] 2 Elementary Calculations 15 Simplifications like fl fl p= p= = 4 p 2 are built in. <p> DiracSimplify applies the Dirac equation. The result of DiracSimplify is not canonically ordered. This is fl fl = D. In <ref> [1] </ref>:= DiracSimplify [DiracMatrix [mu, mu, Dimension -&gt; D]] Out [1]= D Here the Kahane algorithm is used. fl fl - fl fl fl = 2 fl fl fl - . <p> DiracSimplify applies the Dirac equation. The result of DiracSimplify is not canonically ordered. This is fl fl = D. In <ref> [1] </ref>:= DiracSimplify [DiracMatrix [mu, mu, Dimension -&gt; D]] Out [1]= D Here the Kahane algorithm is used. fl fl - fl fl fl = 2 fl fl fl - . <p> The default of DiracTrace is not to evaluate Dirac traces directly. For direct calculation the function Tr should be used. tr ( fl ff fl fi ) = 4 g fffi . In <ref> [1] </ref>:= Tr [DiracMatrix [al, be]] Out [1]= 4 g [al, be] 4 f (a d)(b c) (a c)(b d) + (a b)(c d) g. <p> The default of DiracTrace is not to evaluate Dirac traces directly. For direct calculation the function Tr should be used. tr ( fl ff fl fi ) = 4 g fffi . In <ref> [1] </ref>:= Tr [DiracMatrix [al, be]] Out [1]= 4 g [al, be] 4 f (a d)(b c) (a c)(b d) + (a b)(c d) g. <p> The trace T (10) is a verification of the result given in [8]. This is a little program defining T. The dimension of each particular Dirac matrix is set to d 4. The timings are also displayed in FeynCalcForm, which yields more usual time units. In <ref> [1] </ref>:= T [n _ ] := T [n] = Block [-gammas, calc-, gammas = Dot @@ Table [ DiracMatrix [a [i], Dimension -&gt; (d - 4)], -i, 1, n- ]; calc = Timing [ Tr [ gammas . gammas ] ]; Print ["Time = ", calc [[1]]//FeynCalcForm ]; calc [[2]]]; This <p> The Cvitanovic algorithm [6] is im-plemened similar to [7]. Traces with no free color indices are always evaluated to a number. Otherwise only special cases are simplified. tr ( a b ) = 2 ffi ab . In <ref> [1] </ref>:= GellMannTrace [GellMannMatrix [a, b]] Out [1]= 2 d [a, b] tr (3 a b a b ) = 32. In [2]:= GellMannTrace [ 3 GellMannMatrix [a, b, a, b] ] Out [2]= -32 tr ( a b c ) stays as it is. <p> The Cvitanovic algorithm [6] is im-plemened similar to [7]. Traces with no free color indices are always evaluated to a number. Otherwise only special cases are simplified. tr ( a b ) = 2 ffi ab . In <ref> [1] </ref>:= GellMannTrace [GellMannMatrix [a, b]] Out [1]= 2 d [a, b] tr (3 a b a b ) = 32. In [2]:= GellMannTrace [ 3 GellMannMatrix [a, b, a, b] ] Out [2]= -32 tr ( a b c ) stays as it is. <p> The convention for the scalar arguments is pi0 = p 2 i pij = (p i p j ) 2 ; mi2 = m 2 The B 0 function is symmetric in the mass arguments. In <ref> [1] </ref>:= B0 [s, mz2, mw2] Taking the derivative with respect to the first argument yields DB0. In [2]:= D [%, s] The tensor-integral decomposition is automatically done by FeynCalc when calculating one-loop amplitudes, but extra functions are provided to reduce the coefficients of the tensor-integral decomposition. <p> In [5]:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). In [6]:= PaVe <ref> [1, -pp-, -m12, m22-] </ref> Out [6]= B1 [pp, m12, m22] Coefficient functions of metric tensors have two 0 indices for each g -. <p> In <ref> [1] </ref>:= B1 [pp, m12, m22] -B0 [pp, m12, m22] 2 - Arguments of two-point functions with head Small are replaced by 0, if the other arguments have no head Small and are nonzero. A0 [0] and A0 [Small [m]^2] simplify to 0. <p> This is the result in HoldForm. In [5]:= c12 = PaVeReduce [ PaVe <ref> [1, 2, -s, m2, m2-, -m2, m2, M2-] </ref>, IsolateHead -&gt; K ] Out [5]= K [11] The FullForm of the assignment to c12 is HoldForm [K [11]]. <p> In [8]:= d122 = PaVeReduce [ PaVe <ref> [1, 2, 2, -Small [ME2] </ref>, MW2, MW2, Small [ME2], S, T-, -0, Small [ME2], 0, Small [ME2]-], Mandelstam -&gt; -S, T, U, 2 MW2-, IsolateHead -&gt; F ] Out [8]= F [17] Write the result out into a Fortran file. <p> It may be given in four dimensions. OneLoop performs the necessary extension to D dimensions automatically. This is A 0 = i 2 (2 ) 4D R corresponding to a tadpole diagram. The scaling variable is suppressed in FeynCalc. In <ref> [1] </ref>:= -I/Pi^2 FeynAmpDenominator [ PropagatorDenominator [q, m]] -I 2 2 2 This calculates the tadpole diagram. In [2]:= OneLoop [q, %] 2 2 2 2 For a most compact result the factoring option of OneLoop is set. For a description of all options of OneLoop see Section 3.3.4. <p> The 3 One-Loop Calculations 27 last possibility is usually preferable, since the choices of FeynCalc for the standard matrix elements may have physical significance only by accident. j , generated by FeynArts. This factors the result. In <ref> [1] </ref>:= SetOptions [OneLoop, Factoring -&gt; True]; This defines a function for abbreviation purposes: g c i = g i ! + . Set the p i on-shell and (p 1 p 2 ) = k 2 =2, where k denotes the momentum of the W. <p> In [3]:= Wff1 = OneLoop [ q, I/(2 Pi)^4 FeynAmpDenominator [ PropagatorDenominator [q, M], PropagatorDenominator [q + p1], PropagatorDenominator [q - p2] ] * Spinor [p1] . DiracMatrix [nu] . gc <ref> [1] </ref> . DiracSlash [q + p1] . DiracSlash [Polarization [k]] . gc [3] . DiracSlash [q - p2] . DiracMatrix [nu] . gc [2] . <p> DiracSlash [Polarization [k]] . gc [3] . DiracSlash [q - p2] . DiracMatrix [nu] . gc [2] . Spinor [p2] ] /. (M^2) -&gt; M2 Out [3]= ((1 - 2 B0 [0, 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe <ref> [1, -k2, 0, 0-, -0, 0, M2-] </ref> + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs <p> Spinor [p2] ] /. (M^2) -&gt; M2 Out [3]= ((1 - 2 B0 [0, 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g <ref> [1, +] </ref> g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. <p> C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g <ref> [1, -] </ref> g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. <p> The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. In [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g <ref> [1, +] </ref> g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract <p> In [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g <ref> [1, -] </ref> g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. <p> In [5]:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA <ref> [1] </ref>, MA [2] - In this way you can generate a Fortran file. With replacements you can adapt the result to your other Fortran code. <p> The other definitions are convenient abbreviations: R for the right-handed projection operator fl 6 , L for the left-handed projection operator fl 7 , short mnemonic functions like G, FV and feynden stand for metric tensors, four-vectors and denominators of propagators. In <ref> [1] </ref>:= (R = DiracMatrix [6]; L = DiracMatrix [7]; ScalarProduct [p1, p1] = ScalarProduct [p2, p2] = 0; ScalarProduct [p1, p2] = k2/2 ; SetOptions [ OneLoop, Factoring -&gt; True, FormatType -&gt; FortranForm, ReduceToScalars -&gt; True, WriteOut-&gt;True, FinalSubstitutions -&gt; -g [i _ , "+"] -&gt; gp [i], g [i _ , <p> In [3]:= Wff2 = OneLoop [wff2, q, I/(2 Pi)^4 * feynden [-q, 0-, -q + p1, M1-, -q - p2, M2-] * Spinor [p1] . DiracMatrix [nu] . (g <ref> [1, "-"] </ref> L + g [1, "+"] R) . DiracSlash [-q] . DiracMatrix [ro] . (g [2, "-"] L + g [2, "+"] R) . <p> In [3]:= Wff2 = OneLoop [wff2, q, I/(2 Pi)^4 * feynden [-q, 0-, -q + p1, M1-, -q - p2, M2-] * Spinor [p1] . DiracMatrix [nu] . (g [1, "-"] L + g <ref> [1, "+"] </ref> R) . DiracSlash [-q] . DiracMatrix [ro] . (g [2, "-"] L + g [2, "+"] R) . <p> K (241) = K (235)*MBM (0,1) + K (236)*MBM (0,2) + - K (239)*MBM (2,1) + K (240)*MBM (2,2) K (242) = 2*ALP4PI*FLUFAC*K (241) EEZHBOXES = K (242) Fortran output file "eezhb.for" generated by OneLoopSum for e + e ! ZH. 36 Guide to FeynCalc 1.0 K <ref> [1] </ref> = 2*MH2 - MZ2 K [3] = 1 - 2*SW2 K [5] = MH2 + 2*MZ2 K [7] = MH2 - 3*MZ2 K [9] = 2*MH2^2 + 4*MH2*MZ2 + MZ2^2 K [11] = MH2 - 7*MZ2 K [13] = 3*MH2 - 2*MZ2 K [15] = 2*MW2 - MZ2 K [17] <p> C0 [S, Small [ME2], Small [ME2], MW2, MW2, 0] K [54] = B0 [T, 0, MZ2] K [56] = B0 [T, 0, MW2] K [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM <ref> [0, 1] </ref> + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM [1, 2] + HoldForm [K [239]]*MBM [2, 1] + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for <p> B0 [T, 0, MZ2] K [56] = B0 [T, 0, MW2] K [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM <ref> [1, 1] </ref> + HoldForm [K [238]]*MBM [1, 2] + HoldForm [K [239]]*MBM [2, 1] + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 Miscellaneous Functions 37 4 Miscellaneous Functions <p> = B0 [T, 0, MW2] K [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM <ref> [1, 2] </ref> + HoldForm [K [239]]*MBM [2, 1] + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 Miscellaneous Functions 37 4 Miscellaneous Functions 4.1 Functions for Polynomial Manipulations Unfortunately <p> [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM [1, 2] + HoldForm [K [239]]*MBM <ref> [2, 1] </ref> + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 Miscellaneous Functions 37 4 Miscellaneous Functions 4.1 Functions for Polynomial Manipulations Unfortunately the built-in Mathematica 2.0 functions Factor, <p> This collects f [x] and p [y]. The default setting is not to expand terms like (b 2)d. In <ref> [1] </ref>:= Collect2 [ (b - 2) d f [x] + f [x] + c p [y] + p [y], -f, y-] Out [1]= (1 + (-2 + b) d) f [x] + (1 + c) p [y] With the setting ProductExpand -&gt; True the product 3 (s + m 2 ) <p> This collects f [x] and p [y]. The default setting is not to expand terms like (b 2)d. In <ref> [1] </ref>:= Collect2 [ (b - 2) d f [x] + f [x] + c p [y] + p [y], -f, y-] Out [1]= (1 + (-2 + b) d) f [x] + (1 + c) p [y] With the setting ProductExpand -&gt; True the product 3 (s + m 2 ) gets expanded. <p> Isolate with one argument introduces a single K [i] as abbreviation. In <ref> [1] </ref>:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K [2] replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] <p> Isolate with one argument introduces a single K [i] as abbreviation. In <ref> [1] </ref>:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K [2] replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that <p> Isolate with one argument introduces a single K [i] as abbreviation. In <ref> [1] </ref>:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K [2] replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K <p> Isolate with one argument introduces a single K [i] as abbreviation. In <ref> [1] </ref>:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K [2] replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. <p> In <ref> [1] </ref>:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K [2] replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. <p> = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K <ref> [1] </ref> + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + <p> d) f + e, f] Out [2]= e + f K <ref> [1] </ref> + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. <p> + f K <ref> [1] </ref> + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. <p> In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K <ref> [1] </ref>]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. <p> In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K <ref> [1] </ref>]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. In [5]:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a <p> f K <ref> [1] </ref> + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. In [5]:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a [z] F [2] With the help of an additional function it is easy to introduce identical abbreviations for each subsum. This trick of selectively substituting functions for sums is also quite useful in special reordering of polynomials. <p> In [6]:= ( und [x __ ] := Isolate [Plus [x], IsolateHead -&gt; H]/; FreeQ2 [-x-, -a, d-]; (a [z] (b + c (y + z)) + d [z] (y + z))/. Plus -&gt; und /. und -&gt; Plus ) Here it is clear that H <ref> [1] </ref> = (y + z) is part of H [2]. In [7]:= ReleaseHold [%] Out [7]= (y + z) d [z] + a [z] (b + c H [1]) Decreasing the option IsolateSplit significantly forces Isolate to use more than one L for a - b - c - d - <p> Plus -&gt; und /. und -&gt; Plus ) Here it is clear that H <ref> [1] </ref> = (y + z) is part of H [2]. In [7]:= ReleaseHold [%] Out [7]= (y + z) d [z] + a [z] (b + c H [1]) Decreasing the option IsolateSplit significantly forces Isolate to use more than one L for a - b - c - d - e. <p> In [8]:= Isolate [ a - b - c - d - e, IsolateHead -&gt; L, IsolateSplit -&gt; 15 ] Out [8]= L [2] This shows the values of the L. In [9]:= -L [2], L <ref> [1] </ref>- Out [9]= --c - d - e + L [1], a b The importance of Isolate is significant, since it gives you a means to handle very big expressions. <p> In [8]:= Isolate [ a - b - c - d - e, IsolateHead -&gt; L, IsolateSplit -&gt; 15 ] Out [8]= L [2] This shows the values of the L. In [9]:= -L [2], L <ref> [1] </ref>- Out [9]= --c - d - e + L [1], a b The importance of Isolate is significant, since it gives you a means to handle very big expressions. <p> NumericalFactor [expr] gives the numerical factor of expr PartitHead [expr, h] returns a list a, h [b]- with a free of expressions with head h, and h [b] having head h Three useful functions. FreeQ2 is an extension of FreeQ, allowing a list as second argument. In <ref> [1] </ref>:= FreeQ2 [M^2 + m^2 B0 [pp, m1, m2], -M, B0-] Out [1]= False This gives the numerical factor of the expression. In [2]:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. <p> FreeQ2 is an extension of FreeQ, allowing a list as second argument. In <ref> [1] </ref>:= FreeQ2 [M^2 + m^2 B0 [pp, m1, m2], -M, B0-] Out [1]= False This gives the numerical factor of the expression. In [2]:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. <p> The reasons to include these interface abilities are to utilize the Fortran optimization possibility of Maple and the excellent package Gentran for Fortran code generation. Create a test polynomial. In <ref> [1] </ref>:= tpol = z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K [2] The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - <p> The reasons to include these interface abilities are to utilize the Fortran optimization possibility of Maple and the excellent package Gentran for Fortran code generation. Create a test polynomial. In <ref> [1] </ref>:= tpol = z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K [2] The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This <p> In <ref> [1] </ref>:= tpol = z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K [2] The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. <p> + f [x] (a - b), f]] Out <ref> [1] </ref>= z + K [2] The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. <p> This is " - (p + q) = " - (p+q) . In <ref> [1] </ref>:= Contract [ LeviCivita [m, n, r, s] FourVector [p + q,s] ] Out [1]= eps [m, n, r, p + q] In this way linearity is enforced: " - (p+q) = " - p + " - q . <p> This is " - (p + q) = " - (p+q) . In <ref> [1] </ref>:= Contract [ LeviCivita [m, n, r, s] FourVector [p + q,s] ] Out [1]= eps [m, n, r, p + q] In this way linearity is enforced: " - (p+q) = " - p + " - q . <p> This is the polarization sum for massive bosons: " " fl - = g - + k k -=k 2 . In <ref> [1] </ref>:= PolarizationSum [mu, nu, k] k [mu] k [nu] k.k Here the polarization sum for gluons is given; with external momentum n = p 1 p 2 . <p> This is an easy example of simplifications done by TrickMandelstam. In <ref> [1] </ref>:= TrickMandelstam [(s + t - u) (2 mw2 - t - u), -s, t, u, 2 mw2-] 4 Miscellaneous Functions 43 The result is always given in a factorized form. <p> With the default setting of PaVeOrder a canonical ordering is chosen. It is sufficient to supply a subset of the arguments. In <ref> [1] </ref>:= PaVeOrder [D0 [me2, me2, mw2, mw2, t, s, me2, 0, me2, 0], PaVeOrderList -&gt; -me2, me2, 0, 0-] Out [1]= D0 [me2, s, mw2, t, mw2, me2, me2, 0, 0, me2] This interchanges the f and e. <p> With the default setting of PaVeOrder a canonical ordering is chosen. It is sufficient to supply a subset of the arguments. In <ref> [1] </ref>:= PaVeOrder [D0 [me2, me2, mw2, mw2, t, s, me2, 0, me2, 0], PaVeOrderList -&gt; -me2, me2, 0, 0-] Out [1]= D0 [me2, s, mw2, t, mw2, me2, me2, 0, 0, me2] This interchanges the f and e. <p> Clear $PrePrint. In <ref> [1] </ref>:= $PrePrint=. This is the internal representation of a fl in four dimensions. In [2]:= DiracMatrix [mu] Out [2]= DiracGamma [LorentzIndex [mu]] Here is a fl ff in D dimensions. <p> If you want to change the default setting of BreitMaison you must set it before loading FeynCalc. In the following example the automatic loading of FeynCalc from the init.m file has been turned off. Set the variable $BreitMaison before loading FeynCalc. In <ref> [1] </ref>:= $BreitMaison = True Out [1]= True Loading FeynCalc. In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In [3]:= DiracMatrix [5] . <p> If you want to change the default setting of BreitMaison you must set it before loading FeynCalc. In the following example the automatic loading of FeynCalc from the init.m file has been turned off. Set the variable $BreitMaison before loading FeynCalc. In <ref> [1] </ref>:= $BreitMaison = True Out [1]= True Loading FeynCalc. In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In [3]:= DiracMatrix [5] . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes.
Reference: [2] <author> A. Denner, </author> <title> Techniques for the Calculation of Electroweak Radiative Corrections at the One-Loop Level and Results for W-Physics at LEP200, </title> <note> to appear in Fortschritte der Physik 1992, 41 and references therein. </note>
Reference-contexts: With an appropiate option setting this polynomial is directly converted to an optimized Fortran file. The computational methods and algorithms implemented in FeynCalc can be found in <ref> [2] </ref> and [3], where further references are given. FeynCalc provides also calculator-type like features. You enter a Dirac trace in a very similar notation you use by hand and get back an answer, suitable for further manipulation with Mathematica or ready to translate into Fortran. <p> Thus FeynCalcForm is similar to the Mathematica OutputForm, but specialized to the new objects defined in FeynCalc. Enter a scalar product p q. This is the FeynCalcForm. In [1]:= ScalarProduct [p, q] Out [1]= p.q This is the input for g -. In <ref> [2] </ref>:= MetricTensor [mu, nu] Out [2]= g [mu, nu] A metric tensor g fffi in D dimensions is entered in this way. The dimension is displayed as an index. <p> Thus FeynCalcForm is similar to the Mathematica OutputForm, but specialized to the new objects defined in FeynCalc. Enter a scalar product p q. This is the FeynCalcForm. In [1]:= ScalarProduct [p, q] Out [1]= p.q This is the input for g -. In <ref> [2] </ref>:= MetricTensor [mu, nu] Out [2]= g [mu, nu] A metric tensor g fffi in D dimensions is entered in this way. The dimension is displayed as an index. <p> This is how you enter (p= + q= + m) fl . In [1]:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In <ref> [2] </ref>:= DiracMatrix [ro, 5, mu, 6, al, 7] Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> In [1]:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In <ref> [2] </ref>:= DiracMatrix [ro, 5, mu, 6, al, 7] Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> Contract [expr] contracts double Lorentz indices The function for contraction of tensors. Contract g fffi p fi . In [1]:= Contract [MetricTensor [a, b] FourVector [p, b]] Out [1]= p [a] Contract q ff (p q) ff . In <ref> [2] </ref>:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . In [3]:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. <p> Contract g fffi p fi . In [1]:= Contract [MetricTensor [a, b] FourVector [p, b]] Out [1]= p [a] Contract q ff (p q) ff . In <ref> [2] </ref>:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . In [3]:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. <p> As an example expand (a + b) (c 2d). In [1]:= ExpandScalarProduct [ScalarProduct [a + b, c - 2 d]] Out [1]= a.c - 2 a.d + b.c - 2 b.d Consider again q ff (p q) ff . In <ref> [2] </ref>:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. In [3]:= ExpandScalarProduct [%] Out [3]= p.q - q.q This is how you can substitute q 2 ! 0 afterwards. In [4]:= % /. <p> In [1]:= ExpandScalarProduct [ScalarProduct [a + b, c - 2 d]] Out [1]= a.c - 2 a.d + b.c - 2 b.d Consider again q ff (p q) ff . In <ref> [2] </ref>:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. In [3]:= ExpandScalarProduct [%] Out [3]= p.q - q.q This is how you can substitute q 2 ! 0 afterwards. In [4]:= % /. <p> These special values are inserted immediately whenever possible during the calculation. Set q 2 = 0 before a calculation. In [5]:= ScalarProduct [q, q] = 0 Out [5]= 0 Expanding the result of the contraction q ff (p q) ff now yields (p q). In [6]:= ExpandScalarProduct [Out <ref> [2] </ref>] Out [6]= p.q This expands (a + b) to a + b . <p> Order the product fl fi fl ff ! 2 g fffi fl ff fl fi . In [1]:= DiracOrder [DiracMatrix [be, al]] Out [1]= 2 g [al, be] - ga [al] ga [be] Anticommute back to fl fi fl ff . In <ref> [2] </ref>:= DiracOrder [%, -be, al-] Out [2]= ga [be] ga [al] 2 Elementary Calculations 15 Simplifications like fl fl p= p= = 4 p 2 are built in. <p> Order the product fl fi fl ff ! 2 g fffi fl ff fl fi . In [1]:= DiracOrder [DiracMatrix [be, al]] Out [1]= 2 g [al, be] - ga [al] ga [be] Anticommute back to fl fi fl ff . In <ref> [2] </ref>:= DiracOrder [%, -be, al-] Out [2]= ga [be] ga [al] 2 Elementary Calculations 15 Simplifications like fl fl p= p= = 4 p 2 are built in. In [3]:= DiracOrder [DiracMatrix [mu, mu], DiracSlash [p, p]] Out [3]= 4 p.p fl ff fl fl ff = (2 D) fl in D dimensions. <p> The result of DiracSimplify is not canonically ordered. This is fl fl = D. In [1]:= DiracSimplify [DiracMatrix [mu, mu, Dimension -&gt; D]] Out [1]= D Here the Kahane algorithm is used. fl fl - fl fl fl = 2 fl fl fl - . In <ref> [2] </ref>:= DiracSimplify [DiracMatrix [mu, nu, ro, si, mu]] Out [2]= -2 ga [si] ga [ro] ga [nu] Kahane also gives this identity: 1 fl fl fl fi fl ff fl ffi + fl ffi fl ff fl fi fl fl : In [3]:= DiracSimplify [1/2 DiracMatrix [mu, a, b ,c ,d <p> This is fl fl = D. In [1]:= DiracSimplify [DiracMatrix [mu, mu, Dimension -&gt; D]] Out [1]= D Here the Kahane algorithm is used. fl fl - fl fl fl = 2 fl fl fl - . In <ref> [2] </ref>:= DiracSimplify [DiracMatrix [mu, nu, ro, si, mu]] Out [2]= -2 ga [si] ga [ro] ga [nu] Kahane also gives this identity: 1 fl fl fl fi fl ff fl ffi + fl ffi fl ff fl fi fl fl : In [3]:= DiracSimplify [1/2 DiracMatrix [mu, a, b ,c ,d ,mu]] Out [3]= ga [c] ga [b] ga [a] <p> For direct calculation the function Tr should be used. tr ( fl ff fl fi ) = 4 g fffi . In [1]:= Tr [DiracMatrix [al, be]] Out [1]= 4 g [al, be] 4 f (a d)(b c) (a c)(b d) + (a b)(c d) g. In <ref> [2] </ref>:= Tr [DiracSlash [a, b, c, d]] Out [2]= 4 a.d b.c - 4 a.c b.d + 4 a.b c.d tr ( fl a fl b fl c fl d fl 5 ) = 4 i " abcd . <p> In [1]:= Tr [DiracMatrix [al, be]] Out [1]= 4 g [al, be] 4 f (a d)(b c) (a c)(b d) + (a b)(c d) g. In <ref> [2] </ref>:= Tr [DiracSlash [a, b, c, d]] Out [2]= 4 a.d b.c - 4 a.c b.d + 4 a.b c.d tr ( fl a fl b fl c fl d fl 5 ) = 4 i " abcd . <p> = Block [-gammas, calc-, gammas = Dot @@ Table [ DiracMatrix [a [i], Dimension -&gt; (d - 4)], -i, 1, n- ]; calc = Timing [ Tr [ gammas . gammas ] ]; Print ["Time = ", calc [[1]]//FeynCalcForm ]; calc [<ref> [2] </ref>]]; This calculates a trace of 16 matrices. In [2]:= T [8] Time = 38. s 2 3 4 5 6 7 8 Here we have 18. In [3]:= T [9] Time = 1.8 min 2 3 4 5 6 7 8 9 The trace of 20 Dirac matrices. <p> Otherwise only special cases are simplified. tr ( a b ) = 2 ffi ab . In [1]:= GellMannTrace [GellMannMatrix [a, b]] Out [1]= 2 d [a, b] tr (3 a b a b ) = 32. In <ref> [2] </ref>:= GellMannTrace [ 3 GellMannMatrix [a, b, a, b] ] Out [2]= -32 tr ( a b c ) stays as it is. In [3]:= GellMannTrace [GellMannMatrix [a, b, c]] Out [3]= tr [la [a] la [b] la [c]] tr ( a b c f abc ) = 48 i. <p> Otherwise only special cases are simplified. tr ( a b ) = 2 ffi ab . In [1]:= GellMannTrace [GellMannMatrix [a, b]] Out [1]= 2 d [a, b] tr (3 a b a b ) = 32. In <ref> [2] </ref>:= GellMannTrace [ 3 GellMannMatrix [a, b, a, b] ] Out [2]= -32 tr ( a b c ) stays as it is. In [3]:= GellMannTrace [GellMannMatrix [a, b, c]] Out [3]= tr [la [a] la [b] la [c]] tr ( a b c f abc ) = 48 i. <p> In [12]:= SU3F [c, a, b, SU3FToTraces -&gt; False] * GellMannMatrix [b, c] Out [12]= 3 I la [a] 3 One-Loop Calculations 21 3 One-Loop Calculations The methods and conventions implemented in FeynCalc for the evaluation of one-loop diagrams are described in <ref> [2] </ref> and [3]. The usual Passarino-Veltman scheme for the one-loop integrals is adapted to a large extent [2]. The coefficient functions of the tensor integrals are defined similar to [2], except that the Passarino-Veltman integrals take internal masses squared as arguments. <p> * GellMannMatrix [b, c] Out [12]= 3 I la [a] 3 One-Loop Calculations 21 3 One-Loop Calculations The methods and conventions implemented in FeynCalc for the evaluation of one-loop diagrams are described in <ref> [2] </ref> and [3]. The usual Passarino-Veltman scheme for the one-loop integrals is adapted to a large extent [2]. The coefficient functions of the tensor integrals are defined similar to [2], except that the Passarino-Veltman integrals take internal masses squared as arguments. <p> Calculations 21 3 One-Loop Calculations The methods and conventions implemented in FeynCalc for the evaluation of one-loop diagrams are described in <ref> [2] </ref> and [3]. The usual Passarino-Veltman scheme for the one-loop integrals is adapted to a large extent [2]. The coefficient functions of the tensor integrals are defined similar to [2], except that the Passarino-Veltman integrals take internal masses squared as arguments. A wrapper Fortran program to link FF a Fortran program by G.J. van Oldenborgh [5] for the evaluation of the scalar n-point integrals and FeynCalc is available from the author. <p> In [1]:= B0 [s, mz2, mw2] Taking the derivative with respect to the first argument yields DB0. In <ref> [2] </ref>:= D [%, s] The tensor-integral decomposition is automatically done by FeynCalc when calculating one-loop amplitudes, but extra functions are provided to reduce the coefficients of the tensor-integral decomposition. For fixing the conventions of the coefficient functions the definitions of the tensor-integrals and the de composition are given below. <p> A0 [0] and A0 [Small [m]^2] simplify to 0. The small mass m is set to 0, since the other arguments are non-zero and not Small. In <ref> [2] </ref>:= B1 [pp, Small [me2], m22] -B0 [pp, 0, m22] 2 - But in this case no arguments are replaced by 0. <p> The function Isolate is explained in section 4.4.2. Reduce C 2 (m 2 e ; m 2 e ; 0; m 2 w ) to scalar integrals. In [4]:= PaVeReduce [ PaVe <ref> [2, -Small [me2] </ref>, mw2, t-, -Small [me2], 0, mw2- ] ] Out [4]= - Break down the coefficient function C 12 (s; m 2 ; m 2 ; m 2 ; m 2 ; M 2 ). This is the result in HoldForm. <p> This is the result in HoldForm. In [5]:= c12 = PaVeReduce <ref> [ PaVe [1, 2, -s, m2, m2-, -m2, m2, M2-] </ref>, IsolateHead -&gt; K ] Out [5]= K [11] The FullForm of the assignment to c12 is HoldForm [K [11]]. <p> This is the result in HoldForm. In [5]:= c12 = PaVeReduce [ PaVe <ref> [1, 2, -s, m2, m2-, -m2, m2, M2-] </ref>, IsolateHead -&gt; K ] Out [5]= K [11] The FullForm of the assignment to c12 is HoldForm [K [11]]. <p> In [8]:= d122 = PaVeReduce <ref> [ PaVe [1, 2, 2, -Small [ME2] </ref>, MW2, MW2, Small [ME2], S, T-, -0, Small [ME2], 0, Small [ME2]-], Mandelstam -&gt; -S, T, U, 2 MW2-, IsolateHead -&gt; F ] Out [8]= F [17] Write the result out into a Fortran file. <p> In [8]:= d122 = PaVeReduce [ PaVe <ref> [1, 2, 2, -Small [ME2] </ref>, MW2, MW2, Small [ME2], S, T-, -0, Small [ME2], 0, Small [ME2]-], Mandelstam -&gt; -S, T, U, 2 MW2-, IsolateHead -&gt; F ] Out [8]= F [17] Write the result out into a Fortran file. <p> This is A 0 = i 2 (2 ) 4D R corresponding to a tadpole diagram. The scaling variable is suppressed in FeynCalc. In [1]:= -I/Pi^2 FeynAmpDenominator [ PropagatorDenominator [q, m]] -I 2 2 2 This calculates the tadpole diagram. In <ref> [2] </ref>:= OneLoop [q, %] 2 2 2 2 For a most compact result the factoring option of OneLoop is set. For a description of all options of OneLoop see Section 3.3.4. <p> D. 3.3 Generic Diagrams for W ! f i f 0 j W ! f i f 0 j with OneLoop As an example for calculating triangle diagrams the result for two generic one-loop diagrams of the decay W ! f i f 0 j for massless fermions given in <ref> [2] </ref> is verified with FeynCalc. For the two diagrams different approaches are taken. In the first one FeynCalc introduces standard matrix elements, i.e., that part of the diagram containing polarization dependencies. <p> In [1]:= SetOptions [OneLoop, Factoring -&gt; True]; This defines a function for abbreviation purposes: g c i = g i ! + . Set the p i on-shell and (p 1 p 2 ) = k 2 =2, where k denotes the momentum of the W. In <ref> [2] </ref>:= (gc [i _ ] := g [i, "-"] DiracMatrix [7] + g [i, "+"] DiracMatrix [6]; ScalarProduct [p1, p1] = 0; ScalarProduct [p2, p2] = 0; ScalarProduct [p1, p2] = k2/2); The analytical expression for the generic diagram is: ffiM 1 = i (2) 4 R (2) 4D d D <p> DiracMatrix [nu] . gc [1] . DiracSlash [q + p1] . DiracSlash [Polarization [k]] . gc [3] . DiracSlash [q - p2] . DiracMatrix [nu] . gc <ref> [2] </ref> . <p> ] /. (M^2) -&gt; M2 Out [3]= ((1 - 2 B0 [0, 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g <ref> [2, +] </ref> g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. <p> k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g <ref> [2, -] </ref> g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. <p> The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. In [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g <ref> [2, +] </ref> g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix <p> In [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g <ref> [2, -] </ref> g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. <p> In [5]:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA [1], MA <ref> [2] </ref> - In this way you can generate a Fortran file. With replacements you can adapt the result to your other Fortran code. <p> MAT]; G [x _ y _ ] := MetricTensor [x, y]; FV [p _ , m _ ] := FourVector [p, m]; feynden [x:-_ , _ -..] := FeynAmpDenominator @@ Map [Apply [PropagatorDenominator, #]&, -x-] ); 3 One-Loop Calculations 29 This sets the standard matrix elements: M + M In <ref> [2] </ref>:= SetStandardMatrixElements [ - ( Spinor [p1] . DiracSlash [Polarization [k]] . R . Spinor [p2] ) -&gt; -1-, ( Spinor [p1] . DiracSlash [Polarization [k]] . L . Spinor [p2] ) -&gt; -2 - ]; Here is the second generic diagram. <p> In [3]:= Wff2 = OneLoop [wff2, q, I/(2 Pi)^4 * feynden [-q, 0-, -q + p1, M1-, -q - p2, M2-] * Spinor [p1] . DiracMatrix [nu] . (g [1, "-"] L + g [1, "+"] R) . DiracSlash [-q] . DiracMatrix [ro] . (g <ref> [2, "-"] </ref> L + g [2, "+"] R) . <p> DiracMatrix [nu] . (g [1, "-"] L + g [1, "+"] R) . DiracSlash [-q] . DiracMatrix [ro] . (g [2, "-"] L + g <ref> [2, "+"] </ref> R) . <p> MW2, MW2, 0] K [54] = B0 [T, 0, MZ2] K [56] = B0 [T, 0, MW2] K [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM <ref> [0, 2] </ref> + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM [1, 2] + HoldForm [K [239]]*MBM [2, 1] + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 <p> = B0 [T, 0, MW2] K [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM <ref> [1, 2] </ref> + HoldForm [K [239]]*MBM [2, 1] + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 Miscellaneous Functions 37 4 Miscellaneous Functions 4.1 Functions for Polynomial Manipulations Unfortunately <p> [58] = MH2*MZ2 - T*U K [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM [1, 2] + HoldForm [K [239]]*MBM <ref> [2, 1] </ref> + HoldForm [K [240]]*MBM [2, 2] K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 Miscellaneous Functions 37 4 Miscellaneous Functions 4.1 Functions for Polynomial Manipulations Unfortunately the built-in Mathematica 2.0 functions Factor, <p> [60] = (MZ^5*SW2*HoldForm [K [59]])/(MW2^2*S*HoldForm [K [58]]) (* .............. 338 lines omitted ..................... *) K [241] = HoldForm [K [235]]*MBM [0, 1] + HoldForm [K [236]]*MBM [0, 2] + HoldForm [K [237]]*MBM [1, 1] + HoldForm [K [238]]*MBM [1, 2] + HoldForm [K [239]]*MBM [2, 1] + HoldForm [K [240]]*MBM <ref> [2, 2] </ref> K [242] = 2*ALP4PI*FLUFAC*HoldForm [K [241]] EEZHBOXES = HoldForm [K [242]] Mathematica output file "eezhb.s" generated by OneLoopSum for e + e ! ZH. 4 Miscellaneous Functions 37 4 Miscellaneous Functions 4.1 Functions for Polynomial Manipulations Unfortunately the built-in Mathematica 2.0 functions Factor, Collect and Together are either not <p> In <ref> [2] </ref>:= Collect2 [3 B0 [pp,m1,m2] (m^2 + s) + B0 [pp,m1,m2] s, B0, ProductExpand -&gt; True] 2 This puts terms over a common denominator without expanding the numerator. <p> Isolate with one argument introduces a single K [i] as abbreviation. In [1]:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K <ref> [2] </ref> replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. <p> Isolate with one argument introduces a single K [i] as abbreviation. In [1]:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K <ref> [2] </ref> replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. <p> In [1]:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K <ref> [2] </ref> replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test <p> [1]:= Isolate [a + b] Out [1]= K [1] Here f gets isolated with K [1] and K <ref> [2] </ref> replacing the bracketed subsums. In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. <p> f + (c + d) f + e, f] Out <ref> [2] </ref>= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F <p> Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K <ref> [2] </ref>]]] Asking for K [1] returns its value, but in test K [1] is held. In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. In [5]:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a [z] F [2] With <p> In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K <ref> [2] </ref>, For the term (b + c (y + z)) a single abbreviation F [2] is returned. In [5]:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a [z] F [2] With the help of an additional function it is easy to introduce identical abbreviations for <p> K <ref> [2] </ref>, For the term (b + c (y + z)) a single abbreviation F [2] is returned. In [5]:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a [z] F [2] With the help of an additional function it is easy to introduce identical abbreviations for each subsum. This trick of selectively substituting functions for sums is also quite useful in special reordering of polynomials. <p> Plus -&gt; und /. und -&gt; Plus ) Here it is clear that H [1] = (y + z) is part of H <ref> [2] </ref>. In [7]:= ReleaseHold [%] Out [7]= (y + z) d [z] + a [z] (b + c H [1]) Decreasing the option IsolateSplit significantly forces Isolate to use more than one L for a - b - c - d - e. <p> In [8]:= Isolate [ a - b - c - d - e, IsolateHead -&gt; L, IsolateSplit -&gt; 15 ] Out [8]= L <ref> [2] </ref> This shows the values of the L. In [9]:= -L [2], L [1]- Out [9]= --c - d - e + L [1], a b The importance of Isolate is significant, since it gives you a means to handle very big expressions. <p> In [8]:= Isolate [ a - b - c - d - e, IsolateHead -&gt; L, IsolateSplit -&gt; 15 ] Out [8]= L <ref> [2] </ref> This shows the values of the L. In [9]:= -L [2], L [1]- Out [9]= --c - d - e + L [1], a b The importance of Isolate is significant, since it gives you a means to handle very big expressions. <p> FreeQ2 is an extension of FreeQ, allowing a list as second argument. In [1]:= FreeQ2 [M^2 + m^2 B0 [pp, m1, m2], -M, B0-] Out [1]= False This gives the numerical factor of the expression. In <ref> [2] </ref>:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. In [3]:= PartitHead [f [m] (s - u), f] Out [3]= -s - u, f [m]- A sum gets separated into subsums. <p> FreeQ2 is an extension of FreeQ, allowing a list as second argument. In [1]:= FreeQ2 [M^2 + m^2 B0 [pp, m1, m2], -M, B0-] Out [1]= False This gives the numerical factor of the expression. In <ref> [2] </ref>:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. In [3]:= PartitHead [f [m] (s - u), f] Out [3]= -s - u, f [m]- A sum gets separated into subsums. <p> Create a test polynomial. In [1]:= tpol = z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K <ref> [2] </ref> The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in <p> Create a test polynomial. In [1]:= tpol = z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K <ref> [2] </ref> The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. <p> z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K <ref> [2] </ref> The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. <p> Out [1]= z + K <ref> [2] </ref> The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In [3]:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. <p> In [1]:= Contract [ LeviCivita [m, n, r, s] FourVector [p + q,s] ] Out [1]= eps [m, n, r, p + q] In this way linearity is enforced: " - (p+q) = " - p + " - q . In <ref> [2] </ref>:= EpsEvaluate [ % ] Out [2]= eps [m, n, r, p] + eps [m, n, r, q] This does not evaluate directly to 0. In [3]:= LeviCivita [a, b, c, d] /. d -&gt; c Out [3]= eps [a, b, c, c] Like this you can always evaluate "'s. <p> In [1]:= Contract [ LeviCivita [m, n, r, s] FourVector [p + q,s] ] Out [1]= eps [m, n, r, p + q] In this way linearity is enforced: " - (p+q) = " - p + " - q . In <ref> [2] </ref>:= EpsEvaluate [ % ] Out [2]= eps [m, n, r, p] + eps [m, n, r, q] This does not evaluate directly to 0. In [3]:= LeviCivita [a, b, c, d] /. d -&gt; c Out [3]= eps [a, b, c, c] Like this you can always evaluate "'s. <p> In [1]:= PolarizationSum [mu, nu, k] k [mu] k [nu] k.k Here the polarization sum for gluons is given; with external momentum n = p 1 p 2 . In <ref> [2] </ref>:= PolarizationSum [mu, nu, k, p1 - p2] (p1.p1 - 2 p1.p2 + p2.p2) k [mu] k [nu] 2 k [nu] (p1 - p2)[mu] + k [mu] (p1 - p2)[nu] k.p1 - k.p2 4.7 Simplifications of Expressions with Mandelstam Variables TrickMandelstam [expr, -s, t, u, m1^2 + m2^2 +m3^2 +m4^2-] simplifies <p> This is an easy example of simplifications done by TrickMandelstam. In [1]:= TrickMandelstam [(s + t - u) (2 mw2 - t - u), -s, t, u, 2 mw2-] 4 Miscellaneous Functions 43 The result is always given in a factorized form. In <ref> [2] </ref>:= TrickMandelstam [M^2 s - s^2 + M^2 t - s t + M^2 u - s u, -s, t, u, 2 M^2-] Out [2]= 2 M (M - s) 4.8 Permuting the Arguments of the Four-Point Function The arguments of the Passarino-Veltman four-point function D0are permuted by FeynCalc into an <p> In <ref> [2] </ref>:= TrickMandelstam [M^2 s - s^2 + M^2 t - s t + M^2 u - s u, -s, t, u, 2 M^2-] Out [2]= 2 M (M - s) 4.8 Permuting the Arguments of the Four-Point Function The arguments of the Passarino-Veltman four-point function D0are permuted by FeynCalc into an alphabetical order. If you want a specific permutation of the 24 possible ones, you can use the function PaVeOrder. <p> In [1]:= PaVeOrder [D0 [me2, me2, mw2, mw2, t, s, me2, 0, me2, 0], PaVeOrderList -&gt; -me2, me2, 0, 0-] Out [1]= D0 [me2, s, mw2, t, mw2, me2, me2, 0, 0, me2] This interchanges the f and e. In <ref> [2] </ref>:= PaVeOrder [D0 [a, b, c, d, e, f, m12, m22, m32, m42], PaVeOrderList -&gt; -f, e-] Out [2]= D0 [a, d, c, b, f, e, m22, m12, m42, m32] This shows how to permute several D 0 . <p> In <ref> [2] </ref>:= PaVeOrder [D0 [a, b, c, d, e, f, m12, m22, m32, m42], PaVeOrderList -&gt; -f, e-] Out [2]= D0 [a, d, c, b, f, e, m22, m12, m42, m32] This shows how to permute several D 0 . <p> Clear $PrePrint. In [1]:= $PrePrint=. This is the internal representation of a fl in four dimensions. In <ref> [2] </ref>:= DiracMatrix [mu] Out [2]= DiracGamma [LorentzIndex [mu]] Here is a fl ff in D dimensions. In [3]:= DiracMatrix [al, Dimension -&gt; D] Out [3]= DiracGamma [LorentzIndex [al, D], D] This a product of a four-dimensional q= and a D-dimensional q=. In [4]:= DiracSlash [q] . <p> Clear $PrePrint. In [1]:= $PrePrint=. This is the internal representation of a fl in four dimensions. In <ref> [2] </ref>:= DiracMatrix [mu] Out [2]= DiracGamma [LorentzIndex [mu]] Here is a fl ff in D dimensions. In [3]:= DiracMatrix [al, Dimension -&gt; D] Out [3]= DiracGamma [LorentzIndex [al, D], D] This a product of a four-dimensional q= and a D-dimensional q=. In [4]:= DiracSlash [q] . <p> In the following example the automatic loading of FeynCalc from the init.m file has been turned off. Set the variable $BreitMaison before loading FeynCalc. In [1]:= $BreitMaison = True Out [1]= True Loading FeynCalc. In <ref> [2] </ref>:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In [3]:= DiracMatrix [5] . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes.
Reference: [3] <author> R. Mertig, M. B ohm, and A. </author> <title> Denner, </title> <journal> Comp. Phys. Comm. </journal> <volume> 64 (1991) 345. </volume>
Reference-contexts: With an appropiate option setting this polynomial is directly converted to an optimized Fortran file. The computational methods and algorithms implemented in FeynCalc can be found in [2] and <ref> [3] </ref>, where further references are given. FeynCalc provides also calculator-type like features. You enter a Dirac trace in a very similar notation you use by hand and get back an answer, suitable for further manipulation with Mathematica or ready to translate into Fortran. <p> In [1]:= ScalarProduct [p, q] Out [1]= p.q This is the input for g -. In [2]:= MetricTensor [mu, nu] Out [2]= g [mu, nu] A metric tensor g fffi in D dimensions is entered in this way. The dimension is displayed as an index. In <ref> [3] </ref>:= MetricTensor [al, be, Dimension -&gt; D] Out [3]= g [al, be] Changing D to 4 recovers the default FeynCalcForm for a four-dimensional g fffi . In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. <p> In [2]:= MetricTensor [mu, nu] Out [2]= g [mu, nu] A metric tensor g fffi in D dimensions is entered in this way. The dimension is displayed as an index. In <ref> [3] </ref>:= MetricTensor [al, be, Dimension -&gt; D] Out [3]= g [al, be] Changing D to 4 recovers the default FeynCalcForm for a four-dimensional g fffi . In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In [5]:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. <p> Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. In <ref> [3] </ref>:= DiracMatrix [mu . 5 . nu . 6 . ro . 7] Out [3]= ga [mu] ga [5] ga [nu] ga [6] ga [ro] ga [7] This is a four-dimensional product: 2b= a= 2 (d= c=) (6 q= 3 p=). DiracSlash pulls common numerical factors out. <p> Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. In <ref> [3] </ref>:= DiracMatrix [mu . 5 . nu . 6 . ro . 7] Out [3]= ga [mu] ga [5] ga [nu] ga [6] ga [ro] ga [7] This is a four-dimensional product: 2b= a= 2 (d= c=) (6 q= 3 p=). DiracSlash pulls common numerical factors out. <p> In [1]:= Contract [MetricTensor [a, b] FourVector [p, b]] Out [1]= p [a] Contract q ff (p q) ff . In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . In <ref> [3] </ref>:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. In [4]:= Contract [FourVector [q, al] DiracMatrix [al]] Out [4]= gs [q] Contracting " - p gives " -p . <p> In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . In <ref> [3] </ref>:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. In [4]:= Contract [FourVector [q, al] DiracMatrix [al]] Out [4]= gs [q] Contracting " - p gives " -p . <p> In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. In <ref> [3] </ref>:= ExpandScalarProduct [%] Out [3]= p.q - q.q This is how you can substitute q 2 ! 0 afterwards. In [4]:= % /. <p> In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. In <ref> [3] </ref>:= ExpandScalarProduct [%] Out [3]= p.q - q.q This is how you can substitute q 2 ! 0 afterwards. In [4]:= % /. ScalarProduct [q, q] -&gt; 0 Out [4]= p.q Instead of substituting scalar products at the end of the calculation another possibility is to assign special values for scalar products first. <p> In [2]:= DiracOrder [%, -be, al-] Out [2]= ga [be] ga [al] 2 Elementary Calculations 15 Simplifications like fl fl p= p= = 4 p 2 are built in. In <ref> [3] </ref>:= DiracOrder [DiracMatrix [mu, mu], DiracSlash [p, p]] Out [3]= 4 p.p fl ff fl fl ff = (2 D) fl in D dimensions. <p> In [2]:= DiracOrder [%, -be, al-] Out [2]= ga [be] ga [al] 2 Elementary Calculations 15 Simplifications like fl fl p= p= = 4 p 2 are built in. In <ref> [3] </ref>:= DiracOrder [DiracMatrix [mu, mu], DiracSlash [p, p]] Out [3]= 4 p.p fl ff fl fl ff = (2 D) fl in D dimensions. In [4]:= DiracOrder [DiracMatrix [a, m, a, Dimension -&gt; D]] Out [4]= (2 - D) ga [m] p= q= p= = q= p 2 2 p= (p q). <p> In [2]:= DiracSimplify [DiracMatrix [mu, nu, ro, si, mu]] Out [2]= -2 ga [si] ga [ro] ga [nu] Kahane also gives this identity: 1 fl fl fl fi fl ff fl ffi + fl ffi fl ff fl fi fl fl : In <ref> [3] </ref>:= DiracSimplify [1/2 DiracMatrix [mu, a, b ,c ,d ,mu]] Out [3]= ga [c] ga [b] ga [a] ga [d] + ga [d] ga [a] ga [b] ga [c] This is p= (m q=) p= = q= p 2 + p 2 m 2 p= (p q). <p> [mu, nu, ro, si, mu]] Out [2]= -2 ga [si] ga [ro] ga [nu] Kahane also gives this identity: 1 fl fl fl fi fl ff fl ffi + fl ffi fl ff fl fi fl fl : In <ref> [3] </ref>:= DiracSimplify [1/2 DiracMatrix [mu, a, b ,c ,d ,mu]] Out [3]= ga [c] ga [b] ga [a] ga [d] + ga [d] ga [a] ga [b] ga [c] This is p= (m q=) p= = q= p 2 + p 2 m 2 p= (p q). <p> In [2]:= Tr [DiracSlash [a, b, c, d]] Out [2]= 4 a.d b.c - 4 a.c b.d + 4 a.b c.d tr ( fl a fl b fl c fl d fl 5 ) = 4 i " abcd . In <ref> [3] </ref>:= Tr [DiracMatrix [a, b, c, d, 5]] Out [3]= -4 I eps [a, b, c, d] You may include metric tensors or four-vectors, for example, tr ( 1 4 g fffi fl fl ff p ) = p fi . <p> In <ref> [3] </ref>:= Tr [DiracMatrix [a, b, c, d, 5]] Out [3]= -4 I eps [a, b, c, d] You may include metric tensors or four-vectors, for example, tr ( 1 4 g fffi fl fl ff p ) = p fi . <p> In [2]:= T [8] Time = 38. s 2 3 4 5 6 7 8 Here we have 18. In <ref> [3] </ref>:= T [9] Time = 1.8 min 2 3 4 5 6 7 8 9 The trace of 20 Dirac matrices. In [4]:= T [10] Time = 7.2 min 2 3 4 5 6 7 8 9 10 With 22 Dirac matrices it gets slow. <p> In [1]:= GellMannTrace [GellMannMatrix [a, b]] Out [1]= 2 d [a, b] tr (3 a b a b ) = 32. In [2]:= GellMannTrace [ 3 GellMannMatrix [a, b, a, b] ] Out [2]= -32 tr ( a b c ) stays as it is. In <ref> [3] </ref>:= GellMannTrace [GellMannMatrix [a, b, c]] Out [3]= tr [la [a] la [b] la [c]] tr ( a b c f abc ) = 48 i. <p> In [2]:= GellMannTrace [ 3 GellMannMatrix [a, b, a, b] ] Out [2]= -32 tr ( a b c ) stays as it is. In <ref> [3] </ref>:= GellMannTrace [GellMannMatrix [a, b, c]] Out [3]= tr [la [a] la [b] la [c]] tr ( a b c f abc ) = 48 i. <p> In [12]:= SU3F [c, a, b, SU3FToTraces -&gt; False] * GellMannMatrix [b, c] Out [12]= 3 I la [a] 3 One-Loop Calculations 21 3 One-Loop Calculations The methods and conventions implemented in FeynCalc for the evaluation of one-loop diagrams are described in [2] and <ref> [3] </ref>. The usual Passarino-Veltman scheme for the one-loop integrals is adapted to a large extent [2]. The coefficient functions of the tensor integrals are defined similar to [2], except that the Passarino-Veltman integrals take internal masses squared as arguments. <p> The scalar quantity p 2 is entered as pp, p 2 i as pi0 and (p i p j ) 2 as pij. For the following examples some options are set. In <ref> [3] </ref>:= (SetOptions [A0, A0ToB0 -&gt; False]; SetOptions [-B1, B00, B11-, BReduce -&gt; False]); This is the scalar Passarino-Veltman one-point function. In [4]:= PaVe [0, --, -m02-] Out [4]= A0 [m02] This is the two-point function B 0 (p 2 ; m 2 1 ). <p> The small mass m is set to 0, since the other arguments are non-zero and not Small. In [2]:= B1 [pp, Small [me2], m22] -B0 [pp, 0, m22] 2 - But in this case no arguments are replaced by 0. In <ref> [3] </ref>:= B1 [Small [me2], Small [me2], 0] 1 B0 [Small [me2], 0, Small [me2]] Out [3]= -(-) - PaVeReduce [expr] reduces coefficient functions PaVe to A0, B0, C0, D0 K [i] abbreviations in HoldForm in the result of PaVeReduce Reduction function for Passarino-Veltman coefficient functions. <p> In [2]:= B1 [pp, Small [me2], m22] -B0 [pp, 0, m22] 2 - But in this case no arguments are replaced by 0. In <ref> [3] </ref>:= B1 [Small [me2], Small [me2], 0] 1 B0 [Small [me2], 0, Small [me2]] Out [3]= -(-) - PaVeReduce [expr] reduces coefficient functions PaVe to A0, B0, C0, D0 K [i] abbreviations in HoldForm in the result of PaVeReduce Reduction function for Passarino-Veltman coefficient functions. <p> In [2]:= OneLoop [q, %] 2 2 2 2 For a most compact result the factoring option of OneLoop is set. For a description of all options of OneLoop see Section 3.3.4. In <ref> [3] </ref>:= SetOptions [OneLoop, Factoring -&gt; True, Dimension -&gt; D]; This is the transversal part of a photon self energy diagram with a fermion loop. ie 2 =((2) 4 (1 D)) d 4 q [q 2 m 2 f ] 1 = f B 0 (0; m 2 f ) f )B <p> In <ref> [3] </ref>:= Wff1 = OneLoop [ q, I/(2 Pi)^4 FeynAmpDenominator [ PropagatorDenominator [q, M], PropagatorDenominator [q + p1], PropagatorDenominator [q - p2] ] * Spinor [p1] . DiracMatrix [nu] . gc [1] . DiracSlash [q + p1] . DiracSlash [Polarization [k]] . gc [3] . DiracSlash [q - p2] . <p> In <ref> [3] </ref>:= Wff1 = OneLoop [ q, I/(2 Pi)^4 FeynAmpDenominator [ PropagatorDenominator [q, M], PropagatorDenominator [q + p1], PropagatorDenominator [q - p2] ] * Spinor [p1] . DiracMatrix [nu] . gc [1] . DiracSlash [q + p1] . DiracSlash [Polarization [k]] . gc [3] . DiracSlash [q - p2] . DiracMatrix [nu] . gc [2] . Spinor [p2] ] /. (M^2) -&gt; M2 Out [3]= ((1 - 2 B0 [0, 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + <p> DiracMatrix [nu] . gc [1] . DiracSlash [q + p1] . DiracSlash [Polarization [k]] . gc <ref> [3] </ref> . DiracSlash [q - p2] . DiracMatrix [nu] . gc [2] . Spinor [p2] ] /. (M^2) -&gt; M2 Out [3]= ((1 - 2 B0 [0, 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u <p> -&gt; M2 Out [3]= ((1 - 2 B0 [0, 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g <ref> [3, +] </ref> StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. <p> 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g <ref> [3, -] </ref> StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. <p> The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. In [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g <ref> [3, +] </ref> StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. <p> [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g <ref> [3, -] </ref> StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. <p> DiracSlash [Polarization [k]] . L . Spinor [p2] ) -&gt; -2 - ]; Here is the second generic diagram. Note that in the result StandardMatrixElement is replaced by MAT, as specified in the option FinalSubstitutions of OneLoop on the previous page. In <ref> [3] </ref>:= Wff2 = OneLoop [wff2, q, I/(2 Pi)^4 * feynden [-q, 0-, -q + p1, M1-, -q - p2, M2-] * Spinor [p1] . DiracMatrix [nu] . (g [1, "-"] L + g [1, "+"] R) . DiracSlash [-q] . <p> K (235)*MBM (0,1) + K (236)*MBM (0,2) + - K (239)*MBM (2,1) + K (240)*MBM (2,2) K (242) = 2*ALP4PI*FLUFAC*K (241) EEZHBOXES = K (242) Fortran output file "eezhb.for" generated by OneLoopSum for e + e ! ZH. 36 Guide to FeynCalc 1.0 K [1] = 2*MH2 - MZ2 K <ref> [3] </ref> = 1 - 2*SW2 K [5] = MH2 + 2*MZ2 K [7] = MH2 - 3*MZ2 K [9] = 2*MH2^2 + 4*MH2*MZ2 + MZ2^2 K [11] = MH2 - 7*MZ2 K [13] = 3*MH2 - 2*MZ2 K [15] = 2*MW2 - MZ2 K [17] = 3*MH2 + 4*MZ2 K [19] <p> In [2]:= Collect2 [3 B0 [pp,m1,m2] (m^2 + s) + B0 [pp,m1,m2] s, B0, ProductExpand -&gt; True] 2 This puts terms over a common denominator without expanding the numerator. In <ref> [3] </ref>:= Combine [(a - b) (c - d)/e + g] (a - b) (c - d) + e g e Consider a generic polynomial. <p> In [2]:= test = Isolate [(a + b) f + (c + d) f + e, f] Out [2]= e + f K [1] + f K [2] Looking at the FullForm reveals that the K [i] are given in HoldForm. In <ref> [3] </ref>:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. <p> In [1]:= FreeQ2 [M^2 + m^2 B0 [pp, m1, m2], -M, B0-] Out [1]= False This gives the numerical factor of the expression. In [2]:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. In <ref> [3] </ref>:= PartitHead [f [m] (s - u), f] Out [3]= -s - u, f [m]- A sum gets separated into subsums. <p> In [2]:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. In <ref> [3] </ref>:= PartitHead [f [m] (s - u), f] Out [3]= -s - u, f [m]- A sum gets separated into subsums. <p> Create a test polynomial. In [1]:= tpol = z + Isolate [Isolate [2 Pi I + f [x] (a - b), f]] Out [1]= z + K [2] The default writes out in Mathematica InputForm. In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In <ref> [3] </ref>:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran <p> In [2]:= Write2 ["test.m", test = tpol]; Show the content of the file. In <ref> [3] </ref>:= !!test.m K [1] = a - b K [2] = 2*I*Pi + f [x]*HoldForm [K [1]] test = z + HoldForm [K [2]] This writes a file in Fortran format. In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. In [4]:= !!test.for K (1) = a - b test = z + K (2) This writes a file in Macysma format. <p> In [2]:= EpsEvaluate [ % ] Out [2]= eps [m, n, r, p] + eps [m, n, r, q] This does not evaluate directly to 0. In <ref> [3] </ref>:= LeviCivita [a, b, c, d] /. d -&gt; c Out [3]= eps [a, b, c, c] Like this you can always evaluate "'s. <p> In [2]:= EpsEvaluate [ % ] Out [2]= eps [m, n, r, p] + eps [m, n, r, q] This does not evaluate directly to 0. In <ref> [3] </ref>:= LeviCivita [a, b, c, d] /. d -&gt; c Out [3]= eps [a, b, c, c] Like this you can always evaluate "'s. <p> In [2]:= PaVeOrder [D0 [a, b, c, d, e, f, m12, m22, m32, m42], PaVeOrderList -&gt; -f, e-] Out [2]= D0 [a, d, c, b, f, e, m22, m12, m42, m32] This shows how to permute several D 0 . In <ref> [3] </ref>:= PaVeOrder [ D0 [a, b, c, d, e, f, m12, m22, m32, m42] + D0 [me2, me2, mw2, mw2, t, s, me2, 0, me2, 0], PaVeOrderList-&gt; - -me2, me2, 0, 0-, -f, e - ] D0 [me2, s, mw2, t, mw2, me2, me2, 0, 0, me2] 4.9 On the Internal <p> Clear $PrePrint. In [1]:= $PrePrint=. This is the internal representation of a fl in four dimensions. In [2]:= DiracMatrix [mu] Out [2]= DiracGamma [LorentzIndex [mu]] Here is a fl ff in D dimensions. In <ref> [3] </ref>:= DiracMatrix [al, Dimension -&gt; D] Out [3]= DiracGamma [LorentzIndex [al, D], D] This a product of a four-dimensional q= and a D-dimensional q=. In [4]:= DiracSlash [q] . DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . <p> Clear $PrePrint. In [1]:= $PrePrint=. This is the internal representation of a fl in four dimensions. In [2]:= DiracMatrix [mu] Out [2]= DiracGamma [LorentzIndex [mu]] Here is a fl ff in D dimensions. In <ref> [3] </ref>:= DiracMatrix [al, Dimension -&gt; D] Out [3]= DiracGamma [LorentzIndex [al, D], D] This a product of a four-dimensional q= and a D-dimensional q=. In [4]:= DiracSlash [q] . DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. <p> In the following example the automatic loading of FeynCalc from the init.m file has been turned off. Set the variable $BreitMaison before loading FeynCalc. In [1]:= $BreitMaison = True Out [1]= True Loading FeynCalc. In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In <ref> [3] </ref>:= DiracMatrix [5] . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. <p> Set the variable $BreitMaison before loading FeynCalc. In [1]:= $BreitMaison = True Out [1]= True Loading FeynCalc. In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In <ref> [3] </ref>:= DiracMatrix [5] . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically.
Reference: [4] <author> E. Yehudai and A. C. K. Hsieh, </author> <title> HIP Symbolic High-Energy Physics Calculations, </title> <month> SLAC-PUB- 5576 July </month> <year> 1991. </year>
Reference-contexts: Apart from these basic operations like contraction of tensors, simplification of products of Dirac matrices and trace calculation no attempt has been made to provide tools for tree-level calculations in FeynCalc 1.0. For this purpose a lot of programs exist, among them another Mathematica package, HIP <ref> [4] </ref>, developped at SLAC. A free copy of FeynCalc may be obtained from the author. You may redistribute FeynCalc with no charge, but please do not change the program. <p> The dimension is displayed as an index. In [3]:= MetricTensor [al, be, Dimension -&gt; D] Out [3]= g [al, be] Changing D to 4 recovers the default FeynCalcForm for a four-dimensional g fffi . In <ref> [4] </ref>:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In [5]:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . <p> In [3]:= DiracMatrix [mu . 5 . nu . 6 . ro . 7] Out [3]= ga [mu] ga [5] ga [nu] ga [6] ga [ro] ga [7] This is a four-dimensional product: 2b= a= 2 (d= c=) (6 q= 3 p=). DiracSlash pulls common numerical factors out. In <ref> [4] </ref>:= DiracSlash [2 b, a, 2 (d - c) , 6 q - 3 p] Out [4]= 12 gs [b] gs [a] gs [c - d] gs [p - 2 q] Here is an alternative input with Dot. Commutative products have to be grouped with parentheses here. <p> DiracSlash pulls common numerical factors out. In <ref> [4] </ref>:= DiracSlash [2 b, a, 2 (d - c) , 6 q - 3 p] Out [4]= 12 gs [b] gs [a] gs [c - d] gs [p - 2 q] Here is an alternative input with Dot. Commutative products have to be grouped with parentheses here. <p> In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This contracts g fffi fl ff . In [3]:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. In <ref> [4] </ref>:= Contract [FourVector [q, al] DiracMatrix [al]] Out [4]= gs [q] Contracting " - p gives " -p . In [5]:= Contract [LeviCivita [mu, nu, ro, si] FourVector [p, si]] Out [5]= eps [mu, nu, ro, p] The contraction of " ff- " fi- yields 6 g fffi . <p> In [3]:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. In <ref> [4] </ref>:= Contract [FourVector [q, al] DiracMatrix [al]] Out [4]= gs [q] Contracting " - p gives " -p . In [5]:= Contract [LeviCivita [mu, nu, ro, si] FourVector [p, si]] Out [5]= eps [mu, nu, ro, p] The contraction of " ff- " fi- yields 6 g fffi . <p> In [2]:= Contract [FourVector [q, al] FourVector [p - q, al]] Out [2]= (p - q).q This expands the scalar products. In [3]:= ExpandScalarProduct [%] Out [3]= p.q - q.q This is how you can substitute q 2 ! 0 afterwards. In <ref> [4] </ref>:= % /. ScalarProduct [q, q] -&gt; 0 Out [4]= p.q Instead of substituting scalar products at the end of the calculation another possibility is to assign special values for scalar products first. These special values are inserted immediately whenever possible during the calculation. <p> In [3]:= ExpandScalarProduct [%] Out [3]= p.q - q.q This is how you can substitute q 2 ! 0 afterwards. In <ref> [4] </ref>:= % /. ScalarProduct [q, q] -&gt; 0 Out [4]= p.q Instead of substituting scalar products at the end of the calculation another possibility is to assign special values for scalar products first. These special values are inserted immediately whenever possible during the calculation. Set q 2 = 0 before a calculation. <p> In [3]:= DiracOrder [DiracMatrix [mu, mu], DiracSlash [p, p]] Out [3]= 4 p.p fl ff fl fl ff = (2 D) fl in D dimensions. In <ref> [4] </ref>:= DiracOrder [DiracMatrix [a, m, a, Dimension -&gt; D]] Out [4]= (2 - D) ga [m] p= q= p= = q= p 2 2 p= (p q). <p> In [3]:= DiracOrder [DiracMatrix [mu, mu], DiracSlash [p, p]] Out [3]= 4 p.p fl ff fl fl ff = (2 D) fl in D dimensions. In <ref> [4] </ref>:= DiracOrder [DiracMatrix [a, m, a, Dimension -&gt; D]] Out [4]= (2 - D) ga [m] p= q= p= = q= p 2 2 p= (p q). <p> In <ref> [4] </ref>:= DiracSimplify [DiracSlash [p], DiracSlash [-q] + m, DiracSlash [p]] Out [4]= gs [q] p.p + m p.p - 2 gs [p] p.q This is fl 5 fl = fl fl 5 . <p> In <ref> [4] </ref>:= DiracSimplify [DiracSlash [p], DiracSlash [-q] + m, DiracSlash [p]] Out [4]= gs [q] p.p + m p.p - 2 gs [p] p.q This is fl 5 fl = fl fl 5 . In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . <p> In [3]:= Tr [DiracMatrix [a, b, c, d, 5]] Out [3]= -4 I eps [a, b, c, d] You may include metric tensors or four-vectors, for example, tr ( 1 4 g fffi fl fl ff p ) = p fi . In <ref> [4] </ref>:= Tr [MetricTensor [al, be]/4 DiracMatrix [mu], DiracMatrix [al] FourVector [p, mu]] Out [4]= p [be] If you want to do more complicated traces it is convenient to introduce abbreviations for the several objects. The following examples show how to do this. <p> In <ref> [4] </ref>:= Tr [MetricTensor [al, be]/4 DiracMatrix [mu], DiracMatrix [al] FourVector [p, mu]] Out [4]= p [be] If you want to do more complicated traces it is convenient to introduce abbreviations for the several objects. The following examples show how to do this. The CPU time needed for each trace calculation is for all examples less than one minute (on a NeXT). <p> In [2]:= T [8] Time = 38. s 2 3 4 5 6 7 8 Here we have 18. In [3]:= T [9] Time = 1.8 min 2 3 4 5 6 7 8 9 The trace of 20 Dirac matrices. In <ref> [4] </ref>:= T [10] Time = 7.2 min 2 3 4 5 6 7 8 9 10 With 22 Dirac matrices it gets slow. <p> In [3]:= GellMannTrace [GellMannMatrix [a, b, c]] Out [3]= tr [la [a] la [b] la [c]] tr ( a b c f abc ) = 48 i. In <ref> [4] </ref>:= GellMannTrace [SU3F [a, b, c] GellMannMatrix [a, b, c]] Out [4]= 48 I tr (f ars f brs ) = 3 f ars f brs = 9 ffi ab . <p> In [3]:= GellMannTrace [GellMannMatrix [a, b, c]] Out [3]= tr [la [a] la [b] la [c]] tr ( a b c f abc ) = 48 i. In <ref> [4] </ref>:= GellMannTrace [SU3F [a, b, c] GellMannMatrix [a, b, c]] Out [4]= 48 I tr (f ars f brs ) = 3 f ars f brs = 9 ffi ab . <p> For the following examples some options are set. In [3]:= (SetOptions [A0, A0ToB0 -&gt; False]; SetOptions [-B1, B00, B11-, BReduce -&gt; False]); This is the scalar Passarino-Veltman one-point function. In <ref> [4] </ref>:= PaVe [0, --, -m02-] Out [4]= A0 [m02] This is the two-point function B 0 (p 2 ; m 2 1 ). In [5]:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). <p> For the following examples some options are set. In [3]:= (SetOptions [A0, A0ToB0 -&gt; False]; SetOptions [-B1, B00, B11-, BReduce -&gt; False]); This is the scalar Passarino-Veltman one-point function. In <ref> [4] </ref>:= PaVe [0, --, -m02-] Out [4]= A0 [m02] This is the two-point function B 0 (p 2 ; m 2 1 ). In [5]:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). <p> The function Isolate is explained in section 4.4.2. Reduce C 2 (m 2 e ; m 2 e ; 0; m 2 w ) to scalar integrals. In <ref> [4] </ref>:= PaVeReduce [ PaVe [2, -Small [me2], mw2, t-, -Small [me2], 0, mw2- ] ] Out [4]= - Break down the coefficient function C 12 (s; m 2 ; m 2 ; m 2 ; m 2 ; M 2 ). This is the result in HoldForm. <p> The function Isolate is explained in section 4.4.2. Reduce C 2 (m 2 e ; m 2 e ; 0; m 2 w ) to scalar integrals. In <ref> [4] </ref>:= PaVeReduce [ PaVe [2, -Small [me2], mw2, t-, -Small [me2], 0, mw2- ] ] Out [4]= - Break down the coefficient function C 12 (s; m 2 ; m 2 ; m 2 ; m 2 ; M 2 ). This is the result in HoldForm. <p> transversal part of a photon self energy diagram with a fermion loop. ie 2 =((2) 4 (1 D)) d 4 q [q 2 m 2 f ] 1 = f B 0 (0; m 2 f ) f )B 0 (k 2 ; m 2 f ))]=(36 2 ) In <ref> [4] </ref>:= OneLoop [ q, (I el^2)/(16 Pi^4)/(1 - D) * FeynAmpDenominator [ PropagatorDenominator [q, mf], PropagatorDenominator [q - k, mf] ] * DiracTrace [(mf + DiracSlash [q - k]) . DiracMatrix [mu] . (mf + DiracSlash [q]) . DiracMatrix [mu]] ] /. <p> The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. In <ref> [4] </ref>:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, <p> The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. In <ref> [4] </ref>:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga <p> In <ref> [4] </ref>:= !!wff2.for - (2*k2 + M1**2)*B0 (Null,M1**2,Null) + - (2*k2 + M2**2)*B0 (Null,M2**2,Null) + - 2*(k2*M1**2 + k2*M2**2 + M1**2*M2**2)* - C0 (Null,Null,k2,M1**2,Null,M2**2))* - (gp (1)*gp (2)*MAT (1) + The result is also autmatically assigned to OneLoopResult [name]. In [4]:= OneLoopResult [wff2] 2 2 2 2 2 2 2 2 2 <p> In <ref> [4] </ref>:= !!wff2.for - (2*k2 + M1**2)*B0 (Null,M1**2,Null) + - (2*k2 + M2**2)*B0 (Null,M2**2,Null) + - 2*(k2*M1**2 + k2*M2**2 + M1**2*M2**2)* - C0 (Null,Null,k2,M1**2,Null,M2**2))* - (gp (1)*gp (2)*MAT (1) + The result is also autmatically assigned to OneLoopResult [name]. In [4]:= OneLoopResult [wff2] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 OneLoopResult [name] is set to the result of OneLoop [name, ...] OneLoopResult [name] gets valus as a side effect of OneLoop. 30 Guide to FeynCalc 1.0 3.4 The Options of OneLoop Several options <p> In [3]:= Combine [(a - b) (c - d)/e + g] (a - b) (c - d) + e g e Consider a generic polynomial. In <ref> [4] </ref>:= test = (a - b) x + (b a) y Out [4]= (a - b) x + (-a + b) y Mapping Factor on the summands shows that no canonical factorization of integers in sums takes place. <p> In [3]:= Combine [(a - b) (c - d)/e + g] (a - b) (c - d) + e g e Consider a generic polynomial. In <ref> [4] </ref>:= test = (a - b) x + (b a) y Out [4]= (a - b) x + (-a + b) y Mapping Factor on the summands shows that no canonical factorization of integers in sums takes place. <p> In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In <ref> [4] </ref>:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. <p> In [3]:= FullForm [test] Out [3]//FullForm= Plus [e, Times [f, HoldForm [K [1]]], Times [f, HoldForm [K [2]]]] Asking for K [1] returns its value, but in test K [1] is held. In <ref> [4] </ref>:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. <p> In [2]:= NumericalFactor [-137 x] Out [2]= -137 The action of PartitHead on a product is to split the product apart. In [3]:= PartitHead [f [m] (s - u), f] Out [3]= -s - u, f [m]- A sum gets separated into subsums. In <ref> [4] </ref>:= PartitHead [s^2 + M^2 - f [m], f] 2 2 4.4 Writing Out to Mathematica, Fortran, Macsyma and Maple The Mathematica functions Write and Save may on rare occasions create files that cannot be read in again correctly. <p> In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. In <ref> [4] </ref>:= !!test.for K (1) = a - b test = z + K (2) This writes a file in Macysma format. In [4]:= Write2 ["test.mac", test = tpol, FormatType -&gt; MacsymaForm]; Here the Macsyma format can be seen. <p> In [3]:= Write2 ["test.for", test = tpol, FormatType -&gt; FortranForm]; 4 Miscellaneous Functions 41 Show the content of the Fortran file. In <ref> [4] </ref>:= !!test.for K (1) = a - b test = z + K (2) This writes a file in Macysma format. In [4]:= Write2 ["test.mac", test = tpol, FormatType -&gt; MacsymaForm]; Here the Macsyma format can be seen. In [5]:= !!test.mac test : ( 2*%i*%pi + z + (a - b)*f (x) )$ Here we get a file with Maple conventions. <p> In [3]:= LeviCivita [a, b, c, d] /. d -&gt; c Out [3]= eps [a, b, c, c] Like this you can always evaluate "'s. In <ref> [4] </ref>:= EpsEvaluate [ % ] Out [4]= 0 EpsChisholm [expr] utilize fl " - = +i (fl - fl fl g - fl g fl - + g - fl )fl 5 A function for the Chisholm identity. option name default value LeviCivitaSign -1 sign convention for the "-tensor An option <p> In [3]:= LeviCivita [a, b, c, d] /. d -&gt; c Out [3]= eps [a, b, c, c] Like this you can always evaluate "'s. In <ref> [4] </ref>:= EpsEvaluate [ % ] Out [4]= 0 EpsChisholm [expr] utilize fl " - = +i (fl - fl fl g - fl g fl - + g - fl )fl 5 A function for the Chisholm identity. option name default value LeviCivitaSign -1 sign convention for the "-tensor An option for EpsChisholm. <p> In [2]:= DiracMatrix [mu] Out [2]= DiracGamma [LorentzIndex [mu]] Here is a fl ff in D dimensions. In [3]:= DiracMatrix [al, Dimension -&gt; D] Out [3]= DiracGamma [LorentzIndex [al, D], D] This a product of a four-dimensional q= and a D-dimensional q=. In <ref> [4] </ref>:= DiracSlash [q] . DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. In [5]:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. <p> In [3]:= DiracMatrix [al, Dimension -&gt; D] Out [3]= DiracGamma [LorentzIndex [al, D], D] This a product of a four-dimensional q= and a D-dimensional q=. In <ref> [4] </ref>:= DiracSlash [q] . DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. In [5]:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. <p> In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In [3]:= DiracMatrix [5] . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In <ref> [4] </ref>:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . <p> In [3]:= DiracMatrix [5] . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In <ref> [4] </ref>:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right.
Reference: [5] <author> G. J. van Oldenborgh, </author> <title> FF a package to evaluate one-loop Feynman diagrams, </title> <journal> Comp. Phys. Comm. </journal> <volume> 66 (1991) 1. </volume>
Reference-contexts: In [3]:= MetricTensor [al, be, Dimension -&gt; D] Out [3]= g [al, be] Changing D to 4 recovers the default FeynCalcForm for a four-dimensional g fffi . In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In <ref> [5] </ref>:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . <p> In [3]:= MetricTensor [al, be, Dimension -&gt; D] Out [3]= g [al, be] Changing D to 4 recovers the default FeynCalcForm for a four-dimensional g fffi . In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In <ref> [5] </ref>:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In [7]:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . <p> DiracSlash [p, q, ...] Feynman slashes p= q= . . . DiracMatrix <ref> [5] </ref> fl 5 ChiralityProjector [+1] ! + = (1 + fl 5 )=2 DiracMatrix [6] fl 6 = (1 + fl 5 )=2 ChiralityProjector [-1] ! = (1 fl 5 )=2 DiracMatrix [7] fl 7 = (1 fl 5 )=2 Various input functions for Dirac matrices. <p> This is how you enter (p= + q= + m) fl . In [1]:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix <ref> [ro, 5, mu, 6, al, 7] </ref> Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> In [1]:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix [ro, 5, mu, 6, al, 7] Out [2]= ga [ro] ga <ref> [5] </ref> ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. In [3]:= DiracMatrix [mu . 5 . nu . 6 . ro . 7] Out [3]= ga [mu] ga <ref> [5] </ref> ga [nu] ga [6] ga [ro] ga [7] This is a four-dimensional product: 2b= a= 2 (d= c=) (6 q= 3 p=). DiracSlash pulls common numerical factors out. <p> In [4]:= DiracSlash [2 b, a, 2 (d - c) , 6 q - 3 p] Out [4]= 12 gs [b] gs [a] gs [c - d] gs [p - 2 q] Here is an alternative input with Dot. Commutative products have to be grouped with parentheses here. In <ref> [5] </ref>:= DiracSlash [(2 b) . a . (2 (d - c)) . (6 q - 3 p)] Out [5]= 12 gs [b] gs [a] gs [c - d] gs [p - 2 q] Slashed polarization vectors "= (k) are entered in this way. <p> Commutative products have to be grouped with parentheses here. In <ref> [5] </ref>:= DiracSlash [(2 b) . a . (2 (d - c)) . (6 q - 3 p)] Out [5]= 12 gs [b] gs [a] gs [c - d] gs [p - 2 q] Slashed polarization vectors "= (k) are entered in this way. In [6]:= DiracSlash [Polarization [k]] Out [6]= gs [ep [k]] option name default value Dimension 4 space-time dimension Option for DiracMatrix and DiracSlash. <p> In [3]:= Contract [MetricTensor [al, be] DiracMatrix [al]] Out [3]= ga [be] Contracting q ff fl ff yields a Feynman slash. In [4]:= Contract [FourVector [q, al] DiracMatrix [al]] Out [4]= gs [q] Contracting " - p gives " -p . In <ref> [5] </ref>:= Contract [LeviCivita [mu, nu, ro, si] FourVector [p, si]] Out [5]= eps [mu, nu, ro, p] The contraction of " ff- " fi- yields 6 g fffi . <p> In [4]:= Contract [FourVector [q, al] DiracMatrix [al]] Out [4]= gs [q] Contracting " - p gives " -p . In <ref> [5] </ref>:= Contract [LeviCivita [mu, nu, ro, si] FourVector [p, si]] Out [5]= eps [mu, nu, ro, p] The contraction of " ff- " fi- yields 6 g fffi . <p> These special values are inserted immediately whenever possible during the calculation. Set q 2 = 0 before a calculation. In <ref> [5] </ref>:= ScalarProduct [q, q] = 0 Out [5]= 0 Expanding the result of the contraction q ff (p q) ff now yields (p q). In [6]:= ExpandScalarProduct [Out [2]] Out [6]= p.q This expands (a + b) to a + b . <p> These special values are inserted immediately whenever possible during the calculation. Set q 2 = 0 before a calculation. In <ref> [5] </ref>:= ScalarProduct [q, q] = 0 Out [5]= 0 Expanding the result of the contraction q ff (p q) ff now yields (p q). In [6]:= ExpandScalarProduct [Out [2]] Out [6]= p.q This expands (a + b) to a + b . <p> In [4]:= DiracOrder [DiracMatrix [a, m, a, Dimension -&gt; D]] Out [4]= (2 - D) ga [m] p= q= p= = q= p 2 2 p= (p q). In <ref> [5] </ref>:= DiracOrder [DiracSlash [-p, q, p]] Out [5]= gs [q] p.p - 2 gs [p] p.q Basically DiracOrder is just the implementation of the anticommutator relation ffl ; fl - g = 2 g -. For calculations involving fl 5 you can use the function DiracSimplify. <p> In [4]:= DiracOrder [DiracMatrix [a, m, a, Dimension -&gt; D]] Out [4]= (2 - D) ga [m] p= q= p= = q= p 2 2 p= (p q). In <ref> [5] </ref>:= DiracOrder [DiracSlash [-p, q, p]] Out [5]= gs [q] p.p - 2 gs [p] p.q Basically DiracOrder is just the implementation of the anticommutator relation ffl ; fl - g = 2 g -. For calculations involving fl 5 you can use the function DiracSimplify. <p> In [4]:= DiracSimplify [DiracSlash [p], DiracSlash [-q] + m, DiracSlash [p]] Out [4]= gs [q] p.p + m p.p - 2 gs [p] p.q This is fl 5 fl = fl fl 5 . In <ref> [5] </ref>:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. <p> In [4]:= DiracSimplify [DiracSlash [p], DiracSlash [-q] + m, DiracSlash [p]] Out [4]= gs [q] p.p + m p.p - 2 gs [p] p.q This is fl 5 fl = fl fl 5 . In <ref> [5] </ref>:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. <p> In [4]:= DiracSimplify [DiracSlash [p], DiracSlash [-q] + m, DiracSlash [p]] Out [4]= gs [q] p.p + m p.p - 2 gs [p] p.q This is fl 5 fl = fl fl 5 . In <ref> [5] </ref>:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. <p> In [4]:= DiracSimplify [DiracSlash [p], DiracSlash [-q] + m, DiracSlash [p]] Out [4]= gs [q] p.p + m p.p - 2 gs [p] p.q This is fl 5 fl = fl fl 5 . In <ref> [5] </ref>:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . <p> In [2]:= Tr [DiracSlash [a, b, c, d]] Out [2]= 4 a.d b.c - 4 a.c b.d + 4 a.b c.d tr ( fl a fl b fl c fl d fl 5 ) = 4 i " abcd . In [3]:= Tr <ref> [DiracMatrix [a, b, c, d, 5] </ref>] Out [3]= -4 I eps [a, b, c, d] You may include metric tensors or four-vectors, for example, tr ( 1 4 g fffi fl fl ff p ) = p fi . <p> In [2]:= Tr [DiracSlash [a, b, c, d]] Out [2]= 4 a.d b.c - 4 a.c b.d + 4 a.b c.d tr ( fl a fl b fl c fl d fl 5 ) = 4 i " abcd . In [3]:= Tr [DiracMatrix <ref> [a, b, c, d, 5] </ref>] Out [3]= -4 I eps [a, b, c, d] You may include metric tensors or four-vectors, for example, tr ( 1 4 g fffi fl fl ff p ) = p fi . <p> Some of the examples here verify the results given in [9]. Consider a trace corresponding to the square of the s-channel diagram for fle scattering: T 1 = 16 Set the abbreviations for Dirac matrices and slashes here. In <ref> [5] </ref>:= ( PP = DiracSlash [p']; P = DiracSlash [p]; K = DiracSlash [k]; A = DiracMatrix [al]; B = DiracMatrix [be] ) This is the input for trace T 1 . The CPU time needed for the calculation is of the order of seconds. <p> In [3]:= T [9] Time = 1.8 min 2 3 4 5 6 7 8 9 The trace of 20 Dirac matrices. In [4]:= T [10] Time = 7.2 min 2 3 4 5 6 7 8 9 10 With 22 Dirac matrices it gets slow. In <ref> [5] </ref>:= T [11] Time = 55. min 2 3 4 5 6 7 8 9 10 11 20 Guide to FeynCalc 1.0 2.5 Gell-Mann Traces and Contraction of Color Indices GellMannTrace [expr] calculates traces of Gell-Mann matrices The function for trace calculation of a matrices. <p> In [4]:= GellMannTrace [SU3F [a, b, c] GellMannMatrix [a, b, c]] Out [4]= 48 I tr (f ars f brs ) = 3 f ars f brs = 9 ffi ab . In <ref> [5] </ref>:= GellMannTrace [SU3F [a, r, s] SU3F [b, r, s]] Out [5]= 9 d [a, b] A non trivial case: tr ( a c e d f abe f bcd ) = 0. This takes a few seconds. <p> In [4]:= GellMannTrace [SU3F [a, b, c] GellMannMatrix [a, b, c]] Out [4]= 48 I tr (f ars f brs ) = 3 f ars f brs = 9 ffi ab . In <ref> [5] </ref>:= GellMannTrace [SU3F [a, r, s] SU3F [b, r, s]] Out [5]= 9 d [a, b] A non trivial case: tr ( a c e d f abe f bcd ) = 0. This takes a few seconds. <p> The coefficient functions of the tensor integrals are defined similar to [2], except that the Passarino-Veltman integrals take internal masses squared as arguments. A wrapper Fortran program to link FF a Fortran program by G.J. van Oldenborgh <ref> [5] </ref> for the evaluation of the scalar n-point integrals and FeynCalc is available from the author. <p> In [3]:= (SetOptions [A0, A0ToB0 -&gt; False]; SetOptions [-B1, B00, B11-, BReduce -&gt; False]); This is the scalar Passarino-Veltman one-point function. In [4]:= PaVe [0, --, -m02-] Out [4]= A0 [m02] This is the two-point function B 0 (p 2 ; m 2 1 ). In <ref> [5] </ref>:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). <p> In [4]:= PaVe [0, --, -m02-] Out [4]= A0 [m02] This is the two-point function B 0 (p 2 ; m 2 1 ). In <ref> [5] </ref>:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). In [6]:= PaVe [1, -pp-, -m12, m22-] Out [6]= B1 [pp, m12, m22] Coefficient functions of metric tensors have two 0 indices for each g -. <p> In [4]:= PaVeReduce [ PaVe [2, -Small [me2], mw2, t-, -Small [me2], 0, mw2- ] ] Out [4]= - Break down the coefficient function C 12 (s; m 2 ; m 2 ; m 2 ; m 2 ; M 2 ). This is the result in HoldForm. In <ref> [5] </ref>:= c12 = PaVeReduce [ PaVe [1, 2, -s, m2, m2-, -m2, m2, M2-], IsolateHead -&gt; K ] Out [5]= K [11] The FullForm of the assignment to c12 is HoldForm [K [11]]. <p> This is the result in HoldForm. In <ref> [5] </ref>:= c12 = PaVeReduce [ PaVe [1, 2, -s, m2, m2-, -m2, m2, M2-], IsolateHead -&gt; K ] Out [5]= K [11] The FullForm of the assignment to c12 is HoldForm [K [11]]. If you want to get the value of K [11], you can either type ReleaseHold [c12] or K [11] as done in the example. <p> If you want to get the value of K [11], you can either type ReleaseHold [c12] or K [11] as done in the example. In [6]:= K [11] Out [6]= - + - + - + - K <ref> [5] </ref> 2 K [5] - 2 m2 K [5] 3 One-Loop Calculations 25 Repeated application of ReleaseHold reinserts all K. <p> If you want to get the value of K [11], you can either type ReleaseHold [c12] or K [11] as done in the example. In [6]:= K [11] Out [6]= - + - + - + - K <ref> [5] </ref> 2 K [5] - 2 m2 K [5] 3 One-Loop Calculations 25 Repeated application of ReleaseHold reinserts all K. <p> If you want to get the value of K [11], you can either type ReleaseHold [c12] or K [11] as done in the example. In [6]:= K [11] Out [6]= - + - + - + - K <ref> [5] </ref> 2 K [5] - 2 m2 K [5] 3 One-Loop Calculations 25 Repeated application of ReleaseHold reinserts all K. <p> In <ref> [5] </ref>:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. <p> In <ref> [5] </ref>:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA [1], MA [2] - In this way you can generate a Fortran file. <p> (0,2) + - K (239)*MBM (2,1) + K (240)*MBM (2,2) K (242) = 2*ALP4PI*FLUFAC*K (241) EEZHBOXES = K (242) Fortran output file "eezhb.for" generated by OneLoopSum for e + e ! ZH. 36 Guide to FeynCalc 1.0 K [1] = 2*MH2 - MZ2 K [3] = 1 - 2*SW2 K <ref> [5] </ref> = MH2 + 2*MZ2 K [7] = MH2 - 3*MZ2 K [9] = 2*MH2^2 + 4*MH2*MZ2 + MZ2^2 K [11] = MH2 - 7*MZ2 K [13] = 3*MH2 - 2*MZ2 K [15] = 2*MW2 - MZ2 K [17] = 3*MH2 + 4*MZ2 K [19] = MH2 + 5*MZ2 K [21] <p> In [4]:= test = (a - b) x + (b a) y Out [4]= (a - b) x + (-a + b) y Mapping Factor on the summands shows that no canonical factorization of integers in sums takes place. In <ref> [5] </ref>:= Map [Factor, test] Out [5]= (a - b) x + (-a + b) y If a canonical factorization is desired, you may use Factor2 instead. In [6]:= Map [Factor2, test] Out [6]= (a - b) x - (a - b) y This is the overall factorization of Factor. <p> In [4]:= test = (a - b) x + (b a) y Out [4]= (a - b) x + (-a + b) y Mapping Factor on the summands shows that no canonical factorization of integers in sums takes place. In <ref> [5] </ref>:= Map [Factor, test] Out [5]= (a - b) x + (-a + b) y If a canonical factorization is desired, you may use Factor2 instead. In [6]:= Map [Factor2, test] Out [6]= (a - b) x - (a - b) y This is the overall factorization of Factor. <p> In [4]:= - K [1], test, ReleaseHold [test] - Out [4]= -a + b, e + f K [1] + f K [2], For the term (b + c (y + z)) a single abbreviation F [2] is returned. In <ref> [5] </ref>:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a [z] F [2] With the help of an additional function it is easy to introduce identical abbreviations for each subsum. <p> In <ref> [5] </ref>:= Isolate [a [z] (b + c (y + z)) + d [z] (y + z), -a, d-, IsolateHead -&gt; F] Out [5]= d [z] F [1] + a [z] F [2] With the help of an additional function it is easy to introduce identical abbreviations for each subsum. This trick of selectively substituting functions for sums is also quite useful in special reordering of polynomials. <p> In [4]:= !!test.for K (1) = a - b test = z + K (2) This writes a file in Macysma format. In [4]:= Write2 ["test.mac", test = tpol, FormatType -&gt; MacsymaForm]; Here the Macsyma format can be seen. In <ref> [5] </ref>:= !!test.mac test : ( 2*%i*%pi + z + (a - b)*f (x) )$ Here we get a file with Maple conventions. In [5]:= Write2 ["test.map", test = tpol, FormatType -&gt; MapleForm]; The Maple conventions are only slightly different. <p> In [4]:= Write2 ["test.mac", test = tpol, FormatType -&gt; MacsymaForm]; Here the Macsyma format can be seen. In <ref> [5] </ref>:= !!test.mac test : ( 2*%i*%pi + z + (a - b)*f (x) )$ Here we get a file with Maple conventions. In [5]:= Write2 ["test.map", test = tpol, FormatType -&gt; MapleForm]; The Maple conventions are only slightly different. <p> Use the Chisholm identity for " abcd fl fl a . In <ref> [5] </ref>:= EpsChisholm [ LeviCivita [a, b, c, d] DiracMatrix [mu, a] ] Out [5]= +I (-(g [c, d] ga [mu] ga [b] ga [5]) + g [b, c] ga [mu] ga [d] ga [5] + 42 Guide to FeynCalc 1.0 Eps [a, b, c, d] internal representation of Levi-Civita tensors, where <p> Use the Chisholm identity for " abcd fl fl a . In <ref> [5] </ref>:= EpsChisholm [ LeviCivita [a, b, c, d] DiracMatrix [mu, a] ] Out [5]= +I (-(g [c, d] ga [mu] ga [b] ga [5]) + g [b, c] ga [mu] ga [d] ga [5] + 42 Guide to FeynCalc 1.0 Eps [a, b, c, d] internal representation of Levi-Civita tensors, where the arguments must have head LorentzIndex or Momentum The internal function for Levi-Civita <p> Use the Chisholm identity for " abcd fl fl a . In <ref> [5] </ref>:= EpsChisholm [ LeviCivita [a, b, c, d] DiracMatrix [mu, a] ] Out [5]= +I (-(g [c, d] ga [mu] ga [b] ga [5]) + g [b, c] ga [mu] ga [d] ga [5] + 42 Guide to FeynCalc 1.0 Eps [a, b, c, d] internal representation of Levi-Civita tensors, where the arguments must have head LorentzIndex or Momentum The internal function for Levi-Civita tensors, see also section 4.4.9. This clears $PrePrint. <p> Use the Chisholm identity for " abcd fl fl a . In <ref> [5] </ref>:= EpsChisholm [ LeviCivita [a, b, c, d] DiracMatrix [mu, a] ] Out [5]= +I (-(g [c, d] ga [mu] ga [b] ga [5]) + g [b, c] ga [mu] ga [d] ga [5] + 42 Guide to FeynCalc 1.0 Eps [a, b, c, d] internal representation of Levi-Civita tensors, where the arguments must have head LorentzIndex or Momentum The internal function for Levi-Civita tensors, see also section 4.4.9. This clears $PrePrint. In [6]:= $PrePrint=. This shows the internal structure. <p> In [4]:= DiracSlash [q] . DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. In <ref> [5] </ref>:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. In [6]:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. <p> In [4]:= DiracSlash [q] . DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. In <ref> [5] </ref>:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. In [6]:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. <p> In the following example the automatic loading of FeynCalc from the init.m file has been turned off. Set the variable $BreitMaison before loading FeynCalc. In [1]:= $BreitMaison = True Out [1]= True Loading FeynCalc. In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In [3]:= DiracMatrix <ref> [5] </ref> . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! <p> Set the variable $BreitMaison before loading FeynCalc. In [1]:= $BreitMaison = True Out [1]= True Loading FeynCalc. In [2]:= &lt;<FeynCalc.m Entering fl 5 fl , with fl D-dimensional. In [3]:= DiracMatrix <ref> [5] </ref> . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector <p> In [3]:= DiracMatrix <ref> [5] </ref> . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In [6]:= DiracSimplify [%] ga [mu] ga [5] <p> In [3]:= DiracMatrix <ref> [5] </ref> . DiracMatrix [mu, Dimension -&gt;D] Out [3]= ga [5] ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In [6]:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - <p> ga <ref> [5] </ref> ga [mu] 46 Guide to FeynCalc 1.0 Now only the 4-dimensional part of fl anticommutes, while the D 4 dimensional one commutes. In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga [5] + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In [6]:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - + - + - This is FeynCalc does not simplify this sum <p> In [4]:= DiracSimplify [%] Out [4]= -ga [mu] ga <ref> [5] </ref> + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In [6]:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - + - + - This is FeynCalc does not simplify this sum directly, but you can easily specify which dimension to "eliminate". <p> <ref> [5] </ref> + ga [mu] ga [5] The chirality projectors ! + and ! are inserted automatically. In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In [6]:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - + - + - This is FeynCalc does not simplify this sum directly, but you can easily specify which dimension to "eliminate".
Reference: [6] <institution> P.Cvitanovic, Phys. </institution> <note> Rev. D 14 (1976) 1536. </note>
Reference-contexts: In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In [5]:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In <ref> [6] </ref>:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In [7]:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . <p> In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In [5]:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In <ref> [6] </ref>:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In [7]:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . <p> DiracSlash [p, q, ...] Feynman slashes p= q= . . . DiracMatrix [5] fl 5 ChiralityProjector [+1] ! + = (1 + fl 5 )=2 DiracMatrix <ref> [6] </ref> fl 6 = (1 + fl 5 )=2 ChiralityProjector [-1] ! = (1 fl 5 )=2 DiracMatrix [7] fl 7 = (1 fl 5 )=2 Various input functions for Dirac matrices. A Dirac matrix fl is represented by DiracMatrix [mu]. <p> This is how you enter (p= + q= + m) fl . In [1]:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix <ref> [ro, 5, mu, 6, al, 7] </ref> Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix [ro, 5, mu, 6, al, 7] Out [2]= ga [ro] ga [5] ga [mu] ga <ref> [6] </ref> ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. In [3]:= DiracMatrix [mu . 5 . nu . 6 . ro . 7] Out [3]= ga [mu] ga [5] ga [nu] ga <ref> [6] </ref> ga [ro] ga [7] This is a four-dimensional product: 2b= a= 2 (d= c=) (6 q= 3 p=). DiracSlash pulls common numerical factors out. <p> In [5]:= DiracSlash [(2 b) . a . (2 (d - c)) . (6 q - 3 p)] Out [5]= 12 gs [b] gs [a] gs [c - d] gs [p - 2 q] Slashed polarization vectors "= (k) are entered in this way. In <ref> [6] </ref>:= DiracSlash [Polarization [k]] Out [6]= gs [ep [k]] option name default value Dimension 4 space-time dimension Option for DiracMatrix and DiracSlash. As settings for Dimension 4, a Mathematica Symbol dim, or dim 4 are possible. 10 Guide to FeynCalc 1.0 Entering of a D-dimensional fl . <p> In <ref> [6] </ref>:= DiracSlash [Polarization [k]] Out [6]= gs [ep [k]] option name default value Dimension 4 space-time dimension Option for DiracMatrix and DiracSlash. As settings for Dimension 4, a Mathematica Symbol dim, or dim 4 are possible. 10 Guide to FeynCalc 1.0 Entering of a D-dimensional fl . <p> In [5]:= Contract [LeviCivita [mu, nu, ro, si] FourVector [p, si]] Out [5]= eps [mu, nu, ro, p] The contraction of " ff- " fi- yields 6 g fffi . In <ref> [6] </ref>:= Contract [LeviCivita [a, n, r, s] LeviCivita [b, n, r, s], EpsContract -&gt; True ] Out [6]= -6 g [a, b] option name default value EpsContract False whether to contract Levi-Civita Eps Expanding True whether to expand the input Factoring False whether to factor canonically Options for Contract. <p> In [5]:= Contract [LeviCivita [mu, nu, ro, si] FourVector [p, si]] Out [5]= eps [mu, nu, ro, p] The contraction of " ff- " fi- yields 6 g fffi . In <ref> [6] </ref>:= Contract [LeviCivita [a, n, r, s] LeviCivita [b, n, r, s], EpsContract -&gt; True ] Out [6]= -6 g [a, b] option name default value EpsContract False whether to contract Levi-Civita Eps Expanding True whether to expand the input Factoring False whether to factor canonically Options for Contract. <p> These special values are inserted immediately whenever possible during the calculation. Set q 2 = 0 before a calculation. In [5]:= ScalarProduct [q, q] = 0 Out [5]= 0 Expanding the result of the contraction q ff (p q) ff now yields (p q). In <ref> [6] </ref>:= ExpandScalarProduct [Out [2]] Out [6]= p.q This expands (a + b) to a + b . <p> Set q 2 = 0 before a calculation. In [5]:= ScalarProduct [q, q] = 0 Out [5]= 0 Expanding the result of the contraction q ff (p q) ff now yields (p q). In <ref> [6] </ref>:= ExpandScalarProduct [Out [2]] Out [6]= p.q This expands (a + b) to a + b . <p> In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In <ref> [6] </ref>:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . <p> In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify [DiracMatrix <ref> [6, nu, 7, mu] </ref>] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. <p> In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In <ref> [6] </ref>:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. <p> In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In <ref> [6] </ref>:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. In [8]:= DiracSimplify [(DiracSlash [p] + m) . <p> In [5]:= ( PP = DiracSlash [p']; P = DiracSlash [p]; K = DiracSlash [k]; A = DiracMatrix [al]; B = DiracMatrix [be] ) This is the input for trace T 1 . The CPU time needed for the calculation is of the order of seconds. In <ref> [6] </ref>:= Tr [PP + m,A,P + K + m,B,P + m,B,P + K + m,A/16] Out [6]= 4 m + 4 m k.k + 4 m k.p - 4 m k.p' + 2 k.p k.p' + 2 k.p' p.p - 3 m p.p' - k.k p.p' + p.p p.p' Another nontrivial <p> The CPU time needed for the calculation is of the order of seconds. In <ref> [6] </ref>:= Tr [PP + m,A,P + K + m,B,P + m,B,P + K + m,A/16] Out [6]= 4 m + 4 m k.k + 4 m k.p - 4 m k.p' + 2 k.p k.p' + 2 k.p' p.p - 3 m p.p' - k.k p.p' + p.p p.p' Another nontrivial example is a D-dimensional trace involving 14 Dirac matrices: T 2 = tr ( fl fi <p> The matrices 1 2 a are the infinitesimal generators of the group SU (3). Similar to the case of Dirac traces, also traces of the Gell-Mann matrices a are calculated algebraically. The Cvitanovic algorithm <ref> [6] </ref> is im-plemened similar to [7]. Traces with no free color indices are always evaluated to a number. Otherwise only special cases are simplified. tr ( a b ) = 2 ffi ab . <p> In [5]:= GellMannTrace [SU3F [a, r, s] SU3F [b, r, s]] Out [5]= 9 d [a, b] A non trivial case: tr ( a c e d f abe f bcd ) = 0. This takes a few seconds. In <ref> [6] </ref>:= GellMannTrace [ GellMannMatrix [a, c, e, d] * SU3F [a, b, e] SU3F [b, c, d] ] Repeated indices of ffi ab and f a b c can always be contracted with the Cvitanovic algorithm. 16f ars f brs = 48 ffi ab . <p> In [5]:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). In <ref> [6] </ref>:= PaVe [1, -pp-, -m12, m22-] Out [6]= B1 [pp, m12, m22] Coefficient functions of metric tensors have two 0 indices for each g -. <p> In [5]:= PaVe [0, -pp-, -m02, m12-] Out [5]= B0 [pp, m02, m12] Here is the coefficient function B 1 (p 2 ; m 2 1 ). In <ref> [6] </ref>:= PaVe [1, -pp-, -m12, m22-] Out [6]= B1 [pp, m12, m22] Coefficient functions of metric tensors have two 0 indices for each g -. <p> If you want to get the value of K [11], you can either type ReleaseHold [c12] or K [11] as done in the example. In <ref> [6] </ref>:= K [11] Out [6]= - + - + - + - K [5] 2 K [5] - 2 m2 K [5] 3 One-Loop Calculations 25 Repeated application of ReleaseHold reinserts all K. <p> If you want to get the value of K [11], you can either type ReleaseHold [c12] or K [11] as done in the example. In <ref> [6] </ref>:= K [11] Out [6]= - + - + - + - K [5] 2 K [5] - 2 m2 K [5] 3 One-Loop Calculations 25 Repeated application of ReleaseHold reinserts all K. <p> Set the p i on-shell and (p 1 p 2 ) = k 2 =2, where k denotes the momentum of the W. In [2]:= (gc [i _ ] := g [i, "-"] DiracMatrix [7] + g [i, "+"] DiracMatrix <ref> [6] </ref>; ScalarProduct [p1, p1] = 0; ScalarProduct [p2, p2] = 0; ScalarProduct [p1, p2] = k2/2); The analytical expression for the generic diagram is: ffiM 1 = i (2) 4 R (2) 4D d D q u (p 1 ) fl - (g 1 ! + ) (q= + p=) 3 <p> 0, M2] + 2 k2 C0 [0, 0, k2, 0, M2, 0] + 2 k2 PaVe [1, -k2, 0, 0-, -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [6] </ref> u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 This reduces the result to scalar integrals. The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. <p> This is achieved by using Combine. In [4]:= Wff1 = PaVeReduce [Wff1] // Combine Out [4]= ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [6] </ref> u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. <p> In [5]:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [6] </ref> u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA [1], MA [2] - In this way you can generate a Fortran file. <p> In [5]:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [6] </ref> u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA [1], MA [2] - In this way you can generate a Fortran file. With replacements you can adapt the result to your other Fortran code. <p> The other definitions are convenient abbreviations: R for the right-handed projection operator fl 6 , L for the left-handed projection operator fl 7 , short mnemonic functions like G, FV and feynden stand for metric tensors, four-vectors and denominators of propagators. In [1]:= (R = DiracMatrix <ref> [6] </ref>; L = DiracMatrix [7]; ScalarProduct [p1, p1] = ScalarProduct [p2, p2] = 0; ScalarProduct [p1, p2] = k2/2 ; SetOptions [ OneLoop, Factoring -&gt; True, FormatType -&gt; FortranForm, ReduceToScalars -&gt; True, WriteOut-&gt;True, FinalSubstitutions -&gt; -g [i _ , "+"] -&gt; gp [i], g [i _ , "-"] -&gt; gm [i], <p> In [5]:= Map [Factor, test] Out [5]= (a - b) x + (-a + b) y If a canonical factorization is desired, you may use Factor2 instead. In <ref> [6] </ref>:= Map [Factor2, test] Out [6]= (a - b) x - (a - b) y This is the overall factorization of Factor. <p> In [5]:= Map [Factor, test] Out [5]= (a - b) x + (-a + b) y If a canonical factorization is desired, you may use Factor2 instead. In <ref> [6] </ref>:= Map [Factor2, test] Out [6]= (a - b) x - (a - b) y This is the overall factorization of Factor. In [7]:= Factor [test] Out [7]= (-a + b) (-x + y) Here the convention used by Factor2 becomes clear: the first term in a subsum gets a positive prefactor. <p> This trick of selectively substituting functions for sums is also quite useful in special reordering of polynomials. In <ref> [6] </ref>:= ( und [x __ ] := Isolate [Plus [x], IsolateHead -&gt; H]/; FreeQ2 [-x-, -a, d-]; (a [z] (b + c (y + z)) + d [z] (y + z))/. <p> In [5]:= !!test.mac test : ( 2*%i*%pi + z + (a - b)*f (x) )$ Here we get a file with Maple conventions. In [5]:= Write2 ["test.map", test = tpol, FormatType -&gt; MapleForm]; The Maple conventions are only slightly different. In <ref> [6] </ref>:= !!test.map test := ( 2*I*Pi + z + (a - b)*f (x) ); 4.5 More on Levi-Civita Tensors EpsEvaluate [expr] evaluate Levi-Civita Eps A function for total antisymmetry and linearity with respect to Momentum . This is " - (p + q) = " - (p+q) . <p> This clears $PrePrint. In <ref> [6] </ref>:= $PrePrint=. This shows the internal structure. In [7]:= LeviCivita [m, n, r, s] Out [7]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], LorentzIndex [s]] Contracting " - p yields " - p . In the internal representation the p has the head Momentum wrapped around it. <p> DiracSlash [q, Dimension -&gt; D] Out [4]= DiracGamma [Momentum [q]] . DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. In [5]:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. In <ref> [6] </ref>:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. In [7]:= FourVector [l, mu] Out [7]= Pair [LorentzIndex [mu], Momentum [l]] The dimension is provided as an argument. <p> DiracGamma [Momentum [q, D], D] This shows the convention for a four-dimensional scalar product. In [5]:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. In <ref> [6] </ref>:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. In [7]:= FourVector [l, mu] Out [7]= Pair [LorentzIndex [mu], Momentum [l]] The dimension is provided as an argument. <p> In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In <ref> [6] </ref>:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - + - + - This is FeynCalc does not simplify this sum directly, but you can easily specify which dimension to "eliminate". <p> In [5]:= ChiralityProjector [+1] . DiracMatrix [mu, Dimension -&gt;D] 1 ga [5] 2 2 D The expression is expanded and fl 5 is moved to the right. In <ref> [6] </ref>:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - + - + - This is FeynCalc does not simplify this sum directly, but you can easily specify which dimension to "eliminate".
Reference: [7] <author> A.P. Kryukov and A.Ya. </author> <title> Rodionov, </title> <journal> Comp. Phys. Comm. </journal> <volume> 48 (1988) 327. </volume>
Reference-contexts: In [4]:= % /. D -&gt; 4 In four dimensions g ff ff = 4. In [5]:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In <ref> [7] </ref>:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . In [8]:= FourVector [p - 2 q, mu] Out [8]= (p - 2 q)[mu] Providing (2 q p) yields (p 2 q) . <p> In [5]:= MetricTensor [al, al] Out [5]= 4 While in D dimensions g ff ff = D. In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In <ref> [7] </ref>:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . In [8]:= FourVector [p - 2 q, mu] Out [8]= (p - 2 q)[mu] Providing (2 q p) yields (p 2 q) . <p> DiracSlash [p, q, ...] Feynman slashes p= q= . . . DiracMatrix [5] fl 5 ChiralityProjector [+1] ! + = (1 + fl 5 )=2 DiracMatrix [6] fl 6 = (1 + fl 5 )=2 ChiralityProjector [-1] ! = (1 fl 5 )=2 DiracMatrix <ref> [7] </ref> fl 7 = (1 fl 5 )=2 Various input functions for Dirac matrices. A Dirac matrix fl is represented by DiracMatrix [mu]. For p= = p fl you may use DiracSlash [p]. <p> This is how you enter (p= + q= + m) fl . In [1]:= (DiracSlash [p + q] + m) . DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix <ref> [ro, 5, mu, 6, al, 7] </ref> Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga [7] This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> DiracMatrix [mu] Out [1]= (gs [p + q] + m) ga [mu] Here is fl fl 5 fl fl 6 fl fl 7 . In [2]:= DiracMatrix [ro, 5, mu, 6, al, 7] Out [2]= ga [ro] ga [5] ga [mu] ga [6] ga [al] ga <ref> [7] </ref> This is an alternative input variety. Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. <p> Note that the spaces around the . are essential when fl 5 ; fl 6 and fl 7 are involved. In [3]:= DiracMatrix [mu . 5 . nu . 6 . ro . 7] Out [3]= ga [mu] ga [5] ga [nu] ga [6] ga [ro] ga <ref> [7] </ref> This is a four-dimensional product: 2b= a= 2 (d= c=) (6 q= 3 p=). DiracSlash pulls common numerical factors out. <p> As settings for Dimension 4, a Mathematica Symbol dim, or dim 4 are possible. 10 Guide to FeynCalc 1.0 Entering of a D-dimensional fl . The dimension is displayed as an index in the FeynCalcForm. In <ref> [7] </ref>:= DiracMatrix [mu, Dimension -&gt; D] Out [7]= ga [mu] This is fl fl in D 4 dimensions. <p> As settings for Dimension 4, a Mathematica Symbol dim, or dim 4 are possible. 10 Guide to FeynCalc 1.0 Entering of a D-dimensional fl . The dimension is displayed as an index in the FeynCalcForm. In <ref> [7] </ref>:= DiracMatrix [mu, Dimension -&gt; D] Out [7]= ga [mu] This is fl fl in D 4 dimensions. In [8]:= DiracMatrix [mu, mu, Dimension -&gt; D - 4] Out [8]= ga [mu] ga [mu] 1.3 Entering Gell-Mann Matrices and SU (3) Structure Constants FeynCalc is not a package especially designed for QCD calculations. <p> Contracting only g ff p ff p in g ff p ff p (q fi + r fi ) (p fi s fi ). In <ref> [7] </ref>:= Contract [ MetricTensor [al, si] * FourVector [p, al] FourVector [p, si] * ( FourVector [q, be] + FourVector [r, be] ) * ( FourVector [p, be] - FourVector [q, be] ), Expanding -&gt; False ] Out [7]= p.p (p [be] - q [be]) (q [be] + r [be]) FeynCalc <p> In <ref> [7] </ref>:= Contract [ MetricTensor [al, si] * FourVector [p, al] FourVector [p, si] * ( FourVector [q, be] + FourVector [r, be] ) * ( FourVector [p, be] - FourVector [q, be] ), Expanding -&gt; False ] Out [7]= p.p (p [be] - q [be]) (q [be] + r [be]) FeynCalc uses the transversality condition (k " (k)) = 0 for polarization vectors. <p> In [5]:= ScalarProduct [q, q] = 0 Out [5]= 0 Expanding the result of the contraction q ff (p q) ff now yields (p q). In [6]:= ExpandScalarProduct [Out [2]] Out [6]= p.q This expands (a + b) to a + b . In <ref> [7] </ref>:= ExpandScalarProduct [FourVector [a + b, mu]] Out [7]= a [mu] + b [mu] 2.3 Simplification of Products of Dirac Matrices and Spinors For the simplification of noncommutative products of Dirac matrices and spinors, two functions are provided: DiracOrder, which orders products of Dirac matrices in a canonical way, and DiracSimplify, <p> In [6]:= ExpandScalarProduct [Out [2]] Out [6]= p.q This expands (a + b) to a + b . In <ref> [7] </ref>:= ExpandScalarProduct [FourVector [a + b, mu]] Out [7]= a [mu] + b [mu] 2.3 Simplification of Products of Dirac Matrices and Spinors For the simplification of noncommutative products of Dirac matrices and spinors, two functions are provided: DiracOrder, which orders products of Dirac matrices in a canonical way, and DiracSimplify, which contracts Dirac matrices with equal indices, moves <p> In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify <ref> [DiracMatrix [6, nu, 7, mu] </ref>] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. <p> In [5]:= DiracSimplify [DiracMatrix [5], DiracMatrix [mu]] Out [5]= -ga [mu] ga [5] fl 6 fl - fl 7 fl = fl - fl fl 6 . In [6]:= DiracSimplify [DiracMatrix <ref> [6, nu, 7, mu] </ref>] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. <p> In [6]:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In <ref> [7] </ref>:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. In [8]:= DiracSimplify [(DiracSlash [p] + m) . <p> In [6]:= DiracSimplify [DiracMatrix [6, nu, 7, mu]] Out [6]= ga [nu] ga [mu] ga [6] This is (p= m) u (p) = 0. In <ref> [7] </ref>:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. In [8]:= DiracSimplify [(DiracSlash [p] + m) . Spinor [-p, m]] Out [8]= 0 For the conjugate spinor: u (p= m) = 0. <p> The last command sets P1 = p= 1 , P2 = p= 2 , P3 = p= 3 . In <ref> [7] </ref>:= ( a = DiracMatrix [al, Dimension -&gt; D]; b = DiracMatrix [be, Dimension -&gt; D]; n = DiracMatrix [nu, Dimension -&gt; D]; -P1, P2, P3- = Map [ DiracSlash, -p1, p2, p3- ]) Out [7]= -gs [p1], gs [p2], gs [p3]- 2 Elementary Calculations 17 Here is the input for <p> In <ref> [7] </ref>:= ( a = DiracMatrix [al, Dimension -&gt; D]; b = DiracMatrix [be, Dimension -&gt; D]; n = DiracMatrix [nu, Dimension -&gt; D]; -P1, P2, P3- = Map [ DiracSlash, -p1, p2, p3- ]) Out [7]= -gs [p1], gs [p2], gs [p3]- 2 Elementary Calculations 17 Here is the input for trace T 2 . The result is again collected with respect to scalar products. <p> The matrices 1 2 a are the infinitesimal generators of the group SU (3). Similar to the case of Dirac traces, also traces of the Gell-Mann matrices a are calculated algebraically. The Cvitanovic algorithm [6] is im-plemened similar to <ref> [7] </ref>. Traces with no free color indices are always evaluated to a number. Otherwise only special cases are simplified. tr ( a b ) = 2 ffi ab . In [1]:= GellMannTrace [GellMannMatrix [a, b]] Out [1]= 2 d [a, b] tr (3 a b a b ) = 32. <p> The structure constants are replaced by traces. In <ref> [7] </ref>:= 16 SU3F [a, r, s] SU3F [b, r, s] (-tr [la [b] la [r] la [s]] + tr [la [b] la [s] la [r]])) Expanding forces the products of traces to simplify, if there are indices to contract. <p> In [6]:= PaVe [1, -pp-, -m12, m22-] Out [6]= B1 [pp, m12, m22] Coefficient functions of metric tensors have two 0 indices for each g -. In <ref> [7] </ref>:= PaVe [0,0, -pp-, -m02, m12-] Out [7]= B00 [pp, m02, m12] This is B 11 (p 2 1 ; m 0 ; m 1 ), the coefficient function of p 1 p 1- of B -. <p> In [6]:= PaVe [1, -pp-, -m12, m22-] Out [6]= B1 [pp, m12, m22] Coefficient functions of metric tensors have two 0 indices for each g -. In <ref> [7] </ref>:= PaVe [0,0, -pp-, -m02, m12-] Out [7]= B00 [pp, m02, m12] This is B 11 (p 2 1 ; m 0 ; m 1 ), the coefficient function of p 1 p 1- of B -. <p> In [6]:= K [11] Out [6]= - + - + - + - K [5] 2 K [5] - 2 m2 K [5] 3 One-Loop Calculations 25 Repeated application of ReleaseHold reinserts all K. In <ref> [7] </ref>:= FixedPoint [ReleaseHold [#]&, c12] 1 (m2 - M2) B0 [0, m2, M2] 2 (4 m2 - s) 2 m2 (4 m2 - s) (8 m2 - 10 m2 M2 - 2 m2 s + M2 s) B0 [m2, m2, M2] 2 (4 m2 - 6 M2 - s) B0 [s, <p> Set the p i on-shell and (p 1 p 2 ) = k 2 =2, where k denotes the momentum of the W. In [2]:= (gc [i _ ] := g [i, "-"] DiracMatrix <ref> [7] </ref> + g [i, "+"] DiracMatrix [6]; ScalarProduct [p1, p1] = 0; ScalarProduct [p2, p2] = 0; ScalarProduct [p1, p2] = k2/2); The analytical expression for the generic diagram is: ffiM 1 = i (2) 4 R (2) 4D d D q u (p 1 ) fl - (g 1 ! <p> -0, 0, M2-] + 4 PaVe [0, 0, -k2, 0, 0-, -0, 0, M2-]) (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [7] </ref> u [p2]])) " 2 This reduces the result to scalar integrals. The default result of PaVeReduce is not put over a common denominator. This is achieved by using Combine. <p> ((2 k2 - 2 (2 k2 + M2) B0 [0, 0, M2] + 2 (g [1, +] g [2, +] g [3, +] StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]] + g [1, -] g [2, -] g [3, -] StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [7] </ref> u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. In [5]:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- <p> [k]] ga <ref> [7] </ref> u [p2]])) " 2 28 Guide to FeynCalc 1.0 With this command you can extract the standard matrix elements. In [5]:= var = Select [Variables [Wff1], (Head [#]===StandardMatrixElement)&] Out [5]= -StandardMatrixElement [u [p1] gs [ep [k]] ga [6] u [p2]], StandardMatrixElement [u [p1] gs [ep [k]] ga [7] u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA [1], MA [2] - In this way you can generate a Fortran file. With replacements you can adapt the result to your other Fortran code. In [7]:= Write2 ["Wff1.for", vert = Wff1 /. g <p> StandardMatrixElement [u [p1] gs [ep [k]] ga <ref> [7] </ref> u [p2]]- Here the StandardMatrixElement are set to some abbreviations. In [6]:= Set @@ -var, -MA [1], MA [2] - In this way you can generate a Fortran file. With replacements you can adapt the result to your other Fortran code. In [7]:= Write2 ["Wff1.for", vert = Wff1 /. g [i _ , "+"] -&gt; gp [i] /. g [i _ , "-"] -&gt; FormatType -&gt; FortranForm ] Show the content of the file. <p> In [1]:= (R = DiracMatrix [6]; L = DiracMatrix <ref> [7] </ref>; ScalarProduct [p1, p1] = ScalarProduct [p2, p2] = 0; ScalarProduct [p1, p2] = k2/2 ; SetOptions [ OneLoop, Factoring -&gt; True, FormatType -&gt; FortranForm, ReduceToScalars -&gt; True, WriteOut-&gt;True, FinalSubstitutions -&gt; -g [i _ , "+"] -&gt; gp [i], g [i _ , "-"] -&gt; gm [i], StandardMatrixElement -&gt; MAT]; G <p> + K (240)*MBM (2,2) K (242) = 2*ALP4PI*FLUFAC*K (241) EEZHBOXES = K (242) Fortran output file "eezhb.for" generated by OneLoopSum for e + e ! ZH. 36 Guide to FeynCalc 1.0 K [1] = 2*MH2 - MZ2 K [3] = 1 - 2*SW2 K [5] = MH2 + 2*MZ2 K <ref> [7] </ref> = MH2 - 3*MZ2 K [9] = 2*MH2^2 + 4*MH2*MZ2 + MZ2^2 K [11] = MH2 - 7*MZ2 K [13] = 3*MH2 - 2*MZ2 K [15] = 2*MW2 - MZ2 K [17] = 3*MH2 + 4*MZ2 K [19] = MH2 + 5*MZ2 K [21] = MH2 + 4*MZ2 K [23] <p> In [6]:= Map [Factor2, test] Out [6]= (a - b) x - (a - b) y This is the overall factorization of Factor. In <ref> [7] </ref>:= Factor [test] Out [7]= (-a + b) (-x + y) Here the convention used by Factor2 becomes clear: the first term in a subsum gets a positive prefactor. <p> In [6]:= Map [Factor2, test] Out [6]= (a - b) x - (a - b) y This is the overall factorization of Factor. In <ref> [7] </ref>:= Factor [test] Out [7]= (-a + b) (-x + y) Here the convention used by Factor2 becomes clear: the first term in a subsum gets a positive prefactor. <p> Plus -&gt; und /. und -&gt; Plus ) Here it is clear that H [1] = (y + z) is part of H [2]. In <ref> [7] </ref>:= ReleaseHold [%] Out [7]= (y + z) d [z] + a [z] (b + c H [1]) Decreasing the option IsolateSplit significantly forces Isolate to use more than one L for a - b - c - d - e. <p> Plus -&gt; und /. und -&gt; Plus ) Here it is clear that H [1] = (y + z) is part of H [2]. In <ref> [7] </ref>:= ReleaseHold [%] Out [7]= (y + z) d [z] + a [z] (b + c H [1]) Decreasing the option IsolateSplit significantly forces Isolate to use more than one L for a - b - c - d - e. <p> This clears $PrePrint. In [6]:= $PrePrint=. This shows the internal structure. In <ref> [7] </ref>:= LeviCivita [m, n, r, s] Out [7]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], LorentzIndex [s]] Contracting " - p yields " - p . In the internal representation the p has the head Momentum wrapped around it. <p> This clears $PrePrint. In [6]:= $PrePrint=. This shows the internal structure. In <ref> [7] </ref>:= LeviCivita [m, n, r, s] Out [7]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], LorentzIndex [s]] Contracting " - p yields " - p . In the internal representation the p has the head Momentum wrapped around it. <p> In [5]:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. In [6]:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. In <ref> [7] </ref>:= FourVector [l, mu] Out [7]= Pair [LorentzIndex [mu], Momentum [l]] The dimension is provided as an argument. In [8]:= MetricTensor [a, b, Dimension -&gt; d] Out [8]= Pair [LorentzIndex [a, d], LorentzIndex [b, d]] A (D 4)-dimensional four-vector. <p> In [5]:= DiracSimplify [%] Out [5]= Pair [Momentum [q], Momentum [q]] The head Pair is also used for metric tensors. In [6]:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. In <ref> [7] </ref>:= FourVector [l, mu] Out [7]= Pair [LorentzIndex [mu], Momentum [l]] The dimension is provided as an argument. In [8]:= MetricTensor [a, b, Dimension -&gt; d] Out [8]= Pair [LorentzIndex [a, d], LorentzIndex [b, d]] A (D 4)-dimensional four-vector. <p> In [6]:= DiracSimplify [%] ga [mu] ga [5] ga [mu] Out [6]= - + - + - This is FeynCalc does not simplify this sum directly, but you can easily specify which dimension to "eliminate". In <ref> [7] </ref>:= test = 2 DiracMatrix [mu] + DiracMatrix [mu, Dimension -&gt; D] + DiracMatrix [mu, Dimension -&gt; D-4] Out [7]= 2 ga [mu] + ga [mu] + ga [mu] Switch to the internal representation. <p> In <ref> [7] </ref>:= test = 2 DiracMatrix [mu] + DiracMatrix [mu, Dimension -&gt; D] + DiracMatrix [mu, Dimension -&gt; D-4] Out [7]= 2 ga [mu] + ga [mu] + ga [mu] Switch to the internal representation.
Reference: [8] <author> Matthias Jamin and E. Lautenbacher, </author> <title> TRACER, A Mathematica Package for fl-Algebra in Arbitrary Dimensions, </title> <institution> preprint Technische Universitat M unchen, TUM-T31-20/91. </institution>
Reference-contexts: In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In [7]:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . In <ref> [8] </ref>:= FourVector [p - 2 q, mu] Out [8]= (p - 2 q)[mu] Providing (2 q p) yields (p 2 q) . In [9]:= FourVector [2 q - p, mu] Out [9]= -(p - 2 q)[mu] In general numerical factors are pulled out in a standard way from FourVector. <p> In [6]:= MetricTensor [al, al, Dimension -&gt; D] Out [6]= D Enter a four-dimensional p . In [7]:= FourVector [p, mu] Out [7]= p [mu] You may also enter a sum of four-vectors: (p 2 q) . In <ref> [8] </ref>:= FourVector [p - 2 q, mu] Out [8]= (p - 2 q)[mu] Providing (2 q p) yields (p 2 q) . In [9]:= FourVector [2 q - p, mu] Out [9]= -(p - 2 q)[mu] In general numerical factors are pulled out in a standard way from FourVector. <p> The dimension is displayed as an index in the FeynCalcForm. In [7]:= DiracMatrix [mu, Dimension -&gt; D] Out [7]= ga [mu] This is fl fl in D 4 dimensions. In <ref> [8] </ref>:= DiracMatrix [mu, mu, Dimension -&gt; D - 4] Out [8]= ga [mu] ga [mu] 1.3 Entering Gell-Mann Matrices and SU (3) Structure Constants FeynCalc is not a package especially designed for QCD calculations. But some basic features for Gell Mann matrices are included. <p> The dimension is displayed as an index in the FeynCalcForm. In [7]:= DiracMatrix [mu, Dimension -&gt; D] Out [7]= ga [mu] This is fl fl in D 4 dimensions. In <ref> [8] </ref>:= DiracMatrix [mu, mu, Dimension -&gt; D - 4] Out [8]= ga [mu] ga [mu] 1.3 Entering Gell-Mann Matrices and SU (3) Structure Constants FeynCalc is not a package especially designed for QCD calculations. But some basic features for Gell Mann matrices are included. GellMannMatrix [a, b, ...] Gell-Mann matrices a b . . . <p> In <ref> [8] </ref>:= Contract [FourVector [k, mu] PolarizationVector [k, mu]] Out [8]= 0 14 Guide to FeynCalc 1.0 2.2 Simplification of Scalar Products and Four-Vectors ExpandScalarProduct [expr] expand scalar products and four-vectors in expr A function for expansion of scalar products and four-vectors. As an example expand (a + b) (c 2d). <p> In <ref> [8] </ref>:= Contract [FourVector [k, mu] PolarizationVector [k, mu]] Out [8]= 0 14 Guide to FeynCalc 1.0 2.2 Simplification of Scalar Products and Four-Vectors ExpandScalarProduct [expr] expand scalar products and four-vectors in expr A function for expansion of scalar products and four-vectors. As an example expand (a + b) (c 2d). <p> In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. In <ref> [8] </ref>:= DiracSimplify [(DiracSlash [p] + m) . Spinor [-p, m]] Out [8]= 0 For the conjugate spinor: u (p= m) = 0. In [9]:= DiracSimplify [Spinor [p, m] . (DiracSlash [p] - m)] Out [9]= 0 This is v q= (p= m) = 2 v p q. <p> In [7]:= DiracSimplify [(DiracSlash [p] - m) . Spinor [p, m]] Out [7]= 0 Here is the Dirac equation for v (p): (p= + m) v (p) = 0. In <ref> [8] </ref>:= DiracSimplify [(DiracSlash [p] + m) . Spinor [-p, m]] Out [8]= 0 For the conjugate spinor: u (p= m) = 0. In [9]:= DiracSimplify [Spinor [p, m] . (DiracSlash [p] - m)] Out [9]= 0 This is v q= (p= m) = 2 v p q. In [10]:= DiracSimplify [Spinor [-p, m] . <p> The result is again collected with respect to scalar products. In <ref> [8] </ref>:= Tr [b,a,P1,P2,n,b,P2,P3,a,P1,n,P3,P1,P2] Out [8]= (-1152 + 896 D - 224 D + 16 D ) p1.p2 p1.p3 p2.p2 + (1024 - 512 D + 64 D ) p1.p2 p1.p3 p2.p3 + (448 - 416 D + 112 D - 8 D ) p1.p1 p1.p3 p2.p2 p2.p3 + (-512 + 256 <p> The result is again collected with respect to scalar products. In <ref> [8] </ref>:= Tr [b,a,P1,P2,n,b,P2,P3,a,P1,n,P3,P1,P2] Out [8]= (-1152 + 896 D - 224 D + 16 D ) p1.p2 p1.p3 p2.p2 + (1024 - 512 D + 64 D ) p1.p2 p1.p3 p2.p3 + (448 - 416 D + 112 D - 8 D ) p1.p1 p1.p3 p2.p2 p2.p3 + (-512 + 256 D - 32 D <p> Defining T (n) = Tr (fl 1 fl 2 :::fl n fl 1 fl 2 :::fl n ) we give a list of timings and results for T (8) to T (11). The trace T (10) is a verification of the result given in <ref> [8] </ref>. This is a little program defining T. The dimension of each particular Dirac matrix is set to d 4. The timings are also displayed in FeynCalcForm, which yields more usual time units. <p> In [2]:= T <ref> [8] </ref> Time = 38. s 2 3 4 5 6 7 8 Here we have 18. In [3]:= T [9] Time = 1.8 min 2 3 4 5 6 7 8 9 The trace of 20 Dirac matrices. <p> The structure constants are replaced by traces. In [7]:= 16 SU3F [a, r, s] SU3F [b, r, s] (-tr [la [b] la [r] la [s]] + tr [la [b] la [s] la [r]])) Expanding forces the products of traces to simplify, if there are indices to contract. In <ref> [8] </ref>:= ExpandAll [%] Out [8]= 48 d [a, b] Define f as SU3F. In [9]:= f [x __ ] := SU3F [x] f abr f rcs + f bcr f ras + f car f rbs = 0. <p> In [7]:= 16 SU3F [a, r, s] SU3F [b, r, s] (-tr [la [b] la [r] la [s]] + tr [la [b] la [s] la [r]])) Expanding forces the products of traces to simplify, if there are indices to contract. In <ref> [8] </ref>:= ExpandAll [%] Out [8]= 48 d [a, b] Define f as SU3F. In [9]:= f [x __ ] := SU3F [x] f abr f rcs + f bcr f ras + f car f rbs = 0. <p> In [7]:= PaVe [0,0, -pp-, -m02, m12-] Out [7]= B00 [pp, m02, m12] This is B 11 (p 2 1 ; m 0 ; m 1 ), the coefficient function of p 1 p 1- of B -. In <ref> [8] </ref>:= PaVe [1,1, -p10-, -m12, m22-] Out [8]= B11 [p10, m12, m22] PaVe with one 0 as first argument are scalar Passarino-Veltman integrals. In [9]:= PaVe [0, -p10, p12, p20-, -m12, m22, m32-] Out [9]= C0 [p10, p12, p20, m12, m22, m32] This is D 0 with 10 arguments. <p> In [7]:= PaVe [0,0, -pp-, -m02, m12-] Out [7]= B00 [pp, m02, m12] This is B 11 (p 2 1 ; m 0 ; m 1 ), the coefficient function of p 1 p 1- of B -. In <ref> [8] </ref>:= PaVe [1,1, -p10-, -m12, m22-] Out [8]= B11 [p10, m12, m22] PaVe with one 0 as first argument are scalar Passarino-Veltman integrals. In [9]:= PaVe [0, -p10, p12, p20-, -m12, m22, m32-] Out [9]= C0 [p10, p12, p20, m12, m22, m32] This is D 0 with 10 arguments. <p> In <ref> [8] </ref>:= d122 = PaVeReduce [ PaVe [1, 2, 2, -Small [ME2], MW2, MW2, Small [ME2], S, T-, -0, Small [ME2], 0, Small [ME2]-], Mandelstam -&gt; -S, T, U, 2 MW2-, IsolateHead -&gt; F ] Out [8]= F [17] Write the result out into a Fortran file. <p> In <ref> [8] </ref>:= d122 = PaVeReduce [ PaVe [1, 2, 2, -Small [ME2], MW2, MW2, Small [ME2], S, T-, -0, Small [ME2], 0, Small [ME2]-], Mandelstam -&gt; -S, T, U, 2 MW2-, IsolateHead -&gt; F ] Out [8]= F [17] Write the result out into a Fortran file. In [9]:= Write2 [ "d122.for", d122res = d122, FormatType -&gt; FortranForm ]; This shows the resulting Fortran file. The first abbreviations are always the scalar integrals. The partially recursive definitions of the abbreviations are not fully optimized. <p> With replacements you can adapt the result to your other Fortran code. In [7]:= Write2 ["Wff1.for", vert = Wff1 /. g [i _ , "+"] -&gt; gp [i] /. g [i _ , "-"] -&gt; FormatType -&gt; FortranForm ] Show the content of the file. In <ref> [8] </ref>:= !!Wff1.for vert = (2*k2 + (3*k2 + 2*M2)*B0 (k2,Null,Null) - - 2*(2*k2 + M2)*B0 (Null,M2,Null) + - 2*(k2 + M2)**2* - C0 (Null,Null,k2,Null,M2,Null))* - (gp (1)*gp (2)*gp (3)*MA (1) + StandardMatrixElement [expr] head of a standard matrix element SetStandardMatrixElements [ -sm1 -&gt; abb1-, -sm2 -&gt; abb2-, ...-] set abbreviations for <p> In [7]:= Factor [test] Out [7]= (-a + b) (-x + y) Here the convention used by Factor2 becomes clear: the first term in a subsum gets a positive prefactor. In <ref> [8] </ref>:= Factor2 [test] Out [8]= (a - b) (x - y) option name default value ProductExpand False whether to expand products An expansion controlling option for Collect2 and Combine. 38 Guide to FeynCalc 1.0 4.2 An Isolating Function for Automatically Introducing Abbreviations Isolate [expr] substitute an abbreviation K [i] for expr, <p> In [7]:= Factor [test] Out [7]= (-a + b) (-x + y) Here the convention used by Factor2 becomes clear: the first term in a subsum gets a positive prefactor. In <ref> [8] </ref>:= Factor2 [test] Out [8]= (a - b) (x - y) option name default value ProductExpand False whether to expand products An expansion controlling option for Collect2 and Combine. 38 Guide to FeynCalc 1.0 4.2 An Isolating Function for Automatically Introducing Abbreviations Isolate [expr] substitute an abbreviation K [i] for expr, if Length [expr] &gt; <p> In [7]:= ReleaseHold [%] Out [7]= (y + z) d [z] + a [z] (b + c H [1]) Decreasing the option IsolateSplit significantly forces Isolate to use more than one L for a - b - c - d - e. In <ref> [8] </ref>:= Isolate [ a - b - c - d - e, IsolateHead -&gt; L, IsolateSplit -&gt; 15 ] Out [8]= L [2] This shows the values of the L. <p> In <ref> [8] </ref>:= Isolate [ a - b - c - d - e, IsolateHead -&gt; L, IsolateSplit -&gt; 15 ] Out [8]= L [2] This shows the values of the L. In [9]:= -L [2], L [1]- Out [9]= --c - d - e + L [1], a b The importance of Isolate is significant, since it gives you a means to handle very big expressions. <p> In [6]:= $PrePrint=. This shows the internal structure. In [7]:= LeviCivita [m, n, r, s] Out [7]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], LorentzIndex [s]] Contracting " - p yields " - p . In the internal representation the p has the head Momentum wrapped around it. In <ref> [8] </ref>:= Contract [ % FourVector [p, s]] Out [8]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], Momentum [p]] 4.6 Polarization Sums PolarizationSum [mu, nu] g - PolarizationSum [mu, nu, k] g - + k k - =k 2 PolarizationSum [mu, nu, k, n] g - k k - n 2 =(k <p> In [7]:= LeviCivita [m, n, r, s] Out [7]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], LorentzIndex [s]] Contracting " - p yields " - p . In the internal representation the p has the head Momentum wrapped around it. In <ref> [8] </ref>:= Contract [ % FourVector [p, s]] Out [8]= Eps [LorentzIndex [m], LorentzIndex [n], LorentzIndex [r], Momentum [p]] 4.6 Polarization Sums PolarizationSum [mu, nu] g - PolarizationSum [mu, nu, k] g - + k k - =k 2 PolarizationSum [mu, nu, k, n] g - k k - n 2 =(k n) 2 + (n k - + n <p> In [6]:= MetricTensor [mu, nu] Out [6]= Pair [LorentzIndex [mu], LorentzIndex [nu]] Clearly a four-vector is also represented as a pair internally. In [7]:= FourVector [l, mu] Out [7]= Pair [LorentzIndex [mu], Momentum [l]] The dimension is provided as an argument. In <ref> [8] </ref>:= MetricTensor [a, b, Dimension -&gt; d] Out [8]= Pair [LorentzIndex [a, d], LorentzIndex [b, d]] A (D 4)-dimensional four-vector. In [9]:= FourVector [p, mu, Dimension -&gt; D - 4] Out [9]= Pair [LorentzIndex [mu, -4 + D], Momentum [p, -4 + D]] Obviously it vanishes after changing the dimension. <p> In [7]:= FourVector [l, mu] Out [7]= Pair [LorentzIndex [mu], Momentum [l]] The dimension is provided as an argument. In <ref> [8] </ref>:= MetricTensor [a, b, Dimension -&gt; d] Out [8]= Pair [LorentzIndex [a, d], LorentzIndex [b, d]] A (D 4)-dimensional four-vector. In [9]:= FourVector [p, mu, Dimension -&gt; D - 4] Out [9]= Pair [LorentzIndex [mu, -4 + D], Momentum [p, -4 + D]] Obviously it vanishes after changing the dimension. In [10]:= % /. <p> In [7]:= test = 2 DiracMatrix [mu] + DiracMatrix [mu, Dimension -&gt; D] + DiracMatrix [mu, Dimension -&gt; D-4] Out [7]= 2 ga [mu] + ga [mu] + ga [mu] Switch to the internal representation. In <ref> [8] </ref>:= ($PrePrint=. ; test) Out [8]= 2 DiracGamma [LorentzIndex [mu]] + DiracGamma [LorentzIndex [mu, -4 + D], -4 + D] + DiracGamma [LorentzIndex [mu, D], D] This eliminates each Dirac matrix in D 4 dimension. <p> In [7]:= test = 2 DiracMatrix [mu] + DiracMatrix [mu, Dimension -&gt; D] + DiracMatrix [mu, Dimension -&gt; D-4] Out [7]= 2 ga [mu] + ga [mu] + ga [mu] Switch to the internal representation. In <ref> [8] </ref>:= ($PrePrint=. ; test) Out [8]= 2 DiracGamma [LorentzIndex [mu]] + DiracGamma [LorentzIndex [mu, -4 + D], -4 + D] + DiracGamma [LorentzIndex [mu, D], D] This eliminates each Dirac matrix in D 4 dimension.

References-found: 8

