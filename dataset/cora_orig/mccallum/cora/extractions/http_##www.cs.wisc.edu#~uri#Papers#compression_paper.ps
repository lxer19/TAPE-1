URL: http://www.cs.wisc.edu/~uri/Papers/compression_paper.ps
Refering-URL: http://www.cs.wisc.edu/~uri/
Root-URL: 
Email: email: (jgoldst, raghu, uri)@cs.wisc.edu  
Phone: Tel: (608)262-6611, Fax: (608)262-9777  
Title: Compressing Relations and Indexes  
Author: Jonathan Goldstein Raghu Ramakrishnan Uri Shaft 
Date: February 18, 1998  
Address: 1210 W. Dayton St., Madison, Wisconsin 53706  
Affiliation: Department of Computer Sciences, University of Wisconsin-Madison  
Abstract: We propose a new compression algorithm that is tailored to database applications. It can be applied to a collection of records, and is especially effective for records with many low to medium cardinality fields. In addition, this new technique supports very fast decompression. (Gzip typically takes 10 times the CPU time to decompress relations, while achieving about the same compression ratio.) Our algorithm achieves compression on numeric fields only; while low and medium cardinality fields of other types can be handled by mapping values to a small range of integers, our algorithms must be complemented by other compression techniques for general non-numeric (text, image) fields. Promising application domains include decision support systems (DSS), since `fact tables', which are by far the largest tables in these applications, contain many low and medium cardinality fields and typically no text fields [Kim96]. Further, our decompression rates are faster than typical disk throughputs for sequential scans; in contrast, gzip is slower. This is important in DSS applications, which often scan large ranges of records. An important distinguishing characteristic of our algorithm, in contrast to compression algorithms proposed earlier, is that we can decompress individual tuples (even individual fields), rather than a full page at a time. This offers significant improvements in cases where a page is stored in the buffer pool and repeatedly probed for a few tuples; the page can be stored in compressed form, and retrieving an individual tuple is extremely fast (since there is no I/O, the CPU cost of decompression dominates here). Our compression algorithm also improves index structures such as B-trees and R-trees significantly by reducing the number of leaf pages and compressing index entries, which greatly increases the fanout. In this context, an important feature of our algorithm is that compression can be either lossy or lossless, where either the degree of loss, or the compression ratio, is user-specified. If data entries in the index are simply represented as hkey; ridi pairs, using our compression technique naturally yields the benefits of such optimizations as storing hkey; rid listi pairs and recognizing "runs" of rids.
Abstract-found: 1
Intro-found: 1
Reference: [Bas85] <author> M. A. Bassiouni. </author> <title> Data compression in scientific and statistical databases. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> volume SE-11, no. 10, </volume> <pages> pages 1047-1058, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Additionally, we demonstrated the application of multidimensional bulk loading to compression, and presented a range of performance results that strongly argue for the use of compression in a database context. <ref> [EOS81, RH93, Bas85] </ref> discuss several compression techniques such as run length encoding, header compression, encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page. 20 Like the compression described in Section 4.3, the above techniques, unlike
Reference: [BKK96] <author> Stefan Berchtold, Daniel A. Keim, and Hans-Peter Kriegel. </author> <title> The X|tree: An index structure for high dimensional data. </title> <editor> In T. M. Vijayaraman, A. P. Buchman, C. Mohan, and N. L. Sarda, editors, </editor> <booktitle> Proc. 22th Inf. Conf. on VLDB, </booktitle> <pages> pages 28-39, </pages> <address> Mumbai, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees [BM72] , grid files [NHS88], buddy trees [KSSS90, KSSS89, KHS91], TV-trees [LJF94] (using L 1 metric), and X-trees <ref> [BKK96] </ref>, all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. Our compression technique can be used very effectively on these indexing structures, and is especially useful when the search key contains many dimensions.
Reference: [BKSS92] <author> N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R fl |tree: An efficient and robust access method for points and rectangles. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 322-331, </pages> <year> 1992. </year>
Reference-contexts: If the number of dimensions is greater than two, MBBs with an appropriate number of dimensions are used, but the basic idea remains the same. The above description is sufficiently general that it applies to several variants of the R-tree, including R + -trees [SRF87] and R fl -trees <ref> [BKSS92] </ref>. (Note that MBBs in non-leaf nodes of an R + -tree are nonoverlapping, and therefore point queries search a single path from root to leaf.
Reference: [BM72] <author> R. Bayer and E. McCreight. </author> <title> Organization and maintenance of large ordered indexes. </title> <journal> Acta Informat., </journal> <volume> 1 </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: The algorithm in this case is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees <ref> [BM72] </ref> , grid files [NHS88], buddy trees [KSSS90, KSSS89, KHS91], TV-trees [LJF94] (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs.
Reference: [EOS81] <author> Susan J. Eggers, Frank Olken, and Arie Shoshani. </author> <title> A compression technique for large statistical databases. </title> <booktitle> In VLDB, </booktitle> <pages> pages 424-434, </pages> <year> 1981. </year>
Reference-contexts: Additionally, we demonstrated the application of multidimensional bulk loading to compression, and presented a range of performance results that strongly argue for the use of compression in a database context. <ref> [EOS81, RH93, Bas85] </ref> discuss several compression techniques such as run length encoding, header compression, encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page. 20 Like the compression described in Section 4.3, the above techniques, unlike
Reference: [Gut84] <author> Antonin Guttman. R|trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 47-57, </pages> <year> 1984. </year>
Reference-contexts: The algorithm in this case is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees <ref> [Gut84] </ref>, B-trees [BM72] , grid files [NHS88], buddy trees [KSSS90, KSSS89, KHS91], TV-trees [LJF94] (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. <p> The following sections discuss the impact of compression on R-trees. This includes the alterations needed for dynamic insert, delete, and update. In addition, internal nodes are compressed using lossy compression. 3.1 Description of R-trees The R-tree <ref> [Gut84] </ref> is a height-balanced tree structure designed specifically for indexing multi-dimensional spatial objects. As in a B-tree, each node (a disk page) in the R-tree is either an internal node or a leaf node. Entries in internal nodes point to other nodes.
Reference: [KHS91] <author> H.-P. Kriegel, H. Horn, and M. Schiwietz. </author> <title> The performance of object decomposition techniques for spatial query processing. </title> <booktitle> In Proc. 2nd Symposium on Large Spatial Databases, Lecture Notes in Computer Science, </booktitle> <volume> volume 525, </volume> <pages> pages 257-276, </pages> <year> 1991. </year>
Reference-contexts: algorithm in this case is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees [BM72] , grid files [NHS88], buddy trees <ref> [KSSS90, KSSS89, KHS91] </ref>, TV-trees [LJF94] (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. Our compression technique can be used very effectively on these indexing structures, and is especially useful when the search key contains many dimensions.
Reference: [Kim96] <author> R. Kimball. </author> <title> The Data Warehouse Toolkit. </title> <publisher> John Wiley and Sons, </publisher> <year> 1996. </year>
Reference: [KSSS89] <author> H.-P. Kriegel, M. Schiwietz, R. Schneider, and B. Seeger. </author> <title> Performance comparison of point and spatial access methods. </title> <booktitle> In SSD, </booktitle> <pages> pages 89-113, </pages> <year> 1989. </year>
Reference-contexts: algorithm in this case is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees [BM72] , grid files [NHS88], buddy trees <ref> [KSSS90, KSSS89, KHS91] </ref>, TV-trees [LJF94] (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. Our compression technique can be used very effectively on these indexing structures, and is especially useful when the search key contains many dimensions.
Reference: [KSSS90] <author> H.-P. Kriegel, M. Schiwietz, R. Schneider, and B. Seeger. </author> <title> The buddy-tree: An efficient and robust method for spatial data base systems. </title> <booktitle> In Proc. 16th VLDB Conf., </booktitle> <pages> pages 590-601, </pages> <year> 1990. </year>
Reference-contexts: algorithm in this case is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees [BM72] , grid files [NHS88], buddy trees <ref> [KSSS90, KSSS89, KHS91] </ref>, TV-trees [LJF94] (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. Our compression technique can be used very effectively on these indexing structures, and is especially useful when the search key contains many dimensions.
Reference: [LEL96] <author> Scott T. Leutenegger, Jeffrey M. Edington, and Mario A. Lopez. Str: </author> <title> A simple and efficient algorithm for R-tree packing. </title> <type> Technical Report 96-02, </type> <institution> Mathematics and Computer Science Dept., University of Denver, </institution> <year> 1996. </year>
Reference-contexts: Each of these algorithms produces an index structure (R-tree or B-tree) containing the data records in the leaf pages. The first algorithm, called GBPack, is based on the STR <ref> [LEL96] </ref> bulk-loading algorithm for R-trees. The second algorithm is a variant of the first and trades off some compression to obtain a higher-quality R-tree index.
Reference: [LJF94] <author> King-Ip Lin, H. V. Jagadish, and Christos Faloutsos. </author> <title> The TV|tree: An index structure for high-dimensional data. </title> <journal> VLDB journal, </journal> <volume> 3(4) </volume> <pages> 517-542, </pages> <year> 1994. </year>
Reference-contexts: is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees [BM72] , grid files [NHS88], buddy trees [KSSS90, KSSS89, KHS91], TV-trees <ref> [LJF94] </ref> (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. Our compression technique can be used very effectively on these indexing structures, and is especially useful when the search key contains many dimensions.
Reference: [LZ76] <author> A. Lempel and J. Ziv. </author> <title> On the complexity of finite sequences. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 22(1) </volume> <pages> 75-81, </pages> <year> 1976. </year>
Reference-contexts: 1 Introduction Traditional compression algorithms such as Lempel-Ziv <ref> [Sto88, LZ76, LZ77] </ref>, which is the basis of the standard gzip compression package, require uncompressing a large portion of the file even if only a small part of that file is required.
Reference: [LZ77] <author> A. Lempel and J. Ziv. </author> <title> A universal algorithm for sequential data compression. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 31(3) </volume> <pages> 337-343, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Traditional compression algorithms such as Lempel-Ziv <ref> [Sto88, LZ76, LZ77] </ref>, which is the basis of the standard gzip compression package, require uncompressing a large portion of the file even if only a small part of that file is required.
Reference: [NHS88] <author> J. Nievergelt, H. Hinterberger, and S. C. Sevcik. </author> <title> The grid file: An adaptable, symmetric multikey file structure. </title> <booktitle> In Readings in Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year> <month> 22 </month>
Reference-contexts: The algorithm in this case is actually much simpler than the general version presented above, and runs much faster, but we will not elaborate upon this for lack of space. 3 Compression Applied to Rectangle Based Indexes Many indexing structures, including R-trees [Gut84], B-trees [BM72] , grid files <ref> [NHS88] </ref>, buddy trees [KSSS90, KSSS89, KHS91], TV-trees [LJF94] (using L 1 metric), and X-trees [BKK96], all consist of collections of (rectangle,pointer) pairs and (point,data) pairs. Our compression technique can be used very effectively on these indexing structures, and is especially useful when the search key contains many dimensions.
Reference: [NR95] <author> Wee K. Ng and Chinya V. Ravishankar. </author> <title> Relational database compression using augmented vector quantization. In P.S. </title> <editor> Yu and A. L. P. Chen, editors, </editor> <booktitle> IEEE 11'th International Conference on Data Engineering, </booktitle> <pages> pages 540-549, </pages> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Thus, the effectiveness of the compression can be increased, often dramatically, by partitioning the tuples in a file across pages in an intelligent way. If a database contains 500,000 tuples, say, there are many ways to group these tuples, and different groupings may yield drastically different compression ratios. <ref> [NR95] </ref> demonstrates the effectiveness of using a B-tree sort order to assign tuples to pages. We further develop the connection between index sort orders, including multidimensional indexes like R-trees, and improved compression. <p> In this case we got even better gains than in the Sales dataset case. dataset. Here we have two dimensions and 150000 tuples. We see the same good results as in the other datasets. 5 Related Work Ng and Ravishankar <ref> [NR95] </ref> discussed a compression scheme that is similar in some respects to our work.
Reference: [OQ97] <author> Patrick O'Neil and Dallan Quass. </author> <title> Imporved query performance with variant indexes. </title> <booktitle> In SIG-MOD, </booktitle> <pages> pages 38-49, </pages> <address> Tucson, AZ, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page. 20 Like the compression described in Section 4.3, the above techniques, unlike ours, handle any kind of data, but introduce buffer and storage management problems. <ref> [OQ97] </ref> discusses several query evaluation algorithms based on the use of compression.
Reference: [RH93] <author> Mark A. Roth and Scott J. Van Horn. </author> <title> Database compression. </title> <booktitle> In SIGMOD Record, </booktitle> <volume> volume 22, no. 3, </volume> <pages> pages 31-39, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Additionally, we demonstrated the application of multidimensional bulk loading to compression, and presented a range of performance results that strongly argue for the use of compression in a database context. <ref> [EOS81, RH93, Bas85] </ref> discuss several compression techniques such as run length encoding, header compression, encoding category values, order preserving compression, Huffman encoding, Lempel-Ziv, differencing, prefix and postfix compression, none of which support random access to tuples within a page. 20 Like the compression described in Section 4.3, the above techniques, unlike
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + |tree: A dynamic index for multi| dimensional objects. </title> <booktitle> In Proc. 13th Inf. Conf. on VLDB, </booktitle> <pages> pages 507-518, </pages> <year> 1987. </year>
Reference-contexts: If the number of dimensions is greater than two, MBBs with an appropriate number of dimensions are used, but the basic idea remains the same. The above description is sufficiently general that it applies to several variants of the R-tree, including R + -trees <ref> [SRF87] </ref> and R fl -trees [BKSS92]. (Note that MBBs in non-leaf nodes of an R + -tree are nonoverlapping, and therefore point queries search a single path from root to leaf.
Reference: [Sto88] <author> James A. Storer. </author> <title> Data Compression: Methods and Theory. </title> <publisher> Computer Science Press, </publisher> <address> 1803 Research Blvd. Rockville, Maryland, </address> <year> 1988. </year> <month> 23 </month>
Reference-contexts: 1 Introduction Traditional compression algorithms such as Lempel-Ziv <ref> [Sto88, LZ76, LZ77] </ref>, which is the basis of the standard gzip compression package, require uncompressing a large portion of the file even if only a small part of that file is required.
References-found: 20

