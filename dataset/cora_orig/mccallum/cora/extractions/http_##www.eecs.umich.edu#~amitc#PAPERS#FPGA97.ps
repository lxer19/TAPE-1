URL: http://www.eecs.umich.edu/~amitc/PAPERS/FPGA97.ps
Refering-URL: http://www.eecs.umich.edu/~amitc/PAPERS/FPGA97.html
Root-URL: http://www.cs.umich.edu
Email: famitc,jhayesg@eecs.umich.edu  
Title: General Modeling and Technology-Mapping Technique for LUT-based FPGAs 1  
Author: Amit Chowdhary and John P. Hayes 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Advanced Computer Architecture Laboratory Department of Electrical Engineering and Computer Science University of Michigan  
Abstract: We present a general approach to the FPGA technology mapping problem that applies to any logic block composed of lookup tables (LUTs) and can yield optimal solutions. The connections between LUTs of a logic block are modeled by virtual switches, which define a set of multiple-LUT blocks (MLBs) called an MLB-basis. We identify the MLB-bases for various commercial logic blocks. Given an MLB-basis, we formulate FPGA mapping as a mixed integer linear programming (MILP) problem to achieve both the generality and the optimality objectives. We solve the MILP models using a general-purpose MILP solver, and present the results of mapping some ISCAS-85 benchmark circuits with a variety of commercial FPGAs. Circuits of a few hundred gates can be mapped in reasonable time using the MILP approach directly. Larger circuits can be handled by partitioning them prior to technology mapping. We show that optimal or provably near-optimal solutions can be obtained for the large ISCAS-85 benchmark circuits using partitions defined by their high-level functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Altera Inc. </author> <title> The Altera FPGA Data Book, </title> <institution> Sunnyvale, Calif., </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction Current FPGAs fall into two main types based on their logic block structure: lookup table-based <ref> [1, 2, 11] </ref> and multiplexer-based. An m-input single-output lookup table (LUT) is a static RAM of 2 m bits which can programmed to implement any combinational logic function of at most m inputs. Figure 1 illustrates a few LUT-based logic blocks which serve as examples in this paper. <p> An L-cover corresponds directly to an FPGA implementation. A LUT-based logic block can be used in various modes (circuit configurations) depending on its programmability M ; (b) M-graph M o ; (c) M-graph M p . <ref> [11, 2, 1] </ref>. Existing mapping techniques [10] were designed for one specific configuration, usually a single LUT, and so are not fully applicable to many commercial designs.
Reference: [2] <institution> AT&T Inc. The AT&T FPGA Data Book, </institution> <address> Allentown, Pa., </address> <year> 1995. </year>
Reference-contexts: 1 Introduction Current FPGAs fall into two main types based on their logic block structure: lookup table-based <ref> [1, 2, 11] </ref> and multiplexer-based. An m-input single-output lookup table (LUT) is a static RAM of 2 m bits which can programmed to implement any combinational logic function of at most m inputs. Figure 1 illustrates a few LUT-based logic blocks which serve as examples in this paper. <p> An L-cover corresponds directly to an FPGA implementation. A LUT-based logic block can be used in various modes (circuit configurations) depending on its programmability M ; (b) M-graph M o ; (c) M-graph M p . <ref> [11, 2, 1] </ref>. Existing mapping techniques [10] were designed for one specific configuration, usually a single LUT, and so are not fully applicable to many commercial designs.
Reference: [3] <author> P. Barth. </author> <title> Logic Based 0-1 Constraint Programming. </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: This makes it possible to formulate technology mapping as an exact MILP optimization problem. The MILP formulation is extremely flexible, and can be solved in reasonable time using any standard MILP solver <ref> [3, 6] </ref>. We focus on area minimization, but the approach can be easily modified to optimize delay, or a combination of area and delay, by changing the objective and adding some constraints [4]. The method applies to most types of commercial logic blocks. <p> We have implemented the MILP models described in the previous section for general monotone circuits and a variety of MLB-bases. We have solved these models using various MILP solvers <ref> [6, 3] </ref>, and found that cplex is the most efficient. Note that all these packages can generate optimal solutions, but their execution times vary considerably.
Reference: [4] <author> A. Chowdhary and J. P. Hayes. </author> <title> Technology mapping for field-programmable gate arrays using integer programming. </title> <booktitle> Proc. Int'l Conf. on CAD, </booktitle> <pages> pp. 346-352, </pages> <year> 1995. </year>
Reference-contexts: Some, such as Chortle-crf [8], also handle the two-LUT configuration, but only as a post-processing step. These algorithms employ heuristics which generate solutions quickly, but whose results can be far from optimal. We previously designed a technology mapping algorithm for single-LUT logic blocks <ref> [4] </ref>, which is exact when the LUT size is monotone [5]. This paper extends the method of [4] to general non-monotone circuits and to multiple-LUT logic blocks. To achieve optimality, the FPGA mapping problem is formulated as a mixed integer linear program (MILP). <p> These algorithms employ heuristics which generate solutions quickly, but whose results can be far from optimal. We previously designed a technology mapping algorithm for single-LUT logic blocks <ref> [4] </ref>, which is exact when the LUT size is monotone [5]. This paper extends the method of [4] to general non-monotone circuits and to multiple-LUT logic blocks. To achieve optimality, the FPGA mapping problem is formulated as a mixed integer linear program (MILP). <p> We focus on area minimization, but the approach can be easily modified to optimize delay, or a combination of area and delay, by changing the objective and adding some constraints <ref> [4] </ref>. The method applies to most types of commercial logic blocks. Furthermore, it generates near-optimal mappings for very large circuits via partitioning the circuits and mapping each partition individually. <p> For an MLB with one LUT of fanin m, F reduces to [m]. The MILP formulation of the mapping problem depends on the circuit graph G and the fanin matrix F of the logic block. Single LUT: An MILP-based solution to the FPGA technology mapping problem is developed in <ref> [4] </ref> for the special case where the logic block is a single LUT. This model defines a binary external variable for every node of G. <p> A fanout-free circuit has no RN-pairs; at the other extreme, some circuits such as a grid have O (jV j 2 ) RN-pairs, so the number of such pairs can be quadratic in jV j (the number of RN-pairs was incorrectly stated in <ref> [4] </ref> to be jEj). We assign a reconvergence variable to an RN-pair only if the pair can be merged in a single LUT. Thus the number of reconvergence variables is reduced significantly by considering only the mergeable RN-pairs. <p> G is called monotone iff it has no non-monotone L-subgraph. We have found that the number of non-monotone L-graphs in the ISCAS benchmarks is less than 5% of the number of gates. The MILP model, described in <ref> [4] </ref>, applies to all circuit graphs, but is guaranteed to be optimal only for monotone circuit graphs. Here, we extend that model to generate optimal L-cover for any non-monotone circuit graph. <p> The problem of finding an area-optimal L-cover can be formulated as follows. MILP Model 1 Assign the external variables of G to f0; 1g to satisfy the constraints described in <ref> [4] </ref> along with the constraints (1)-(3). The resulting assignment defines an L-cover C L;G of G by L. <p> Note that all these packages can generate optimal solutions, but their execution times vary considerably. Prior to technology mapping, the circuit nodes are decomposed such that every node can be mapped to at least one LUT in the MLB, unlike our prior work <ref> [4] </ref> and that of a few others [10], where every node is decomposed into 2-input nodes. This has the advantage of reducing the time to solve the MILP model, since the time roughly depends on the number of binary variables in the formulation which in turn depends on jV j. <p> The benchmarks c432, c499, c880 and c6288 have 196, 392, 347 and 2406 gates, respectively. These benchmarks are partitioned using their high-level models from [9]; the same partitions are also used in <ref> [4] </ref>. Most practical circuits have well-defined high-level models, which can produce suitable partitions. The cuts used for c880 benchmark are shown in Fig. 12. The number of cuts needed for a logic block depends on the number of LUTs and interconnections it contains.
Reference: [5] <author> J. Cong and Y. Ding. FlowMap: </author> <title> An Optimal Technology Mapping Algorithm for Delay Optimization in Lookup-Table Based FPGA Designs. </title> <journal> IEEE Trans. on CAD, </journal> <volume> 13(1) </volume> <pages> 1-11, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: These algorithms employ heuristics which generate solutions quickly, but whose results can be far from optimal. We previously designed a technology mapping algorithm for single-LUT logic blocks [4], which is exact when the LUT size is monotone <ref> [5] </ref>. This paper extends the method of [4] to general non-monotone circuits and to multiple-LUT logic blocks. To achieve optimality, the FPGA mapping problem is formulated as a mixed integer linear program (MILP). <p> This procedure is similar to the step of finding a minimum-depth cut at every node of G in the Flowmap algorithm <ref> [5] </ref>. An m-input L-graph of G is monotone, iff it has no subgraph which is an L-graph with more than m inputs [5]. For example, the 3-input L-graph in Fig.8a is non-monotone, since it has a subgraph which is a 4-input L-graph. <p> This procedure is similar to the step of finding a minimum-depth cut at every node of G in the Flowmap algorithm <ref> [5] </ref>. An m-input L-graph of G is monotone, iff it has no subgraph which is an L-graph with more than m inputs [5]. For example, the 3-input L-graph in Fig.8a is non-monotone, since it has a subgraph which is a 4-input L-graph. G is called monotone iff it has no non-monotone L-subgraph. <p> Note that the last term in constraint (3) is non-linear, but it can be linearized using the fact that input-size [s] is bounded by m. The preprocessing procedure to find the DN-pairs of G uses a maxflow-mincut network flow technique similar to the Flowmap algorithm <ref> [5] </ref>. Like the RN-pairs, the number of DN-pairs is a very small fraction of the total number of nodes for the ISCAS benchmarks. The problem of finding an area-optimal L-cover can be formulated as follows.
Reference: [6] <institution> CPLEX Optimization Inc. CPLEX documentation, </institution> <year> 1990. </year>
Reference-contexts: This makes it possible to formulate technology mapping as an exact MILP optimization problem. The MILP formulation is extremely flexible, and can be solved in reasonable time using any standard MILP solver <ref> [3, 6] </ref>. We focus on area minimization, but the approach can be easily modified to optimize delay, or a combination of area and delay, by changing the objective and adding some constraints [4]. The method applies to most types of commercial logic blocks. <p> We have implemented the MILP models described in the previous section for general monotone circuits and a variety of MLB-bases. We have solved these models using various MILP solvers <ref> [6, 3] </ref>, and found that cplex is the most efficient. Note that all these packages can generate optimal solutions, but their execution times vary considerably.
Reference: [7] <author> E. Detjens et al. </author> <title> Technology mapping in MIS. </title> <booktitle> Proc. Int'l Conf. on CAD, </booktitle> <pages> pp. 116-119, </pages> <year> 1987. </year>
Reference-contexts: Previous techniques are incapable of addressing such a wide range of logic blocks and mapping objectives. 2 Modeling Logic Blocks Prior to technology mapping, the input logic circuit C is synthesized by a technology-independent logic minimization step performed using a logic synthesis package such as mis <ref> [7] </ref>. The gates in C are usually decomposed into smaller gates that can be mapped to the smallest component in the FPGA logic block.
Reference: [8] <author> R. J. Francis, J. Rose, and Z. Vranesic. Chortle-crf: </author> <title> Fast technology mapping for lookup table based field programmable gate arrays. </title> <booktitle> Proc. 28th Design Automation Conf., </booktitle> <pages> pp. 613-619, </pages> <year> 1991. </year>
Reference-contexts: This logic block can be configured either as a 5-input LUT, or as two 4-input LUTs where the total number of inputs is no more than 5. Most algorithms were designed for the single-LUT configuration of the XC3000. Some, such as Chortle-crf <ref> [8] </ref>, also handle the two-LUT configuration, but only as a post-processing step. These algorithms employ heuristics which generate solutions quickly, but whose results can be far from optimal. We previously designed a technology mapping algorithm for single-LUT logic blocks [4], which is exact when the LUT size is monotone [5].
Reference: [9] <author> M. C. Hansen and J. P. Hayes. </author> <title> High-level test generation using physically-induced faults. </title> <booktitle> Proc. of VLSI Test Symposium, </booktitle> <pages> pp. 20-28, </pages> <year> 1995. </year>
Reference-contexts: We have mapped some representative ISCAS-85 benchmark circuits with the logic blocks of Fig. 1 using the MILP approach. The benchmarks c432, c499, c880 and c6288 have 196, 392, 347 and 2406 gates, respectively. These benchmarks are partitioned using their high-level models from <ref> [9] </ref>; the same partitions are also used in [4]. Most practical circuits have well-defined high-level models, which can produce suitable partitions. The cuts used for c880 benchmark are shown in Fig. 12.
Reference: [10] <author> A. Sangiovanni-Vincentelli, A. El Gamal, and J. Rose. </author> <title> Synthesis methods for field programmable gate arrays. </title> <booktitle> Proc. of IEEE, </booktitle> <pages> pp. 1057-1083, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The goal is to minimize area, which is measured by the total number of logic blocks. Figure 2 shows a mapping of a small circuit using three 4-input LUTs. Existing mapping algorithms were designed specifically for the XC3000 shown in Fig. 1a <ref> [10] </ref>. This logic block can be configured either as a 5-input LUT, or as two 4-input LUTs where the total number of inputs is no more than 5. Most algorithms were designed for the single-LUT configuration of the XC3000. <p> An L-cover corresponds directly to an FPGA implementation. A LUT-based logic block can be used in various modes (circuit configurations) depending on its programmability M ; (b) M-graph M o ; (c) M-graph M p . [11, 2, 1]. Existing mapping techniques <ref> [10] </ref> were designed for one specific configuration, usually a single LUT, and so are not fully applicable to many commercial designs. There is thus a need for a general model to capture the various modes of a multiple LUT logic block that is a small circuit of LUTs. <p> Prior to technology mapping, the circuit nodes are decomposed such that every node can be mapped to at least one LUT in the MLB, unlike our prior work [4] and that of a few others <ref> [10] </ref>, where every node is decomposed into 2-input nodes. This has the advantage of reducing the time to solve the MILP model, since the time roughly depends on the number of binary variables in the formulation which in turn depends on jV j.
Reference: [11] <author> Xilinx Inc. </author> <title> The Programmable Logic Data Book, </title> <address> Santa Clara, Calif., </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Current FPGAs fall into two main types based on their logic block structure: lookup table-based <ref> [1, 2, 11] </ref> and multiplexer-based. An m-input single-output lookup table (LUT) is a static RAM of 2 m bits which can programmed to implement any combinational logic function of at most m inputs. Figure 1 illustrates a few LUT-based logic blocks which serve as examples in this paper. <p> An L-cover corresponds directly to an FPGA implementation. A LUT-based logic block can be used in various modes (circuit configurations) depending on its programmability M ; (b) M-graph M o ; (c) M-graph M p . <ref> [11, 2, 1] </ref>. Existing mapping techniques [10] were designed for one specific configuration, usually a single LUT, and so are not fully applicable to many commercial designs. <p> As is evident in Fig. 4c, M 3 and M 4 are subsumed by M 2 and M 1 , respectively. Thus the MLB-basis of XC4000 is fM 1 ; M 2 g. The XC3000 logic block is used in two modes <ref> [11] </ref>; one is a 5-input LUT and the other is a pair of 4-input LUTs, these modes correspond to M 1 and M 2 of Fig. 6a, respectively. The two-output mode of the XC3000 has 6 virtual switches in its primary inputs.
References-found: 11

