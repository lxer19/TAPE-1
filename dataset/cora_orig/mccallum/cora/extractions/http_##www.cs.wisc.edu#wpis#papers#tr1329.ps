URL: http://www.cs.wisc.edu/wpis/papers/tr1329.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: 
Email: manuvir@cs.wisc.edu reps@cs.wisc.edu  
Phone: Tel: 1 (608) 262-2091  
Title: BTA Termination Using CFL-Reachability  
Author: Manuvir Das Thomas Reps Das Thomas Reps 
Keyword: partial evaluation, binding-time analysis, termination, context-free-language reachability  
Address: 1210 W. Dayton St. 1210 W. Dayton St. Madison, WI 53706, USA Madison, WI 53706, USA  
Note: Manuvir  
Affiliation: University of Wisconsin-Madison  Computer Sciences Department Computer Sciences Department University of Wisconsin-Madison University of Wisconsin-Madison  
Abstract: In this paper, we develop a BTA algorithm that ensures termination of off-line partial evaluation for first-order functional programs, extending the work of Holst and of Glenstrup and Jones. Holst's characterization of in-situ-decreasing behaviour does not account for parameters that do not control the recursion of their functions. We extend Holst's framework to handle this phenomenon by defining the "influential" property for parameters. Glenstrup and Jones's algorithm for identifying in-situ-decreasing parameters, which relies on the size markings (", #, =) on the edges of a dependence graph, says that a path must be free of " edges and must contain at least one # edge to be size-decreasing. We extend their language of size-decreasing paths: A size-decreasing path may contain " edges provided that every " edge is balanced by the appropriate kind of # edge. We modify the size markings on the graph edges and use Context-Free-Language Reachability, a generalized form of graph reachability, to identify such complex size-decreasing paths. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: In order to identify a greater number of in-situ-decreasing parameters than Glenstrup and Jones, we extend the parameter dependency graph with new nodes and new edge markings and we use CFL-reachability rather than a closed semi-ring graph algorithm <ref> [1, 3] </ref>. * There is a general result that all "context-free language reachability problems" can be solved in time cubic in the number of vertices in the graph [15].
Reference: [2] <author> P. H. Andersen and C. K. Holst. </author> <title> Termination analysis for o*ine partial evaluation of a higher order functional language. </title> <booktitle> In Proceedings of the Third International Static Analysis Symposium, </booktitle> <year> 1996. </year>
Reference-contexts: The algorithm described in this 13 paper extends their work by using more precise markings on flow edges and by using CFL-reachability to identify a broader class of size-decreasing paths. Andersen and Holst have described an extension of Holst's analysis to a higher-order lambda calculus <ref> [2] </ref>. Although their primary emphasis was termination analysis for programs with higher-order functions, they observe that their technique for handling higher-order functions can be adapted to discover some size-decreasing paths containing " edges.
Reference: [3] <author> Arne J. Glenstrup and Neil D. Jones. </author> <title> BTA algorithms to ensure termination of off-line partial evaluation. </title> <booktitle> Andrei Ershov Second International Conference `Perspectives of System Informatics', Lecture Notes in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: an infinite loop or an infinite recursion because of "static-infinite computations" in a subject program [5, 13] (e.g. infinite loops that are completely static.) In this paper, we develop a BTA algorithm that marks every "static-infinite computation" as "dynamic", extending the work of Holst [4] and of Glenstrup and Jones <ref> [3] </ref>. As pointed out by Jones in [6], partial evaluation involves a basic tradeoff between "totality" and "computational completeness". <p> A function that contains an in-situ decreasing parameter can only call itself a finite number of times before this parameter takes on the value null. 1 Glenstrup and Jones have defined a second algorithm that identifies in-situ decreasing parameters <ref> [3] </ref>. They define a structure, called the parameter dependency graph (PDG), whose edges denote data dependences between function parameters. Edges are labelled to indicate their size-changing effects, as in Example 1 below. <p> In Section 8, we discuss related work. 3 2 A simple functional language and its semantics In this section we present a simple, first-order call-by-value functional language, F, and the semantics of programs in F. The language and its description is taken directly from Glenstrup and Jones's work in <ref> [3] </ref>; we use the same language so that our results can be compared with previous work, while we reproduce the language description here for completeness. <p> This serves as a formal justification of the algorithm for identifying in-situ-decreasing-parameters that is presented in Section 7. We first relate the semantic concept of a transition sequence defined in Section 2 with the syntactic concept of a call path defined by Glensrup and Jones in <ref> [3] </ref>. A call path is an abstraction of a transition sequence where every vector of values is replaced by a vector of syntactic expressions. We show that every transition sequence from function f to itself corresponds to a call path from f to itself. <p> Finally, parameter vals of eval is marked isd because the only paths in flow path that have vals as their target are in insitu decr path. 2 Readers familiar with the work of Glenstrup and Jones <ref> [3] </ref> will notice that Algorithm 1 has a substantially different structure than their algorithm (quite apart from the use of CFL-reachability). In the algorithm of Glenstrup and Jones, parameters may be identified as in-situ-decreasing on the basis of the BSV behaviour of other parameters. <p> Glenstrup and Jones define a second algorithm for identifying in-situ-decreasing parameters, which uses the markings ", # and = on edges in the parameter dependency graph <ref> [3] </ref>. The algorithm described in this 13 paper extends their work by using more precise markings on flow edges and by using CFL-reachability to identify a broader class of size-decreasing paths. Andersen and Holst have described an extension of Holst's analysis to a higher-order lambda calculus [2]. <p> In order to identify a greater number of in-situ-decreasing parameters than Glenstrup and Jones, we extend the parameter dependency graph with new nodes and new edge markings and we use CFL-reachability rather than a closed semi-ring graph algorithm <ref> [1, 3] </ref>. * There is a general result that all "context-free language reachability problems" can be solved in time cubic in the number of vertices in the graph [15].
Reference: [4] <author> C.K. Holst. </author> <title> Finiteness analysis. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <booktitle> August 1991 (Lecture Notes in Computer Science, </booktitle> <volume> vol. 523), </volume> <pages> pages 473-495. </pages> <publisher> ACM, Berlin: Springer-Verlag, </publisher> <year> 1991. </year> <month> 14 </month>
Reference-contexts: is that they may fall into an infinite loop or an infinite recursion because of "static-infinite computations" in a subject program [5, 13] (e.g. infinite loops that are completely static.) In this paper, we develop a BTA algorithm that marks every "static-infinite computation" as "dynamic", extending the work of Holst <ref> [4] </ref> and of Glenstrup and Jones [3]. As pointed out by Jones in [6], partial evaluation involves a basic tradeoff between "totality" and "computational completeness". <p> In the context of functional programs without looping constructs and infinite data structures, non-terminating behaviour results from infinite recursion. Holst has shown that in programs that manipulate list data it is possible to identify functions that are limited to finite recursion <ref> [4] </ref>. He identifies parameters that are "in-situ decreasing": An in-situ decreasing parameter of a function f strictly decreases in size on every (recursive) chain of calls from f to f. <p> is the number of parameters in p, V ar is the number of where variables in p, and Ops is the number of cons/car/cdr operations in p. 8 Related work The basis for the work described in this paper is Holst's definition of the in-situ-decreasing property for function parameters in <ref> [4] </ref>: An in-situ decreasing parameter of a function f strictly decreases in size on every (recursive) chain of calls from f to f. Glenstrup and Jones define a second algorithm for identifying in-situ-decreasing parameters, which uses the markings ", # and = on edges in the parameter dependency graph [3].
Reference: [5] <author> N.D. Jones. </author> <title> Automatic program specialization: A re-examination from basic principles. </title> <editor> In D. Bjtrner, A.P. Ershov, and N.D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 225-282. </pages> <address> Amsterdam: </address> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: The role of a binding-time analysis (BTA) is to annonate all statements in a subject program as either "static" or "dynamic". A typical basis for binding-time analysis is the notion of congruence <ref> [5] </ref>: A BTA is congruent if no statements annotated "static" by the BTA depend on statements annotated "dynamic". The annotated program is passed to a specializer, which executes the statements marked static and produces residual code for the statements marked dynamic. <p> A known problem with off-line partial evaluators that use congruence-based binding-time analysis is that they may fall into an infinite loop or an infinite recursion because of "static-infinite computations" in a subject program <ref> [5, 13] </ref> (e.g. infinite loops that are completely static.) In this paper, we develop a BTA algorithm that marks every "static-infinite computation" as "dynamic", extending the work of Holst [4] and of Glenstrup and Jones [3].
Reference: [6] <author> N.D. Jones, C.K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: As pointed out by Jones in <ref> [6] </ref>, partial evaluation involves a basic tradeoff between "totality" and "computational completeness".
Reference: [7] <author> J. Kasami. </author> <title> An efficient recognition and syntax analysis algorithm for context-free languages. </title> <type> Scientific Report AFCRL-65-758, </type> <institution> Air Force Cambridge Research Laboratory, Bedford, </institution> <address> MA, </address> <year> 1965. </year>
Reference-contexts: CFL-reachability problems can be solved using a dynamic-programming algorithm. (The algorithm can be thought of as a generalization of the CYK algorithm for context-free recognition <ref> [7, 16] </ref>.) There is a general result that all CFL-reachability problems can be solved in time cubic in the number of vertices in the graph [15].
Reference: [8] <author> D. Melski and T. Reps. </author> <title> Interconvertibility of set constraints and context-free langauge reachability. </title> <type> Technical Report 1330, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: Reps used CFL-reachability to develop a shape-analysis algorithm [9]. He used edge markings that are identical to the markings used on the edges of the ADDG defined in this paper. Melski and Reps have shown that CFL-reachability problems are convertible into a class of set-constraint problems (and vice versa) <ref> [8] </ref>. Because set-constraints are related to regular-tree grammars, this result also has some bearing on the relationship between our work and that of Andersen and Holst.
Reference: [9] <author> T. Reps. </author> <title> Shape analysis as a generalized path problem. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> La Jolla, California, </address> <month> June </month> <year> 1995, </year> <pages> pages 1-11. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1995. </year>
Reference-contexts: This allows our technique to determine that the path is size-decreasing: Because the cons operation on cdr (vals) is balanced by the cdr operation on state, the net effect is that just a single cdr is applied to vals. 2 To handle such cases, we use CFL-reachability <ref> [9] </ref>, a generalized form of graph reachability. A CFL-reachability problem is one in which a path is considered to connect two vertices in a graph only if the concatenation of the labels on the edges of the path is a word in a certain context-free language. <p> CFL-reachability has also been used for a number of other program-analysis problems: Reps, Sagiv, and Horwitz applied CFL-reachability techniques to interprocedural dataflow-analysis problems [11, 12] and to inter-procedural slicing [10]. Reps used CFL-reachability to develop a shape-analysis algorithm <ref> [9] </ref>. He used edge markings that are identical to the markings used on the edges of the ADDG defined in this paper. Melski and Reps have shown that CFL-reachability problems are convertible into a class of set-constraint problems (and vice versa) [8].
Reference: [10] <author> T. Reps, S. Horwitz, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <booktitle> In SIGSOFT 94: Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <address> (New Orleans, LA, </address> <month> December 7-9, </month> <year> 1994), </year> <booktitle> ACM SIGSOFT Software Engineering Notes 19(5), </booktitle> <pages> pages 11-20, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: CFL-reachability has also been used for a number of other program-analysis problems: Reps, Sagiv, and Horwitz applied CFL-reachability techniques to interprocedural dataflow-analysis problems [11, 12] and to inter-procedural slicing <ref> [10] </ref>. Reps used CFL-reachability to develop a shape-analysis algorithm [9]. He used edge markings that are identical to the markings used on the edges of the ADDG defined in this paper.
Reference: [11] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedural dataflow analysis via graph reachability. </title> <type> Technical Report 94/14, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: CFL-reachability has also been used for a number of other program-analysis problems: Reps, Sagiv, and Horwitz applied CFL-reachability techniques to interprocedural dataflow-analysis problems <ref> [11, 12] </ref> and to inter-procedural slicing [10]. Reps used CFL-reachability to develop a shape-analysis algorithm [9]. He used edge markings that are identical to the markings used on the edges of the ADDG defined in this paper.
Reference: [12] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Conference Record of the Twenty-Second ACM Syposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <year> 1995), </year> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: CFL-reachability has also been used for a number of other program-analysis problems: Reps, Sagiv, and Horwitz applied CFL-reachability techniques to interprocedural dataflow-analysis problems <ref> [11, 12] </ref> and to inter-procedural slicing [10]. Reps used CFL-reachability to develop a shape-analysis algorithm [9]. He used edge markings that are identical to the markings used on the edges of the ADDG defined in this paper.
Reference: [13] <author> P. Sestoft. </author> <title> Automatic call unfolding in a partial evaluator. </title> <editor> In D. Bjtrner, A.P. Ershov, and N.D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 485-506. </pages> <address> Amsterdam: </address> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: A known problem with off-line partial evaluators that use congruence-based binding-time analysis is that they may fall into an infinite loop or an infinite recursion because of "static-infinite computations" in a subject program <ref> [5, 13] </ref> (e.g. infinite loops that are completely static.) In this paper, we develop a BTA algorithm that marks every "static-infinite computation" as "dynamic", extending the work of Holst [4] and of Glenstrup and Jones [3].
Reference: [14] <author> M. Wegman and K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <booktitle> In Conference Record of the Twelfth ACM Syposium on Principles of Programming Languages, </booktitle> <pages> pages 291-299, </pages> <year> 1985. </year>
Reference-contexts: The 2 We use the notation foo path (m,n) to mean that that n is reachable from m via a path in the language foo path. 12 expression is then simplified using a standard intra-procedural constant propagation technique such as the algorithm of Wegman and Zadeck in <ref> [14] </ref>. If the simplified expression does not contain any occurences of ?, parameter f j satisfies the influential property and f j is marked as influ.
Reference: [15] <author> M. Yannakakis. </author> <title> Graph-theoretic methods in database theory. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pages 230-242, </pages> <year> 1990. </year>
Reference-contexts: CFL-reachability problems can be solved using a dynamic-programming algorithm. (The algorithm can be thought of as a generalization of the CYK algorithm for context-free recognition [7, 16].) There is a general result that all CFL-reachability problems can be solved in time cubic in the number of vertices in the graph <ref> [15] </ref>. <p> the parameter dependency graph with new nodes and new edge markings and we use CFL-reachability rather than a closed semi-ring graph algorithm [1, 3]. * There is a general result that all "context-free language reachability problems" can be solved in time cubic in the number of vertices in the graph <ref> [15] </ref>.
Reference: [16] <author> D.H. Younger. </author> <title> Recognition and parsing of context-free languages in time n 3 . Information and Control, </title> (10):189-208, 1967. 
Reference-contexts: CFL-reachability problems can be solved using a dynamic-programming algorithm. (The algorithm can be thought of as a generalization of the CYK algorithm for context-free recognition <ref> [7, 16] </ref>.) There is a general result that all CFL-reachability problems can be solved in time cubic in the number of vertices in the graph [15].
References-found: 16

