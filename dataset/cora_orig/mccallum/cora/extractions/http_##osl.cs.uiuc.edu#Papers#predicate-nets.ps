URL: http://osl.cs.uiuc.edu/Papers/predicate-nets.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Language.html
Root-URL: http://www.cs.uiuc.edu
Email: fshaku j aghag@cs.uiuc.edu sami@lri.fr  
Title: Visualizing Actor Programs using Predicate Transition Nets  
Author: Shakuntala Miriyala and Gul Agha Yamina Sami 
Address: Urbana, IL 61801, USA 91405 Orsay Cedex, France  
Affiliation: Dept. of Computer Science LRI, UA410 CNRS University of Illinois Bat 490, Universite Paris-Sud  
Abstract: The Actor model of concurrent computation unifies the functional and object-oriented programming language paradigms. The model provides a flexible basis for concurrent programming. It supports local state, dynamic creation and configuration, and inherent parallelism. Because of the fluidity of Actors, specifying and debugging actor systems is often considered difficult. We believe visual programming techniques are of fundamental importance in addressing powerful concurrent systems of this nature. Not surprisingly, a number of methods to visualize actor programs have been proposed. We give an outline of visualization techniques and their relation to actors. We then discuss one such proposal, namely the use of Predicate Transition nets, to visualize actor programs. 
Abstract-found: 1
Intro-found: 1
Reference: [Agh86] <author> G. A. Agha. </author> <title> A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1986. </year>
Reference-contexts: Actors were originally proposed in the mid 70's by Carl Hewitt [Hew77]. The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system <ref> [Agh86] </ref>, by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models [SVN91, ELR90, JR89]. Actors have been proposed as a universal model for parallel complexity [BVN91]. <p> In particular, the latter work shows that CPN's can emulate important aspects of arbitrary actor programs defined in Agha's semantics <ref> [Agh86] </ref>. Our interest is a more practical one we have implemented and experimented with the system we describe. We have also developed a number of important generalizations and specializations which simplify the visual descriptions of unserialized actors, enabledness conditions, multiparty interactions, hierarchical abstractions, and meta-level architectures. <p> Additional places for address generator and communication are introduced in the transformation. 3 The Actor Model The actor model, first proposed by Carl Hewitt [Hew77] and later developed by one of the authors <ref> [Agh86] </ref>, captures the essence of concurrent computation in distributed systems at an abstract level. In the model, the universe contains computational agents, called actors, which are distributed in time and space. Each actor has a conceptual location (its mail address) and a behavior. <p> By contrast, the behavior of actors is inherently concurrent. Actors support local state: an actor computes its replacement behavior in order to account for changes in its responses subsequent to the commu 7 nication it has just processed. A program in an actor language consists of <ref> [Agh86] </ref>: * behavior definitions which associate a behavior schema with an identifier, without actually creating an actor. * new expressions which create new actors and return their mail addresses. <p> In the following section, we discuss how PrT-nets provide an abstract representation for actor programs as modeled in <ref> [Agh86] </ref>. The behavior definitions of an actor program are captured by the static places and transitions, while the dynamic parts of an actor program namely, actors and messages are mapped to the tokens of a PrT-net. <p> Instead of associating separate places for address generation in each behavior, we assume a tagging scheme on message tokens which allows extension of the tags to locally generate globally unique mail addresses and new tags (as in the semantic operational model in <ref> [Agh86] </ref>). As a simplification, we simply ignore the details of an address generation scheme. We assume that the underlying actor execution system generates unique actor mail addresses which appear in the appropriate tokens. <p> This eliminates the need for an additional place like the address-generator. * A variation of the SV-N algorithm models a version of Actors known as SAL, that is described in Chapter 3 of <ref> [Agh86] </ref>. Transition of actor tokens when a become command is executed, is handled by an additional place called `aficionados.' The execution of become B2 by an actor is interpreted by putting the associated actor token in the aficionado place.
Reference: [Agh89] <author> G. A. Agha. </author> <title> Supporting multiparadigm programming on actor architectures. </title> <booktitle> In Proceedings of Parallel Architectures and Languages Europe, Vol. II: Parallel Languages (PARLE '89), </booktitle> <pages> pages 1-19. </pages> <address> Espirit, </address> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> LNCS 366. </note>
Reference-contexts: Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming <ref> [Agh89] </ref> and variants of it have been used to support concurrent object-oriented programming [Agh90b, Yon90]. We use a net-theoretic model, namely Predicate Transition net (PrT-net), to provide a visual representation of actor systems. PrT-nets are a high-level extension of the Petri Net model of concurrency.
Reference: [Agh90a] <author> G. Agha. </author> <title> The structure and semantics of actor languages. </title> <editor> In J. W. deBakker, W. P. deRoever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <pages> pages 1-59. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS 489. </note>
Reference-contexts: In either case, observe that actor tokens are still required to depict the customers (continuations). An important issue in actor based systems is the problem of synchronization constraints, i.e., conditions limiting the communications an actor in a given state is able to process <ref> [Agh90a] </ref>. For example, a bounded buffer which is empty cannot service requests to dequeue. Different approaches to selectively process external communications may be taken (see [Agh90b]). One solution used by actor systems is to let an actor explicitly buffer incoming communications which it is not ready to process (insensitive actors).
Reference: [Agh90b] <author> G. A. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming <ref> [Agh90b, Yon90] </ref>. We use a net-theoretic model, namely Predicate Transition net (PrT-net), to provide a visual representation of actor systems. PrT-nets are a high-level extension of the Petri Net model of concurrency. Under certain finiteness restrictions, PrT-nets can be mapped to equivalent Petri nets. <p> For example, a bounded buffer which is empty cannot service requests to dequeue. Different approaches to selectively process external communications may be taken (see <ref> [Agh90b] </ref>). One solution used by actor systems is to let an actor explicitly buffer incoming communications which it is not ready to process (insensitive actors).
Reference: [AS88] <author> W. Athas and C. Seitz. </author> <title> Multicomputers: Message-passing concurrent computers. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 9-23, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: A multicomputer is an ensemble of computers (processors with local memory) connected by a global (virtual) network. The actor model combines procedural and data abstraction with concurrency. Thus, Actors provide a powerful programming model for multicomputers <ref> [AS88, Dal86] </ref>. Actors were originally proposed in the mid 70's by Carl Hewitt [Hew77]. The concept has continued to evolve and has recently generated increasing interest.
Reference: [BLP88] <author> Tommaso Bolognesi, Diego Latella, and Annamaria Pisano. </author> <title> Towards a graphic syntax for lotos. </title> <booktitle> Research into Networks and Distributed Applications, </booktitle> <pages> pages 973-987, </pages> <year> 1988. </year>
Reference-contexts: In particular, a number of visual models, including GARP, Augmented Event Diagrams, and various net models, have been used to specify the structure or behavior of actor systems. We describe some of these systems and their applicability to developing representations for actor-like dynamic systems. G-LOTOS Graphic-LOTOS (G-Lotos) <ref> [BLP88] </ref> is a visual notation for the LOTOS specification language. LOTOS is closely related to Milner's Calculus of Concurrent Systems it allows synchronous communication between agents whose interconnection pattern is fixed at compile time. In G-Lotos, each basic element of a program is mapped to a pictorial representation.
Reference: [BVN91] <author> F. Baude and G. </author> <title> Vidal-Naquet. Actors as a parallel programming model. </title> <booktitle> In Proceedings of 8th Symposium on Theoretical Aspects of Computer Science, </booktitle> <year> 1991. </year> <note> LNCS 480. </note>
Reference-contexts: The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system [Agh86], by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models [SVN91, ELR90, JR89]. Actors have been proposed as a universal model for parallel complexity <ref> [BVN91] </ref>. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming [Agh90b, Yon90]. We use a net-theoretic model, namely Predicate Transition net (PrT-net), to provide a visual representation of actor systems.
Reference: [Cli81] <author> W. D. Clinger. </author> <title> Foundations of actor semantics. </title> <type> AI-TR- 633, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: Thus, Actors provide a powerful programming model for multicomputers [AS88, Dal86]. Actors were originally proposed in the mid 70's by Carl Hewitt [Hew77]. The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics <ref> [Cli81] </ref>, by a transition system [Agh86], by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models [SVN91, ELR90, JR89]. Actors have been proposed as a universal model for parallel complexity [BVN91].
Reference: [Dal86] <author> W. Dally. </author> <title> A VLSI Architecture for Concurrent Data Structures. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: A multicomputer is an ensemble of computers (processors with local memory) connected by a global (virtual) network. The actor model combines procedural and data abstraction with concurrency. Thus, Actors provide a powerful programming model for multicomputers <ref> [AS88, Dal86] </ref>. Actors were originally proposed in the mid 70's by Carl Hewitt [Hew77]. The concept has continued to evolve and has recently generated increasing interest.
Reference: [ELR90] <author> J. Engelfrient, G. Leih, and G. Rozenberg. </author> <title> Parallel object-based systems and petri nets. </title> <type> Technical report, </type> <institution> Leiden university, Netherlands, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system [Agh86], by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models <ref> [SVN91, ELR90, JR89] </ref>. Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming [Agh90b, Yon90]. <p> At least two distinct net theoretic approaches have been proposed to model actor-based systems: the Parallel Object-Based Transition System (Pots) and Colored Petri Nets (CPN). In fact, the model we use is closely related to CPN. Engelfriet, Leih and Rozenberg <ref> [ELR90] </ref> developed the Pots formalism to represent parallel object-based systems. Pots is a Petri net model augmented by an additional annotation used to indicate the acquaintances of an object (acquaintances are objects an object knows about).
Reference: [Gen87] <author> H.J. Genrich. </author> <title> Predicate/transition nets. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> (254):207-247, 1987. 
Reference-contexts: After philosopher p 3 has dined, he releases his forks and any of the other philosophers can enter the dining state. Following Genrich <ref> [Gen87] </ref>, the basic form of a PrT-net, P N , is defined as (N; A; M 0 ), where 1. <p> In both the approaches, actors and messages are represented by tokens, and behaviors are represented by the graph of the net. The use of tokens in a PrT-net and colors in CPN do not correspond to the definitions in <ref> [Gen87] </ref> and [Jen90] respectively. Because the address and state of the actors to be generated are not known at compile time, the set of tokens in a PrT-net and, correspondingly, colors in a CPN, are not fixed at the beginning of execution.
Reference: [GL81] <author> H.J. Genrich and K. Lautenbach. </author> <title> System modelling with high-level petri nets. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 109-136, </pages> <year> 1981. </year>
Reference-contexts: Under certain finiteness restrictions, PrT-nets can be mapped to equivalent Petri nets. Net theory is a well-studied model of concurrency. In particular, a number of net theoretic techniques have been developed to formally verify properties of concurrent systems such as reachability, deadlock, livelock, etc. (see, for example, <ref> [GL81, Vau87, Rei85] </ref>). Note that Predicate Transition nets are formally equivalent to Colored Petri Nets used by Sami and Vidal-Naquet to model actors. <p> The current trend in the field of net-theory is to translate an analysis method developed for one kind of net to another. When PrT-nets were first introduced by Genrich and Lautenbach <ref> [GL81] </ref>, generalizing place invariants and transition invariants in the net seemed difficult. The invariants contain free variables and to interpret these invariants, it is necessary to bind these variables by a complex set of substitution rules. This made the interpretation of invariants difficult.
Reference: [Goe90] <author> S. K. Goering. </author> <title> A graph grammar approach to concurrent programming. </title> <type> Technical Report UIUCDCS-R-90-1576, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1990. </year> <month> 31 </month>
Reference-contexts: While the declarative approach is in principle superior to explicit directives, the current state of the art requires specifying a rendering function on a per system basis. Further work is required to provide a basis for building reusable abstractions. GARP In GARP (Graphical Abstraction for concurRent Processing) <ref> [Goe90] </ref>, a running program consists of a set of processes which communicate by message passing. Internal behavior of each process is defined structurally using text and communication between processes is specified graphically. GARP uses 4-grammar rewrite rules to expand complex nodes into simpler subgraphs [KGC89]. <p> The specifications inside the internal nodes take care of evaluating expressions, sending and analyzing messages and making decisions to control the computation <ref> [Goe90] </ref>. Although GARP effectively represents the potential primitive actions of an actor, it does not provide a mechanism for representing complex multiparty interaction patterns as a single visual abstraction. Actor Grammars Actor grammars are a formalization of finitary actor systems in terms of a graph grammar model [JR89].
Reference: [Hew77] <author> C. E. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3) </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: A multicomputer is an ensemble of computers (processors with local memory) connected by a global (virtual) network. The actor model combines procedural and data abstraction with concurrency. Thus, Actors provide a powerful programming model for multicomputers [AS88, Dal86]. Actors were originally proposed in the mid 70's by Carl Hewitt <ref> [Hew77] </ref>. The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system [Agh86], by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models [SVN91, ELR90, JR89]. <p> The transformation from actor programs to a CPN is based on the actor commands within a behavior definition. Additional places for address generator and communication are introduced in the transformation. 3 The Actor Model The actor model, first proposed by Carl Hewitt <ref> [Hew77] </ref> and later developed by one of the authors [Agh86], captures the essence of concurrent computation in distributed systems at an abstract level. In the model, the universe contains computational agents, called actors, which are distributed in time and space.
Reference: [Jef85] <author> D.R. Jefferson. </author> <title> Virtual time. </title> <journal> ACM TOPLAS, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <year> 1985. </year>
Reference-contexts: Here a provision for real-time intervention is necessary. One way of doing this is to slow down the execution of the system with the help of a synchronous message passing protocol. A better alternative for a distributed implementation is to use a time-warp mechanism with roll-back <ref> [Jef85] </ref>, where the official global clock corresponds to the display of the tokens. Specifying and visualizing large concurrent systems with Predicate Transitions nets is cumbersome and thus error prone. A mechanism to add further layers of abstraction is to break the net into smaller subnets.
Reference: [Jen81] <author> K. Jensen. </author> <title> Colored petri nets and the invariant method. </title> <journal> TCS, </journal> <volume> 14 </volume> <pages> 317-336, </pages> <year> 1981. </year>
Reference-contexts: The invariants contain free variables and to interpret these invariants, it is necessary to bind these variables by a complex set of substitution rules. This made the interpretation of invariants difficult. To solve this problem a first version of CPN was introduced by Jensen <ref> [Jen81] </ref>. The main ideas are similar to PrT-nets, but the relation between an occurrence element and token colors involved in the occurrence is defined by functions instead of expressions.
Reference: [Jen83] <author> K. Jensen. </author> <title> High-level petri nets. </title> <publisher> LNCS, </publisher> (66):166-180, 1983. 
Reference-contexts: However, the functions attached to arcs in a CPN are more difficult to read and understand than the expressions attached to arcs in PrT-nets. This led to an improved model of CPN called a high-level net <ref> [Jen83] </ref>. The modeling of actors by CPN and PrT-net can be divided into two stages. The first consists of deriving some information from the given actor program to be used in modeling. This stage is identical in both the approaches.
Reference: [Jen90] <author> K. Jensen. </author> <title> Colored petri nets: A high level language for system design and analysis. </title> <booktitle> Lecture Notes in Computer Science: Advances in Petri Nets, </booktitle> <year> 1990. </year>
Reference-contexts: In both the approaches, actors and messages are represented by tokens, and behaviors are represented by the graph of the net. The use of tokens in a PrT-net and colors in CPN do not correspond to the definitions in [Gen87] and <ref> [Jen90] </ref> respectively. Because the address and state of the actors to be generated are not known at compile time, the set of tokens in a PrT-net and, correspondingly, colors in a CPN, are not fixed at the beginning of execution. <p> However, in the CPN approach all message tokens are contained in the communication place. Although PrT-nets and CPN's are considered two different dialects of the same language <ref> [Jen90] </ref>, we think that PrT-nets provides a than CPN's to model actors. <p> Specifying and visualizing large concurrent systems with Predicate Transitions nets is cumbersome and thus error prone. A mechanism to add further layers of abstraction is to break the net into smaller subnets. Jensen <ref> [Jen90] </ref> describes hierarchical nets to model large systems. A hierarchical net is composed of smaller divisions called pages. Each page is a net in itself and can be used to represent a subsystem. The concept of hierarchical nets could be extended to visualize execution of large actor programs.
Reference: [JR89] <author> D. Janssens and G. Rozenberg. </author> <title> Actor grammars. </title> <journal> Mathematical Systems Theory, </journal> (22):75-107, 1989. 
Reference-contexts: The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system [Agh86], by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models <ref> [SVN91, ELR90, JR89] </ref>. Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming [Agh90b, Yon90]. <p> Although GARP effectively represents the potential primitive actions of an actor, it does not provide a mechanism for representing complex multiparty interaction patterns as a single visual abstraction. Actor Grammars Actor grammars are a formalization of finitary actor systems in terms of a graph grammar model <ref> [JR89] </ref>. The actor grammars framework is particularly suitable for representing configurations (distributed snapshots) of actor systems. Corresponding to each configuration of an actor system, there is a graph and, corresponding to each transition in an actor system, there is a graph transformation.
Reference: [KGC89] <author> S. M. Kaplan, S. K. Goering, and R. H. Campbell. </author> <title> Specifying concurrent systems with 4 grammars. </title> <booktitle> pages 20-27. The fifth International Workshop on Software Specification and Design, </booktitle> <month> April </month> <year> 1989. </year>
Reference-contexts: Internal behavior of each process is defined structurally using text and communication between processes is specified graphically. GARP uses 4-grammar rewrite rules to expand complex nodes into simpler subgraphs <ref> [KGC89] </ref>. GARP provides an interleaving model of concurrency: computation may be carried out by repeatedly choosing a production from a set of rewrite rules, and applying it to transform the graph.
Reference: [Man87] <author> C. Manning. Traveler: </author> <title> the actor observatory. Proceedings of European Conference on Object-Oriented Programming. </title> <note> Also appeared in LNCS, (276), </note> <month> January </month> <year> 1987. </year>
Reference-contexts: Each lifeline is augmented with a box like structure to represent pending events, i.e., communications which have been sent but not processed. Augmented Event Diagrams were used by Manning in the Traveler observatory to support the debugging of actor programs <ref> [Man87] </ref>. A significant source of complexity in event diagrams is that they contain every event, and in any realistic concurrent systems, there are simply too many events. Manning addresses this difficulty by structuring computations into sets of events which causally connect a response to a request (much like a transaction).
Reference: [Mes90] <author> J. Meseguer. </author> <title> A logical theory of concurrent objects. </title> <booktitle> In OOPSLA/ECOOP Proceedings, </booktitle> <address> New York, 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system [Agh86], by term rewriting and category theoretic constructs <ref> [Mes90] </ref> and by Petri Nets and related models [SVN91, ELR90, JR89]. Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming [Agh90b, Yon90].
Reference: [RC89] <author> G. Roman and K. C. Cox. </author> <title> A declarative approach to visualizing concurrent computations. </title> <booktitle> IEEE COMPUTER, </booktitle> <pages> pages 25-36, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: This makes it unsuitable for a number of applications such as fault-tolerant computing. Roman's Visualization System Roman proposes a declarative approach to visualization and applies the methodology to a shared dataspace model of concurrency <ref> [RC89] </ref>. In the shared dataspace model, concurrent processes communicate via addressable data structures. Roman's visualization approach is to require a formal mapping between computational states of a program and their rendering in terms of graphical objects.
Reference: [Rei85] <author> W. Reisig. </author> <title> Petri Nets. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Under certain finiteness restrictions, PrT-nets can be mapped to equivalent Petri nets. Net theory is a well-studied model of concurrency. In particular, a number of net theoretic techniques have been developed to formally verify properties of concurrent systems such as reachability, deadlock, livelock, etc. (see, for example, <ref> [GL81, Vau87, Rei85] </ref>). Note that Predicate Transition nets are formally equivalent to Colored Petri Nets used by Sami and Vidal-Naquet to model actors. <p> The transition up-forks (P) indicates that the philosopher moves from thinking to dining state after receiving the required forks. The transition down-forks (P) indicates that after dining, a philosopher puts down his forks and enters the thinking state (figure adapted from <ref> [Rei85] </ref>) . of places, a set of transitions, and a set of arcs. The arcs are represented by arrows from places to transitions and from transitions to places known as input and output arcs respectively. The place from which an input arc originates is known as an input place. <p> By contrast, observe that actors are a lower-level model which represents point to point asynchronous communication inherent in distributed architectures. The working of a PrT-net is best understood through an example. Consider the dining philosophers problem modeled in Fig. 1 (from <ref> [Rei85] </ref>). A collection of philosophers is sitting around a table. Each philosopher has a plate in front of him. Between any two neighboring plates lies a fork. Whenever a philosopher eats he uses both forks, the one to the right and the other to the left of his plate.
Reference: [SF90] <author> David Stotts and Richard Furuta. </author> <title> Temporal hyperprogramming. </title> <journal> Journal of Visual languages and Computing, </journal> (1):237-253, 1990. 
Reference-contexts: Traveler is an evolving system and some of these deficiencies may be addressed by ongoing research. Net Theoretic Approaches Net theoretic models have been used in visual programming for a number of applications. For example, the Trellis Hypertext system <ref> [SF90] </ref> uses timed petri nets for temporal hyperprogram-ming. At least two distinct net theoretic approaches have been proposed to model actor-based systems: the Parallel Object-Based Transition System (Pots) and Colored Petri Nets (CPN). In fact, the model we use is closely related to CPN.
Reference: [SVN91] <author> Y. Sami and G. </author> <title> Vidal-Naquet. Formalization of the behavior of actors by colored petri nets and some applications. </title> <booktitle> PARLE '91, </booktitle> <year> 1991. </year>
Reference-contexts: The concept has continued to evolve and has recently generated increasing interest. The actor model has been formally characterized by means of power domain semantics [Cli81], by a transition system [Agh86], by term rewriting and category theoretic constructs [Mes90] and by Petri Nets and related models <ref> [SVN91, ELR90, JR89] </ref>. Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming [Agh90b, Yon90]. <p> Sami and Vidal-Naquet proposed the use of a high-level net, namely Colored Petri Net (CPN), to model actors <ref> [SVN91] </ref>. The transformation from actor programs to a CPN is based on the actor commands within a behavior definition. <p> In particular, this means that reflective actor architectures may not be modelled. Such architectures allow the system level actors implementing an application to be dynamically accessible to the application 5 Modeling Actor programs with Predicate Transition nets Colored Petri nets (CPN's) have been used by Sami and Vidal-Naquet <ref> [SVN91] </ref> to formalize the behavior of actors. We will call their algorithm for transforming actors programs into CPN's the SV-N algorithm. Internal concurrency is depicted in the SV-N algorithm by interpreting actor program in terms of its primitive actions.
Reference: [TSS89] <author> C. Tomlinson, M. Scheevel, and V. Singh. </author> <title> Report on rosette 1.0. </title> <type> Technical Report ACT-OODS-449-89(Q), </type> <institution> Object-Based Concurrent Systems Project, MCC, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: A become command must be embedded in a behavior definition and it will be used to determine the new behavior of an actor whose definition is specified using the behavior schema. The behavior definition for checking accounts below illustrates programs in Rosette, an Actor language developed at MCC <ref> [TSS89] </ref>. A behavior definition is used in a new command to create individual actors with specific initial parameters. In this case, a number giving the initial value of balance and my-savings would be specified for creating a check-acc actor. <p> We illustrate the modeling process by a simple algorithm and then provide an algorithm for deriving a PrT-net from an actor program is given. 6.1 A Simple Recursive Program Consider the code for a factorial program based on the actor language Rosette <ref> [TSS89] </ref>. <p> Different approaches to selectively process external communications may be taken (see [Agh90b]). One solution used by actor systems is to let an actor explicitly buffer incoming communications which it is not ready to process (insensitive actors). In the Rosette language, Tomlinson and Singh <ref> [TSS89] </ref> proposed a mechanism which associates to each potential state of actor an enabled set specifying the particular methods the actor is willing to invoke. The actor then processes the first message in its queue which invokes a method in its current enabled set.
Reference: [Vau87] <author> J. Vautherin. </author> <title> Parallel systems specifications with coloured petri nets and algebraic abstract data types. </title> <booktitle> Advances in Petri Nets, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pages 291-308, </pages> <year> 1987. </year>
Reference-contexts: Under certain finiteness restrictions, PrT-nets can be mapped to equivalent Petri nets. Net theory is a well-studied model of concurrency. In particular, a number of net theoretic techniques have been developed to formally verify properties of concurrent systems such as reachability, deadlock, livelock, etc. (see, for example, <ref> [GL81, Vau87, Rei85] </ref>). Note that Predicate Transition nets are formally equivalent to Colored Petri Nets used by Sami and Vidal-Naquet to model actors.
Reference: [Yon90] <author> A. Yonezawa. </author> <title> ABCL An Object-Oriented Concurrent System. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1990. </year> <month> 32 </month>
Reference-contexts: Actors have been proposed as a universal model for parallel complexity [BVN91]. The model has also been proposed as a basis for multiparadigm programming [Agh89] and variants of it have been used to support concurrent object-oriented programming <ref> [Agh90b, Yon90] </ref>. We use a net-theoretic model, namely Predicate Transition net (PrT-net), to provide a visual representation of actor systems. PrT-nets are a high-level extension of the Petri Net model of concurrency. Under certain finiteness restrictions, PrT-nets can be mapped to equivalent Petri nets.
References-found: 29

