URL: http://www.cs.rice.edu/CS/PLT/Publications/pldi98-ff.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Units: Cool Modules for HOT Languages  
Author: Matthew Flatt Matthias Felleisen 
Address: Houston, Texas 77005-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: A module system ought to enable assembly-line programming using separate compilation and an expressive linking language. Separate compilation allows programmers to develop parts of a program independently. A linking language gives programmers precise control over the assembly of parts into a whole. This paper presents models of program units, MzScheme's module language for assembly-line programming. Units support separate compilation, independent module reuse, cyclic dependencies, hierarchical structuring, and dynamic linking. The models explain how to integrate units with untyped and typed languages such as Scheme and ML. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Barnes, J. G. P. </author> <title> Programming in Ada 95. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: However, even the most advanced linking systems rely on a global namespace of function names and module (i.e., file) names. As a result, modules can be linked and invoked only once in a program. Many modern languages (e.g., Ada 95 <ref> [1] </ref>, Modula-2 [30], Modula-3 [11], Haskell [15], and Java [10]) use packages. A package system delineates the boundaries of each module and forces the specification of static dependencies between modules. Since module linking and invocation are clearly separated, packages allow mutually recursive function and type definitions across package boundaries.
Reference: [2] <author> Biswas, S. K. </author> <title> Higher-order functors with transparent signatures. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 154-163. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [3] <author> Cardelli, L. </author> <title> Program fragments, linking, </title> <booktitle> and modu-larization. In Proc. ACM Symposium on Principles of Programming Languages (1997), </booktitle> <pages> pp. 266-277. </pages>
Reference-contexts: Existing module systems for HOT (higher-order, typed) languages do not enable assembly-line programming. Some HOT module languages do not provide separate compilation, making it impossible to test and distribute individual modules <ref> [3] </ref>. In other module languages, e.g., the package languages of Ada, Modula-3, and Java, connections are hard-wired within modules instead of specified in a separate assembly process. <p> Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli <ref> [3] </ref> anticipated the unit language's emphasis on module linking as well as module definition. Our unit model is more concrete than his proposal and addresses many of his suggestions for future work.
Reference: [4] <author> Curtis, P., and Rauen, J. </author> <title> A module system for Scheme. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 13-28. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [5] <author> Duggan, D., and Sourelis, C. </author> <title> Mixin modules. </title> <booktitle> In Proc. ACM International Conference on Functional Programming (1996), </booktitle> <pages> pp. 262-273. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules [2, 4, 12, 16, 18, 20, 21, 23, 29]. Duggan and Sourelis <ref> [5] </ref> have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [6] <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Tech. Rep. 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <journal> Theoretical Computer Science, </journal> <volume> volume 102, </volume> <year> 1992, </year> <pages> pp. 235-271. </pages>
Reference-contexts: For all three sections, we only consider those parts of the core language that are immediately relevant to units. The rigorous description of the unit language, including its type structures and semantics, relies on well-known type checking and rewriting techniques for Scheme and ML <ref> [6, 13, 31] </ref>. In the rewriting model of evaluation, the set of program expressions is partitioned into a set of values and a set of non-values. <p> The rules extend those for Scheme <ref> [6] </ref> and resemble equations in the higher-order module calculus of Harper, Mitchell, and Moggi [13]. The first rule specifies that an invoke expression reduces to a letrec expression containing the invoked unit's definitions and initialization expression. In this le-trec expression, imported variables are replaced by values.
Reference: [7] <author> Findler, R. B., Flanagan, C., Flatt, M., Krish-namurthi, S., and Felleisen, M. DrScheme: </author> <title> A pedagogic programming environment for Scheme. </title> <booktitle> In Proc. International Symposium on Programming Languages: Implementations, Logics, and Programs (1997), </booktitle> <pages> pp. 369-388. </pages>
Reference-contexts: Our unit model also addresses the often overlooked, but increasingly important, problem of dynamic linking. The unit language was originally implemented for the development of DrScheme <ref> [7, 25] </ref>, Rice's Scheme programming environment, which is implemented using MzScheme. DrScheme is a large and dynamic program with many integrated components, including a multimedia editor, an interactive evaluator, a syntax checker, and a static debugger. Additional components can be dynamically linked into the environment.
Reference: [8] <author> Flatt, M. PLT MzScheme: </author> <title> Language manual. </title> <type> Tech. Rep. </type> <institution> TR97-280, Rice University, </institution> <year> 1997. </year>
Reference-contexts: To appear: PLDI - June 17-19 1998, Montreal, Canada not support mutually recursive procedure and type definitions at the module level. Finally, few HOT module languages handle dynamic program construction and dynamic linking, which are needed for programs with "some assembly required," e.g., web-based applets. For MzScheme <ref> [8] </ref>, we designed and implemented a language of modules, called program units, to support assembly-line programming.
Reference: [9] <author> Flatt, M., Krishnamurthi, S., and Felleisen, M. </author> <title> Classes and mixins. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1998), </booktitle> <pages> pp. 171-183. </pages>
Reference-contexts: Classes suffer the same drawbacks as packages: links, such as a superclass name, are hardwired to a specific class <ref> [9] </ref>. assembling modules. Unlike package languages, the basic ML module, a structure, is not a fragment of unevaluated code. Instead, a structure is a record with fields containing the module's exported values and types.
Reference: [10] <author> Gosling, J., Joy, B., and Steele, G. </author> <title> The Java Language Specification. The Java Series. </title> <address> Addison-Wes-ley, Reading, MA, USA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, even the most advanced linking systems rely on a global namespace of function names and module (i.e., file) names. As a result, modules can be linked and invoked only once in a program. Many modern languages (e.g., Ada 95 [1], Modula-2 [30], Modula-3 [11], Haskell [15], and Java <ref> [10] </ref>) use packages. A package system delineates the boundaries of each module and forces the specification of static dependencies between modules. Since module linking and invocation are clearly separated, packages allow mutually recursive function and type definitions across package boundaries.
Reference: [11] <author> Harbison, S. P. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: However, even the most advanced linking systems rely on a global namespace of function names and module (i.e., file) names. As a result, modules can be linked and invoked only once in a program. Many modern languages (e.g., Ada 95 [1], Modula-2 [30], Modula-3 <ref> [11] </ref>, Haskell [15], and Java [10]) use packages. A package system delineates the boundaries of each module and forces the specification of static dependencies between modules. Since module linking and invocation are clearly separated, packages allow mutually recursive function and type definitions across package boundaries.
Reference: [12] <author> Harper, R., and Lillibridge, M. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1994), </booktitle> <pages> pp. 123-137. </pages>
Reference-contexts: In the following subsections, we briefly discuss each of these concepts. 5.1 Exposing Type Information The ML module system allows signatures that reveal some information about an exported type <ref> [12, 20] </ref>. The partially exposed types (or translucent types) are used for propagating type dependencies in a way that allows type sharing, but they are also useful for assigning a name to a complex type that is exposed to clients. <p> The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [13] <author> Harper, R., Mitchell, J., and Moggi, E. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1990), </booktitle> <pages> pp. 341-354. </pages>
Reference-contexts: For all three sections, we only consider those parts of the core language that are immediately relevant to units. The rigorous description of the unit language, including its type structures and semantics, relies on well-known type checking and rewriting techniques for Scheme and ML <ref> [6, 13, 31] </ref>. In the rewriting model of evaluation, the set of program expressions is partitioned into a set of values and a set of non-values. <p> The rules extend those for Scheme [6] and resemble equations in the higher-order module calculus of Harper, Mitchell, and Moggi <ref> [13] </ref>. The first rule specifies that an invoke expression reduces to a letrec expression containing the invoked unit's definitions and initialization expression. In this le-trec expression, imported variables are replaced by values.
Reference: [14] <author> Harper, R., and Stone, C. </author> <title> A type-theoretic semantics for Standard ML 1996. </title> <note> Submitted for publication, </note> <year> 1997. </year>
Reference-contexts: The scope of a defined variable includes all of the definition expressions e v in the unit as well as the initialization expression e. In each definition val x = e v , the expression e v must be valuable in the sense of Harper and Stone <ref> [14] </ref>, with the restriction that imported and defined variable names are not considered valuable.
Reference: [15] <editor> Hudak, P., and Wadler, P. (Eds.). </editor> <title> Report on the programming language Haskell. </title> <type> Tech. Rep. </type> <institution> YALE/DCS/RR777, Yale University, Department of Computer Science, </institution> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: However, even the most advanced linking systems rely on a global namespace of function names and module (i.e., file) names. As a result, modules can be linked and invoked only once in a program. Many modern languages (e.g., Ada 95 [1], Modula-2 [30], Modula-3 [11], Haskell <ref> [15] </ref>, and Java [10]) use packages. A package system delineates the boundaries of each module and forces the specification of static dependencies between modules. Since module linking and invocation are clearly separated, packages allow mutually recursive function and type definitions across package boundaries.
Reference: [16] <author> Jagannathan, S. </author> <title> Metalevel building blocks for modular systems. </title> <journal> ACM Transactions on Programming Languages and Systems 16, </journal> <month> 3 (May </month> <year> 1994), </year> <pages> 456-492. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [17] <author> Kelsey, R. A. </author> <title> Fully-parameterized modules or the missing link. </title> <type> Tech. Rep. 97-3, </type> <institution> NEC Research Institute, </institution> <year> 1997. </year>
Reference-contexts: Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition. Our unit model is more concrete than his proposal and addresses many of his suggestions for future work. Kelsey's proposed module system for Scheme <ref> [17] </ref> captures most of the organizational properties of units, but does not address static typing or dynamic linking. 7 Conclusion Program units deliver both the traditional benefits of modules for separate compilation and the more recent advances of higher-order modules and programmer-controlled linking.
Reference: [18] <author> Lee, Shinn-Der and Daniel P. Friedman. </author> <title> Quasi-static scoping: Sharing variable bindings across multiple lexical scopes. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1993), </booktitle> <pages> pp. 479-492. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [19] <author> Leroy, X. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1992), </booktitle> <pages> pp. 177-188. </pages>
Reference-contexts: When compiling a unit, imported types are obviously not yet determined and thus have unknown representations. Hence, expressions involving imported types must be compiled like polymorphic functions in ML <ref> [19, 28] </ref>. Otherwise, the restrictions implied by a unit's interface allow inter-procedural optimizations within the unit (such as inlining, specialization, and dead-code elimination).
Reference: [20] <author> Leroy, X. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1994), </booktitle> <pages> pp. 109-122. </pages>
Reference-contexts: In the following subsections, we briefly discuss each of these concepts. 5.1 Exposing Type Information The ML module system allows signatures that reveal some information about an exported type <ref> [12, 20] </ref>. The partially exposed types (or translucent types) are used for propagating type dependencies in a way that allows type sharing, but they are also useful for assigning a name to a complex type that is exposed to clients. <p> The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [21] <author> Leroy, X. </author> <title> Applicative functions and fully transparent higher-order modules. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 142-153. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [22] <author> MacQueen, D. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming (1984), </booktitle> <pages> pp. 198-207. </pages>
Reference-contexts: In addition, among the languages with packages, only Java provides a mechanism for dynamic linking. This mechanism is expressed indirectly via the language of class loaders, and is not fully general due to the constraints of a global package namespace. 2 ML's functor system <ref> [22, 24] </ref> is the most notable example of a language that lets a programmer describe abstractions over modules and gives a programmer direct control over 2 Java's class system can also be viewed as a kind of module system or as a complement to the package system. <p> As a result, the information formerly exposed by the abbreviation becomes hidden, replaced by an opaque type. 5.3 Sharing Type sharing specifications are used to solve the "diamond import" problem for ML <ref> [22] </ref>. Suppose a particular symbol structure is provided to both a lexer functor and a parser functor.
Reference: [23] <author> MacQueen, D. B., and Tofte, M. </author> <title> A semantics for higher-order functors. </title> <booktitle> In European Symposium on Programming (Apr. 1994), </booktitle> <publisher> Springer-Verlag, LNCS 788, </publisher> <pages> pp. 409-423. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [24] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: In addition, among the languages with packages, only Java provides a mechanism for dynamic linking. This mechanism is expressed indirectly via the language of class loaders, and is not fully general due to the constraints of a global package namespace. 2 ML's functor system <ref> [22, 24] </ref> is the most notable example of a language that lets a programmer describe abstractions over modules and gives a programmer direct control over 2 Java's class system can also be viewed as a kind of module system or as a complement to the package system.
Reference: [25] <institution> Rice University PLT. DrScheme. </institution> <note> URL: www.cs.rice.edu/CS/PLT/packages/drscheme/. </note>
Reference-contexts: Our unit model also addresses the often overlooked, but increasingly important, problem of dynamic linking. The unit language was originally implemented for the development of DrScheme <ref> [7, 25] </ref>, Rice's Scheme programming environment, which is implemented using MzScheme. DrScheme is a large and dynamic program with many integrated components, including a multimedia editor, an interactive evaluator, a syntax checker, and a static debugger. Additional components can be dynamically linked into the environment.
Reference: [26] <author> Saraswat, V. </author> <title> Java is not type-safe, </title> <month> Aug. </month> <year> 1997. </year> <note> URL: www.research.att.com/~vj/bug.html. </note>
Reference-contexts: This type-checking must be performed in the correct context to ensure that dynamic linking is type-safe. Java's dynamic class loading is broken because it checks types in a type environment that may differ from the environment where the class is used <ref> [26] </ref>. 4 The Structure and Interpretation of Units In this section we develop a semantic and type-theoretic account of the unit language design in three stages.
Reference: [27] <author> SunSoft. </author> <title> SunOS 5.5 Linker and Libraries Manual, </title> <year> 1996. </year>
Reference-contexts: Traditional languages like C have relied on the filesystem as the language of modules. Programs (makefiles) manipulate .o files to select the modules that are linked into a program, and module files are partially linked to create new .o or library files. Modern linking systems such as ELF <ref> [27] </ref> support dynamic linking. However, even the most advanced linking systems rely on a global namespace of function names and module (i.e., file) names. As a result, modules can be linked and invoked only once in a program.
Reference: [28] <author> Tarditi, D., Morrisett, G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM Conference on Programming Language Design and Implementation (1996), </booktitle> <pages> pp. 181-192. </pages>
Reference-contexts: When compiling a unit, imported types are obviously not yet determined and thus have unknown representations. Hence, expressions involving imported types must be compiled like polymorphic functions in ML <ref> [19, 28] </ref>. Otherwise, the restrictions implied by a unit's interface allow inter-procedural optimizations within the unit (such as inlining, specialization, and dead-code elimination).
Reference: [29] <author> Tofte, M. </author> <title> Principal signatures for higher-order program modules. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages (1992), </booktitle> <pages> pp. 189-199. </pages>
Reference-contexts: The Scheme and ML communities have produced a large body of work exploring variations on the standard module system, especially variations for higher-order modules <ref> [2, 4, 12, 16, 18, 20, 21, 23, 29] </ref>. Duggan and Sourelis [5] have investigated "mixin modules" for specifying recursive and extensible definitions across modules; their work and ours have no overlap. Cardelli [3] anticipated the unit language's emphasis on module linking as well as module definition.
Reference: [30] <author> Wirth, N. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: However, even the most advanced linking systems rely on a global namespace of function names and module (i.e., file) names. As a result, modules can be linked and invoked only once in a program. Many modern languages (e.g., Ada 95 [1], Modula-2 <ref> [30] </ref>, Modula-3 [11], Haskell [15], and Java [10]) use packages. A package system delineates the boundaries of each module and forces the specification of static dependencies between modules. Since module linking and invocation are clearly separated, packages allow mutually recursive function and type definitions across package boundaries.
Reference: [31] <author> Wright, A., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 160, </type> <institution> Rice University, </institution> <year> 1991. </year> <journal> Information and Computation, </journal> <volume> volume 115(1), </volume> <year> 1994, </year> <pages> pp. 38-94. </pages>
Reference-contexts: For all three sections, we only consider those parts of the core language that are immediately relevant to units. The rigorous description of the unit language, including its type structures and semantics, relies on well-known type checking and rewriting techniques for Scheme and ML <ref> [6, 13, 31] </ref>. In the rewriting model of evaluation, the set of program expressions is partitioned into a set of values and a set of non-values. <p> that the invoke and compound reductions propagate type definitions as well as val definitions. 4.2.3 Type Soundness If we were to combine Unit c with the monomorphic subset of ML, we could prove a Milner-style type soundness theorem using a subject reduction argument along the lines of Wright and Felleisen <ref> [31] </ref>. 4.2.4 Unit c Implementation Closed units in Unit c can be compiled separately in the same way as closed functors in ML. When compiling a unit, imported types are obviously not yet determined and thus have unknown representations.
References-found: 31

