URL: http://theory.lcs.mit.edu/~danl/3qpcp.ps
Refering-URL: http://theory.lcs.mit.edu/~danl/
Root-URL: 
Email: fvenkat,danl,madhu,lucag@lcs.mit.edu.  
Title: A tight characterization of NP with 3 query PCPs  
Author: Venkatesan Guruswami Daniel Lewin Madhu Sudan Luca Trevisan 
Note: Research supported by the Italian CNR.  
Address: 545 Technology Square, Cambridge, MA 02139, USA.  
Affiliation: Laboratory for Computer Science, MIT,  
Date: May 4, 1998  
Abstract: It is known that there exists a PCP characterization of NP where the verifier makes 3 queries and has a one-sided error that is bounded away from 1; and also that 2 queries do not suffice for such a characterization. Thus PCPs with 3 queries possess non-trivial verification power and motivate the task of determining the lowest error that can be achieved with a 3-query PCP. Recently, H-astad [10] has shown a tight characterization of NP by constructing a 3-query PCP verifier with "error" arbitrarily close to 1=2. Unfortunately, this verifier makes two-sided error and H-astad makes essential use of this feature. One-sided error, on the other hand, is a natural notion to associate with a proof system, since it has the desirable property that every rejected proof has a short counterexample. The question of determining the smallest error for which there exists a 3-query PCP verifier making one-sided error and accepting an NP-complete language, however, remained open. We resolve this question by showing that NP has a 3-query PCP with a one-sided error that is arbitrarily close to 1=2. This characterization is tight, i.e., the error cannot be lower. This result is in seeming contradiction with the results of Trevisan [14] and Zwick [16] who show that in order to recognize an NP-complete language, the error probability of a PCP verifier making 3 non-adaptive queries and having one-sided error must be at least 5=8. We get around this bottleneck by designing an adaptive 3-query PCP for NP. Our result yields the first tight analysis of an adaptive PCP; and reveals a previously unsuspected separation between the powers of adaptive and non-adaptive PCPs. Our design and analysis of adaptive PCPs can be extended to higher number of queries as well and we give an example of such a proof system with 5 queries. Our adaptive verifiers yield proof systems whose error probabilities match those of previous constructions, while also achieving one-sidedness in the error. This raises new questions about the power of adaptive PCPs, which deserve further study. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and hardness of approximation problems. </title> <booktitle> In Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> Highlights of the other PCP constructions are presented in Section 5 and certain containments of PCP classes in P are given in Section 6. 2 Background Our PCP constructions rely on the proof-composition methodology introduced by Arora and Safra [2] and then refined in <ref> [1, 6, 7, 5, 10] </ref>. In this methodology one uses a verifier by Raz [12] and then "composes" it with an "inner verifier": the result of the composition is a PCP construction.
Reference: [2] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs: A new characterization of NP. </title> <journal> Journal of the ACM, </journal> <volume> 45(1) </volume> <pages> 70-122, </pages> <year> 1998. </year>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> Section 4 describes the verifier of Theorem 1.2, Part (2). Highlights of the other PCP constructions are presented in Section 5 and certain containments of PCP classes in P are given in Section 6. 2 Background Our PCP constructions rely on the proof-composition methodology introduced by Arora and Safra <ref> [2] </ref> and then refined in [1, 6, 7, 5, 10]. In this methodology one uses a verifier by Raz [12] and then "composes" it with an "inner verifier": the result of the composition is a PCP construction.
Reference: [3] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polylogarithmic time. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> We perform a tight analysis of this verifier and obtain a somewhat surprising result: Theorem 1.1 For every " &gt; 0, NP = PCP 1; 1 2 +" <ref> [log; 3] </ref>. The theorem is tight since, as pointed out earlier, any 3-query verifier for NP must make an error with probability at least 1 2 . <p> We summarize this with the following open questions: (1) What is the smallest s for which N P = naPCP 1;s <ref> [log; 3] </ref>? (2) Is it true that for every q, there exist s 0 &lt; s, such that PCP 1;s [log; q] P while NP = PCP 1;s 0 [log; q + 1]? (3) If NP = PCP c;s [log; q], then is it the case that for every " &gt; <p> Fact 1 ([13]) If there exists a polynomial time factor r approximation algorithm for MAX kCSP, then PCP c;s [ log; k] P for any s=c &lt; r. Existing approximation algorithms in [13, 14, 16] for various MAX kCSP problems therefore imply that PCP c;s <ref> [ log; 3] </ref> P for any s=c &lt; 1=2, naPCP 1;s [ log; 3] P for any s &lt; 5=8, PCP c;s [ log; k] P for any s=c &lt; 2 1k , and lastly naPCP 1;s [ log; k] P for any s &lt; (k + 1)=2 k . <p> Existing approximation algorithms in [13, 14, 16] for various MAX kCSP problems therefore imply that PCP c;s <ref> [ log; 3] </ref> P for any s=c &lt; 1=2, naPCP 1;s [ log; 3] P for any s &lt; 5=8, PCP c;s [ log; k] P for any s=c &lt; 2 1k , and lastly naPCP 1;s [ log; k] P for any s &lt; (k + 1)=2 k .
Reference: [4] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover in teractive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 3-40, </pages> <year> 1991. </year> <note> Preliminary version in Proc. of FOCS'90. </note>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> These are described below, where the notation naPCP below stands for non-adaptive PCP. Theorem 1.2 For every " &gt; 0, the following hold: (1) (4 non-adaptive queries) NP = naPCP 1; 1 2 +" <ref> [log; 4] </ref>. (2) (5 adaptive queries) NP = PCP 1; 1 4 +" [log; 5]. (3) (5 non-adaptive queries) NP = naPCP 1; 7 16 +" [log; 5]. (4) (6 non-adaptive queries) NP = naPCP 1; 1 4 +" [log; 6]. <p> Part (3) requires some modification of the verifier of Part (2). Finally, using the semidefinite programming methodology of Karloff and Zwick [11, 16], we also prove the following containment result for 4-query PCP. Theorem 1.3 For any c; s such that s=c &lt; 0:33, PCP c;s <ref> [log; 4] </ref> P. <p> Theorem 6.1 There exists a polynomial time algorithm for approximating MAX 4CSP within a factor of 0.33 of the optimum. Corollary 6.1 For any s=c &lt; 0:33, we have PCP c;s <ref> [ log; 4] </ref> P. By the above corollary adaptive PCPs making 4 queries cannot achieve a soundness of 0.33 if they have near-perfect completeness; however, a 5-query non-adaptive PCP construction with 10 near-perfect completeness and soundness 0.25 is known [15].
Reference: [5] <author> M. Bellare, O. Goldreich, and M. Sudan. </author> <title> Free bits, PCP's and non-approximability towards tight results (5th version). Technical Report TR95-24, </title> <booktitle> Electronic Colloquium on Computational Complexity, </booktitle> <year> 1997. </year> <note> Preliminary version in Proc. of FOCS'95. </note>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> Most previous constructions do not use adaptivity. However, to get a tight answer to the 3-query question, it seems necessary to build an adaptive verifier; and the only construction of an adaptive PCP verifier in the literature is a construction of Bellare et al. <ref> [5] </ref>. Thus this entire area seems relatively unexplored. We build a new adaptive 3-query verifier for NP. This verifier is based on a combination of 1 We will use this term loosely for the present and formalize it shortly. 1 the adaptive verifier of Bellare et al. [5] and the non-adaptive <p> Bellare et al. <ref> [5] </ref>. Thus this entire area seems relatively unexplored. We build a new adaptive 3-query verifier for NP. This verifier is based on a combination of 1 We will use this term loosely for the present and formalize it shortly. 1 the adaptive verifier of Bellare et al. [5] and the non-adaptive verifier with perfect completeness of H-astad [10]. We perform a tight analysis of this verifier and obtain a somewhat surprising result: Theorem 1.1 For every " &gt; 0, NP = PCP 1; 1 2 +" [log; 3]. <p> These are described below, where the notation naPCP below stands for non-adaptive PCP. Theorem 1.2 For every " &gt; 0, the following hold: (1) (4 non-adaptive queries) NP = naPCP 1; 1 2 +" [log; 4]. (2) (5 adaptive queries) NP = PCP 1; 1 4 +" <ref> [log; 5] </ref>. (3) (5 non-adaptive queries) NP = naPCP 1; 7 16 +" [log; 5]. (4) (6 non-adaptive queries) NP = naPCP 1; 1 4 +" [log; 6]. Part (2) of result is where the main technical work is done. <p> Theorem 1.2 For every " &gt; 0, the following hold: (1) (4 non-adaptive queries) NP = naPCP 1; 1 2 +" [log; 4]. (2) (5 adaptive queries) NP = PCP 1; 1 4 +" <ref> [log; 5] </ref>. (3) (5 non-adaptive queries) NP = naPCP 1; 7 16 +" [log; 5]. (4) (6 non-adaptive queries) NP = naPCP 1; 1 4 +" [log; 6]. Part (2) of result is where the main technical work is done. <p> posed to us by Oded Goldreich. 2 For adaptive PCP, 5 queries are stronger than 4. (from Theorem 1.2 (2) and Theorem 1.3.) 5 non-adaptive queries are stronger than 4 adaptive queries. (from Theorem 1.3 with c = 1 " and the fact proved in [15] that NP PCP 1";1=4 <ref> [ log; 5] </ref> for any " &gt; 0.) These results further highlight some aspects in which our understanding of PCPs are still not tight. <p> Highlights of the other PCP constructions are presented in Section 5 and certain containments of PCP classes in P are given in Section 6. 2 Background Our PCP constructions rely on the proof-composition methodology introduced by Arora and Safra [2] and then refined in <ref> [1, 6, 7, 5, 10] </ref>. In this methodology one uses a verifier by Raz [12] and then "composes" it with an "inner verifier": the result of the composition is a PCP construction. <p> As an error correcting code we use the long code of Bellare et al. <ref> [5] </ref>. <p> Codewords of the long code are 1-folded; in the rest of the paper we will restrict to 1-folded functions, this can be done without loss of generality using an access mechanism from <ref> [5] </ref>. A string B indexed by functions g 2 F m is S-consistent, where S f0; 1g m , if g jS h jS implies B (g) = B (h). Notice that the long code of an element of S is S-consistent. <p> The above definition is based on the standard definition of an inner verifier (e.g. from <ref> [5] </ref>) but it incorporates the possibility that the decoding procedure be randomized 3 and also allows the soundness condition to be averaged over the choices of . <p> A (f ) = 1 implies B (g) = B (g (f ffi ^ h)) and A (f ) = 1 implies B (g) = B (g (f ffi ^ h)) : (1) 3 Bellare et al. <ref> [5] </ref> used a deterministic procedure that returned a list of candidates, and this was conceptually similar to the randomized decoding idea that first appeared in [10]. <p> h)) if A (f ) = 1 then accept iff B (g) = B (g (f ffi ^ h)) With probability 1 p do accept iff A (f ) = B (g)B (g (f ffi )) Checking this condition is essentially the Monomial Basis Check (MBC) of Bellare et al. <ref> [5] </ref>, with the minor twist of looking at both A and B (Bellare et al. [5] would instead look only at B, and then test separately whether A is consistent with B). As a first proposal, we consider the test of domain. <p> (f ffi ^ h)) With probability 1 p do accept iff A (f ) = B (g)B (g (f ffi )) Checking this condition is essentially the Monomial Basis Check (MBC) of Bellare et al. <ref> [5] </ref>, with the minor twist of looking at both A and B (Bellare et al. [5] would instead look only at B, and then test separately whether A is consistent with B). As a first proposal, we consider the test of domain. It is possible to show that the MBC inner verifier is (1; 3=4; 3)-good, i.e., the soundness is 3=4. <p> Combining the two verification procedures, we define the BGS p verifier (see Figure 2) that is very similar to one used in <ref> [5] </ref>. Omitted calculations (this time they are quite hard) show that it is best to set p = 1=3 and that BGS 1=3 is a (1; 2=3; 3)-good verifier, i.e. the soundness is 2=3.
Reference: [6] <author> M Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs and applications to approximation. </title> <booktitle> In Proceedings of the 25th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year> <note> See also the errata sheet in Proc of STOC'94. </note>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> (1) (4 non-adaptive queries) NP = naPCP 1; 1 2 +" [log; 4]. (2) (5 adaptive queries) NP = PCP 1; 1 4 +" [log; 5]. (3) (5 non-adaptive queries) NP = naPCP 1; 7 16 +" [log; 5]. (4) (6 non-adaptive queries) NP = naPCP 1; 1 4 +" <ref> [log; 6] </ref>. Part (2) of result is where the main technical work is done. <p> Highlights of the other PCP constructions are presented in Section 5 and certain containments of PCP classes in P are given in Section 6. 2 Background Our PCP constructions rely on the proof-composition methodology introduced by Arora and Safra [2] and then refined in <ref> [1, 6, 7, 5, 10] </ref>. In this methodology one uses a verifier by Raz [12] and then "composes" it with an "inner verifier": the result of the composition is a PCP construction.
Reference: [7] <author> M. Bellare and M. Sudan. </author> <title> Improved non-approximability results. </title> <booktitle> In Proceedings of the 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 184-193, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . <p> Highlights of the other PCP constructions are presented in Section 5 and certain containments of PCP classes in P are given in Section 6. 2 Background Our PCP constructions rely on the proof-composition methodology introduced by Arora and Safra [2] and then refined in <ref> [1, 6, 7, 5, 10] </ref>. In this methodology one uses a verifier by Raz [12] and then "composes" it with an "inner verifier": the result of the composition is a PCP construction.
Reference: [8] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Interactive proofs and the hardness of approximating cliques. </title> <journal> Journal of the ACM, </journal> <volume> 43(2) </volume> <pages> 268-292, </pages> <year> 1996. </year> <note> Preliminary version in Proc. of FOCS91. </note>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 .
Reference: [9] <author> U. Feige and J. Kilian. </author> <title> Two prover protocols low error at affordable rates. </title> <booktitle> In Proceedings of the 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 172-183, </pages> <year> 1994. </year> <month> 11 </month>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments <ref> [4, 3, 8, 2, 1, 6, 9, 7, 5] </ref> recently culminated in the striking results of H-astad [10] showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 .
Reference: [10] <author> J. H-astad. </author> <title> Some optimal inapproximability results. Technical Report TR97-37, </title> <booktitle> Electronic Colloquium on Computational Complexity, </booktitle> <year> 1997. </year> <note> Preliminary version in Proc. of STOC'97. </note>
Reference-contexts: 1 Introduction The construction of efficient probabilistically checkable proofs (PCPs) has been a subject of active research in past few years. A sequence of surprising developments [4, 3, 8, 2, 1, 6, 9, 7, 5] recently culminated in the striking results of H-astad <ref> [10] </ref> showing that every language in NP has a PCP verifier querying 3 bits and having error probability 1 arbitrarily close to 1 2 . This characterization of NP is tight in the sense that no verifier querying 3 bits could achieve an error strictly smaller than 1 2 . <p> We build a new adaptive 3-query verifier for NP. This verifier is based on a combination of 1 We will use this term loosely for the present and formalize it shortly. 1 the adaptive verifier of Bellare et al. [5] and the non-adaptive verifier with perfect completeness of H-astad <ref> [10] </ref>. We perform a tight analysis of this verifier and obtain a somewhat surprising result: Theorem 1.1 For every " &gt; 0, NP = PCP 1; 1 2 +" [log; 3]. <p> Highlights of the other PCP constructions are presented in Section 5 and certain containments of PCP classes in P are given in Section 6. 2 Background Our PCP constructions rely on the proof-composition methodology introduced by Arora and Safra [2] and then refined in <ref> [1, 6, 7, 5, 10] </ref>. In this methodology one uses a verifier by Raz [12] and then "composes" it with an "inner verifier": the result of the composition is a PCP construction. <p> A string B indexed by functions g 2 F m is S-consistent, where S f0; 1g m , if g jS h jS implies B (g) = B (h). Notice that the long code of an element of S is S-consistent. An access mechanism described in <ref> [10] </ref> allows us to restrict without loss of generality to S-consistent B. <p> The latter is a technicality that is necessary to use some new results of H-astad <ref> [10] </ref>, and it makes the definition less elegant as several details of the Raz verifier have to be taken into account explicitly (for example the fact that is a projection, rather than an arbitrary function mapping f1; 1g m into f1; 1g n , and also that is selected uniformly). <p> ffi ^ h)) and A (f ) = 1 implies B (g) = B (g (f ffi ^ h)) : (1) 3 Bellare et al. [5] used a deterministic procedure that returned a list of candidates, and this was conceptually similar to the randomized decoding idea that first appeared in <ref> [10] </ref>. <p> As a first proposal, we consider the test of domain. It is possible to show that the MBC inner verifier is (1; 3=4; 3)-good, i.e., the soundness is 3=4. We omit the (not too hard) analysis, that is based on the techniques of <ref> [10] </ref>. The following argument shows that the analysis is tight: if A and B are inconsistent long codes then the MBC verifier accepts with probability 3/4, and our decoding procedure will have success probability zero when working with two inconsistent Long codes. <p> The expressions arising in (2) are extremely hard to bound, but we are fortunate that their analysis already appeared in the literature! Indeed they are the same expressions arising in a verifier that H-astad <ref> [10] </ref> constructs in order to prove a (tight) non-approximability result for satisfiable instances of MAX 3SAT. <p> 1 it accepts iff B (g) = B (g (f ffi ^ h)); if A (f ) = 1 it accepts no matter what is the value of B (g) and B (g (f ffi ^ h)). (see steps (2) and (3) in the definition of the 3S " verifier <ref> [10, Page 23] </ref> and the comments in [10, Remark 4.12].) H-astad proves that the expectation of B (g)B (g (f ffi ^ h)) can be upper bounded by some arbitrarily small constant, for any B, and he also shows that whenever the expectation of A (f )B (g)B (g (f ffi <p> B (g (f ffi ^ h)); if A (f ) = 1 it accepts no matter what is the value of B (g) and B (g (f ffi ^ h)). (see steps (2) and (3) in the definition of the 3S " verifier [10, Page 23] and the comments in <ref> [10, Remark 4.12] </ref>.) H-astad proves that the expectation of B (g)B (g (f ffi ^ h)) can be upper bounded by some arbitrarily small constant, for any B, and he also shows that whenever the expectation of A (f )B (g)B (g (f ffi 5 The sample space of X A;B;;p <p> There is a counter-example showing that the expressions of (2) cannot be bounded without going through such additional complications. For our purposes, it suffices to pick p according to the same distribution as in <ref> [10, Test 3S, Page 29] </ref> and then apply the results proved therein. Our final verifier IV3 ffi , described in Figure 3, is the same as B-MBC p except for the choice of p. <p> The strange distribution of p is the particular one for which H-astad shows how to bound the expressions of (2). The constant c used in the definition of " 1 ; : : : ; " t is an absolute constant which is left unspecified in <ref> [10] </ref>. Using results from [10], specifically Lemmas 4.6 and 4.10, we can prove that the soundness of IV3 ffi can be made arbitrarily close to 1/2 by choosing ffi small. Theorem 3.1 For any ffi &gt; 0, IV3 ffi is a (1; 1=2 + 2ffi; 3)-good inner verifier. <p> The constant c used in the definition of " 1 ; : : : ; " t is an absolute constant which is left unspecified in <ref> [10] </ref>. Using results from [10], specifically Lemmas 4.6 and 4.10, we can prove that the soundness of IV3 ffi can be made arbitrarily close to 1/2 by choosing ffi small. Theorem 3.1 For any ffi &gt; 0, IV3 ffi is a (1; 1=2 + 2ffi; 3)-good inner verifier.
Reference: [11] <author> H. Karloff and U. </author> <title> Zwick. </title> <booktitle> A (7=8 ")-approximation algorithm for MAX 3SAT? In Proceedings of the 38th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1997. </year>
Reference-contexts: It is interesting to observe that that for several choices of q, the best known non-adaptive PCP verifier is obtained by starting from an adaptive one. Part (3) requires some modification of the verifier of Part (2). Finally, using the semidefinite programming methodology of Karloff and Zwick <ref> [11, 16] </ref>, we also prove the following containment result for 4-query PCP. Theorem 1.3 For any c; s such that s=c &lt; 0:33, PCP c;s [log; 4] P. <p> Our first result relies on a semidefinite programming relaxation of MAX 4CSP using a methodology of Karloff and Zwick <ref> [11, 16] </ref> and a numerical analysis of the approximation ratio guaranteed by rounding the SDP solution using a random hyperplane with certain probability and using a random assignment to the variables with the remaining probability. <p> Theorem 6.3 We have, for any " &gt; 0, PCP 1";s [ log; k] P, where s = 3 2 k +2 O ( k" 1=3 Acknowledgments We would like to thank Uri Zwick for having provided us with the code he used in <ref> [11, 16] </ref>.
Reference: [12] <author> R. Raz. </author> <title> A parallel repetition theorem. </title> <booktitle> In Proceedings of the 27th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 447-456, </pages> <year> 1995. </year>
Reference-contexts: In this methodology one uses a verifier by Raz <ref> [12] </ref> and then "composes" it with an "inner verifier": the result of the composition is a PCP construction. This methodology is very useful since it reduces the task of constructing a PCP protocol to the simpler task of finding inner verifiers.
Reference: [13] <author> L. Trevisan. </author> <title> Positive linear programming, parallel approximation, </title> <booktitle> and PCP's. In Proceedings of the 4th European Symposium on Algorithms, </booktitle> <pages> pages 62-75. </pages> <publisher> LNCS 1136, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Prior to this result there was no evidence indicating that such a separation might exist. In fact, on the contrary, Trevisan <ref> [13] </ref> points out that adaptive and nonadaptive PCPs actually have the same power for PCPs with two-sided error. Of technical interest is that we extend (in retrospect, quite easily) the Fourier analysis method of H-astad to the case of adaptive PCPs. <p> Fact 1 ([13]) If there exists a polynomial time factor r approximation algorithm for MAX kCSP, then PCP c;s [ log; k] P for any s=c &lt; r. Existing approximation algorithms in <ref> [13, 14, 16] </ref> for various MAX kCSP problems therefore imply that PCP c;s [ log; 3] P for any s=c &lt; 1=2, naPCP 1;s [ log; 3] P for any s &lt; 5=8, PCP c;s [ log; k] P for any s=c &lt; 2 1k , and lastly naPCP 1;s [
Reference: [14] <author> L. Trevisan. </author> <title> Approximating satisfiable satisfiability problems. </title> <booktitle> In Proceedings of the 5th Euro pean Symposium on Algorithms, </booktitle> <pages> pages 472-485. </pages> <publisher> LNCS 1284, Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Yet, even H-astad could only achieve an error probability arbitrarily close to 3/4 with a PCP verifier that queries three bits and makes one-sided error. (Presumably he did not think about this long enough.) Trevisan <ref> [14] </ref> and Zwick [16] show a fundamental barrier to this quest: They show that any verifier making 3 non-adaptive queries to the proof oracle, and achieving a one-sided error better than 5=8 can only recognize languages in P. This brings up another subtlety in the definition of PCP. <p> Fact 1 ([13]) If there exists a polynomial time factor r approximation algorithm for MAX kCSP, then PCP c;s [ log; k] P for any s=c &lt; r. Existing approximation algorithms in <ref> [13, 14, 16] </ref> for various MAX kCSP problems therefore imply that PCP c;s [ log; 3] P for any s=c &lt; 1=2, naPCP 1;s [ log; 3] P for any s &lt; 5=8, PCP c;s [ log; k] P for any s=c &lt; 2 1k , and lastly naPCP 1;s [
Reference: [15] <author> L. Trevisan. </author> <title> Recycling queries in PCPs and in linearity tests. </title> <booktitle> In Proceedings of the 30th ACM Symposium on Theory of Computing, </booktitle> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: [16].) 2 This question was posed to us by Oded Goldreich. 2 For adaptive PCP, 5 queries are stronger than 4. (from Theorem 1.2 (2) and Theorem 1.3.) 5 non-adaptive queries are stronger than 4 adaptive queries. (from Theorem 1.3 with c = 1 " and the fact proved in <ref> [15] </ref> that NP PCP 1";1=4 [ log; 5] for any " &gt; 0.) These results further highlight some aspects in which our understanding of PCPs are still not tight. <p> A definition of inner verifier with respect to a randomized decoding procedure is explicit in <ref> [15] </ref>. 5 Inner Verifier BGS p (A; B; ) Choose uniformly at random f 2 F n , g; h 2 F m With probability p do if A (f ) = 1 then accept iff B (g) = B (g (f ffi ^ h)) if A (f ) = 1 <p> As one might expect, this method yields 8 soundness of (1=2) 2 = 1=4 while making 5 (adaptive) queries (this construction follows the same idea of recycling one bit as in <ref> [15] </ref>). We now give a different test that gives no improvement over this test for the case of 5 adaptive queries, but which, however, has other applications (which shall be sketched in section 5) that the originally suggested one does not. <p> By the above corollary adaptive PCPs making 4 queries cannot achieve a soundness of 0.33 if they have near-perfect completeness; however, a 5-query non-adaptive PCP construction with 10 near-perfect completeness and soundness 0.25 is known <ref> [15] </ref>. Thus, we exhibit the first instance where adaptive PCPs are strictly less powerful than non-adaptive PCPs that just make one extra query (unless P 6= NP).
Reference: [16] <author> U. Zwick. </author> <title> Approximation algorithms for constraint satisfaction problems involving at most three variables per constraint. </title> <booktitle> In Proceedings of the 9th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1998. </year>
Reference-contexts: Yet, even H-astad could only achieve an error probability arbitrarily close to 3/4 with a PCP verifier that queries three bits and makes one-sided error. (Presumably he did not think about this long enough.) Trevisan [14] and Zwick <ref> [16] </ref> show a fundamental barrier to this quest: They show that any verifier making 3 non-adaptive queries to the proof oracle, and achieving a one-sided error better than 5=8 can only recognize languages in P. This brings up another subtlety in the definition of PCP. <p> It is interesting to observe that that for several choices of q, the best known non-adaptive PCP verifier is obtained by starting from an adaptive one. Part (3) requires some modification of the verifier of Part (2). Finally, using the semidefinite programming methodology of Karloff and Zwick <ref> [11, 16] </ref>, we also prove the following containment result for 4-query PCP. Theorem 1.3 For any c; s such that s=c &lt; 0:33, PCP c;s [log; 4] P. <p> Theorem 1.1, 1.2 and 1.3 together yield some partial answer to the question posed earlier, since they exhibit some non-trivial values of q for which q + 1 queries give more power than q: For non-adaptive PCP, 4 queries are stronger than 3. (from Theorem 1.2 (1) and <ref> [16] </ref>.) 2 This question was posed to us by Oded Goldreich. 2 For adaptive PCP, 5 queries are stronger than 4. (from Theorem 1.2 (2) and Theorem 1.3.) 5 non-adaptive queries are stronger than 4 adaptive queries. (from Theorem 1.3 with c = 1 " and the fact proved in [15] <p> Fact 1 ([13]) If there exists a polynomial time factor r approximation algorithm for MAX kCSP, then PCP c;s [ log; k] P for any s=c &lt; r. Existing approximation algorithms in <ref> [13, 14, 16] </ref> for various MAX kCSP problems therefore imply that PCP c;s [ log; 3] P for any s=c &lt; 1=2, naPCP 1;s [ log; 3] P for any s &lt; 5=8, PCP c;s [ log; k] P for any s=c &lt; 2 1k , and lastly naPCP 1;s [ <p> Our first result relies on a semidefinite programming relaxation of MAX 4CSP using a methodology of Karloff and Zwick <ref> [11, 16] </ref> and a numerical analysis of the approximation ratio guaranteed by rounding the SDP solution using a random hyperplane with certain probability and using a random assignment to the variables with the remaining probability. <p> Theorem 6.3 We have, for any " &gt; 0, PCP 1";s [ log; k] P, where s = 3 2 k +2 O ( k" 1=3 Acknowledgments We would like to thank Uri Zwick for having provided us with the code he used in <ref> [11, 16] </ref>.
References-found: 16

