URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-92-7.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Title: Functional Synthesis Using Area and Delay Optimization  
Author: Elke A. Rundensteiner and Daniel D. Gajski 
Address: Irvine, CA 92717  
Affiliation: Department of Information and Computer Science University of California,  
Abstract: It is generally overlooked that designers use functional models more frequently than behavioral or gate-level models. In functional modeling, the functionality of one or more register-transfer level (RTL) components are described as separate concurrent blocks using a hardware description language such as VHDL. In this paper, we present two algorithms that synthesize a netlist of RTL components from a functional description while minimizing hardware costs and delay. Experimental results show that the proposed algorithms produce designs that are comparable to those produced by human designers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. D. Dutt, and J. R. Kipps, </author> <title> Bridging High-Level Synthesis to RTL Technology Libraries, </title> <booktitle> Proc. 28th Design Automation Conf., </booktitle> <pages> pp. 526-529, </pages> <year> 1991. </year>
Reference-contexts: Functional synthesis therefore addresses the technology mapping problem at the RTL level. Previous work on RTL technology mapping has focussed on translating a generic RTL structure into a technology-specific one <ref> [3, 1] </ref>. These approaches work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions.
Reference: [2] <author> N. D. Dutt, </author> <title> GENUS: A Generic Component Library for High Level Synthesis, </title> <type> Tech. Rep. 89-09, </type> <institution> Univ. of Cal., Irvine, </institution> <year> 1989. </year>
Reference-contexts: The experiments presented below are based on the following examples. Example 1 is an Adder/Subtractor from <ref> [2] </ref>; examples 2 and 3 are variations of an ALU from the Mano book; example 4 is a functionally reduced version of the TI 74181 ALU; example 5 is a divide-by-3328 counter from Rockwell; example 6 describes a combination of a counting and a logic unit with partially permuted inputs; example <p> 15 * 0% Concur2 452 10 * 452 10 * 0% In this second experiment, we explore FSA's ability to perform technology adaptation by replacing the component-specific information by different libraries: (a) the TTL library, (b) the Mano library, and (c) the Generic Component Library GENUS developed at UC Irvine <ref> [2] </ref>. The results us ing FSA with the B&B Component Mapper and ff=1 are given in Table 2. Table 2 shows that FSA produces better designs using the TTL library than when using the Mano or the Genus library.
Reference: [3] <author> G. W. Leive and D. E. Thomas, </author> <title> A Technology Relative Logic Synthesis and Module Selection System, </title> <booktitle> Proc. 18th Design Automation Conf., </booktitle> <pages> pp. 479-485, </pages> <year> 1981. </year>
Reference-contexts: Functional synthesis therefore addresses the technology mapping problem at the RTL level. Previous work on RTL technology mapping has focussed on translating a generic RTL structure into a technology-specific one <ref> [3, 1] </ref>. These approaches work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions.
Reference: [4] <author> G. P. Paulin and J. P. Knight, </author> <title> Scheduling and Binding Algorithms for High-Level Synthesis, </title> <booktitle> Proc. 26th Design Automation Conf., </booktitle> <pages> pp. 1-6, </pages> <year> 1989. </year>
Reference-contexts: We propose to automate this labor intensive and costly process of redesign by automatically mapping functional descriptions into components from a given RTL library. In contrast, behavioral synthesis maps a behavioral description of the desired system to a RTL structure of generic RTL components <ref> [4, 8] </ref>. Thus, functional synthesis can work in synergism with behavioral synthesis by mapping functional descriptions of RTL designs produced by the latter onto actual hardware. Functional synthesis therefore addresses the technology mapping problem at the RTL level. <p> In this paper, we present two algorithms that solve the second problem by formulating it as a clique partitioning problem - similar to work done for solving the allocation problem in behavioral synthesis <ref> [8, 4] </ref>. Our algorithms handle nested conditional branches and do not assume a preallocation of functional units and unit binding as done in [4]. Our cost functions incorporate costs for both interconnection and function select logic. <p> Our algorithms handle nested conditional branches and do not assume a preallocation of functional units and unit binding as done in <ref> [4] </ref>. Our cost functions incorporate costs for both interconnection and function select logic. Lastly, by combining the branch-and-bound methodology with clique partitioning, we succeed in pruning the search space without losing the guarantee of an optimal solution. We outline our component mapping approach in Section 2.
Reference: [5] <author> E. A. Rundensteiner and D. D. Gajski, </author> <title> A Design Representation Model for High-Level Synthesis, </title> <type> Tech. Rep. 90-27, </type> <institution> Univ. of Cal., Irvine, </institution> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: V is composed of three disjoint sets V = N [ R [ D, with N the set of operators, R the set of storage elements, and D the set of decision nodes that model data selection <ref> [5] </ref>. Two operator nodes n1 and n2 in G are defined to be mergeable with respect to a given unit table U (component library) if and only if there is a unit u 2 U which implements the functions of both n1 and n2.
Reference: [6] <author> E. A. Rundensteiner, D. D. Gajski, and L. Bic, </author> <title> Component Synthesis: Technology Mapping from Register Transfer Descriptions, </title> <booktitle> Proc. Int. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 208-211, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: In addition, component mapping exploits the mutual exclusiveness of operators for unit sharing in order to minimize hardware area and delay. Our Functional Synthesis Algorithms tool (FSA) consists of two modules: the functionality recognizer and the component mapper [7]. In <ref> [6] </ref>, we present an algorithm for functionality recognition which merges expression subtrees into library-specific nodes whenever components are capable of executing those expressions as one function. <p> They are defined to be mutually exclusive to one other if the conditions which selects each can never be true at the same time <ref> [6] </ref>. Finally, they are said to be compatible with respect to U, if they are mutually exclusive and mergeable. FSA generates a compatibility graph CG = (N,E) from G with N the set of operator nodes of G and E a set of undirected edges, called compatibility edges. <p> Do not map n 1 and n 2 to same unit, i.e., do not use edge e in the clique cover: - CG ) CG by deleting edge e from CG, - G ) G by setting G 0 The rules for compatibility and flow graph transformations are given in <ref> [6] </ref>, while below we give an example of case 1. Figures 3 (a) and 3 (b) describes how two operators n 1 and n 2 are mapped to the same component by merging them into one multi-functional operator node n k in G.
Reference: [7] <author> E. A. Rundensteiner, D. D. Gajski, and L. Bic, </author> <title> Component Synthesis from Functional Descriptions, </title> <type> Tech. Rep. 90-24, </type> <institution> Univ. of Cal., Irvine, </institution> <month> Dec. </month> <year> 1990, </year> <month> (revised Aug. </month> <year> 1991). </year>
Reference-contexts: In addition, component mapping exploits the mutual exclusiveness of operators for unit sharing in order to minimize hardware area and delay. Our Functional Synthesis Algorithms tool (FSA) consists of two modules: the functionality recognizer and the component mapper <ref> [7] </ref>. In [6], we present an algorithm for functionality recognition which merges expression subtrees into library-specific nodes whenever components are capable of executing those expressions as one function. <p> If FSA finds one complete solution to the left of the cutoff line then the partial solution P D and all solutions derivable from P D can be discarded. Due to limited space, the correctness proofs of the bounding function can be found in <ref> [7] </ref>. delay area high low low high PD (Ax,Dx) Ax alpha*Ax Dx beta*Dx space of acceptable solutions space of discarded solutions bound on partial design Dx PD'(alpha*Ax,beta*Dx) cut-off function is alpha*Ax + beta*Dx= alpha*X + beta*Y 5 Component mapping algorithms The FSA tool first generates a compatibility graph CG for the <p> Due to space limitations, the reader is referred to <ref> [7] </ref> for the definition of the area benefit () and delay benefit () functions. 5.2 Heuristic component mapper Algorithm 5.1. : Heuristic Component Mapper Input: flow graph G, compatibility graph CG, unit table U, ff, fi.
Reference: [8] <author> C. Tseng and D. P. Siewiorek, </author> <title> Automated Synthesis of Data Paths in Digital Systems, </title> <journal> IEEE Trans. on Computer-Aided Design, CAD-5, </journal> <volume> 3, </volume> <pages> pp. 379-395, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: We propose to automate this labor intensive and costly process of redesign by automatically mapping functional descriptions into components from a given RTL library. In contrast, behavioral synthesis maps a behavioral description of the desired system to a RTL structure of generic RTL components <ref> [4, 8] </ref>. Thus, functional synthesis can work in synergism with behavioral synthesis by mapping functional descriptions of RTL designs produced by the latter onto actual hardware. Functional synthesis therefore addresses the technology mapping problem at the RTL level. <p> In this paper, we present two algorithms that solve the second problem by formulating it as a clique partitioning problem - similar to work done for solving the allocation problem in behavioral synthesis <ref> [8, 4] </ref>. Our algorithms handle nested conditional branches and do not assume a preallocation of functional units and unit binding as done in [4]. Our cost functions incorporate costs for both interconnection and function select logic.
References-found: 8

