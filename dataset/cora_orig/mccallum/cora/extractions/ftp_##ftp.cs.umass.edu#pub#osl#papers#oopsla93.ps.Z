URL: ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla93.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Object Fault Handling for Persistent Programming Languages: A Performance Evaluation  
Author: Antony L. Hosking J. Eliot B. Moss 
Address: Amherst, MA 01003  
Affiliation: Object Systems Laboratory Department of Computer Science University of Massachusetts  
Abstract: A key mechanism of a persistent programming language is its ability to detect and handle references to non-resident objects. Ideally, this mechanism should be hidden from the programmer, allowing the transparent manipulation of all data regardless of its potential lifetime. We term such a mechanism object faulting, in a deliberate analogy with page faulting in virtual memory systems. This paper presents a number of mechanisms for detecting and handling references to persistent objects, and evaluates their relative performance within an implementation of Persistent Smalltalk. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <month> Nov. </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Persistent programming languages combine the features of database systems and programming languages to allow the seamless manipulation of data, without regard for its potential lifetime, be it transient or persistent <ref> [1] </ref>. To achieve this the language must provide a mechanism for the detection and handling of references to persistent data. Ideally, this mechanism should be hidden from the programmer, so that manipulation of persistent and non-persistent data is as transparent as possible.
Reference: [2] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson, and E. J. Shekita. </author> <title> Storage management for objects in EXODUS. </title> <editor> In W. Kim and F. H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, chapter 14, </booktitle> <pages> pages 341-369. </pages> <publisher> ACM Press/Addison-Wesley, </publisher> <address> New York, New York, </address> <year> 1989. </year>
Reference-contexts: The systems considered in that study include Object-Store [13, 16], a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) <ref> [2, 20] </ref>. Several of the architectures based on ESM require the program to manipulate objects through a call interface, with modifications being performed in the client buffer pool of ESM, as opposed to the virtual memory space of the application.
Reference: [3] <author> R. G. G. Cattell and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM Trans. Database Syst., </journal> <volume> 17(1) </volume> <pages> 1-31, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: In contrast, the page-trapping PF schemes must be aggressive in eliminating indirections, since the indirect blocks reside in protected pages, to which any access will be trapped. 5.1 The benchmark database Our benchmarks are drawn from the OO1 object operations benchmarks <ref> [3] </ref>. The OO1 benchmark database consists of a collection of 20,000 part objects, indexed by part numbers in the range 1 through 20,000, with exactly three connections from each part to other parts.
Reference: [4] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Commun. ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> Nov. </month> <year> 1970. </year>
Reference-contexts: There are on average three or four logical segments per physical segment. Newly created objects are clustered into segments only as they are encountered when unswizzling, using an essentially breadth-first traversal similar to that of copying garbage collectors <ref> [4] </ref>. The part objects are 68 bytes in size (including the object header).
Reference: [5] <editor> A. Dearle, G. M. Shaw, and S. B. Zdonik, editors. </editor> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, Massachusetts, </address> <month> Sept. </month> <year> 1990. </year> <title> Published as Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference: [6] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The underlying permanent storage is managed by the Mneme persistent object store [14]. Our Smalltalk implementation is based on the definition of Goldberg and Robson <ref> [6] </ref>, and consists of two components: a virtual machine and a virtual image. The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality. While we have retained the standard bytecode instruction set of Goldberg and Robson [6], our implementation of <p> Goldberg and Robson <ref> [6] </ref>, and consists of two components: a virtual machine and a virtual image. The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality. While we have retained the standard bytecode instruction set of Goldberg and Robson [6], our implementation of the virtual machine differs somewhat from their original definition. The virtual image is derived from an early commercial version of Smalltalk with minor modifications.
Reference: [7] <author> S. P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1992. </year>
Reference-contexts: Nevertheless, we see no reason why the results will not carry over to a compiled setting; only the relative overheads of object fault detection and handling will change with respect to total execution time. However, some languages (e.g., Modula-3 <ref> [15, 7] </ref>, C++ [23]) do not enforce the pure object-oriented style of execution that enables residency checks to be piggy-backed with method invocation. Operations on an object can be performed without necessarily invoking a method on it.
Reference: [8] <author> A. L. Hosking. </author> <title> Main memory management for persistence, </title> <address> Oct. </address> <year> 1991. </year> <title> Position paper presented at the OOPSLA '91 Workshop on Garbage Collection. </title>
Reference-contexts: In particular, standard programming language techniques for memory management, including those of garbage collection, can be used to manage the objects resident in the program's virtual address space <ref> [8] </ref>. The unit of transfer between the permanent database and Mneme's buffers is the physical segment, which may have arbitrary size (up to some large system-defined limit). Thus a physical segment may contain any number of objects. Objects within a physical segment are further grouped into logical segments.
Reference: [9] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Towards compile-time optimisations for persistence. </title> <editor> In Dearle et al. </editor> <volume> [5], </volume> <pages> pages 17-27. </pages>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. Proceedings ACM Conference on Object-Oriented Programming Systems, Languages, and Applications Washington, DC, Sep. 1993, pp. 288-303 we use for such a mechanism is object faulting <ref> [9, 10] </ref>. The analogy with page faulting virtual memory is deliberate, since the intent is to provide the illusion of a persistent virtual heap of objects, potentially much larger than physical or even virtual memory. <p> Operations on an object can be performed without necessarily invoking a method on it. This means that explicit residency checks must be compiled into the code in advance of such operations, to ensure that the object is resident. Compiler optimizations <ref> [19, 18, 9, 10] </ref> may allow these explicit residency checks to be merged or eliminated. For example, control-flow information may reveal that multiple traversals of a particular object reference along a given execution path require only one residency check, rather than a check per traversal.
Reference: [10] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Compiler support for persistent programming. </title> <type> COINS Technical Report 91-25, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> Mar. </month> <year> 1991. </year>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. Proceedings ACM Conference on Object-Oriented Programming Systems, Languages, and Applications Washington, DC, Sep. 1993, pp. 288-303 we use for such a mechanism is object faulting <ref> [9, 10] </ref>. The analogy with page faulting virtual memory is deliberate, since the intent is to provide the illusion of a persistent virtual heap of objects, potentially much larger than physical or even virtual memory. <p> Operations on an object can be performed without necessarily invoking a method on it. This means that explicit residency checks must be compiled into the code in advance of such operations, to ensure that the object is resident. Compiler optimizations <ref> [19, 18, 9, 10] </ref> may allow these explicit residency checks to be merged or eliminated. For example, control-flow information may reveal that multiple traversals of a particular object reference along a given execution path require only one residency check, rather than a check per traversal.
Reference: [11] <author> T. Kaehler. </author> <title> Virtual memory on a narrow machine for an object-oriented language. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 87-106, </pages> <address> Portland, Oregon, </address> <month> Sept. </month> <year> 1986. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 21, </volume> <month> 11 (Nov. </month> <year> 1986). </year>
Reference-contexts: Extending the size of the heap beyond that which can be addressed in virtual memory requires OIDs that are not virtual memory addresses. Such systems must ultimately perform translation of OIDs to in-memory pointers to allow the program to manipulate the data. LOOM <ref> [12, 11] </ref> represents one of the earliest attempts to extend the size of the heap beyond that addressable by a machine word. Its goal was to provide extended virtual memory support for Smalltalk systems on machines with a narrow (16-bit) word width.
Reference: [12] <author> T. Kaehler and G. Krasner. </author> <title> LOOMlarge object-oriented memory for Smalltalk-80 systems. </title> <editor> In G. Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <booktitle> chapter 14, </booktitle> <pages> pages 251-270. </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Extending the size of the heap beyond that which can be addressed in virtual memory requires OIDs that are not virtual memory addresses. Such systems must ultimately perform translation of OIDs to in-memory pointers to allow the program to manipulate the data. LOOM <ref> [12, 11] </ref> represents one of the earliest attempts to extend the size of the heap beyond that addressable by a machine word. Its goal was to provide extended virtual memory support for Smalltalk systems on machines with a narrow (16-bit) word width.
Reference: [13] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Commun. ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: White and DeWitt [26] have compared the overall performance of a number of architectures and systems that perform object faulting and pointer swizzling. The systems considered in that study include Object-Store <ref> [13, 16] </ref>, a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) [2, 20].
Reference: [14] <author> J. E. B. Moss. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Trans. Inf. Syst., </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: Objects are copied on demand into the virtual memory address space of the program from the buffer pool of the persistent storage manager, in this case the Mneme persistent object store <ref> [14] </ref>. This copying includes any translation needed to convert the objects into a form acceptable to the program, including pointer swizzling. <p> The underlying permanent storage is managed by the Mneme persistent object store <ref> [14] </ref>. Our Smalltalk implementation is based on the definition of Goldberg and Robson [6], and consists of two components: a virtual machine and a virtual image. The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality.
Reference: [15] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: Nevertheless, we see no reason why the results will not carry over to a compiled setting; only the relative overheads of object fault detection and handling will change with respect to total execution time. However, some languages (e.g., Modula-3 <ref> [15, 7] </ref>, C++ [23]) do not enforce the pure object-oriented style of execution that enables residency checks to be piggy-backed with method invocation. Operations on an object can be performed without necessarily invoking a method on it.
Reference: [16] <institution> Object Design, Inc. ObjectStore User Guide, </institution> <month> Oct. </month> <year> 1990. </year> <note> Release 1.0. </note>
Reference-contexts: White and DeWitt [26] have compared the overall performance of a number of architectures and systems that perform object faulting and pointer swizzling. The systems considered in that study include Object-Store <ref> [13, 16] </ref>, a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) [2, 20].
Reference: [17] <author> A. Purdy, B. Schuchardt, and D. Maier. </author> <title> Integrating an object server with other worlds. </title> <journal> ACM Trans. Office Inf. Syst., </journal> <volume> 5(1) </volume> <pages> 27-47, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: The Alltalk system [22] takes a similar approach to LOOM in its implementation of a persistent Smalltalk system, using an object table to translate between object pointers and memory addresses. Alltalk performs no swizzling: object pointers are always external identifiers that must be translated whenever they are deref-erenced. GemStone <ref> [17] </ref>, is another effort to expand the Smalltalk heap to include objects on disk. However, it extends Smalltalk to provide considerable database functionality, including queries and a query execution model.
Reference: [18] <author> J. E. Richardson. </author> <title> Compiled item faulting: A new technique for managing I/O in a persistent language. </title> <editor> In Dearle et al. </editor> <volume> [5], </volume> <pages> pages 3-16. </pages>
Reference-contexts: Operations on an object can be performed without necessarily invoking a method on it. This means that explicit residency checks must be compiled into the code in advance of such operations, to ensure that the object is resident. Compiler optimizations <ref> [19, 18, 9, 10] </ref> may allow these explicit residency checks to be merged or eliminated. For example, control-flow information may reveal that multiple traversals of a particular object reference along a given execution path require only one residency check, rather than a check per traversal.
Reference: [19] <author> J. E. Richardson and M. J. Carey. </author> <title> Persistence in the E language: Issues and implementation. </title> <journal> Software: Practice and Experience, </journal> 19(12) 1115-1150, Dec. 1990. Page <volume> 15 </volume>
Reference-contexts: Operations on an object can be performed without necessarily invoking a method on it. This means that explicit residency checks must be compiled into the code in advance of such operations, to ensure that the object is resident. Compiler optimizations <ref> [19, 18, 9, 10] </ref> may allow these explicit residency checks to be merged or eliminated. For example, control-flow information may reveal that multiple traversals of a particular object reference along a given execution path require only one residency check, rather than a check per traversal.
Reference: [20] <author> D. Schuh, M. Carey, and D. DeWitt. </author> <title> Persistence in E revisitedimplementation experiences. </title> <editor> In Dearle et al. </editor> <volume> [5], </volume> <pages> pages 345-359. </pages>
Reference-contexts: The systems considered in that study include Object-Store [13, 16], a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) <ref> [2, 20] </ref>. Several of the architectures based on ESM require the program to manipulate objects through a call interface, with modifications being performed in the client buffer pool of ESM, as opposed to the virtual memory space of the application.
Reference: [21] <author> V. Singhal, S. V. Kakkad, and P. R. Wilson. </author> <title> Texas, an efficient, portable persistent store. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 11-33, </pages> <address> San Miniato, Italy, </address> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: We note that this is generally acknowledged to be one of the best operating system implementations for trapping page protection faults. Page 3 The Texas system <ref> [21, 27] </ref> uses a page mapping scheme similar to ObjectStore to fault objects and swizzle pointers. When a persistent object is to be assigned a virtual address, a page of virtual memory is reserved (and access protected) for the page in the persistent store that contains the object.
Reference: [22] <author> A. Straw, F. Mellender, and S. Riegel. </author> <title> Object management in a persistent Smalltalk system. </title> <journal> Software: Practice and Experience, </journal> <volume> 19(8) </volume> <pages> 719-737, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The implementors of LOOM acknowledge this and speculate on refinements to their system that would group objects together for transfer between memory and disk. The Alltalk system <ref> [22] </ref> takes a similar approach to LOOM in its implementation of a persistent Smalltalk system, using an object table to translate between object pointers and memory addresses. Alltalk performs no swizzling: object pointers are always external identifiers that must be translated whenever they are deref-erenced.
Reference: [23] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Nevertheless, we see no reason why the results will not carry over to a compiled setting; only the relative overheads of object fault detection and handling will change with respect to total execution time. However, some languages (e.g., Modula-3 [15, 7], C++ <ref> [23] </ref>) do not enforce the pure object-oriented style of execution that enables residency checks to be piggy-backed with method invocation. Operations on an object can be performed without necessarily invoking a method on it.
Reference: [24] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: At each object fault our system scans all transient (i.e., non-persistent) objects (including active stack frames) to eliminate any references to fault blocks that have been converted to indirect blocks. We also maintain a remembered set <ref> [24, 25] </ref> for each page of allocated fault blocks, recording all persistent objects whose pointer tag on a 32-bit machine. 4 Mneme's 28-bit OIDs allow us to keep the size of fault blocks to 32 bits.
Reference: [25] <author> D. M. Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year> <type> Ph.D. Dissertation, </type> <institution> University of California at Berkeley, </institution> <month> February </month> <year> 1986. </year>
Reference-contexts: At each object fault our system scans all transient (i.e., non-persistent) objects (including active stack frames) to eliminate any references to fault blocks that have been converted to indirect blocks. We also maintain a remembered set <ref> [24, 25] </ref> for each page of allocated fault blocks, recording all persistent objects whose pointer tag on a 32-bit machine. 4 Mneme's 28-bit OIDs allow us to keep the size of fault blocks to 32 bits.
Reference: [26] <author> S. J. White and D. J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 419-431, </pages> <address> Vancouver, Canada, Aug. 1992. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: None of them consider the performance overheads of persistence, accepting the costs as necessary to support the functionality they desire. Here, we are interested in exploring the design space for implementing persistent programming languages, by evaluating the performance of a number of mechanisms for object faulting. White and DeWitt <ref> [26] </ref> have compared the overall performance of a number of architectures and systems that perform object faulting and pointer swizzling. The systems considered in that study include Object-Store [13, 16], a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) [2, 20]. <p> Whether software-mediated object faults (realized by augmenting the programming language implementation) can offer competitive performance is a question we explore here. 3 System architecture and rationale Our architecture (see Figure 1) bears a close resemblance to the object caching architecture of White and DeWitt <ref> [26] </ref>. Objects are copied on demand into the virtual memory address space of the program from the buffer pool of the persistent storage manager, in this case the Mneme persistent object store [14]. <p> Edge marking schemes take the approach of tagging the references between the objects. If tagged as swiz-zled, then a reference is a direct pointer to the corresponding object in memory; if non-swizzled then the reference consists of an OID. This is the approach used by EPVM 2.0 <ref> [26] </ref>. An apparent disadvantage of edge marking is that OIDs can be fetched from the pointer fields of objects, passed around, and stored, without accessing the target object. When the target object finally is accessed the origin of the reference may no longer be known. <p> We have already discussed the reasons for our choice, on the grounds of flexibility in the management of resident objects. Moreover, the performance study of White and DeWitt <ref> [26] </ref> indicated that such an architecture was superior to the others they considered. We also recognize that our page trapping approach, which allocates fault blocks in protected pages, does not compare directly with the memory-mapped file approaches of ObjectStore and Texas.
Reference: [27] <author> P. R. Wilson and S. V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently and compatibly supporting huge address spaces on standard hardware. </title> <booktitle> In Proceedings of the 1992 International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <address> Paris, France, Sept. 1992. </address> <publisher> IEEE Press. </publisher> <pages> Page 16 </pages>
Reference-contexts: We note that this is generally acknowledged to be one of the best operating system implementations for trapping page protection faults. Page 3 The Texas system <ref> [21, 27] </ref> uses a page mapping scheme similar to ObjectStore to fault objects and swizzle pointers. When a persistent object is to be assigned a virtual address, a page of virtual memory is reserved (and access protected) for the page in the persistent store that contains the object. <p> As execution proceeds, pages are reserved in a wave-front just ahead of the most recently faulted and swizzled pages, guaranteeing that the application will only ever see virtual memory addresses. Wilson and Kakkad <ref> [27] </ref> report promising preliminary performance results for an implementation of persistent C++ using Texas. The beauty of Texas is that it requires little or no modification to an existing language to support persistence.
References-found: 27

