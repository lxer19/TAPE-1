URL: http://www.eecs.umich.edu/techreports/cse/1993/CSE-TR-178-93.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse93.html
Root-URL: http://www.eecs.umich.edu
Title: CSE-TR Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation  
Author: Joo P. Marques Silva and Karem A. Sakallah 
Address: Ann Arbor, Michigan 48109-2122fl USA  
Affiliation: THE UNIVERSITY OF MICHIGAN Computer Science and Engineering Divisionfl Department of Electrical Engineering and Computer Sciencefl  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abramovici, M. A. Breuer, and A. D. Friedman, </author> <title> Digital Systems Testing and Testable Design. </title> <publisher> Computer Science Press, </publisher> <year> 1990. </year>
Reference-contexts: The conditions to sensitize a path depend on the application. In recent years, extensive work has been done in developing techniques to prune the search space associated with path sensitization problems, particularly in test pattern generation <ref> [ 1, 5-9, 13-16, 19] </ref>. These techniques can be categorized as deterministic (e.g. unique sensitization points, head lines, static/dynamic learning, search space equivalence relations) and nondeterministic (e.g. simple and multiple backtracing). In this paper we propose new deterministic heuristics to further improve search-space pruning in path sensitiza tion. <p> Throughout the paper we use the concepts of D-frontier, J-frontier , X-path, backward/forward implications, head line, unique sensitization points, and other concepts used in path sensitization for test-pattern generation, and which are described in detail in <ref> [1] </ref>. Furthermore, LEAP can perform static learning as proposed in [15], but the extended learning criterion of [10] is used, which includes static learning due to backward implications. Examples of static learning are shown in Fig. 1. Other concepts used in path sensitization are analyzed in the next sections. <p> The results given for SOCRATES also use the improved learning criterion of [10]. Because our main goal is to compare the deterministic heuristics of each algorithm, only structural controllability/ observability measures are used <ref> [1] </ref>. Furthermore, only the following backtracing schemes were tested: 1. Simple backtracing, starting by trying to satisfy the most difficult controllability problems and afterwards trying to satisfy the most simple observability problems. 2. Multiple backtracing, as proposed in [5], but using structural controllability/observability measures. <p> This option is intended to allow using the path sensitization algorithm in other applications, mainly timing analysis and delay-fault testing. Furthermore, no redundancy removal techniques are used <ref> [1] </ref>, [17]. In the tests performed, each path sensitization problem is intended to be analyzed individually, and updating redundant information on the circuit every time a fault is proved redundant, would eventually relate individual path sensitization problems.

Reference: [3] <author> R. Dechter, </author> <title> Learning While Searching in ConstraintSatisfaction Problems. </title> <type> Technical Report CSD-860049, </type> <institution> University of California at Los Angeles, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: In case of inconsistencies, we provide a method to determine nodes which must have assume certain values to avoid inconsistencies. This is referred to as failure-driven asser tions , and can be viewed as a form of learning while searching <ref> [3] </ref>. We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm [14], PODEM [7], FAN [5], TOPS [8], SOCRATES [15] and EST [6], backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking .
Reference: [4] <author> T. Fujino, and H. Fujiwara, </author> <title> An Efficient Test Generation Algorithm Based on Search Space Dominance. </title> <booktitle> Proc. 22nd Fault Tolerant Comput. Symp., </booktitle> <year> 1992. </year>
Reference-contexts: Future work is mainly intended to overcome this problem and to improve the inconsistency processing schemes proposed in LEAP . A natural evolution consists in introducing search space equivalence [6] and dominance <ref> [4] </ref> relations to further prune the search space.
Reference: [5] <author> H. Fujiwara, and T. Shimono, </author> <title> On the Acceleration of Test Generation Algorithms. </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-32, no. 12, </volume> <month> December </month> <year> 1983, </year> <pages> pp. 1137-1144. </pages>
Reference-contexts: In this paper we propose new deterministic heuristics to further improve search-space pruning in path sensitiza tion. These techniques are based on a dynamic analysis of the search process. We start by illustrating how unique sen sitization points <ref> [5] </ref> can be efficiently determined dynamically. Our algorithm has linear time complexity , in contrast to the algorithm suggested in SOCRATES [16] which has worst-case quadratic time complexity. <p> This is referred to as failure-driven asser tions , and can be viewed as a form of learning while searching [3]. We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm [14], PODEM [7], FAN <ref> [5] </ref>, TOPS [8], SOCRATES [15] and EST [6], backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking . In some situations backtracking can provably be performed to some other node in the decision tree, thus saving a lar ge number of backtracks. <p> Hence, j k ,( ) V = CSE-TR-178-93: Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation 3 3 Level-Dependent Analysis 3.1 Dynamic Evaluation of Unique Sensitization Points unique sensitization point is a gate in a circuit which must propagate an error for a given fault to be detected <ref> [5] </ref>. The inputs to this gate, which cannot propagate the error signal, must assume noncontrolling values and are referred to as unique sensitization implications . In Fig. 4 a, an example of a unique sensitization point and corresponding unique sensitization implication are shown. <p> Both vertices can propagate the error signal currently on Assuming the D-frontier to be composed of only , then the error signal propagates from only if assumes a noncontrolling value, i.e. 0. The evaluation of unique sensitization points was proposed in FAN <ref> [5] </ref>, TOPS [8], and SOCRATES [15] as a pre inconsistency 1 3 decision level decision node (c) Decision tree 1 0 1 Key: , vertex implied to 1 at decision level and implication level 2 0 ,( ) 0 = X 5 3 0 ,( ) 1 = X 6 1 <p> and hence can be understood as the implication parents of derived unique sensitization implications. (a) Static (b) Dynamic unique sensitization points unique sensitization point unique sensitization implication CSE-TR-178-93: Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation 5 3.2 Dynamic Evaluation of Head Lines and Dont Cares In FAN <ref> [5] </ref> and SOCRATES [15], head lines are defined as the outputs of fanout-free sub-circuits. Head lines can be satisfied to any logic value in linear time. By using head lines instead of primary inputs, the search space can be effectively reduced. <p> TG-LEAP can also run customized implementations of PODEM, F AN and SOCRATES, that employ the deterministic heuristics of each of these path sensitization algorithms. The implementation of PODEM [7], PODEM*, can perform both forward and backward implications, and thus must maintain a J-frontier. The implementation of FAN <ref> [5] </ref>, FAN*, computes unique (1) (3) inconsistencies only dependent on decision levels 4 and 1 (A) (A) Chronologic backtracking: backtrack to decision level 3 (B) Dependency-directed backtracking: backtrack to decision level 1 1 CSE-TR-178-93: Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation 11 sensitization points dynamically whenever the size <p> Furthermore, only the following backtracing schemes were tested: 1. Simple backtracing, starting by trying to satisfy the most difficult controllability problems and afterwards trying to satisfy the most simple observability problems. 2. Multiple backtracing, as proposed in <ref> [5] </ref>, but using structural controllability/observability measures. In TG-LEAP backtracing is always performed to a head line in opposition to the backtracing schemes in FAN and SOCRATES, where backtracing can stop at fanout points [5], [15]. <p> Multiple backtracing, as proposed in <ref> [5] </ref>, but using structural controllability/observability measures. In TG-LEAP backtracing is always performed to a head line in opposition to the backtracing schemes in FAN and SOCRATES, where backtracing can stop at fanout points [5], [15]. This option is intended to allow using the path sensitization algorithm in other applications, mainly timing analysis and delay-fault testing. Furthermore, no redundancy removal techniques are used [1], [17]. <p> The techniques proposed have been incorporated in a path sensitization algorithm (LEAP), which experimental results show to be more suitable to prove redundancy and to find tests for hard to detect faults than customized implementations of PODEM [7], FAN <ref> [5] </ref> and SOCRATES [15]. Despite the improvements introduced in LEAP, the search process is still extremely dependent on the ordering of assignments to the head lines as the results in Section 4 show.
Reference: [6] <author> J. Giraldi, and M. L. Bushnell, </author> <title> EST: The New Frontier in Automatic Test-Pattern Generation. </title> <booktitle> In Proc. 27th Design Automation Conf., </booktitle> <year> 1990. </year>
Reference-contexts: We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm [14], PODEM [7], FAN [5], TOPS [8], SOCRATES [15] and EST <ref> [6] </ref>, backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking . In some situations backtracking can provably be performed to some other node in the decision tree, thus saving a lar ge number of backtracks. <p> Future work is mainly intended to overcome this problem and to improve the inconsistency processing schemes proposed in LEAP . A natural evolution consists in introducing search space equivalence <ref> [6] </ref> and dominance [4] relations to further prune the search space.
Reference: [7] <author> P. Goel, </author> <title> An Implicit Enumeration Algorithm to Generate Tests for Combinational Logic Circuits. </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-30, no. 3, </volume> <month> March </month> <year> 1981, </year> <pages> pp. 215-222. </pages>
Reference-contexts: This is referred to as failure-driven asser tions , and can be viewed as a form of learning while searching [3]. We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm [14], PODEM <ref> [7] </ref>, FAN [5], TOPS [8], SOCRATES [15] and EST [6], backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking . In some situations backtracking can provably be performed to some other node in the decision tree, thus saving a lar ge number of backtracks. <p> Afterwards, we present a comprehensive set of results that illustrate the effectiveness of LEAP in proving redundancy and in detecting difficult faults. In Section 5 directions for future research are described. 2 Definitions The underlying algorithm for path sensitization is assumed to be a PODEM-based decision procedure <ref> [7] </ref>, where decisions are made with respect to the primary inputs (or to the head lines). <p> TG-LEAP can also run customized implementations of PODEM, F AN and SOCRATES, that employ the deterministic heuristics of each of these path sensitization algorithms. The implementation of PODEM <ref> [7] </ref>, PODEM*, can perform both forward and backward implications, and thus must maintain a J-frontier. <p> The techniques proposed have been incorporated in a path sensitization algorithm (LEAP), which experimental results show to be more suitable to prove redundancy and to find tests for hard to detect faults than customized implementations of PODEM <ref> [7] </ref>, FAN [5] and SOCRATES [15]. Despite the improvements introduced in LEAP, the search process is still extremely dependent on the ordering of assignments to the head lines as the results in Section 4 show.
Reference: [8] <author> T. Kirkland, and M. </author> <title> Ray Mercer , A Topological Search Algorithm for ATPG. </title> <booktitle> In Proc. 24th Design Automation Conf., </booktitle> <year> 1987. </year>
Reference-contexts: This is referred to as failure-driven asser tions , and can be viewed as a form of learning while searching [3]. We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm [14], PODEM [7], FAN [5], TOPS <ref> [8] </ref>, SOCRATES [15] and EST [6], backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking . In some situations backtracking can provably be performed to some other node in the decision tree, thus saving a lar ge number of backtracks. <p> Both vertices can propagate the error signal currently on Assuming the D-frontier to be composed of only , then the error signal propagates from only if assumes a noncontrolling value, i.e. 0. The evaluation of unique sensitization points was proposed in FAN [5], TOPS <ref> [8] </ref>, and SOCRATES [15] as a pre inconsistency 1 3 decision level decision node (c) Decision tree 1 0 1 Key: , vertex implied to 1 at decision level and implication level 2 0 ,( ) 0 = X 5 3 0 ,( ) 1 = X 6 1 0 ,(
Reference: [9] <author> A. Lioy, </author> <title> Adaptive Backtrace and Dynamic Partitioning Enhance APTG. </title> <booktitle> In Proc. Int. Conf. Computer Design, </booktitle> <year> 1988. </year>
Reference-contexts: Consequently , after decision level 2, the set of dynamic head lines becomes instead of the static set , and the dimension of the search space is reduced to half. In <ref> [9] </ref> the concept of dont care vertices was introduced; it basically denotes a vertex that cannot af fect fault prop agation after some decision level, and has been used to speed up the search process by reducing the number of implications performed.
Reference: [10] <author> W. Kunz, and D. Pradhan, </author> <title> Accelerated Dynamic Learning for Test Pattern Generation in Combinational Circuits. </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 12, no. 5, </volume> <month> May </month> <year> 1993, </year> <pages> pp. 684-694. </pages>
Reference-contexts: Furthermore, LEAP can perform static learning as proposed in [15], but the extended learning criterion of <ref> [10] </ref> is used, which includes static learning due to backward implications. Examples of static learning are shown in Fig. 1. Other concepts used in path sensitization are analyzed in the next sections. In order to implement some of the techniques proposed in LEAP, the following additional definitions are required. <p> A path inconsistency occurs when the D-frontier becomes empty after some decision. The two types of inconsistency are illustrated in Fig. 3. In Fig. 3-b the D-frontier is assumed to be composed only of Hence, (b) Improved learning criterion <ref> [10] </ref> (a) In SOCRATES Hence, j k ,( ) V = CSE-TR-178-93: Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation 3 3 Level-Dependent Analysis 3.1 Dynamic Evaluation of Unique Sensitization Points unique sensitization point is a gate in a circuit which must propagate an error for a given fault <p> Hence, SOCRATES* corresponds to a more ef ficient implementation of the deterministic heuristics in [15] and [16] until phase DYN_1 [16], but without the implementation of instruction 2 of the unique sensitization procedure [15]. The results given for SOCRATES also use the improved learning criterion of <ref> [10] </ref>. Because our main goal is to compare the deterministic heuristics of each algorithm, only structural controllability/ observability measures are used [1]. Furthermore, only the following backtracing schemes were tested: 1.
Reference: [11] <author> S. Mallela, and S. Wu, </author> <title> A Sequential Circuit Test Generation System. </title> <booktitle> In Proc. Int. Test Conf., </booktitle> <year> 1985. </year>
Reference-contexts: Parent tracing is performed for each of the vertices in to identify lower decision levels that contribute to relevant implications at decision level In <ref> [11] </ref> and [12] some different forms of dependency-directed backtracking were proposed for test-pattern generation in sequential circuits. However, the backtracking scheme proposed in [11] is only sketched and no experimental results are given. <p> Parent tracing is performed for each of the vertices in to identify lower decision levels that contribute to relevant implications at decision level In <ref> [11] </ref> and [12] some different forms of dependency-directed backtracking were proposed for test-pattern generation in sequential circuits. However, the backtracking scheme proposed in [11] is only sketched and no experimental results are given.
Reference: [12] <author> R. Marlett, </author> <title> An Effective Test Generation System for Sequential Circuits. </title> <booktitle> In Proc. 23th Design Automation Conf., </booktitle> <year> 1986. </year>
Reference-contexts: Parent tracing is performed for each of the vertices in to identify lower decision levels that contribute to relevant implications at decision level In [11] and <ref> [12] </ref> some different forms of dependency-directed backtracking were proposed for test-pattern generation in sequential circuits. However, the backtracking scheme proposed in [11] is only sketched and no experimental results are given. The backtracking scheme proposed in [12] uses a concept equivalent to decision levels to decide the backtracking point in the <p> lower decision levels that contribute to relevant implications at decision level In [11] and <ref> [12] </ref> some different forms of dependency-directed backtracking were proposed for test-pattern generation in sequential circuits. However, the backtracking scheme proposed in [11] is only sketched and no experimental results are given. The backtracking scheme proposed in [12] uses a concept equivalent to decision levels to decide the backtracking point in the decision tree, but as described in [12], the analysis is performed local to an inconsistency and hence it may not to be complete. Consequently, some detectable faults may not be detected. <p> However, the backtracking scheme proposed in [11] is only sketched and no experimental results are given. The backtracking scheme proposed in <ref> [12] </ref> uses a concept equivalent to decision levels to decide the backtracking point in the decision tree, but as described in [12], the analysis is performed local to an inconsistency and hence it may not to be complete. Consequently, some detectable faults may not be detected. The dependency-directed backtracking scheme proposed here has negligible overhead in the absence of inconsistencies.
Reference: [13] <author> J. Rajski, and H. Cox, </author> <title> A Method to Calculate Necessary Assignments in Algorithmic Test Pattern Generation. </title> <booktitle> In Proc. Int. Test Conf., </booktitle> <year> 1990. </year>
Reference-contexts: In a complete test pattern generation system, fault simulation would be employed to reduce the test set size, and to randomly detect some dif ficult detectable faults, as proposed <ref> [13] </ref>, [15] and [19]. We further note that our implementation of SOCRATES* has some relevant differences with respect to the original algorithm [15], [16]. SOCRATES uses an improved multiple backtracing procedure as well as improved controllability/ observability measures to guide the decision procedure.
Reference: [14] <author> J. P. Roth, </author> <title> Diagnosis of Automata Failures: a Calculus and a Method. </title> <journal> IBM J. Res. Develop., </journal> <volume> vol. 10, </volume> <pages> pp. 278-291, </pages> <month> July </month> <year> 1966. </year>
Reference-contexts: This is referred to as failure-driven asser tions , and can be viewed as a form of learning while searching [3]. We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm <ref> [14] </ref>, PODEM [7], FAN [5], TOPS [8], SOCRATES [15] and EST [6], backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking .
Reference: [15] <editor> M. H. Schulz et. al., SOCRA TES: </editor> <title> A Highly Efficient Automatic Test Pattern Generation System. </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <volume> vol. 7, no. 1, </volume> <month> January </month> <year> 1988, </year> <pages> pp. 126-137. </pages>
Reference-contexts: We also intro duce an algorithm to perform dependency-directed backtracking . In most algorithms for path sensitization such as the D-algorithm [14], PODEM [7], FAN [5], TOPS [8], SOCRATES <ref> [15] </ref> and EST [6], backtracking is always performed to the previous node in the decision tree, i.e. chronologic backtracking . In some situations backtracking can provably be performed to some other node in the decision tree, thus saving a lar ge number of backtracks. <p> Throughout the paper we use the concepts of D-frontier, J-frontier , X-path, backward/forward implications, head line, unique sensitization points, and other concepts used in path sensitization for test-pattern generation, and which are described in detail in [1]. Furthermore, LEAP can perform static learning as proposed in <ref> [15] </ref>, but the extended learning criterion of [10] is used, which includes static learning due to backward implications. Examples of static learning are shown in Fig. 1. Other concepts used in path sensitization are analyzed in the next sections. <p> Both vertices can propagate the error signal currently on Assuming the D-frontier to be composed of only , then the error signal propagates from only if assumes a noncontrolling value, i.e. 0. The evaluation of unique sensitization points was proposed in FAN [5], TOPS [8], and SOCRATES <ref> [15] </ref> as a pre inconsistency 1 3 decision level decision node (c) Decision tree 1 0 1 Key: , vertex implied to 1 at decision level and implication level 2 0 ,( ) 0 = X 5 3 0 ,( ) 1 = X 6 1 0 ,( ) 0 = <p> be understood as the implication parents of derived unique sensitization implications. (a) Static (b) Dynamic unique sensitization points unique sensitization point unique sensitization implication CSE-TR-178-93: Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation 5 3.2 Dynamic Evaluation of Head Lines and Dont Cares In FAN [5] and SOCRATES <ref> [15] </ref>, head lines are defined as the outputs of fanout-free sub-circuits. Head lines can be satisfied to any logic value in linear time. By using head lines instead of primary inputs, the search space can be effectively reduced. <p> The implementation of SOCRA TES, SOCRATES*, implements the concepts described in <ref> [15] </ref> and also computes dynamic unique sensitization points, but using the algorithm proposed in Section 3.1. Hence, SOCRATES* corresponds to a more ef ficient implementation of the deterministic heuristics in [15] and [16] until phase DYN_1 [16], but without the implementation of instruction 2 of the unique sensitization procedure [15]. <p> The implementation of SOCRA TES, SOCRATES*, implements the concepts described in <ref> [15] </ref> and also computes dynamic unique sensitization points, but using the algorithm proposed in Section 3.1. Hence, SOCRATES* corresponds to a more ef ficient implementation of the deterministic heuristics in [15] and [16] until phase DYN_1 [16], but without the implementation of instruction 2 of the unique sensitization procedure [15]. The results given for SOCRATES also use the improved learning criterion of [10]. <p> in <ref> [15] </ref> and also computes dynamic unique sensitization points, but using the algorithm proposed in Section 3.1. Hence, SOCRATES* corresponds to a more ef ficient implementation of the deterministic heuristics in [15] and [16] until phase DYN_1 [16], but without the implementation of instruction 2 of the unique sensitization procedure [15]. The results given for SOCRATES also use the improved learning criterion of [10]. Because our main goal is to compare the deterministic heuristics of each algorithm, only structural controllability/ observability measures are used [1]. Furthermore, only the following backtracing schemes were tested: 1. <p> Multiple backtracing, as proposed in [5], but using structural controllability/observability measures. In TG-LEAP backtracing is always performed to a head line in opposition to the backtracing schemes in FAN and SOCRATES, where backtracing can stop at fanout points [5], <ref> [15] </ref>. This option is intended to allow using the path sensitization algorithm in other applications, mainly timing analysis and delay-fault testing. Furthermore, no redundancy removal techniques are used [1], [17]. <p> In a complete test pattern generation system, fault simulation would be employed to reduce the test set size, and to randomly detect some dif ficult detectable faults, as proposed [13], <ref> [15] </ref> and [19]. We further note that our implementation of SOCRATES* has some relevant differences with respect to the original algorithm [15], [16]. SOCRATES uses an improved multiple backtracing procedure as well as improved controllability/ observability measures to guide the decision procedure. <p> a complete test pattern generation system, fault simulation would be employed to reduce the test set size, and to randomly detect some dif ficult detectable faults, as proposed [13], <ref> [15] </ref> and [19]. We further note that our implementation of SOCRATES* has some relevant differences with respect to the original algorithm [15], [16]. SOCRATES uses an improved multiple backtracing procedure as well as improved controllability/ observability measures to guide the decision procedure. Furthermore, SOCRA TES* only implements one of the unique sensitization procedures of SOCRA TES [16]. This justifi es the dif ferences in results observed between SOCRATES* and SOCRATES. <p> The techniques proposed have been incorporated in a path sensitization algorithm (LEAP), which experimental results show to be more suitable to prove redundancy and to find tests for hard to detect faults than customized implementations of PODEM [7], FAN [5] and SOCRATES <ref> [15] </ref>. Despite the improvements introduced in LEAP, the search process is still extremely dependent on the ordering of assignments to the head lines as the results in Section 4 show. Future work is mainly intended to overcome this problem and to improve the inconsistency processing schemes proposed in LEAP .
Reference: [16] <author> M. H. Schulz, and E. Auth, </author> <title> Improved Deterministic Test Pattern Generation with Applications to Redundancy Identifi cation. </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <volume> vol. 8, no. 7, </volume> <month> July </month> <year> 1989, </year> <pages> pp. 811-816. </pages>
Reference-contexts: These techniques are based on a dynamic analysis of the search process. We start by illustrating how unique sen sitization points [5] can be efficiently determined dynamically. Our algorithm has linear time complexity , in contrast to the algorithm suggested in SOCRATES <ref> [16] </ref> which has worst-case quadratic time complexity. We, then, show that the notion of head lin es can be naturally extended to dynamic situations, and thus the size of the set of head lines can be reduced as the search process evolves. <p> for the error signal to propagate from must assume the noncontrolling value of is not a static dominator of X 2 , but due to the implication of becomes a dynamic dominator of The evaluation of dynamic unique sensitization points may be required to prove the redundancy of some faults <ref> [16] </ref>. In a second version of SOCRATES [16], an approach to dynamically compute unique sensitization points based on the intersection of the dynamic dominators of each vertex in the D-frontier is given. This algorithm has quadratic time complexity because it requires the intersection of lists of dominator vertices. <p> must assume the noncontrolling value of is not a static dominator of X 2 , but due to the implication of becomes a dynamic dominator of The evaluation of dynamic unique sensitization points may be required to prove the redundancy of some faults <ref> [16] </ref>. In a second version of SOCRATES [16], an approach to dynamically compute unique sensitization points based on the intersection of the dynamic dominators of each vertex in the D-frontier is given. This algorithm has quadratic time complexity because it requires the intersection of lists of dominator vertices. <p> Furthermore, computing the lists of dynamic dominators of each vertex in the D-frontier also has worst-case quadratic time complexity on the size of the circuit graph. In SOCRATES, the dynamic evaluation of unique sensitization points is only applied to difficult faults, that are otherwise aborted <ref> [16] </ref>. 3.1.1 Levelized Breadth-First Traversal If we envision a circuit as a directed graph and identify the vertices in the D-frontier, then a levelized breadth-first traversal from the vertices in the D-frontier and until a primary output is reached, identifies the existence of an X-path and also identifies the dynamic unique <p> This information is what allows performing dependency-directed backtracking. Our approach to derive failure-driven assertions eventually determines the same information that can be deter - mined with dynamic learning as proposed in SOCRA TES <ref> [16] </ref>, but there are some relevant dif ferences. Dynamic learning has quadratic time complexity and has to be performed after each decision. For this reason dynamic learning is only used for extremely difficult faults [16]. <p> same information that can be deter - mined with dynamic learning as proposed in SOCRA TES <ref> [16] </ref>, but there are some relevant dif ferences. Dynamic learning has quadratic time complexity and has to be performed after each decision. For this reason dynamic learning is only used for extremely difficult faults [16]. On the other hand, computing failure-driven assertions has linear time complexity and is only performed after an inconsistency is found. However , in some cases failure-driven assertions may take several decisions to derive the same information that can be derived with dynamic learning after one decision. <p> The implementation of SOCRA TES, SOCRATES*, implements the concepts described in [15] and also computes dynamic unique sensitization points, but using the algorithm proposed in Section 3.1. Hence, SOCRATES* corresponds to a more ef ficient implementation of the deterministic heuristics in [15] and <ref> [16] </ref> until phase DYN_1 [16], but without the implementation of instruction 2 of the unique sensitization procedure [15]. The results given for SOCRATES also use the improved learning criterion of [10]. <p> The implementation of SOCRA TES, SOCRATES*, implements the concepts described in [15] and also computes dynamic unique sensitization points, but using the algorithm proposed in Section 3.1. Hence, SOCRATES* corresponds to a more ef ficient implementation of the deterministic heuristics in [15] and <ref> [16] </ref> until phase DYN_1 [16], but without the implementation of instruction 2 of the unique sensitization procedure [15]. The results given for SOCRATES also use the improved learning criterion of [10]. Because our main goal is to compare the deterministic heuristics of each algorithm, only structural controllability/ observability measures are used [1]. <p> We further note that our implementation of SOCRATES* has some relevant differences with respect to the original algorithm [15], <ref> [16] </ref>. SOCRATES uses an improved multiple backtracing procedure as well as improved controllability/ observability measures to guide the decision procedure. Furthermore, SOCRA TES* only implements one of the unique sensitization procedures of SOCRA TES [16]. This justifi es the dif ferences in results observed between SOCRATES* and SOCRATES. <p> that our implementation of SOCRATES* has some relevant differences with respect to the original algorithm [15], <ref> [16] </ref>. SOCRATES uses an improved multiple backtracing procedure as well as improved controllability/ observability measures to guide the decision procedure. Furthermore, SOCRA TES* only implements one of the unique sensitization procedures of SOCRA TES [16]. This justifi es the dif ferences in results observed between SOCRATES* and SOCRATES.
Reference: [17] <author> R. M. Stallman, and G. J. Sussman, </author> <title> Forward Reasoning and Dependency-Directed Backtracking in a System for Computer-Aided Circuit Analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 9 (1977), </volume> <pages> pp. 135-196. </pages>
Reference-contexts: Our dependency backtracking algorithm is provably complete , in the sense that a solution is found if a solution exists, and has linear time complexity. Furthermore, if no backtracking is required the algorithm introduces no overhead in the search process. Dependency-directed backtracking schemes were originally proposed in <ref> [17] </ref> in an application of artificial intelligence techniques to circuit analysis. The new techniques for search-space pruning have been incorporated in a path sensitization algorithm LEAP (LEvel-dependent Analysis in Path sensitization). <p> This option is intended to allow using the path sensitization algorithm in other applications, mainly timing analysis and delay-fault testing. Furthermore, no redundancy removal techniques are used [1], <ref> [17] </ref>. In the tests performed, each path sensitization problem is intended to be analyzed individually, and updating redundant information on the circuit every time a fault is proved redundant, would eventually relate individual path sensitization problems.
Reference: [18] <author> R. E. Tarjan, </author> <title> Finding Dominators in Directed Graphs. </title> <journal> SIAM J. Comput., </journal> <volume> vol. 3, </volume> <pages> pp. 62-89, </pages> <year> 1974. </year>
Reference-contexts: 1 ,( ) X 6 2 1 ,( ) current decision level (b) Circuit graph Vertex (a) Vertex inconsistency (b) Path inconsistency 1 0 D-frontier composed only of CSE-TR-178-93: Search-Space Pruning Heuristics for Path Sensitization in Test Pattern Generation 4 processing step and is based on the concept of dominators <ref> [18] </ref>. However, as the search process evolves, other unique sensitization points may exist, which cannot be determined with preprocessing techniques. An example of a dynamic unique sensitization point is shown in Fig. 4-b. Because has been implied to 1, is implied to 0.
Reference: [19] <author> J. A. Waicukauski, et. al., </author> <title> ATPG for Ultra-Large Structured Designs. </title> <booktitle> In Proc. Int. Test Conf., </booktitle> <year> 1990. </year>
Reference-contexts: The conditions to sensitize a path depend on the application. In recent years, extensive work has been done in developing techniques to prune the search space associated with path sensitization problems, particularly in test pattern generation <ref> [ 1, 5-9, 13-16, 19] </ref>. These techniques can be categorized as deterministic (e.g. unique sensitization points, head lines, static/dynamic learning, search space equivalence relations) and nondeterministic (e.g. simple and multiple backtracing). In this paper we propose new deterministic heuristics to further improve search-space pruning in path sensitiza tion. <p> In a complete test pattern generation system, fault simulation would be employed to reduce the test set size, and to randomly detect some dif ficult detectable faults, as proposed [13], [15] and <ref> [19] </ref>. We further note that our implementation of SOCRATES* has some relevant differences with respect to the original algorithm [15], [16]. SOCRATES uses an improved multiple backtracing procedure as well as improved controllability/ observability measures to guide the decision procedure.
References-found: 18

