URL: http://www.cc.gatech.edu/systems/papers/GuTPDS.ps.Z
Refering-URL: http://www.cs.gatech.edu/systems/projects/FALCON/
Root-URL: 
Title: Falcon: On-line Monitoring and Steering of Parallel Programs  
Author: Weiming Gu, Greg Eisenhauer, Karsten Schwan, Jeffrey Vetter 
Keyword: Index Terms Parallel processing, program steering, program adaptation, on-line monitoring, instrumentation, trace analysis, perturbation, performance evaluation, performance displays, molecular dynamics simulation.  
Date: November 1994 Revised September 1995  
Note: Submitted to the IEEE TPDS  
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Advances in high performance computing, communications, and user interfaces are enabling developers to construct increasingly interactive high performance applications. The Falcon system presented in this paper supports such interactivity by providing runtime libraries, tools, and user interfaces that jointly permit the on-line monitoring and steering of large-scale parallel codes. The principal aspects of Falcon described in this paper are its abstractions and tools for capture and analysis of application-specific program information, performed on-line, with controlled latencies and scalable to parallel machines of substantial size. In addition, Falcon provides support for the on-line graphical display of monitoring information, and it allow programs to be steered during their execution, by human users or algorithmically. Falcon also promotes the use of on-line monitoring for purposes other than performance debugging and it permits developers and end users to experiment with alternative program configurations, to play `what if' games with selected program attributes, and to improve program performance by reacting to runtime changes in program behavior. This paper presents our basic research motivation, outlines the Falcon system's functionality, and includes by a detailed evaluation of its performance characteristics in light of its principal contributions. Falcon's functionality and performance evaluation are driven by our experiences with large-scale parallel applications being developed with end users in physics and in atmospheric sciences. The sample application highlighted in this paper is a molecular dynamics simulation program (MD) used by physicists to study the statistical mechanics of liquids. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas E. Anderson and Edward D. Lazowska. Quartz: </author> <title> A tool for tuning parallel program performance. </title> <booktitle> In Proc. of the 1990 SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 115-125, </pages> <address> Boston, </address> <month> May </month> <year> 1990. </year>
Reference: [2] <author> Peter Bates. </author> <title> Debugging heterogeneous distributed systems using event-based models of behavior. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <institution> University of Wisconsin, Madison, WI, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The measurements presented above imply that program steering can be performed rates approximating the execution times of the set of inner loops in programs like MD. From these measurements and in accordance with earlier results presented in this paper and in <ref> [2] </ref> addressing the time required for analyzing monitoring output, it should be apparent that the steering component of Falcon is sufficiently fast to (1) keep up with fairly high rates of monitoring and (2) steer programs at rates and with overheads enabling medium 35 grain algorithmic program configuration [5] and interactive
Reference: [3] <author> Adam Beguelin, Jack Dongarra, Al Geist, and Vaidy Sunderam. </author> <title> Visualization and debugging in a heterogeneous environment. </title> <journal> Computer, </journal> <volume> 26(6) </volume> <pages> 88-95, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Instead, they focus on reducing or controlling program perturbation due to performance monitoring [32]. A further distinction between Falcon and other projects on performance debugging <ref> [37, 30, 3] </ref> is Falcon's support of application-specific monitoring. Such support is essential when end users wish to use monitoring output to steer their programs or to simply understand their runtime behaviors in terms of familiar quantities (e.g., total energy in the MD application).
Reference: [4] <author> Devesh Bhatt, Rakesh Jha, Todd Steves, Rashmi Bhatt, and David Wills. SPI: </author> <title> an Instrumentation Development Environment for Parallel/Distributed Systems. </title> <booktitle> In Proceedings of The 9th International Parallel Processing Symposium, </booktitle> <pages> pages 494-501. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: Each such action may modify any number of program attributes, perform computations, and even initiate other actions. Steering actions are similar to existing models of event/action systems <ref> [4] </ref> in that they are triggered by the receipt of specific events.
Reference: [5] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year> <note> Older version available from the Department of Computer and Information Science, </note> <institution> The Ohio State University, OSU-CISRC-5/88-TR, </institution> <note> newer version available from College of Computing, </note> <institution> Georgia Institute of Technology, </institution> <address> Atlanta GA, GTRC-TR-90/67. </address>
Reference-contexts: Specifically, the Falcon system supports interactive program steering, or the on-line configuration of a program by human users, with the purpose of affecting the program's execution behavior. Falcon also supports program steering performed by on-line algorithms, typically called program adaptation <ref> [5, 6] </ref>. Program steering is useful to end users and developers alike because it permits them to explore alternative computational methods, data domains, and parameter settings. <p> However, our work has often been more concerned with performance improvement by on-line program adaptation, including demonstrating significant performance gains [39] through on-line configuration of mutex lock implementa 4 tions in threads-based multiprocessor programs. Similarly, object-based mechanisms for on-line program configuration are described in <ref> [5, 13, 10] </ref>, where program improvements concern the dynamic adjustment of timing, performance, and reliability properties in response to changes in application needs or in characteristics of the execution environment. <p> be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [44], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing 8 in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 10, 29, 13] </ref>). The primary concerns of this paper are the second and third requirements for program steering. The on-line capture, analysis, and display of information about current program behavior and performance, at the rates required for program steering is of particular importance. <p> This object appears to the steering system as one that exports a number of invokable methods, each of which concerns a specific modifiable program attribute. Therefore, steerable objects are similar to adaptable objects first developed for real-time systems <ref> [5] </ref> and to configurable objects developed for object-oriented operating systems [11]. Each steerable object can be "registered" with the steering system, which maintains a repository of all such objects and their methods in the steering server. Falcon offers both synchronous and asynchronous modes for invoking the methods of steerable objects. <p> This permits the steering system to relegate the responsibility for determining when certain steering actions may be enacted to the application developer, in contrast to previous work performed for real-time systems and described in <ref> [5, 12] </ref> where program adaptations are always performed in conjunction with method invocations on real-time objects. Steering actions are composite operations to be performed by the steering system in response to requests from the user or to monitoring events generated by the program. <p> and in [2] addressing the time required for analyzing monitoring output, it should be apparent that the steering component of Falcon is sufficiently fast to (1) keep up with fairly high rates of monitoring and (2) steer programs at rates and with overheads enabling medium 35 grain algorithmic program configuration <ref> [5] </ref> and interactive steering by application programmers. It is not possible to use Falcon's current mechanisms to perform steering of program abstractions accessed with very high frequencies, like the adaptable locks described in [39]. <p> The VASE system [22] offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability <ref> [5, 39, 8] </ref>. Early work in this research area focuses on the dynamic adjustment of parallel and real-time applications in order to adapt them to different execution environments [44].
Reference: [6] <author> Charles Consel, Calton Pu, and Jonathan Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. </title> <booktitle> In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation. ACM, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Specifically, the Falcon system supports interactive program steering, or the on-line configuration of a program by human users, with the purpose of affecting the program's execution behavior. Falcon also supports program steering performed by on-line algorithms, typically called program adaptation <ref> [5, 6] </ref>. Program steering is useful to end users and developers alike because it permits them to explore alternative computational methods, data domains, and parameter settings.
Reference: [7] <author> Greg Eisenhauer, Weiming Gu, Thomas Kindler, Karsten Schwan, Dilma Silva, and Jeffrey Vetter. </author> <title> Opportunities and tools for highly interactive distributed and parallel computing. </title> <type> Technical Report GIT-CC-94-58, </type> <institution> Georgia Institute of Technology, College of Computing, </institution> <address> Atlanta, GA 30332-0280, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Program steering, either in conjunction with or solely performed by on-line algorithms, can also be used to improve program performance by reacting to dynamic changes in the program's computational or input/output behaviors <ref> [7] </ref>. In the long term, we expect program steering technologies to used in the broader context of distributed laboratories, where multiple and physically distributed end users can collaborate with each other as if they were co-located in a single laboratory setting. <p> A general overview of research on program steering appears in [18]. More information on the utility and challenges concerning steering appears in <ref> [7] </ref>. 5 Related Research Other research related to Falcon falls largely into three different categories: (1) work on program steering, (2) research addressing program and performance monitoring, and (3) specific results concerning program perturbation and other analyses of monitoring information implemented by monitoring systems.
Reference: [8] <author> Greg Eisenhauer, Weiming Gu, Karsten Schwan, and Niru Mallavarupu. </author> <title> Falcon toward interactive parallel programs: The on-line steering of a molecular dynamics application. </title> <booktitle> In Proceedings of The Third International Symposium on High-Performance Distributed Computing (HPDC-3), </booktitle> <pages> pages 26-34, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1994. </year> <journal> IEEE, IEEE Computer Society. </journal>
Reference-contexts: These requirements form one basis on which Falcon's functionality is evaluated. 2.1 The MD Application MD is an interactive molecular dynamics simulation developed at Georgia Tech in cooperation with a group of physicists exploring the statistical mechanics of complex liquids <ref> [49, 8] </ref>. In this paper, we consider a physical system which contains 4800 particles representing an alkane film and 2700 particles in a crystalline base on which the film is layered. <p> The VASE system [22] offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability <ref> [5, 39, 8] </ref>. Early work in this research area focuses on the dynamic adjustment of parallel and real-time applications in order to adapt them to different execution environments [44]. <p> Early work in this research area focuses on the dynamic adjustment of parallel and real-time applications in order to adapt them to different execution environments [44]. More recent experiments demonstrate that changes to specific program states or program components, such as locks [39] and problem partition boundaries <ref> [8] </ref>, can significantly improve overall program performance. Such previous work differs from the results presented in this paper in the extent and nature of its support for program steering. The Falcon system explores in depth the monitoring requirements necessary to support on-line program steering.
Reference: [9] <author> Greg Eisenhauer and Karsten Schwan. </author> <title> MD A flexible framework for high-speed parallel molecular dynamics. </title> <editor> In Adrian Tentner, editor, </editor> <booktitle> High Performance Computing - 1994, </booktitle> <pages> pages 70-75, </pages> <address> P.O. Box 17900, San Diego, CA 92177, </address> <month> April </month> <year> 1994. </year> <title> Society for Computer Simulation, </title> <booktitle> Society for Computer Simulation. Proceedings of the 1994 SCS Simulation Multiconference. </booktitle>
Reference-contexts: The Falcon system's development is part of an ongoing research effort involving the development of large-scale scientific and engineering applications <ref> [9, 26] </ref>, of abstractions and tools for program development and evaluation, and of mechanisms for increasing such programs' utility by making them interactively accessible to end users. <p> It is more difficult to demonstrate enhanced utility via steering, especially when such promises are based on expected increases in the effectiveness of end users. In general, we address this issue by exploring the use of Falcon with sample applications developed jointly with end users in physics <ref> [9] </ref> and atmospheric sciences [26]. This paper describes experimental results derived from our work with physicists on a molecular dynamics simulation (MD). <p> In order to this behavior, Falcon was used to monitor the MD application on a 64-node Kendall Square Research KSR1 machine. The specific MD simulation used in these measurements uses a cylindrical domain decomposition; MD performance and speedups with different decompositions are evaluated in detail elsewhere <ref> [9] </ref>. The experiments presented in this section demonstrate that the multiple monitoring mechanisms (e.g., tracing versus sampling sensors) supported by Falcon can be employed such that monitoring overheads remain moderate for realistic parallel application programs.
Reference: [10] <author> Ahmed Gheith, Bodhi Mukherjee, Dilma Silva, and Karsten Schwan. KTK: </author> <title> Kernel support for configurable objects and invocations. </title> <booktitle> In Second International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 236-240. </pages> <publisher> IEEE, ACM, </publisher> <month> March </month> <year> 1994. </year>
Reference-contexts: However, our work has often been more concerned with performance improvement by on-line program adaptation, including demonstrating significant performance gains [39] through on-line configuration of mutex lock implementa 4 tions in threads-based multiprocessor programs. Similarly, object-based mechanisms for on-line program configuration are described in <ref> [5, 13, 10] </ref>, where program improvements concern the dynamic adjustment of timing, performance, and reliability properties in response to changes in application needs or in characteristics of the execution environment. <p> be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [44], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing 8 in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 10, 29, 13] </ref>). The primary concerns of this paper are the second and third requirements for program steering. The on-line capture, analysis, and display of information about current program behavior and performance, at the rates required for program steering is of particular importance.
Reference: [11] <author> Ahmed Gheith, Bodhisattwa Mukherjee, Dilma Silva, and Karsten Schwan. KTK: </author> <title> Configurable objects and invocations. </title> <booktitle> In Proceedings of the International Workshop on Object-Orientation in Operating Systems, </booktitle> <month> August </month> <year> 1993. </year> <note> (Position Paper). 40 </note>
Reference-contexts: This object appears to the steering system as one that exports a number of invokable methods, each of which concerns a specific modifiable program attribute. Therefore, steerable objects are similar to adaptable objects first developed for real-time systems [5] and to configurable objects developed for object-oriented operating systems <ref> [11] </ref>. Each steerable object can be "registered" with the steering system, which maintains a repository of all such objects and their methods in the steering server. Falcon offers both synchronous and asynchronous modes for invoking the methods of steerable objects.
Reference: [12] <author> Ahmed Gheith and Karsten Schwan. </author> <title> CHAOS-arc kernel support for multi-weight objects, invocations, and atomicity in real-time applications. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(1) </volume> <pages> 33-72, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: This permits the steering system to relegate the responsibility for determining when certain steering actions may be enacted to the application developer, in contrast to previous work performed for real-time systems and described in <ref> [5, 12] </ref> where program adaptations are always performed in conjunction with method invocations on real-time objects. Steering actions are composite operations to be performed by the steering system in response to requests from the user or to monitoring events generated by the program.
Reference: [13] <author> Prabha Gopinath and Karsten Schwan. </author> <title> CHAOS: Why one cannot have only an operating system for real-time applications. </title> <journal> SIGOPS Notices, </journal> <pages> pages 106-125, </pages> <month> July </month> <year> 1989. </year> <note> Also available as Philips Technical Note TN-89-006. </note>
Reference-contexts: However, our work has often been more concerned with performance improvement by on-line program adaptation, including demonstrating significant performance gains [39] through on-line configuration of mutex lock implementa 4 tions in threads-based multiprocessor programs. Similarly, object-based mechanisms for on-line program configuration are described in <ref> [5, 13, 10] </ref>, where program improvements concern the dynamic adjustment of timing, performance, and reliability properties in response to changes in application needs or in characteristics of the execution environment. <p> be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [44], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing 8 in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 10, 29, 13] </ref>). The primary concerns of this paper are the second and third requirements for program steering. The on-line capture, analysis, and display of information about current program behavior and performance, at the rates required for program steering is of particular importance.
Reference: [14] <author> Weiming Gu. </author> <title> On-line Monitoring and Interactive Steering of Large-Scale Parallel and Distributed Applications. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Additional information about how performance-relevant and application-specific graphical displays are constructed, how they are used for performance understanding and for gaining application-specific insights on program behavior, and how they are integrated with the rest of the Falcon system is available elsewhere <ref> [15, 14] </ref>. General methods for supporting performance understanding in program animation systems are described in [27, 47].
Reference: [15] <author> Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan, John Stasko, Jeffrey Vetter, and Niru-pama Mallavarupu. </author> <title> Falcon: On-line monitoring and steering of large-scale parallel programs. </title> <type> Technical Report GIT-CC-94-21, </type> <institution> Georgia Institute of Technology, College of Computing, </institution> <address> Atlanta, GA 30332-0280, </address> <month> April </month> <year> 1994. </year> <note> Also in Frontiers 95. </note>
Reference-contexts: Specifically, Falcon offers several default on-line graphical animations of the performance of threads-based parallel program (see <ref> [15] </ref>). In addition, Falcon uses the Polka system for program animation which provides users with easy-to-use tools for creating application-specific 2D animations of arbitrary program attributes [48]. <p> Additional information about how performance-relevant and application-specific graphical displays are constructed, how they are used for performance understanding and for gaining application-specific insights on program behavior, and how they are integrated with the rest of the Falcon system is available elsewhere <ref> [15, 14] </ref>. General methods for supporting performance understanding in program animation systems are described in [27, 47]. <p> For on-line monitoring, it must be possible to construct and then include with the event stream temporary event storage and reordering routines. Such analyses are performed in the event reordering filter constructed for the thread life-time view. Its implementation and use for performance understanding are discussed in detail elsewhere <ref> [27, 47, 15] </ref>. To summarize, Falcon supports the on-line display of captured program information in two ways: (1) by permitting the placement of necessary analysis code at any level of its event capture hierarchy and (2) by facilitating the attachment of multiple performance-relevant and application-specific displays to captured event streams.
Reference: [16] <author> Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan, John Stasko, Jeffrey Vetter, and Nirupama Mallavarupu. </author> <title> Falcon: On-line monitoring and steering of large-scale parallel programs. </title> <booktitle> In Proceedings of FRONTIERS'95, </booktitle> <month> February </month> <year> 1995. </year> <note> To appear. Also available as Technical Report GIT-CC-94-21, </note> <institution> College of Computing, Georgia Institute of Technology. </institution>
Reference-contexts: In comparison, with Gprof, the execution time of MD is increased by approximately 180%. Similar advantages of Falcon to other profiling tools are demonstrated when using Prof. Experimental results not reported in detail here show that Prof's overhead is approximately 130% <ref> [16] </ref>. Performance of alternative monitoring techniques.
Reference: [17] <author> Weiming Gu, Jeffrey Vetter, and Karsten Schwan. </author> <title> An annotated bibliography of interactive program steering. </title> <type> Technical Report GIT-CC-94-15, </type> <institution> Georgia Institute of Technology, College of Computing, Geor-gia Institute of Technology, </institution> <address> Atlanta, GA 30332-0280, </address> <month> February </month> <year> 1994. </year> <journal> Also appear in ACM SIGPLAN Notices 29(9), </journal> <pages> pages 140-148. </pages>
Reference-contexts: For algorithmic steering, captured information is provided to steering algorithms. Many such algorithms have been described in the literature (see Section 5 and <ref> [17] </ref>), each requires information specific to the application and/or to the steering actions being performed. For example, one algorithm developed in our own work attempts to improve program performance by dynamically configuring mutex lock implementations for programs running on shared memory machines [39].
Reference: [18] <author> Weiming Gu, Jeffrey Vetter, and Karsten Schwan. </author> <title> An annotated bibliography of interactive program steering. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 140-148, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Ongoing research with the steering component of Falcon includes its evaluation with a large scale atmospheric modeling application [26], as well as its integration with user interface facilities for program steering. A general overview of research on program steering appears in <ref> [18] </ref>. <p> Also, the steering mechanisms of Falcon are intended to support both algorithmic and interactive steering, which imposes performance requirements not shared by other systems. Readers 36 interested in the general topic of program steering can find a complete review of such work in <ref> [18] </ref>. Program monitoring. Past work addressing the monitoring of parallel and distributed programs has typically focussed on performance understanding and debugging.
Reference: [19] <author> Michael T. Heath and Jennifer A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> 8(5) </volume> <pages> 29-39, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: identifies the limits on possible rates with which steering may be performed due to minimum monitoring, decision making, and enactment delays implied by the library's implementation. 3.5 Falcon's On-line Display System Graphical displays have been shown useful in presenting data structures, algorithms [46], runtime program behavior [31], and performance information <ref> [19, 42] </ref> to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information. Instead, Falcon supports the on-line use of displays to help users understand a target program's performance and runtime behavior, as well as to interactively steer their parallel codes.
Reference: [20] <author> Jeffrey K. Hollingsworth and Barton P. Miller. </author> <title> Dynamic control of performance monitoring on large scale parallel systems. </title> <booktitle> In Proceedings of the 7th ACM International Conference on Supercomputing, </booktitle> <pages> pages 185-194, </pages> <address> Tokyo, Japan, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: An alternative approach to performance debugging (and also complimentary to our research) is the W 3 search model described in <ref> [20] </ref>. This model is designed to assist users in interacting with the monitoring system while searching for performance bottlenecks in the target program.
Reference: [21] <author> Jeffrey K. Hollingsworth, Barton P. Miller, and Jon Cargille. </author> <title> Dynamic program instrumentation for scalable performance tools. </title> <booktitle> In Proceedings of SHPCC'94, </booktitle> <pages> pages 841-850, </pages> <address> Knoxville, TN, May 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This distinguishes our work from related research on performance monitoring and tuning, including that of Reed [42] and Miller <ref> [21] </ref>, both of which generally address the issue of performance debugging using program traces stored in intermediate files. These projects' primary concern is not the latency with which program events are transferred from the program to the end user (i.e., to an interactive user interface or to an adaptation algorithm). <p> Such changes permit the selection of suitable monitoring performance for specific monitoring and steering tasks, and they may be used to adapt the monitoring system to dynamic changes in workload imposed by the target application. For example, when heavy monitoring is 4 Related work by Hollingsworth and Miller <ref> [21] </ref> removes instrumentation points in order to completelyeliminate the overheads of such `turned-off' instrumentation points. 15 detected by a simple monitor-monitor mechanism, new local monitoring threads may be forked.
Reference: [22] <author> D. Jablonowski, J. Bruner, B. Bliss, and R. Haber. VASE: </author> <title> The Visualization and application steering environment. </title> <booktitle> In Proceedings of Sumpercomputing '93, </booktitle> <pages> pages 560-569, </pages> <address> Portland, OR, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Such support is essential when end users wish to use monitoring output to steer their programs or to simply understand their runtime behaviors in terms of familiar quantities (e.g., total energy in the MD application). Related research in program steering (e.g., the Vase system <ref> [22] </ref>) differs from our work in its focus on steering by human users. In contrast, because Falcon supports both algorithmic and interactive program steering, it emphasizes monitoring latencies and overheads more than strictly human interactive systems like Vase. <p> Falcon's monitoring support, the exploratory nature 19 of our research concerning program steering has not yet permitted us to develop compile-time support for program steering, such as language support placing constraints on possible steering or the integration of steering support with the application's programming language performed in the Vase system <ref> [22] </ref>. The performance evaluation of the steering library's current implementation presented in Section 4.4 demonstrates that the current implementation easily supports interactive steering. <p> Each of these topics are reviewed in turn below. Interactive program steering. The concept of steering can be found in many interactive scientific visualization and animation applications which allow users directly to manipulate the objects to be visualized or animated <ref> [24, 22] </ref>. For example, in a wind tunnel simulation, users can interactively change shapes and boundaries of objects in the wind tunnel in order to see the effects on the air flow. <p> Research has also addressed the provision of programming models and environments to support the interactive steering of scientific visualization. In [24], DYNA3D and AVS (Application Visualization System from AVS Inc.) are combined with customized interactive steering code to produce a time-accurate, unsteady finite-element simulation. The VASE system <ref> [22] </ref> offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability [5, 39, 8].
Reference: [23] <author> Yves Jean, Thomas Kindler, William Ribarsky, Weiming Gu, Gregory Eisenhauer, Karsten Schwan, and Fred Alyea. </author> <title> Case study: An integrated approach for steering, visualization, and analysis of atmospheric simulations. In Visualization `95. </title> <publisher> IEEE, </publisher> <month> October </month> <year> 1995. </year> <note> Also published as GIT-GVU-95-15, http://www.cc.gatech.edu/gvu/reports). 41 </note>
Reference-contexts: Furthermore, Falcon is now being used for experimenting with alternative parameter settings in a large-scale atmospheric modeling application [26], using interactive 3D data displays via the Silicon Graphics Explorer environment <ref> [23] </ref>. 3 Falcon emphasizes low latency, on-line monitoring, performed by capturing only those program attributes required for specific performance analyses or for specific program steering.
Reference: [24] <author> David Kerlick and Elisabeth Kirby. </author> <title> Towards interactive steering, visualization and animation of un-steady finite element simulations. </title> <booktitle> In Proceedings of Visualization'93, </booktitle> <year> 1993. </year>
Reference-contexts: Each of these topics are reviewed in turn below. Interactive program steering. The concept of steering can be found in many interactive scientific visualization and animation applications which allow users directly to manipulate the objects to be visualized or animated <ref> [24, 22] </ref>. For example, in a wind tunnel simulation, users can interactively change shapes and boundaries of objects in the wind tunnel in order to see the effects on the air flow. <p> Research has also addressed the provision of programming models and environments to support the interactive steering of scientific visualization. In <ref> [24] </ref>, DYNA3D and AVS (Application Visualization System from AVS Inc.) are combined with customized interactive steering code to produce a time-accurate, unsteady finite-element simulation. The VASE system [22] offers tools that create and manage collections of steerable Fortran codes.
Reference: [25] <author> Carol Kilpatrick and Karsten Schwan. </author> <title> Using languages for describing capture, analysis, and display of performance information for parallel and distributed applications. </title> <type> Technical report, </type> <institution> School of Information and Computer Science, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: The use of such techniques with Falcon would further improve system performance. The topic of application-specific program monitoring has been addressed previously by Snodgrass and in our own research [45, 41]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages <ref> [41, 25] </ref>, some of which are based on the Entity-Relational model [45]. We are only now beginning to add `view'-level specifications to the Falcon system. Data and perturbation analysis.
Reference: [26] <author> Thomas Kindler, Karsten Schwan, Dilma Silva, Mary Trauner, and Fred Alyea. </author> <title> Parallelization of spectral models for atmospheric transport processes. </title> <type> Technical Report GIT-CC-95-17, </type> <institution> Georgia Institute of Technology, College of Computing, </institution> <address> Atlanta, GA 30332-0280, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The Falcon system's development is part of an ongoing research effort involving the development of large-scale scientific and engineering applications <ref> [9, 26] </ref>, of abstractions and tools for program development and evaluation, and of mechanisms for increasing such programs' utility by making them interactively accessible to end users. <p> In addition, Falcon uses the Polka system for program animation which provides users with easy-to-use tools for creating application-specific 2D animations of arbitrary program attributes [48]. Furthermore, Falcon is now being used for experimenting with alternative parameter settings in a large-scale atmospheric modeling application <ref> [26] </ref>, using interactive 3D data displays via the Silicon Graphics Explorer environment [23]. 3 Falcon emphasizes low latency, on-line monitoring, performed by capturing only those program attributes required for specific performance analyses or for specific program steering. <p> For example, atmospheric scientists working with our group utilize program steering to reduce turnaround time when determining certain model parameter settings such that simulation outputs match observational data <ref> [26] </ref>. However, our work has often been more concerned with performance improvement by on-line program adaptation, including demonstrating significant performance gains [39] through on-line configuration of mutex lock implementa 4 tions in threads-based multiprocessor programs. <p> In general, we address this issue by exploring the use of Falcon with sample applications developed jointly with end users in physics [9] and atmospheric sciences <ref> [26] </ref>. This paper describes experimental results derived from our work with physicists on a molecular dynamics simulation (MD). <p> A sample application-specific view depicting chemical concentrations in the atmosphere and accepting steering commands was developed for steering the atmospheric modeling application described in <ref> [26] </ref>. This view appears on the bottom right of Figure 6. For brevity, this paper discusses only one interesting topic concerning on-line vs. off-line displays, which is the analysis of monitoring information such that displays depict actual program behavior rather than artifacts of the monitoring system's implementation. <p> Toward this end, we are now developing and integrating into Falcon interactive 3D data visualization tools. These tools are being used for steering a large-scale atmospheric modeling application <ref> [26] </ref>. 4 System Evaluation End users will not employ Falcon for program monitoring and steering if its use results in undue degradation in the performance of their application programs. <p> Such high-rate and low-latency steering must be performed by local monitors themselves, or even by using custom implementations of sampling sensors. Ongoing research with the steering component of Falcon includes its evaluation with a large scale atmospheric modeling application <ref> [26] </ref>, as well as its integration with user interface facilities for program steering. A general overview of research on program steering appears in [18]. <p> The specific example being constructed by our group is a laboratory for atmospheric modeling research <ref> [26] </ref>, where multiple models use input data received from satellites, share and correlate their outputs, and generate inputs to online visualizations. Moreover, model outputs (e.g., data visualizations), on-line performance information, and model execution control may be performed by multiple scientists collaborating across physically distributed machines. Acknowledgments.
Reference: [27] <author> Eileen Kraemer. </author> <title> A Framework, Tools, and Methodology for the Visualization of Parallel and Distributed Systems. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: General methods for supporting performance understanding in program animation systems are described in <ref> [27, 47] </ref>. In Falcon, monitoring information captured for use by on-line displays may be analyzed at several different sites, including in extended sensors, local monitors, the central monitor, and in additional analysis packages interposed between central monitor and displays. <p> For on-line monitoring, it must be possible to construct and then include with the event stream temporary event storage and reordering routines. Such analyses are performed in the event reordering filter constructed for the thread life-time view. Its implementation and use for performance understanding are discussed in detail elsewhere <ref> [27, 47, 15] </ref>. To summarize, Falcon supports the on-line display of captured program information in two ways: (1) by permitting the placement of necessary analysis code at any level of its event capture hierarchy and (2) by facilitating the attachment of multiple performance-relevant and application-specific displays to captured event streams. <p> More interestingly, a PhD thesis addressing parallel program animation has used Falcon's threads performance data to evaluate the utility of a variety of animations for performance understanding <ref> [27, 28] </ref>. This thesis implemented on-line techniques for handling "out-of-order" events produced during program monitoring that may violate program causality. 6 Conclusions and Future Work In this paper, we have demonstrated the utility and potentials of program steering with a large-scale parallel application program, a molecular dynamics simulation.
Reference: [28] <author> Eileen Kraemer and John T. Stasko. </author> <title> Issues in visualization for the comprehension of parallel progr ams. </title> <booktitle> In Proceedings, Workshop on Program Comprehension, </booktitle> <pages> pages 116-125, </pages> <address> Washington, DC, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: More interestingly, a PhD thesis addressing parallel program animation has used Falcon's threads performance data to evaluate the utility of a variety of animations for performance understanding <ref> [27, 28] </ref>. This thesis implemented on-line techniques for handling "out-of-order" events produced during program monitoring that may violate program causality. 6 Conclusions and Future Work In this paper, we have demonstrated the utility and potentials of program steering with a large-scale parallel application program, a molecular dynamics simulation.
Reference: [29] <author> Jeff Kramer and Jeff MaGee. </author> <title> Dynamic configuration for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):424-436, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: Other examples of the utility of program steering include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems and the load balancing or program configuration for enhanced reliability in distributed systems <ref> [29, 43, 33] </ref>. Many of the research results listed above concern performance improvements attained by program steering. It is more difficult to demonstrate enhanced utility via steering, especially when such promises are based on expected increases in the effectiveness of end users. <p> be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [44], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing 8 in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 10, 29, 13] </ref>). The primary concerns of this paper are the second and third requirements for program steering. The on-line capture, analysis, and display of information about current program behavior and performance, at the rates required for program steering is of particular importance.
Reference: [30] <author> Thomas J. LeBlanc and John M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-481, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Instead, they focus on reducing or controlling program perturbation due to performance monitoring [32]. A further distinction between Falcon and other projects on performance debugging <ref> [37, 30, 3] </ref> is Falcon's support of application-specific monitoring. Such support is essential when end users wish to use monitoring output to steer their programs or to simply understand their runtime behaviors in terms of familiar quantities (e.g., total energy in the MD application).
Reference: [31] <author> Allen D. Malony, David H. Hammerslag, and David J. Jablonowski. </author> <title> Traceview: A trace visualization. </title> <journal> IEEE Software, </journal> <pages> pages 19-28, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: It also identifies the limits on possible rates with which steering may be performed due to minimum monitoring, decision making, and enactment delays implied by the library's implementation. 3.5 Falcon's On-line Display System Graphical displays have been shown useful in presenting data structures, algorithms [46], runtime program behavior <ref> [31] </ref>, and performance information [19, 42] to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information.
Reference: [32] <author> Allen D. Malony, Daniel A. Reed, and Harry A. G. Wijshoff. </author> <title> Performance measurement intrusion and perturbation analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(4) </volume> <pages> 433-450, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: These projects' primary concern is not the latency with which program events are transferred from the program to the end user (i.e., to an interactive user interface or to an adaptation algorithm). Instead, they focus on reducing or controlling program perturbation due to performance monitoring <ref> [32] </ref>. A further distinction between Falcon and other projects on performance debugging [37, 30, 3] is Falcon's support of application-specific monitoring. <p> Such perturbation can be predicted fairly well (results on the KSR-2 are presented in Section 4), and therefore, its effects on the correctness of timing information can be eliminated using known techniques for perturbation analysis <ref> [32] </ref>. Falcon's runtime monitoring system itself may be configured (steered) in several ways, including disabling or enabling sets of sensors, varying activation rates, etc. <p> They include the costs of accessing the sensor switch flag, computing the values of sensor attributes, and writing the generated sensor record into an event queue. Falcon performs no additional inline processing, such algorithms for detecting more complex side effects of program perturbation <ref> [32] </ref>, so these subcosts characterize the basic cost of tracing sensors. However, these values do not include excessive perturbation that might be caused by bottlenecks in the processing and transmission of the events (which would result in delays in obtaining buffer space). <p> Data and perturbation analysis. Monitoring information may be refined with trace data analysis techniques, such as the Critical Path Analysis and Phase Behavior Analysis described in [35]. In addition, more sophisticated analysis techniques may be used to reduce and correct perturbation to the measured program performance due to monitoring <ref> [32] </ref>, and to apply various statistical filtering techniques prior displaying the data to users. All such techniques may be applied to Falcon's monitoring data as well, but at this time only the simplistic perturbation analysis required for the thread life-time view has been implemented with 37 Falcon.
Reference: [33] <author> Keith Marzullo and Mark Wood. </author> <title> Making real-time reactive systems reliable. </title> <journal> ACM Operating Systems Review, </journal> <volume> 25(1) </volume> <pages> 45-48, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Other examples of the utility of program steering include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems and the load balancing or program configuration for enhanced reliability in distributed systems <ref> [29, 43, 33] </ref>. Many of the research results listed above concern performance improvements attained by program steering. It is more difficult to demonstrate enhanced utility via steering, especially when such promises are based on expected increases in the effectiveness of end users.
Reference: [34] <author> Henry Massalin and Calton Pu. </author> <title> Threads and input/output in the synthesis kernel. </title> <booktitle> In Proceedings of the 12th Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201. </pages> <publisher> SIGOPS, Assoc. Comput. Mach., </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: For further latency reductions, additional sensor compiler functionality must be provided, perhaps generating alternative representations of stubs generated from sensor specifications or even using on-line recompilation and relinking techniques like those described for the Synthesis operating system <ref> [34] </ref>. In summary, while Falcon's functionality is easily provided on a wide variety of target machines and platforms, its mechanisms for controlling monitoring overheads and latencies rely in part on the availability of parallelism in the underlying machine.
Reference: [35] <author> Barton P. Miller, Morgan Clark, Jeff Hollingsworth, Steven Kierstead, Sek-See Lim, and Timothy Torzewski. IPS-2: </author> <title> The second generation of a parallel program measurement system. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 206-217, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Readers 36 interested in the general topic of program steering can find a complete review of such work in [18]. Program monitoring. Past work addressing the monitoring of parallel and distributed programs has typically focussed on performance understanding and debugging. These performance monitoring systems (e.g.Miller's IPS [36] and IPS-2 <ref> [35] </ref>, Reed's Pablo [42]) provide programmers with execution information about their parallel codes and lead their attention to those program components on which most execution time is spent. A variety of performance metrics like `normalized processor time'[1] and `execution time on the critical execution path' [35] are employed to describe the <p> (e.g.Miller's IPS [36] and IPS-2 <ref> [35] </ref>, Reed's Pablo [42]) provide programmers with execution information about their parallel codes and lead their attention to those program components on which most execution time is spent. A variety of performance metrics like `normalized processor time'[1] and `execution time on the critical execution path' [35] are employed to describe the program's runtime performance. Recent research by several of these groups is attempting to relate performance measurements to the specific program components impacting performance, typically by interfacing performance tools to program compilers. <p> We are only now beginning to add `view'-level specifications to the Falcon system. Data and perturbation analysis. Monitoring information may be refined with trace data analysis techniques, such as the Critical Path Analysis and Phase Behavior Analysis described in <ref> [35] </ref>. In addition, more sophisticated analysis techniques may be used to reduce and correct perturbation to the measured program performance due to monitoring [32], and to apply various statistical filtering techniques prior displaying the data to users.
Reference: [36] <author> Barton P. Miller and Cui-Qing Yang. IPS: </author> <title> An interactive and automatic performance measurement tool for parallel and distributed programs. </title> <booktitle> In Proceedings of the 7th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 482-489, </pages> <address> Berlin, West Germany, </address> <month> September </month> <year> 1987. </year> <note> IEEE. </note>
Reference-contexts: Readers 36 interested in the general topic of program steering can find a complete review of such work in [18]. Program monitoring. Past work addressing the monitoring of parallel and distributed programs has typically focussed on performance understanding and debugging. These performance monitoring systems (e.g.Miller's IPS <ref> [36] </ref> and IPS-2 [35], Reed's Pablo [42]) provide programmers with execution information about their parallel codes and lead their attention to those program components on which most execution time is spent.
Reference: [37] <author> B. Mohr, D. Brown, and A. Malony. </author> <title> Tau: A portable parallel program analysis environment for pc++. </title> <booktitle> In Proceedings of CONPAR 94 - VAPP VI, </booktitle> <pages> pages 29-40. </pages> <institution> University of Linz, </institution> <month> September </month> <year> 1994. </year> <note> LNCS 854. </note>
Reference-contexts: Instead, they focus on reducing or controlling program perturbation due to performance monitoring [32]. A further distinction between Falcon and other projects on performance debugging <ref> [37, 30, 3] </ref> is Falcon's support of application-specific monitoring. Such support is essential when end users wish to use monitoring output to steer their programs or to simply understand their runtime behaviors in terms of familiar quantities (e.g., total energy in the MD application).
Reference: [38] <author> Bodhisattwa Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <booktitle> In Proceedings of the Sun User Group Technical Conference, </booktitle> <pages> pages 101-112, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Falcon's implementation relies on a Mach-compatible Cthreads library <ref> [38] </ref> available on a variety of hardware platforms, including the Kendall Square Research KSR-1 and KSR-2 supercomputers, the Sequent multiprocessor, uni- and multi-processor SGI, SUN SPARC, IBM RS6000 workstations, and various Linux machines. Falcon's implementation structure is depicted in Figure 5. <p> In addition, we briefly describe Falcon's steering mechanisms and its on-line display system, which consume the information obtained from the on-line monitoring system. Portability and limitations. The current implementation of Falcon relies on the availability of Georgia Tech Cthreads <ref> [38] </ref> on the desired target machine and on the availability of shared memory between application processes and local monitoring threads. Local monitoring threads are written as Cthreads programs and rely on Falcon's event buffering mechanisms for event transfer.
Reference: [39] <author> Bodhisattwa Mukherjee and Karsten Schwan. </author> <title> Improving performance by use of adaptive objects: Experimentation with a configurable multiprocessor thread package. </title> <booktitle> In Proc. of the second International Symposium on High Performance Distributed Computing, </booktitle> <pages> pages 59-66, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: For example, atmospheric scientists working with our group utilize program steering to reduce turnaround time when determining certain model parameter settings such that simulation outputs match observational data [26]. However, our work has often been more concerned with performance improvement by on-line program adaptation, including demonstrating significant performance gains <ref> [39] </ref> through on-line configuration of mutex lock implementa 4 tions in threads-based multiprocessor programs. <p> For example, one algorithm developed in our own work attempts to improve program performance by dynamically configuring mutex lock implementations for programs running on shared memory machines <ref> [39] </ref>. This algorithm requires the capture of small amounts of program information (i.e., the average waiting times experienced by threads on individual mutex locks) with low latencies and high rates attainable only with the sampling techniques described and used in Section 4.3 below. <p> In the case of dynamic load balancing by shifting domain boundaries in MD, the rates of change in particle locations are sufficiently low so that human users can detect load imbalances and shift domain boundaries. However, when steering is used to dynamically adjust lock waiting strategies as in <ref> [39] </ref>, changes in locking patterns must be detected and reacted to every few 9 milliseconds. As a result, any on-line monitoring support for program steering must provide information necessary for steering with low latency. <p> Low latency implies that steering algorithms can rapidly react to changes in a user program's current state such as is required to support the configuration done in <ref> [39] </ref>. Monitoring latency includes the cost of writing a sensor record to a monitoring buffer, the waiting time in the buffer, and the cost of reading the sensor record from the monitoring buffer. <p> It is not possible to use Falcon's current mechanisms to perform steering of program abstractions accessed with very high frequencies, like the adaptable locks described in <ref> [39] </ref>. Such high-rate and low-latency steering must be performed by local monitors themselves, or even by using custom implementations of sampling sensors. <p> The VASE system [22] offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability <ref> [5, 39, 8] </ref>. Early work in this research area focuses on the dynamic adjustment of parallel and real-time applications in order to adapt them to different execution environments [44]. <p> Early work in this research area focuses on the dynamic adjustment of parallel and real-time applications in order to adapt them to different execution environments [44]. More recent experiments demonstrate that changes to specific program states or program components, such as locks <ref> [39] </ref> and problem partition boundaries [8], can significantly improve overall program performance. Such previous work differs from the results presented in this paper in the extent and nature of its support for program steering. The Falcon system explores in depth the monitoring requirements necessary to support on-line program steering.
Reference: [40] <author> Bodhisattwa Mukherjee and Karsten Schwan. </author> <title> Survey of real-time operating systems. </title> <type> Technical Report GIT-CC-93/18, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: These changes may range in complexity from modifications of a few selected application parameters to concerted changes of complex run-time program states. The time-scale of these changes can vary from rapid modifications to the implementation of single program abstractions (e.g., a single mutex lock in a parallel code <ref> [40] </ref>) to the occasional modification of program attributes by end users (e.g., load balancing in a large-scale scientific code as described in Section 2.2 2 below).
Reference: [41] <author> D. M. Ogle, K. Schwan, and R. Snodgrass. </author> <title> Application-dependent dynamic monitoring of distributed and parallel systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(7) </volume> <pages> 762-778, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Analyses may employ statistical methods, boolean operators like those described in <ref> [41] </ref>, or simply reorder the events being received. Graphical views may be displayed with multiple media or systems, currently including X windows, Motif, and the SGI Explorer environment. <p> Future work should address compiler and user interface support for this task, as well as additional functionality in the stub compiler to generate alternative stub implementations <ref> [41] </ref>. 11 information. Further analysis of the trace information is performed before it is displayed to end users or used in steering algorithms. Trace information can also be stored in trace files for postmortem analysis. <p> These hooks are implemented such that their presence in `disabled' mode has no performance effects on the target program. The use of such techniques with Falcon would further improve system performance. The topic of application-specific program monitoring has been addressed previously by Snodgrass and in our own research <ref> [45, 41] </ref>. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [41, 25], some of which are based on the Entity-Relational model [45]. We are only now beginning to add `view'-level specifications to the Falcon system. Data and perturbation analysis. <p> The use of such techniques with Falcon would further improve system performance. The topic of application-specific program monitoring has been addressed previously by Snodgrass and in our own research [45, 41]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages <ref> [41, 25] </ref>, some of which are based on the Entity-Relational model [45]. We are only now beginning to add `view'-level specifications to the Falcon system. Data and perturbation analysis. <p> We are now generalizing the notion of sensors to permit programmers to specify higher level `views' of monitoring data like those described in <ref> [41, 45] </ref>. Such views will be implemented with library support resident in both local and central monitors. The resulting higher level abstractions presented by views to end users should be helpful in permitting them to both understand program behavior and to design suitable steering algorithms.
Reference: [42] <author> Daniel A. Reed, Ruth A. Aydt, Roger J. Noe, Keith A. Shields, and Bradley W. Schwartz. </author> <title> An Overview of the Pablo Performance Analysis Environment. </title> <institution> Department of Computer Science, University of Illinois, </institution> <address> 1304 West Springfield Avenue, Urbana, Illinois 61801, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: This distinguishes our work from related research on performance monitoring and tuning, including that of Reed <ref> [42] </ref> and Miller [21], both of which generally address the issue of performance debugging using program traces stored in intermediate files. <p> identifies the limits on possible rates with which steering may be performed due to minimum monitoring, decision making, and enactment delays implied by the library's implementation. 3.5 Falcon's On-line Display System Graphical displays have been shown useful in presenting data structures, algorithms [46], runtime program behavior [31], and performance information <ref> [19, 42] </ref> to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information. Instead, Falcon supports the on-line use of displays to help users understand a target program's performance and runtime behavior, as well as to interactively steer their parallel codes. <p> As a result, trace-file based monitoring systems <ref> [42] </ref> sort such files prior to displaying the events they contain. For on-line monitoring, it must be possible to construct and then include with the event stream temporary event storage and reordering routines. Such analyses are performed in the event reordering filter constructed for the thread life-time view. <p> Program monitoring. Past work addressing the monitoring of parallel and distributed programs has typically focussed on performance understanding and debugging. These performance monitoring systems (e.g.Miller's IPS [36] and IPS-2 [35], Reed's Pablo <ref> [42] </ref>) provide programmers with execution information about their parallel codes and lead their attention to those program components on which most execution time is spent.
Reference: [43] <author> Karsten Schwan, Prabha Gopinath, </author> <title> and Win Bo. CHAOS kernel support for objects in the real-time domain. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):904-916, </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: Other examples of the utility of program steering include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems and the load balancing or program configuration for enhanced reliability in distributed systems <ref> [29, 43, 33] </ref>. Many of the research results listed above concern performance improvements attained by program steering. It is more difficult to demonstrate enhanced utility via steering, especially when such promises are based on expected increases in the effectiveness of end users.
Reference: [44] <author> Karsten Schwan, Rajiv Ramnath, Sridhar Vasudevan, and David Ogle. </author> <title> A language and system for the construction and timing of parallel programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(4) </volume> <pages> 455-471, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Concerning the first requirement, in MD, domains are represented in such a way that their boundaries are easily shifted to permit steering for improved workload balance. In general, however, programs can be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support <ref> [44] </ref>, or by requiring that the programming language offer stronger mechanisms of abstraction than those existing 8 in parallel Fortran or in the Cthreads library used in our work (e.g., the object model [5, 10, 29, 13]). <p> Early work in this research area focuses on the dynamic adjustment of parallel and real-time applications in order to adapt them to different execution environments <ref> [44] </ref>. More recent experiments demonstrate that changes to specific program states or program components, such as locks [39] and problem partition boundaries [8], can significantly improve overall program performance.
Reference: [45] <author> Richard Snodgrass. </author> <title> A relational approach to monitoring complex systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(2) </volume> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: These hooks are implemented such that their presence in `disabled' mode has no performance effects on the target program. The use of such techniques with Falcon would further improve system performance. The topic of application-specific program monitoring has been addressed previously by Snodgrass and in our own research <ref> [45, 41] </ref>. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [41, 25], some of which are based on the Entity-Relational model [45]. We are only now beginning to add `view'-level specifications to the Falcon system. Data and perturbation analysis. <p> The topic of application-specific program monitoring has been addressed previously by Snodgrass and in our own research [45, 41]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [41, 25], some of which are based on the Entity-Relational model <ref> [45] </ref>. We are only now beginning to add `view'-level specifications to the Falcon system. Data and perturbation analysis. Monitoring information may be refined with trace data analysis techniques, such as the Critical Path Analysis and Phase Behavior Analysis described in [35]. <p> We are now generalizing the notion of sensors to permit programmers to specify higher level `views' of monitoring data like those described in <ref> [41, 45] </ref>. Such views will be implemented with library support resident in both local and central monitors. The resulting higher level abstractions presented by views to end users should be helpful in permitting them to both understand program behavior and to design suitable steering algorithms.
Reference: [46] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: It also identifies the limits on possible rates with which steering may be performed due to minimum monitoring, decision making, and enactment delays implied by the library's implementation. 3.5 Falcon's On-line Display System Graphical displays have been shown useful in presenting data structures, algorithms <ref> [46] </ref>, runtime program behavior [31], and performance information [19, 42] to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information.
Reference: [47] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <type> Technical Report GIT-GVU-92-10, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: General methods for supporting performance understanding in program animation systems are described in <ref> [27, 47] </ref>. In Falcon, monitoring information captured for use by on-line displays may be analyzed at several different sites, including in extended sensors, local monitors, the central monitor, and in additional analysis packages interposed between central monitor and displays. <p> For on-line monitoring, it must be possible to construct and then include with the event stream temporary event storage and reordering routines. Such analyses are performed in the event reordering filter constructed for the thread life-time view. Its implementation and use for performance understanding are discussed in detail elsewhere <ref> [27, 47, 15] </ref>. To summarize, Falcon supports the on-line display of captured program information in two ways: (1) by permitting the placement of necessary analysis code at any level of its event capture hierarchy and (2) by facilitating the attachment of multiple performance-relevant and application-specific displays to captured event streams.
Reference: [48] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Specifically, Falcon offers several default on-line graphical animations of the performance of threads-based parallel program (see [15]). In addition, Falcon uses the Polka system for program animation which provides users with easy-to-use tools for creating application-specific 2D animations of arbitrary program attributes <ref> [48] </ref>. <p> In contrast, the central monitoring is typically located on a front end workstation or on a processor providing user interface functionality. Falcon uses the Polka system for the construction and use of graphical displays of program information <ref> [48] </ref>. Several performance or functional views (e.g., the bar-graphs in Figure 2) have been built with this tool. <p> A version of Falcon currently being completed also works with PVM across networked execution platforms, including the IBM SP-2 machine. Similar portability is attained for the graphical displays used with Falcon. Notably, the Polka animation library can be executed on any Unix platform on which Motif is available <ref> [48] </ref>. Falcon's low-level mechanisms are available via the Internet since early Summer 1994. A version of Falcon offering on-line user interfaces for monitoring and monitor control will be released in 1995.
Reference: [49] <author> T. K. Xia, Jian Ouyang, M. W. Ribarsky, and Uzi Landman. </author> <title> Interfacial alkane films. </title> <journal> Physical Review Letters, </journal> <volume> 69(13) </volume> <pages> 1967-1970, </pages> <month> 28 September </month> <year> 1992. </year> <month> 43 </month>
Reference-contexts: These requirements form one basis on which Falcon's functionality is evaluated. 2.1 The MD Application MD is an interactive molecular dynamics simulation developed at Georgia Tech in cooperation with a group of physicists exploring the statistical mechanics of complex liquids <ref> [49, 8] </ref>. In this paper, we consider a physical system which contains 4800 particles representing an alkane film and 2700 particles in a crystalline base on which the film is layered.
References-found: 49

