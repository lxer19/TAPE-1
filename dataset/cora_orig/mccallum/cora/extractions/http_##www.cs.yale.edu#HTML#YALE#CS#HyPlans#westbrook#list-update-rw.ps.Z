URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/list-update-rw.ps.Z
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/westbrook/
Root-URL: http://www.cs.yale.edu
Title: Off-line Algorithms for The List Update Problem  
Author: Nick Reingold Jeffery Westbrook 
Date: October 16, 1995  
Address: P.O. Box 636 Murray Hill, NJ 07974-0636.  New Haven, CT 06520-2158.  
Affiliation: AT&T Bell Laboratories  Department of Computer Science Yale University  
Abstract: Optimum off-line algorithms for the list update problem are investigated. The list update problem involves implementing a dictionary of items as a linear list. Several characterizations of optimum algorithms are given; these lead to an implementation of an optimum algorithm which runs in time O(2 n n!m), where n is the length of the list and m is the number or requests. The previous best algorithm runs in time O((n!) 2 m) [4]. Off-line algorithms for list update are useful in the study of competitive on-line algo rithms.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Bentley and C. C. McGeoch. </author> <title> Amortized analyses of self-organizing sequential search heuristics. </title> <journal> Commun. ACM, </journal> <volume> 28(4) </volume> <pages> 404-411, </pages> <month> Apr. </month> <year> 1985. </year>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions.
Reference: [2] <author> P. J. Burville and J. F. C. Kingman. </author> <title> On a model for storage and search. </title> <journal> Journal of Applied Probability, </journal> <volume> 10 </volume> <pages> 697-701, </pages> <year> 1973. </year>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions.
Reference: [3] <author> W. J. Hendricks. </author> <title> An account of self-organizing systems. </title> <journal> SIAM J. Comput., </journal> <volume> 5(4) </volume> <pages> 715-723, </pages> <month> Dec. </month> <year> 1976. </year>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions.
Reference: [4] <author> M. Manasse, L. A. McGeoch, and D. Sleator. </author> <title> Competitive algorithms for on-line problems. </title> <booktitle> In Proc. 20th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 322-333, </pages> <year> 1988. </year>
Reference-contexts: The previous best algorithm to compute the optimum cost for the list update problem was an adaptation of an algorithm of Manasse, McGeoch, and Sleator <ref> [4] </ref> which runs in time fi (m (n!) 2 ), and space fi (n!), where m is the number of requests and n is the number of items in the list. <p> We assume contains only access requests. Let n be the length of the list and m be the number of accesses in . 5 In <ref> [4] </ref>, Manasse, McGeoch, and Sleator discuss task systems, of which list update is a special case. They give a dynamic programming algorithm for finding the minimal cost to service a request sequence in any task system. <p> At n = 7, for example, there are approximately ninety-two thousand probes of the DYN (l; i) table per request. For comparison, at n = 7 the simple dynamic programming algorithm derived from Manasse et al. <ref> [4] </ref> does approximately twenty-five million probes per request. We leave open, however, the problem of finding an algorithm that is polynomial in both n and m, or conversely showing that such an algorithm is unlikely or impossible.
Reference: [5] <author> J. McCabe. </author> <title> On serial files with relocatable records. </title> <journal> Operations Research, </journal> <volume> 13 </volume> <pages> 609-618, </pages> <year> 1965. </year>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions.
Reference: [6] <author> N. Reingold, J. Westbrook, and D. D. Sleator. </author> <title> Randomized algorithms for the list update problem. </title> <journal> Algorithmica, </journal> <volume> 11 </volume> <pages> 15-32, </pages> <year> 1994. </year>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions. <p> This research is also motivated by practical uses, since to perform empirical studies of the competitiveness of on-line algorithms for list-update it is necessary to have an optimum or even near-optimum off-line algorithm to compare against. Furthermore, the results presented here have been used in <ref> [6] </ref> to find lower bounds on the competitiveness of randomized on-line algorithms for list update. One simple off-line algorithm is to initially order the items by decreasing frequency of access, and after that make no rearrangements. This is the optimum static rule.
Reference: [7] <author> R. Rivest. </author> <title> On self-organizing sequential search heuristics. </title> <journal> Commun. ACM, </journal> <volume> 19(2) </volume> <pages> 63-67, </pages> <month> February </month> <year> 1976. </year> <month> 12 </month>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions.
Reference: [8] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Amortized efficiency of list update and paging rules. </title> <journal> Commun. ACM, </journal> <volume> 28(2) </volume> <pages> 202-208, </pages> <year> 1985. </year> <month> 13 </month>
Reference-contexts: On the other hand, performing a rearrangement may itself be costly. Finding an algorithm to rearrange the items most effectively is an interesting and difficult problem. This problem, called the list update problem, has been investigated by many researchers <ref> [1, 2, 3, 5, 7, 8, 6] </ref>. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis [8]. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions. <p> This problem, called the list update problem, has been investigated by many researchers [1, 2, 3, 5, 7, 8, 6]. It is distinguished by being one of the two problems in Sleator and Tarjan's seminal paper on competitive analysis <ref> [8] </ref>. A list update algorithm takes a request sequence and determines rearrangements to be done between accesses, deletions, or insertions. <p> Thus we still leave open the problem of finding an algorithm that is polynomial in n and m, or proving that the problem is NP-Hard. This paper is organized as follows. Section 2 contains a formal description of the list update model as defined by Sleator and Tarjan <ref> [8] </ref>. We show one simplification that can be made to the model. We also give a counter-example to a theorem of Sleator and Tarjan from [8], showing that their theorem is incorrect. Sections 3 and 5 contains various theorems about the characteristics of optimum algorithms. <p> This paper is organized as follows. Section 2 contains a formal description of the list update model as defined by Sleator and Tarjan <ref> [8] </ref>. We show one simplification that can be made to the model. We also give a counter-example to a theorem of Sleator and Tarjan from [8], showing that their theorem is incorrect. Sections 3 and 5 contains various theorems about the characteristics of optimum algorithms. <p> A deletion is done by searching for the item and then removing it. At any time, the algorithm may exchange the position of any two adjacent items in the list. Each request or exchange has a cost. In the standard model defined by Sleator and Tarjan <ref> [8] </ref> the costs are as follows: 1. An access or deletion of the i th item in the list costs i. An insertion costs n + 1, where n is the length of the list prior to the insertion. 2. <p> Accesses, insertions, and deletions have the same cost as in the standard model. Most on-line algorithms in the standard model use only free exchanges, and it is tempting to conclude that with free exchanges available, paid exchanges should never be needed. Sleator and Tarjan claim (Theorem 3 of <ref> [8] </ref>) that in the standard model, there is a minimum cost off-line algorithm that uses only free exchanges. Unfortunately, their theorem is wrong.
References-found: 8

