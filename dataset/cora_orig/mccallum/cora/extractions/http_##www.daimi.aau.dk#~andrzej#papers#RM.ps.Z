URL: http://www.daimi.aau.dk/~andrzej/papers/RM.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Email: andrzej+@cs.cmu.edu  
Title: Representing Monads  
Author: Andrzej Filinski 
Address: Pittsburgh, PA 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We show that any monad whose unit and extension operations are expressible as purely functional terms can be embedded in a call-by-value language with "composable continuations". As part of the development, we extend Meyer and Wand's characterization of the relationship between continuation-passing and direct style to one for continuation-passing vs. general "monadic" style. We further show that the composable-continuations construct can itself be represented using ordinary, non-composable first-class continuations and a single piece of state. Thus, in the presence of two specific computational effects storage and escapes - any expressible monadic structure (e.g., nondetermin-ism as represented by the list monad) can be added as a purely definitional extension, without requiring a rein-terpretation of the whole language. The paper includes an implementation of the construction (in Standard ML with some New Jersey extensions) and several examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Third International Symposium on Programming Language Implementation and Logic Programming, number 528 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <address> Pas-sau, Germany, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: To emphasize the typing issues involved, we use the New Jersey dialect of Standard ML <ref> [1] </ref> as our concrete language, but the operational content should translate straightforwardly into Scheme as well (though instantiation to different mon-ads may be less convenient without a module facility).
Reference: [2] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: In the following, we will show that in fact any monadic effect whose definition is itself expressible in a functional language can be synthesized from just two "impure" constructs: first-class continuations and a 446 storage cell. In other words, a language like Scheme <ref> [2] </ref>, or ML with first-class continuations [5], is already "monadically complete" in the sense that any program expressible in the somewhat contorted monadic style can also can be written in direct style.
Reference: [3] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Abstracting control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: with Felleisen's prompt [6], whose #-notation we have adopted here; but shift differs from prompt's original companion control (or F) in that the continuation is not given control over 0 in the definition of S.) For more details on shift/reset and their relation to other notions of composable continuations, see <ref> [3, 4, 17, 33] </ref>. As with the monadic [], the operation # would typically be provided as a function on thunks rather than as a special form. <p> The trick is to view the CPS translation with continuation-composing definitions of shift and reset as a direct-style specification of a language (with as just another higher-order function), and obtain from it a proper continuation semantics using a new "meta-continuation" fl, as detailed in <ref> [3] </ref>. <p> in E) can be expressed directly as [let x 1 = (E 1 ) in . . . let x n = (E n ) in E] For example, we can compute the "cartesian product" of two lists as let open ListRep in reify (fn ()=&gt;let val x = reflect <ref> [3, 4, 5] </ref>; val y = reflect ["foo", "bar"] in (x,y) end) (* val it = [(3,"foo"),(3,"bar"),(4,"foo"),(4,"bar"), (5,"foo"),(5,"bar")]: (int * string) list *) Of course, this is probably not the most efficient way of implementing list comprehensions in ML. <p> A possible equivalence between monads and CPS was conjectured by Danvy and Filinski <ref> [3] </ref> and partially fleshed out by Wadler [32], but even the latter was quite informal since the result generalizes Meyer and Wand's, one would expect the proof to be at least as complicated. <p> Peyton Jones and 454 Wadler [18] probe the relationship between monads and CPS further, and Wadler [33] analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typability obscures the deeper connections. "Composable continuations" have also been studied by a number of researchers <ref> [10, 8, 3] </ref>. Many of these constructs depend on explicit support from the compiler or runtime system, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [26]. <p> In the composable-continuations characterization of monads, monad combination seems to correspond to also letting the target language of the defining translations contain monadic effects, leading to the hierarchy of control operators and the associated meta n -continuation-passing style introduced in <ref> [3] </ref> and further investigated by Murthy [17].
Reference: [4] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control: A study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: with Felleisen's prompt [6], whose #-notation we have adopted here; but shift differs from prompt's original companion control (or F) in that the continuation is not given control over 0 in the definition of S.) For more details on shift/reset and their relation to other notions of composable continuations, see <ref> [3, 4, 17, 33] </ref>. As with the monadic [], the operation # would typically be provided as a function on thunks rather than as a special form. <p> in E) can be expressed directly as [let x 1 = (E 1 ) in . . . let x n = (E n ) in E] For example, we can compute the "cartesian product" of two lists as let open ListRep in reify (fn ()=&gt;let val x = reflect <ref> [3, 4, 5] </ref>; val y = reflect ["foo", "bar"] in (x,y) end) (* val it = [(3,"foo"),(3,"bar"),(4,"foo"),(4,"bar"), (5,"foo"),(5,"bar")]: (int * string) list *) Of course, this is probably not the most efficient way of implementing list comprehensions in ML.
Reference: [5] <author> Bruce F. Duba, Robert Harper, and David Mac-Queen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Actually, many of the useful monadic effects that are not already included can be defined in terms of existing concepts in typical eager functional languages. For example, backtracking can be expressed with call=cc and an updatable stack of backtracking points <ref> [5] </ref>. Still, such implementations appear ad-hoc, require a thorough understanding of the imperative features used, and have no clear connection to the "pure" monadic abstractions they implement. <p> In the following, we will show that in fact any monadic effect whose definition is itself expressible in a functional language can be synthesized from just two "impure" constructs: first-class continuations and a 446 storage cell. In other words, a language like Scheme [2], or ML with first-class continuations <ref> [5] </ref>, is already "monadically complete" in the sense that any program expressible in the somewhat contorted monadic style can also can be written in direct style. <p> write let open Escape in 3 + escape (fn k=&gt;6 + coerce (k 1)) end; (* val it = 4 : int *) (The use of void and coerce instead of an unconstrained type variable in escape permits storage of continuations in ref-cells while staying within the ML type system <ref> [5] </ref>.) Now we can define a composable-continuations facil ity, parameterized by the type of final answers: signature CONTROL = sig type ans val reset : (unit -&gt; ans) -&gt; ans val shift : (('1a -&gt; ans) -&gt; ans) -&gt; '1a end; functor Control (type ans) : CONTROL = struct open Escape <p> in E) can be expressed directly as [let x 1 = (E 1 ) in . . . let x n = (E n ) in E] For example, we can compute the "cartesian product" of two lists as let open ListRep in reify (fn ()=&gt;let val x = reflect <ref> [3, 4, 5] </ref>; val y = reflect ["foo", "bar"] in (x,y) end) (* val it = [(3,"foo"),(3,"bar"),(4,"foo"),(4,"bar"), (5,"foo"),(5,"bar")]: (int * string) list *) Of course, this is probably not the most efficient way of implementing list comprehensions in ML.
Reference: [6] <author> Matthias Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <address> San Diego, Cali-fornia, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: For example: 1 + #(2 fi S (k: k (k 10))) (For our purposes, reset coincides with Felleisen's prompt <ref> [6] </ref>, whose #-notation we have adopted here; but shift differs from prompt's original companion control (or F) in that the continuation is not given control over 0 in the definition of S.) For more details on shift/reset and their relation to other notions of composable continuations, see [3, 4, 17, 33].
Reference: [7] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103(2) </volume> <pages> 235-271, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Perhaps the connections outlined in this paper can lead to some cross-fertilization and help avoid duplication of effort. For example, "pure" functional programmers might benefit from work on organizing and reasoning about first-class continuations and storage cells in the "imperative" setting (e.g., <ref> [7] </ref>); noting that these are monadic effects is clearly not sufficient to actually reason about them. Conversely, results about algebraic properties of particular monads (e.g., [11]) could be useful for recognizing and exploiting patterns of continuation and state usage in eager languages.
Reference: [8] <author> Matthias Felleisen, Mitchell Wand, Daniel P. Fried-man, and Bruce F. Duba. </author> <title> Abstract continuations: A mathematical semantics for handling full functional jumps. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 52-62, </pages> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: Peyton Jones and 454 Wadler [18] probe the relationship between monads and CPS further, and Wadler [33] analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typability obscures the deeper connections. "Composable continuations" have also been studied by a number of researchers <ref> [10, 8, 3] </ref>. Many of these constructs depend on explicit support from the compiler or runtime system, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [26].
Reference: [9] <author> Robert Hieb, R. Kent Dybvig, and Carl Brugge-man. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, Lawall and Danvy are investigating applications of composable continuations for continuation-based partial evaluation [12]; preliminary results indicate that using the embedded shift/reset instead of an explicit CPS transformation step can give significant improvements in time and in space, when run under an efficient implementation of call=cc <ref> [9] </ref>. 5 Implementation and Examples In this section we transcribe the abstract construction presented so far into runnable code.
Reference: [10] <author> Gregory F. Johnson and Dominic Duggan. </author> <title> Stores and partial continuations as first-class objects in a language and its environment. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 158-168, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Peyton Jones and 454 Wadler [18] probe the relationship between monads and CPS further, and Wadler [33] analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typability obscures the deeper connections. "Composable continuations" have also been studied by a number of researchers <ref> [10, 8, 3] </ref>. Many of these constructs depend on explicit support from the compiler or runtime system, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [26].
Reference: [11] <author> David J. King and Philip Wadler. </author> <title> Combining monads. </title> <editor> In J. Launchbury and P. M. Sansom, editors, </editor> <booktitle> Functional Programming, Glasgow 1992, </booktitle> <pages> pages 134-143, </pages> <address> Ayr, Scotland, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For example, "pure" functional programmers might benefit from work on organizing and reasoning about first-class continuations and storage cells in the "imperative" setting (e.g., [7]); noting that these are monadic effects is clearly not sufficient to actually reason about them. Conversely, results about algebraic properties of particular monads (e.g., <ref> [11] </ref>) could be useful for recognizing and exploiting patterns of continuation and state usage in eager languages.
Reference: [12] <author> Julia L. Lawall and Olivier Danvy. </author> <title> Continuation-based partial evaluation. </title> <institution> Indiana University and Aarhus University. </institution> <type> Personal communication, </type> <month> Octo-ber </month> <year> 1993. </year>
Reference-contexts: Incidentally, the above definitions of shift and reset in terms of call=cc and and state could well have practical applications unrelated to monads. For example, Lawall and Danvy are investigating applications of composable continuations for continuation-based partial evaluation <ref> [12] </ref>; preliminary results indicate that using the embedded shift/reset instead of an explicit CPS transformation step can give significant improvements in time and in space, when run under an efficient implementation of call=cc [9]. 5 Implementation and Examples In this section we transcribe the abstract construction presented so far into runnable
Reference: [13] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda-calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs Proceedings, number 193 in Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224, </pages> <address> Brooklyn, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: We then relate the two translations, generalizing the results of Meyer and Wand <ref> [13] </ref> about the typed CPS transform: their method can be seen as covering the particular case where T is the identity monad (i.e., T ff = ff, j = id , and f fl = f ). 2.1 The monadic translation The monadic translation transforms an object-language term E with free
Reference: [14] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Pacific Grove, California, </address> <month> June </month> <year> 1989. </year> <journal> IEEE. </journal> <volume> 456 </volume>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. <ref> [14, 16] </ref>, they were quickly popularized by Wadler and others as a technique for structuring functional programs [32, 18]. It is not hard to see the reason for this popularity: monads promise access to state, control operators, I/O, etc., while retaining the strong reasoning principles valid for pure functional languages. <p> will be performing.) The operations are required to satisfy three monad laws: j fl = id T ff (f fl ffi g) = f fl ffi g fl Monads can be used to give a semantics of various "computational effects" (such as state, exceptions, or I/O) in applicative programming languages <ref> [14, 16] </ref>. In particular, our development is set in a simple call-by-value (CBV) functional language based on "Moggi's principle": Computations of type ff correspond to values of type T ff. <p> The term translation is given by [[x]] T = j x [[E 1 E 2 ]] T = (f: f fl [[E 2 ]] T ) [[E 1 ]] T [[[E]]] T = j [[E]] T (where the last two, perhaps less familiar-looking, equations are taken from Moggi <ref> [14] </ref>.) As an example of monadic reasoning, let us quickly check that the monad laws verify the correspondence principle for [] and (): [[([E])]] T = id [[[E]]] T = id (j [[E]] T ) Conversely, taking x as a representative value (the other cases are analogous): [[[(x)]]] T = j <p> Another glimmer of the correspondence can be seen in Sabry and Felleisen's result [24] that fij-equivalence of CPS terms coincides with direct-style equivalence in Moggi's computational -calculus <ref> [14] </ref>, which captures exactly the equivalences that hold in the presence of arbitrary monadic effects.
Reference: [15] <author> Eugenio Moggi. </author> <title> An abstract view of program-ming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, Scot-land, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: How to do this uniformly is still not quite clear; Moggi's monad constructors <ref> [15] </ref> and Steele's pseudomonads [29] are two possible techniques.
Reference: [16] <author> Eugenio Moggi. </author> <title> Notions of computation and mon-ads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. <ref> [14, 16] </ref>, they were quickly popularized by Wadler and others as a technique for structuring functional programs [32, 18]. It is not hard to see the reason for this popularity: monads promise access to state, control operators, I/O, etc., while retaining the strong reasoning principles valid for pure functional languages. <p> will be performing.) The operations are required to satisfy three monad laws: j fl = id T ff (f fl ffi g) = f fl ffi g fl Monads can be used to give a semantics of various "computational effects" (such as state, exceptions, or I/O) in applicative programming languages <ref> [14, 16] </ref>. In particular, our development is set in a simple call-by-value (CBV) functional language based on "Moggi's principle": Computations of type ff correspond to values of type T ff. <p> More generally, using the above and the first half of the theorem, we get a monadic congruence result: k fl [[E]] T = [[E]] K fOE ff g (k ffi fi ) For example, in the case of the partiality monad <ref> [16] </ref>, T ff = ff ] f?g, with k fl as the strict extension of k (i.e., k fl a = k a for a 2 ff; k fl ? = ?), we recover the usual restriction [25] that the continuation be strict to get a congruence; the monadic characterization generalizes
Reference: [17] <author> Chetan R. Murthy. </author> <title> Control operators, hierarchies, and pseudo-classical type systems: A-translation at work. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Continuations, </booktitle> <pages> pages 49-71, </pages> <address> San Fran-cisco, California, </address> <month> June </month> <year> 1992. </year> <type> (Technical Report No. </type> <institution> STAN-CS-92-1426, Department of Computer Science, Stanford University). </institution>
Reference-contexts: with Felleisen's prompt [6], whose #-notation we have adopted here; but shift differs from prompt's original companion control (or F) in that the continuation is not given control over 0 in the definition of S.) For more details on shift/reset and their relation to other notions of composable continuations, see <ref> [3, 4, 17, 33] </ref>. As with the monadic [], the operation # would typically be provided as a function on thunks rather than as a special form. <p> In the composable-continuations characterization of monads, monad combination seems to correspond to also letting the target language of the defining translations contain monadic effects, leading to the hierarchy of control operators and the associated meta n -continuation-passing style introduced in [3] and further investigated by Murthy <ref> [17] </ref>.
Reference: [18] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. [14, 16], they were quickly popularized by Wadler and others as a technique for structuring functional programs <ref> [32, 18] </ref>. It is not hard to see the reason for this popularity: monads promise access to state, control operators, I/O, etc., while retaining the strong reasoning principles valid for pure functional languages. <p> Another glimmer of the correspondence can be seen in Sabry and Felleisen's result [24] that fij-equivalence of CPS terms coincides with direct-style equivalence in Moggi's computational -calculus [14], which captures exactly the equivalences that hold in the presence of arbitrary monadic effects. Peyton Jones and 454 Wadler <ref> [18] </ref> probe the relationship between monads and CPS further, and Wadler [33] analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typability obscures the deeper connections. "Composable continuations" have also been studied by a number of researchers [10, 8, 3].
Reference: [19] <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(2) </volume> <pages> 125-159, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: where the term translation is given by [[x]] K = k: k x [[E 1 E 2 ]] K = k: [[E 1 ]] K (f: [[E 2 ]] K (a: f a k)) [[[E]]] K = k: k ([[E]] K j) The first three equations are the usual ones <ref> [19] </ref>.
Reference: [20] <author> Christian Queinnec and Bernard Serpette. </author> <title> A dynamic extent control operator for partial continuations. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-184, </pages> <address> Orlando, Florida, </address> <month> Jan-uary </month> <year> 1991. </year>
Reference-contexts: The embedding is fairly complex, relying on dynamically-allocated, mutable data structures, eq?-tests, and with no direct connection to a formal semantics of the constructs. Yet another Scheme-implementable notion of partial continuations was proposed by Queinnec and Serpette <ref> [20] </ref>; the code required is perhaps even more intricate. (To be fair, both of these constructs are apparently more general than shift/reset, though the practical utility of this additional power remains to be seen.) The much simpler construction presented in this paper uses only a single cell holding a continuation, and
Reference: [21] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: In fact, it might be that the syntactic "noise" due to writing everything in monadic (or any other) style makes it harder to recognize and exploit organizational units that do not conveniently fit into the monadic mold (for example, concurrency packages like Reppy's CML <ref> [21] </ref>, or "imperative unification" using mutable data structures). The present work also sheds some light on the problem of integrating individual monads to express composite effects.
Reference: [22] <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <editor> In Jacques Loeckx, editor, </editor> <booktitle> 2nd Colloquium on Automata, Languages and Programming, number 14 in Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156, </pages> <address> Saarbrucken, West Germany, </address> <month> July </month> <year> 1974. </year>
Reference-contexts: To get a simple relationship between the two translations, we assume o to contain all denotable values <ref> [22] </ref> (note that such an o does not have to be a type expressible in the source language). 1 Fur ther, to avoid clutter in the term equations, we omit injections into and projections from o. <p> Early investigations <ref> [22, 25, 30] </ref> were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results seem closely tied to specific semantic models.
Reference: [23] <author> Jon G. Riecke. </author> <title> Delimiting the scope of effects. </title> <booktitle> In Functional Programming Languages and Computer Architecture 1993, </booktitle> <pages> pages 146-155, </pages> <address> Copen-hagen, Denmark, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Finally, recent work by Riecke <ref> [23] </ref> on effect delimiters may be somehow related to the present paper, as they share several concepts and techniques (specifically, mon-ads, prompts, and retractions).
Reference: [24] <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 288-298, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year> <note> Revised version to appear in Lisp and Symbolic Computation. </note>
Reference-contexts: Another glimmer of the correspondence can be seen in Sabry and Felleisen's result <ref> [24] </ref> that fij-equivalence of CPS terms coincides with direct-style equivalence in Moggi's computational -calculus [14], which captures exactly the equivalences that hold in the presence of arbitrary monadic effects.
Reference: [25] <author> Ravi Sethi and Adrian Tang. </author> <title> Constructing call-by-value continuation semantics. </title> <journal> Journal of the ACM, </journal> <volume> 27(3) </volume> <pages> 580-597, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: (k ffi fi ) For example, in the case of the partiality monad [16], T ff = ff ] f?g, with k fl as the strict extension of k (i.e., k fl a = k a for a 2 ff; k fl ? = ?), we recover the usual restriction <ref> [25] </ref> that the continuation be strict to get a congruence; the monadic characterization generalizes this requirement to other computational effects. <p> Early investigations <ref> [22, 25, 30] </ref> were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results seem closely tied to specific semantic models.
Reference: [26] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Control de-limiters and their hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 67-99, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Many of these constructs depend on explicit support from the compiler or runtime system, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen <ref> [26] </ref>. The embedding is fairly complex, relying on dynamically-allocated, mutable data structures, eq?-tests, and with no direct connection to a formal semantics of the constructs.
Reference: [27] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 161-175, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Thus, we only need to define A and #. (That K, A, and # together suffice for defining all "pure" CPS 451 terms in a domain-theoretic setting was already noted by Sitaram and Felleisen <ref> [27] </ref>).
Reference: [28] <author> Brian C. Smith. </author> <title> Reflection and Semantics in a Procedural Language. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1982. </year> <month> MIT-LCS-TR-272. </month>
Reference-contexts: As also noted by Moggi, the correspondence principle can be embodied in an "introspective" language extension which could be called monadic reflection (by analogy to computational reflection <ref> [28, 34] </ref>), given by two operators: ` E : T ff and ` [E] : T ff For any E : T ff, (E) reflects the value of E as an "effectful" computation of type ff.
Reference: [29] <author> Guy L. Steele, Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proceedings of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year> <note> (To appear). </note>
Reference-contexts: How to do this uniformly is still not quite clear; Moggi's monad constructors [15] and Steele's pseudomonads <ref> [29] </ref> are two possible techniques.
Reference: [30] <author> Joseph E. Stoy. </author> <title> The congruence of two programming language definitions. </title> <journal> Theoretical Computer Science, </journal> <volume> 13(2) </volume> <pages> 151-174, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: Early investigations <ref> [22, 25, 30] </ref> were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results seem closely tied to specific semantic models.
Reference: [31] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 461-493, </pages> <month> December </month> <year> 1992. </year> <note> (An earlier version appeared in Proceedings of the 1990 ACM Conference on Lisp and Functional Programming </note> ). 
Reference-contexts: The only aspect that would seem missing is the ability for programmers to use their own, application-specific monadic abstractions such as nondeterminism or parsers <ref> [31] </ref> - with the same ease and naturality as built-in effects. Actually, many of the useful monadic effects that are not already included can be defined in terms of existing concepts in typical eager functional languages. <p> As observed by Wadler <ref> [31] </ref>, however, list comprehensions can be generalized to arbitrary monads; similarly we get general monad comprehensions in ML simply by supplying the appropriate [] and () operations. 5.6 Example: continuations Finally, let us consider the continuation monad (for an arbitrary but fixed answer type): functor ContMonad (type answer) : MONAD =
Reference: [32] <author> Philip Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Al-buquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. [14, 16], they were quickly popularized by Wadler and others as a technique for structuring functional programs <ref> [32, 18] </ref>. It is not hard to see the reason for this popularity: monads promise access to state, control operators, I/O, etc., while retaining the strong reasoning principles valid for pure functional languages. <p> The translation on types looks similar: [[]] K = [[T ff]] K = T [[ff]] K where Kfl = (fl !T o) !T o for a type o of final answers. (The key idea of making T o the "new" answer type is due to Wadler <ref> [32] </ref>). <p> We also give several examples; the reader may want to compare these with Wadler's presentation <ref> [32] </ref>. 5.1 Composable continuations In SML/NJ, first-class continuations have a type distinct from the type of general procedures. <p> A possible equivalence between monads and CPS was conjectured by Danvy and Filinski [3] and partially fleshed out by Wadler <ref> [32] </ref>, but even the latter was quite informal since the result generalizes Meyer and Wand's, one would expect the proof to be at least as complicated.
Reference: [33] <author> Philip Wadler. </author> <title> Monads and composable continuations. </title> <booktitle> Lisp and Symbolic Computation, </booktitle> <year> 1994. </year> <note> (To appear). </note>
Reference-contexts: with Felleisen's prompt [6], whose #-notation we have adopted here; but shift differs from prompt's original companion control (or F) in that the continuation is not given control over 0 in the definition of S.) For more details on shift/reset and their relation to other notions of composable continuations, see <ref> [3, 4, 17, 33] </ref>. As with the monadic [], the operation # would typically be provided as a function on thunks rather than as a special form. <p> Peyton Jones and 454 Wadler [18] probe the relationship between monads and CPS further, and Wadler <ref> [33] </ref> analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typability obscures the deeper connections. "Composable continuations" have also been studied by a number of researchers [10, 8, 3].
Reference: [34] <author> Mitchell Wand and Daniel P. Friedman. </author> <title> The mystery of the tower revealed: A non-reflective description of the reflective tower. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1), </volume> <month> May </month> <year> 1988. </year> <month> 457 </month>
Reference-contexts: As also noted by Moggi, the correspondence principle can be embodied in an "introspective" language extension which could be called monadic reflection (by analogy to computational reflection <ref> [28, 34] </ref>), given by two operators: ` E : T ff and ` [E] : T ff For any E : T ff, (E) reflects the value of E as an "effectful" computation of type ff.
References-found: 34

