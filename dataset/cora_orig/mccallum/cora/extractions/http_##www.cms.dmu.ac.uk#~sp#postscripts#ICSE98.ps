URL: http://www.cms.dmu.ac.uk/~sp/postscripts/ICSE98.ps
Refering-URL: http://www.cms.dmu.ac.uk:80/~sp/
Root-URL: 
Email: email:sp@dmu.ac.uk  email: luker@dmu.ac.uk  email: zedan@dmu.ac.uk  
Title: A Template for Design Transform Specification  
Author: Sagar Pidaparthi Paul Luker Hussein Zedan 
Keyword: Reengineering, design transformations, object-oriented design, black box design, glass box design, Transformation, Translation.  
Address: LE1 9BH  LE1 9BH  LE1 9BH  
Affiliation: School of Computing Sciences, DeMontfort University, Leicester, UK,  School of Computing Sciences, DeMontfort University, Leicester, UK,  School of Computing Sciences, DeMontfort University, Leicester, UK,  
Abstract: Migration from a procedural architecture to an object-oriented architecture is possible through an appropriate sequence of design transformations. This paper initially provides a conceptual foundation for migration from a procedural to an objectoriented software architecture for legacy software, which relies upon a view of the software life cycle, in which all software development is considered to be an evolutionary activity wherein re-engineering/restructuring is an important process applied repeatedly on the artefacts of development at various stages in this evolution. We then introduce a novel approach of viewing a procedural program from an objectoriented perspective in which there is a single god class which has a large number of global variables and methods, supported by several user-defined classes which have no behaviour, only data definitions. This view, coupled with repeated restructuring, enables a seamless migration of behaviour from the god class to other classes using design transformation methods. There is a distinction between the processes of translation and transformation, processes that we contend are orthogonal to each other, which thereby enables us to concentrate on behaviour-preserving design transformations in order to migrate from one design to another, leaving the language issues to be handled by translators. Having established the need for behaviour-preserving design transformations, we provide a template for specifying design transformations. The main contribution of this paper is in the proposal of a template for the communication of design transformations. An example design transformation is presented which demonstrates the usefulness of the proposed template. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Booch, G., </author> <year> (1991), </year> <title> ObjectOriented Design with Applications, </title> <publisher> The Benjamin/ Cummings Publishing Company. </publisher>
Reference-contexts: The structured methodologies of the 1970s and 1980s supported linear design processes, which do not lend themselves well to evolutionary development. It is now commonly accepted that software design and development requires cyclic or iterative approaches in order to control evolution. Booch <ref> [1] </ref> proposes a life cycle in which there are two kinds of processes for software design, the macro design process and the micro design process. Each phase in the macro design process encompasses a complete iteration of a micro design processes. <p> Usually there is one component called the system, which controls the execution of the system. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical such as OMT [5], UML [6], or Booch <ref> [1] </ref>, or by using languages like Language for Object Oriented Modelling (LOOM)[7]. Alternatively they can be specified using formal languages like COLD-K [2,3,4] as in the Meteor Project.
Reference: 2. <author> Feijs, L. </author> <title> (1993) Formalisation of Design Methods, Ellis Horwood Series in Computers and their Applications. </title>
Reference: 3. <author> Feijs, L. And Jonkers, H.B.M. </author> <title> (1989) METEOR and beyond: industrialising formal methods, </title> <editor> In: K.H. Bennet (ED.) </editor> <booktitle> Software Engineering Environments: Research and Practice, </booktitle> <publisher> Ellis Horwood Limited, </publisher> <pages> pp. </pages> <month> 255-274.. </month>
Reference-contexts: However, it is important to note that the design transformations discussed by Feijs <ref> [3] </ref>, are at a very high level of abstraction and are not suitable for our purpose of migrating from procedural to objectoriented programs. COLD-K is used to specify the designs of software systems, for which it introduces the concepts of black box descriptions and glass box descriptions of software systems.
Reference: 4. <author> Bergstra, J.A., Heering, J., Klint,, </author> <title> P (1990) Module Algebra, </title> <journal> JACM Vol. </journal> <volume> 37 No 2 pp. </volume> <pages> 335-372. </pages>
Reference: 5. <author> Rumbaugh, J.,Blaha, M., Premerlani, W., Eddy, F., Lorensen, W., </author> <title> (1991)Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: Usually there is one component called the system, which controls the execution of the system. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical such as OMT <ref> [5] </ref>, UML [6], or Booch [1], or by using languages like Language for Object Oriented Modelling (LOOM)[7]. Alternatively they can be specified using formal languages like COLD-K [2,3,4] as in the Meteor Project.
Reference: 6. <institution> Unified Modelling Language, </institution> <note> Available at &lt;http:www.rational.com/ </note>
Reference-contexts: Usually there is one component called the system, which controls the execution of the system. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical such as OMT [5], UML <ref> [6] </ref>, or Booch [1], or by using languages like Language for Object Oriented Modelling (LOOM)[7]. Alternatively they can be specified using formal languages like COLD-K [2,3,4] as in the Meteor Project.
Reference: 7. <author> Barclay, K., Savage, J., </author> <year> (1996), </year> <title> Language for object Oriented modelling taken from Object Oriented Design with C++, </title> <publisher> Prentice Hall Publishers, pp35-75. </publisher>
Reference: 8. <author> Choi, S.C. and Scacchi, W., </author> <year> (1990), </year> <title> Extracting and Restructuring the design of large systems, </title> <journal> IEEE Software. </journal>
Reference: 9. <author> Chen, Y.F., Nishimoto, M.Y., Ramamoorthy, </author> <title> C.V.,(1990) The C Information Abstraction System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. </volume> <pages> 3. </pages>
Reference: 10. <author> Pidaparthi, S., </author> <title> (1994) Forward and Reverse Engineering CASE Tool Supporting Multiple Views for Software Development". </title> <institution> Internal Report for De Montfort University, Leicester, U.K. </institution>
Reference: 11. <author> Pidaparthi, S., Cysewski, </author> <title> G.,(1996) Migration to Object Oriented System Structure Using Design Transformation Methods, </title> <booktitle> Proceedings of The Fifth International Conference Information Systems Development ISD96.pp 555-571. </booktitle>
Reference: 12. <author> Pidaparthi, S, Cysewski, </author> <title> G.,(1997) Case Study in Migration to ObjectOriented System Structure Using Design Transformation Methods, </title> <booktitle> Proceedings of First Euro-Micro Working Conference on Software Maintenance and Reengineering, </booktitle> <address> 17-19,March, </address> <year> 1997. </year> <pages> pp 128-135. </pages>
Reference: 13. <author> Zedan, H., Pidaparthi, S., </author> <title> (1997) Formalisation of Design Transformations, </title> <institution> Internal Report for DeMontfort University, Leicester, U.K. </institution>
Reference: 14. <author> Gamma, E., Helm, R., Johnson, R., Vlissides., </author> <title> (1994) Design Patterns, </title> <publisher> Addison-Wesley Professional Computing Series. </publisher>
Reference-contexts: DESIGN TRANSFORMATION TEMPLATE Given below is a suitable adaptation of a template specified by Gamma et. al. <ref> [14] </ref> for pattern specification. <p> It is important to ensure that there is only a single instance of the variables defined by the super class as the god class originally had only a single instance of these global variables, accessible to all the members of the class. The proposed solution incorporates the singleton <ref> [14] </ref> design pattern. <p> Sample Code and Usage: Will be available on the web. Program Listing: Will be available on the web. Known Uses: To partition a god class and extract reusable classes. Related Transformations: Simple partition, partition with parameters, partitioning utility methods, partition with inheritance and singleton design pattern <ref> [14] </ref> Your Name (sp@dmu.ac.uk). Last updated on Monday, September 15, 1997 6. CONCLUSIONS The design transformations addressed in this paper are useful both for improving the architecture of object oriented systems and for facilitating the migration from legacy procedural software to objectoriented software. <p> The main contribution of this paper is in the proposal of a template for the communication of design transformations. This template is based on the template for the description of design patterns proposed by Gamma et. al <ref> [14] </ref>. There are many features of design transformations which are different from design patterns as might be expected owing to the fact that they are addressing two different foci of design.
Reference: 15. <author> Riel, A.J. </author> <year> (1997), </year> <title> ObjectOriented Design Heuristics. </title> <publisher> Addison-Wesley Professional Computing Series. </publisher>
Reference-contexts: The translated version of the program will have a large number of global variables and methods encapsulated by the major (system) class of the system called the god class <ref> [15] </ref>, while there will be several small classes, which represent the user-defined types of the procedural subject program. In effect, we can state that a procedural program is a badly designed objectoriented program with a single large god class in which all the program behaviour is centralised.
References-found: 15

