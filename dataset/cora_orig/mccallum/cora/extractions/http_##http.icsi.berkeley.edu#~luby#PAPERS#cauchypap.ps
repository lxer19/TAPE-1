URL: http://http.icsi.berkeley.edu/~luby/PAPERS/cauchypap.ps
Refering-URL: http://http.icsi.berkeley.edu/~luby/
Root-URL: http://http.icsi.berkeley.edu
Title: An XOR-Based Erasure-Resilient Coding Scheme  
Author: Johannes Blomer Malik Kalfane Richard Karp Marek Karpinski Michael Luby David Zuckerman k 
Abstract: An (m; n; b; r)-erasure-resilient coding scheme consists of an encoding algorithm and a decoding algorithm with the following properties. The encoding algorithm produces a set of n packets each containing b bits from a message of m packets containing b bits. The decoding algorithm is able to recover the message from any set of r packets. Erasure-resilient codes have been used to protect real-time traffic sent through packet based networks against packet losses. In this paper we describe a erasure-resilient coding scheme that is based on a version of Reed-Solomon codes and which has the property that r = m: Both the encoding and decoding algorithms run in quadratic time and have been customized to give the first real-time implementations of Priority Encoding Transmission (PET) [2],[1] for medium quality video transmission on Sun SPARCstation 20 workstations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Albanese, J. Blomer, J. Edmonds, M. Luby, M. Sudan, </author> <title> Priority Encoding Transmission, </title> <booktitle> in Proc. 35 th Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1994. </year> <pages> pp. 604-613. </pages>
Reference-contexts: Thus, it makes sense to protect real-time traffic sent through such networks against losses by adding a moderate level of redundancy using erasure-resilient codes. Algorithms based on this approach have been developed for applications such as multi casting real-time high-volume video information over lossy packet based networks <ref> [2, 1, 4] </ref> and other high volume real-time applications [8]. The two most important properties of fl International Computer Science Institute, Berkeley, California. <p> In this paper we show how to customize a version of Reed-Solomon codes so that it yields a (quadratic time) MDS code that runs in real-time for medium quality video transmission on existing workstations <ref> [2, 1] </ref>, i.e., at the rate of a few megabits per second. The version of Reed-Solomon codes we use is based on Cauchy matrices over finite fields (see for example [6] and [11]). Every square submatrix of a Cauchy matrix is invertible. <p> The corrupted packets are treated as being lost. In applications of erasure-resilient codes like robust data transfer on packet-based networks <ref> [1] </ref>, information dispersal [8], or secret sharing [10], this is a realistic assumption. An important subclass of error-correcting or erasure-resilient codes are linear codes. <p> The bound is significantly better than the bound shown in <ref> [1] </ref>. The bound almost matches the least possible packet size of the Cauchy-code and the XOR-code. For slightly better bounds for the case of special linear MDS codes see [6].
Reference: [2] <author> A. Albanese, J. Blomer, J. Edmonds, M. Luby, </author> <title> Priority Encoding Transmission, </title> <type> Technical Report TR-94-039, </type> <institution> International Computer Science Institute, Berkeley, </institution> <year> 1994. </year>
Reference-contexts: Thus, it makes sense to protect real-time traffic sent through such networks against losses by adding a moderate level of redundancy using erasure-resilient codes. Algorithms based on this approach have been developed for applications such as multi casting real-time high-volume video information over lossy packet based networks <ref> [2, 1, 4] </ref> and other high volume real-time applications [8]. The two most important properties of fl International Computer Science Institute, Berkeley, California. <p> In this paper we show how to customize a version of Reed-Solomon codes so that it yields a (quadratic time) MDS code that runs in real-time for medium quality video transmission on existing workstations <ref> [2, 1] </ref>, i.e., at the rate of a few megabits per second. The version of Reed-Solomon codes we use is based on Cauchy matrices over finite fields (see for example [6] and [11]). Every square submatrix of a Cauchy matrix is invertible. <p> However, the main gain compared to the method based on the evaluation and interpolation of polynomials is achieved by using a well-known representation of elements in finite fields of the form GF [2 L ] by (L fi L)-matrices over GF <ref> [2] </ref> (see [9]). This allows us to replace arithmetic operations on field elements by XOR's of computer words and in practice XOR's of computer words are much more efficient than multiplications in finite fields. The paper is organized as follows. <p> The main goal of this paper is to describe a systematic linear MDS code over GF <ref> [2] </ref> such that the time needed to decode a message M from m given encoding packets decreases 3 with the number of information packets among these encoding packets. <p> We first give an outline of the construction. 3 Outline of the XOR-Code The goal of this paper is to construct a systematic, linear erasure-resilient MDS code over GF <ref> [2] </ref>: As it turns out there is a general method to turn any systematic, linear code over a finite field GF [2 L ] with packet size b into a systematic, linear code over GF [2] with packet size b: This method is based on the fact that for each element <p> goal of this paper is to construct a systematic, linear erasure-resilient MDS code over GF <ref> [2] </ref>: As it turns out there is a general method to turn any systematic, linear code over a finite field GF [2 L ] with packet size b into a systematic, linear code over GF [2] with packet size b: This method is based on the fact that for each element of a finite field GF [2 L ] there is a representation as a column vector of length L over GF [2] and a representation as an (L fi L)-matrix over GF [2] such that <p> L ] with packet size b into a systematic, linear code over GF <ref> [2] </ref> with packet size b: This method is based on the fact that for each element of a finite field GF [2 L ] there is a representation as a column vector of length L over GF [2] and a representation as an (L fi L)-matrix over GF [2] such that the matrix-vector multiplication of the matrix representation of an element ff with the vector representation of an element fi yields the vector representation of the product fffi. <p> over GF <ref> [2] </ref> with packet size b: This method is based on the fact that for each element of a finite field GF [2 L ] there is a representation as a column vector of length L over GF [2] and a representation as an (L fi L)-matrix over GF [2] such that the matrix-vector multiplication of the matrix representation of an element ff with the vector representation of an element fi yields the vector representation of the product fffi. <p> Moreover, the addition of the vector or matrix representations of two elements ff and fi results in the vector or matrix representation of the sum ff + fi: This suggests the following method to transform a linear code over GF [2 L ] into a linear code over GF <ref> [2] </ref>: Replace each element in the generator matrix by its matrix representation to obtain the new generator matrix. Replace each field element in a message by its vector representation. <p> In our implementations we chose w to be 32; the word size on a Sun SPARCstation. For a code over GF <ref> [2] </ref>; a message of m packets is then considered to be an (mb fi 32)-matrix M over GF [2]. <p> In our implementations we chose w to be 32; the word size on a Sun SPARCstation. For a code over GF <ref> [2] </ref>; a message of m packets is then considered to be an (mb fi 32)-matrix M over GF [2]. Using the same generator matrix as in the single bit case, the encoding is now given by the matrix product of the generator matrix with M: Using this slight variation of the XOR-code, encoding a message of size 32m L bits requires m L coordinate-wise XOR's of 32-bit words. <p> In other words, if the number of segments in each packet is N we apply the code in parallel to N messages. 4 More formally, a message M consisting of m packets of size 32 L N is considered as a (mL fi 32N )-matrix over GF <ref> [2] </ref>. The encoding is obtained by multiplying this matrix by the generator matrix defining the original XOR-code. The j th packet of the encoding is given by the j th block of L consecutive rows of the resulting matrix. In this version the XOR-code has been implemented. <p> field of polynomials in GF <ref> [2] </ref>[X ] taken modulo p (X): Elements in GF [2 L ] can be identified with polynomials f (X ) = P L1 of degree at most L 1: The column vector (f 0 ; : : : ; f L1 ) t in GF [2] L will be called the coefficient vector of the element f (X ) = P L1 Construction 4.1 (Matrix representation of finite fields) For any f 2 GF [2 L ] let o (f ) be the matrix whose i th column is the coefficient vector of X i1 f <p> This proves the theorem. This theorem shows that inverting Cauchy matrices is significantly simpler than inverting an arbitrary matrix. However, multiplications and divisions in a finite field GF [2 L ] using the arithmetic of polynomials over GF <ref> [2] </ref> is rather inefficient. In the implementation of the XOR-code we avoid polynomial arithmetic by transforming multiplications and divisions into additions and subtractions of exponents by using a table of discrete logarithms. <p> Construction 6.1 (XOR-Code) Assume L maxflog (m); log (n m)g. Consider a message M = (M 1 ; : : : ; M m ) t of m packets containing L words of size w as an element of (GF <ref> [2] </ref>) mLfiw Let C be an (n m fi m)-Cauchy-matrix over the finite field GF [2 L ]: Let (c ij ); i = 1; : : :; n; j = 1; : : : ; m; be the matrix (I m jC): The generator matrix E of the XOR-code is <p> ~ E is the matrix whose (jL + i) th row (i = 0; : : : ; b 1) is the i th row of ~ E j : Remark that the ~ E j 's, E j 's and M i 's are (L fi w)-matrices over GF <ref> [2] </ref> and the o (c ij )'s are (L fi L)-matrices over GF [2]: Hence additions and multiplications in the steps above have to interpreted as matrix additions and multiplications. <p> 0; : : : ; b 1) is the i th row of ~ E j : Remark that the ~ E j 's, E j 's and M i 's are (L fi w)-matrices over GF <ref> [2] </ref> and the o (c ij )'s are (L fi L)-matrices over GF [2]: Hence additions and multiplications in the steps above have to interpreted as matrix additions and multiplications. <p> o: Since D is a (k fi k)-matrix, by Theorem 5.3 this requires O (k 2 ) arithmetic operations in GF [2 L ]: In Step 2, instead of computing D 1 using the isomorphism o and the procedure for inverting Cauchy-matrices we could also use Gaussian elimination over GF <ref> [2] </ref>. This would require O ((m k) 3 L 3 ) bit operations. <p> This representation is very useful to multiply two elements, as one just needs to add their exponents (modulo 2 L 1). * As an L-dimensional vector over GF <ref> [2] </ref>. <p> ExpToFieldElt: A table that goes from the exponent of an element, in terms of a previously chosen generator of the multiplicative group, to its representation as a vector over GF <ref> [2] </ref>. FieldEltToExp: The table that goes from the vector representation of an element to its exponent of the generator.
Reference: [3] <author> N. Alon J. Edmonds, M. Luby, </author> <title> Linear Time Erasure Codes with Nearly Optimal Recovery, </title> <booktitle> in Proc. 36 th Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1995. </year>
Reference-contexts: The lower bound we prove applies only to the payload of packets. It does not include the space needed for the unique identifier, we assume is included in every packet. Finally, we should mention that recently <ref> [3] </ref> constructed erasure-resilient codes that are almost MDS and that have linear time encoding and decoding algorithms. In these codes the number of packets needed to recover the message is (1 + *)m, where * is an 2 arbitrary positive constant.
Reference: [4] <author> E. Biersack, </author> <title> "Performance evaluation of forward error correction in ATM networks", </title> <booktitle> Proceedings of SIGCOMM '92, </booktitle> <address> Baltimore, </address> <year> 1992. </year>
Reference-contexts: Thus, it makes sense to protect real-time traffic sent through such networks against losses by adding a moderate level of redundancy using erasure-resilient codes. Algorithms based on this approach have been developed for applications such as multi casting real-time high-volume video information over lossy packet based networks <ref> [2, 1, 4] </ref> and other high volume real-time applications [8]. The two most important properties of fl International Computer Science Institute, Berkeley, California.
Reference: [5] <author> D. Grigoriev, M. Karpinski, M. Singer, </author> <title> Fast Parallel Alogorithms for Multivariate Polynomial over Finite Fields, </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 19, </volume> <year> 1990, </year> <pages> pp. 1059-1063. </pages>
Reference: [6] <author> F. J. MacWilliams, N. J. A. Sloane, </author> <title> The Theory of Error-Correcting Codes, </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: An erasure-resilient code where any portion of the encoding equal to the length of the message is sufficient to recover the message is called a maximal distance separable (MDS) code in the literature (see for example <ref> [6] </ref>). An ideal erasure-resilient code would be a linear time MDS code, but so far no such code is known. Theoretically the most efficient MDS codes can be constructed based on evaluating and interpolating polynomials over specially chosen finite fields using Discrete Fourier Transform. <p> The version of Reed-Solomon codes we use is based on Cauchy matrices over finite fields (see for example <ref> [6] </ref> and [11]). Every square submatrix of a Cauchy matrix is invertible. Therefore Cauchy matrices can be used to implement linear, systematic codes, i.e., the encoding is a linear function of the message and the unencoded message is part of the encoding. <p> Hence our definition coincides with the standard definition of MDS codes (see for example <ref> [6] </ref>). As opposed to error-correcting codes, where bits can be corrupted and the locations of corrupted bits are not known in advance, in an erasure-resilient code the indices of corrupted packets are known. The corrupted packets are treated as being lost. <p> A proof of the following theorem can be found for example in <ref> [6] </ref>. Theorem 2.2 Let C be a an ((n m) fi m)-matrix over GF [2 L ]: The matrix (I m jC) is the generator matrix of a systematic MDS code with packet size L if and only if every square submatrix of C is invertible. <p> The bound is significantly better than the bound shown in [1]. The bound almost matches the least possible packet size of the Cauchy-code and the XOR-code. For slightly better bounds for the case of special linear MDS codes see <ref> [6] </ref>.
Reference: [7] <author> L. Mirsky, </author> <title> An Introduction to Linear Algebra, </title> <publisher> Dover, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: x n1 +y 2 : : : 1 1 1 x n +y n 7 7 7 7 then det (C) = i&lt;j (x i x j ) i&lt;j (y i y j ) i;j=1 (x i + y j ) A proof of this theorem can be found in <ref> [7] </ref>. Note that the first part of the theorem follows from the second part, since any sub-matrix of a Cauchy matrix is itself a Cauchy matrix.
Reference: [8] <author> M. O. Rabin, </author> <title> Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance, </title> <journal> J. ACM, </journal> <volume> Vol. 36, No. 2, </volume> <month> April </month> <year> 1989, </year> <pages> pp. 335-348. </pages>
Reference-contexts: Algorithms based on this approach have been developed for applications such as multi casting real-time high-volume video information over lossy packet based networks [2, 1, 4] and other high volume real-time applications <ref> [8] </ref>. The two most important properties of fl International Computer Science Institute, Berkeley, California. <p> The corrupted packets are treated as being lost. In applications of erasure-resilient codes like robust data transfer on packet-based networks [1], information dispersal <ref> [8] </ref>, or secret sharing [10], this is a realistic assumption. An important subclass of error-correcting or erasure-resilient codes are linear codes. <p> The following theorem can also be found in Rabin's paper <ref> [8] </ref>. Theorem 5.3 The inverse of an (n fi n)-Cauchy matrix over a field F can be computed using O (n 2 ) arithmetic operations in F . Proof: Assume the Cauchy matrix C is as in Theorem 5.2.
Reference: [9] <author> S. Roman, </author> <title> Coding and Information Theory, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: However, the main gain compared to the method based on the evaluation and interpolation of polynomials is achieved by using a well-known representation of elements in finite fields of the form GF [2 L ] by (L fi L)-matrices over GF [2] (see <ref> [9] </ref>). This allows us to replace arithmetic operations on field elements by XOR's of computer words and in practice XOR's of computer words are much more efficient than multiplications in finite fields. The paper is organized as follows.
Reference: [10] <author> A. Shamir, </author> <title> How to Share a Secret, </title> <journal> C. ACM, </journal> <volume> Vol. 22, No. 11, </volume> <month> November </month> <year> 1979, </year> <pages> pp. 612-613. </pages>
Reference-contexts: The corrupted packets are treated as being lost. In applications of erasure-resilient codes like robust data transfer on packet-based networks [1], information dispersal [8], or secret sharing <ref> [10] </ref>, this is a realistic assumption. An important subclass of error-correcting or erasure-resilient codes are linear codes.
Reference: [11] <author> S. B. Wicker, V. K. Bhargava, </author> <title> Reed-Solomon Codes and their Applications, </title> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1994. </year> <month> 19 </month>
Reference-contexts: The version of Reed-Solomon codes we use is based on Cauchy matrices over finite fields (see for example [6] and <ref> [11] </ref>). Every square submatrix of a Cauchy matrix is invertible. Therefore Cauchy matrices can be used to implement linear, systematic codes, i.e., the encoding is a linear function of the message and the unencoded message is part of the encoding. <p> As required by Theorem 2.2, every square submatrix of a Cauchy matrix is nonsingular. Cauchy matrices are easier to invert than general matrices. This is important to achieve efficient decoding algorithms. MDS codes based on Cauchy matrices are a variant of Reed-Solomon codes (see for example <ref> [11] </ref>). We will describe Cauchy matrices in detail in Section 5. In practice it turns out to be more efficient to define packets as containing b words consisting of w bits each than to define them in terms of single bits. <p> Cauchy matrices have also been used in [8],[5]. They can be used to define one variant of Reed-Solomon codes <ref> [11] </ref>).
References-found: 11

