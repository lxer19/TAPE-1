URL: ftp://ftp.cs.ucsd.edu/pub/team/diffusionclocksync.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: Clock Synchronization in the Presence of Omission and Performance Failures, and Processor Joins  
Author: Flaviu Cristian, Houtan Aghili and Ray Strong 
Affiliation: IBM Research Almaden Research Center  
Abstract: This paper presents a simple practical protocol for synchronizing clocks in a distributed system. Synchronization consists of maintaining logical clocks which run at roughly the speed of a correct hardware clock and are within some known bound of each other. Synchronization is achieved by periodically computing adjustments to the hardware clocks present in the system. The protocol is tolerant of any number of omission failures (e.g. processor crashes, link crashes, occasional message losses) and performance failures (e.g. overloaded processors, slow links) that do not partition the communications network and handles any number of simultaneous processor joins. An earlier version of this paper was ppresented at the 16th IEEE Int. Symp. on Fault-tolerant Computing Systems, Vienna, July 1-4, 1986. Flaviu Cristian is now with the University of California, San Diego. Houtan Aghili is now with IBM Research, T. J. Watson Research Center. 
Abstract-found: 1
Intro-found: 1
Reference: [C] <author> F. Cristian: </author> <title> Probabilistic Clock Synchronization, </title> <journal> Distributed Computing, </journal> <volume> Vol. 3, </volume> <pages> pp 146-158, </pages> <year> 1989. </year>
Reference-contexts: Such an adjustment can be implemented either by bumping the local clock to T, or by slightly increasing the speed of the local clock so as to catch up with the remote clock <ref> [C] </ref>, [CS]. The operation C.read reads the current value displayed by C. The operation C.duration (T:Time), used to measure time intervals, reads the number of time units elapsed between a previous time T and the present time. The Timer data type has a unique operation "set (T:Time)".
Reference: [Cr] <author> F. Cristian: </author> <title> Understanding Fault-tolerant Distributed Systems, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 2, </volume> <booktitle> Feb 1991 and erratum in CACM Vol. </booktitle> <volume> 34, No. 4, </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: for current quartz based clock chips, and the extensive error detecting circuitry built in such chips, in this paper we will assume that the likelihood of undetectable clock failure occurrences is negligible compared to other sources of system failures (for a precise interpretation of what "negligible" means, we refer to <ref> [Cr] </ref>).
Reference: [CS] <author> F. Cristian and F. Shmuck: </author> <title> Continuous Clock Amortization Need not Affect the Precision of a Clock Synchronization Algorithm, </title> <institution> IBM Research Report RJ7290, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: We refer the reader to discussions of various methods for maintaining smooth logical clocks by amortizing adjustments in [DHSS] and <ref> [CS] </ref>. One of our main objectives was to design a protocol that is practical . <p> Such an adjustment can be implemented either by bumping the local clock to T, or by slightly increasing the speed of the local clock so as to catch up with the remote clock [C], <ref> [CS] </ref>. The operation C.read reads the current value displayed by C. The operation C.duration (T:Time), used to measure time intervals, reads the number of time units elapsed between a previous time T and the present time. The Timer data type has a unique operation "set (T:Time)".
Reference: [CASD] <author> F. Cristian, H. Aghili, R. Strong D. Dolev: </author> <title> Fault-Tolerant Atomic Broadcast Protocols. </title> <booktitle> Proc. 15th Int. Conf. on Fault-Tolerant Computing, </booktitle> <address> Ann Arbor, Michigan, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: A component failure occurs when a component does not deliver the service requested in the manner specified. We distinguish among three general failure classes <ref> [CASD] </ref>. If the component never responds to a service request it suffers an omission failure. If the component delivers a requested service either too early or too late (i.e. outside the real time interval specified) it suffers a timing failure. We call late timing failures performance failures. <p> (N 1) fi ldel (network delay) real time units between p and q, where N is the maximum number of processors in the system. (For a better, but more complex, upper bound on the network delay which would guarantee a closer synchronization of clocks, the interested reader is referred to <ref> [CASD] </ref>.) Our protocol is designed to tolerate omission and performance failures that do not partition the network of correct processors. We acknowledge the possibility that other types of failures (e.g. very fast clocks, or sabotaged processors). <p> Also, in the absence of processor joins, it is required that each periodic clock synchronization terminate within some known real time delay sdel (synchronization delay). A protocol that achieves (C1,C2) is said to achieve linear envelope clock synchronization. 5 Informal Algorithm Presentation Our algorithm is based on information diffusion <ref> [CASD] </ref>, [DHSS]. It is simpler than [DHSS] because we limit the class of failures to be tolerated to omission and performance failures. It also uses a simpler method for handling processor joins. <p> Another important application is in ensuring consistency among the knowledge states of the computers of a distributed system. An earlier paper <ref> [CASD] </ref> has presented protocols for ensuring the consistency of replicated data that depend on synchronized clocks. 15
Reference: [DHSS] <author> D. Dolev, J. Halpern, B. Simons, R. </author> <title> Strong: Fault-Tolerant Clock Synchronization, </title> <institution> IBM Research Report RJ4094, </institution> <year> 1983. </year>
Reference-contexts: We refer the reader to discussions of various methods for maintaining smooth logical clocks by amortizing adjustments in <ref> [DHSS] </ref> and [CS]. One of our main objectives was to design a protocol that is practical . <p> A protocol that achieves (C1,C2) is said to achieve linear envelope clock synchronization. 5 Informal Algorithm Presentation Our algorithm is based on information diffusion [CASD], <ref> [DHSS] </ref>. It is simpler than [DHSS] because we limit the class of failures to be tolerated to omission and performance failures. It also uses a simpler method for handling processor joins. <p> A protocol that achieves (C1,C2) is said to achieve linear envelope clock synchronization. 5 Informal Algorithm Presentation Our algorithm is based on information diffusion [CASD], <ref> [DHSS] </ref>. It is simpler than [DHSS] because we limit the class of failures to be tolerated to omission and performance failures. It also uses a simpler method for handling processor joins. <p> In the absence of processor crashes or joins, one could use a predefined synchronizer processor to generate synch waves. If processor crashes are likely, and they certainly are, the existence of a unique synchronizer becomes a single point of failure. As observed in <ref> [DHSS] </ref>, it is better to distribute the role of synchronizer among all processors. The idea is that any processor should be able to initiate a synch wave if it discovers that PER clock time units have elapsed since the last synchronization occurred. <p> Then they will drift apart for at most (1 + )P ER real time units before they are resynchronized by the protocol. 7 Algorithm Analysis To prove the correctness of our protocol we use a technique similar to that of <ref> [DHSS] </ref>. Since the objective of our synchronization protocol is to provide tolerance of only omission and performance failures, our simpler protocol provides stronger properties than those of [DHSS] (in the sense that the accuracy of the logical clocks is not 11 worse as is the case in [DHSS] than that of <p> are resynchronized by the protocol. 7 Algorithm Analysis To prove the correctness of our protocol we use a technique similar to that of <ref> [DHSS] </ref>. Since the objective of our synchronization protocol is to provide tolerance of only omission and performance failures, our simpler protocol provides stronger properties than those of [DHSS] (in the sense that the accuracy of the logical clocks is not 11 worse as is the case in [DHSS] than that of a correct hardware clock, and that the maximum adjustment by which a logical clock can be set forward is a constant smaller then that of [DHSS]). <p> to that of <ref> [DHSS] </ref>. Since the objective of our synchronization protocol is to provide tolerance of only omission and performance failures, our simpler protocol provides stronger properties than those of [DHSS] (in the sense that the accuracy of the logical clocks is not 11 worse as is the case in [DHSS] than that of a correct hardware clock, and that the maximum adjustment by which a logical clock can be set forward is a constant smaller then that of [DHSS]). Theorem 1. The algorithm achieves linear envelope synchronization among all joined clocks. <p> of <ref> [DHSS] </ref> (in the sense that the accuracy of the logical clocks is not 11 worse as is the case in [DHSS] than that of a correct hardware clock, and that the maximum adjustment by which a logical clock can be set forward is a constant smaller then that of [DHSS]). Theorem 1. The algorithm achieves linear envelope synchronization among all joined clocks.
Reference: [IBM370] <author> IBM System/370: </author> <title> Principles of Operation, </title> <address> GA32-7000-8, </address> <year> 1981. </year>
Reference-contexts: For example, if the counting register that composes a clock is self-checking, the occurrence of a physical failure within it will generate (with high probability) a clock-error exception. If a detectable physical failure affects a hardware clock, any attempt at reading its value terminates with a clock-error exception <ref> [IBM370] </ref>.
Reference: [KO] <author> H. Kopetz, W. Ochsenreiter: </author> <title> Internal Clock Synchronization with a VLSI Synchronization Unit, </title> <type> TR 1985/7, </type> <institution> Technical Univ. Vienna, </institution> <year> 1985. </year>
Reference-contexts: Because of the simpler failure model considered, the protocol presented is considerably simpler then those presented in [LM,DHSS,LL], especially in the handling of processor joins. The engineering approach adopted is similar in spirit to the one adopted in <ref> [KO] </ref>, where protocol simplicity is achieved by limiting the total number of failures that can be tolerated during a synchronization. Synchronized clocks are useful for a number of reasons.
Reference: [L] <author> L. Lamport: </author> <title> Time, Clocks, and the Ordering of Events in a Distributed Systems, </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 21, No. 7, </volume> <month> July </month> <year> 1978, </year> <pages> pp. 558-565. </pages>
Reference-contexts: Synchronized clocks are useful for a number of reasons. They can be used to totally order the events of a distributed system <ref> [L] </ref> (e.g. merging of the data base logs generated on distinct computers into a common unique log), and they can be used to measure the time that elapses between events that occur on different processors (e.g. do performance evaluation of distributed systems).
Reference: [LM] <author> L. Lamport, M. Melliar-Smith: </author> <title> Synchronizing Clocks in the presence of failures, </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> Vol. 32, No. 1, </volume> <month> January </month> <year> 1985, </year> <pages> pp. 52-78. </pages>
Reference: [LL] <author> J. Lundelius, N. Lynch: </author> <title> A new failure-tolerant algorithm for clock synchronization, </title> <booktitle> Proc. of the 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1983. </year>
Reference: [MIL] <editor> MIL Handbook 217D, </editor> <volume> Notice 1, </volume> <month> 13 June </month> <year> 1983, </year> <note> pp.5.1.15-1. 16 </note>
Reference-contexts: Current experience indicates that the average quartz clock that is used in medium to high-end digital computers has a mean time between failures (MTBF) in excess of 15-25 years, and that good clocks, like those used in military applications, can have MTBF's expressed in hundreds of years <ref> [MIL] </ref>. Many of the clock failures likely to occur in practice can be detected by the error detecting circuitry incorporated in clock chips.
References-found: 11

