URL: http://www-ee.technion.ac.il/~issy/papers/tichy-config-man.ps.gz
Refering-URL: http://www-ee.technion.ac.il/~issy/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Note: Contents  
Abstract: 2 A Bi-Level Language for Software Process Modeling 1 2.1 INTRODUCTION : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 1 2.2 MOTIVATION : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 3 2.3 BACKGROUND : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 5 2.4 ASL SYNTAX AND SEMANTICS : : : : : : : : : : : : : : : : : : : : : 9 2.5 ASL ENACTION MODEL : : : : : : : : : : : : : : : : : : : : : : : : : 13 2.6 IMPLEMENTATION DETAILS : : : : : : : : : : : : : : : : : : : : : : : 19 2.7 ASL EXAMPLE : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 21 2.8 RELATED WORK : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 24 2.9 CONTRIBUTIONS : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 30 
Abstract-found: 1
Intro-found: 1
Reference: [ADWR86] <author> George S. Avrunin, Laura K. Dillon, Jack C. Wileden, and William E. Riddle. </author> <title> Constrained expressions: Adding analysis capabilities to design methods for concurrent software systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):278-292, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Further discussion of action languages is outside the scope of this paper. We present a working multi-user implementation of a bi-level PML. We selected our own MARVEL Strategy Language (MSL) [HKBBS92] to express constraints, and a variant of constrained expressions <ref> [ADWR86] </ref> 1 due to Riddle [Rid91] for the topology component. MSL provides planning system-style rules for specifying the prerequisites and consequences of the tool invocations of each individual process step, usually applied to the tool's data parameters and related objects.
Reference: [Bar92] <author> Naser S. Barghouti. </author> <title> Supporting cooperation in the MARVEL process-centered SDE. </title> <editor> In Herbert Weber, editor, </editor> <booktitle> 5th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 21-31, </pages> <address> Tyson's Corner VA, </address> <month> December </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: Instead, individual rules and/or atomic rule chains enacted on behalf of different users that attempt to access the same data at the same time in incompatible modes (e.g., one reads while another writes or both write) are resolved through a semantics-based concurrency control protocol <ref> [Bar92] </ref>.
Reference: [Bat88] <author> Peter Bates. </author> <title> Distributed debugging tools for heterogeneous distributed systems. </title> <booktitle> In 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 308-315, </pages> <address> San Jose CA, </address> <month> June </month> <year> 1988. </year> <title> IEEE Computer Society. 7 Another member of our group has implemented the completely independent StateMate process modeling formalism [HK89] by translation into MSLfor enaction; see [Hei93a]. </title> <type> 32 REFERENCES </type>
Reference-contexts: A Bi-Level Language for Software Process Modeling 3 event patterns in concurrent systems, and similar formalisms have been widely used in both sequential [BH83] and concurrent <ref> [Bat88, PHK91] </ref> debuggers. Our resulting PML is called the Activity Structures Language (ASL). MSL is a proper subset of ASL.
Reference: [BCD + 91] <author> Ph. Boveroux, G. Canals, J. C. Derniame, C. Godart, Ph. Jamart, and J. Lonchamp. </author> <title> Software process modelling in the ALF system: an example. </title> <editor> In A. Fugetta, R. Conradi, and V. Ambriola, editors, </editor> <booktitle> 1st European Workshop on Software Process Modeling, </booktitle> <pages> pages 167-179, </pages> <address> Milan, Italy, </address> <month> May </month> <year> 1991. </year> <month> AICA. </month>
Reference-contexts: This is the most clearly constraint-oriented aspect of the PML, although the operator pre- and post-conditions and rules also seem to be more concerned with constraints than topology. Boveroux et al. provide an extended example of an ALF process model <ref> [BCD + 91] </ref>. APPL/A is a process programming language [Ost87] based on Ada. Process roles are represented as Ada tasks and synchronize via rendezvous. Subroutines support hierarchical decomposition and conventional structured-programming constructs specify the control flow among process steps. This imperative aspect provides the topology-oriented level of the PML.
Reference: [BEM91] <author> Noureddine Belkhatir, Jacky Estublier, and Walcelio L. Melo. </author> <title> Adele 2: A support to large software development process. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 159-170, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sut90] extends Ada, Funsoft nets [Gru91] are based on Petri nets, AP5 [Coh86] uses OPS5-like production system rules, Darwin [Min91] employs Prolog-like logic programming rules, Adele <ref> [BEM91] </ref> follows database triggers, HFSP [Kat89] is similar to attribute grammars, etc. <p> Adele's triggers seem typical of those employed in many modern database management systems, but as far as we know, only Adele has been directly applied to process modeling and enaction <ref> [BEM91] </ref>. When a trigger's pre-condition is satisfied, its action is executed. PRE and POST triggers are evaluated at the beginning and end of a process step, respectively, within an all-or-nothing transaction.
Reference: [BEM93] <author> Noureddine Belkhatir, Jacky Estublier, and Walcelio L. Melo. </author> <title> Software process model and work space control in the Adele system. </title> <booktitle> In 2nd International Conference on the Software Process: Continuous Software Process Improvement, </booktitle> <pages> pages 2-11, </pages> <address> Berlin Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Synchronization among roles is specified in a second formalism, called TEMPO <ref> [BEM93] </ref>, with rules built on top of Adele's triggers; this is different from our bi-level breakdown, since TEMPO is concerned with collaboration among what are defined as effectively separate processes rather than topology of a process.
Reference: [BFKM85] <author> Lee Brownston, Robert Farrell, Elaine Kant, and Nancy Martin. </author> <title> Programming Expert Systems in OPS5. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1985. </year>
Reference-contexts: Topology with respect to single or multiple users can thus be specified (implicitly) by the constraints of individual process steps, but at a relatively low and non-intuitive level. The Brownston et al. OPS5 book <ref> [BFKM85] </ref> dedicates many pages to hacking control flow in rule systems, by introducing state variables to force chaining among rules in the desired order. The Common Lisp Framework (CLF) [Pro88] incorporates a process model written in AP5, which supports data-driven forward chaining over two separate rule bases [Coh86].
Reference: [BH83] <author> Bernd Bruegge and Peter Hibbard. </author> <title> Generalized path expressions: A high-level debugging mechanism. </title> <journal> The Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 265-276, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: A Bi-Level Language for Software Process Modeling 3 event patterns in concurrent systems, and similar formalisms have been widely used in both sequential <ref> [BH83] </ref> and concurrent [Bat88, PHK91] debuggers. Our resulting PML is called the Activity Structures Language (ASL). MSL is a proper subset of ASL.
Reference: [BPJ91] <author> R.F. Bruynooghe, J.M. Parker, and J.S.Rowles. PSS: </author> <title> A system for process enactment. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 128-141, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We think it may be even more difficult to specify topology using this approach than the forward-chaining systems. Again, there is no explicit synchronization, although the system has been shown applicable to multi-user configuration management [MR90]. The Process Support System (PSS) <ref> [BPJ91] </ref> uses a process modeling language called simply PML. PML also represents concurrent roles as instances of classes, which communicate with one another by asynchronous message passing.
Reference: [BSKH93] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An architecture for multiuser software development environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: modeling facilities already provided by MSL. (MARVEL's action language was used as is for interfacing to commercial off-the-shelf tools through what is often called tool envelopes [GK91].) ASL was implemented by translation of the extended constrained expressions into MSL, followed by normal enaction of MSL using the multi-user MARVEL kernel <ref> [BSKH93] </ref>. The only modification to MARVEL itself was the addition of a 750-line module in the process engine.
Reference: [CG89] <author> Nicholas Carriero and David Gelernter. </author> <title> Linda in context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: ProcessWall, however, seems to have an advantage over ASL in flexibility. Oikos [Cia93] is arguably bi-level, although this nature may not be obvious since the two levels are relatively well-integrated. The topological layer, based on Linda-like tuple spaces <ref> [CG89] </ref>, consists of a hierarchical structure of blackboards that represent the work breakdown as mutually recursive process and environment blackboards. Process blackboards generally represent predefined processes (or process fragments) while environments offer the user freedom to choose among available processes.
Reference: [CH74] <author> R.H. </author> <title> Campbell and A.N. Habermann. The specification of process synchronization by path expressions. </title> <booktitle> In Operating Systems, volume 16 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: Constrained expressions support regular expression operators and concurrent shuffle of process fragments, as well as send/receive primitives for synchronization among concurrent subexpressions thus directing the overall workflow. Constrained expressions were originally developed as an alternative to path expressions <ref> [CH74] </ref> for specifying 1 This use of the term constrained should not be confused with the constraints discussed in this paper. A Bi-Level Language for Software Process Modeling 3 event patterns in concurrent systems, and similar formalisms have been widely used in both sequential [BH83] and concurrent [Bat88, PHK91] debuggers.
Reference: [Cia93] <author> Paolo Ciancarini. </author> <title> Coordinating rule-based software processes with ESP. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 203-227, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: ASL has an advantage over the ProcessWall mechanisms, in that both levels can (in principle, but not necessarily) be specified in a single unit, which may aid understandability. ProcessWall, however, seems to have an advantage over ASL in flexibility. Oikos <ref> [Cia93] </ref> is arguably bi-level, although this nature may not be obvious since the two levels are relatively well-integrated. The topological layer, based on Linda-like tuple spaces [CG89], consists of a hierarchical structure of blackboards that represent the work breakdown as mutually recursive process and environment blackboards.
Reference: [Coh86] <author> Donald Cohen. </author> <title> Automatic compilation of logical specifications into efficient programs. </title> <booktitle> In 5th National Conferenceon Artificial Intelligence, volume Science, </booktitle> <pages> pages 20-25, </pages> <address> Philadel-phia, PA, </address> <month> August </month> <year> 1986. </year> <note> AAAI. </note>
Reference-contexts: Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sut90] extends Ada, Funsoft nets [Gru91] are based on Petri nets, AP5 <ref> [Coh86] </ref> uses OPS5-like production system rules, Darwin [Min91] employs Prolog-like logic programming rules, Adele [BEM91] follows database triggers, HFSP [Kat89] is similar to attribute grammars, etc. <p> OPS5 book [BFKM85] dedicates many pages to hacking control flow in rule systems, by introducing state variables to force chaining among rules in the desired order. The Common Lisp Framework (CLF) [Pro88] incorporates a process model written in AP5, which supports data-driven forward chaining over two separate rule bases <ref> [Coh86] </ref>. Consistency rules have a similar purpose to MARVEL's atomicity annotations and automation rules are related to MARVEL's automation annotations, but with nothing akin chaining restrictions; both forms of rules include a pre-condition and an action.
Reference: [DG90] <author> Wolfgang Deiters and Volker Gruhn. </author> <title> Managing software processes in the environment MELMAC. </title> <editor> In Richard N. Taylor, editor, </editor> <booktitle> 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 193-205, </pages> <address> Irvine CA, </address> <month> December </month> <year> 1990. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: A user has the freedom to choose among enabled nodes, including switching back and forth among in-progress subgraphs. Multiple users are synchronized through the precedence relations among the nodes in their (concurrent) subprocesses. Melmac <ref> [DG90] </ref> is typical of the many process-centered environments whose PML is based on Petri nets.
Reference: [DR93] <author> Prasun Dewan and John Riedl. </author> <title> Toward computer-supported concurrent software engineering. </title> <journal> Computer, </journal> <volume> 26(1) </volume> <pages> 17-27, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: An alternative interpretation of concurrent repetition would require each of the instances to follow the same choice, which could be useful for executing a groupware tool <ref> [DR93] </ref>. Passive Recognition might handle @(A | B); C by allowing any number of end-users to do either A or B, but not both, until some user happens to do C.
Reference: [GJ92] <author> Volker Gruhn and Rudiger Jegelka. </author> <title> An evaluation of FUNSOFT nets. </title> <editor> In J.C. Derniame, editor, </editor> <booktitle> Software Process Technology Second European Workshop, number 635 in Lecture Notes in Computer Science, </booktitle> <pages> pages 196-214. </pages> <publisher> Springer-Verlag, </publisher> <address> Trondheim, Norway, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: If multiple transitions invoke the same tool, the predicate must be repeated for each case; of course, different predicates may be warranted. Predicates thus provide a limited form of constraints <ref> [GJ92] </ref>. The Hierarchical and Functional Software Process (HFSP) PML [Kat89] is based on attribute grammars. The topology of the process model is defined through context-free productions, representing sequencing, alternation, iteration and hierarchical structuring (including recursion).
Reference: [GK91] <author> Mark A. Gisi and Gail E. Kaiser. </author> <title> Extending a tool integration language. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 218-227, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The rest of ASL consists of Riddle's activity structures extended with parameter variables, whose classes (types) are defined by object-oriented data modeling facilities already provided by MSL. (MARVEL's action language was used as is for interfacing to commercial off-the-shelf tools through what is often called tool envelopes <ref> [GK91] </ref>.) ASL was implemented by translation of the extended constrained expressions into MSL, followed by normal enaction of MSL using the multi-user MARVEL kernel [BSKH93]. The only modification to MARVEL itself was the addition of a 750-line module in the process engine.
Reference: [GNR91] <author> Steven L. Gaede, Brian Nejmeh, and William E. Riddle. </author> <title> Interim report process management: Infrastructure exploration project. </title> <type> Technical Report 7-48-5, </type> <institution> Software Design & Analysis, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Choices among alternatives including whether or not to repeat a cycle could be requested from the user in a live environment, or selected randomly in a simulation. The generation approach has been explored by Gaede on top of the single-user MARVEL 2.6 <ref> [GNR91] </ref>. 2. In what we call the Passive Recognition approach, the environment's enforcement capabilities would be used to recognize a process, given an actual sequence of commands (activities) entered by the users. Thus the process engine would function as a parser of strings in the language defined by AS-def.
Reference: [Gru91] <author> Volker Gruhn. </author> <title> Validation and Verification of Software Process Models. </title> <type> PhD thesis, </type> <institution> Forschungsberichte des Fachbereichs Informatik der Universitat Dortmund, </institution> <year> 1991. </year> <note> Bericht Nr. 394/91. </note>
Reference-contexts: Enaction usually enforces and/or automates (portions of) the desired process on behalf of a team of environment users (see, e.g., [Sch93, ICS93]). Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sut90] extends Ada, Funsoft nets <ref> [Gru91] </ref> are based on Petri nets, AP5 [Coh86] uses OPS5-like production system rules, Darwin [Min91] employs Prolog-like logic programming rules, Adele [BEM91] follows database triggers, HFSP [Kat89] is similar to attribute grammars, etc. <p> Multiple users are synchronized through the precedence relations among the nodes in their (concurrent) subprocesses. Melmac [DG90] is typical of the many process-centered environments whose PML is based on Petri nets. In Melmac's Funsoft nets <ref> [Gru91] </ref>, multiple transitions can fire simultaneously to reflect multiple participants in the process, so synchronization is treated the same way as other control flow, through the topology and marking of the net.
Reference: [Hei90] <author> Dennis Heimbigner. </author> <title> Proscription versus Prescription in process-centered environments. </title> <editor> In Takuya Katayama, editor, </editor> <booktitle> 6th International Software Process Workshop: Support for the Software Process, </booktitle> <pages> pages 99-102, </pages> <address> Hakodate, Japan, October 1990. </address> <publisher> IEEE Computer REFERENCES 33 Society Press. </publisher>
Reference-contexts: We have identified four distinct points on the spectrum from prescriptive (system-driven) to proscriptive (user-driven) <ref> [Hei90] </ref>: 1. The straightforward prescriptive interpretation of an AS-def generates an actual process instance as a sequence of activities, so we call it the Generation approach.
Reference: [Hei92] <author> Dennis Heimbigner. </author> <title> The ProcessWall: A process state server approach to process programming. </title> <editor> In Herbert Weber, editor, </editor> <booktitle> 5th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 159-168, </pages> <address> Tyson's Corner VA, </address> <month> December </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: The user then chooses among those possible actions, at which point the scheduling is resumed. PSS seems to have no structure imposed above that of the individual roles and their interconnections, which implicitly determines the topology. 2.8.3 Bi-Level PMLs Heimbigner's ProcessWall <ref> [Hei92] </ref> is not a complete process-centered environment, but an environment component a process state server with a predefined representation for tasks, hierarchical breakdown of tasks into (sub)tasks and individual process steps, and data flow among nodes in the graph.
Reference: [Hei93a] <author> George T. Heineman. </author> <title> Automatic translation of process modeling formalisms. </title> <type> Technical Report CUCS-036-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> November </month> <year> 1993. </year>
Reference: [Hei93b] <author> George T. Heineman. </author> <title> A transaction manager component for cooperative transaction models. </title> <type> Technical Report CUCS-017-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> July </month> <year> 1993. </year> <type> PhD Thesis Proposal. </type>
Reference-contexts: There are also coordination modeling facilities for defining project-specific collaboration policies, which also apply reactively to concurrency control conflicts that happen to come up; see <ref> [Hei93b] </ref>. own development; the full process consists of 40 classes, 184 rules and 46 tool envelopes. 4 This arch rule's queries gather up all the C, yacc, lex and ar files included in the module value of its parameter variable (?m), as well as in any nested modules. 5 The properties
Reference: [HK89] <author> Watts Humphrey and Marc I. Kellner. </author> <title> Software process modeling: </title> <booktitle> Principles of entity process models. In 11th Internation Conference on Software Engineering, </booktitle> <pages> pages 331-342, </pages> <address> Pittsburgh PA, May 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [HK91] <author> Dennis Heimbigner and Marc Kellner. </author> <title> Software process example for ISPW-7, </title> <month> August </month> <year> 1991. </year> <note> /pub/cs/techreports/ISPW7/ispw7.ex.ps.Z available by anonymous ftp from ftp.cs.colorado.edu. </note>
Reference-contexts: Many PMLs have successfully been used to model part or all of the ISPW6 [KFF + 91] or ISPW7 <ref> [HK91] </ref> example problem, but it is generally agreed that some language paradigms are better than others at expressing different aspects of software processes [KR90].
Reference: [HKBBS92] <author> George T. Heineman, Gail E. Kaiser, Naser S. Barghouti, and Israel Z. Ben-Shaul. </author> <title> Rule chaining in MARVEL: Dynamic binding of parameters. </title> <journal> IEEE Expert, </journal> <volume> 7(6) </volume> <pages> 26-32, </pages> <month> December </month> <year> 1992. </year> <booktitle> [ICS93] 2nd International Conference on the Software Process: Continuous Software Process Improvement, </booktitle> <address> Berlin, Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Further discussion of action languages is outside the scope of this paper. We present a working multi-user implementation of a bi-level PML. We selected our own MARVEL Strategy Language (MSL) <ref> [HKBBS92] </ref> to express constraints, and a variant of constrained expressions [ADWR86] 1 due to Riddle [Rid91] for the topology component. MSL provides planning system-style rules for specifying the prerequisites and consequences of the tool invocations of each individual process step, usually applied to the tool's data parameters and related objects.
Reference: [IOIT91] <author> Hajimu Iida, Takeshi Ogihara, Katsuro Inoue, and Koji Torii. </author> <title> Generating a menu-oriented navigation system from formal description of software development activity sequence. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 45-57, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Terminal symbols represent individual process steps, whose tools are invoked through interfaces defined in a process enaction script. HFSP's decomposition conditions are placed on productions to restrict their application, similar to the predicates of Petri nets. The PDL project defines processes using context-free grammars <ref> [IOIT91] </ref>, with similar topological properties to HFSP.
Reference: [IPKT89] <author> Katsuro Inoue, Takeshi Pgihara, Tohru Kikuno, and Koji Torii. </author> <title> A formal adaptation method for process descriptions. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 145-153, </pages> <address> Pittsburgh PA, May 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The enaction model provides a menu-based navigation through the topological framework, although the authors postulate another enaction model analogous to the Passive Recognition of our ASL environment. A process model is translated into a second formalism, the functional Process Description Language (PDL) <ref> [IPKT89] </ref>, which is independent rather than constituting a level of a combined formalism as in ASL. The PDL process program, called a script, is then refined manually from an abstract to a concrete form that can be directly enacted by the PDL interpreter.
Reference: [Kat89] <author> Takuya Katayama. </author> <title> A hierarchical and functional software process description and its enaction. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 343-352, </pages> <address> Pittsburgh PA, May 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sut90] extends Ada, Funsoft nets [Gru91] are based on Petri nets, AP5 [Coh86] uses OPS5-like production system rules, Darwin [Min91] employs Prolog-like logic programming rules, Adele [BEM91] follows database triggers, HFSP <ref> [Kat89] </ref> is similar to attribute grammars, etc. Many PMLs have successfully been used to model part or all of the ISPW6 [KFF + 91] or ISPW7 [HK91] example problem, but it is generally agreed that some language paradigms are better than others at expressing different aspects of software processes [KR90]. <p> If multiple transitions invoke the same tool, the predicate must be repeated for each case; of course, different predicates may be warranted. Predicates thus provide a limited form of constraints [GJ92]. The Hierarchical and Functional Software Process (HFSP) PML <ref> [Kat89] </ref> is based on attribute grammars. The topology of the process model is defined through context-free productions, representing sequencing, alternation, iteration and hierarchical structuring (including recursion). The attributes' semantic functions specify computations on input parameters from the parent subprocess and on output parameters from the children.
Reference: [KFF + 91] <author> Marc I. Kellner, Peter H. Feiler, Anthony Finkelstein, Takuya Katayama, Leon J. Oster-weil, Maria H. Penedo, and H. Dieter Rombach. </author> <title> Software process modeling example problem. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 176-186, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Many PMLs have successfully been used to model part or all of the ISPW6 <ref> [KFF + 91] </ref> or ISPW7 [HK91] example problem, but it is generally agreed that some language paradigms are better than others at expressing different aspects of software processes [KR90].
Reference: [KR90] <author> Marc I. Kellner and H. Dieter Rombach. </author> <title> Session summary: Comparisons of software process descriptions. </title> <editor> In Takuya Katayama, editor, </editor> <booktitle> 6th International Software Process Workshop: Support for the Software Process, </booktitle> <pages> pages 7-18, </pages> <address> Hakodate, Japan, October 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Many PMLs have successfully been used to model part or all of the ISPW6 [KFF + 91] or ISPW7 [HK91] example problem, but it is generally agreed that some language paradigms are better than others at expressing different aspects of software processes <ref> [KR90] </ref>. One of the most significant distinctions among different styles of PMLs is their affinities towards control flow and synchronization, or the topology of the workflow, vs. constraints on isolated process steps.
Reference: [Min91] <author> Naftaly H. Minsky. </author> <title> Law-governed systems. </title> <journal> Software Engineering Journal, </journal> <volume> 6(5) </volume> <pages> 285-302, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sut90] extends Ada, Funsoft nets [Gru91] are based on Petri nets, AP5 [Coh86] uses OPS5-like production system rules, Darwin <ref> [Min91] </ref> employs Prolog-like logic programming rules, Adele [BEM91] follows database triggers, HFSP [Kat89] is similar to attribute grammars, etc. <p> Synchronization among roles is specified in a second formalism, called TEMPO [BEM93], with rules built on top of Adele's triggers; this is different from our bi-level breakdown, since TEMPO is concerned with collaboration among what are defined as effectively separate processes rather than topology of a process. Darwin's laws <ref> [Min91] </ref> define both the process model and the permitted evolution of the process model over time (see, e.g., [MP93]). Laws are syntactically and semantically similar to Prolog rules. Process steps are modeled by messages between objects; the objects represent tools and users as well as data.
Reference: [MP93] <author> Nazim H. Madhavji and Maria H. Penedo, </author> <title> editors. Special Section on the Evolution of Software Processes, </title> <journal> volume 19:12 of IEEE Transactions on Software Engineering. </journal> <month> December, </month> <year> 1993. </year>
Reference-contexts: Darwin's laws [Min91] define both the process model and the permitted evolution of the process model over time (see, e.g., <ref> [MP93] </ref>). Laws are syntactically and semantically similar to Prolog rules. Process steps are modeled by messages between objects; the objects represent tools and users as well as data. Constraints are enforced via Prolog-style unification and backtracking, with messages evaluated as goals with respect to the law.
Reference: [MR90] <author> Naftaly H. Minsky and David Rozenshtein. </author> <title> Configuration management by consensus: An application of law-governed systems. </title> <editor> In Richard N. Taylor, editor, </editor> <booktitle> 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 44-55, </pages> <address> Irvine CA, </address> <month> December </month> <year> 1990. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: We think it may be even more difficult to specify topology using this approach than the forward-chaining systems. Again, there is no explicit synchronization, although the system has been shown applicable to multi-user configuration management <ref> [MR90] </ref>. The Process Support System (PSS) [BPJ91] uses a process modeling language called simply PML. PML also represents concurrent roles as instances of classes, which communicate with one another by asynchronous message passing.
Reference: [MS91] <author> Peiwei Mi and Walt Scacchi. </author> <title> Modeling articulation work in software engineering processes. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 188-201, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In either case, each node passes through a sequence of states, beginning with None and normally proceeding through Allocated, Ready and Active before finishing in the Done state. Other states may be reached under exceptional conditions, in which case external repair is required in order to continue the process <ref> [MS91] </ref>. Once a node enters the Done state, its successor nodes become enabled (enactable), which appears to be the only kind of constraint enforced. A user has the freedom to choose among enabled nodes, including switching back and forth among in-progress subgraphs.
Reference: [MS92] <author> Peiwei Mi and Walt Scacchi. </author> <title> Process integration in CASE environments. </title> <journal> IEEE Software, </journal> <volume> 34 REFERENCES 9(2) </volume> <pages> 45-53, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Articulator <ref> [MS92] </ref> models a process as a hierarchical structure of task graphs, in the style outlined above, directly presenting the topology of the process. At the lowest level in the hierarchy, action nodes represent individual process steps, and their status is derived from the enactment of that step.
Reference: [NG91] <author> K. Narayanaswamy and Neil M. Goldman. </author> <title> Team coordination: Information sharing + policies. </title> <editor> In Ian Thomas, editor, </editor> <booktitle> 7th International Software Process Workshop: Communication and Coordination in the Software Process, </booktitle> <pages> pages 99-101, </pages> <address> Yountville CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A process model supports only one participant at a time, so there is no synchronization, per se although data can be imported from another user <ref> [NG91] </ref>. Adele's triggers seem typical of those employed in many modern database management systems, but as far as we know, only Adele has been directly applied to process modeling and enaction [BEM91]. When a trigger's pre-condition is satisfied, its action is executed.
Reference: [Ost87] <author> Leon Osterweil. </author> <title> Software processes are software too. </title> <booktitle> In 9th International Conference on Software Engineering, </booktitle> <pages> pages 1-13, </pages> <address> Monterey CA, March 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This is the most clearly constraint-oriented aspect of the PML, although the operator pre- and post-conditions and rules also seem to be more concerned with constraints than topology. Boveroux et al. provide an extended example of an ALF process model [BCD + 91]. APPL/A is a process programming language <ref> [Ost87] </ref> based on Ada. Process roles are represented as Ada tasks and synchronize via rendezvous. Subroutines support hierarchical decomposition and conventional structured-programming constructs specify the control flow among process steps. This imperative aspect provides the topology-oriented level of the PML.
Reference: [OZG91] <author> Flavio Oquendo, Jean-Daniel Zucker, and Philip Griffiths. </author> <title> The MASP approach to software process description, </title> <editor> instantiation and enaction. In A. Fugetta, R. Conradi, and V. Ambriola, editors, </editor> <booktitle> 1st European Workshop on Software Process Modeling, </booktitle> <pages> pages 147-155, </pages> <address> Milan, Italy, </address> <month> May </month> <year> 1991. </year> <month> AICA. </month>
Reference-contexts: ASL avoids this problem by merging the constraints specified in an activity's rule skeleton into each instance of the rule (occurrence in an activity structure) automatically. The Accueil de Logiciel Futur (ALF) environment employs a sophisticated multi-paradigm process modeling formalism, called the Model for Assisted Software Processes (MASP) <ref> [OZG91] </ref>. In addition to an object model based on PCTE class definitions [Tho89], the MASP notation has five components: 1. A set of operator types that define individual process steps in terms of their pre-conditions and post-conditions, expressed in first-order logic. 30 Kaiser, Popovich and Ben-Shaul 2.
Reference: [PHK91] <author> M. Krish Ponamgi, Wenwey Hseush, and Gail E. Kaiser. </author> <title> Debugging multi-threaded programs with MpD. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 37-43, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: A Bi-Level Language for Software Process Modeling 3 event patterns in concurrent systems, and similar formalisms have been widely used in both sequential [BH83] and concurrent <ref> [Bat88, PHK91] </ref> debuggers. Our resulting PML is called the Activity Structures Language (ASL). MSL is a proper subset of ASL.
Reference: [Pro88] <institution> CLF Project. CLF Manual. USC Information Sciences Institute, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: The Brownston et al. OPS5 book [BFKM85] dedicates many pages to hacking control flow in rule systems, by introducing state variables to force chaining among rules in the desired order. The Common Lisp Framework (CLF) <ref> [Pro88] </ref> incorporates a process model written in AP5, which supports data-driven forward chaining over two separate rule bases [Coh86].
Reference: [Rid91] <author> William E. Riddle. </author> <title> Activity structure definitions. </title> <type> Technical Report 7-52-3, </type> <institution> Software Design & Analysis, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Further discussion of action languages is outside the scope of this paper. We present a working multi-user implementation of a bi-level PML. We selected our own MARVEL Strategy Language (MSL) [HKBBS92] to express constraints, and a variant of constrained expressions [ADWR86] 1 due to Riddle <ref> [Rid91] </ref> for the topology component. MSL provides planning system-style rules for specifying the prerequisites and consequences of the tool invocations of each individual process step, usually applied to the tool's data parameters and related objects.
Reference: [Sch93] <author> Wilhelm Schafer, </author> <title> editor. </title> <booktitle> 8th International Software Process Workshop: State of the Practice in Process Technology, </booktitle> <address> Wadern, Germany, March 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Environment instances are maintained by trained process engineers who define and evolve project-specific process models. Enaction usually enforces and/or automates (portions of) the desired process on behalf of a team of environment users (see, e.g., <ref> [Sch93, ICS93] </ref>). Many PMLs are based to some extent on notational paradigms originally devised for other purposes.
Reference: [SHO90] <author> Stanley M. Sutton, Jr., Dennis Heimbigner, and Leon J. Osterweil. </author> <title> Language constructs for managing change in process-centered environments. </title> <editor> In Richard N. Taylor, editor, </editor> <booktitle> 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 206-217, </pages> <address> Irvine CA, </address> <month> December </month> <year> 1990. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: It can be called as a function, to return a truth value, or it can be enforced. When a predicate is enforced, then no operation may leave the predicate violated, except as specifically allowed within one of APPL/A's transaction-like statements <ref> [SHO90] </ref>.
Reference: [Sut90] <author> Stanley M. Sutton, Jr. APPL/A: </author> <title> A Prototype Language for Software-Process Programming. </title> <type> PhD thesis, </type> <institution> University of Colorado, </institution> <year> 1990. </year>
Reference-contexts: Enaction usually enforces and/or automates (portions of) the desired process on behalf of a team of environment users (see, e.g., [Sch93, ICS93]). Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A <ref> [Sut90] </ref> extends Ada, Funsoft nets [Gru91] are based on Petri nets, AP5 [Coh86] uses OPS5-like production system rules, Darwin [Min91] employs Prolog-like logic programming rules, Adele [BEM91] follows database triggers, HFSP [Kat89] is similar to attribute grammars, etc.
Reference: [Tho89] <author> Ian Thomas. </author> <title> PCTE interfaces: Supporting tools in software-engineering environments. </title> <journal> IEEE Software, </journal> <pages> pages 15-23, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The Accueil de Logiciel Futur (ALF) environment employs a sophisticated multi-paradigm process modeling formalism, called the Model for Assisted Software Processes (MASP) [OZG91]. In addition to an object model based on PCTE class definitions <ref> [Tho89] </ref>, the MASP notation has five components: 1. A set of operator types that define individual process steps in terms of their pre-conditions and post-conditions, expressed in first-order logic. 30 Kaiser, Popovich and Ben-Shaul 2. A set of expressions.
Reference: [Wil88] <author> Lloyd G. Williams. </author> <title> Software process modeling: A behavioral approach. </title> <booktitle> In 10th International Conference on Software Engineering, </booktitle> <pages> pages 174-186, </pages> <address> Raffles City, Singapore, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: The only modification to MARVEL itself was the addition of a 750-line module in the process engine. The idea of implementing constrained expressions in terms of MARVEL was first suggested by Williams <ref> [Wil88] </ref>, although he did not express the idea as a multi-level process language, and did not undertake any implementation effort. We motivate our approach by presenting a small process fragment taken from the ISPW7 example problem that requires modeling of both topology and constraints.
References-found: 48

