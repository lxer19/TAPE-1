URL: ftp://ftp.cs.virginia.edu/pub/techreports/IPC-89-02.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Abstract-found: 0
Intro-found: 0
Reference: [AgG89] <author> R. Agrawal and N. H. Gehani, </author> <title> ODE (Object Database and Environment): The Language and the Data Model, </title> <booktitle> Proc. 1989 ACM SIGMOD Conf. </booktitle> <month> 18,2 (June </month> <year> 1989), </year> <pages> 36-45. </pages>
Reference-contexts: However, changing this limitation as in <ref> [AgG89] </ref>, would effectively yield fixpoint queries [AhU79]. 30 7. Attribute and Map Inverses 7.1. General Description ADAMS attributes and maps are, by design, single valued. Expressions of the form &lt;element_desig&gt;.<attr_desig> and &lt;element_desig&gt;.&lt;map_desig&gt; denote a single data value or ADAMS element, respectively.
Reference: [AhU79] <author> A. V. Aho and J. D. Ullman, </author> <title> Universality of Data Retrieval Languages, </title> <booktitle> Proc. 6th ACM ACM Symp. on Prin. of Programming Languages, </booktitle> <address> San Antonio, TX, </address> <month> Jan. </month> <year> 1979, </year> <pages> 110-120. </pages>
Reference-contexts: However, changing this limitation as in [AgG89], would effectively yield fixpoint queries <ref> [AhU79] </ref>. 30 7. Attribute and Map Inverses 7.1. General Description ADAMS attributes and maps are, by design, single valued. Expressions of the form &lt;element_desig&gt;.<attr_desig> and &lt;element_desig&gt;.&lt;map_desig&gt; denote a single data value or ADAMS element, respectively.
Reference: [ACO85] <author> A. Albano, L. Cardelli and R. Orsini, </author> <title> Galileo: A Strongly Typed Interactive Conceptual Lanugage, </title> <journal> ACM Trans. Database Systems 10,2 (June 1985), </journal> <pages> 230-260. </pages>
Reference-contexts: It is relatively easy to learn and to implement. A common problem that arises when older computational forms are extended is that they become quite complex. There are special cases to learn, and more importantly, to implement. An example is Galileo <ref> [ACO85] </ref>, a strongly typed interactive language which embraces many pre-defined special types. Our goal has been to keep the number of basic constructs to a minimum. To this end, we envision sets as the basic aggregation concept.
Reference: [BuA86] <author> P. Buneman and M. Atkinson, </author> <title> Inheritance and Persistence in Database Programming Languages, </title> <booktitle> Proc. ACM SIGMOD Conf. </booktitle> <month> 15,2 (May </month> <year> 1986), </year> <pages> 4-15. </pages>
Reference-contexts: In many languages, such as Algol and Pascal [JeW75], they are a kind of stepchild which is explicitly disavowed by the parent language In others, only inherently sequential stream I/O is supported. None, with the possible exception of persistent Pascal <ref> [BuA86, CAD87] </ref>, employ a computational model in which the process is coequal with a permanent database from which specific data items are directly accessible. ADAMS was created in response to these kinds of perceived deficiencies. This report represents the combined design efforts of its authors over a three month period.
Reference: [Car84] <author> L. Cardelli, </author> <title> A Semantics of Multiple Inheritance, in Semantics of Data Types, </title> <booktitle> Lecture Notes in CS 173, </booktitle> <publisher> Springer Verlag , June 1984, </publisher> <pages> 51-67. </pages>
Reference-contexts: Actual stored data values are drawn from user definable codomains. It is possible to create sets of elements in ADAMS, but not sets of data values. Every ADAMS element must belong to a class. The class system supports multiple inheritance <ref> [Car84] </ref>. In this regard, and in its syntax and usage, ADAMS is a semantic database system in the sense of [HuK87]. Probably the most important aspect of ADAMS is its treatment of names.
Reference: [CAD87] <author> R. L. Cooper, M. P. Atkinson, A. Dearie and D. Abderrahmane, </author> <title> Constructing Database Systems in a Persistent Environment, </title> <booktitle> Proc. 13th VLDB Conf., </booktitle> <address> Brighton, England, </address> <month> Sep. </month> <year> 1987, </year> <pages> 117-125. </pages>
Reference-contexts: In many languages, such as Algol and Pascal [JeW75], they are a kind of stepchild which is explicitly disavowed by the parent language In others, only inherently sequential stream I/O is supported. None, with the possible exception of persistent Pascal <ref> [BuA86, CAD87] </ref>, employ a computational model in which the process is coequal with a permanent database from which specific data items are directly accessible. ADAMS was created in response to these kinds of perceived deficiencies. This report represents the combined design efforts of its authors over a three month period.
Reference: [DGS88] <author> D. J. DeWitt, S. Ghandeharizadeh and D. Schneider, </author> <title> A Performance Analysis of the Gamma Database Machine, </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Chicago, </address> <month> June </month> <year> 1988, </year> <pages> 350-360. </pages>
Reference-contexts: Parallelizability: The language paradigm of existing database systems is based on sequential processes running on a single processor. Given a parallel operating environment, one can implement utility processes in parallel as in <ref> [DGS88] </ref>, but there is seldom facilities for a programmer to exploit the inherent possibility of parallel data access at the applications level.
Reference: [FeR69] <author> J. Feldman and P. Rovner, </author> <title> An Algol-based Associative Language, </title> <journal> Comm. ACM 14,10 (Oct. </journal> <year> 1969), </year> <pages> 439-449. </pages>
Reference-contexts: The first case would yield all elements "who major in CS" as above. One of the earliest treatments of data representation by means of ordered triples is the seminal LEAP system <ref> [FeR69] </ref> which simulated associative memory by hash coding. However, this triple notation by itself is syntactically incomplete. The elements - x of the inverse set must all belong to some class; and that class must be specified.
Reference: [HuK87] <author> R. Hull and R. King, </author> <title> Semantic Database Modeling: Survey, Applications, and Research Issues, </title> <journal> Computing Surveys 19,3 (Sep. </journal> <year> 1987), </year> <pages> 201-260. </pages>
Reference-contexts: Every ADAMS element must belong to a class. The class system supports multiple inheritance [Car84]. In this regard, and in its syntax and usage, ADAMS is a semantic database system in the sense of <ref> [HuK87] </ref>. Probably the most important aspect of ADAMS is its treatment of names. Although there are many different ways of referencing desired data elements and their values [KhC86], at some fundamental level data access depends on the ability to name elements, or sets of elements, in the database.
Reference: [JeW75] <author> K. Jensen and N. Wirth, </author> <title> Pascal: User Manual and Report, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: To fully exploit the potential of tightly coupled parallel processing, one needs a language that encourages parallel database access and processing. (4) Finally, we note the awkward status of read/write statements in traditional programming languages. In many languages, such as Algol and Pascal <ref> [JeW75] </ref>, they are a kind of stepchild which is explicitly disavowed by the parent language In others, only inherently sequential stream I/O is supported.
Reference: [KhC86] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> Object Identity, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: In this regard, and in its syntax and usage, ADAMS is a semantic database system in the sense of [HuK87]. Probably the most important aspect of ADAMS is its treatment of names. Although there are many different ways of referencing desired data elements and their values <ref> [KhC86] </ref>, at some fundamental level data access depends on the ability to name elements, or sets of elements, in the database. <p> But simple "literal names" turn out to be inadequate for denoting and describing vast collections of persistent data. We find we want to be able to parameterize names and to be able to subscript them as well. Moreover, as noted by <ref> [KhC86] </ref> naming is not the only way of identifying objects. Objects, or entities, may be designated in a variety of ways.
Reference: [Klu88] <author> C. Klumpp, </author> <title> Implementation of an ADAMS Prototype: the ADAMS Preprocessor, </title> <institution> IPC TR-88-005, Institute for Parallel Computation, Univ. of Virginia, </institution> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: ADAMS was created in response to these kinds of perceived deficiencies. This report represents the combined design efforts of its authors over a three month period. It builds on several earlier reports, notably [PSF87] which was later presented at the 1988 Hypercube Conference as [PSF88], [PFW88], and <ref> [Klu88] </ref>. Each of these has presented fragments of ADAMS syntax. But, much of this early syntax has been modified in the light of trial usage, especially of the prototype interpreter described in [Klu88]. The reader is warned to use only this, most recent, version of ADAMS. 1.1. <p> several earlier reports, notably [PSF87] which was later presented at the 1988 Hypercube Conference as [PSF88], [PFW88], and <ref> [Klu88] </ref>. Each of these has presented fragments of ADAMS syntax. But, much of this early syntax has been modified in the light of trial usage, especially of the prototype interpreter described in [Klu88]. The reader is warned to use only this, most recent, version of ADAMS. 1.1. Goals of ADAMS The overriding goal in designing ADAMS was to create a flexible database system that would actually be used by a large number of applications programmers. <p> The first is designed to illustrate and exercise those features which are used in relational and semantic database models. It was described in [PSF88] and served as a prototype implementation test vehicle in <ref> [Klu88] </ref>. The second database will be used to illustrate scientific usage. A practice used by the ADAMS group, is to capitalize the names of generic sets, such as codomains and classes, and to represent specific entity instances in lower case letters. <p> For example, in the statement &lt;< advisor instantiates_a FACULTY_MAP, scope is USER &gt;> both advisor and FACULTY_MAP are literal strings. This can be quite confusing at first. In <ref> [Klu88] </ref> we suggested changing the syntax to read &lt;< "advisor" instantiates_a "FACULTY_MAP", scope is USER &gt;> but this suggestion seems ill-advised. It would make the declaration of ADAMS names much clearer, but it would make their subsequent use more awkward.
Reference: [Mai83] <author> D. Maier, </author> <title> The Theory of Relational Databases, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1983. </year>
Reference-contexts: It is impossible to retrieve a set of "data values". (2) The class of a retrieval set is well defined; it must be the same as &lt;set_desig&gt;. 31 (3) Because all elements satisfying the predicate expression are restricted to membership in &lt;set_desig&gt;, this retrieval expression must be "safe" (p.247, <ref> [Mai83] </ref>). 7.4. Examples The following straight forward example retrieves CS majors.
Reference: [Mos85] <author> J. E. B. Moss, </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: What is clearly required is that no persistent ADAMS construct (class or instance) reference a non-persistent construct. Only this is currently enforced. 41 10. Transactions 10.1. General Description ADAMS provides the user with nested transactions based on the well-known model of Moss <ref> [Mos85] </ref>. These transactions are designed only to provide concurrency control. Fault tolerance and reliability control will be buried within the ADAMS implementation and will not be accessible to the user. However, the casual user need not become involved with either the transaction concept or concurrency control at all.
Reference: [OBB89] <author> A. Ohori, P. Buneman and V. </author> <title> Breazu-Tannen, </title> <booktitle> Database Programming in Machiavelli </booktitle>
Reference-contexts: A goal of ADAMS, as well as many other object-oriented database systems such as <ref> [OBB89] </ref>, is to enable static type checking at compile time and minimal interaction with the dictionary at run time. Unfortunately, if one is dealing with persistent data this is easier said than done.
References-found: 15

