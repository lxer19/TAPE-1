URL: http://www.cs.utah.edu/~cs606/papers/sigops92.ps
Refering-URL: http://www.cs.utah.edu/~cs606/
Root-URL: 
Email: E-mail: Peter.Dickman@inria.fr  
Phone: Telephone: +33 (1) 39 63 52 93  
Title: Contrasting Fragmented Objects with Uniform Transparent Object References for Distributed Programming  
Author: Peter Dickman, Mesaac Makpangou and Marc Shapiro 
Address: Rocquencourt, BP 105, 78153 Le Chesnay Cedex, France  
Affiliation: Projet SOR, INRIA  
Abstract: The fragmented object model is compared with the more usual paradigm of uniform transparent references to objects in a distributed system. Having considered both models in terms of a variety of issues, the impact on system builders and application programmers is briefly noted. Although the fragmented object model is somewhat more powerful, in particular in its support for replicated objects, it is also more costly. The possibility of combining the two models to form a new hybrid is considered. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Khayri A. M. Ali and Seif Haridi. </author> <title> Global garbage collection for distributed heap storage systems. </title> <type> Technical Report SICS R87005, </type> <institution> Swedish Institute of Computer Science, Sp-anga, Sweden, </institution> <year> 1987. </year>
Reference-contexts: The BOAR library [21], now being developed, includes support classes for general persistent objects. 2.4 Garbage Collection Distributed garbage collection is a difficult problem, since all known algorithms that can collect cycles are either not fault tolerant <ref> [13, 1] </ref>, can be slow to recover garbage [17] or are not scalable [25]. Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage [24, 6] offers significant advantages in reducing the work required of these complete techniques.
Reference: [2] <author> M.P. Atkinson. </author> <title> PS-Algol: An Algol with a persistent heap. </title> <journal> ACM Sigplan Notices, </journal> <volume> 17(7) </volume> <pages> 24-31, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: For remote objects, a method invocation through the reference leads to marshalling of the parameters and their transmission by a remote procedure call (RPC) layer (e.g. [4]); whereas for persistent objects, such an invocation may lead to the object being mapped into an address space from secondary storage (e.g. <ref> [2] </ref>). Such references have been offered in a large number of systems, including [2, 7, 10, 15]. The principal motivation for such references is that they can be used to provide a number of transparency mechanisms [12]. <p> Such references have been offered in a large number of systems, including <ref> [2, 7, 10, 15] </ref>. The principal motivation for such references is that they can be used to provide a number of transparency mechanisms [12]. In particular, the location of objects, how they are accessed and whether or not they are persistent are all normally concealed from the client.
Reference: [3] <author> Kenneth Birman, Andre Schiper, and Pat Stephen-son. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Communications primitives, such as causal or atomic multicast <ref> [3] </ref>, must be efficiently implemented, and this is not easy to achieve as part of a user-level library.
Reference: [4] <author> A.D. Birrell and B.J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: For remote objects, a method invocation through the reference leads to marshalling of the parameters and their transmission by a remote procedure call (RPC) layer (e.g. <ref> [4] </ref>); whereas for persistent objects, such an invocation may lead to the object being mapped into an address space from secondary storage (e.g. [2]). Such references have been offered in a large number of systems, including [2, 7, 10, 15].
Reference: [5] <author> Daniel G. Bobrow. </author> <title> Managing reentrant stuctures using reference counts. </title> <journal> ACM Transactions on Programming languages and Systems, </journal> <volume> 2(3) </volume> <pages> 269-273, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage [24, 6] offers significant advantages in reducing the work required of these complete techniques. Such benefits rely, however, on distributed cycles being relatively 2 rare. Alternative approaches, such as <ref> [5, 14] </ref>, are more appropriate if small cycles are common and predictable. The idea is that small cyclic structures can be managed by the garbage collector as a single entity, thereby concealing the presence of the cycle and permitting acyclic garbage detection techniques to be used.
Reference: [6] <author> Peter Dickman. </author> <title> Optimising weighted reference counts for scalable fault-tolerant distributed object-support systems. </title> <note> (To appear, based on material in [7]). </note>
Reference-contexts: Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage <ref> [24, 6] </ref> offers significant advantages in reducing the work required of these complete techniques. Such benefits rely, however, on distributed cycles being relatively 2 rare. Alternative approaches, such as [5, 14], are more appropriate if small cycles are common and predictable.
Reference: [7] <author> Peter Dickman. </author> <title> Distributed Object Management in a Non-Small Graph of Autonomous Networks with Few Failures. </title> <type> PhD thesis, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1992. </year>
Reference-contexts: Such references have been offered in a large number of systems, including <ref> [2, 7, 10, 15] </ref>. The principal motivation for such references is that they can be used to provide a number of transparency mechanisms [12]. In particular, the location of objects, how they are accessed and whether or not they are persistent are all normally concealed from the client. <p> It follows that optimi-sations which ensure that calls are local have benefits in terms of program simplification as well as run-time efficiency. In the UTOR model special support, such as the Bellerophon colocator references <ref> [7] </ref>, is required to achieve this. The fragmented object model permits the designer of an FO class to handle such problems within the fragment, however this will not always be possible.
Reference: [8] <author> Peter Dickman and Mesaac Makpangou. </author> <title> A refinement of the fragmented object model. </title> <booktitle> In Proceedings of the Third International Workshop on Object Orientation in Operating Systems, </booktitle> <year> 1992. </year> <note> (To appear). </note>
Reference-contexts: The first is that of the uniform transparent object reference (UTOR), which is widely used in current distributed systems, whilst the second is that of the fragmented object (FO). The presentation of fragmented objects draws heavily on recent work <ref> [8] </ref>, in which the model is refined, providing rather more detail than has previously been available. It therefore differs somewhat from earlier published material on this topic [19, 20]. In Section 2 the approaches are contrasted on an issue by issue basis. <p> This decision may thus be based on, for example, the number of extant fragments and the current state of the object. A detailed explanation of this is given in <ref> [8] </ref>. It is not yet clear whether such a hybrid represents a significant improvement over the FO model.
Reference: [9] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: This situation can be compared with the provision of low-level types in many object-based programming languages. Whilst it is theoretically possible to maintain the object model down to the bit-level [12] this is, in practice, unhelpful and the usual approach <ref> [9, 22, 10] </ref> is to break the model at some level. That is, to provide built-in classes which could not, themselves, be reasonably implemented in the model presented to language programmers. A minimal UTOR model is simpler to implement, but lacks many of the facilities of any FO implementation.
Reference: [10] <author> Stephen M. V. Hailes. </author> <title> The Design and Implementation of Troy, a Distributed Object-Based Language. </title> <type> PhD thesis, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1992. </year>
Reference-contexts: Such references have been offered in a large number of systems, including <ref> [2, 7, 10, 15] </ref>. The principal motivation for such references is that they can be used to provide a number of transparency mechanisms [12]. In particular, the location of objects, how they are accessed and whether or not they are persistent are all normally concealed from the client. <p> This situation can be compared with the provision of low-level types in many object-based programming languages. Whilst it is theoretically possible to maintain the object model down to the bit-level [12] this is, in practice, unhelpful and the usual approach <ref> [9, 22, 10] </ref> is to break the model at some level. That is, to provide built-in classes which could not, themselves, be reasonably implemented in the model presented to language programmers. A minimal UTOR model is simpler to implement, but lacks many of the facilities of any FO implementation.
Reference: [11] <author> Kenneth Graham Hamilton. </author> <title> A Remote Procedure Call System. </title> <type> PhD thesis, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1984. </year> <note> (Available as Univ. </note> <institution> Cam-bridge Computer Lab. </institution> <type> Technical Report 70). </type>
Reference-contexts: The assumption must be, however, that all invocations are remote (rather than all being local), as otherwise the additional failure modes introduced by network problems and failed remote nodes cannot be adequately handled <ref> [11] </ref>. In the UTOR model this means that additional exceptional returns may occur. Treating all invocations as potentially remote can lead to inefficiencies, since large amounts of unnecessary error handling code may be produced.
Reference: [12] <author> A.J. Herbert and J. Monk, </author> <title> editors. ANSA Reference Manual. </title> <address> APM, Cambridge (UK), </address> <year> 1987. </year>
Reference-contexts: Such references have been offered in a large number of systems, including [2, 7, 10, 15]. The principal motivation for such references is that they can be used to provide a number of transparency mechanisms <ref> [12] </ref>. In particular, the location of objects, how they are accessed and whether or not they are persistent are all normally concealed from the client. Furthermore, because of this, system-level policies, for example whether objects are migrated or remotely invoked, can be cleanly encapsulated. <p> This situation can be compared with the provision of low-level types in many object-based programming languages. Whilst it is theoretically possible to maintain the object model down to the bit-level <ref> [12] </ref> this is, in practice, unhelpful and the usual approach [9, 22, 10] is to break the model at some level. That is, to provide built-in classes which could not, themselves, be reasonably implemented in the model presented to language programmers.
Reference: [13] <author> Paul Hudak and Robert M. Keller. </author> <title> Garbage collection and task deletion in distributed applicative programming. </title> <booktitle> In Proceedings of the 1982 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 168-178, </pages> <year> 1982. </year>
Reference-contexts: The BOAR library [21], now being developed, includes support classes for general persistent objects. 2.4 Garbage Collection Distributed garbage collection is a difficult problem, since all known algorithms that can collect cycles are either not fault tolerant <ref> [13, 1] </ref>, can be slow to recover garbage [17] or are not scalable [25]. Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage [24, 6] offers significant advantages in reducing the work required of these complete techniques.
Reference: [14] <author> Yuuji Ichisugi and Akinori Yonezawa. </author> <title> Distributed garbage collection using group reference counting. Presented at the OOPSLA/ECOOP '90 Workshop on `Garbage Collection in Object-Oriented Systems', </title> <note> available by anonymous FTP from ftp.diku.dk (129.142.96.1) in /pub/GC90, </note> <year> 1990. </year>
Reference-contexts: Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage [24, 6] offers significant advantages in reducing the work required of these complete techniques. Such benefits rely, however, on distributed cycles being relatively 2 rare. Alternative approaches, such as <ref> [5, 14] </ref>, are more appropriate if small cycles are common and predictable. The idea is that small cyclic structures can be managed by the garbage collector as a single entity, thereby concealing the presence of the cycle and permitting acyclic garbage detection techniques to be used.
Reference: [15] <author> Eric Jul, Henry Levy, Norman Hutchinson, and An-drew Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Such references have been offered in a large number of systems, including <ref> [2, 7, 10, 15] </ref>. The principal motivation for such references is that they can be used to provide a number of transparency mechanisms [12]. In particular, the location of objects, how they are accessed and whether or not they are persistent are all normally concealed from the client.
Reference: [16] <author> P.J. Leach, B.L. Stumpf, J.A. Hamilton, and P.H. Levine. </author> <title> UIDs as internal names in distributed systems. </title> <booktitle> In Proceedings of the 1st Annual ACM Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 34-41, </pages> <year> 1982. </year>
Reference-contexts: two models in the previous section, we now present the differences in terms of: the support required of the run-time system; how systems are built in the two models; and their impact on applications programming. 3.1 Runtime Support The support required for a UTOR model, for example Leach et al's <ref> [16] </ref>, is a subset of that required for an FO model. In both systems it is essential that local objects and references are supported with additional mechanisms that permit messages to be passed between nodes.
Reference: [17] <author> Barbara Liskov and Rivka Ladin. </author> <title> Highly-available distributed services and fault-tolerant distributed garbage collection. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 29-39, </pages> <year> 1986. </year>
Reference-contexts: The BOAR library [21], now being developed, includes support classes for general persistent objects. 2.4 Garbage Collection Distributed garbage collection is a difficult problem, since all known algorithms that can collect cycles are either not fault tolerant [13, 1], can be slow to recover garbage <ref> [17] </ref> or are not scalable [25]. Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage [24, 6] offers significant advantages in reducing the work required of these complete techniques. Such benefits rely, however, on distributed cycles being relatively 2 rare.
Reference: [18] <author> Mesaac Makpangou and Yvon Gourhant. </author> <title> Fragmented objects: A building block for distributed object-support operating systems. </title> <booktitle> Newsletter of the IEEE Computer Society Technical Committee on Operating Systems and Application Environments, </booktitle> <volume> 5(1) </volume> <pages> 22-25, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, because of this, system-level policies, for example whether objects are migrated or remotely invoked, can be cleanly encapsulated. However, these policies would be built into the run-time system and could not easily be changed. 1.2 Fragmented Objects Fragmented objects <ref> [18] </ref> are a programming paradigm for distributed systems which naturally extends the proxy principle of [23]. A fragmented object appears, to a client, to be a local object.
Reference: [19] <author> Mesaac Makpangou, Yvon Gourhant, Jean-Pierre Le Narzul, and Marc Shapiro. </author> <title> Structuring distributed applications as fragmented objects. </title> <institution> Rapport de Recherche 1404, INRIA Rocquencourt, France, </institution> <year> 1991. </year>
Reference-contexts: The presentation of fragmented objects draws heavily on recent work [8], in which the model is refined, providing rather more detail than has previously been available. It therefore differs somewhat from earlier published material on this topic <ref> [19, 20] </ref>. In Section 2 the approaches are contrasted on an issue by issue basis. Following this, in Section 3, is a comparison of the models in terms of the support they require and the way they are intended to be used within systems and by application programmers.
Reference: [20] <author> Mesaac Makpangou, Yvon Gourhant, Jean-Pierre Le Narzul, and Marc Shapiro. </author> <title> Fragmented objects for distributed abstractions. In T.L. </title> <editor> Casavant and M. Sing-hal, editors, </editor> <booktitle> Advances in Distributed Computing: Concepts and Design. IEEE-CS, </booktitle> <year> 1992. </year> <note> (To appear). </note>
Reference-contexts: The presentation of fragmented objects draws heavily on recent work [8], in which the model is refined, providing rather more detail than has previously been available. It therefore differs somewhat from earlier published material on this topic <ref> [19, 20] </ref>. In Section 2 the approaches are contrasted on an issue by issue basis. Following this, in Section 3, is a comparison of the models in terms of the support they require and the way they are intended to be used within systems and by application programmers.
Reference: [21] <author> Mesaac Makpangou, Yvon Gourhant, and Marc Shapiro. BOAR: </author> <title> A library of fragmented object types for distributed abstractions. </title> <booktitle> In Proceedings of the International Workshop on Object Orientation in Operating Systems, </booktitle> <year> 1991. </year>
Reference-contexts: This issue is closely related to replication as the reference to a persistent object is, in effect, a reference to a group of replicas: one or more on disk and others in memory. The BOAR library <ref> [21] </ref>, now being developed, includes support classes for general persistent objects. 2.4 Garbage Collection Distributed garbage collection is a difficult problem, since all known algorithms that can collect cycles are either not fault tolerant [13, 1], can be slow to recover garbage [17] or are not scalable [25].
Reference: [22] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: This situation can be compared with the provision of low-level types in many object-based programming languages. Whilst it is theoretically possible to maintain the object model down to the bit-level [12] this is, in practice, unhelpful and the usual approach <ref> [9, 22, 10] </ref> is to break the model at some level. That is, to provide built-in classes which could not, themselves, be reasonably implemented in the model presented to language programmers. A minimal UTOR model is simpler to implement, but lacks many of the facilities of any FO implementation.
Reference: [23] <author> Marc Shapiro. </author> <title> Structure and encapsulation in distributed systems. </title> <booktitle> In Proceedings of the 6th International Conference on Distributed Computer Systems, </booktitle> <pages> pages 198-204, </pages> <year> 1986. </year>
Reference-contexts: However, these policies would be built into the run-time system and could not easily be changed. 1.2 Fragmented Objects Fragmented objects [18] are a programming paradigm for distributed systems which naturally extends the proxy principle of <ref> [23] </ref>. A fragmented object appears, to a client, to be a local object. However, the distributed clients of a fragmented object are, in fact, each associated with a local fragment and these fragments themselves form a single distributed object.
Reference: [24] <author> Marc Shapiro, Peter Dickman, and David Plainfosse. </author> <title> Robust distributed references and acyclic garbage collection. </title> <booktitle> In Proceedings of the 11th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1992. </year> <note> (To appear). </note>
Reference-contexts: Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage <ref> [24, 6] </ref> offers significant advantages in reducing the work required of these complete techniques. Such benefits rely, however, on distributed cycles being relatively 2 rare. Alternative approaches, such as [5, 14], are more appropriate if small cycles are common and predictable.
Reference: [25] <author> Stephen C. Vestal. </author> <title> Garbage Collection: An Exercise in Distributed Fault-Tolerant Programming. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, University of Washington, </institution> <address> Seattle WA, USA, </address> <year> 1987. </year> <note> (Available as Univ. Washing-ton CS Technical Report 87-01-03). Acknowledgements The principal author of this paper is funded by an ERCIM Fellowship. Work on the FO model is also supported through the CEC Esprit project `Harness'. 5 </note>
Reference-contexts: The BOAR library [21], now being developed, includes support classes for general persistent objects. 2.4 Garbage Collection Distributed garbage collection is a difficult problem, since all known algorithms that can collect cycles are either not fault tolerant [13, 1], can be slow to recover garbage [17] or are not scalable <ref> [25] </ref>. Supplementing such algorithms with an efficient fault-tolerant mechanism that collects all, or almost all, acyclic garbage [24, 6] offers significant advantages in reducing the work required of these complete techniques. Such benefits rely, however, on distributed cycles being relatively 2 rare.
References-found: 25

