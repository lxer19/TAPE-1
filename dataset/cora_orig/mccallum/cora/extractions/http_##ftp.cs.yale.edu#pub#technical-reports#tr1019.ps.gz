URL: http://ftp.cs.yale.edu/pub/technical-reports/tr1019.ps.gz
Refering-URL: http://ftp.cs.yale.edu/pub/technical-reports/
Root-URL: http://www.cs.yale.edu
Title: Malicious Membership Queries and Exceptions  
Author: Dana Angluin Martinch Krikis 
Note: This research was supported by the National Science Foundation, grant CCR-9213881.  
Date: March 1994  
Affiliation: Yale University Department of Computer Science  
Pubnum: YALEU/DCS/TR-1019  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Angluin. </author> <title> Learning regular sets from queries and counterexamples. </title> <journal> Inform. Comput., </journal> <volume> 75(2) </volume> <pages> 87-106, </pages> <month> November </month> <year> 1987. </year> <month> 30 </month>
Reference-contexts: As corollaries of Theorem 3 we have the following. Corollary 4 The class of regular languages, represented by DFA's, is learnable in polynomial time with equivalence and malicious membership queries. Proof: In [5] it was shown that this class of concepts is polynomially closed under finite exceptions. In <ref> [1] </ref> it was shown that it is learnable in polynomial time using membership and equivalence queries. Corollary 5 The class of boolean decision trees is learnable in polynomial time with extended equivalence and malicious membership queries.
Reference: [2] <author> D. Angluin. </author> <title> Queries and concept learning. </title> <journal> Machine Learning, </journal> <volume> 2(4) </volume> <pages> 319-342, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Similarly, for a negative counterexample v, if x v then x has to be a negative point of the target formula. For this reason we define a subroutine CheckedMQ and use it instead of a membership query. The subroutine is given in Figure 1. As in <ref> [2] </ref> and [4], our algorithm also uses a subroutine Reduce in order to move down in the lattice from a positive counterexample. All the membership queries are done using the subroutine CheckedMQ, which possibly lets the algorithm avoid some incorrect answers. The subroutine Reduce is given in Figure 2. <p> This is done by another very simple subroutine TheFunction, given in Figure 5. TheFunction (x) f Return 1 h (x) Else Return h (x) g As in <ref> [2] </ref>, [4] and Section 3, our algorithm also uses a subroutine Reduce to move down in the lattice from a positive counterexample. Its goal is to reduce the positive counterexample to some point which can be added as a term to the formula h.
Reference: [3] <author> D. Angluin. </author> <title> Exact learning of -DNF formulas with malicious membership queries. </title> <type> Technical Report YALEU/DCS/TR-1020, </type> <institution> Yale University Department of Computer Science, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: These include DFA's and boolean decision trees. However, this result leaves the question open for other classes, polynomial-time learnable with equivalence and (vanilla) membership queries, such as read once formulas, that are not polynomially closed under finite exceptions. A start in this direction is made in <ref> [3] </ref>, which gives a randomized polynomial-time algorithm to learn -DNF formulas with equivalence and malicious membership queries.
Reference: [4] <author> D. Angluin and D. K. </author> <title> Slonim. Randomly fallible teachers: learning monotone DNF with an incomplete membership oracle. </title> <journal> Machine Learning, </journal> <volume> 14(1) </volume> <pages> 7-26, </pages> <year> 1994. </year>
Reference-contexts: The "I don't know" answers are determined by independent coin flips the first time each query is made <ref> [4] </ref>. They give a polynomial-time algorithm to learn monotone DNF formulas with high probability in this setting. They also show that a variant of this algorithm can deal with one-sided errors, assuming that no negative point is classified as positive. <p> Similarly, for a negative counterexample v, if x v then x has to be a negative point of the target formula. For this reason we define a subroutine CheckedMQ and use it instead of a membership query. The subroutine is given in Figure 1. As in [2] and <ref> [4] </ref>, our algorithm also uses a subroutine Reduce in order to move down in the lattice from a positive counterexample. All the membership queries are done using the subroutine CheckedMQ, which possibly lets the algorithm avoid some incorrect answers. The subroutine Reduce is given in Figure 2. <p> This is done by another very simple subroutine TheFunction, given in Figure 5. TheFunction (x) f Return 1 h (x) Else Return h (x) g As in [2], <ref> [4] </ref> and Section 3, our algorithm also uses a subroutine Reduce to move down in the lattice from a positive counterexample. Its goal is to reduce the positive counterexample to some point which can be added as a term to the formula h.
Reference: [5] <author> R. Board and L. Pitt. </author> <title> On the necessity of Occam algorithms. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 100 </volume> <pages> 157-184, </pages> <year> 1992. </year>
Reference-contexts: This definition differs from the similar one given in <ref> [5] </ref> because we do not require that there exists a polynomial-time algorithm that given a concept and a list of exceptions produces the new concept. However, for the classes that we consider there are such algorithms. <p> This concludes the proof of Theorem 1. 5 Finite Exceptions The relevant definitions for this section were introduced in Section 2.2. Here we give a few lemmas and examples. Example 1 The class of regular languages represented by DFA's is polynomially closed under finite exceptions. In <ref> [5] </ref> there is given an algorithm that takes as input 17 a DFA M and an exception set S and produces a new DFA for xcpt (M; S). Its size is polynomial in the size of M and S. <p> Its size is polynomial in the size of M and S. Example 2 Another example of a class that is polynomially closed under finite exceptions is the class of boolean decision trees. This result is taken from <ref> [5] </ref> but since the construction is not given there, we sketch it here. Lemma 3 The class of boolean decision trees is polynomially closed under finite exceptions. Proof: Let T be a decision tree on n variables. Let S be the exception set for T . <p> Note that stronger bounds on the size of the new formula can be obtained by using the result in [14]. We, however, chose to present a simpler argument. Also note that the size bound is insufficient for strong polynomial closure under exception lists as defined in <ref> [5] </ref>. Example 5 As our final example we show that any class that is obtained by adding exception tables to another class is polynomially closed under finite exceptions. Lemma 5 Let (R; Dom; ) be any class of concepts. <p> This concludes the proof of Theorem 3. As corollaries of Theorem 3 we have the following. Corollary 4 The class of regular languages, represented by DFA's, is learnable in polynomial time with equivalence and malicious membership queries. Proof: In <ref> [5] </ref> it was shown that this class of concepts is polynomially closed under finite exceptions. In [1] it was shown that it is learnable in polynomial time using membership and equivalence queries.
Reference: [6] <author> N. Bshouty. </author> <title> Exact learning via the monotone theory. </title> <booktitle> In Proc. of the 34th Symposium on the Foundations of Comp. Sci., </booktitle> <pages> pages 302-311. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1993. </year>
Reference-contexts: Corollary 5 The class of boolean decision trees is learnable in polynomial time with extended equivalence and malicious membership queries. Proof: Lemma 3 shows that the class of boolean decision trees is polynomially closed under finite exceptions. In <ref> [6] </ref> it was shown that it is learnable in polynomial time using membership and extended equivalence queries. Corollary 6 The class of monotone DNF formulas with finite exceptions is learnable in polynomial time with equivalence and malicious membership queries.
Reference: [7] <author> T. Dean, D. Angluin, K. Basye, S. Engelson, L. Kaelbling, E. Kokkevis, and O. Maron. </author> <title> Inferring finite automata with stochastic output functions and an application to map learning. </title> <booktitle> In Proceedings of AAAI-92, </booktitle> <pages> pages 208-214. </pages> <publisher> AAAI, </publisher> <year> 1992. </year>
Reference-contexts: A related model is considered by Dean et al. for the case of a robot learning a finite-state map of its environment using faulty sensors and reliable effectors <ref> [7] </ref>. In this model, observation errors are taken as independent as long as there is a nonempty action sequence separating them.
Reference: [8] <author> S. A. Goldman, M. J. Kearns, and R. E. Schapire. </author> <title> Exact identification of read-once formulas using fixed points of amplification functions. </title> <journal> SIAM J. Comput., </journal> <volume> 22(4) </volume> <pages> 705-726, </pages> <year> 1993. </year>
Reference-contexts: For example, Goldman, 3 Kearns and Schapire give polynomial-time algorithms for exactly learning read-once majority formulas and read-once positive NAND formulas of depth O (log n) with high probability using membership queries with high rates of persistent random noise or modest rates of persistent malicious noise <ref> [8] </ref>. As another example, the algorithm of Kushilevitz and Mansour that uses membership queries and exactly learns logarithmic depth decision trees with high probability in polynomial time seems likely to be robust under nontrivial rates of persistent random noise in the answers to queries [10].
Reference: [9] <author> M. Kearns. </author> <title> Efficient noise-tolerant learning from statistical queries. </title> <booktitle> In Proc. 25th Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pages 392-401. </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference-contexts: Algorithms that use membership queries to estimate probabilities (in the spirit of the statistical queries defined by Kearns <ref> [9] </ref>) are generally not too sensitive to small rates of random persistent errors in the answers to queries.
Reference: [10] <author> E. Kushilevitz and Y. Mansour. </author> <title> Learning decision trees using the Fourier spectrum. </title> <booktitle> In Proc. of the 23rd Symposium on Theory of Computing, </booktitle> <pages> pages 455-464. </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: As another example, the algorithm of Kushilevitz and Mansour that uses membership queries and exactly learns logarithmic depth decision trees with high probability in polynomial time seems likely to be robust under nontrivial rates of persistent random noise in the answers to queries <ref> [10] </ref>. However, other algorithms depend more strongly on the correctness of the answers to individual queries; in these cases, the existence of an error-tolerant algorithm for the problem is in question.
Reference: [11] <author> D. Ron and R. Rubinfeld. </author> <title> Learning fallible finite state automata. </title> <booktitle> In Proc. 6th Annu. Workshop on Comput. Learning Theory, </booktitle> <pages> pages 218-227. </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference-contexts: and very interesting application of the ideas of error-correcting algorithms, Ron and Rubin-feld use the criterion of PAC-identification with respect to the uniform distribution, and give a polynomial-time randomized algorithm using membership queries to learn DFA's with high rates of random persistent errors in the answers to the membership queries <ref> [11] </ref>. Algorithms that use membership queries to estimate probabilities (in the spirit of the statistical queries defined by Kearns [9]) are generally not too sensitive to small rates of random persistent errors in the answers to queries.
Reference: [12] <author> Y. Sakakibara. </author> <title> On learning from queries and counterexamples in the presence of noise. </title> <journal> Inform. Proc. Lett., </journal> <volume> 37(5) </volume> <pages> 279-284, </pages> <month> March </month> <year> 1991. </year> <month> 31 </month>
Reference-contexts: Sakakibara defines one model of non-persistent errors, in which each answer to a query may be wrong with some probability, and repeated queries constitute independent events <ref> [12] </ref>. He gives a general technique of repeating each query sufficiently often to establish the correct answer with high probability. This yields a uniform transformation of existing query algorithms.
Reference: [13] <author> L. G. Valiant. </author> <title> Learning disjunctions of conjunctions. </title> <booktitle> In Proceedings of the 9th International Joint Conference on Artificial Intelligence, </booktitle> <volume> vol. 1, </volume> <pages> pages 560-566, </pages> <address> Los Angeles, California, </address> <year> 1985. </year> <booktitle> International Joint Committee for Artificial Intelligence. </booktitle>
Reference-contexts: In both cases, the goal is to identify exactly the concept presented by the equivalence oracle. 1.1 Error Models There is a considerable body of literature on errors in examples in the PAC model, starting with the first error-tolerant algorithm in the PAC model, given by Valiant <ref> [13] </ref>.
Reference: [14] <author> Y. Zhuravlev and Y. Kogan. </author> <title> Realization of boolean functions with a small number of zeros by disjunctive normal forms, and related problems. </title> <journal> Soviet Math. Doklady, </journal> <volume> 32 </volume> <pages> 771-775, </pages> <year> 1985. </year> <month> 32 </month>
Reference-contexts: Example 4 By duality it follows that the class of CNF formulas is polynomially closed under finite exceptions. Note that stronger bounds on the size of the new formula can be obtained by using the result in <ref> [14] </ref>. We, however, chose to present a simpler argument. Also note that the size bound is insufficient for strong polynomial closure under exception lists as defined in [5].
References-found: 14

