URL: http://www.cs.ucsb.edu/conferences/java98/papers/pointers.ps
Refering-URL: http://www.cs.ucsb.edu/conferences/java98/program.html
Root-URL: http://www.cs.ucsb.edu
Email: eddemaine@uwaterloo.ca  
Title: Converting C Pointers to Java References  
Author: Erik D. Demaine 
Address: Waterloo, Ontario, Canada N2L 3G1  
Affiliation: Department of Computer Science University of Waterloo  
Abstract: We consider the problem of converting C pointers to the less flexible concept of references. Our main application is converting scientific applications from C to Java. We provide a general method to model essentially all features of pointers using references. The model is easily implemented in Java. We give optimizations that map key facilities like arrays and structures onto the obvious Java equivalents, arrays and objects. These improvements make the conversion "optimal" for all typed pointers. For untyped pointers, we can still fall back on the general model, hence providing general automatic conversion from C to Java code, whose efficiency improves with the quality of the C code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yukio Andoh. j2c/CafeBabe. </author> <title> World Wide Web. </title> <address> http://www.webcity.co.jp/info/andoh/ java/j2c.html. </address>
Reference-contexts: Section 4 discusses how this can be improved to be "optimal" for most applications. We conclude in Section 5. 1 2 Related Work Much work has been done on converting Java to C for optimization purposes; see for example Harissa [10], j2c <ref> [1] </ref>, JCC [12], and Toba [11]. However, little has been done on the reverse direction. Of particular relevance are c2j [9] and c2j++ [13]. <p> Accessing the variable corresponds to accessing the first element of the array, and the address of the variable is the array itself. Indeed, the array method is nearly identical to the object method, replacing "Int" with "int []." C Java int var; 7! int [] var = new int <ref> [1] </ref>; int ivar = 5; 7! int [] ivar = f5g; var++; 7! var [0]++; int *ptr = &var; 7! int [] ptr = var; f (ptr); 7! f (ptr); Objects and arrays are likely the only general methods for addressing basic variables. <p> C Java int a [5]; 7! int [] a = new int [5]; p++; 7! Not allowed. *p = 5; 7! p [0] = 5; int i; 7! int [] i = new int <ref> [1] </ref>; p = &i; 7! p = i; arrays. Pointing to elements of an array is not allowed. 4.3 Indexable Arrays While Java arrays J (t)[ ] adequately represent pointers to basic variables and pointers to arrays, they do not fully represent the C type tfl.
Reference: [2] <author> James W. Demmel, Stanley C. Eisenstat, John R. Gilbert, Xiaoye S. Li, and Joseph W. H. Liu. </author> <title> A supernodal approach to sparse partial pivoting. </title> <type> Technical Report UCB//CSD-95-883, </type> <institution> Computer Science Division, </institution> <address> U. C. Berkeley, </address> <month> July </month> <year> 1995. </year> <note> To appear in SIAM J. Matrix Analysis and Applications. </note>
Reference-contexts: In this paper, we discuss automatic conversion of pointers into references, with the application of converting C code into Java. Our main focus is on translating scientific applications written in C. A significant example of such a program is SuperLU <ref> [2, 3] </ref>, a state-of-the-art general sparse linear solver released in 1997 and available only in C. The rest of this paper is outlined as follows. Section 2 surveys related work. In Section 3, we give a general and flexible conversion model that provides nearly full conversion from C to Java. <p> In contrast, C allows one to add an integer (such as 1) to a pointer that points to an array, causing it to point to a particular element of the array. Such practice is common (for example, in SuperLU <ref> [2, 3] </ref>), since in C it allows efficient access to individual elements of arrays; that is, repeatedly accessing a [i] is made faster 6 by assigning p = &a [i] (or p = a+i) and then repeatedly accessing *p. <p> (int [] a, int i) f this.a = a; this.i = t; g public int [] a; public int i; g C Java int a [5]; 7! int [] a = new int [5]; int *p = a; 7! IntPointer p = new IntPointer (a, 0); p++; 7! p.i++; p <ref> [2] </ref> = 10; 7! p.a [p.i+2] = 10; i = 5; 7! i [0] = 5; One possible optimization, called unrolling, removes a level of indirection by replacing the structure with two individual variables (Figure 7). <p> C Java int a [5]; 7! int [] a = new int [5]; int *p = a; 7! int [] p = a; p++; 7! p i++; p <ref> [2] </ref> = 10; 7! p [p i+2] = 10; i = 5; 7! i [0] = 5; p i = 0; p = g (); 7! IntPointer temp = g (); p = temp.a; p i = temp.i; return p; 7! return new IntPointer (p, p i); care. <p> In the worst case, which is rare, function copying results in quadratic code expansion. C Java int i; 7! Int i; int a [5]; 7! int [] a = new int [5]; int *p = &a <ref> [2] </ref>; 7! int [] p = a; f (p); 7! f (p, p i); void f (int *i) f 7! void f (Int i) f i.val = 5; g *i = 5; void f (int [] i) f i [0] = 5; g g void f (int [] i, int i <p> Note the use of Java's function overloading. 4.4 Multi-dimensional Arrays Multi-dimensional C arrays are in fact one-dimensional arrays with syntactic sugar for accessing elements. For example, if we declare int a [3][4], then both a and a <ref> [2] </ref> have types corresponding to int *. In contrast, Java's multi-dimensional arrays have depth. For example, int [][] a = new int [4][] declares a as a four-element array of references to arrays; each entry of a is initially null. <p> Hence, multi-dimensional C arrays must be converted to one-dimensional Java arrays (Figure 9). C Java int a [3][4]; 7! int [] a = new int [3*4]; a [1]<ref> [2] </ref> = b [2][1]; 7! a [1*4+2] = b [2*4+1]; int *q = b [2]; 7! int [] q = b; 4.5 Structures C structures quite obviously map to Java objects (Figure 10 (a)). Any elements of a structure are converted as if they represented variables. <p> Any pointers that directly or may indirectly point to such information must also use the block model. Our goal is to use the block model as little as possible. Indeed, "well-written" (in particular scientific) applications should not need it at all. Our analysis of SuperLU <ref> [2, 3] </ref>, a good representative of such applications, indicates that the block model is unnecessary. In general, the programmer may want to hand-convert any code that requires the block model in order to improve efficiency. 5 Conclusion We have presented a model for a complete and automatic C-to-Java converter.
Reference: [3] <author> James W. Demmel, John R. Gilbert, and Xiaoye S. Li. </author> <title> SuperLU Users' Guide, </title> <month> November </month> <year> 1997. </year> <title> World Wide Web. </title> <address> http://www.netlib.org/scalapack/prototype/superlu ug.ps. </address>
Reference-contexts: In this paper, we discuss automatic conversion of pointers into references, with the application of converting C code into Java. Our main focus is on translating scientific applications written in C. A significant example of such a program is SuperLU <ref> [2, 3] </ref>, a state-of-the-art general sparse linear solver released in 1997 and available only in C. The rest of this paper is outlined as follows. Section 2 surveys related work. In Section 3, we give a general and flexible conversion model that provides nearly full conversion from C to Java. <p> In contrast, C allows one to add an integer (such as 1) to a pointer that points to an array, causing it to point to a particular element of the array. Such practice is common (for example, in SuperLU <ref> [2, 3] </ref>), since in C it allows efficient access to individual elements of arrays; that is, repeatedly accessing a [i] is made faster 6 by assigning p = &a [i] (or p = a+i) and then repeatedly accessing *p. <p> Any pointers that directly or may indirectly point to such information must also use the block model. Our goal is to use the block model as little as possible. Indeed, "well-written" (in particular scientific) applications should not need it at all. Our analysis of SuperLU <ref> [2, 3] </ref>, a good representative of such applications, indicates that the block model is unnecessary. In general, the programmer may want to hand-convert any code that requires the block model in order to improve efficiency. 5 Conclusion We have presented a model for a complete and automatic C-to-Java converter.
Reference: [4] <author> Geoffrey Fox, Xiaoming Li, Qiang Zheng, and Wu Zhigang. </author> <title> A prototype of FORTRAN-to-Java converter. </title> <booktitle> In Proceedings of the ACM 1997 Workshop on Java for Science and Engineering Computation, </booktitle> <address> Las Vagas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: For scientific applications, arrays are perhaps the most important and common data structure, so their conversion is important. Indeed, we pay much attention to their efficient representation in Java in this paper. Another related project is a recent Fortran-to-Java converter f2j <ref> [4] </ref>. It is of interest because it uses an intermediate representation of C, that is, it converts Fortran code into C, and converts the result to Java. <p> Hence, the lack of such support is of limited importance. The main problem with the block model is its inefficiency. This is the topic of the next section. 3 main () f int a <ref> [4] </ref> = f1,2,3,0g; printf ("%dnn", sum (a)); g int s = 0; while (*a != 0) s += *(a++); return s; g main () f IntB [] a = fnew IntB (1), new IntB (2), new IntB (3), new IntB (0)g; StructB a = new StructB (a ); System.out.println (sum (new <p> The reason for this is that the converter does not know, when converting sum's code, that a is an array. If it knew, it could perform the conversion in Figure 2. main () f int a <ref> [4] </ref> = f1,2,3,0g; printf ("%dnn", sum (a)); g int s = 0; while (*a != 0) s += *(a++); return s; g main () f int [] a = f1,2,3,0g; System.out.println (sum (a)); g int a i = 0; while (a [a i] != 0) s += *(a [a i++]); return <p> For example, if we declare int a [3]<ref> [4] </ref>, then both a and a [2] have types corresponding to int *. In contrast, Java's multi-dimensional arrays have depth. For example, int [][] a = new int [4][] declares a as a four-element array of references to arrays; each entry of a is initially null. Hence, multi-dimensional C arrays must be converted to one-dimensional Java arrays (Figure 9). C Java int a [3][4]; 7! int [] a = new int [3*4]; a [1][2] = b [2][1]; 7! a
Reference: [5] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. Java Series. Sun Microsys-tems, </title> <year> 1996. </year>
Reference-contexts: In fact, while this adds extra overhead, it is the most efficient general method. This is because, while Java has a stack, it does not support taking the address of anything on the stack <ref> [5] </ref>. Objects cannot be allocated on the stack (unlike C++ for example); only references to objects can be allocated on the stack. One cannot pass basic values by reference or otherwise find their addresses. <p> Any addressable variable v of type t must also be mapped to this type, and references to v are replaced by v [0], which the & operator converts back to v. C Java int a <ref> [5] </ref>; 7! int [] a = new int [5]; p++; 7! Not allowed. *p = 5; 7! p [0] = 5; int i; 7! int [] i = new int [1]; p = &i; 7! p = i; arrays. <p> Any addressable variable v of type t must also be mapped to this type, and references to v are replaced by v [0], which the & operator converts back to v. C Java int a <ref> [5] </ref>; 7! int [] a = new int [5]; p++; 7! Not allowed. *p = 5; 7! p [0] = 5; int i; 7! int [] i = new int [1]; p = &i; 7! p = i; arrays. <p> rare case when their address is stored in a pointer that also at some time points to an array. public class IntPointer f public IntPointer (int [] a, int i) f this.a = a; this.i = t; g public int [] a; public int i; g C Java int a <ref> [5] </ref>; 7! int [] a = new int [5]; int *p = a; 7! IntPointer p = new IntPointer (a, 0); p++; 7! p.i++; p [2] = 10; 7! p.a [p.i+2] = 10; i = 5; 7! i [0] = 5; One possible optimization, called unrolling, removes a level of indirection <p> a pointer that also at some time points to an array. public class IntPointer f public IntPointer (int [] a, int i) f this.a = a; this.i = t; g public int [] a; public int i; g C Java int a <ref> [5] </ref>; 7! int [] a = new int [5]; int *p = a; 7! IntPointer p = new IntPointer (a, 0); p++; 7! p.i++; p [2] = 10; 7! p.a [p.i+2] = 10; i = 5; 7! i [0] = 5; One possible optimization, called unrolling, removes a level of indirection by replacing the structure with two individual variables <p> This improves efficiency, except when we return a pointer into an array from a function, in which case we must temporarily switch to the object representation. C Java int a <ref> [5] </ref>; 7! int [] a = new int [5]; int *p = a; 7! int [] p = a; p++; 7! p i++; p [2] = 10; 7! p [p i+2] = 10; i = 5; 7! i [0] = 5; p i = 0; p = g (); 7! IntPointer <p> This improves efficiency, except when we return a pointer into an array from a function, in which case we must temporarily switch to the object representation. C Java int a <ref> [5] </ref>; 7! int [] a = new int [5]; int *p = a; 7! int [] p = a; p++; 7! p i++; p [2] = 10; 7! p [p i+2] = 10; i = 5; 7! i [0] = 5; p i = 0; p = g (); 7! IntPointer temp = g (); p = temp.a; p <p> This allows effective optimization 7 of the special cases, even if multiple cases are exploited. In the worst case, which is rare, function copying results in quadratic code expansion. C Java int i; 7! Int i; int a <ref> [5] </ref>; 7! int [] a = new int [5]; int *p = &a [2]; 7! int [] p = a; f (p); 7! f (p, p i); void f (int *i) f 7! void f (Int i) f i.val = 5; g *i = 5; void f (int [] i) f <p> This allows effective optimization 7 of the special cases, even if multiple cases are exploited. In the worst case, which is rare, function copying results in quadratic code expansion. C Java int i; 7! Int i; int a <ref> [5] </ref>; 7! int [] a = new int [5]; int *p = &a [2]; 7! int [] p = a; f (p); 7! f (p, p i); void f (int *i) f 7! void f (Int i) f i.val = 5; g *i = 5; void f (int [] i) f i [0] = 5; g g void f
Reference: [6] <author> William G. Griswold and Paul Phillips. </author> <title> UCSD benchmarks for Java. World Wide Web. </title> <note> http:/ /www-cse.ucsd.edu/~wgg/JavaProf/javaprof.html. </note>
Reference-contexts: Section 4.1 also gives the results from a benchmark we wrote, comparing the various options for call-by-reference in Java. A related "microbenchmark" has been developed by Griswold and Phillips <ref> [6] </ref>. 3 Block Model This section defines what we call the block model of pointers. It allows us to abstract essentially all features of C pointers into a simple theoretical framework. The few limitations are discussed in Section 3.3.
Reference: [7] <author> Yuuji Ichisugi. epplib/ref.lsp. </author> <title> In EPP distribution, 1997. World Wide Web. </title> <note> http:// www.aist.go.jp/ETL/etl/bunsan/~ichisugi/. </note>
Reference-contexts: Section 4.1 discusses possible methods for passing basic values such as integers to functions by reference in Java. We know of one system supporting this, EPP [8]. EPP is a framework for Java preprocessors and one example, called ref <ref> [7] </ref>, adds an operator "&" for passing values by reference. It implements this using one-element arrays, but in such a way that does not allow taking general addresses of basic values, unlike our methods in Section 4.1.
Reference: [8] <author> Yuuji Ichisugi and Yves Roudier. </author> <title> The extensible Java preprocessor kit and a tiny data-parallel Java. </title> <booktitle> In Proceedings of the 1997 International Scientific Computing in Object-Oriented Parallel Environments Conference, </booktitle> <address> Marina del Rey, California, </address> <month> December </month> <year> 1997. </year> <title> World Wide Web. </title> <address> http://www.aist.go.jp/ETL/etl/bunsan/~ichisugi/doc/iscope97.ps.gz. </address>
Reference-contexts: A couple of minor results in this paper have been partially achieved before. Section 4.1 discusses possible methods for passing basic values such as integers to functions by reference in Java. We know of one system supporting this, EPP <ref> [8] </ref>. EPP is a framework for Java preprocessors and one example, called ref [7], adds an operator "&" for passing values by reference. It implements this using one-element arrays, but in such a way that does not allow taking general addresses of basic values, unlike our methods in Section 4.1.
Reference: [9] <author> Chris Laffra. </author> <title> C2J | A C++ to Java translator. In Advanced Java: Idioms, Pitfalls, Styles and Programming Tips, chapter 4. </title> <publisher> Prentice Hall Computer Books, </publisher> <year> 1996. </year>
Reference-contexts: We conclude in Section 5. 1 2 Related Work Much work has been done on converting Java to C for optimization purposes; see for example Harissa [10], j2c [1], JCC [12], and Toba [11]. However, little has been done on the reverse direction. Of particular relevance are c2j <ref> [9] </ref> and c2j++ [13]. Both are tools for translating C++ to Java. c2j++ is based on c2j; the main difference is that c2j++ is written in Java, whereas c2j is written in C++. Unfortunately, the tools are limited.
Reference: [10] <author> Gilles Muller, Barbara Moura, Fabrice Bellard, and Charles Consel. Harissa: </author> <title> A flexible and efficient Java environment mixing bytecode and compiled code. </title> <booktitle> In Proceedings of the 3rd Conference on Object-Oriented Technologies and Systems, </booktitle> <year> 1997. </year>
Reference-contexts: Section 4 discusses how this can be improved to be "optimal" for most applications. We conclude in Section 5. 1 2 Related Work Much work has been done on converting Java to C for optimization purposes; see for example Harissa <ref> [10] </ref>, j2c [1], JCC [12], and Toba [11]. However, little has been done on the reverse direction. Of particular relevance are c2j [9] and c2j++ [13].
Reference: [11] <author> Todd A. Proebsting, Gregg Townsend, Patrick Bridges, John H. Hartman, Tim Newsham, and Scott A. Watterson. Toba: </author> <title> A Java-to-C translator. World Wide Web. </title> <note> http:// www.cs.arizona.edu/sumatra/toba. </note>
Reference-contexts: Section 4 discusses how this can be improved to be "optimal" for most applications. We conclude in Section 5. 1 2 Related Work Much work has been done on converting Java to C for optimization purposes; see for example Harissa [10], j2c [1], JCC [12], and Toba <ref> [11] </ref>. However, little has been done on the reverse direction. Of particular relevance are c2j [9] and c2j++ [13]. Both are tools for translating C++ to Java. c2j++ is based on c2j; the main difference is that c2j++ is written in Java, whereas c2j is written in C++.
Reference: [12] <author> Nik Shaylor. </author> <title> JCC | A Java to C converter, </title> <month> May </month> <year> 1997. </year> <title> World Wide Web. </title> <note> http:// www.geocities.com/CapeCanaveral/Hangar/4040/jcc.html. </note>
Reference-contexts: Section 4 discusses how this can be improved to be "optimal" for most applications. We conclude in Section 5. 1 2 Related Work Much work has been done on converting Java to C for optimization purposes; see for example Harissa [10], j2c [1], JCC <ref> [12] </ref>, and Toba [11]. However, little has been done on the reverse direction. Of particular relevance are c2j [9] and c2j++ [13].
Reference: [13] <author> Ilya Tilevich. C2J++, </author> <title> C++ to Java translator written in Java, 1997. World Wide Web. </title> <note> http://pacevm.dac.pace.edu/~ny971734/c2j.html. 10 </note>
Reference-contexts: However, little has been done on the reverse direction. Of particular relevance are c2j [9] and c2j++ <ref> [13] </ref>. Both are tools for translating C++ to Java. c2j++ is based on c2j; the main difference is that c2j++ is written in Java, whereas c2j is written in C++. Unfortunately, the tools are limited. They essentially ignore the problem of pointers, which is the main difficulty of C-to-Java conversion.
References-found: 13

