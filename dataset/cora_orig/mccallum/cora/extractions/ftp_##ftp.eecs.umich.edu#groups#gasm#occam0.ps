URL: ftp://ftp.eecs.umich.edu/groups/gasm/occam0.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Title: Algebraic Operational Semantics and Occam  
Author: Yuri Gurevich ; Lawrence S. Moss 
Abstract: We generalize algebraic operational semantics from sequential languages to distributed, concurrent languages using Occam as an example. Elsewhere, we will discuss applications to the study of verification and transformation of programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Blakley, R., Ph. D. </author> <type> Thesis, </type> <institution> University of Michigan. </institution> <note> (In preparation). </note>
Reference-contexts: There have been three studies of programming languages in this framework, of Modula-2 [4], Smalltalk <ref> [1] </ref>, and Prolog (including all of the non-logical operations that change the program) [2]. This paper extends the approach of dynamic structures to the case of distributed, concurrent computation. <p> We also thank Padmanabhan Krishnan and Dalia Malki for many discussions concerning Occam and distributed computing. 2 Background on Evolving Structures Sequential evolving structures were introduced in [3] and used in <ref> [1] </ref>, [2], and [4] to give operational semantics for Modula-2, Smalltalk, and Prolog, respectively. They are abstract machines working in discrete linear time. Sequentiality means only that the time is discrete and linear; the machine may be parallel and even distributed. <p> We do this for each U m ; otherwise s k+1 is identical to s k . Notice that S is unable to exchange information with the outside world. More general evolving structures can be found in <ref> [1, 2, 3, and 4] </ref>. 3 An Example from Occam Consider the following example of a program P of Occam: PAR d! max (x,y) c? a e! min (a,b) Here is the intended meaning of this program: P consists of three processes running in parallel: c! max (i,j), d! max (x,y)
Reference: [2] <author> Borger, E., </author> <title> A Logical Operational Semantics for Full Prolog, </title> <booktitle> these Proceedings. </booktitle>
Reference-contexts: There have been three studies of programming languages in this framework, of Modula-2 [4], Smalltalk [1], and Prolog (including all of the non-logical operations that change the program) <ref> [2] </ref>. This paper extends the approach of dynamic structures to the case of distributed, concurrent computation. <p> We also thank Padmanabhan Krishnan and Dalia Malki for many discussions concerning Occam and distributed computing. 2 Background on Evolving Structures Sequential evolving structures were introduced in [3] and used in [1], <ref> [2] </ref>, and [4] to give operational semantics for Modula-2, Smalltalk, and Prolog, respectively. They are abstract machines working in discrete linear time. Sequentiality means only that the time is discrete and linear; the machine may be parallel and even distributed. <p> We do this for each U m ; otherwise s k+1 is identical to s k . Notice that S is unable to exchange information with the outside world. More general evolving structures can be found in <ref> [1, 2, 3, and 4] </ref>. 3 An Example from Occam Consider the following example of a program P of Occam: PAR d! max (x,y) c? a e! min (a,b) Here is the intended meaning of this program: P consists of three processes running in parallel: c! max (i,j), d! max (x,y)
Reference: [3] <author> Gurevich, Y., </author> <booktitle> Logic and the Challenge of Computer Science. In Trends in Theoretical Computer Science (E. </booktitle> <editor> Borger, ed.), </editor> <publisher> Computer Science Press, </publisher> <year> 1988, </year> <pages> 1-57. </pages>
Reference-contexts: We also thank Padmanabhan Krishnan and Dalia Malki for many discussions concerning Occam and distributed computing. 2 Background on Evolving Structures Sequential evolving structures were introduced in <ref> [3] </ref> and used in [1], [2], and [4] to give operational semantics for Modula-2, Smalltalk, and Prolog, respectively. They are abstract machines working in discrete linear time. Sequentiality means only that the time is discrete and linear; the machine may be parallel and even distributed. <p> We do this for each U m ; otherwise s k+1 is identical to s k . Notice that S is unable to exchange information with the outside world. More general evolving structures can be found in <ref> [1, 2, 3, and 4] </ref>. 3 An Example from Occam Consider the following example of a program P of Occam: PAR d! max (x,y) c? a e! min (a,b) Here is the intended meaning of this program: P consists of three processes running in parallel: c! max (i,j), d! max (x,y)
Reference: [4] <author> Gurevich, Y. and J. M. Morris, </author> <title> Algebraic Operational Semantics and Modula-2. </title> <booktitle> In Proceedings, Logik in der Informatik, Springer LNCS, </booktitle> <volume> vol. 329, </volume> <pages> pp. 81-101. </pages>
Reference-contexts: There have been three studies of programming languages in this framework, of Modula-2 <ref> [4] </ref>, Smalltalk [1], and Prolog (including all of the non-logical operations that change the program) [2]. This paper extends the approach of dynamic structures to the case of distributed, concurrent computation. <p> We also thank Padmanabhan Krishnan and Dalia Malki for many discussions concerning Occam and distributed computing. 2 Background on Evolving Structures Sequential evolving structures were introduced in [3] and used in [1], [2], and <ref> [4] </ref> to give operational semantics for Modula-2, Smalltalk, and Prolog, respectively. They are abstract machines working in discrete linear time. Sequentiality means only that the time is discrete and linear; the machine may be parallel and even distributed. Later in this paper we introduce a class of nonsequential evolving structures.
Reference: [5] <author> Hoare, C. A. R., </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Lon-don, </address> <year> 1985. </year>
Reference-contexts: In a different direction, we believe that distributed evolving structures work well as a pedagogical tool, too. Our approach is somewhat different from the existing influential approaches, such as CCS [7], CSP <ref> [5] </ref>, denotational semantics and algebraic semantics. We don't use transition systems taking one program to another; usually only our models evolve, not our programs. And we do not exploit uninterpreted atomic actions. In reality, atomic actions come in different forms and with different parameters.
Reference: [6] <author> Hoare, C. A. R. and A. W. Roscoe, </author> <title> The Laws of Occam Programming, </title> <institution> Oxford University Computing Laboratory Technical Monograph PRG-53, </institution> <year> 1986. </year> <note> Also appears in Theoretical Computer Science 60 (1988), pp. 177-229. </note>
Reference: [7] <author> Milner, R., </author> <title> A Calculus of Communicating Systems, </title> <publisher> Springer LNCS vol. </publisher> <address> 92, </address> <year> 1980. </year>
Reference-contexts: In a different direction, we believe that distributed evolving structures work well as a pedagogical tool, too. Our approach is somewhat different from the existing influential approaches, such as CCS <ref> [7] </ref>, CSP [5], denotational semantics and algebraic semantics. We don't use transition systems taking one program to another; usually only our models evolve, not our programs. And we do not exploit uninterpreted atomic actions. In reality, atomic actions come in different forms and with different parameters.
Reference: [8] <author> Pountain, D., </author> <title> A Tutorial Introduction to OCCAM Programming, </title> <publisher> INMOS Ltd, </publisher> <year> 1987. </year>
Reference-contexts: J. Watson Research Center, Yorktown Heights, NY 10598. 1 For concreteness, we focus on the language Occam <ref> [8] </ref>, and the reader need not have familiar-ity with the language to understand what we are doing. <p> It turns out that the implementation of ALT is rather tricky; we do not base the semantics on the details of the standard implementation of Occam on transputers. We interleave the rules of ALT with explanations. The Occam Tutorial <ref> [8] </ref> holds that "Because of this power, and because it is unlike anything in conventional programming languages, ALT is far-and-away the most difficult of the occam constructions to explain and to understand." We feel that an algebraic operational treatment might help people to grasp the ALT construction.
Reference: [9] <author> Roscoe, A. W., </author> <title> Denotational Semantics for Occam, </title> <editor> in S. D. Brookes, et al (eds.), </editor> <booktitle> Seminar on Concurrency Springer LNCS 197, </booktitle> <year> 1985, </year> <pages> 306-329. 17 </pages>
References-found: 9

