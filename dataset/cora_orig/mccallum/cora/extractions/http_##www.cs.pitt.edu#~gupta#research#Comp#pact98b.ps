URL: http://www.cs.pitt.edu/~gupta/research/Comp/pact98b.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/optimization.html
Root-URL: http://www.cs.pitt.edu
Title: Capturing the Effects of Code Improving Transformations  
Author: Clara Jaramillo, Rajiv Gupta and Mary Lou Soffa 
Address: Pittsburgh Pittsburgh,PA 15260  
Affiliation: Department of Computer Science University of  
Abstract: Symbolic debugging of transformed code requires information about the impact of applying transformations on statement instances so that the appropriate values can be displayed to a user. We present a technique to automatically identify statement instance correspondences between untransformed and transformed code and generate mappings reflecting these correspondences as code improving transformations are applied. The mappings support classical optimizations as well as loop transformations. Establishing mappings requires analyzing how the position, number, and order of instances of a statement can change in a particular context when transformations are applied. In addition to enabling symbolic debugging of transformed code, these mappings can be used to understand transformed code and to compare values computed in both program versions either manually or automatically. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adl-Tabatabai, A. </author> <title> Source-Level Debugging of Globally Optimized Code. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year> <note> Technical Report CMU-CS-96-133. </note>
Reference-contexts: The existing approach to this problem is to utilize source level debuggers that allow a user to debug from the point of view of the source level program but actually execute the transformed code <ref> [1, 2, 3, 4, 5, 6, 7, 10, 11, 13] </ref>. To accomplish this task, mappings are used to track the relationship between an untransformed program and its transformed version. <p> Loop transformation effects on mappings with ! hfli! ! hfli labels on loop bodies level debuggers of transformed code developed map pings of statements to track an untransformed program to its transformed version <ref> [1, 2, 3, 4, 7, 10, 11, 13, 14] </ref>. Mappings are statically analyzed to determine the placement of breakpoints and determine if values of source level variables are reportable at given break points.
Reference: [2] <author> Brooks, G., Hansen, G.J., and Simmons, S. </author> <title> A New Approach to Debugging Optimized Code. </title> <booktitle> In Proceedings ACM SIGPLAN'92 Conf. on Programming Languages Design and Implementation, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The existing approach to this problem is to utilize source level debuggers that allow a user to debug from the point of view of the source level program but actually execute the transformed code <ref> [1, 2, 3, 4, 5, 6, 7, 10, 11, 13] </ref>. To accomplish this task, mappings are used to track the relationship between an untransformed program and its transformed version. <p> Loop transformation effects on mappings with ! hfli! ! hfli labels on loop bodies level debuggers of transformed code developed map pings of statements to track an untransformed program to its transformed version <ref> [1, 2, 3, 4, 7, 10, 11, 13, 14] </ref>. Mappings are statically analyzed to determine the placement of breakpoints and determine if values of source level variables are reportable at given break points.
Reference: [3] <author> Copperman, M. </author> <title> Debugging Optimized Code Without Being Misled. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 16(3) </volume> <pages> 387-427, </pages> <year> 1994. </year>
Reference-contexts: The existing approach to this problem is to utilize source level debuggers that allow a user to debug from the point of view of the source level program but actually execute the transformed code <ref> [1, 2, 3, 4, 5, 6, 7, 10, 11, 13] </ref>. To accomplish this task, mappings are used to track the relationship between an untransformed program and its transformed version. <p> Loop transformation effects on mappings with ! hfli! ! hfli labels on loop bodies level debuggers of transformed code developed map pings of statements to track an untransformed program to its transformed version <ref> [1, 2, 3, 4, 7, 10, 11, 13, 14] </ref>. Mappings are statically analyzed to determine the placement of breakpoints and determine if values of source level variables are reportable at given break points.
Reference: [4] <author> Coutant, D.S., Meloy, S., and Ruscetta, M. </author> <title> DOC: </title>
Reference-contexts: The existing approach to this problem is to utilize source level debuggers that allow a user to debug from the point of view of the source level program but actually execute the transformed code <ref> [1, 2, 3, 4, 5, 6, 7, 10, 11, 13] </ref>. To accomplish this task, mappings are used to track the relationship between an untransformed program and its transformed version. <p> Loop transformation effects on mappings with ! hfli! ! hfli labels on loop bodies level debuggers of transformed code developed map pings of statements to track an untransformed program to its transformed version <ref> [1, 2, 3, 4, 7, 10, 11, 13, 14] </ref>. Mappings are statically analyzed to determine the placement of breakpoints and determine if values of source level variables are reportable at given break points.
References-found: 4

