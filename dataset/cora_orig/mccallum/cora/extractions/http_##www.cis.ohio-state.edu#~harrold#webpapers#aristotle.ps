URL: http://www.cis.ohio-state.edu/~harrold/webpapers/aristotle.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/758/Organon/dev2/impl-plan/implement2.html
Root-URL: 
Title: Aristotle: A System for Research on and Development of Program-Analysis-Based Tools  
Author: Mary Jean Harrold Gregg Rothermel 
Keyword: KEY WORDS: program analysis, software engineering, CASE, experimental systems  
Address: SUMMARY  
Affiliation: Department of Computer and Information Science, The Ohio State University. and  Department of Computer Science, Oregon State University.  
Abstract: Aristotle provides program analysis information and supports the development of software engineering tools. Aristotle's front end consists of parsers that gather control-flow, local data-flow, and symbol table information for C and Java programs. Aristotle tools use the data provided by the front end to perform a variety of tasks, such as data-flow and control-dependence analysis, data-flow testing, regression test selection, graph construction and graph viewing. Parsers and tools use database access routines to store information in, and retrieve it from, a data repository. Users can view analysis data textually or graphically. A user interface provides menu-driven access to tools; many tools can also be invoked directly from applications programs. Most of Aristotle's components function on single procedures and entire programs. We use Aristotle as a platform for developing and experimenting with program analysis, maintenance, and testing tools. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, J. Horgan, E. Krauser, and S. </author> <title> London. Incremental regression testing. </title> <booktitle> In Proceedings of the Conference on Software Maintenance - 1993, </booktitle> <pages> pages 348-357, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: INTRODUCTION Many techniques for automating software engineering tasks rely on program analysis information information that is obtained by analyzing software. For example, several regression testing techniques <ref> [1, 4, 5, 9, 22, 23] </ref> use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information.
Reference: [2] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 16-27, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: An interprocedural control-flow graph is useful for analyses such as interprocedural data-flow analysis [10] and program slicing <ref> [2] </ref>. To provide support for these techniques, we incorporated an interprocedural control-flow graph builder into Aristotle.
Reference: [3] <author> T. Ball and J. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: For example, several regression testing techniques [1, 4, 5, 9, 22, 23] use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling <ref> [3] </ref> require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques [11, 19, 26], which, in turn, require various forms of dependence and flow information. Before researchers can implement and experiment with program-analysis-based testing and maintenance techniques such as these, they must acquire the prerequisite program-analysis tools.
Reference: [4] <author> S. Bates and S. Horwitz. </author> <title> Incremental program testing using program dependence graphs. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 384-396, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: INTRODUCTION Many techniques for automating software engineering tasks rely on program analysis information information that is obtained by analyzing software. For example, several regression testing techniques <ref> [1, 4, 5, 9, 22, 23] </ref> use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information.
Reference: [5] <author> D. Binkley. </author> <title> Using semantic differencing to reduce the cost of regression testing. </title> <booktitle> In Proceedings of the Conference on Software Maintenance - 1992, </booktitle> <pages> pages 41-50, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: INTRODUCTION Many techniques for automating software engineering tasks rely on program analysis information information that is obtained by analyzing software. For example, several regression testing techniques <ref> [1, 4, 5, 9, 22, 23] </ref> use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information.
Reference: [6] <author> P. Devanbu, D. Rosenblum, and A. Wolf. </author> <title> Generating testing and analysis tools with Aria. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(1) </volume> <pages> 42-62, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Sage [16] creates abstract syntax trees for C and C++ programs, and provides several utilities that can be used to create new analysis tools. Aria <ref> [6] </ref> generates testing and analysis tools for C and C++ programs from abstract-syntax-graph representations (an abstract syntax tree with semantic information) of the programs, and can be used to generate many different types of dependence graphs.
Reference: [7] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Aristotle's intraprocedural control-dependence analysis tool accepts a control-flow graph as input, and produces intraprocedural control-dependence information using the algorithm presented in Reference <ref> [7] </ref>. This algorithm uses the control-flow graph to compute postdominator information, which is then used to compute control-dependencies for the program. <p> The tool uses database access routines to write the data-dependence graph to the database. Control dependence information is frequently encoded in a control-dependence graph <ref> [7] </ref>, such as the graph shown in the upper right in Figure 4. A control-dependence graph summarizes the control conditions necessary for a statement to execute, and identifies statements that are guaranteed to execute if a given statement has executed. <p> Aristotle's control-dependence graph builder uses access routines to retrieve control dependence information from the database, and uses this information to produce control-dependence graphs. That tool uses the algorithm of <ref> [7] </ref> to create region nodes in two phases.
Reference: [8] <author> P. E. Frankl and E. J. Weyuker. </author> <title> An applicable family of data flow criteria. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1483-1498, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: For example, several regression testing techniques [1, 4, 5, 9, 22, 23] use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing <ref> [8, 14, 18, 20] </ref>, test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques [11, 19, 26], which, in turn, require various forms of dependence and flow information.
Reference: [9] <author> R. Gupta, M. J. Harrold, and M. L. Soffa. </author> <title> An approach to regression testing using slicing. </title> <booktitle> In Proceedings of the Conference on Software Maintenance - 1992, </booktitle> <pages> pages 299-308, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: INTRODUCTION Many techniques for automating software engineering tasks rely on program analysis information information that is obtained by analyzing software. For example, several regression testing techniques <ref> [1, 4, 5, 9, 22, 23] </ref> use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information.
Reference: [10] <author> M.J. Harrold and G. Rothermel. </author> <title> Separate computation of alias information for reuse. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(7) </volume> <pages> 442-460, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: An interprocedural control-flow graph is useful for analyses such as interprocedural data-flow analysis <ref> [10] </ref> and program slicing [2]. To provide support for these techniques, we incorporated an interprocedural control-flow graph builder into Aristotle.
Reference: [11] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year> <month> 12 </month>
Reference-contexts: Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques <ref> [11, 19, 26] </ref>, which, in turn, require various forms of dependence and flow information. Before researchers can implement and experiment with program-analysis-based testing and maintenance techniques such as these, they must acquire the prerequisite program-analysis tools. In general, it is difficult and time-consuming to construct such tools.
Reference: [12] <author> R. Kadia. </author> <title> Issues encountered in building a flexible software development environment. </title> <booktitle> In Proceedings of the 5th Symposium on Software Development Environments, </booktitle> <pages> pages 169-179, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: A number of systems provide, or could support the development of, program analysis tools. The Arcadia project and its ProDAG subsystem <ref> [12, 21] </ref> provide program-analysis tools for use with Ada programs; these include tools for constructing control-flow graphs and computing data- and control-dependencies. Sage [16] creates abstract syntax trees for C and C++ programs, and provides several utilities that can be used to create new analysis tools.
Reference: [13] <author> B. Korel. </author> <title> Automated software test data generation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(8) </volume> <pages> 870-879, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: For example, several regression testing techniques [1, 4, 5, 9, 22, 23] use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation <ref> [13] </ref>, and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques [11, 19, 26], which, in turn, require various forms of dependence and flow information.
Reference: [14] <author> J. W. Laski and B. Korel. </author> <title> A data flow oriented program testing strategy. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 9(3) </volume> <pages> 347-54, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: For example, several regression testing techniques [1, 4, 5, 9, 22, 23] use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing <ref> [8, 14, 18, 20] </ref>, test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques [11, 19, 26], which, in turn, require various forms of dependence and flow information.
Reference: [15] <author> I. Lemke and G. Sander. </author> <title> Visualization of Compiler Graphs, </title> <month> May </month> <year> 1994. </year>
Reference-contexts: After a user specifies a graph type and viewing options, the graph viewers use database access routines to obtain the specified graph from the database, format that data for display by the XVCG <ref> [15] </ref> graph viewing tool, and invoke that tool.
Reference: [16] <author> A. Malony, B. Mohr, P. Beckman, D. Gannon, S. Yang, and F. Bodin. </author> <title> Performance analysis of pC++: A portable data-parallel programming system for scalable parallel computers. </title> <booktitle> In 8th International Parallel Processing Symposium, </booktitle> <pages> pages 75-84, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: A number of systems provide, or could support the development of, program analysis tools. The Arcadia project and its ProDAG subsystem [12, 21] provide program-analysis tools for use with Ada programs; these include tools for constructing control-flow graphs and computing data- and control-dependencies. Sage <ref> [16] </ref> creates abstract syntax trees for C and C++ programs, and provides several utilities that can be used to create new analysis tools.
Reference: [17] <author> J. Mylopoulos, M. Stanley, K. Wong, M. Bernstein, R. DeMori, G. Ewart, K. Kontogiannis, E. Merlo, H. Muller, S. Tilley, and M. </author> <title> Tomic. Towards an integrated toolset for program understanding. </title> <booktitle> In Proceedings of CASCON '94, </booktitle> <pages> pages 19-31, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Aria [6] generates testing and analysis tools for C and C++ programs from abstract-syntax-graph representations (an abstract syntax tree with semantic information) of the programs, and can be used to generate many different types of dependence graphs. Rigi <ref> [17] </ref> provides a toolkit for program understanding that can be used for activities such as reverse engineering of large systems. SUIF [27], an infrastructure for support of compiler research for high-performance systems, provides a front end that generates abstract syntax trees for C programs.
Reference: [18] <author> S.C. Ntafos. </author> <title> An evaluation of required testing element strategies. </title> <booktitle> Proceedings of the 7th International Conference on Software Engineering, </booktitle> <pages> pages 250-256, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: For example, several regression testing techniques [1, 4, 5, 9, 22, 23] use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing <ref> [8, 14, 18, 20] </ref>, test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques [11, 19, 26], which, in turn, require various forms of dependence and flow information.
Reference: [19] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques <ref> [11, 19, 26] </ref>, which, in turn, require various forms of dependence and flow information. Before researchers can implement and experiment with program-analysis-based testing and maintenance techniques such as these, they must acquire the prerequisite program-analysis tools. In general, it is difficult and time-consuming to construct such tools.
Reference: [20] <author> S. Rapps and E. J. Weyuker. </author> <title> Selecting software test data using data flow information. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(4) </volume> <pages> 367-375, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: For example, several regression testing techniques [1, 4, 5, 9, 22, 23] use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing <ref> [8, 14, 18, 20] </ref>, test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques [11, 19, 26], which, in turn, require various forms of dependence and flow information.
Reference: [21] <author> D. J. Richardson, T. O'Malley, C. T. Moore, and S. L. Aha. </author> <title> Developing and integrating ProDAG in the Arcadia environment. </title> <booktitle> In Proceedings of ACM SIGSOFT '92: Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 109-119, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: A number of systems provide, or could support the development of, program analysis tools. The Arcadia project and its ProDAG subsystem <ref> [12, 21] </ref> provide program-analysis tools for use with Ada programs; these include tools for constructing control-flow graphs and computing data- and control-dependencies. Sage [16] creates abstract syntax trees for C and C++ programs, and provides several utilities that can be used to create new analysis tools.
Reference: [22] <author> G. Rothermel and M. J. Harrold. </author> <title> A safe, efficient algorithm for regression test selection. </title> <booktitle> In Proceedings of the Conference on Software Maintenance - 1993, </booktitle> <pages> pages 358-367, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: INTRODUCTION Many techniques for automating software engineering tasks rely on program analysis information information that is obtained by analyzing software. For example, several regression testing techniques <ref> [1, 4, 5, 9, 22, 23] </ref> use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information.
Reference: [23] <author> G. Rothermel and M. J. Harrold. </author> <title> Selecting tests and identifying test coverage requirements for modified software. </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 169-184, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: INTRODUCTION Many techniques for automating software engineering tasks rely on program analysis information information that is obtained by analyzing software. For example, several regression testing techniques <ref> [1, 4, 5, 9, 22, 23] </ref> use control- and data-dependence information to determine the retesting required after a program is modified. Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information.
Reference: [24] <author> G. Rothermel and M. J. Harrold. </author> <title> Analyzing regression test selection techniques. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(8), </volume> <month> August </month> <year> 1996. </year>
Reference-contexts: To reduce the cost of regression testing, we prefer to reuse tests from existing test suites whenever possible. Regression test selection algorithms select, from existing test suites, tests that should be rerun on a modified program. We 8 have developed a regression test selection algorithm <ref> [24] </ref> that uses control-flow information about a program P and a modified version, P 0 , to select tests in the test suite for P that execute code that has been modified for P 0 . We implemented our regression test selection algorithm as an Aristotle tool.
Reference: [25] <author> K. Tewary and M. J. Harrold. </author> <title> Fault modeling using the program dependence graph. </title> <booktitle> In IEEE International Symposium on Software Reliability '94, </booktitle> <pages> pages 126-135, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: In either case, to obtain the trace we must instrument the program by inserting probes that will produce the trace at runtime. To generate instrumented code, we developed a code instrumenter <ref> [25] </ref>. Users of this tool specify the type of information they wish to collect about program execution, and the tool generates a C program instrumented with probe statements that will collect that information, that can be compiled by any C compiler.
Reference: [26] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Techniques such as data-flow testing [8, 14, 18, 20], test-case generation [13], and dynamic execution profiling [3] require control-flow information. Tools for program understanding and impact analysis use program-slicing techniques <ref> [11, 19, 26] </ref>, which, in turn, require various forms of dependence and flow information. Before researchers can implement and experiment with program-analysis-based testing and maintenance techniques such as these, they must acquire the prerequisite program-analysis tools. In general, it is difficult and time-consuming to construct such tools.
Reference: [27] <author> R. P. Wilson, R. S. French, C. S. Wilson, S. P. Amarasinghe, J. M. Anderson, S. W. K. Tjiang, S.-W. Liao, C.-W. Tsend, M. W. Hall, M. S. Lam, and J. L. Hennessy. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <journal> ACM Sigplan Notices, </journal> <volume> 29(12) </volume> <pages> 31-37, </pages> <month> December </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: Rigi [17] provides a toolkit for program understanding that can be used for activities such as reverse engineering of large systems. SUIF <ref> [27] </ref>, an infrastructure for support of compiler research for high-performance systems, provides a front end that generates abstract syntax trees for C programs. Each of these systems supports, to some degree, research on and development of program-analysis-based tools; however, each also has drawbacks.
References-found: 27

