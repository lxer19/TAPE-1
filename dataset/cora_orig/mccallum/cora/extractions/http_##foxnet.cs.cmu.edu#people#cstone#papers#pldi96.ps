URL: http://foxnet.cs.cmu.edu/people/cstone/papers/pldi96.ps
Refering-URL: http://foxnet.cs.cmu.edu/people/cstone/
Root-URL: 
Title: TIL: A Type-Directed Optimizing Compiler for ML  
Author: David Tarditi Greg Morrisett Perry Cheng Chris Stone Robert Harper Peter Lee 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: February 29, 1996  
Pubnum: CMU-CS-96-108  
Abstract: This paper will appear in the Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, Philadelphia, Pennsylvania, May 21-24, 1996. It is also published as Fox Memorandum CMU-CS-FOX-96-01 Abstract We describe a new compiler for Standard ML called TIL, that is based on four technologies: intensional polymorphism, tag-free garbage collection, conventional functional language optimization, and loop optimization. We use intensional polymorphism and tag-free garbage collection to provide specialized representations, even though SML is a polymorphic language. We use conventional functional language optimization to reduce the cost of intensional polymorphism, and loop optimization to generate good code for recursive functions. We present an example of TIL compiling an SML function to machine code, and compare the performance of TIL code against that of a widely used compiler, Standard ML of New Jersey. This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050, and in part by the National Science Foundation under Grant No. CCR-9502674, and in part by the Isaac Newton Institute for Mathematical Sciences, Cambridge, England. David Tarditi was also partly supported by an AT&T Bell Labs PhD Scholarship. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency, the U.S. Government, the National Science Foundation or AT&T. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Shail Aditya, Christine Flood, and James Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In LFP '94 [30], </booktitle> <pages> pages 12-23. </pages>
Reference-contexts: Goldberg and Gloger improved Appel's algorithm [20, 19]. None of the unification-based algorithms were implemented due to the complexity of the algorithms and the overhead of performing unification during garbage collection. Aditya, Flood, and Hicks used type-passing to support fully tag-free garbage collection for Id <ref> [1] </ref>. Independently, Tolmach [46] implemented a type-passing garbage collection algorithm for ML. Our approach differs from others by using "nearly" tag-free collection. In particular, records and arrays on the heap are tagged.
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: Our approach differs from others by using "nearly" tag-free collection. In particular, records and arrays on the heap are tagged. Another difference is that we calculate type environments eagerly, while the other implementations construct type environments lazily during garbage collection. Loop-oriented optimizations are well-known for imperative languages <ref> [2] </ref>. However, few results are reported for Lisp, Scheme, and ML. Appel [5] and Serrano [40] report common-subexpression elimination optimizations similar to ours. Appel found that CSE was not useful in the SML/NJ 19 compiler.
Reference: [3] <author> Andrew Appel. </author> <title> A critique of Standard ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 391-429, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Because lists are used often in SML, the SML/NJ compiler also flattens cons cells (and other constructors). However, in violation of the SML Definition [31], SML/NJ prevents programmers from abstracting the type of these constructors, in order to prevent representation mismatches between definitions of abstract datatypes and their uses <ref> [3] </ref>. In contrast, TIL supports fully abstract datatype components, but uses intensional polymorphism to determine representations of abstract datatypes, potentially at run time. 5 In addition to specializing calling conventions and datatypes, the conversion from Lambda to Lmli makes polymorphic equality explicit as a term in the language.
Reference: [4] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> (2):153-162, 1989. 
Reference-contexts: Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere [12, 11, 48, 15]. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification <ref> [4] </ref>. Goldberg and Gloger improved Appel's algorithm [20, 19]. None of the unification-based algorithms were implemented due to the complexity of the algorithms and the overhead of performing unification during garbage collection. Aditya, Flood, and Hicks used type-passing to support fully tag-free garbage collection for Id [1].
Reference: [5] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The types and values corresponding to these free variables are placed in records. These records are paired with the code to form an abstract closure. TIL uses a flat environment representation for type and value environments <ref> [5] </ref>. For known functions, TIL generates closed code but avoids creating environments or a closure. Following Kranz [27], we modify the call sites of known functions to pass free variables as additional arguments. TIL closes over only variables which are function arguments or are bound within functions. <p> Further performance analysis of TIL appears in Morrisett's [33] and Tarditi's theses [45]. 5.1 Benchmarks Table 1 describes the benchmark programs, which range in size from 62 lines to about 2000 lines of code. Some of these programs have been used previously for measuring ML performance <ref> [5, 16] </ref>. The benchmarks cover a range of application areas including scientific computing, list-processing, systems programming, and compilers. We compiled the programs as single closed modules. <p> Some of these programs have been used previously for measuring ML performance [5, 16]. The benchmarks cover a range of application areas including scientific computing, list-processing, systems programming, and compilers. We compiled the programs as single closed modules. For Lexgen and Simple, which are standard benchmarks <ref> [5] </ref>, we eliminated functors by hand because TIL does not yet support the full SML module language. Because whole programs were given to the compiler, we found that the optimizer naturally eliminated all polymorphic functions. Consequently, for this benchmark suite, there was no run-time cost to support intensional polymorphism. <p> In particular, records and arrays on the heap are tagged. Another difference is that we calculate type environments eagerly, while the other implementations construct type environments lazily during garbage collection. Loop-oriented optimizations are well-known for imperative languages [2]. However, few results are reported for Lisp, Scheme, and ML. Appel <ref> [5] </ref> and Serrano [40] report common-subexpression elimination optimizations similar to ours. Appel found that CSE was not useful in the SML/NJ 19 compiler.
Reference: [6] <author> Andrew W. Appel, James S. Mattson, and David Tarditi. </author> <title> A lexical analyzer generator for Standard ML. Distributed with Standard ML of New Jersey, </title> <year> 1989. </year>
Reference-contexts: FFT 246 Fast fourier transform, multiplying polynomials up to degree 65,536 Knuth-Bendix 618 An implementation of the Knuth-Bendix completion algorithm. Lexgen 1123 A lexical-analyzer generator <ref> [6] </ref>, processing the lexical description of Standard ML. Life 146 The game of Life implemented using lists [39]. Matmult 62 Integer matrix multiply, on 200x200 integer arrays. PIA 2065 The Perspective Inversion Algorithm [47] deciding the location of an object in a perspective video image.
Reference: [7] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In LFP '94 [30], </booktitle> <pages> pages 55-64. </pages>
Reference-contexts: We measured the maximum amount of physical memory during execution using getrusage. We used the size program to measure the size of executables for TIL. For SML/NJ, we used the size program to 15 Program lines Description Checksum 241 Checksum fragment from the Foxnet <ref> [7] </ref>, doing 5000 checksums on a 4096-byte array. FFT 246 Fast fourier transform, multiplying polynomials up to degree 65,536 Knuth-Bendix 618 An implementation of the Knuth-Bendix completion algorithm. Lexgen 1123 A lexical-analyzer generator [6], processing the lexical description of Standard ML.
Reference: [8] <author> Lars Birkedal, Nick Rothwell, Mads Tofte, and David N. Turner. </author> <title> The ML Kit, </title> <type> Version 1. Technical Report 93/14, </type> <institution> DIKU, </institution> <year> 1993. </year>
Reference-contexts: The low-level phases of the compiler use languages where registers are annotated with garbage collection information. The following sections describe the phases of TIL and the intermediate languages they use in more detail. 3.1 Front-end The first phase of TIL uses the front-end of the ML Kit compiler <ref> [8] </ref> to parse and elaborate (type check) SML source code. The Kit produces annotated abstract syntax for all of SML and then compiles a subset of this abstract syntax to an explicitly-typed core language called Lambda. The compilation to Lambda eliminates pattern matching and various derived forms.
Reference: [9] <author> Guy E. Blelloch. NESL: </author> <title> A nested data-parallel language (version 2.6). </title> <type> Technical Report CMU-CS-93-129, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> April </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector. Other researchers have suggested that polymorphism should be eliminated entirely at compile time <ref> [9, 25, 21] </ref>, in the style of C++ templates [44]. This prevents separate compilation of a polymorphic definition from its uses. In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this.
Reference: [10] <author> Hans-Juergen Boehm. </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In PLDI '93 [36], </booktitle> <pages> pages 197-206. </pages>
Reference-contexts: Recording the information at compile time makes it possible for code to use untagged representations. Unlike so-called conservative collectors (see for example <ref> [10, 14] </ref>), the information recorded by TIL is sufficient to collect all unreachable objects. Collection is "nearly" tag-free because tags are placed only on heap-allocated data structures (records and arrays); values in registers, on the stack, and within data structures remain tagless.
Reference: [11] <author> P. Branquart and J. Lewi. </author> <title> A scheme for storage allocation and garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this. Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere <ref> [12, 11, 48, 15] </ref>. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm [20, 19].
Reference: [12] <author> Dianne Ellen Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: 1 Introduction We are investigating a new approach to compiling Standard ML (SML) based on four key technologies: intensional polymorphism [23], nearly tag-free garbage collection <ref> [12, 46, 34] </ref>, conventional functional language optimization, and loop optimization. <p> The collector looks up the layout of each stack-frame to determine which stack locations to trace. We record additional liveness information for each variable to avoid tracing pointers that are no longer needed. This approach is well-understood for monomorphic languages requiring garbage collection <ref> [12] </ref>. Following Tolmach [46], we extended it to a polymorphic language as follows: when a variable whose type is unknown is saved in a stack frame, the type of the variable is also saved in the stack frame. <p> In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this. Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere <ref> [12, 11, 48, 15] </ref>. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm [20, 19]. <p> Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere [12, 11, 48, 15]. Britton suggested associating type information with return addresses on the stack <ref> [12] </ref>. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm [20, 19]. None of the unification-based algorithms were implemented due to the complexity of the algorithms and the overhead of performing unification during garbage collection.
Reference: [13] <author> Fred C. Chow. </author> <title> Minimizing register usage penalty at procedure calls. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-94, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: We would also like to improve TIL's compile times, so that large programs can also be compiled as a whole. Finally, we would like to continue improving the performance of ML programs. We would like to extend our register allocation strategy along the lines of Chow <ref> [13] </ref> or Steenkiste [43]. We would also like to investigate more loop optimizations, such as strength-reduction, induction-variable elimination, and loop unrolling. On a more speculative note, we would like to explore stack allocation of data structures.
Reference: [14] <author> A. Demers, M. Weiser, B. Hayes, H. Boehm, D. Bobrow, and S. Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the 17th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <month> January </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: Recording the information at compile time makes it possible for code to use untagged representations. Unlike so-called conservative collectors (see for example <ref> [10, 14] </ref>), the information recorded by TIL is sufficient to collect all unreachable objects. Collection is "nearly" tag-free because tags are placed only on heap-allocated data structures (records and arrays); values in registers, on the stack, and within data structures remain tagless.
Reference: [15] <author> Amer Diwan, Eliot Moss, and Richard Hudson. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 273-282, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this. Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere <ref> [12, 11, 48, 15] </ref>. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm [20, 19].
Reference: [16] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory-System Performance of Programs with Intensive Heap Allocation. </title> <journal> Transactions on Computer Systems, </journal> <month> August </month> <year> 1995. </year>
Reference-contexts: Further performance analysis of TIL appears in Morrisett's [33] and Tarditi's theses [45]. 5.1 Benchmarks Table 1 describes the benchmark programs, which range in size from 62 lines to about 2000 lines of code. Some of these programs have been used previously for measuring ML performance <ref> [5, 16] </ref>. The benchmarks cover a range of application areas including scientific computing, list-processing, systems programming, and compilers. We compiled the programs as single closed modules.
Reference: [17] <author> K. Ekanadham and Arvind. </author> <title> SIMPLE: An exercise in future scientific programming. Technical Report Computation Structures Group Memo 273, </title> <publisher> MIT, </publisher> <address> Cambridge, MA, </address> <month> July </month> <year> 1987. </year> <note> Simultaneously published as IBM/T. J. </note> <institution> Watson Research Center Research Report 12686, Yorktown Heights, NY. </institution>
Reference-contexts: Life 146 The game of Life implemented using lists [39]. Matmult 62 Integer matrix multiply, on 200x200 integer arrays. PIA 2065 The Perspective Inversion Algorithm [47] deciding the location of an object in a perspective video image. Simple 870 A spherical fluid-dynamics program <ref> [17] </ref>, run for 4 iterations with grid size of 100. Table 1: Benchmark Programs measure the size of the run-time system and then added the size of the heap created by exportFn. Finally, we measured end-to-end compilation time, including time to assemble files produced by TIL.
Reference: [18] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In PLDI '93 [36], </booktitle> <pages> pages 237-247. </pages>
Reference-contexts: The optimizations include most of those typically done by compilers for functional languages. They also include loop-oriented optimizations, such as invariant removal, applied to recursive functions. TIL first translates Lmli to a subset of Lmli called Bform. Bform, based on A-Normal-Form <ref> [18] </ref>, is a more regular intermediate language than Lmli that facilitates optimization. The translation from Lmli names all intermediate computations and binds them to variables by a let-construct. It also names all potentially heap-allocated values, including strings, records and functions.
Reference: [19] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection in strongly typed programming languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere [12, 11, 48, 15]. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm <ref> [20, 19] </ref>. None of the unification-based algorithms were implemented due to the complexity of the algorithms and the overhead of performing unification during garbage collection. Aditya, Flood, and Hicks used type-passing to support fully tag-free garbage collection for Id [1].
Reference: [20] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere [12, 11, 48, 15]. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm <ref> [20, 19] </ref>. None of the unification-based algorithms were implemented due to the complexity of the algorithms and the overhead of performing unification during garbage collection. Aditya, Flood, and Hicks used type-passing to support fully tag-free garbage collection for Id [1].
Reference: [21] <author> Cordelia Hall, Simon L. Peyton Jones, and Patrick M. Sansom. </author> <title> Unboxing using specialisation. </title> <editor> In D. Turner K. Hammond, P.M. Sandom, editor, </editor> <booktitle> Functional Programming, 1994. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector. Other researchers have suggested that polymorphism should be eliminated entirely at compile time <ref> [9, 25, 21] </ref>, in the style of C++ templates [44]. This prevents separate compilation of a polymorphic definition from its uses. In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this.
Reference: [22] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In POPL '94 [37], </booktitle> <pages> pages 123-137. </pages>
Reference-contexts: Each source module is compiled to a Lambda module with an explicit list of imported modules and their signatures. Imported signatures may include transparent definitions of types defined in other modules; hence TIL supports a limited form of translucent <ref> [22] </ref> or manifest types [29]. Currently, the mapping to Lambda does not handle signatures, nested structures, or functors.
Reference: [23] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Conference Record of the 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: 1 Introduction We are investigating a new approach to compiling Standard ML (SML) based on four key technologies: intensional polymorphism <ref> [23] </ref>, nearly tag-free garbage collection [12, 46, 34], conventional functional language optimization, and loop optimization. <p> give an overview of the structure of TIL, present a detailed example showing how TIL compiles ML code, and give performance results of code produced by TIL. 2 Overview of the Technologies This section contains a high-level overview of the technologies we use in TIL. 2.1 Intensional Polymorphism Intensional polymorphism <ref> [23] </ref> eliminates restrictions on data representations due to polymorphism, separate compilation, abstract datatypes, and garbage collection. It also supports efficient calling conventions (multiple arguments passed in registers) and tag-free polymorphic, structural equality. <p> The key difficulty with using typed intermediate languages is formulating a type system that is expressive enough to statically type check terms that branch on types at run time, such as sub. The type system used in TIL is based on the approach suggested by Harper and Morrisett <ref> [23, 33] </ref>. Types themselves are represented as expressions in a simply-typed -calculus extended with an inductively generated base kind (the monotypes), and a corresponding induction elimination form. <p> Currently, the mapping to Lambda does not handle signatures, nested structures, or functors. In principle, however, all of these constructs are supported by TIL's intermediate languages. 3.2 Lmli and Type-Directed Optimizations Lmli, which stands for ML i <ref> [23] </ref>, is an intensionally polymorphic language that provides explicit support for constructing, passing, and analyzing types at run-time. We use these constructs in the translation of Lambda to Lmli to provide efficient data representations for user-defined datatypes, multi-argument functions, tag-free polymorphic equality, and specialized arrays.
Reference: [24] <author> Fritz Henglein and Jesper Jtrgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In POPL '94 [37], </booktitle> <pages> pages 213-226. </pages>
Reference-contexts: However, they only supported a limited set of "unboxed types" (ints and floats) and restricted these types from instantiating type variables. Later, Leroy suggested a general approach for unboxing values based on the ML type system [28]. Leroy's approach has been extended and implemented elsewhere <ref> [38, 24, 42] </ref>, including the SML/NJ compiler. It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector.
Reference: [25] <author> M.P. Jones. </author> <title> Partial evaluation for dictionary-free overloading. </title> <institution> Research Report YALEU/DCS/RR-959, Yale University, </institution> <address> New Haven, Connecticut, USA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector. Other researchers have suggested that polymorphism should be eliminated entirely at compile time <ref> [9, 25, 21] </ref>, in the style of C++ templates [44]. This prevents separate compilation of a polymorphic definition from its uses. In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this.
Reference: [26] <author> Simon Peyton Jones and John Launchbury. </author> <title> Unboxed values as first-class citizens. </title> <booktitle> In Proceedings of the Conference on Functional Programming and Computer Architecture, volume 523 of Lecture Notes on Computer Science, </booktitle> <pages> pages 636-666. </pages> <publisher> ACM, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Also, there is no description of the internals of the Napier '88 compiler, nor is there an account of the performance of code generated by the compiler. Peyton Jones and Launchbury suggested that types could be used to unbox values in a polymorphic language <ref> [26] </ref>. However, they only supported a limited set of "unboxed types" (ints and floats) and restricted these types from instantiating type variables. Later, Leroy suggested a general approach for unboxing values based on the ML type system [28].
Reference: [27] <author> David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <address> Palo Alto, California, </address> <month> June </month> <year> 1986. </year> <journal> ACM. </journal> <volume> 21 </volume>
Reference-contexts: These records are paired with the code to form an abstract closure. TIL uses a flat environment representation for type and value environments [5]. For known functions, TIL generates closed code but avoids creating environments or a closure. Following Kranz <ref> [27] </ref>, we modify the call sites of known functions to pass free variables as additional arguments. TIL closes over only variables which are function arguments or are bound within functions.
Reference: [28] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Conference Record of the 19th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: This approach supports fast garbage collection and efficient polymorphic functions, but can result in inefficient code when types are known at compile time. Even with recent advances in SML compilation, such as Leroy's representation analysis <ref> [28] </ref>, values must be placed in a universal representation before being stored in updateable data structures (e.g., arrays) or recursive data structures (e.g., lists). Intensional polymorphism and tag-free garbage collection eliminate the need to use a universal representation when compiling polymorphic languages. <p> However, they only supported a limited set of "unboxed types" (ints and floats) and restricted these types from instantiating type variables. Later, Leroy suggested a general approach for unboxing values based on the ML type system <ref> [28] </ref>. Leroy's approach has been extended and implemented elsewhere [38, 24, 42], including the SML/NJ compiler. It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector.
Reference: [29] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In POPL '94 [37], </booktitle> <pages> pages 109-122. </pages>
Reference-contexts: Each source module is compiled to a Lambda module with an explicit list of imported modules and their signatures. Imported signatures may include transparent definitions of types defined in other modules; hence TIL supports a limited form of translucent [22] or manifest types <ref> [29] </ref>. Currently, the mapping to Lambda does not handle signatures, nested structures, or functors.
Reference: [30] <institution> Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </institution> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference: [31] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Because lists are used often in SML, the SML/NJ compiler also flattens cons cells (and other constructors). However, in violation of the SML Definition <ref> [31] </ref>, SML/NJ prevents programmers from abstracting the type of these constructors, in order to prevent representation mismatches between definitions of abstract datatypes and their uses [3].
Reference: [32] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Conference Record of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: Then it performs switch-continuation inlining, sinking, uncurrying, comparison elimination, fix minimizing, and inlining. The entire process, starting with the reduction optimizations, is iterated two or more times. 3.4 Closure conversion TIL uses a type-directed, abstract closure conversion in the style suggested by Minamide, Morrisett, and Harper <ref> [32] </ref> to convert Lmli-Bform programs to to Lmli-Closure programs. Lmli-Closure is an extension of Lmli-Bform that provides constructs for explicitly constructing closures and their environments. For each escaping Bform function, TIL generates a closed piece of code, a type environment, and a value environment.
Reference: [33] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Published as Technical Report CMU-CS-95-226. </note>
Reference-contexts: The key difficulty with using typed intermediate languages is formulating a type system that is expressive enough to statically type check terms that branch on types at run time, such as sub. The type system used in TIL is based on the approach suggested by Harper and Morrisett <ref> [23, 33] </ref>. Types themselves are represented as expressions in a simply-typed -calculus extended with an inductively generated base kind (the monotypes), and a corresponding induction elimination form. <p> However, unlike Tolmach, we evaluate substitutions of ground types for type variables eagerly instead of lazily. This is due in part for technical reasons (see <ref> [33, Chapter 7] </ref>), and in part to avoid a class of space leaks that might result with lazy substitution. 3 Compilation Phases of TIL conversion use a typed intermediate language. The phase after closure conversion use an untyped 3 4 language where variables are annotated with garbage collection information. <p> Fortunately, the optimizer later eliminates unecessary box/unbox operations during the constant-folding phase, so straight-line floating point code still runs fast. In all, the combination of type-directed optimizations reduce running times by roughly 40% and allocation by 50% <ref> [33, Chapter 8] </ref>. However, much of this improvement can be realized by other techniques; For example, SML/NJ uses Leroy's unboxing technique to achieve comparable improvements for calling conventions [42]. <p> We measure execution time, heap allocation, physical memory requirements, executable size, and compile time. We also measure the effect of loop optimizations. Further performance analysis of TIL appears in Morrisett's <ref> [33] </ref> and Tarditi's theses [45]. 5.1 Benchmarks Table 1 describes the benchmark programs, which range in size from 62 lines to about 2000 lines of code. Some of these programs have been used previously for measuring ML performance [5, 16].
Reference: [34] <author> Greg Morrisett, Matthias Felleisen, and Robert Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <address> La Jolla, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction We are investigating a new approach to compiling Standard ML (SML) based on four key technologies: intensional polymorphism [23], nearly tag-free garbage collection <ref> [12, 46, 34] </ref>, conventional functional language optimization, and loop optimization.
Reference: [35] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(3) </volume> <pages> 342-371, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: If the array dimensions are held unknown, then the loop optimizations speed up matmult by a factor of 2.5. 6 Related Work Morrison et al. used an "ad-hoc" approach to implement polymorphism in their implementation of Napier '88 <ref> [35] </ref>. In particular, they passed representations of types to polymorphic routines at run-time to determine behavior. However, to our knowledge, Napier '88 did not use types to implement tag-free garbage collection.
Reference: [36] <institution> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </institution> <address> Albuquerque, New Mexico, </address> <month> June </month> <year> 1993. </year> <note> ACM. </note>
Reference: [37] <institution> Conference Record of the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </institution> <month> January </month> <year> 1994. </year> <note> ACM. </note>
Reference: [38] <author> Eigil Rosager Poulsen. </author> <title> Representation analysis for efficient implementation of polymorphism. </title> <type> Technical report, </type> <institution> Department of Computer Science (DIKU), University of Copenhagen, </institution> <month> April </month> <year> 1993. </year> <note> Master Dissertation. </note>
Reference-contexts: However, they only supported a limited set of "unboxed types" (ints and floats) and restricted these types from instantiating type variables. Later, Leroy suggested a general approach for unboxing values based on the ML type system [28]. Leroy's approach has been extended and implemented elsewhere <ref> [38, 24, 42] </ref>, including the SML/NJ compiler. It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector.
Reference: [39] <author> Chris Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: FFT 246 Fast fourier transform, multiplying polynomials up to degree 65,536 Knuth-Bendix 618 An implementation of the Knuth-Bendix completion algorithm. Lexgen 1123 A lexical-analyzer generator [6], processing the lexical description of Standard ML. Life 146 The game of Life implemented using lists <ref> [39] </ref>. Matmult 62 Integer matrix multiply, on 200x200 integer arrays. PIA 2065 The Perspective Inversion Algorithm [47] deciding the location of an object in a perspective video image. Simple 870 A spherical fluid-dynamics program [17], run for 4 iterations with grid size of 100.
Reference: [40] <author> Manual Serrano and Pierre Weis. </author> <title> 1+1 = 1: an optimizing CAML compiler. </title> <type> Technical Report 2264, </type> <institution> INRIA, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Another difference is that we calculate type environments eagerly, while the other implementations construct type environments lazily during garbage collection. Loop-oriented optimizations are well-known for imperative languages [2]. However, few results are reported for Lisp, Scheme, and ML. Appel [5] and Serrano <ref> [40] </ref> report common-subexpression elimination optimizations similar to ours. Appel found that CSE was not useful in the SML/NJ 19 compiler.
Reference: [41] <author> Zhong Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Prince-ton University, Princeton, </institution> <address> New Jersey, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: For TIL, we compiled programs with all optimizations enabled. For SML/NJ, we compiled programs using the default optimization settings. We used a recent internal release of SML/NJ (a variant of version 1.08), since it produces code that is about 35% faster than the current standard release (0.93) of SML/NJ <ref> [41] </ref>. TIL always prefixes a set of operations on to each module that it compiles, in order to facilitate optimization. This "inline" prelude contains 2-d array operations, commonly-used list functions, and so forth.
Reference: [42] <author> Zhong Shao and Andrew W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129, </pages> <address> La Jolla, California, </address> <month> June </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: In all, the combination of type-directed optimizations reduce running times by roughly 40% and allocation by 50% [33, Chapter 8]. However, much of this improvement can be realized by other techniques; For example, SML/NJ uses Leroy's unboxing technique to achieve comparable improvements for calling conventions <ref> [42] </ref>. The advantage of our approach is that we use a single mechanism (intensional polymorphism) to specialize calling conventions, flatten constructors, unbox floating-point arrays, and eliminating tags for both polymorphic equality and garbage collection. 3.3 Optimizations TIL employs an extensive set of optimizations. <p> However, they only supported a limited set of "unboxed types" (ints and floats) and restricted these types from instantiating type variables. Later, Leroy suggested a general approach for unboxing values based on the ML type system [28]. Leroy's approach has been extended and implemented elsewhere <ref> [38, 24, 42] </ref>, including the SML/NJ compiler. It does not support unboxed array components nor flattened, recursive datatypes. Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector.
Reference: [43] <author> Peter Steenkiste. </author> <title> Advanced register allocation. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation. </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: We would also like to improve TIL's compile times, so that large programs can also be compiled as a whole. Finally, we would like to continue improving the performance of ML programs. We would like to extend our register allocation strategy along the lines of Chow [13] or Steenkiste <ref> [43] </ref>. We would also like to investigate more loop optimizations, such as strength-reduction, induction-variable elimination, and loop unrolling. On a more speculative note, we would like to explore stack allocation of data structures.
Reference: [44] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, 2nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Tolmach [46] combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector. Other researchers have suggested that polymorphism should be eliminated entirely at compile time [9, 25, 21], in the style of C++ templates <ref> [44] </ref>. This prevents separate compilation of a polymorphic definition from its uses. In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this.
Reference: [45] <author> David R. Tarditi. </author> <title> Optimizing ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: We measure execution time, heap allocation, physical memory requirements, executable size, and compile time. We also measure the effect of loop optimizations. Further performance analysis of TIL appears in Morrisett's [33] and Tarditi's theses <ref> [45] </ref>. 5.1 Benchmarks Table 1 describes the benchmark programs, which range in size from 62 lines to about 2000 lines of code. Some of these programs have been used previously for measuring ML performance [5, 16].
Reference: [46] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In LFP '94 [30], </booktitle> <pages> pages 1-11. </pages>
Reference-contexts: 1 Introduction We are investigating a new approach to compiling Standard ML (SML) based on four key technologies: intensional polymorphism [23], nearly tag-free garbage collection <ref> [12, 46, 34] </ref>, conventional functional language optimization, and loop optimization. <p> The collector looks up the layout of each stack-frame to determine which stack locations to trace. We record additional liveness information for each variable to avoid tracing pointers that are no longer needed. This approach is well-understood for monomorphic languages requiring garbage collection [12]. Following Tolmach <ref> [46] </ref>, we extended it to a polymorphic language as follows: when a variable whose type is unknown is saved in a stack frame, the type of the variable is also saved in the stack frame. <p> Later, Leroy suggested a general approach for unboxing values based on the ML type system [28]. Leroy's approach has been extended and implemented elsewhere [38, 24, 42], including the SML/NJ compiler. It does not support unboxed array components nor flattened, recursive datatypes. Tolmach <ref> [46] </ref> combined Leroy's approach with tag-free garbage collection. However, he used an ad hoc approach to propagate type information to the collector. Other researchers have suggested that polymorphism should be eliminated entirely at compile time [9, 25, 21], in the style of C++ templates [44]. <p> Goldberg and Gloger improved Appel's algorithm [20, 19]. None of the unification-based algorithms were implemented due to the complexity of the algorithms and the overhead of performing unification during garbage collection. Aditya, Flood, and Hicks used type-passing to support fully tag-free garbage collection for Id [1]. Independently, Tolmach <ref> [46] </ref> implemented a type-passing garbage collection algorithm for ML. Our approach differs from others by using "nearly" tag-free collection. In particular, records and arrays on the heap are tagged. Another difference is that we calculate type environments eagerly, while the other implementations construct type environments lazily during garbage collection.
Reference: [47] <author> Kevin G. Waugh, Patrick McAndrew, and Greg Michaelson. </author> <title> Parallel implementations from function prototypes: a case study. </title> <institution> Technical Report Computer Science 90/4, Heriot-Watt University, Edinburgh, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Lexgen 1123 A lexical-analyzer generator [6], processing the lexical description of Standard ML. Life 146 The game of Life implemented using lists [39]. Matmult 62 Integer matrix multiply, on 200x200 integer arrays. PIA 2065 The Perspective Inversion Algorithm <ref> [47] </ref> deciding the location of an object in a perspective video image. Simple 870 A spherical fluid-dynamics program [17], run for 4 iterations with grid size of 100. Table 1: Benchmark Programs measure the size of the run-time system and then added the size of the heap created by exportFn.
Reference: [48] <author> P.L. Wodon. </author> <title> Methods of garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year> <month> 22 </month>
Reference-contexts: In contrast, intensional polymorphism, and in particular the intermediate forms of TIL, support separate compilation of polymorphic definitions, though we have yet to take advantage of this. Tag-free garbage collection was originally proposed for monomorphic languages like Pascal, but has been used elsewhere <ref> [12, 11, 48, 15] </ref>. Britton suggested associating type information with return addresses on the stack [12]. Appel suggested extending this technique to ML by using unification [4]. Goldberg and Gloger improved Appel's algorithm [20, 19].
References-found: 48

