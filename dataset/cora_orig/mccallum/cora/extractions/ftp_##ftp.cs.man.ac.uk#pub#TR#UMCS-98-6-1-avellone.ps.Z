URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-avellone.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: favellone,ferram,migliolig@dsi.unimi.it  
Title: Synthesis of Programs in Abstract Data Types  
Author: Alessandro Avellone Mauro Ferrari Pierangelo Miglioli 
Address: via Comelico 39, 20135 Milano-Italy  
Affiliation: Dipartimento di Scienze dell'Informazione Universita degli Studi di Milano  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Avellone. </author> <title> The algorithmic content of constructive proofs: translating proofs into programs and interpreting proofs as programs. </title> <type> PhD thesis, </type> <institution> Dipartimento di Scienze dell'Informazione, Universita degli Studi di Milano, Italy, </institution> <year> 1998. </year>
Reference-contexts: These considerations should explain why our synthesis method only translate the rules of 9-introduction (assignments), of _-introduction (assignment to the tv variable) and of _-elimination (if-then-else). Here, we will not give all the definitions related to OE -dis sets (see, <ref> [1] </ref> for a complete definition and discussion on dischargeable sets); we only give the main definitions and results. Thus, let I = f 1 ; : : : ; n g be any set of classically consistent sets of wffs 2 not containing the empty set. <p> Proof: The assertion can be proved by induction according the primitive recursive description of f using the strongly numeralwise representable property in IPA of primitive recursive functions (for a detailed definition we refer the reader to <ref> [1, 5] </ref>). 2 As an immediate consequence of Theorem 5 one get: for every assignmot o 9z fl (x 1 ;: : :; x n ; z) AE, if (x 1 ;: : :; x n ; z) is the representing wff of a primitive recursive function f (x 1 ;:
Reference: [2] <author> J. Bates and R. Constable. </author> <title> Proof as programs. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Starting from the pioneering work of Constable [4], Constructive Program Synthesis has been investigated by many authors. A non exhaustive list is <ref> [2, 8, 10, 12, 14] </ref>. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., [2, 10, 11]). <p> A non exhaustive list is [2, 8, 10, 12, 14]. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., <ref> [2, 10, 11] </ref>). It is based on the fact that constructive proofs can be (almost) directly interpreted as executable programs, using for example, the Curry-Howard isomor-phism, or other kinds of operational interpretations, like the one in [10].
Reference: [3] <author> A. Bertoni, G. Mauri, and P. Miglioli. </author> <title> On the power of model theory to specify abstract data types and to capture their recursiveness. </title> <note> Fundamenta Informaticae, VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: I is an isoinitial model of T iff, for every model M of T, there is an unique isomorphic embedding : I ! M. For an initial model, homomorphisms are used in the place of isomorphic embeddings. Isoinitial models have been introduced in <ref> [3] </ref> and have been used in specification frameworks by [7]. Here we use isoinitial models because they seem more suitable to a constructive approach (see also [9]). In particular, we are interested in the following properties.
Reference: [4] <author> R. Constable. </author> <title> Constructive mathematics and automatic program writers. </title> <booktitle> In Proc. IFIP 1971 (Lublijana). </booktitle> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: 1 Introduction Starting from the pioneering work of Constable <ref> [4] </ref>, Constructive Program Synthesis has been investigated by many authors. A non exhaustive list is [2, 8, 10, 12, 14]. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S.
Reference: [5] <author> M. Ferrari. </author> <title> Strongly Constructive Formal Systems. </title> <type> PhD thesis, </type> <institution> Dipartimento di Scienze dell'Informazione, Universita degli Studi di Milano, Italy, </institution> <year> 1997. </year>
Reference-contexts: Proof: The assertion can be proved by induction according the primitive recursive description of f using the strongly numeralwise representable property in IPA of primitive recursive functions (for a detailed definition we refer the reader to <ref> [1, 5] </ref>). 2 As an immediate consequence of Theorem 5 one get: for every assignmot o 9z fl (x 1 ;: : :; x n ; z) AE, if (x 1 ;: : :; x n ; z) is the representing wff of a primitive recursive function f (x 1 ;:
Reference: [6] <author> J. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and editors P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Reachability is known in literature also as "no junk" <ref> [6] </ref>. It means that every element of the domain is representable by a ground term. Isoinitial models are similar to the more popular initial models. I is an isoinitial model of T iff, for every model M of T, there is an unique isomorphic embedding : I ! M.
Reference: [7] <author> K.K. Lau and M. Ornaghi. </author> <title> Forms of logic specifications: a preliminary study. </title> <editor> In J. Gallagher, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 96, LNCS 1207, </volume> <pages> pages 295-312, </pages> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: For an initial model, homomorphisms are used in the place of isomorphic embeddings. Isoinitial models have been introduced in [3] and have been used in specification frameworks by <ref> [7] </ref>. Here we use isoinitial models because they seem more suitable to a constructive approach (see also [9]). In particular, we are interested in the following properties.
Reference: [8] <author> P. Miglioli, U. Moscato, and M. Or-naghi. </author> <title> Program specification and synthesis in constructive formal systems. </title> <editor> In K.- K. Lau and T.P. Clement, editors, </editor> <title> Logic Program Synthesis and Transformation, </title> <booktitle> Manchester 1991, </booktitle> <pages> pages 13-26. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Workshops in Computing. </note>
Reference-contexts: 1 Introduction Starting from the pioneering work of Constable [4], Constructive Program Synthesis has been investigated by many authors. A non exhaustive list is <ref> [2, 8, 10, 12, 14] </ref>. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., [2, 10, 11]).
Reference: [9] <author> P. Miglioli, U. Moscato, and M. Ornaghi. </author> <title> An improved refutation system for intu-itionistic predicate logic. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 12 </volume> <pages> 361-373, </pages> <year> 1994. </year>
Reference-contexts: For an initial model, homomorphisms are used in the place of isomorphic embeddings. Isoinitial models have been introduced in [3] and have been used in specification frameworks by [7]. Here we use isoinitial models because they seem more suitable to a constructive approach (see also <ref> [9] </ref>). In particular, we are interested in the following properties. <p> Semiconstructive systems have been introduced and discussed in <ref> [9] </ref>. Here we are interested in the following property. Theorem 2 Let T be a -theory with at least one reachable model and let us suppose that T is semiconstructive in L.
Reference: [10] <author> P. Miglioli and M. Ornaghi. </author> <title> A logically justified model of computation. </title> <journal> Funda-menta Informaticae, </journal> <volume> IV,1,2:151-172,277-341, </volume> <year> 1981. </year>
Reference-contexts: 1 Introduction Starting from the pioneering work of Constable [4], Constructive Program Synthesis has been investigated by many authors. A non exhaustive list is <ref> [2, 8, 10, 12, 14] </ref>. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., [2, 10, 11]). <p> A non exhaustive list is [2, 8, 10, 12, 14]. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., <ref> [2, 10, 11] </ref>). It is based on the fact that constructive proofs can be (almost) directly interpreted as executable programs, using for example, the Curry-Howard isomor-phism, or other kinds of operational interpretations, like the one in [10]. <p> It is based on the fact that constructive proofs can be (almost) directly interpreted as executable programs, using for example, the Curry-Howard isomor-phism, or other kinds of operational interpretations, like the one in <ref> [10] </ref>. In this abstract we follow a different, less popular approach, that we call program-extraction. Here, the relevant computational content of a constructive proof is extracted in the form of a program of a target programming language. We have chosen an imperative, Pascal-like programming language.
Reference: [11] <author> Chetan R. Murthy. </author> <title> Classical proofs as programs: How, what, and why. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <month> 613:71 ??, </month> <year> 1992. </year>
Reference-contexts: A non exhaustive list is [2, 8, 10, 12, 14]. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., <ref> [2, 10, 11] </ref>). It is based on the fact that constructive proofs can be (almost) directly interpreted as executable programs, using for example, the Curry-Howard isomor-phism, or other kinds of operational interpretations, like the one in [10].
Reference: [12] <author> Helmut Schwichtenberg. </author> <title> Proofs as programs. </title> <editor> In P. Aczel, H. Simmons, and S. S. Wainer, editors, </editor> <booktitle> Proof Theory. A selection of papers from the Leeds Proof Theory Pro-gramme 1990, </booktitle> <pages> pages 81-113. </pages> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Starting from the pioneering work of Constable [4], Constructive Program Synthesis has been investigated by many authors. A non exhaustive list is <ref> [2, 8, 10, 12, 14] </ref>. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., [2, 10, 11]).
Reference: [13] <author> A. S. Troelstra. </author> <title> Metamathematical Investigation of Intuitionistic Arithmetic and Analysis. </title> <booktitle> Lecture Notes in Mathematics 344. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1973. </year>
Reference-contexts: ;: : :; x n ; w) is the representing wff of f (x 1 ;: : :; x n ). 2 We can extend the previous result into a completeness result involving all the partial recursive functions with the help of new proof patterns involving Markov Principle. (see, e.g., <ref> [13] </ref>) and new synthesis rules; more details will be given in the full paper.
Reference: [14] <author> A. A. Voronkov. </author> <title> On completeness of program synthesis systems. </title> <editor> In E. Borger, G. Jager, H. Kleine Buning, and M.M. Richter, editors, </editor> <booktitle> Computer Science Logic, </booktitle> <pages> pages 411-418. </pages> <booktitle> 5th Workshop, CSL '91, Berne, </booktitle> <address> Switzerland, </address> <publisher> Springer-Verlag, </publisher> <month> Oc-tober </month> <year> 1991 1991. </year> <month> 8 </month>
Reference-contexts: 1 Introduction Starting from the pioneering work of Constable [4], Constructive Program Synthesis has been investigated by many authors. A non exhaustive list is <ref> [2, 8, 10, 12, 14] </ref>. The general idea is that a constructive proof of a specification S implicitly contains an algorithm to solve S. A popular approach to Constructive Program Synthesis is known as proofs as programs (see, e.g., [2, 10, 11]).
References-found: 14

