URL: http://www.cs.unc.edu/~anderson/papers/disc98.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Wait-Free Synchronization in Quantum-Based Multiprogrammed Systems (Extended Abstract)  
Author: James H. Anderson, Rohit Jain, and David Ott 
Address: Chapel Hill  
Affiliation: Department of Computer Science University of North Carolina at  
Abstract: We consider wait-free synchronization in multiprogrammed uniprocessor and multiprocessor systems in which the processes bound to each processor are scheduled for execution using a scheduling quantum. We show that, in such systems, any object with consensus number P in Herlihy's wait-free hierarchy is universal for any number of processes executing on P processors, provided the scheduling quantum is of a certain size. We give an asymptotically tight characterization of how large the scheduling quantum must be for this result to hold. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Anderson, R. Jain, and D. Ott. </author> <title> Wait-free synchronization in quantum-based multiprogrammed systems, </title> <month> May </month> <year> 1998. </year> <note> Available at http://www.cs.unc.edu/ ~anderson/papers.html. </note>
Reference-contexts: As C varies, the quantum required for this consensus implementation to work correctly is as given in Table 1. In the full paper, we prove that our characterization of the required quantum is asymptotically tight <ref> [1] </ref>. This proof is omitted here due to space limitations. We end the paper with concluding remarks in Sect. 5. 2 Definitions and Notation A quantum-based system consists of a set a processes and a set of processors. <p> In our implementation, the Seen flags provide the needed mechanism. There are two pairs of such flags for each process p, Seen1 [p; 0]/Seen2 [p; 0] and Seen1 <ref> [p; 1] </ref>/Seen2 [p; 1]. p alternates between these pairs from one C&S to the next. The current pair is given by p's alt variable. <p> In our implementation, the Seen flags provide the needed mechanism. There are two pairs of such flags for each process p, Seen1 [p; 0]/Seen2 [p; 0] and Seen1 <ref> [p; 1] </ref>/Seen2 [p; 1]. p alternates between these pairs from one C&S to the next. The current pair is given by p's alt variable. If p detects that Seen2 [p; alt ] holds, then it knows that a value it has assigned to X1 or X2 has been seen by another process. <p> We now state some lemmas about the number of access failures that may occur in a history. We first consider the two extremes C = 2P and C = P and then the general case (proofs of Lemmas 4 and 5 can be found in <ref> [1] </ref>). Lemma 4: Suppose that C = 2P and that Q is large enough to ensure that each process can be preempted at most once while accessing any two consensus levels in succession (the two levels don't have to be consecutive). <p> in polynomial space and time for any number of processes using read/write registers and C-consensus objects if C P and Q max (2c; c (2P + 1 C)). 2 In the full paper, we prove the following theorem, showing that the quantum used in the implementation above is asymptotically tight <ref> [1] </ref>. <p> This algorithm is correct if Q = 8 (this requires first replacing the for loop by straight-line code), just like our uniprocessor consensus algorithm. However, their algorithm requires fewer references to shared memory. The algorithm employs three shared variables, P <ref> [1] </ref>, P [2], and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then to P [3]. We found our mechanism of detecting preemptions to be much easier to employ when implementing other objects. <p> However, their algorithm requires fewer references to shared memory. The algorithm employs three shared variables, P <ref> [1] </ref>, P [2], and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then to P [3]. We found our mechanism of detecting preemptions to be much easier to employ when implementing other objects.
Reference: 2. <author> M. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <year> 1991. </year>
Reference-contexts: In related previous work, Ramamurthy, Moir, and Anderson considered wait-free synchronization in multiprogrammed systems in which processes on the same processor are scheduled by priority [4]. For such systems, Ramamurthy et al. showed that any object with consensus number P in Herlihy's wait-free hierarchy <ref> [2] </ref> is universal for any number of processes executing on P processors, i.e., universality is a function of the number of processors in a system, not the number of processes. <p> Obviously, if C &lt; P , then universal algorithms are impossible <ref> [2] </ref>. If P C 2P , then the smallest value of Q that suffices is a value proportional to (2P + 1 C)T max . If 2P C &lt; 1, then the smallest value of Q that suffices is a value proportional to 2T max . <p> If 2P C &lt; 1, then the smallest value of Q that suffices is a value proportional to 2T max . If C = 1, then Q (obviously) can be any value <ref> [2] </ref>. An important special case of our main result is that reads and writes are universal in quantum-based uniprocessor systems (P = 1). In this case, the scheduling quantum must be large enough to encompass the execution of eight high-level language instructions (see Theorem 1). <p> Then, in Sect. 3, we present our results for quantum-based uniprocessor systems. We begin by presenting a wait-free, constant-time implementation of a consensus object that uses only reads and writes and a quantum of constant size. This implementation proves that reads and writes are universal in quantum-based uniprocessor systems <ref> [2] </ref>. Object implementations of practical interest are usually based on synchronization primitives such as compare-and-swap (C&S), not consensus objects. We show that, given a quantum of constant size and using only reads and writes, C&S can be implemented in a quantum-based uniprocessor system in constant time. <p> This algorithm is correct if Q = 8 (this requires first replacing the for loop by straight-line code), just like our uniprocessor consensus algorithm. However, their algorithm requires fewer references to shared memory. The algorithm employs three shared variables, P [1], P <ref> [2] </ref>, and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then to P [3]. We found our mechanism of detecting preemptions to be much easier to employ when implementing other objects. <p> However, their algorithm requires fewer references to shared memory. The algorithm employs three shared variables, P [1], P <ref> [2] </ref>, and P [3]. The idea is to attempt to copy a value from P [1] to P [2], and then to P [3]. We found our mechanism of detecting preemptions to be much easier to employ when implementing other objects.
Reference: 3. <author> M. Moir and S. </author> <title> Ramamurthy. </title> <type> Private communication. </type> <year> 1998. </year>
Reference-contexts: P : array [1::3] of valtype [ ? initially ? procedure decide (val: valtype) returns valtype private variable v; w: valtype 1: v := val; 3: w := P [i]; 4: if w 6= ? then 5: v := w else 6: P [i] := v od; 7: return P <ref> [3] </ref> Fig. 6. Moir and Ramamurthy's uniprocessor consensus algorithm. 5 Concluding Remarks Our work was partially inspired by a read/write consensus algorithm for quantum-based uniprocessor systems due to Moir and Ramamurthy [3]. <p> if w 6= ? then 5: v := w else 6: P [i] := v od; 7: return P <ref> [3] </ref> Fig. 6. Moir and Ramamurthy's uniprocessor consensus algorithm. 5 Concluding Remarks Our work was partially inspired by a read/write consensus algorithm for quantum-based uniprocessor systems due to Moir and Ramamurthy [3]. Actually, their goal was to design wait-free algorithms for multiprocessor systems in which the processor-to-memory bus is allocated to processors using quantum-based scheduling. Their consensus algorithm, which is shown in Fig. 6, is also correct in a quantum-based uniprocessor system. <p> This algorithm is correct if Q = 8 (this requires first replacing the for loop by straight-line code), just like our uniprocessor consensus algorithm. However, their algorithm requires fewer references to shared memory. The algorithm employs three shared variables, P [1], P [2], and P <ref> [3] </ref>. The idea is to attempt to copy a value from P [1] to P [2], and then to P [3]. We found our mechanism of detecting preemptions to be much easier to employ when implementing other objects. <p> However, their algorithm requires fewer references to shared memory. The algorithm employs three shared variables, P [1], P [2], and P <ref> [3] </ref>. The idea is to attempt to copy a value from P [1] to P [2], and then to P [3]. We found our mechanism of detecting preemptions to be much easier to employ when implementing other objects.
Reference: 4. <author> S. Ramamurthy, M. Moir, and J. Anderson. </author> <title> Real-time object sharing with minimal support. </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 233-242. </pages> <year> 1996. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction This paper is concerned with wait-free synchronization in multiprogrammed systems. In such systems, several processes may be bound to the same processor. In related previous work, Ramamurthy, Moir, and Anderson considered wait-free synchronization in multiprogrammed systems in which processes on the same processor are scheduled by priority <ref> [4] </ref>. For such systems, Ramamurthy et al. showed that any object with consensus number P in Herlihy's wait-free hierarchy [2] is universal for any number of processes executing on P processors, i.e., universality is a function of the number of processors in a system, not the number of processes.
References-found: 4

