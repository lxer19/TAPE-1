URL: http://cse.ogi.edu/~sheard/papers/PepmTdpe97.ps
Refering-URL: http://www.cse.ogi.edu/~sheard/sheard.html
Root-URL: http://www.cse.ogi.edu
Email: sheard@cse.ogi.edu  
Title: A Type-directed, On-line, Partial Evaluator for a Polymorphic Language  
Author: Tim Sheard 
Address: P.O. Box 91000, Portland, OR 97291-1000 USA  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: Recently, Olivier Danvy introduced a new, simple method for implementing powerful partial evaluators, namely type-directed partial evaluation[9]. He introduced a partial evaluator for the simply-typed lambda calculus (x2). This paper explores the possibility of using the same techniques over a lambda calculus with a richer type system. We generalize and extend Danvy's work in four ways: 1. Our system handles a much richer language than that 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Altenkirch, M. Hofmann, and T. Streicher. </author> <title> Categorical reconstruction of a reduction free normalization proof. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 953, </volume> <year> 1995. </year>
Reference-contexts: Recent work has used such techniques to construct the inverse of the evaluation functional [2] and to demonstrate that every term (in a combinator form) of system F has a normal form <ref> [1] </ref>. In the latter work, a constructive proof is used to extract an ML program remarkably similar to the reification based partial evaluator for the polymorphic lambda calculus. Recent work by John Hughes [16] builds another framework for type based partial evaluation.
Reference: [2] <author> U. Berger and H. Schwichtenberg. </author> <title> An inverse of the evaluation functional for typed -calculus. </title> <booktitle> In LICS'91, Symposium on Logic in Computer Science, Amsterdam, </booktitle> <pages> pages 203-211. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Danvy points out several other examples in the literature where the same strategy (using types to turn functions produced from a closed expressions into terms) is used <ref> [8, 2] </ref>. The key to this process is the reflect function. The function f, expects an argument (of type value) with a particular shape; that is to say an argument constructed in a particular way from the constructors vint and vfun. <p> The technique of using expansion-reduction systems to reach normal forms is well known in the rewriting community, especially the use of eta-expansion [17]. Recent work has used such techniques to construct the inverse of the evaluation functional <ref> [2] </ref> and to demonstrate that every term (in a combinator form) of system F has a normal form [1]. In the latter work, a constructive proof is used to extract an ML program remarkably similar to the reification based partial evaluator for the polymorphic lambda calculus.
Reference: [3] <author> A. Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. In N.D. </title> <editor> Jones, editor, </editor> <booktitle> ESOP '90. 3rd European Symposium on Programming, Copen-hagen, Denmark, May 1990 (Lecture Notes in Computer Science, </booktitle> <volume> vol. 432), </volume> <pages> pages 70-87. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: Two of the harder problems in partial evaluation are pushing a static context over a dynamic branch such as an if or case, and handling higher order functions. The first has been handled by continuation based specialization [6, 4], and the second by a closure analysis <ref> [14, 15, 3, 5] </ref>. In reification based systems, higher order functions are treated like any other function, and static contexts are handled implicitly by the use of the shift and reset control operators which abstract the current context and push it into the clauses of the case.
Reference: [4] <author> A. Bondorf. </author> <title> Improving binding times without explicit cps-conversion. </title> <booktitle> In 1992 ACM Conference in Lisp and Functional Programming, </booktitle> <address> San Francisco, </address> <booktitle> Califor-nia (Lisp Pointers, </booktitle> <volume> vol. V, no. 1, </volume> <year> 1992), </year> <pages> pages 1-10. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: Two of the harder problems in partial evaluation are pushing a static context over a dynamic branch such as an if or case, and handling higher order functions. The first has been handled by continuation based specialization <ref> [6, 4] </ref>, and the second by a closure analysis [14, 15, 3, 5].
Reference: [5] <author> C. Consel. </author> <title> Binding time analysis for higher order un-typed functional languages. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, Nice, France, </booktitle> <pages> pages 264-272. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Two of the harder problems in partial evaluation are pushing a static context over a dynamic branch such as an if or case, and handling higher order functions. The first has been handled by continuation based specialization [6, 4], and the second by a closure analysis <ref> [14, 15, 3, 5] </ref>. In reification based systems, higher order functions are treated like any other function, and static contexts are handled implicitly by the use of the shift and reset control operators which abstract the current context and push it into the clauses of the case.
Reference: [6] <author> C. Consel and O. Danvy. </author> <title> For a better support of static data flow. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <booktitle> August 1991 (Lecture Notes in Computer Science, </booktitle> <volume> vol. 523), </volume> <pages> pages 496-519. </pages> <address> New York: </address> <publisher> ACM, Berlin: Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Two of the harder problems in partial evaluation are pushing a static context over a dynamic branch such as an if or case, and handling higher order functions. The first has been handled by continuation based specialization <ref> [6, 4] </ref>, and the second by a closure analysis [14, 15, 3, 5].
Reference: [7] <author> C. Consel and O. Danvy. </author> <title> Partial evaluation in parallel. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 5(4) </volume> <pages> 315-330, </pages> <year> 1993. </year>
Reference-contexts: The traditional 4 partial evaluation literature describes two separate techniques which are used to control the complexity of performing symbolic evaluation of the source program given its static inputs. The first, off-line partial evaluation <ref> [18, 7] </ref>, uses an initial phase, called binding-time analysis, which uses only the fact that an input is static, to construct an annotated program. This annotated program is then resid-ualized, executing the static components and rebuilding the dynamic components to construct the residual program.
Reference: [8] <author> R. Di Cosmo. </author> <title> Isomorphisms of types: from -calculus to information retrieval and language design. </title> <editor> In Ronald V. Book, editor, </editor> <booktitle> Progress in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <year> 1995. </year>
Reference-contexts: Danvy points out several other examples in the literature where the same strategy (using types to turn functions produced from a closed expressions into terms) is used <ref> [8, 2] </ref>. The key to this process is the reflect function. The function f, expects an argument (of type value) with a particular shape; that is to say an argument constructed in a particular way from the constructors vint and vfun.
Reference: [9] <author> O. Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In POPL'96: The 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Pe-tersburg, Florida, </address> <month> January </month> <year> 1996, </year> <pages> pages 242-257. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: A contribution of this paper is that effective partial evaluators, for realistic languages, can be built as expansion-reduction systems, and that the type-directed strategy of Danvy <ref> [9] </ref> is exactly the mechanism needed to determine when expansion is necessary. In this paper we provide the details of implementing a reification based partial evaluator as an expansion-reduction system. <p> To fix this some sort of reification-time match handling is needed that elides branches of sum-abstractions that cause reification time match errors. 13 Related work This work was inspired by the work of Danvy <ref> [9] </ref>, which first demonstrated to the author the concept of reification based partial evaluation. Our use of a value type which embeds type information is a major contribution to Danvy's work. Danvy used the Scheme compiler as his reduction engine.
Reference: [10] <author> O. Danvy and A. Filinski. </author> <title> Abstracting control. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160. </pages> <publisher> ACM, ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: By inspecting the domain t this choice can be made. It builds an appropriate abstraction with "fresh" bound variables, and uses Danvy and Filinski's reset control operator <ref> [10, 13] </ref> to delimit a new dynamic context. Think of this dynamic context as a limited contin-utation, which when applied, will carry forward only that part of the continuation starting from the shift operator. This context may be extracted by a shift control operator in the reflect function. <p> This technique has been quite effective in removing run-time datatype tags, when the specialized version of a program no longer needs them. 14 Future Work For a long time, it appeared to the author that the delimited control operators shift and reset <ref> [10] </ref> were necessary to do reification over sums.
Reference: [11] <author> O. Danvy, K. Malmkjr, and J. Palsberg. </author> <title> The essence of eta-expansion in partial evaluation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(3) </volume> <pages> 209-228, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: The implementations for shift and reset in SML used in our implementation can be found in the literature [13] Expansion of a value to reflect its type has been used by Danvy, Malmkjr and Palsberg to perform binding-time improvements <ref> [11] </ref>. The technique of using expansion-reduction systems to reach normal forms is well known in the rewriting community, especially the use of eta-expansion [17].
Reference: [12] <author> L. Fegaras and T. Sheard. </author> <title> Revisiting catamorphisms over datatypes with embedded functions (or, programs from outer space). </title> <booktitle> In Conference Record of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <pages> pages 284-294, </pages> <address> St. Petersburg, Florida, </address> <month> January 21-24, </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: The domain of values contains constructors for integers (vint) and functions (vfun) corresponding to the types tint and tarrow. In addition, the domain of values must also contain the coercion <ref> [12] </ref> vdyn. This constructor is crucial to implementing reification, it allows the syntactic domain to be embedded in the semantic domain. Dynamic values are transparent at the programmer level interface and are used only by the reification process. The evaluation function is completely standard. <p> The use of an injection constructor (vdyn) which allows the embedding of the syntactic domain into the semantic domain has roots in our earlier work on the use of cata-morphisms as structured control operators <ref> [12] </ref>, and on meta programming systems where code is a first class value [22]. The use of lazy expansion in the reflect function we find reminiscent of the delayed expansion of encodings in Launchbury's work on self applicable partial evaluators for strongly-typed languages [19].
Reference: [13] <author> A. Filinski. </author> <title> Representing monads. </title> <booktitle> In Conference Record of the 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457. </pages> <publisher> ACM, ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: By inspecting the domain t this choice can be made. It builds an appropriate abstraction with "fresh" bound variables, and uses Danvy and Filinski's reset control operator <ref> [10, 13] </ref> to delimit a new dynamic context. Think of this dynamic context as a limited contin-utation, which when applied, will carry forward only that part of the continuation starting from the shift operator. This context may be extracted by a shift control operator in the reflect function. <p> This risks duplicating code, but this code duplication can often be controlled by restructuring the program. The implementations for shift and reset in SML used in our implementation can be found in the literature <ref> [13] </ref> Expansion of a value to reflect its type has been used by Danvy, Malmkjr and Palsberg to perform binding-time improvements [11]. The technique of using expansion-reduction systems to reach normal forms is well known in the rewriting community, especially the use of eta-expansion [17]. <p> Because shift and reset can be implemented using continuations and state <ref> [13] </ref>, it seems 4 As opposed to type-directed. 11 reasonable that these same mechanisms could be used to construct a type-directed partial evaluator over sums which uses continuations and state instead of shift and reset.
Reference: [14] <author> C. K. Gomard. </author> <title> Higher order partial evaluation HOPE for the lambda calculus. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Two of the harder problems in partial evaluation are pushing a static context over a dynamic branch such as an if or case, and handling higher order functions. The first has been handled by continuation based specialization [6, 4], and the second by a closure analysis <ref> [14, 15, 3, 5] </ref>. In reification based systems, higher order functions are treated like any other function, and static contexts are handled implicitly by the use of the shift and reset control operators which abstract the current context and push it into the clauses of the case.
Reference: [15] <editor> C.K. Gomard and N.D. Jones. </editor> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <month> January </month> <year> 1991. </year> <month> 12 </month>
Reference-contexts: Two of the harder problems in partial evaluation are pushing a static context over a dynamic branch such as an if or case, and handling higher order functions. The first has been handled by continuation based specialization [6, 4], and the second by a closure analysis <ref> [14, 15, 3, 5] </ref>. In reification based systems, higher order functions are treated like any other function, and static contexts are handled implicitly by the use of the shift and reset control operators which abstract the current context and push it into the clauses of the case.
Reference: [16] <author> J. Hughes. </author> <title> Type specialisation for the -calculus; or, a new paradigm for partial evaluation based on type inference. </title> <type> Technical report, </type> <institution> Department of Cop-muter Science, Chalmers Technical University, </institution> <address> URL: http://www.cs.chalmers.se/ rjmh., </address> <year> 1996. </year>
Reference-contexts: In the latter work, a constructive proof is used to extract an ML program remarkably similar to the reification based partial evaluator for the polymorphic lambda calculus. Recent work by John Hughes <ref> [16] </ref> builds another framework for type based partial evaluation. Here, rather than base the propagation of static information on the unfolding of functions a type inference-like analysis is used instead.
Reference: [17] <author> C. B. Jay. </author> <title> Long fi normal forms and confluence (revised). </title> <type> Technical Report ECS-LFCS-91-183, </type> <institution> Department of Computer Science, University of Ed-inburgh, </institution> <month> June </month> <year> 1992. </year> <note> revised version available at http://theory.doc.ic.ac.uk/tfm/papers/JayCB/longbeta-eta.dvi.Z. </note>
Reference-contexts: The technique of using expansion-reduction systems to reach normal forms is well known in the rewriting community, especially the use of eta-expansion <ref> [17] </ref>. Recent work has used such techniques to construct the inverse of the evaluation functional [2] and to demonstrate that every term (in a combinator form) of system F has a normal form [1].
Reference: [18] <author> N.D. Jones, C.K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: The traditional 4 partial evaluation literature describes two separate techniques which are used to control the complexity of performing symbolic evaluation of the source program given its static inputs. The first, off-line partial evaluation <ref> [18, 7] </ref>, uses an initial phase, called binding-time analysis, which uses only the fact that an input is static, to construct an annotated program. This annotated program is then resid-ualized, executing the static components and rebuilding the dynamic components to construct the residual program.
Reference: [19] <author> J. Launchbury. </author> <title> A strongly typed self-applicable partial evaluator. </title> <booktitle> In FPCA'91: Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Ma., </address> <pages> pages 145-164, </pages> <address> Berlin, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag, LNCS 523. </note>
Reference-contexts: The use of lazy expansion in the reflect function we find reminiscent of the delayed expansion of encodings in Launchbury's work on self applicable partial evaluators for strongly-typed languages <ref> [19] </ref>. The traditional 4 partial evaluation literature describes two separate techniques which are used to control the complexity of performing symbolic evaluation of the source program given its static inputs.
Reference: [20] <author> E. Ruf. </author> <title> Topics in Online Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Stanford University, California, </institution> <month> February </month> <year> 1993. </year> <note> Published as technical report CSL-TR-93-563. </note>
Reference-contexts: This annotated program is then resid-ualized, executing the static components and rebuilding the dynamic components to construct the residual program. On-line partial evaluators <ref> [21, 20] </ref>, on the other hand, use the actual values associated with the static inputs to symbolically execute the source to build the residual program. We consider our partial evaluator on-line since the implementation of "smart" primitives actually probes the actual values of the static inputs.
Reference: [21] <author> E. Ruf and D. Weise. </author> <title> On the specialization of online program specializers. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 251-281, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: This annotated program is then resid-ualized, executing the static components and rebuilding the dynamic components to construct the residual program. On-line partial evaluators <ref> [21, 20] </ref>, on the other hand, use the actual values associated with the static inputs to symbolically execute the source to build the residual program. We consider our partial evaluator on-line since the implementation of "smart" primitives actually probes the actual values of the static inputs.
Reference: [22] <author> T. Sheard. </author> <title> Well typed meta-programming systems. </title> <type> Technical Report 95-013, </type> <institution> Oregon Graduate Institute, </institution> <address> P.O. Box 91000, Portland, Oregon 97291-1000 USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: The use of an injection constructor (vdyn) which allows the embedding of the syntactic domain into the semantic domain has roots in our earlier work on the use of cata-morphisms as structured control operators [12], and on meta programming systems where code is a first class value <ref> [22] </ref>. The use of lazy expansion in the reflect function we find reminiscent of the delayed expansion of encodings in Launchbury's work on self applicable partial evaluators for strongly-typed languages [19].
References-found: 22

