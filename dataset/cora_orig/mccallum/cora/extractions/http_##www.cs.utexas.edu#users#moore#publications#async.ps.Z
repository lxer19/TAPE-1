URL: http://www.cs.utexas.edu/users/moore/publications/async.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/best-ideas/async/index.html
Root-URL: 
Title: Formal Aspects of A Formal Model of Asynchronous Communication and Its Use in Mechanically Verifying
Author: J Strother Moore 
Keyword: hardware verification, fault tolerance, protocol verification, clock synchronization, Manchester format, automatic theorem proving, Boyer-Moore logic, ISO protocol level 1, performance modeling.  
Address: 1717 West Sixth Street, Suite 290 Austin, Tx 78703-4776 U.S.A.  
Affiliation: Computational Logic, Inc.  
Note: c  
Pubnum: Computing  
Date: (1993) 3: 1-000  1993 BCS  
Abstract: We present a formal model of asynchronous communication between two digital hardware devices. The model takes the form of a function in the Boyer-Moore logic. The function transforms the signal stream generated by one processor into that consumed by an independently clocked processor, given the phases and rates of the two clocks and the communications delay. The model can be used quantitatively to derive concrete performance bounds on communications at ISO protocol level 1 (physical level). We use the model to show that an 18-bit/cell biphase mark protocol reliably sends messages of arbitrary length between two processors provided the ratio of the clock rates is within 5% of unity. 
Abstract-found: 1
Intro-found: 1
Reference: [Ae88] <author> Aggarwal, S. and Sabnani, K. (eds.): </author> <title> Protocol Specification, Testing, </title> <editor> and Verifi cation VIII. </editor> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1988. </year>
Reference-contexts: An important survey of the field was published as long ago as 1979 [Sun79] and the field has an annual conference (Protocol Testing, Specification, and Verification) with proceedings published by North-Holland <ref> [Ae88] </ref>. The International Standards Organization has defined seven levels of protocol. Level 1, the "physical level," deals with pin connections, voltage levels, and physical signal formats. Level 2, the "data link level," concerns itself with data formats, synchronization, error control, and flow control.
Reference: [Bar85] <author> Barringer, H.: </author> <title> A Survey of Verification Techniques for Parallel Programs. </title> <booktitle> Springer-Verlag Lecture Notes in Computer Science 191, </booktitle> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: The A Formal Model of Asynchronous Communication 31 reader interested in the general problems of verifying distributed and/or concurrent systems should see, in addition to [Mil80] and [Hoa85], the seminal work by Manna and Pnueli [MP84], Barringer's survey <ref> [Bar85] </ref>, and the Unity model by Chandy and Misra [CM88]. In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field.
Reference: [BHMY89] <author> Bevier, W.R., Hunt, W.A., Moore, J S. and Young, W.D.: </author> <title> Special issue on system verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4), </volume> <month> 409-530 </month> <year> (1989). </year>
Reference-contexts: The clear but unstated direction of the CLI work on fault-tolerance was to enable the eventual fabrication of a device implementing the Byzantine agreement algorithm|a device whose design had been mechanically verified from the journal article describing the algorithm all the way down to the netlist. (See <ref> [BHMY89] </ref> for a description of the similarly verified "CLI short stack" that goes from a verified compiler for a simple high-level language, through a verified assembler and linker, to a microprocessor verfied at the gate level.) However, a major stumbling block in this program was the fact that the four microprocessors
Reference: [BY91] <author> Bevier, W.R. and Young, W.D.: </author> <title> The proof of correctness of a fault-tolerant circuit design. </title> <booktitle> In Proceedings of the Second International Working Conference on Dependable Computing for Critical Applications, </booktitle> <pages> pp. 107-114. </pages> <publisher> IFIP, </publisher> <month> February </month> <year> 1991. </year>
Reference-contexts: Relation to Other Work This work began as part of a NASA-sponsored investigation at Computational Logic, Inc. (CLI) into the formalization of fault tolerance. W. Bevier and W. Young of CLI formalized with Nqthm the Oral Messages (or "Byzantine Agreement") algorithm of Pease, Shostak, and Lamport [PSL80]. In <ref> [BY91] </ref> they describe the formalization and correctness proof of that algorithm and carried it all the way down to the Nqthm specification of four microprocessors that use the algorithm to reach agreement in the presence of faults.
Reference: [BM79] <author> Boyer, R.S. and Moore, J S.: </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The Nqthm logic imposes restrictions on equations purporting to be "defi-nitions." These restrictions insure that one and only one mathematical function satisfies the equation. Because of this assurance, we can add such admissible definitions to the logic without rendering the logic inconsistent. The reader should see <ref> [BM79, BM88] </ref> for details. In this presentation we do not further concern ourselves with the admissibility of our definitions. We define the operations of "negation" and "exclusive-or" as follows.
Reference: [BM88] <author> Boyer, R.S. and Moore, J S.: </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Put less pedantically, we will exhibit a formal model of asynchronous communication and use it to prove that a commonly used protocol works. The proof was checked with the Boyer-Moore theorem prover, Nqthm <ref> [BM88] </ref>. The biphase mark protocol|variously known as "Bi--M," "FM" or "single density" and sometimes called a "format" rather than a "protocol"|is a convention for representing both a string of bits and clock edges in a square wave. <p> This article is a shortened version of [Moo92a], where we present the proof in full as well as develop a "reusable theory" that allows the application of our model to other protocols. 2. Logical Foundations We use the Nqthm "computational logic" described in <ref> [BM88] </ref>. Truth values, bits, and signals will all be represented by the objects t and f which are distinct constants. We call these two objects "Booleans." Because the logic's language is untyped, we define a predicate, boolp, which recognizes just them. <p> The Nqthm logic imposes restrictions on equations purporting to be "defi-nitions." These restrictions insure that one and only one mathematical function satisfies the equation. Because of this assurance, we can add such admissible definitions to the logic without rendering the logic inconsistent. The reader should see <ref> [BM79, BM88] </ref> for details. In this presentation we do not further concern ourselves with the admissibility of our definitions. We define the operations of "negation" and "exclusive-or" as follows.
Reference: [BH90] <author> Brock, B.C. and Hunt, </author> <title> W.A.: A formal introduction to a simple hdl. </title> <editor> In J. Staunstrup, editor, </editor> <booktitle> Formal Methods for VLSI Design, </booktitle> <pages> pp. 285-329. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: Consider send. It is the formal specification of the kernel of the send side of a microprocessor's communications module. Indeed, its definition was developed with that use in mind. See [Moo92b]. Using the Formal HDL described in <ref> [BH90] </ref>, it is possible to design a circuit that implements send. <p> Young [You91] then used Nqthm to prove the correctness of the interactive convergence clock synchronization algorithm, essentially following in the footsteps of Rushby and von Henke [RvH89]. Meanwhile, the present author used the hardware description language formalized in Nqthm by B. Brock and W. Hunt <ref> [BH90] </ref> of CLI to implement the processor specified by Bevier and Young and to prove that the described design meets their specification [Moo92b].
Reference: [Cam88] <author> Campbell, J.: </author> <title> C Programmer's Guide to Serial Communications. </title> <editor> Howard W. </editor> <publisher> Sams and Co., </publisher> <address> 4300 West 62 Street, Indianapolis, </address> <note> IN 46268, </note> <year> 1988. </year>
Reference-contexts: receiver counts off a fixed number of cycles, 3 The word "mark" in "biphase mark" comes from the "Automatic Recorder" of 19 th century telegraphy where the line idle state produced a mark on a rotating drum and the arrival of a pulse lifted the stylus to produce a space <ref> [Cam88] </ref>. The names MARK and SPACE were adopted for logical 1 and logical 0 respectively. However, except in the name "biphase mark," our use of the word "mark" is intended in its nontechnical sense, i.e., "a conspicuous object serving as a guide for travelers"[Mis87].
Reference: [CM88] <author> Chandy, K.M. and Misra, J.: </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: The A Formal Model of Asynchronous Communication 31 reader interested in the general problems of verifying distributed and/or concurrent systems should see, in addition to [Mil80] and [Hoa85], the seminal work by Manna and Pnueli [MP84], Barringer's survey [Bar85], and the Unity model by Chandy and Misra <ref> [CM88] </ref>. In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field.
Reference: [CES86] <author> Clarke, </author> <title> E.M., Emerson, E.A. and Sistla, A.P.: Automatic verification of finite state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2), </volume> <month> 244-263 </month> <year> (1986). </year>
Reference-contexts: But in the 80s the combination of finite-state machine models, propositional temporal logic, and fast mechanical decision procedures came to dominate mechanized protocol verification because of the speed and automation this combination offered. For a description how this approach is applied to the alternating bit protocol see <ref> [CES86] </ref> by E. Clarke, E. Emerson and A. Sistla. Clarke and O. Grumberg have written an excellent review of the use of finite state machines and temporal logic in automatic verification of concurrent systems [CG87].
Reference: [CG87] <author> Clarke, E.M. and Grumberg, O.: </author> <title> Research on automatic verification of finite-state concurrent systems. </title> <journal> Ann. Rev. Comput. Sci., </journal> <volume> 2, </volume> <month> 269-290 </month> <year> (1987). </year>
Reference-contexts: For a description how this approach is applied to the alternating bit protocol see [CES86] by E. Clarke, E. Emerson and A. Sistla. Clarke and O. Grumberg have written an excellent review of the use of finite state machines and temporal logic in automatic verification of concurrent systems <ref> [CG87] </ref>. However, both the finite state machine approach and the related Petri net approach [Pet81] suffer from the inability to discuss time quantitatively.
Reference: [DiV81] <author> DiVito, B.L.: </author> <title> A mechanical verification of the alternating bit protocol. </title> <type> Technical Report ICSCA-CMP-21, </type> <institution> Institute for Computing Science, The University of Texas at Austin, </institution> <year> 1981. </year>
Reference-contexts: In the late 70s mechanical protocol verification was based on the then-standard program verification technology: a procedural encoding of the protocol was annotated with inductive assertions, from which verification conditions were mechanically generated and then interactively proved. In <ref> [DiV81] </ref> this method is applied to the alternating bit protocol. See [DiV82] for examples of method applied to still-higher transport level protocols.
Reference: [DiV82] <author> DiVito, B.L.: </author> <title> Verification of communications protcols and abstract process mod els. </title> <type> PhD Thesis ICSCA-CMP-25, </type> <institution> Institute for Computing Science and Computer Applications, University of Texas at Austin, </institution> <year> 1982. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: In the late 70s mechanical protocol verification was based on the then-standard program verification technology: a procedural encoding of the protocol was annotated with inductive assertions, from which verification conditions were mechanically generated and then interactively proved. In [DiV81] this method is applied to the alternating bit protocol. See <ref> [DiV82] </ref> for examples of method applied to still-higher transport level protocols. But in the 80s the combination of finite-state machine models, propositional temporal logic, and fast mechanical decision procedures came to dominate mechanized protocol verification because of the speed and automation this combination offered.
Reference: [Gol90] <author> Goldschlag, </author> <title> D.M.: Mechanizing unity. In Programming Concepts and Methods. </title> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: The A Formal Model of Asynchronous Communication 31 reader interested in the general problems of verifying distributed and/or concurrent systems should see, in addition to [Mil80] and [Hoa85], the seminal work by Manna and Pnueli [MP84], Barringer's survey [Bar85], and the Unity model by Chandy and Misra [CM88]. In <ref> [Gol90] </ref>, D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field.
Reference: [Hoa85] <author> Hoare, </author> <title> C.A.R.: Communicating Sequential Processes. </title> <publisher> Prentice Hall International, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: To apply the model, one must characterize the signals produced and consumed by the two communicating processes. This input/output model of concurrent processes is a familiar one used in Mil-ner's CCS [Mil80] and Hoare's CSP <ref> [Hoa85] </ref>. Unlike that work, we consider only the simple case of one way communication. However, our focus is entirely on the physical problems introduced by asynchrony, namely how clock rates, delay, and phase shift affect the received signal. <p> The quantitative modeling of time makes our work very different in character and focus from the cited work. The A Formal Model of Asynchronous Communication 31 reader interested in the general problems of verifying distributed and/or concurrent systems should see, in addition to [Mil80] and <ref> [Hoa85] </ref>, the seminal work by Manna and Pnueli [MP84], Barringer's survey [Bar85], and the Unity model by Chandy and Misra [CM88]. In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification.
Reference: [Hun85] <author> Hunt, </author> <title> W.A.: Fm8501: A verified microprocessor. </title> <type> Phd thesis, </type> <institution> University of Texas at Austin, </institution> <month> December </month> <year> 1985. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field. In common with our work, many formal models of microprocessors, e.g., <ref> [Hun85] </ref>, [Pyg85], and [Joy90], quantitatively measure time in cycles. A particularly intriguing title, given the title of this work, is J. Joyce's "Formal Specification and Verification of Asynchronous Processes in Higher-Order Logic"[Joy88]. The report deals with the same problem confronted in [Hun85], namely how to formalize the interaction between a synchronous <p> with our work, many formal models of microprocessors, e.g., <ref> [Hun85] </ref>, [Pyg85], and [Joy90], quantitatively measure time in cycles. A particularly intriguing title, given the title of this work, is J. Joyce's "Formal Specification and Verification of Asynchronous Processes in Higher-Order Logic"[Joy88]. The report deals with the same problem confronted in [Hun85], namely how to formalize the interaction between a synchronous microprocessor and an asynchronous memory via a four-phase handshaking protocol. The report offers an attractive alternative to the formalization presented in [Hun85]. But it does not address general asynchronous communication in the sense that we do. <p> The report deals with the same problem confronted in <ref> [Hun85] </ref>, namely how to formalize the interaction between a synchronous microprocessor and an asynchronous memory via a four-phase handshaking protocol. The report offers an attractive alternative to the formalization presented in [Hun85]. But it does not address general asynchronous communication in the sense that we do. Because we verify a protocol in this paper, it is necessary to comment upon the relation of our work to the very old and very active research area of protocol verification.
Reference: [Int91] <author> Intel Corporation: Microcommunications. </author> <title> Intel Literature Sales, P.O. Box 7641, Mt. Prospect, </title> <address> IL 60056-7641, </address> <year> 1991. </year>
Reference-contexts: For example, it is an industry standard for single density magnetic floppy disk recording. It is one of several protocols implemented by such commercially available microcontrollers as the Intel 82530 Serial Communications Controller <ref> [Int91] </ref>. A version of biphase mark, called "Manchester," is used in the Ethernet [Rod88] and is implemented in the Intel 82C501AD Ethernet Serial Interface [Int91]. Biphase mark is also used in some optical communications and satellite telemetry applications [Skl88]. There is no doubt that it works. <p> It is one of several protocols implemented by such commercially available microcontrollers as the Intel 82530 Serial Communications Controller <ref> [Int91] </ref>. A version of biphase mark, called "Manchester," is used in the Ethernet [Rod88] and is implemented in the Intel 82C501AD Ethernet Serial Interface [Int91]. Biphase mark is also used in some optical communications and satellite telemetry applications [Skl88]. There is no doubt that it works. But, as far as we have been able to determine, a rigorous analysis of its tolerance of asynchrony has not been done. <p> The analogous inequalities are 3+7+3 12 &lt; 0+4+1+4, which are invalid. That is, the proof breaks down for the 16-cycle symmetric biphase mark protocol. This is not to say that the 16-cycle version does not work! Such a configuration is used in the Intel 82530 Serial Communications Controller <ref> [Int91] </ref> (where it presumably works) and we have found no example of reasonably close clock rates for which it fails in our model. But we cannot prove that it works using the attack shown here. Our attack bounds a sum by summing the bounds, which gives sound but crude results.
Reference: [JL91] <author> Jain, P. and Lam, S.S.: </author> <title> Specification real-time protocols for broadcast networks. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(4), </volume> <month> 404-422 </month> <year> (1991). </year>
Reference-contexts: This is in stark contrast to our work, where explicit, quantitatively measured time forms the foundation of the model. Finally, while not at level 1 and not supported by mechanically checked proofs, the closest work on protocol verification is perhaps that by P. Jain and S. Lam <ref> [JL91] </ref> where time is modeled quantitatively and discretely and signal propagation down a bus is also modeled (assuming constant propagation speed). They specify a modified Expressnet protocol which they prove to be collison-free and they derive bounds for its access delay. 11.
Reference: [Joy88] <author> Joyce, J.J.: </author> <title> Formal specification and verification of asynchronous processes in higher-order logic. </title> <type> Technical Report No. 136, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> June </month> <year> 1988. </year>
Reference: [Joy90] <author> Joyce, J.J.: </author> <title> Multi-level verification of microprocessor-based systems. </title> <type> Technical Report No. 195, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field. In common with our work, many formal models of microprocessors, e.g., [Hun85], [Pyg85], and <ref> [Joy90] </ref>, quantitatively measure time in cycles. A particularly intriguing title, given the title of this work, is J. Joyce's "Formal Specification and Verification of Asynchronous Processes in Higher-Order Logic"[Joy88].
Reference: [MP84] <author> Manna, Z. and Pnueli, A.: </author> <title> Adequate proof principles for invariance and liveness properties of concurrent programs. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 4, </volume> <month> 257-289 </month> <year> (1984). </year>
Reference-contexts: The A Formal Model of Asynchronous Communication 31 reader interested in the general problems of verifying distributed and/or concurrent systems should see, in addition to [Mil80] and [Hoa85], the seminal work by Manna and Pnueli <ref> [MP84] </ref>, Barringer's survey [Bar85], and the Unity model by Chandy and Misra [CM88]. In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field.
Reference: [Mil80] <author> Milner, R.: </author> <title> A Calculus of Communicating Systems. </title> <address> Springler-Verlag, Berlin, </address> <year> 1980. </year>
Reference-contexts: To apply the model, one must characterize the signals produced and consumed by the two communicating processes. This input/output model of concurrent processes is a familiar one used in Mil-ner's CCS <ref> [Mil80] </ref> and Hoare's CSP [Hoa85]. Unlike that work, we consider only the simple case of one way communication. However, our focus is entirely on the physical problems introduced by asynchrony, namely how clock rates, delay, and phase shift affect the received signal. <p> The quantitative modeling of time makes our work very different in character and focus from the cited work. The A Formal Model of Asynchronous Communication 31 reader interested in the general problems of verifying distributed and/or concurrent systems should see, in addition to <ref> [Mil80] </ref> and [Hoa85], the seminal work by Manna and Pnueli [MP84], Barringer's survey [Bar85], and the Unity model by Chandy and Misra [CM88]. In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification.
Reference: [Mis87] <editor> Mish, F.C., editor.: </editor> <booktitle> Webster's Ninth New Collegiate Dictionary. Merriam Webster, </booktitle> <publisher> Inc, </publisher> <year> 1987. </year>
Reference: [Moo92a] <author> Moore, J S.: </author> <title> A formal model of asynchronous communication and its use in mechanically verifying a biphase mark protocol. </title> <type> Technical Report NASA CR-4433, </type> <institution> NASA, </institution> <year> 1992. </year>
Reference-contexts: We have proved that the conventional choice of cell size also works, provided the ratio of the clock rates is within 3% of unity, and we briefly indicate how the proof differs from the proof of the 18-cycle version. This article is a shortened version of <ref> [Moo92a] </ref>, where we present the proof in full as well as develop a "reusable theory" that allows the application of our model to other protocols. 2. Logical Foundations We use the Nqthm "computational logic" described in [BM88]. <p> They are a first step toward what we call a "reusable formal theory" or "rule book" for async. They are only the first step because we stopped when we had enough rules to prove biphase mark correct. See <ref> [Moo92a] </ref> for the presentation of the reusable theory. 7.2. <p> Complete details are given in <ref> [Moo92a] </ref>. We transform the left-hand side of the conclusion above into a slightly dif 22 J Strother Moore ferent form and then appeal to a lemma (discussed below). <p> This is particularly important because we will need to use our inductive hypothesis to process cells of parity opposite that of the first cell. 8 The proof of BPM18-Lemma is by induction on the length of msg. See <ref> [Moo92a] </ref> for the details. We separate two base cases, one for the empty msg and one for msg s of length 1.
Reference: [Moo92b] <author> Moore, J S.: </author> <title> Mechanically verified hardware implementing an 8-bit parallel io byzantine agreement processor. </title> <type> Technical Report NASA CR-189588, </type> <institution> NASA, </institution> <year> 1992. </year> <title> 34 J Strother Moore </title>
Reference-contexts: Consider send. It is the formal specification of the kernel of the send side of a microprocessor's communications module. Indeed, its definition was developed with that use in mind. See <ref> [Moo92b] </ref>. Using the Formal HDL described in [BH90], it is possible to design a circuit that implements send. <p> Proving such a correctness result would be straightforward (given the reusable theory developed for the Formal HDL by Brock and Hunt) for some hardware designs. See <ref> [Moo92b] </ref> for an example of the use of the Formal HDL in the specification and design of a simple verified microprocessor. <p> Meanwhile, the present author used the hardware description language formalized in Nqthm by B. Brock and W. Hunt [BH90] of CLI to implement the processor specified by Bevier and Young and to prove that the described design meets their specification <ref> [Moo92b] </ref>.
Reference: [PSL80] <author> Pease, M., Shostak, R. and Lamport, L.: </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2), </volume> <month> 228-234 </month> <year> (1980). </year>
Reference-contexts: Relation to Other Work This work began as part of a NASA-sponsored investigation at Computational Logic, Inc. (CLI) into the formalization of fault tolerance. W. Bevier and W. Young of CLI formalized with Nqthm the Oral Messages (or "Byzantine Agreement") algorithm of Pease, Shostak, and Lamport <ref> [PSL80] </ref>. In [BY91] they describe the formalization and correctness proof of that algorithm and carried it all the way down to the Nqthm specification of four microprocessors that use the algorithm to reach agreement in the presence of faults.
Reference: [Pet81] <author> Peterson, J.L.: </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: Clarke, E. Emerson and A. Sistla. Clarke and O. Grumberg have written an excellent review of the use of finite state machines and temporal logic in automatic verification of concurrent systems [CG87]. However, both the finite state machine approach and the related Petri net approach <ref> [Pet81] </ref> suffer from the inability to discuss time quantitatively.
Reference: [Pyg85] <author> Pygott, C.H.: </author> <title> Formal proof of correspondence between the specification of a hard ware module and its gate level implementation. </title> <type> Report 85012, </type> <institution> Royal Signals and Radar Establishment, Malvern, </institution> <address> Worcestershire (United Kingdom), </address> <month> November </month> <year> 1985. </year>
Reference-contexts: In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See [Yoe90] for a tutorial introduction to and overview of the field. In common with our work, many formal models of microprocessors, e.g., [Hun85], <ref> [Pyg85] </ref>, and [Joy90], quantitatively measure time in cycles. A particularly intriguing title, given the title of this work, is J. Joyce's "Formal Specification and Verification of Asynchronous Processes in Higher-Order Logic"[Joy88].
Reference: [Rod88] <author> Roden, </author> <title> M.S.: Digital Communication Systems Design. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: For example, it is an industry standard for single density magnetic floppy disk recording. It is one of several protocols implemented by such commercially available microcontrollers as the Intel 82530 Serial Communications Controller [Int91]. A version of biphase mark, called "Manchester," is used in the Ethernet <ref> [Rod88] </ref> and is implemented in the Intel 82C501AD Ethernet Serial Interface [Int91]. Biphase mark is also used in some optical communications and satellite telemetry applications [Skl88]. There is no doubt that it works. <p> Our model is based on three assumptions. * The distortion in the signal due to the presence of an edge is limited to the time-span of the cycle during which the edge was written. For example, we ignore intersymbol interference <ref> [Rod88] </ref>. * The clocks of both processors are linear functions of real time, e.g., the ticks of a given clock are equally spaced events in real time. We ignore clock jitter. * Reading on an edge produces nondeterministically defined signal values, not indeterminate values.
Reference: [RvH89] <author> Rushby, J. and von Henke, F.: </author> <title> Formal verification of the interactive convergence clock synchronization algorithm using ehdm. </title> <type> Technical Report SRI CSL 89-3R, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA 94025, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: According to <ref> [RvH89] </ref> typical clocks are incorrect by less than 15fi10 -6 seconds per second and the ratio of the rates of two such clocks are well within our bounds. <p> Suppose the reader is nominally 20MHz but ticks faster so that in twenty million ticks it counts off .999996 seconds. That is, r is 499,998 and the clock is gaining roughly 4fi10 -6 seconds per second, which is consistent with the clocks reported in <ref> [RvH89] </ref>. Then if the first signal in the output of pass 1 reaches the reader 11fi10 -13 seconds before the reader's clock ticks, the output is as described in pass 2 of Figure 4. <p> Young [You91] then used Nqthm to prove the correctness of the interactive convergence clock synchronization algorithm, essentially following in the footsteps of Rushby and von Henke <ref> [RvH89] </ref>. Meanwhile, the present author used the hardware description language formalized in Nqthm by B. Brock and W. Hunt [BH90] of CLI to implement the processor specified by Bevier and Young and to prove that the described design meets their specification [Moo92b].
Reference: [Skl88] <author> Sklar, B.: </author> <title> Digital Communications Fundamentals and Applications. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: A version of biphase mark, called "Manchester," is used in the Ethernet [Rod88] and is implemented in the Intel 82C501AD Ethernet Serial Interface [Int91]. Biphase mark is also used in some optical communications and satellite telemetry applications <ref> [Skl88] </ref>. There is no doubt that it works. But, as far as we have been able to determine, a rigorous analysis of its tolerance of asynchrony has not been done.
Reference: [Sun79] <author> Sunshine, C.: </author> <title> Formal techniques for protocol specification and verification. </title> <address> Com puter, g12(9), </address> <month> 20-27 </month> <year> (1979). </year>
Reference-contexts: Because we verify a protocol in this paper, it is necessary to comment upon the relation of our work to the very old and very active research area of protocol verification. An important survey of the field was published as long ago as 1979 <ref> [Sun79] </ref> and the field has an annual conference (Protocol Testing, Specification, and Verification) with proceedings published by North-Holland [Ae88]. The International Standards Organization has defined seven levels of protocol. Level 1, the "physical level," deals with pin connections, voltage levels, and physical signal formats.
Reference: [Yoe90] <author> Yoeli, M.: </author> <title> Formal Verification of Hardware Design. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1990. </year>
Reference-contexts: In [Gol90], D. Goldschlag describes an Nqthm-based mechanized proof system Unity. Our work finds its closest relatives in the very active field of hardware verification. See <ref> [Yoe90] </ref> for a tutorial introduction to and overview of the field. In common with our work, many formal models of microprocessors, e.g., [Hun85], [Pyg85], and [Joy90], quantitatively measure time in cycles. A particularly intriguing title, given the title of this work, is J.
Reference: [You91] <author> Young, W.D.: </author> <title> Verifying the interactive convergence clock synchronization algo rithm using the boyer-moore theorem prover. Internal Note 199, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: In [BY91] they describe the formalization and correctness proof of that algorithm and carried it all the way down to the Nqthm specification of four microprocessors that use the algorithm to reach agreement in the presence of faults. Young <ref> [You91] </ref> then used Nqthm to prove the correctness of the interactive convergence clock synchronization algorithm, essentially following in the footsteps of Rushby and von Henke [RvH89]. Meanwhile, the present author used the hardware description language formalized in Nqthm by B. Brock and W.
References-found: 34

