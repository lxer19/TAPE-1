URL: http://www.cs.uoregon.edu/~sabry/papers/reasoning-tr.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Title: Reasoning about Programs in Continuation-Passing Style  
Author: Amr Sabry Matthias Felleisen 
Note: TR 92-180  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  (Rice  
Pubnum: Technical Report  
Abstract: A preliminary version of this paper appeared in Lisp and Functional Programming June 22-24, 1992, San Francisco, California. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Appel, A. and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982, </year> <pages> 293-302. </pages>
Reference-contexts: 1 Compiling with CPS Many modern compilers for higher-order functional languages <ref> [1, 16, 24, 25] </ref> utilize some variant of the Fischer-Reynolds continuation-passing style (CPS) transformation [10, 23]. Once a program is in continuation-passing style, these compilers usually perform code optimizations via local transformations. Typical examples of such optimizations are loop unrolling, procedure inlining, and partial evaluation. <p> On the practical side, code generation phases in compilers favor smaller, i.e., more manageable, programs. Hence, 1 In Reynolds's transformation the continuation is the second argument to a procedure. Reasoning about Programs in Continuation-Passing Style 7 "practical" CPS transformations <ref> [1, 5, 16, 24, 25] </ref> use special algorithms to minimize the size of their outputs.
Reference: 2. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The first discusses the typed and untyped versions of the calculi and their soundness with respect to observational equivalence. The second is a correspondence between the extension of the v -calculus and the CPS type structure. 2 fl: Calculi and Semantics The language of the pure lambda calculus, fl <ref> [2] </ref>, consists of variables, -abstractions, and applications. <p> Sabry, M. Felleisen Lemma 3.6 Let P and Q be in fi-normal form. If fi ` F [[M ]] !! P and fi ` F [[M ]] !! Q, then P Q. Proof. The proof is a consequence of the Church-Rosser theorem for fi <ref> [2] </ref>. It remains to establish that all fi-reduction paths terminate. Lemma 3.7 Let M 2 fl. <p> Specifically, our universe of discourse consists only of the terms that contribute to the proofs of equations of the form: fi ` C k [[M ]] = C k [[N ]]: Since fi is CR <ref> [2] </ref>, it is sufficient to consider equations of the form: fi ` C k [[M ]] !! P: Hence, the interesting set of CPS terms is: S = fP j 9M 2 fl: fi ` C k [[M ]] !! P g: The definition of the function C k provides some
Reference: 3. <author> Danvy, O. </author> <title> Back to direct style. </title> <booktitle> In 4th Proc. European Symposium on Programming. Springer Lecture Notes in Computer Science, </booktitle> <volume> 582. </volume> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1992, </year> <pages> 130-150. </pages>
Reference-contexts: The new transformation also produces the smallest possible output of all known CPS transformations, without reducing any of the original (source) redexes. 2. Second, we develop an un-CPS transformation that maps canonical CPS programs and their derivations back to the original language. As Danvy and Lawall <ref> [3, 6] </ref> convincingly argue, this translation from CPS to direct terms is useful in its own right. 3. Finally, by studying the connection between the CPS and un-CPS transformations, we systematically derive A. The extended -value calculus is equivalent to an untyped variant of Moggi's [21] computational -calculus. <p> Values consist of variables, drawn from the set Vars, and -abstractions. Reasoning about Programs in Continuation-Passing Style 3 We adopt Barendregt's <ref> [2: ch 2, 3] </ref> notation and terminology for this syntax. Thus, in the abstraction (x:M ), the variable x is bound in M . Variables that are not bound by a -abstraction are free; the set of free variables in a term M is F V (M ). <p> The first fact is a property of the function C k that reduces administrative redexes on the fly. The second one is due to the closure of the set of CPS terms under fi-reductions. We discuss each point in detail below. 5 5 Danvy and Lawall <ref> [3, 6] </ref> define a direct style transformation mapping CPS programs into source terms. The transformation is the inverse of the Danvy-Filinski CPS transformation [5]; it is only applicable to images of fl terms.
Reference: 4. <author> Danvy, O. </author> <title> Three steps for the CPS transformation. </title> <type> Tech. Rep. </type> <institution> CIS-92-2. Kansas State University, </institution> <year> 1992. </year>
Reference-contexts: According to folklore in the functional compiler-building community <ref> [4] </ref>, the first aspect of a CPS transformation is to give the value of every application a name.
Reference: 5. <author> Danvy, O. and A. Filinski. </author> <title> Representing control: A study of the CPS transformation. </title> <type> Tech. </type> <institution> Rpt. CIS-91-2. Kansas State University, </institution> <year> 1991. </year> <note> 34 A. Sabry, M. Felleisen </note>
Reference-contexts: On the practical side, code generation phases in compilers favor smaller, i.e., more manageable, programs. Hence, 1 In Reynolds's transformation the continuation is the second argument to a procedure. Reasoning about Programs in Continuation-Passing Style 7 "practical" CPS transformations <ref> [1, 5, 16, 24, 25] </ref> use special algorithms to minimize the size of their outputs. <p> Therefore, the relation F 2 is a function. Moreover, by Lemma 3.7, all reduction paths starting at F [[M ]] for M 2 fl terminate. Hence, F 2 is a total function. 2 See also the discussion of this idea by Danvy and Filinski <ref> [5] </ref>. 8 A. Sabry, M. Felleisen Lemma 3.6 Let P and Q be in fi-normal form. If fi ` F [[M ]] !! P and fi ` F [[M ]] !! Q, then P Q. Proof. The proof is a consequence of the Church-Rosser theorem for fi [2]. <p> The output of F 2 is extremely compact. For example, applying F 2 to (((x:y:x) a) b) yields the term: M = k:((x:((y:kx) b)) a) For the same example, both Steele's Rabbit transformation [25] and the Danvy/Filinski transformation <ref> [5] </ref> yield the term: 3 N = k:((k 1 x:(k 1 k 2 y:k 2 x)) (m:mkb) a): The evaluation of M requires two fi-reductions: M ! k:((y:ka) b) ! k:ka; while the evaluation of N requires three (binary) fi-reductions: N ! k:((m:mkb) (k 2 y:k 2 a)) ! k:ka: Since <p> We discuss each point in detail below. 5 5 Danvy and Lawall [3, 6] define a direct style transformation mapping CPS programs into source terms. The transformation is the inverse of the Danvy-Filinski CPS transformation <ref> [5] </ref>; it is only applicable to images of fl terms. For example, let M = ((d:5) ((x:xx) (x:xx))): Reasoning about Programs in Continuation-Passing Style 19 The effect of administrative reductions: The function C k incorporates the reduction of all administrative redexes from the output of the Fischer CPS.
Reference: 6. <author> Danvy, O. and J. L. Lawall. </author> <title> Back to direct style II: First-class continuations. </title> <booktitle> In Proc. 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1992, </year> <note> this volume. </note>
Reference-contexts: The new transformation also produces the smallest possible output of all known CPS transformations, without reducing any of the original (source) redexes. 2. Second, we develop an un-CPS transformation that maps canonical CPS programs and their derivations back to the original language. As Danvy and Lawall <ref> [3, 6] </ref> convincingly argue, this translation from CPS to direct terms is useful in its own right. 3. Finally, by studying the connection between the CPS and un-CPS transformations, we systematically derive A. The extended -value calculus is equivalent to an untyped variant of Moggi's [21] computational -calculus. <p> The first fact is a property of the function C k that reduces administrative redexes on the fly. The second one is due to the closure of the set of CPS terms under fi-reductions. We discuss each point in detail below. 5 5 Danvy and Lawall <ref> [3, 6] </ref> define a direct style transformation mapping CPS programs into source terms. The transformation is the inverse of the Danvy-Filinski CPS transformation [5]; it is only applicable to images of fl terms.
Reference: 7. <author> Felleisen, M. and D.P. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. In Formal Description of Programming Concepts III , edited by M. Wirsing. </title> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <address> Amsterdam, </address> <year> 1986, </year> <pages> 193-217. </pages>
Reference-contexts: Typically, eval is defined via an abstract machine that manipulates abstract counterparts to machine stacks, stores, registers, etc. Examples are the SECD machine [17] and the CEK machine <ref> [7] </ref>. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction theorem [7, 22]. The Standard Reduction theorem defines a partial function, 4 A. Sabry, M. Felleisen 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl. <p> Typically, eval is defined via an abstract machine that manipulates abstract counterparts to machine stacks, stores, registers, etc. Examples are the SECD machine [17] and the CEK machine [7]. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction theorem <ref> [7, 22] </ref>. The Standard Reduction theorem defines a partial function, 4 A. Sabry, M. Felleisen 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl. <p> The special contexts, E, are evaluation contexts and have the following definition for the call-by-value and call-by-name variants of fl respectively <ref> [7] </ref>: E v ::= [ ] j (V E v ) j (E v M ) Conceptually, the hole of an evaluation context, [ ], points to the current instruction, which must be a fi v or fi redex. <p> The decomposition of M into E [(V N )] where (V N ) is a redex means that the current instruction is (V N ) and that the rest of the computation (the continuation <ref> [7] </ref>!) is E. Since, a call-by-name language never evaluates arguments, evaluation contexts do not include contexts of the shape (V E n ). <p> For the source terms, this means that the body of an abstraction in application position absorbs the syntactic representation of the continuation, which is the evaluation context of the redex <ref> [7] </ref>. Thus, a program of the shape E [((x:M ) V )] where E represents K, must be translated as if it had been written as ((x:E [M ]) V ). Put differently, our CPS transformation "symbolically" evaluates redexes by lifting them to the root of the program.
Reference: 8. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <institution> Theor. Comput. Sci., </institution> <year> 1992, </year> <note> to appear. </note>
Reference-contexts: However, the correspondence theorem fails since operators like call/cc manipulate their continuation in non-standard ways. To re-establish the correspondence theorem for such languages, we need to find an extension for the -control calculus <ref> [8, 9] </ref> that corresponds to fi on CPS terms.
Reference: 9. <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, </note> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: However, the correspondence theorem fails since operators like call/cc manipulate their continuation in non-standard ways. To re-establish the correspondence theorem for such languages, we need to find an extension for the -control calculus <ref> [8, 9] </ref> that corresponds to fi on CPS terms.
Reference: 10. <author> Fischer, M.J. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proc. ACM Conference on Proving Assertions About Programs, SIGPLAN Notices 7(1), </booktitle> <year> 1972, </year> <pages> 104-109. </pages>
Reference-contexts: 1 Compiling with CPS Many modern compilers for higher-order functional languages [1, 16, 24, 25] utilize some variant of the Fischer-Reynolds continuation-passing style (CPS) transformation <ref> [10, 23] </ref>. Once a program is in continuation-passing style, these compilers usually perform code optimizations via local transformations. Typical examples of such optimizations are loop unrolling, procedure inlining, and partial evaluation. In the terminology of the -calculus, optimizations generally correspond to (sequences of) fi- and -reductions. <p> For a few years, the transformation remained part of the folklore of computer science until Fischer and Reynolds codified it in 1972. Fischer <ref> [10] </ref> studied two implementation strategies for fl: a heap-based retention strategy, in which all variable bindings are retained until no longer needed, and a stack-based deletion strategy, in which variable bindings are destroyed when control leaves the procedure (or block) in which they were created.
Reference: 11. <author> Friedman, D.P., M. Wand, and C.T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference: 12. <author> Friedman, H. </author> <title> Equality between functionals. In Logic Colloquium'73, </title> <editor> Rohit Parikh (Ed.), </editor> <booktitle> Lecture Notes in Mathematics 453, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1973, </year> <pages> 22-37. </pages>
Reference-contexts: K 1 [[(x:P )]] = ((x:C 1 [[P ]]) [ ]). The function is homomorphic is all cases except cases 4 and 8. Both are impossible if the input is of the form C k [[M ]] for some M 2 fl. 9 Typed CPS Models Friedman <ref> [12] </ref> investigates the connection between the typed fi-calculus and the functionals of finite type. Two convertible -terms define the same functional of finite type, and two non-convertible -terms define different functionals. Technically, fi is sound and complete with respect to the full type structure. <p> Also, P B j= M = N means that for all environments , P [[M ]] = P [[N ]]. Based on this definition, we can formulate the completeness theorem. Theorem 9.1 (Friedman <ref> [12] </ref>) Let M; N 2 fl. Then, fi ` M = N iff P B j= M = N . Since F [[M ]] 2 fl, the theorem implies the following corollary. Corollary 9.2 Let M; N 2 fl.
Reference: 13. <author> Gateley, J. </author> <title> and B.F. Duba. Call-by-value combinatory logic and the lambda-value calculus. </title> <booktitle> In Proc. 1991 Workshop on Mathematical Foundations of Programming Semantics. Lecture Notes in Computer Science 517, to appear. </booktitle>
Reference-contexts: extends the call-by-value -calculus such that: v A ` M = N iff fi ` cps (M ) = cps (N ): Such a correspondence theorem would be similar to the correspondence theorems for the -calculus and combinatory logic [2: ch 7], and the v -calculus and by-value combinatory logic <ref> [13] </ref>. In analogy to model theory, we call the left-to-right direction soundness and the right-to-left direction completeness since the CPS transformation is often taken as the definition of a call-by-value semantics. To derive A, we proceed in three steps: 1.
Reference: 14. <author> Harper, R. and M. Lillibridge. </author> <title> Polymorphic type assignment and cps conversion. </title> <type> Tech. </type> <institution> Rpt. CMU-CS-92-122. Carnegie Mellon University. </institution> <year> 1992. </year> <note> Preliminary version in: Proc. Workshop on Continuations: CW92 . Technical Report CS-92-1426. </note> <institution> Stanford University, </institution> <year> 1992, </year> <pages> 13-22. </pages>
Reference-contexts: Technically, fi is sound and complete with respect to the full type structure. The Correspondence Theorem suggests the existence of a similar completeness theorem for the c -calculus and the CPS type structure <ref> [20, 14] </ref>. We prove this theorem after briefly reviewing the full type structure and the CPS type structure as denotational models for the call-by-value -calculus.
Reference: 15. <author> Hieb R., R. K. Dybvig, and C. Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> 66-77. </pages>
Reference-contexts: If so, optimizations of CPS programs could be understood and reported in terms of the original program as opposed to its rather complicated CPS version. In particular, compilers that do not use the CPS transformation, e.g., Chez Scheme <ref> [15] </ref> or Zinc [18], could benefit by implementing transformations of source programs that correspond to transformations of CPS programs.
Reference: 16. <author> Kranz, D., et al. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proc. SIGPLAN 1986 Symposium on Compiler Construction. SIGPLAN Notices 21(7), </booktitle> <year> 1986, </year> <pages> 219-233. </pages>
Reference-contexts: 1 Compiling with CPS Many modern compilers for higher-order functional languages <ref> [1, 16, 24, 25] </ref> utilize some variant of the Fischer-Reynolds continuation-passing style (CPS) transformation [10, 23]. Once a program is in continuation-passing style, these compilers usually perform code optimizations via local transformations. Typical examples of such optimizations are loop unrolling, procedure inlining, and partial evaluation. <p> On the practical side, code generation phases in compilers favor smaller, i.e., more manageable, programs. Hence, 1 In Reynolds's transformation the continuation is the second argument to a procedure. Reasoning about Programs in Continuation-Passing Style 7 "practical" CPS transformations <ref> [1, 5, 16, 24, 25] </ref> use special algorithms to minimize the size of their outputs.
Reference: 17. <author> Landin, P.J. </author> <title> The mechanical evaluation of expressions. </title> <journal> Comput. J. </journal> <volume> 6(4), </volume> <year> 1964, </year> <pages> 308-320. </pages>
Reference-contexts: A program is a term with no free variables and, in practical languages, an answer is a member of the syntactic category of values. Typically, eval is defined via an abstract machine that manipulates abstract counterparts to machine stacks, stores, registers, etc. Examples are the SECD machine <ref> [17] </ref> and the CEK machine [7]. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction theorem [7, 22]. The Standard Reduction theorem defines a partial function, 4 A. Sabry, M.
Reference: 18. <author> Leroy, X. </author> <title> The Zinc experiment. </title> <type> Technical Report 117. </type> <institution> INRIA, </institution> <year> 1990. </year>
Reference-contexts: If so, optimizations of CPS programs could be understood and reported in terms of the original program as opposed to its rather complicated CPS version. In particular, compilers that do not use the CPS transformation, e.g., Chez Scheme [15] or Zinc <ref> [18] </ref>, could benefit by implementing transformations of source programs that correspond to transformations of CPS programs.
Reference: 19. <author> Meyer, A.R. and J.R. Riecke. </author> <title> Continuations may be unreasonable. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <year> 1988, </year> <pages> 63-71. </pages>
Reference-contexts: Since the context D includes a term (k:m:(m x:x)) that ignores its continuation, there is no context C 2 fl such that C k [[C [M ]]] = D [C k [[M ]]]. This result prompted Meyer and Riecke <ref> [19] </ref> to deduce that "continuations may be unreasonable". However, a restriction of D to range over contexts in the language cps (fl) results in a notion of observational equivalence that coincides with the call-by-value observational equivalence.
Reference: 20. <author> Meyer, A.R. and M. Wand. </author> <title> Continuation semantics in typed lambda-calculi. </title> <booktitle> Proc. Workshop Logics of Programs, Lecture Notes in Computer Science 193, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985, </year> <pages> 219-224. </pages>
Reference-contexts: Technically, fi is sound and complete with respect to the full type structure. The Correspondence Theorem suggests the existence of a similar completeness theorem for the c -calculus and the CPS type structure <ref> [20, 14] </ref>. We prove this theorem after briefly reviewing the full type structure and the CPS type structure as denotational models for the call-by-value -calculus. <p> Corollary 9.2 Let M; N 2 fl. Then c ` M = N iff fi ` F [[M ]] = F [[N ]] iff P B j= F [[M ]] = F [[N ]]. CPS Type Structure Meyer and Wand <ref> [20] </ref> establish that the type of a fl term may be related in a straightforward manner to the type of its CPS transform. The set of types becomes: 6 s ::= o j (s ! a) ! (s ! a) where a denotes a distinguished type of answers.
Reference: 21. <author> Moggi, E. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> 14-23. </pages> <note> Also appeared as: </note> <institution> LFCS Report ECS-LFCS-88-66, University of Edinburgh, </institution> <year> 1988. </year>
Reference-contexts: As Danvy and Lawall [3, 6] convincingly argue, this translation from CPS to direct terms is useful in its own right. 3. Finally, by studying the connection between the CPS and un-CPS transformations, we systematically derive A. The extended -value calculus is equivalent to an untyped variant of Moggi's <ref> [21] </ref> computational -calculus. The next section introduces the basic terminology and notation of the -calculus and its semantics. The third section is a short history of CPS transformations. In Section 4, we formalize the problem and outline our approach to the solution. <p> Rather the result is valid for any CPS transformation cps that satisfies the following condition for M 2 fl: fi ` F [[M ]] = cps (M ): End Note 7.4 The computational -calculus The calculus v A is equivalent to an untyped variant of Moggi's computational -calculus c <ref> [21] </ref>. <p> Therefore, the natural question is whether our extension is sound with respect to the call-by-value observational equivalence relation. Moggi <ref> [21] </ref> proves the result for a typed setting. In a dynamically typed language, the soundness of the c -calculus with respect to the call-by-value observational equivalence relation depends on the particular language extensions.
Reference: 22. <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Comput. Sci. </journal> <volume> 1, </volume> <year> 1975, </year> <month> 125-159. </month> <title> Reasoning about Programs in Continuation-Passing Style 35 </title>
Reference-contexts: Technically speaking, we are addressing the following question: which calculus can prove M = N for by-value expressions M and N , if cps (M ) = cps (N ) is provable in the (by-value or by-name) -calculus? As Plotkin <ref> [22] </ref> showed in 1974, the v -calculus does not suffice. Thus we refine this question as follows: fl Both authors were supported in part by NSF grant CCR 89-17022 and by Texas ATP grant 91-003604014. 1 2 A. Sabry, M. <p> Typically, eval is defined via an abstract machine that manipulates abstract counterparts to machine stacks, stores, registers, etc. Examples are the SECD machine [17] and the CEK machine [7]. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction theorem <ref> [7, 22] </ref>. The Standard Reduction theorem defines a partial function, 4 A. Sabry, M. Felleisen 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl. <p> He developed a constructive (but informal) method to transform an interpreter such that it becomes indifferent to whether the underlying parameter passing technique is call-by-value or call-by-name. His transformation is essentially the same transformation as Fischer's F . 1 Plotkin <ref> [22] </ref> later proved Reynolds' ideas correct. Theorem 3.2 (Plotkin [22]) Let M 2 fl. <p> He developed a constructive (but informal) method to transform an interpreter such that it becomes indifferent to whether the underlying parameter passing technique is call-by-value or call-by-name. His transformation is essentially the same transformation as Fischer's F . 1 Plotkin <ref> [22] </ref> later proved Reynolds' ideas correct. Theorem 3.2 (Plotkin [22]) Let M 2 fl. Simulation: [[eval v (M )]] = eval n (F [[M ]] (x:x)) Indifference: eval n (F [[M ]] (x:x)) = eval v (F [[M ]] (x:x)) The Simulation theorem shows that the evaluation of the CPS program produces correct outputs. <p> For example, F [[((x:x) (y y))]] = k:((k:k k:x:((k:kx) k)) (n:(m k) n)))): Although the original term contains one -abstraction and no fi v -redexes, its CPS counterpart contains a large number of both. Plotkin <ref> [22] </ref> referred to the new redexes as administrative redexes because an evaluator must always reduce them before re-establishing fi v -redexes that were present in the source term. From both a theoretical and a practical perspective, the presence of the administrative redexes is undesirable. <p> From both a theoretical and a practical perspective, the presence of the administrative redexes is undesirable. On the theoretical side, they complicate reasoning about CPS programs. For example, Plotkin <ref> [22] </ref> finds it necessary to define an improved CPS transformation exclusively for the proof of Theorem 3.2 above. On the practical side, code generation phases in compilers favor smaller, i.e., more manageable, programs. Hence, 1 In Reynolds's transformation the continuation is the second argument to a procedure. <p> Reasoning about Programs in Continuation-Passing Style 9 4 Transforming CPS programs With the elimination of all administrative redexes, we can turn our attention to "interesting" fi-transformations on CPS programs. Plotkin <ref> [22] </ref> was the first to offer some insights about the relation between reductions on source terms and CPS terms. In his comparative study of equational theories for call-by-value languages and call-by-name languages, he proved the following theorem. Theorem 4.1 (Plotkin [22]) Let M; N 2 fl. 1. v ` M = <p> Plotkin <ref> [22] </ref> was the first to offer some insights about the relation between reductions on source terms and CPS terms. In his comparative study of equational theories for call-by-value languages and call-by-name languages, he proved the following theorem. Theorem 4.1 (Plotkin [22]) Let M; N 2 fl. 1. v ` M = N implies v ` F [[M ]] = F [[N ]]; 2. v ` F [[M ]] = F [[N ]] does not imply v ` M = N ; 3. v ` F [[M ]] = F [[N ]] <p> In short, fi-reductions prove more equations on CPS terms than fi v -reductions prove on source terms. The effect of -reductions is unknown. Moreover, the induced observational equivalence relations do not correspond. Corollary 4.2 (Plotkin <ref> [22] </ref>) Let M; N 2 fl. 1. F [[M ]] ~ = n F [[N ]] implies M ~ = v N ; 2. M ~ = v N does not imply F [[M ]] ~ = n F [[N ]]. <p> Any expansion starting from a -abstraction will also result in a -abstraction. Therefore, L is a value: (F [[M ]] x:x) !! fi W 0 By the Standard Reduction theorem <ref> [22] </ref>, if a term reduces to a value, then it standard-reduces to a value. Therefore, eval n (F [[M ]] x:x) is defined. 30 A. Sabry, M. <p> Sabry, M. Felleisen As pointed out in Section 4, M ~ = v N does not imply that C k [[M ]] ~ = n C k [[N ]]. For example, if M = y:x:x (y x) df then, M ~ = v N <ref> [22] </ref>. On the other hand, C k [[M ]] = (k k:y:(k k:x:((y (x k)) x))); and the context D = ((k:[ ]) (k:m:m (x:x))))) differentiates the two expressions.
Reference: 23. <author> Reynolds, </author> <title> J.C. Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proc. ACM Annual Conference, </booktitle> <year> 1972, </year> <pages> 717-740. </pages>
Reference-contexts: 1 Compiling with CPS Many modern compilers for higher-order functional languages [1, 16, 24, 25] utilize some variant of the Fischer-Reynolds continuation-passing style (CPS) transformation <ref> [10, 23] </ref>. Once a program is in continuation-passing style, these compilers usually perform code optimizations via local transformations. Typical examples of such optimizations are loop unrolling, procedure inlining, and partial evaluation. In the terminology of the -calculus, optimizations generally correspond to (sequences of) fi- and -reductions. <p> F : fl ! fl F [[M N ]] = k:F [[M ]] (m:F [[N ]] n:(m k) n) [[x:M ]] = k:x:F [[M ]] k Reynolds <ref> [23] </ref> investigated definitional interpreters for higher-order languages. One of his goals was the desire to liberate the definition of a language from the parameter-passing technique of the defining language.
Reference: 24. <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: 1 Compiling with CPS Many modern compilers for higher-order functional languages <ref> [1, 16, 24, 25] </ref> utilize some variant of the Fischer-Reynolds continuation-passing style (CPS) transformation [10, 23]. Once a program is in continuation-passing style, these compilers usually perform code optimizations via local transformations. Typical examples of such optimizations are loop unrolling, procedure inlining, and partial evaluation. <p> On the practical side, code generation phases in compilers favor smaller, i.e., more manageable, programs. Hence, 1 In Reynolds's transformation the continuation is the second argument to a procedure. Reasoning about Programs in Continuation-Passing Style 7 "practical" CPS transformations <ref> [1, 5, 16, 24, 25] </ref> use special algorithms to minimize the size of their outputs.
Reference: 25. <author> Steele, G.L., Jr. RABBIT: </author> <title> A compiler for SCHEME. </title> <type> Memo 474, </type> <institution> MIT AI Lab, </institution> <year> 1978. </year>
Reference-contexts: 1 Compiling with CPS Many modern compilers for higher-order functional languages <ref> [1, 16, 24, 25] </ref> utilize some variant of the Fischer-Reynolds continuation-passing style (CPS) transformation [10, 23]. Once a program is in continuation-passing style, these compilers usually perform code optimizations via local transformations. Typical examples of such optimizations are loop unrolling, procedure inlining, and partial evaluation. <p> On the practical side, code generation phases in compilers favor smaller, i.e., more manageable, programs. Hence, 1 In Reynolds's transformation the continuation is the second argument to a procedure. Reasoning about Programs in Continuation-Passing Style 7 "practical" CPS transformations <ref> [1, 5, 16, 24, 25] </ref> use special algorithms to minimize the size of their outputs. <p> The last claim follows by induction on the number of -abstractions in F [[M ]]. The output of F 2 is extremely compact. For example, applying F 2 to (((x:y:x) a) b) yields the term: M = k:((x:((y:kx) b)) a) For the same example, both Steele's Rabbit transformation <ref> [25] </ref> and the Danvy/Filinski transformation [5] yield the term: 3 N = k:((k 1 x:(k 1 k 2 y:k 2 x)) (m:mkb) a): The evaluation of M requires two fi-reductions: M ! k:((y:ka) b) ! k:ka; while the evaluation of N requires three (binary) fi-reductions: N ! k:((m:mkb) (k 2 y:k
References-found: 25

