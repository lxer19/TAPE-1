URL: http://www.cs.indiana.edu/l/www/ftp/pierce/friendly.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Email: Benjamin.Pierce@inria.fr  David.Turner@dcs.ed.ac.uk  
Title: Statically Typed Friendly Functions via Partially Abstract Types  
Author: Benjamin C. Pierce INRIA-Roquencourt David N. Turner 
Date: April 1993  
Note: INRIA-Roquencourt Rapport  
Address: Edinburgh  
Affiliation: University of  de Recherche  
Pubnum: No. 1899  
Abstract: University of Edinburgh Technical Report ECS-LFCS-93-256 Abstract A well-known shortcoming of the object model of Simula and Smalltalk is the inability to deal cleanly with methods that require access to the internal state of more than one object at a time. Recent language designs have therefore extended the basic object model with notions such as friends' methods and protected features, which allow external access to the internal state of objects but limit the scope in which such access can be used. We show that a variant of this idea can be added to any type-theoretic model of the basic object-oriented mechanisms (encapsulation, message passing, and inheritance), using a construction based on Cardelli and Wegner's partially abstract types, a refinement of Mitchell and Plotkin's type-theoretic treatment of abstract types. and
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [BDG + 88] <author> Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common Lisp Object System specification X3J13 document 88-002R. </title> <journal> SIGPLAN Notices, </journal> <volume> 23, </volume> <year> 1988. </year>
Reference-contexts: But this is not possible: the object model specifies that each method is associated with exactly one object and has access to the internal state of just that object. Languages such as CLOS <ref> [BDG + 88] </ref> have addressed this problem by dropping the strong encapsulation requirement imposed by Smalltalk's object model. In CLOS, the internal state of an object is available globally. This facilitates the implementation of functions like set union, at the cost of weaker linguistic support for data abstraction.
Reference: [BM92] <author> Kim Bruce and John Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Proceedings of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albequerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: The ideas behind this system are due to Cardelli, particularly to his 1988 paper, "Structural Subtyping and the Notion of Power Type" [Car88b]; the extension of the subtype relation to type operators was developed by Cardelli and Mitchell <ref> [Car90, Mit90, BM92] </ref>. Cardelli [Car90] has given a more powerful treatment of operator subtyping, including both monotonic and antimonotonic subtyping in addition to pointwise subtyping. We omit a detailed treatment of the semantics of F ! . <p> A semantic model of a version of F ! extended with recursive types (and including recursively defined values, which are needed here to model self) has been given by Bruce and Mitchell <ref> [BM92] </ref>. B.1 Syntax B.1.1.
Reference: [Bru92] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented language: Design, static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in [PT93] will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93] </ref>. For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in [PT93]; however, the ideas here are not sensitive to the details of this model. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance.
Reference: [Bru93] <author> Kim B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in [PT93] will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93] </ref>. For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in [PT93]; however, the ideas here are not sensitive to the details of this model. <p> To simplify the underlying formal model, we use a functional style of programming with objects where, instead of updating the state in-place, a method returns a new state. (Questions of typing are not affected by this simplification; the model can be extended to include imperative-style object-oriented programming <ref> [Bru93] </ref>.) For example, a bump method for point objects might return a state whose x-coordinate has been increased by one: # bump = fun (state:-|x: Int|-) -x = plus 1 state.x-; bump = &lt;val&gt; : -|x:Int|- -&gt; -|x:Int|- A setX method takes an extra parameter, which becomes the x-coordinate of the <p> Since the internal state of points | just a single integer | is already fully accessible through the operations setX and getX, this example does not distinguish between formalisms that allow full-fledged friendly functions, with privileged access to the states of more than one object, from formalisms such as <ref> [Mit90, CCH + 89, Bru93, Car92] </ref>, which allow only a weak form of binary methods that can accept additional arguments of the same object type as the receiver but can access only one of them concretely. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance.
Reference: [Bud91] <author> Timothy Budd. </author> <title> An Introduction to Object-Oriented Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference-contexts: A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>.
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: The subtype relation is defined by a collection of inference rules (listed in Appendix B) with conclusions of the form ` S T . For example, we use the usual rule (c.f. <ref> [Car86] </ref>) for subtyping between record types: fl 1 ; :::; l n g fk 1 ; :::; k m g for each k i = l j , ` S i T j ` fjk 1 :S 1 ; :::; k m :S m jg 2 ? (S-Record) Consider, for example,
Reference: [Car88a] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year> <title> Preliminary version in Semantics of Data Types, </title> <editor> Kahn, MacQueen, and Plotkin, eds., </editor> <publisher> Springer-Verlag LNCS 173, </publisher> <year> 1984. </year>
Reference-contexts: A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>.
Reference: [Car88b] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: The ideas behind this system are due to Cardelli, particularly to his 1988 paper, "Structural Subtyping and the Notion of Power Type" <ref> [Car88b] </ref>; the extension of the subtype relation to type operators was developed by Cardelli and Mitchell [Car90, Mit90, BM92]. Cardelli [Car90] has given a more powerful treatment of operator subtyping, including both monotonic and antimonotonic subtyping in addition to pointwise subtyping.
Reference: [Car90] <author> Luca Cardelli. </author> <booktitle> Notes about F ! &lt;: . Unpublished notes, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: The ideas behind this system are due to Cardelli, particularly to his 1988 paper, "Structural Subtyping and the Notion of Power Type" [Car88b]; the extension of the subtype relation to type operators was developed by Cardelli and Mitchell <ref> [Car90, Mit90, BM92] </ref>. Cardelli [Car90] has given a more powerful treatment of operator subtyping, including both monotonic and antimonotonic subtyping in addition to pointwise subtyping. We omit a detailed treatment of the semantics of F ! . <p> The ideas behind this system are due to Cardelli, particularly to his 1988 paper, "Structural Subtyping and the Notion of Power Type" [Car88b]; the extension of the subtype relation to type operators was developed by Cardelli and Mitchell [Car90, Mit90, BM92]. Cardelli <ref> [Car90] </ref> has given a more powerful treatment of operator subtyping, including both monotonic and antimonotonic subtyping in addition to pointwise subtyping. We omit a detailed treatment of the semantics of F ! .
Reference: [Car92] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <note> Research re port 81, DEC Systems Research Center, January 1992. To appear in [GM93]. </note>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in [PT93] will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93] </ref>. For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in [PT93]; however, the ideas here are not sensitive to the details of this model. <p> Since the internal state of points | just a single integer | is already fully accessible through the operations setX and getX, this example does not distinguish between formalisms that allow full-fledged friendly functions, with privileged access to the states of more than one object, from formalisms such as <ref> [Mit90, CCH + 89, Bru93, Car92] </ref>, which allow only a weak form of binary methods that can accept additional arguments of the same object type as the receiver but can access only one of them concretely. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance.
Reference: [Cas92] <author> Giuseppe Castagna. </author> <title> Strong typing in object-oriented paradigms. </title> <institution> Rapport de Recherche LIENS-92-11, Ecole Normale Superieure, Paris, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: In a more theoretical vein, we are intrigued by the possibility of combining the techniques presented here with recent work on formalising CLOS's object model <ref> [Ghe91, CGL92, Cas92] </ref>. The required theoretical basis, an extension of Castagna, Ghelli, and Longo's lambda-calculus with subtyping and overloading to include F ! 's higher-order polymorphism, would be of significant interest in its own right.
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in [PT93] will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93] </ref>. For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in [PT93]; however, the ideas here are not sensitive to the details of this model. <p> Since the internal state of points | just a single integer | is already fully accessible through the operations setX and getX, this example does not distinguish between formalisms that allow full-fledged friendly functions, with privileged access to the states of more than one object, from formalisms such as <ref> [Mit90, CCH + 89, Bru93, Car92] </ref>, which allow only a weak form of binary methods that can accept additional arguments of the same object type as the receiver but can access only one of them concretely. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance.
Reference: [CGL92] <author> G. Castagna, G. Ghelli, and G. Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <booktitle> In ACM conference on LISP and Functional Programming, </booktitle> <pages> pages 182-192, </pages> <address> San Francisco, </address> <month> July </month> <year> 1992. </year> <note> ACM Press. Also available as Rapport de Recherche LIENS-92-4, </note> <institution> Ecole Normale Superieure, Paris. </institution>
Reference-contexts: In a more theoretical vein, we are intrigued by the possibility of combining the techniques presented here with recent work on formalising CLOS's object model <ref> [Ghe91, CGL92, Cas92] </ref>. The required theoretical basis, an extension of Castagna, Ghelli, and Longo's lambda-calculus with subtyping and overloading to include F ! 's higher-order polymorphism, would be of significant interest in its own right.
Reference: [Cha92] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <pages> pages 33-56, </pages> <year> 1992. </year>
Reference-contexts: Eiffel's selective exports provide a more general capability: each class may name a collection of classes whose methods are allowed direct access to its instances' internal states. This idea is refined still further in Chambers' language Cecil <ref> [Cha92] </ref>, in which multi-methods are regarded as "part of" all of the objects to which they may apply. Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year> <note> REFERENCES 27 </note>
Reference-contexts: The technical device used here to hide just the rep method while leaving the others visible outside the scope of the abstract type is a natural generalization of Cardelli and Wegner's notion of partially abstract type <ref> [CW85] </ref>. 3 A bonus of our approach is that the extra mechanism affects only the creation of objects and the invocation of friendly functions on them. Programs that manipulate objects in terms of the original object model are unaffected. <p> A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>. <p> Cardelli and Wegner <ref> [CW85] </ref> show how bounded existential types can be used to implement partially abstract types, where the exact representation type is hidden but some of its structure may be revealed. <p> Formally, the type system is a straightforward generalization of Cardelli and Wegner's bounded quantification <ref> [CW85] </ref> with a notion of type operator familiar from Girard's system F ! [Gir72]. The syntax and typing rules are summarized in Appendix B. The examples in the paper were typeset by a prototype compiler for F ! that type-checks and evaluates declarations preceded by the symbol #. <p> e'-. (Note that record types use slightly different brackets.) We select elements of a record using the syntax e.x, where x is a label: # record = -x = 1, y = 2-; record = &lt;val&gt; : -|x: Int, y: Int|- # record.x; 1 : Int The notion of subtyping <ref> [CW85] </ref> formalizes the observation that values of certain types may always be safely substituted for values of other types. <p> # inc : C -&gt; C, # isZero : C -&gt; Bool # |-; counter = &lt;val&gt; : Some (C) -|zero: C, inc: C-&gt;C, isZero: C-&gt;Bool|- Since we have subtyping, we allow a bound for the existentially quantified type variable C (this provides what are known as partially abstract types <ref> [CW85] </ref>). Abstract types are unpacked using the open construct.
Reference: [dB72] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: In particular, we allow only closed statements in instances of inference rules. Moreover, we assume that all variables bound in a context have distinct names. This convention, which amounts to regarding all variables as bound and viewing bound variables as deBruijn indices <ref> [dB72] </ref>, replaces the usual side-conditions in rules such as T-Some-E.
Reference: [Ghe91] <author> Giorgio Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 129-143, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <journal> Distributed as SIGPLAN Notices, </journal> <volume> Volume 26, Number 11, </volume> <month> November </month> <year> 1991. </year>
Reference-contexts: In a more theoretical vein, we are intrigued by the possibility of combining the techniques presented here with recent work on formalising CLOS's object model <ref> [Ghe91, CGL92, Cas92] </ref>. The required theoretical basis, an extension of Castagna, Ghelli, and Longo's lambda-calculus with subtyping and overloading to include F ! 's higher-order polymorphism, would be of significant interest in its own right.
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Formally, the type system is a straightforward generalization of Cardelli and Wegner's bounded quantification [CW85] with a notion of type operator familiar from Girard's system F ! <ref> [Gir72] </ref>. The syntax and typing rules are summarized in Appendix B. The examples in the paper were typeset by a prototype compiler for F ! that type-checks and evaluates declarations preceded by the symbol #. Declarations may be split across a number of lines, and are terminated with a semicolon. <p> F ! incorporates Girard's notion of type operators <ref> [Gir72] </ref>, which can be thought of as forming a simply-typed -calculus at the level of types. To ensure their well-formedness, types and type operators are assigned kinds, K, which have the form * or K-&gt;K. <p> For example, Fun (T) -|a:T,b:T|- is a subtype of Fun (T) -|a:T|-, since -|a:T,b:T|- is a subtype of -|a:T|-. 15 B Summary of F ! This appendix summarizes the syntax and typing rules of the typed -calculus F ! , an extension of Girard's system F ! <ref> [Gir72] </ref> with subtyping. The ideas behind this system are due to Cardelli, particularly to his 1988 paper, "Structural Subtyping and the Notion of Power Type" [Car88b]; the extension of the subtype relation to type operators was developed by Cardelli and Mitchell [Car90, Mit90, BM92].
Reference: [GM93] <author> Carl A. Gunter and John C. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>.
Reference: [MHF93] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In 1993 IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance.
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <note> To appear in [GM93]. </note>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in [PT93] will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93] </ref>. For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in [PT93]; however, the ideas here are not sensitive to the details of this model. <p> Since the internal state of points | just a single integer | is already fully accessible through the operations setX and getX, this example does not distinguish between formalisms that allow full-fledged friendly functions, with privileged access to the states of more than one object, from formalisms such as <ref> [Mit90, CCH + 89, Bru93, Car92] </ref>, which allow only a weak form of binary methods that can accept additional arguments of the same object type as the receiver but can access only one of them concretely. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance. <p> The ideas behind this system are due to Cardelli, particularly to his 1988 paper, "Structural Subtyping and the Notion of Power Type" [Car88b]; the extension of the subtype relation to type operators was developed by Cardelli and Mitchell <ref> [Car90, Mit90, BM92] </ref>. Cardelli [Car90] has given a more powerful treatment of operator subtyping, including both monotonic and antimonotonic subtyping in addition to pointwise subtyping. We omit a detailed treatment of the semantics of F ! .
Reference: [MP88] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>. <p> of friendly functions rests: Mitchell and Plotkin's use of existential types to give a straightforward type-theoretic explanation of abstract types and Cardelli and Wegner's extended notion of partially abstract types. 3 Partially abstract types Mitchell and Plotkin observed that abstract types can be modeled by existential types in polymorphic lambda-calculi <ref> [MP88] </ref>.
Reference: [PT93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <note> 1993. To appear; a preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: Rouaix's Alcool language [Rou90b, Rou90a, Rou92] explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation. This work extends recent theoretical work on static type systems for Smalltalk-style objects <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref>. Indeed, the same ideas can be used to extend any of these models with friendly functions. <p> We use the phrase friendly functions rather than multi-methods to avoid confusion with object models involving multiple-dispatch. In Section 2 we summarize the relevant parts of a static type system for objects originally presented in <ref> [PT93] </ref>. Section 3 describes partially abstract types and their encoding in terms of bounded existential types; Section 4 describes their use in encoding friendly functions. The encoding of inheritance found in [PT93] can also be modified to work in the presence of friendly functions; the construction is described in Appendix C. <p> In Section 2 we summarize the relevant parts of a static type system for objects originally presented in <ref> [PT93] </ref>. Section 3 describes partially abstract types and their encoding in terms of bounded existential types; Section 4 describes their use in encoding friendly functions. The encoding of inheritance found in [PT93] can also be modified to work in the presence of friendly functions; the construction is described in Appendix C. Our model of objects is based on F ! , a higher-order explicitly-typed -calculus with subtyping. A short introduction to F ! is given in Appendix A. <p> A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>. <p> Although our construction does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in <ref> [PT93] </ref> will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93]. <p> does not depend on the details of any particular type-theoretic model of objects, familiarity with the development in [PT93] will be helpful for understanding the more technical parts of the paper. 2 Ob jects A number of type-theoretic treatments of objects and message passing are available in the recent literature <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93] </ref>. For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in [PT93]; however, the ideas here are not sensitive to the details of this model. <p> For the sake of concreteness, we develop our account of friendly functions using a particular model of objects that we have discussed in depth in <ref> [PT93] </ref>; however, the ideas here are not sensitive to the details of this model. The state of an object is represented by a single value. <p> state.c-; c = &lt;val&gt; : Object CPointM # c' = send_bump CPointM c; c' = &lt;val&gt; : Object CPointM # send_getX CPointM c'; 6 : Int Complete details of the implementation of the Object type constructor, the new_object value constructor, and the functions for sending messages can be found in <ref> [PT93] </ref>. <p> Since bounded existential quantifiers can be encoded already in a second-order lambda-calculus with bounded quantification, it follows that this construction is available in any of the type-theoretic encodings of objects based on extensions of this calculus <ref> [Mit90, CCH + 89, Bru93, Bru92, Car92, PT93, MHF93] </ref> with no complication of the underlying formal theory. One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance. <p> One question that immediately arises is whether this construction interacts smoothly with mechanisms of inheritance. Somewhat surprisingly, we find that it does: for example, an implementation of inheritance based on the object model of <ref> [PT93] </ref> can be extended fairly straightforwardly with friendly functions. <p> Indeed, the friendly functions themselves can be inherited by subclasses! Since the details of this development are rather technical, we omit them here; interested readers may find them in Appendix C. 5 Future Work We believe that the high-level syntax for class definitions developed in <ref> [PT93] </ref> can be extended to provide a convenient syntax for class definitions with friendly functions. In a more theoretical vein, we are intrigued by the possibility of combining the techniques presented here with recent work on formalising CLOS's object model [Ghe91, CGL92, Cas92]. <p> T i ` fl 1 = e 1 ; :::; l n = e n g 2 fjl 1 :T 1 ; :::; l n :T n jg (T-Record-I) ` e 2 fjl:T jg (T-Record-E) 19 C Inheritance In this appendix we show that the implementation of inheritance developed in <ref> [PT93] </ref> can be extended to deal with friendly functions. Although our implementation provides inheritance of friendly functions themselves, this is only to illustrate the flexibility of our approach, rather than to suggest that a language design based on this form of inheritance would be ideal in practice. <p> We use a formulation of inheritance that makes the instance variables of a class visible to all of its subclasses, as in Smalltalk. Other choices are possible; see <ref> [PT93] </ref>. We reuse our example of points and colored points to illustrate our implementation of inheritance; for brevity, we omit the bump method in this section. <p> Inheritance allows these methods to be written once, in the definition of points, and then reused in the definition of colored points. We adapt our previous encoding of inheritance in <ref> [PT93] </ref> to automatically package up any friendly functions relevant to an object. A class is a data structure that can either be used as the starting point for the definition of subclasses by incremental extension (using the extend function), or can be instantiated to a package using the instantiate function. <p> To save space, we refer the reader to <ref> [PT93] </ref> for an explanation. # Class = # Fun (SelfM: *-&gt;*) % object interface type # Fun (SelfI: *-&gt;*) % object interface extended with rep method # Fun (SelfF: *-&gt;*) % friendly function interface # Fun (SelfR) % internal representation type # All (FinalR) % final representation # (FinalR-&gt;SelfR) -&gt; %
Reference: [Rey85] <author> John Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 185. </note>
Reference-contexts: A % symbol indicates that the rest of the line is a comment and will be ignored by the compiler. Basic familiarity with polymorphic type systems, subtypes, existential types, and conventional object-oriented languages is assumed; background reading on these topics can be found in <ref> [MP88, CW85, PT93, Car88a, Bud91, GR83, Rey85] </ref>.
Reference: [Rou90a] <author> Fran~cois Rouaix. </author> <title> ALCOOL-90: Typage de la surcharge dans un langage fonction-nel. </title> <institution> These de doctorat, Universite Paris 7, </institution> <year> 1990. </year>
Reference-contexts: This idea is refined still further in Chambers' language Cecil [Cha92], in which multi-methods are regarded as "part of" all of the objects to which they may apply. Rouaix's Alcool language <ref> [Rou90b, Rou90a, Rou92] </ref> explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation.
Reference: [Rou90b] <author> Fran~cois Rouaix. </author> <title> Safe run-time overloading. </title> <booktitle> In Proceedings of the 17th ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 355-366, </pages> <year> 1990. </year>
Reference-contexts: This idea is refined still further in Chambers' language Cecil [Cha92], in which multi-methods are regarded as "part of" all of the objects to which they may apply. Rouaix's Alcool language <ref> [Rou90b, Rou90a, Rou92] </ref> explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation.
Reference: [Rou92] <author> Fran~cois Rouaix. </author> <note> The Alcool-90 Report. Preliminary draft, in the Alcool distribution, </note> <month> April </month> <year> 1992. </year>
Reference-contexts: This idea is refined still further in Chambers' language Cecil [Cha92], in which multi-methods are regarded as "part of" all of the objects to which they may apply. Rouaix's Alcool language <ref> [Rou90b, Rou90a, Rou92] </ref> explores a related approach based on abstract types and overloading. In this paper, we develop a statically typed object model supporting flexible access to internal object states and enforcing encapsulation.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1986. </year>
Reference-contexts: The restriction that objects should normally be manipulated by sending them messages, rather than by modifying their internal state directly (using their slot accessors), is a matter of programming style: it is not enforced by the language. Other recent language designs take a more refined approach. In C++ <ref> [Str86] </ref>, each class definition may include a group of friend functions, which live outside of the instances of the class | they are functions, not methods | but are allowed to access the internal state of objects of that class on the same basis as the methods.
References-found: 30

