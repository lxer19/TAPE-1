URL: http://www.cs.washington.edu/research/projects/safety/www/papers/tse3/journal.ps
Refering-URL: http://www.cs.washington.edu/research/projects/safety/www/papers.html
Root-URL: 
Email: heimdahl@cps.msu.edu  
Title: Completeness and Consistency in Hierarchical State-Based Requirements  
Author: Mats P.E. Heimdahl Nancy G. Leveson 
Address: A-714 Wells Hall East Lansing, Michigan 48824-1027  FR-35 Seattle, WA 98195  
Affiliation: Michigan State University Department of Computer Science,  University of Washington Computer Science and Engineering,  
Abstract: This paper describes methods for automatically analyzing formal, state-based requirements specifications for some aspects of completeness and consistency. The approach uses a low-level functional formalism, simplifying the analysis process. State-space explosion problems are eliminated by applying the analysis at a high level of abstraction; i.e., instead of generating a reachability graph for analysis, the analysis is performed directly on the model. The method scales up to large systems by decomposing the specification into smaller, analyzable parts and then using functional composition rules to ensure that verified properties hold for the entire specification. The analysis algorithms and tools have been validated on TCAS II, a complex, airborne, collision-avoidance system required on all commercial aircraft with more than 30 passengers that fly in U.S. airspace. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Atlee and J. Gannon. </author> <title> State-based model checking of event-driven system require ments. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Conference on Software for Critical Systems. Software Engineering Notes. </booktitle> <volume> Volume 16 Number 5, </volume> <year> 1991. </year>
Reference-contexts: The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem. Model checking: Model checking is conceptually simple and is applicable in a wide variety of languages and application areas <ref> [1, 6, 7] </ref>. Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the state space can significantly improve the performance of the model checking approach [5].
Reference: [2] <author> G. R. Bruns, S. L. Gerhart, I. Forman, and M. Graf. </author> <title> Design technology assessment: The statecharts approach. </title> <type> Technical Report STP-107-86, </type> <institution> MCC, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Viewing an RSML specification as a mathematical relation is the basis for our formalization of the language and will be described in detail in Section 3. AND/OR Tables. Statecharts use predicate calculus to describe the guarding conditions on the transitions <ref> [2, 9] </ref>. Our TCAS external reviewers (including avionics engineers, component engineers, airline representatives, and pilots), however, did not find this notation natural or reviewable.
Reference: [3] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Our analysis tools use Binary Decision Diagrams (BDDs) <ref> [3] </ref> for the manipulation of the conditions. BDDs are data structures used to represent boolean functions in a canonical form. Initially, our main concern was the performance of the and and or operations needed to check for mutual exclusion and complete coverage.
Reference: [4] <author> J.R. Burch, E.M. Clarke, D.E. Long, K.L. McMillan, and D.L. Dill. </author> <title> Symbolic model chacking for sequential circuit verification. </title> <type> Technical Report CMU-CS-93-211, </type> <institution> Carnegie Mellon University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the state space can significantly improve the performance of the model checking approach [5]. Symbolic model checking has been applied to large models <ref> [5, 4] </ref>, but only for systems with 3 simple, repetitive elements|such as those commonly found in hardware applications. The time and space complexity of the symbolic approach is affected not only by the size of the specification but also by the regularity of specification.
Reference: [5] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the state space can significantly improve the performance of the model checking approach <ref> [5] </ref>. Symbolic model checking has been applied to large models [5, 4], but only for systems with 3 simple, repetitive elements|such as those commonly found in hardware applications. <p> Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the state space can significantly improve the performance of the model checking approach [5]. Symbolic model checking has been applied to large models <ref> [5, 4] </ref>, but only for systems with 3 simple, repetitive elements|such as those commonly found in hardware applications. The time and space complexity of the symbolic approach is affected not only by the size of the specification but also by the regularity of specification.
Reference: [6] <author> E. M. Clarke, M. C. Browne, E. A. Emerson, and A. P. Sistla. </author> <title> Using temporal logic for automatic verification of finite state systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 3-26. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem. Model checking: Model checking is conceptually simple and is applicable in a wide variety of languages and application areas <ref> [1, 6, 7] </ref>. Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the state space can significantly improve the performance of the model checking approach [5].
Reference: [7] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite state concurrent systems using temporal logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem. Model checking: Model checking is conceptually simple and is applicable in a wide variety of languages and application areas <ref> [1, 6, 7] </ref>. Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the state space can significantly improve the performance of the model checking approach [5].
Reference: [8] <author> Patrice Godefroid, Gerhard J. Holzmann, and Dieder Pirottin. </author> <title> State space caching revisited. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 175-186, </pages> <year> 1992. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to derive, and these approaches may not be practical for complex systems. Reachability analysis: Modeling a system as a finite-state machine and then performing reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [8, 14, 15] </ref>. The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem.
Reference: [9] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Section 6 presents conclusions. 2 Overview of the RSML Notation RSML is a state-based requirements specification language suitable for the specification of reactive systems. RSML includes several features developed by Harel for Statecharts <ref> [10, 9] </ref>: superstates, AND decomposition, broadcast communication, and conditional connectives. In addition, RSML has some unique syntactic and semantic features that were developed to enhance readability, reviewability, and analyzability and our ability to handle complex systems. A complete description of RSML is provided in [19]. <p> Viewing an RSML specification as a mathematical relation is the basis for our formalization of the language and will be described in detail in Section 3. AND/OR Tables. Statecharts use predicate calculus to describe the guarding conditions on the transitions <ref> [2, 9] </ref>. Our TCAS external reviewers (including avionics engineers, component engineers, airline representatives, and pilots), however, did not find this notation natural or reviewable.
Reference: [10] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Section 6 presents conclusions. 2 Overview of the RSML Notation RSML is a state-based requirements specification language suitable for the specification of reactive systems. RSML includes several features developed by Harel for Statecharts <ref> [10, 9] </ref>: superstates, AND decomposition, broadcast communication, and conditional connectives. In addition, RSML has some unique syntactic and semantic features that were developed to enhance readability, reviewability, and analyzability and our ability to handle complex systems. A complete description of RSML is provided in [19].
Reference: [11] <author> D. Harel, A. Pnueli, J.P. Schmidt, and R. Sherman. </author> <title> On the formal semantics of statecharts (extended abstract). </title> <booktitle> In 2nd Symposium on Logic in Computer Science, </booktitle> <pages> pages 54-64, </pages> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: The restrictions governing the structure of a global state have been formally defined for Statecharts by Harel <ref> [11] </ref>. These definitions are also applicable to RSML. Although the definitions are not essential for understanding the remainder of the paper, for completeness they have been included in Appendix A. The remainder of this section is devoted to the next-state relation F .
Reference: [12] <author> Mats P.E. Heimdahl. </author> <title> Static Analysis of State-Based Requirements: Analysis for Com pleteness and Consistency. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <year> 1994. </year>
Reference-contexts: Fortunately, the number of parallel transitions in real systems seems to be fairly limited, and this straight forward approach has been shown to be adequate to analyze a major part of a large real life system (TCAS II) for determinism <ref> [12] </ref>. struct Event String name; TransitionArray transitions; // All transitions triggered by this event -struct Nondeterministic Trans trans1; Trans trans2; Table 4: Data structure for non-deterministic pairs of transition NondeterministicArray NondeterministicTransitions (Event e) NondeterministicArray resultArray; for (i = 0 ; i &lt; size_of (e.transitions); i++) for (j = i+1; j &lt;
Reference: [13] <author> Mats P.E. Heimdahl and Nancy G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <month> April </month> <year> 1995. </year> <month> 28 </month>
Reference-contexts: this modification, the set of transitions out of state ASL-1 is d-complete , and the tool will report that there are no conditions where the behavior is unspecified (Figure 11). 5.1.1 Spurious Error Reports During initial experiments with our first prototype tool, spurious error reports were not a serious problem <ref> [13] </ref>. All spurious reports could be traced either to (1) a lack of type checking capability or (2) the inability of the tool to adequately include information about the structure of the state machine in the analysis.
Reference: [14] <author> Gerhard J. Holzmann. </author> <title> Tracing protocols. </title> <journal> AT& T Technical Journal, </journal> <volume> 64(10), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to derive, and these approaches may not be practical for complex systems. Reachability analysis: Modeling a system as a finite-state machine and then performing reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [8, 14, 15] </ref>. The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem.
Reference: [15] <author> Gerhard J. Holzmann. </author> <title> Automated protocol validation in Argos: Assertion proving and scatter searching. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(6) </volume> <pages> 683-696, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to derive, and these approaches may not be practical for complex systems. Reachability analysis: Modeling a system as a finite-state machine and then performing reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [8, 14, 15] </ref>. The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem.
Reference: [16] <author> M. S. Jaffe, N. G. Leveson, M. P.E. Heimdahl, and B. Melhart. </author> <title> Software require ments analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 241-258, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: The definition of specification completeness provided by Jaffe was subsequently formalized using a simple Mealy-machine model called RSM (Requirements State Machine) <ref> [16] </ref>. The RSM notation was developed solely as a means for formally defining our criteria, and lacks most desirable properties of a true requirements specification language. To be useful in practical applications, these criteria need to be translated into criteria applicable to a real specification language. <p> It may seem overly restrictive to require that the behavior of the software be limited to a mathematical function. However, safety-critical software should not be incompletely specified. In <ref> [16] </ref>, we define requirements completeness as the specification being sufficient to distinguish the behavior of the desired software from that of any other, undesired program that might be designed. Nondeterministic specifications often hide dangerous incompleteness in this sense. <p> Our long term goal is to provide a suite of analysis tools to help find a wide variety of flaws in software requirements early during software development. Many desirable properties of requirements specification have been defined by Jaffe et al. <ref> [16] </ref>, for example, non-reachability of hazardous states and path robustness properties. Additional properties are being defined for the human-computer interface (see Leveson [20] for some of the new criteria).
Reference: [17] <author> M.S. Jaffe. </author> <title> Completeness, Robustness, and Safety in Real-Time Software Requirements and Specifications. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <year> 1988. </year>
Reference-contexts: Jaffe, in his dissertation, defined a rigorous basis for ascertaining whether or not a given set of software requirements is internally complete, i.e, closed with respect to statements and inferences that can be made on the basis of information included in the specification <ref> [17] </ref>. Emphasis is placed on aspects of requirements specification that are usually not adequately handled, including timing and robustness, and on aspects that are particularly related to safety and accidents.
Reference: [18] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> TCAS II Requirements Specification. </title>
Reference-contexts: Thus, the analysis is both conceptually simple and eliminates the problem with state-space explosion. To ensure that the formal RSML specification language and the associated analysis algorithms and tools are appropriate for large and realistic systems, a testbed specification was developed for TCAS II <ref> [18] </ref>. The testbed is currently being used to develop and validate various types of analysis algorithms and tools on the underlying formal model. <p> Although the TCAS specification effort was originally planned to be experimental only, the government/industry groups responsible for TCAS II liked RSML so much that the specification was adopted as the official FAA TCAS II System Requirements Specification <ref> [18] </ref>. As a result, our initial baseline specification was subjected to an extensive (and expensive) independent verification and validation (IV&V) effort. We have applied the analysis techniques described in this paper to major parts of our baseline TCAS II specification.
Reference: [19] <author> N. G. Leveson, M. P.E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements spec ification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: RSML was developed by the Irvine Safety Research Group using a real aircraft collision-avoidance system called TCAS II (Traffic alert and Collision Avoidance System II) as a testbed <ref> [19] </ref>. <p> In addition, RSML has some unique syntactic and semantic features that were developed to enhance readability, reviewability, and analyzability and our ability to handle complex systems. A complete description of RSML is provided in <ref> [19] </ref>. This section contains only a description of the RSML features necessary to understand this paper. A simple finite-state machine is composed of states connected by transitions (see Figure 1). Default or start states are signified by states whose connecting transition has no source.
Reference: [20] <author> Nancy G. Leveson. Safeware: </author> <title> System Safety and Computers. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: that many serious conceptual errors are introduced in this first stage of software development|errors introduced during the requirements stage have been shown to be more difficult and more expensive to correct than errors introduced later in the lifecycle, and they are more likely than implementation errors to be safety critical <ref> [20, 21] </ref>. Therefore, it is important to provide methods and techniques to eliminate requirements-related errors as early as possible. To provide analysis procedures to find errors in specifications, it is first necessary to determine the desirable properties of a specification. <p> Many desirable properties of requirements specification have been defined by Jaffe et al. [16], for example, non-reachability of hazardous states and path robustness properties. Additional properties are being defined for the human-computer interface (see Leveson <ref> [20] </ref> for some of the new criteria). Our goal is to formally define these properties in the RSML framework (and develop new ones suitable to this new framework) and provide efficient automated analysis procedures for these properties. 27
Reference: [21] <author> R. Lutz. </author> <title> Targeting safety-related errors during software requirements analysis. </title> <booktitle> In Proceedings of the First ACM SOGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: that many serious conceptual errors are introduced in this first stage of software development|errors introduced during the requirements stage have been shown to be more difficult and more expensive to correct than errors introduced later in the lifecycle, and they are more likely than implementation errors to be safety critical <ref> [20, 21] </ref>. Therefore, it is important to provide methods and techniques to eliminate requirements-related errors as early as possible. To provide analysis procedures to find errors in specifications, it is first necessary to determine the desirable properties of a specification.
Reference: [22] <author> A. Pnueli and M. Shalev. </author> <title> What is in a step? In J. </title> <editor> Klop, J. Meijer, and J. Rutten, editors, J.W. De Baker, </editor> <booktitle> Liber Amicorum, </booktitle> <pages> pages 373-400. </pages> <address> CWI Amsterdam, </address> <year> 1989. </year>
Reference: [23] <author> A. P. Ravn and H. Richel. </author> <title> Requirements capture for embedded real-time systems. </title> <booktitle> In IMACS Symposium MCTS, </booktitle> <year> 1991. </year>
Reference-contexts: Formal proof systems: Formal proof systems can be powerful tools in the verification of critical properties of algorithms [25]. Attempts have been made to extend the use of formal proofs and apply them to requirements specifications, for example, the ProCoS (Provably Correct Systems) project <ref> [23, 24] </ref>. Unfortunately, the languages used in the theorem proving approach, such as process algebras and higher order logics, are not understandable by the non-software professionals involved in most requirements specification efforts and thus are not suitable as high-level requirements languages.
Reference: [24] <author> H. Richel and A. P. Ravn. </author> <title> Requirements capture for computer based systems. </title> <type> Tech nical Report ID/DTH HR 2/2, </type> <institution> Technical University of Denmark, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Formal proof systems: Formal proof systems can be powerful tools in the verification of critical properties of algorithms [25]. Attempts have been made to extend the use of formal proofs and apply them to requirements specifications, for example, the ProCoS (Provably Correct Systems) project <ref> [23, 24] </ref>. Unfortunately, the languages used in the theorem proving approach, such as process algebras and higher order logics, are not understandable by the non-software professionals involved in most requirements specification efforts and thus are not suitable as high-level requirements languages.
Reference: [25] <author> J. Rushby and F. von Henke. </author> <title> Formal verification of algorithms for critical systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 13-23, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Related approaches to requirements analysis include methods based on formal proof systems and different static analysis techniques such as reachability analysis and model checking. Formal proof systems: Formal proof systems can be powerful tools in the verification of critical properties of algorithms <ref> [25] </ref>. Attempts have been made to extend the use of formal proofs and apply them to requirements specifications, for example, the ProCoS (Provably Correct Systems) project [23, 24].
References-found: 25

