URL: ftp://ftp.csd.uu.se/pub/papers/reports/0141.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: fperm,thomaslg@csd.uu.se  
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Type Graphs in Practice proposed as a domain suitable for inferring disjunctive and recursive types
Author: Per Mildner, Thomas Lindgren 
Keyword: Type graphs  
Note: have been  
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Dept., Uppsala University  
Abstract: UPMAIL Technical Report No. 141 April 7, 1997 ISSN 1100-0686 Abstract Of central importance are the operations used to ensure termination of the analysis, i.e., the methods used to introduce recursiveness in the inferred types. We evaluate performance of several such methods on some Prolog programs of realistic size. We show that none of the methods previously proposed in the literature are, in fact, feasible as described. We also show that the problems are not primarily dependent on the size of the analysed program, but instead on the complexity, and thus size, of the intermediate types. We propose and evaluate some methods to overcome these problems. We conclude that using the upper bound operation on type graphs will, in practice, make the analysis infeasible for many typical pro grams.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Le Charlier, K. Musumbu, P. Van Hentenryck. </author> <title> A Generic Abstract Interperation Algorithm and Its Complexity Analysis (Extended Abstract). ICLP 91, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [2] <author> B. Le Charlier, P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog ACM Transactions on Programming Languages and Systems, </title> <booktitle> 16(1) </booktitle> <pages> 35-101, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: This differs from the pattern domain used for the same purpose in GAIA <ref> [2] </ref>.
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Comparing the Galois Connection and Widening/Narrowing Approaches to Abstract Interpretation, invited paper. </title> <booktitle> In Programming Language Implementation and Logic Programming, Proceedings of the Fourth International Symposium, PLILP'92, 1992, also Lecture Notes in Computer Science 631, </booktitle> <pages> pages 269-295. </pages>
Reference-contexts: For type graphs it does not hold 2 as it is possible to construct an infinite number of type graphs describing successively larger sets of concrete values. To ensure termination of the analysis for these kinds of domains a widening can be used <ref> [3] </ref> to ensure that any such sequence of successively less precise approximations is stationary, i.e., that the analyser will reach a final approximation in a finite number of steps.
Reference: [4] <author> S.K. Debray. </author> <title> Efficient dataflow analysis of logic programs. </title> <journal> Journal of the ACM, </journal> <volume> Vol 39, No. 4, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: Note that there are no nodes denoting the set of unbound, i.e., free, variables. Instead an any-node will have to be used. The disadvantage to this is that information sometimes is lost when free variables occurs. The advantage is that it makes our domain instantiation-closed <ref> [4] </ref>. This avoids the need for the expensive and complex tracking of possible aliasing between variables. Abstract Atomic Values All numbers are abstracted to the same abstract num value.
Reference: [5] <author> T.W. Getzinger. </author> <title> Abstract interpretation for the compile-time optimization of logic programs. </title> <type> Ph.D. Thesis, </type> <institution> University of South Cali-fornia, </institution> <type> Report 93/09, </type> <year> 1993. </year>
Reference-contexts: They did not provide results of using the type graph domain on programs of any significant size. Getzinger, in his thesis <ref> [5] </ref>, evaluated several domains in order to evaluate their impact on the code generated by an optimising Prolog compiler. His attempt to evaluate (rigid) type graphs met with mixed success as it failed to terminate within reasonable time for many of the benchmarks used. <p> Their article does not say how numbers or primitives such as is/2 and arg/3 were handled. 3 Our Analyser The present work uses an analyser framework, implemented in Prolog, similar to that used by Getzinger in his thesis <ref> [5] </ref>, i.e., a mono-variant top-down analyser. The analyser ignores cut as well as clause-order but observes the left to right evaluation order for clause bodies. For every predicate a single pair of call and success pattern is maintained. <p> This set of benchmarks are widely known, selected to be representative of real Prolog programs, easily obtainable 6 and can be executed using accompanying input data. The Berkeley benchmarks have been used <ref> [5] </ref> to evaluate the analyser and compiler in the Aquarius system. We have included the "large" benchmarks from this archive. Additionally we used file aquarius compiler.pl 7 , a stand-alone version of the compiler in the Aquarius system.
Reference: [6] <author> P. Van Hentenryck, A. Cortesi, B. Le Charlier. </author> <title> Type Analysis of Prolog Using Type Graphs Journal of Logic Programming, </title> <journal> pp. </journal> <pages> 179-209, </pages> <year> 1995. </year>
Reference-contexts: His attempt to evaluate (rigid) type graphs met with mixed success as it failed to terminate within reasonable time for many of the benchmarks used. He did not attempt to analyse the reasons for this in any depth 1 . Finally, Hentenryck et al. <ref> [6] </ref> incorporated rigid type graphs into their generic analyser framework GAIA and proposed a novel widening operator. To our knowledges this is the only previous work that provides information on using type graphs not only for "toy" programs. <p> A functor-node with arity zero is used to abstract atoms, e.g., []. A or-node has n unordered children, n &gt; 1 and denotes the union of the denotations of its children. There are some additional constraints imposed on type graphs, for details see <ref> [6, 8] </ref>. Note that there are no nodes denoting the set of unbound, i.e., free, variables. Instead an any-node will have to be used. The disadvantage to this is that information sometimes is lost when free variables occurs. The advantage is that it makes our domain instantiation-closed [4]. <p> In the tables below this method is denoted Depth-2. Topological Clash In order to better guide the generalisation of the type graphs Hentenryck et al. used both the old type graph and the upper bound of the old and new type graph for a particular argument position <ref> [6] </ref>. Comparing the two type graphs they use the mismatching nodes, what they termed topological clashes, to guide the introduction of back arcs. <p> A simple method is to use an any-node but it is possible to obtain better results by actually performing an upper bound and ensuring the size limit in some way. It is not clear what method was used in <ref> [6] </ref>. Our implementation uses the ordinary upper bound operation and then applies successively aggressive methods to bring the size down to below the limit. As a last, but in practice never encountered, resort we fall back to using an any-node when the upper bound cannot otherwise be made small enough. <p> We have included the "large" benchmarks from this archive. Additionally we used file aquarius compiler.pl 7 , a stand-alone version of the compiler in the Aquarius system. We have not been able to obtain the benchmarks used by Hentenryck et al <ref> [6] </ref> in their evaluation of the TC widening 8 . Table 1 lists the benchmarks used and Table 2 gives some indication of the size and structure of each benchmark program. <p> At least some of them are broken in ways that causes the analyser to determine that the program would fail before doing any useful work. 8 The benchmarks available by ftp from Brown University do not seem to be the same as those used in <ref> [6] </ref> since several size measures differ from those reported for the benchmarks in [6]. Making a meaningful comparison of our results with those reported in [6] using "similar" programs would be difficult, especially for domains as precise as those considered here. 6 not include calls to undefined procedures, such as builtins <p> ways that causes the analyser to determine that the program would fail before doing any useful work. 8 The benchmarks available by ftp from Brown University do not seem to be the same as those used in <ref> [6] </ref> since several size measures differ from those reported for the benchmarks in [6]. Making a meaningful comparison of our results with those reported in [6] using "similar" programs would be difficult, especially for domains as precise as those considered here. 6 not include calls to undefined procedures, such as builtins for which the analyser have no special handling. <p> before doing any useful work. 8 The benchmarks available by ftp from Brown University do not seem to be the same as those used in <ref> [6] </ref> since several size measures differ from those reported for the benchmarks in [6]. Making a meaningful comparison of our results with those reported in [6] using "similar" programs would be difficult, especially for domains as precise as those considered here. 6 not include calls to undefined procedures, such as builtins for which the analyser have no special handling.
Reference: [7] <author> G. </author> <title> Janssens Deriving Run Time Properties of Logic Programs by Means of Abstract Interpretation. </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Katholieke Universiteit Leuven, </institution> <year> 1990. </year>
Reference-contexts: Their work, including the thesis by Janssens <ref> [7] </ref> established a firm theoretical basis for type graphs and their associated operations (mainly upper bound of two type graphs, lower bound of two type graphs, comparing the denotations of two type graphs and Depth-k restriction as a way to ensure termination of the analysis). <p> Depth-k Restriction One way of ensuring termination is to limit the number of times a specific functor can occur on a forward path from the root of the type graph 3 <ref> [8, 7] </ref>. Assuming a finite number of distinct functors in the analysed program this implies a finite maximum size of a type graph and thus ensures termination. <p> We currently select the nearest suitable node where a suitable node is either a functor-node with the same name/arity as the replaced node or an or-node with a child with the same name/arity as the removed node. For all the details see <ref> [7] </ref>. 4 and then repeating the process until no violation of the Depth-k restriction remains. We have evaluated the case where k = 2, i.e., when no functor is allowed to appear more than twice on a forward path. In the tables below this method is denoted Depth-2.
Reference: [8] <author> G. Janssens, M. Bruynooghe. </author> <title> Deriving Descriptions of Possible Values of Program Variables by Means of Abstract Interpretation Journal of Logic Programming, </title> <address> 13(2-3):205-258, </address> <year> 1992. </year>
Reference-contexts: general unification with matching; determining that parts of the program will never fail, thus enabling a more efficient execution model; compile time reuse, i.e., statically determine that a term appearing at runtime can be destructively reused. 1 2 Relation to other research Type graphs were introduced by Janssens and Bruynooghe <ref> [8] </ref> as a domain for inferring disjunctive and recursive types of Prolog programs through abstract interpretation. <p> A functor-node with arity zero is used to abstract atoms, e.g., []. A or-node has n unordered children, n &gt; 1 and denotes the union of the denotations of its children. There are some additional constraints imposed on type graphs, for details see <ref> [6, 8] </ref>. Note that there are no nodes denoting the set of unbound, i.e., free, variables. Instead an any-node will have to be used. The disadvantage to this is that information sometimes is lost when free variables occurs. The advantage is that it makes our domain instantiation-closed [4]. <p> As mentioned above we treat other atomic values as functors with arity zero. 3 Abstract Aliasing The basic type graph domain is augmented with definite same-value information, in much the same way as done by Janssens and Bruynooghe <ref> [8] </ref>. This differs from the pattern domain used for the same purpose in GAIA [2]. <p> Depth-k Restriction One way of ensuring termination is to limit the number of times a specific functor can occur on a forward path from the root of the type graph 3 <ref> [8, 7] </ref>. Assuming a finite number of distinct functors in the analysed program this implies a finite maximum size of a type graph and thus ensures termination. <p> method is denoted Jungle. 6 Additional Heuristics We also tried some additional methods piggybacked upon the other widen-ings in an attempt to alleviate some of their problems. 5 Fold Equal Nodes The basic upper bound and intersection operations for type graphs do not produce a type graph that is minimal <ref> [8] </ref>. Thus there may be nodes with a denotation equal to an ancestor of the node. It is then possible to replace the node with a back arc to the ancestor, thus producing a type graph with the same denotation with fewer nodes.
Reference: [9] <author> T. Lindgren, P. Mildner. </author> <title> The Precision of a Simple Structure Analyzer Technical report 140, </title> <institution> Computing Science Department, Uppsala University, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: As used here, we still need to transform the type jungle from its compact representation to a type graph. In a companion paper we investigate an analyser using the compact type jungle representation throughout the analysis <ref> [9] </ref>. <p> Still it fails for expr 11 . The problem seems to be that the process of transforming from the compact type jungle representation to an explicitly represented type graph can produce a very large type graph. As a comparison the type jungle based analyser described in <ref> [9] </ref> analyses expr in just a few seconds. 8 Conclusion We have shown that the previously proposed type graph widenings Depth-k and TC does not keep down the size of intermediate type graphs appearing during abstract interpretation. <p> A problem in the current setting is that, even though type jungles allow a compact representation, the explicit representation of a type jungle as a type graph can be prohibitly large. A companion paper <ref> [9] </ref> investigates the use of type jungles without explicit representation as type graphs. 9 Future Work It would be interesting to compare the precison obtained using the various method investigated here. In particular we would like to apply the same methods as used in [9], comparing the static precison with the <p> A companion paper <ref> [9] </ref> investigates the use of type jungles without explicit representation as type graphs. 9 Future Work It would be interesting to compare the precison obtained using the various method investigated here. In particular we would like to apply the same methods as used in [9], comparing the static precison with the dynamic precision obtained by weighting procedures by their execution frequency and comparing the static and dynamic precison with the types that actually appears when executing the analysed programs.
Reference: [10] <author> A. Mulkers, W. Winsborough, M. Bruynooghe. </author> <title> Analysis of Shared Data Structures for Compile-Time Garbage collection in Logic Programs. ICLP 90, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [11] <author> P. Van Roy. </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? Ph.D. </title> <type> Thesis, </type> <institution> University of California (Berkeley), </institution> <year> 1990. </year>
Reference-contexts: 1 Background Inferring, at compile time, the recursive structure of arguments that will appear at runtime is important for many advanced compiler optimisation <ref> [11, 12] </ref>.
Reference: [12] <author> A. Taylor. </author> <title> High Performance Prolog Implementation. </title> <type> Ph.D. Thesis, </type> <institution> Basser Dept. of Comp.Sci., University of Sydney, </institution> <year> 1991. </year> <month> 14 </month>
Reference-contexts: 1 Background Inferring, at compile time, the recursive structure of arguments that will appear at runtime is important for many advanced compiler optimisation <ref> [11, 12] </ref>.
References-found: 12

