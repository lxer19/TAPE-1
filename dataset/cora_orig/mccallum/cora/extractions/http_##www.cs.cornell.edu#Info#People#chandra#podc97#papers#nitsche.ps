URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/papers/nitsche.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/newProgram.html
Root-URL: 
Email: Email: nitsche@ifi.unizh.ch  Email: pw@montefiore.ulg.ac.be  
Title: Relative Liveness and Behavior Abstraction (Extended Abstract)  
Author: Ulrich Nitsche Pierre Wolper 
Keyword: Verification, Relative Liveness Properties, Behavior Abstraction, Simple Homomorphisms.  
Address: Winterthurerstr. 190, CH-8057 Zurich, Switzerland  Montefiore, B28 B-4000 Liege Sart Tilman, Belgium  
Affiliation: University of Zurich, Department of Computer Science  University of Liege, Institute  
Abstract: This paper is motivated by the fact that verifying liveness properties under a fairness condition is often problematic, especially when abstraction is used. It shows that using a more abstract notion than truth under fairness, specifically the concept of relative liveness property can lead to interesting possibilities. Technically, it is first established that deciding relative liveness is a PSPACE-complete problem and it is shown that relative liveness properties can always be satisfied by some fair implementation. Thereafter, the interaction between behavior abstraction and relative liveness properties is studied and it is proved that relative liveness properties can be verified on behavior abstractions, if the abstracting homomorphism is simple in the sense of Ochsenschlager. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abadi, M., and Lamport, L. </author> <title> The existence of refinement mappings. </title> <type> SRC Report 29, </type> <institution> DEC System Research Center, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: This concept and the dual notion of relative safety property were introduced in [12] as a means of clarifying the shift from liveness to safety when timing constraints are introduced in a system. It can also be traced to the notion of machine-closed property <ref> [1, 2, 4] </ref>. Here we make a different use of the concept and view it as an abstraction of a liveness property being true under fairness. In fact, we interpret relative liveness as a satisfaction relation for properties represented by temporal logic formulas [8, 23]. <p> Hardness can be established by a reduction from regular language inclusion [10]. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure. Indeed, recall the following definition <ref> [1, 2, 4] </ref>. Definition 4.6 Let fl L ! ! , for an alphabet . (L ! ; fl) is called a machine closed live structure if and only if pre (L ! ) pre (fl).
Reference: [2] <author> Abadi, M., and Lamport, L. </author> <title> Composing specifications. </title> <type> SRC Report 66, </type> <institution> DEC System Research Center, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: This concept and the dual notion of relative safety property were introduced in [12] as a means of clarifying the shift from liveness to safety when timing constraints are introduced in a system. It can also be traced to the notion of machine-closed property <ref> [1, 2, 4] </ref>. Here we make a different use of the concept and view it as an abstraction of a liveness property being true under fairness. In fact, we interpret relative liveness as a satisfaction relation for properties represented by temporal logic formulas [8, 23]. <p> Hardness can be established by a reduction from regular language inclusion [10]. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure. Indeed, recall the following definition <ref> [1, 2, 4] </ref>. Definition 4.6 Let fl L ! ! , for an alphabet . (L ! ; fl) is called a machine closed live structure if and only if pre (L ! ) pre (fl).
Reference: [3] <author> Alpern, B., and Schneider, F. B. </author> <title> Defining liveness. </title> <journal> Information Processing Letters 21, </journal> <month> 4 (October </month> <year> 1985), </year> <pages> 181-185. </pages>
Reference-contexts: 1 Introduction To be able to verify liveness properties of a system <ref> [3] </ref>, it is almost always necessary to include a fairness hypothesis in the system description [9]. Indeed, introducing a fairness hypothesis makes it possible to ignore behaviors that correspond to extreme execution scenarios and that, in any case, would not occur in any reasonable implementation. <p> Remark 1 If L ! = ! , then the definitions of relative live-ness and relative safety become exactly the definitions of live-ness and safety given in <ref> [3] </ref>. To prove the decidability of relative liveness and safety for regular !-languages, we use the following characterizations of these properties. <p> General properties can always be represented as the intersection of a liveness and a safety property <ref> [3] </ref>. As given precisely below, the relativized version of this result is that a property holds for an !-language if it is both a relative liveness and a relative safety property of the language.
Reference: [4] <author> Alur, R., and Henzinger, T. A. </author> <title> Local liveness for compositional modeling of fair reactive systems. </title> <booktitle> In Computer Aided Verification (CAV) '95 (1995), </booktitle> <editor> P. Wolper, Ed., </editor> <volume> vol. </volume> <booktitle> 939 of Lecture Notes in Computer Scinece, </booktitle> <publisher> Springer, </publisher> <pages> pp. 166-179. </pages>
Reference-contexts: This concept and the dual notion of relative safety property were introduced in [12] as a means of clarifying the shift from liveness to safety when timing constraints are introduced in a system. It can also be traced to the notion of machine-closed property <ref> [1, 2, 4] </ref>. Here we make a different use of the concept and view it as an abstraction of a liveness property being true under fairness. In fact, we interpret relative liveness as a satisfaction relation for properties represented by temporal logic formulas [8, 23]. <p> Hardness can be established by a reduction from regular language inclusion [10]. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure. Indeed, recall the following definition <ref> [1, 2, 4] </ref>. Definition 4.6 Let fl L ! ! , for an alphabet . (L ! ; fl) is called a machine closed live structure if and only if pre (L ! ) pre (fl).
Reference: [5] <author> Berstel, J. </author> <title> Transductions and Context-Free Languages, first ed. </title> <publisher> Studienbucher Informatik. Teubner Verlag, Stuttgart, </publisher> <year> 1979. </year>
Reference-contexts: not do so in the case of that, if the homomorphism is simple in the sense of [21], one can conclude that relative liveness properties that hold on the abstract system also hold on the concrete system. 3 Preliminaries For defining our concepts, we need several notions from language theory <ref> [5, 7, 11, 24] </ref>. Let L fl be a language and let L ! ! be an !-language. Definition 3.1 The left quotient of L by a word w 2 fl is defined by cont (w; L) = fv 2 fl j wv 2 Lg.
Reference: [6] <author> Capellmann, C., Demant, R., Fatahi-Vanani, F., Galvez-Estrada, R., Nitsche, U., and Ochsen-schl ager, P. </author> <title> Verification by behavior abstraction: A case study of service interaction detection in intelligent telephone networks. </title> <booktitle> In Computer Aided Verification (CAV) '96 (New Brunswick, 1996), vol. 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 466-469. </pages>
Reference-contexts: Therefore, regarding the results of this paper, we can check relative liveness properties of specifications without an exhaustive construction of their state-spaces. An application of abstraction techniques to the detection of undesired feature interactions in intelligent networks can be found in <ref> [6] </ref>. Relative liveness properties reveal a satisfaction relation for properties that informally says: "almost all computations satisfy the property." In this sense, they appear to be close to properties that are probabilistically true [26, 27].
Reference: [7] <author> Eilenberg, S. </author> <title> Automata, </title> <journal> Languages and Machines, </journal> <volume> vol. </volume> <editor> A. </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: not do so in the case of that, if the homomorphism is simple in the sense of [21], one can conclude that relative liveness properties that hold on the abstract system also hold on the concrete system. 3 Preliminaries For defining our concepts, we need several notions from language theory <ref> [5, 7, 11, 24] </ref>. Let L fl be a language and let L ! ! be an !-language. Definition 3.1 The left quotient of L by a word w 2 fl is defined by cont (w; L) = fv 2 fl j wv 2 Lg. <p> Because L ! " lim (pre (L ! )) = L ! , we finally obtain L ! P. 2 3 As shown in [12], relative liveness and safety properties also have an elegant definition within the Cantor topology, i.e. the topological space over ! compatible with the following metric <ref> [7] </ref>. (For topological notions see [14].) Definition 4.8 Let common (x; y) designate the longest common prefix of two !-words x and y in ! .
Reference: [8] <author> Emerson, E. A. </author> <title> Temporal and modal logic. </title> <booktitle> In van Leeuwen [25], </booktitle> <pages> pp. 995-1072. </pages>
Reference-contexts: Here we make a different use of the concept and view it as an abstraction of a liveness property being true under fairness. In fact, we interpret relative liveness as a satisfaction relation for properties represented by temporal logic formulas <ref> [8, 23] </ref>. Notice that for a property to be a relative liveness property of a system does correspond, in the desired abstract sense, to the property being satisfied under fairness. <p> The initial state is shaded grey, a convention we will also use in subsequent state diagrams. From Figure 2, it is easy to see that our system does not satisfy the propositional linear time temporal logic <ref> [8, 23] </ref> property 23 (result). Indeed, lock (requestnoreject) ! is a computation of the system that does not satisfy 23 (result). Nevertheless, it is clear that what is missing for the property 23 (result) to be true is a fairness hypothesis on the system executions. <p> The notation x (n:::) , n 2 IN , represents the suffix x n x n+1 x n+2 : : : of an !-word x 2 ! starting with the n th letter of x. To describe properties, we use propositional linear temporal logic (PLTL) <ref> [8, 23] </ref>. PLTL-formulas are defined with respect to a set AP of atomic propositions. All atomic propositions and the proposition true are PLTL-formulas. If ~ and are PLTL-formulas, then so are :(~), (~) ^ (), e (~) and (~) U ().
Reference: [9] <author> Francez, N. </author> <title> Fairness, first ed. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction To be able to verify liveness properties of a system [3], it is almost always necessary to include a fairness hypothesis in the system description <ref> [9] </ref>. Indeed, introducing a fairness hypothesis makes it possible to ignore behaviors that correspond to extreme execution scenarios and that, in any case, would not occur in any reasonable implementation.
Reference: [10] <author> Garey, M. R., and Johnson, D. S. </author> <title> Computers and Intractability. A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Co., </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Proof The characterizations given by Lemma 4.3 and Lemma 4.4 reduce the problem to questions decidable in PSPACE <ref> [24, 10] </ref> (notice that for PLTL formulas one can build in PSPACE an automaton for the formula and for its complement [28]). Hardness can be established by a reduction from regular language inclusion [10]. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure. <p> Hardness can be established by a reduction from regular language inclusion <ref> [10] </ref>. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure. Indeed, recall the following definition [1, 2, 4].
Reference: [11] <author> Harrison, M. A. </author> <title> Introduction to Formal Language Theory, first ed. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1978. </year>
Reference-contexts: not do so in the case of that, if the homomorphism is simple in the sense of [21], one can conclude that relative liveness properties that hold on the abstract system also hold on the concrete system. 3 Preliminaries For defining our concepts, we need several notions from language theory <ref> [5, 7, 11, 24] </ref>. Let L fl be a language and let L ! ! be an !-language. Definition 3.1 The left quotient of L by a word w 2 fl is defined by cont (w; L) = fv 2 fl j wv 2 Lg.
Reference: [12] <author> Henzinger, T. A. </author> <note> Sooner is safer than later. Information Processing Letters 43 (1992), 135-141. </note>
Reference-contexts: Their definition is a relativized version of the definition of liveness: every prefix of a behavior of the system can be extended to an infinite behavior that satisfies the property. This concept and the dual notion of relative safety property were introduced in <ref> [12] </ref> as a means of clarifying the shift from liveness to safety when timing constraints are introduced in a system. It can also be traced to the notion of machine-closed property [1, 2, 4]. <p> Because L ! " lim (pre (L ! )) = L ! , we finally obtain L ! P. 2 3 As shown in <ref> [12] </ref>, relative liveness and safety properties also have an elegant definition within the Cantor topology, i.e. the topological space over ! compatible with the following metric [7]. (For topological notions see [14].) Definition 4.8 Let common (x; y) designate the longest common prefix of two !-words x and y in !
Reference: [13] <author> Hoogeboom, H., and Rozenberg, G. </author> <title> Infinitary languages: Basic theory and applications to concurrent systems. </title> <booktitle> In Current Trends in Concurrency (1986), </booktitle> <editor> J. de Bakker, W.-P. de Roever, and G. Rozenberg, Eds., </editor> <volume> vol. </volume> <booktitle> 224 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 266-342. </pages>
Reference: [14] <author> Kelley, J. L. </author> <title> General Topology. </title> <publisher> Van Nostrand, Princeton, </publisher> <year> 1955. </year>
Reference-contexts: (pre (L ! )) = L ! , we finally obtain L ! P. 2 3 As shown in [12], relative liveness and safety properties also have an elegant definition within the Cantor topology, i.e. the topological space over ! compatible with the following metric [7]. (For topological notions see <ref> [14] </ref>.) Definition 4.8 Let common (x; y) designate the longest common prefix of two !-words x and y in ! .
Reference: [15] <author> Manna, Z., and Pnueli, A. </author> <title> The Temporal Logic of Reactive and Concurrent Systems|Specification, first ed. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Even though this intuition is clear, making fairness precise is somewhat more complicated: should one be "weakly" or "strongly" fair, "transition" or "process" fair, or isn't "justice" or even "compassion" what fairness should really be <ref> [15] </ref>? Of course, there is a rational way of choosing which fairness notion is adequate for a given problem by considering the nature of the model being used and making reason fl Ulrich Nitsche was supported by a DAAD-fellowship HSP II/AUFE to visit the University of Liege.
Reference: [16] <author> Nitsche, U. </author> <title> Verification of Co-Operating Systems and Behaviour Abstraction. </title> <type> PhD thesis, </type> <institution> University of Frankfurt, Germany. </institution> <note> handed in 1996. </note>
Reference-contexts: In this paper, we show that the concept of being a relative liveness property is a suitable abstraction of truth under fairness that lends itself easily to verification in the context of abstraction by using the techniques of <ref> [16, 20, 21, 22] </ref>. Relative liveness properties are liveness properties within the universe of behaviors of the system. Their definition is a relativized version of the definition of liveness: every prefix of a behavior of the system can be extended to an infinite behavior that satisfies the property. <p> We can now give a statement relating a property true on an abstraction of a system to a property true at the concrete level <ref> [17, 16] </ref> Lemma 7.5 Let L ! 0! , let be a PLTL-formula in 0 -normal form, and let h : 1 ! 01 be an abstracting homomorphism. <p> We can show that, to each !-word x 0 2 lim (h (L)), there exists a sequence (u n ) n2IN of words in L such that (u n ) n2IN generates an !-word x in lim (L) and h (x) = x 0 <ref> [16] </ref>. 2 Using Lemma 8.1, we can now prove our result relating a relative liveness property of lim (h (L)) to a relative liveness property of lim (L).
Reference: [17] <author> Nitsche, U. </author> <title> Propositional linear temporal logic and language homomorphisms. </title> <booktitle> In Logical Foundations of Computer Science '94, St. Petersburg (1994), </booktitle> <editor> A. Nerode and Y. V. Matiyasevich, Eds., </editor> <volume> vol. </volume> <booktitle> 813 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 265-277. </pages>
Reference-contexts: We can now give a statement relating a property true on an abstraction of a system to a property true at the concrete level <ref> [17, 16] </ref> Lemma 7.5 Let L ! 0! , let be a PLTL-formula in 0 -normal form, and let h : 1 ! 01 be an abstracting homomorphism.
Reference: [18] <author> Nitsche, U. </author> <title> A verification method based on homomorphic model abstraction. </title> <booktitle> In Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing (Los Angeles, 1994), </booktitle> <publisher> ACM Press, </publisher> <address> p. </address> <month> 393. </month>
Reference-contexts: One major advantage of relative liveness properties is that they can be verified using behavior abstraction under simple homomor-phisms as is shown in Theorem 8.2. A related result for the 8293-fragment of CTL fl appears in <ref> [18, 19] </ref>. Additionally, a recent result [20] shows that simplicity of homomorphisms is also a necessary condition for the preservation of relative liveness properties under abstraction.
Reference: [19] <author> Nitsche, U. </author> <title> Verification and behavior abstraction - towards a tractable verification technique for large distributed systems. </title> <journal> Journal of Systems and Software 33, </journal> <month> 3 (June </month> <year> 1996), </year> <pages> 273-285. </pages>
Reference-contexts: One major advantage of relative liveness properties is that they can be verified using behavior abstraction under simple homomor-phisms as is shown in Theorem 8.2. A related result for the 8293-fragment of CTL fl appears in <ref> [18, 19] </ref>. Additionally, a recent result [20] shows that simplicity of homomorphisms is also a necessary condition for the preservation of relative liveness properties under abstraction.
Reference: [20] <author> Nitsche, U., and Ochsenschl ager, P. </author> <title> Approximately satisfied properties of systems and simple language homomorphisms. </title> <booktitle> Information Processing Letters 60 (1996), </booktitle> <pages> 201-206. </pages>
Reference-contexts: In this paper, we show that the concept of being a relative liveness property is a suitable abstraction of truth under fairness that lends itself easily to verification in the context of abstraction by using the techniques of <ref> [16, 20, 21, 22] </ref>. Relative liveness properties are liveness properties within the universe of behaviors of the system. Their definition is a relativized version of the definition of liveness: every prefix of a behavior of the system can be extended to an infinite behavior that satisfies the property. <p> Then lim (h (L)); 0 j= RL if and only if lim (L); h 0 j= RL R (): Proof This corollary is a summary of Theorem 8.2 and Theorem 8.3. 2 If h (L) contains maximal words, we have to extend them by f#g fl as presented in <ref> [20] </ref>, to keep maximal words "visible" when considering lim (h (L)). 9 Conclusion We have introduced relative liveness properties as an abstraction of properties true under fairness. <p> One major advantage of relative liveness properties is that they can be verified using behavior abstraction under simple homomor-phisms as is shown in Theorem 8.2. A related result for the 8293-fragment of CTL fl appears in [18, 19]. Additionally, a recent result <ref> [20] </ref> shows that simplicity of homomorphisms is also a necessary condition for the preservation of relative liveness properties under abstraction.
Reference: [21] <author> Ochsenschl ager, P. </author> <title> Verification of cooperating systems by simple homomorphisms using the product net machine. In Workshop: Algorithmen und Werkzeuge fur Petrinetze (1994), </title> <editor> J. Desel, A. Oberweis, and W. Reisig, Eds., </editor> <address> Humboldt Universitat Berlin, </address> <pages> pp. 48-53. </pages>
Reference-contexts: In this paper, we show that the concept of being a relative liveness property is a suitable abstraction of truth under fairness that lends itself easily to verification in the context of abstraction by using the techniques of <ref> [16, 20, 21, 22] </ref>. Relative liveness properties are liveness properties within the universe of behaviors of the system. Their definition is a relativized version of the definition of liveness: every prefix of a behavior of the system can be extended to an infinite behavior that satisfies the property. <p> Precisely, we consider abstractions defined by language homomorphisms in the context of systems described by !-languages. We prove that whether a property is a relative liveness property can be reliably checked on the abstract system, provided that the homomorphism is simple in the sense of <ref> [21] </ref>. <p> What distinguishes the two abstractions is the nature of the homomorphism. In the case of Figure 2 the homomorphism preserves relative liveness properties, whereas it does not do so in the case of that, if the homomorphism is simple in the sense of <ref> [21] </ref>, one can conclude that relative liveness properties that hold on the abstract system also hold on the concrete system. 3 Preliminaries For defining our concepts, we need several notions from language theory [5, 7, 11, 24]. <p> However, this is stronger than needed. Indeed, since we are dealing with relative liveness properties, it is sufficient that the behaviors in cont (h (w); h (L)) "eventually" become behaviors in h (cont (w; L)). This condition is the one called simplicity of an abstraction homomorphism in <ref> [21] </ref>. Its exact definition is the following. <p> The ho momorphism h is simple for L if and only if it is simple for L and all words w 2 L. Theorem 8.2 will show that this definition indeed meets all the requirements we have informally described above. More details about simple homomorphisms can be found in <ref> [21] </ref>. 7 Preservation of Linear Properties Before turning to the preservation of relative liveness properties under simple homomorphisms, we need some general results about abstraction homomorphisms and properties. The problem we address is that the properties true of the abstracted system and of the concrete system can rarely be identical.
Reference: [22] <author> Ochsenschl ager, P. </author> <title> Compositional verification of cooperating systems using simple homomorphisms. In Workshop: Algorithmen und Werkzeuge fur Petrinetze (1995), </title> <editor> J. Desel, H. Fleischhack, A. Oberweis, and M. Sonnenschein, Eds., </editor> <booktitle> Universitat Oldenburg, </booktitle> <pages> pp. 8-13. </pages>
Reference-contexts: In this paper, we show that the concept of being a relative liveness property is a suitable abstraction of truth under fairness that lends itself easily to verification in the context of abstraction by using the techniques of <ref> [16, 20, 21, 22] </ref>. Relative liveness properties are liveness properties within the universe of behaviors of the system. Their definition is a relativized version of the definition of liveness: every prefix of a behavior of the system can be extended to an infinite behavior that satisfies the property. <p> For practical purposes, it is essential to be able to obtain a representation of the abstract behavior of a system without an exhaustive construction of the finite-state system generating the original behavior. A compositional analysis 6 technique <ref> [22] </ref> makes it possible to compute the finite-state representation of the abstract behavior by a partial state-space exploration. Therefore, regarding the results of this paper, we can check relative liveness properties of specifications without an exhaustive construction of their state-spaces.
Reference: [23] <author> Pnueli, A. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the 18th Annual IEEE Symposium on Foundations of Computer Science (1977), </booktitle> <pages> pp. 46-57. </pages>
Reference-contexts: Here we make a different use of the concept and view it as an abstraction of a liveness property being true under fairness. In fact, we interpret relative liveness as a satisfaction relation for properties represented by temporal logic formulas <ref> [8, 23] </ref>. Notice that for a property to be a relative liveness property of a system does correspond, in the desired abstract sense, to the property being satisfied under fairness. <p> The initial state is shaded grey, a convention we will also use in subsequent state diagrams. From Figure 2, it is easy to see that our system does not satisfy the propositional linear time temporal logic <ref> [8, 23] </ref> property 23 (result). Indeed, lock (requestnoreject) ! is a computation of the system that does not satisfy 23 (result). Nevertheless, it is clear that what is missing for the property 23 (result) to be true is a fairness hypothesis on the system executions. <p> The notation x (n:::) , n 2 IN , represents the suffix x n x n+1 x n+2 : : : of an !-word x 2 ! starting with the n th letter of x. To describe properties, we use propositional linear temporal logic (PLTL) <ref> [8, 23] </ref>. PLTL-formulas are defined with respect to a set AP of atomic propositions. All atomic propositions and the proposition true are PLTL-formulas. If ~ and are PLTL-formulas, then so are :(~), (~) ^ (), e (~) and (~) U ().
Reference: [24] <author> Thomas, W. </author> <title> Automata on infinite objects. </title> <booktitle> In van Leeuwen [25], </booktitle> <pages> pp. 133-191. </pages> <editor> [25] van Leeuwen, J., Ed. </editor> <booktitle> Formal Models and Semantics (1990), vol. B of Handbook of Theoretical Computer Science, </booktitle> <publisher> Elsevier. </publisher>
Reference-contexts: not do so in the case of that, if the homomorphism is simple in the sense of [21], one can conclude that relative liveness properties that hold on the abstract system also hold on the concrete system. 3 Preliminaries For defining our concepts, we need several notions from language theory <ref> [5, 7, 11, 24] </ref>. Let L fl be a language and let L ! ! be an !-language. Definition 3.1 The left quotient of L by a word w 2 fl is defined by cont (w; L) = fv 2 fl j wv 2 Lg. <p> Proof The characterizations given by Lemma 4.3 and Lemma 4.4 reduce the problem to questions decidable in PSPACE <ref> [24, 10] </ref> (notice that for PLTL formulas one can build in PSPACE an automaton for the formula and for its complement [28]). Hardness can be established by a reduction from regular language inclusion [10]. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure.
Reference: [26] <author> Vardi, M. Y. </author> <title> Automatic verification of probabilistic concurrent finite-state programs. </title> <booktitle> In Proceedings of the 26th IEEE Symposium on Foundations of Computer Science (Portland, </booktitle> <month> October </month> <year> 1985), </year> <pages> pp. 327-338. 7 </pages>
Reference-contexts: Relative liveness properties reveal a satisfaction relation for properties that informally says: "almost all computations satisfy the property." In this sense, they appear to be close to properties that are probabilistically true <ref> [26, 27] </ref>. It would be an interesting topic for further study to investigate the exact link between relative liveness and probabilistic verification.
Reference: [27] <author> Vardi, M. Y., and Wolper, P. </author> <title> An automata--theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the 1st Symposium on Logic in Computer Science (Cambridge, </booktitle> <month> June </month> <year> 1986). </year>
Reference-contexts: Relative liveness properties reveal a satisfaction relation for properties that informally says: "almost all computations satisfy the property." In this sense, they appear to be close to properties that are probabilistically true <ref> [26, 27] </ref>. It would be an interesting topic for further study to investigate the exact link between relative liveness and probabilistic verification.
Reference: [28] <author> Vardi, M. Y., and Wolper, P. </author> <title> Reasoning about infinite computations. </title> <booktitle> Information and Computation 115, </booktitle> <month> 1 (November </month> <year> 1994), </year> <pages> 1-37. 8 </pages>
Reference-contexts: Proof The characterizations given by Lemma 4.3 and Lemma 4.4 reduce the problem to questions decidable in PSPACE [24, 10] (notice that for PLTL formulas one can build in PSPACE an automaton for the formula and for its complement <ref> [28] </ref>). Hardness can be established by a reduction from regular language inclusion [10]. 2 Note that Lemma 4.3 provides the link between relative liveness and machine closure. Indeed, recall the following definition [1, 2, 4].
References-found: 27

