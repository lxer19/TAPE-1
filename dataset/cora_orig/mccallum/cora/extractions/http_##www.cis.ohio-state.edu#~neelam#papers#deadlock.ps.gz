URL: http://www.cis.ohio-state.edu/~neelam/papers/deadlock.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: Email: lai, neelam@cis.ohio-state.edu  
Title: A Wait-Free Probe Algorithm for Distributed Deadlock Detection and Resolution  
Author: Young Man Kim, Ten H. Lai, Neelam Soundararajan 
Keyword: Index Terms Deadlock detection and resolution, distributed algorithm, correctness proof.  
Date: January 25, 1997  
Address: 2015 Neil Avenue Mall  Columbus, Ohio 43210-1277  
Affiliation: Department of Computer and Information Science  Ohio State University  
Abstract: Edge-chasing is the basis of many deadlock detection algorithms. This method detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. Once a deadlock is detected, a special message called token is sent to clean up those probes in the deadlock cycle which, if not removed, may later lead to phantom deadlock detections. Only after the token has traversed the entire deadlock cycle and returned to its initiator, the deadlock is resolved by aborting a so-called victim in the deadlock cycle. In a deadlock, all involved transactions are held waiting and all involved resources are locked up. It is thus desirable to resolve a deadlock as soon as it is detected, without waiting for the token message to go around the deadlock cycle. This paper proposes an algorithm that achieves this and thereby reduces the average deadlock persistence time by as much as two thirds. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.M. Chandy and J. Misra, </author> <title> "A distributed algorithm for detecting resource deadlocks in distributed systems," </title> <booktitle> Proc. Symp. on Principles of Distributed Computing, </booktitle> <month> Aug. </month> <year> 1982, </year> <pages> pp. 157-164. </pages>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., [1, 2, 3, 9, 13, 14, 15, 17, 19]). Originally proposed by Chandy, Misra and Hass <ref> [1, 2] </ref>, an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. Sinha and Natarajan [19] proposed the use of priorities to reduce the number of probe messages. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected.
Reference: [2] <author> K.M. Chandy, J. Misra, and L.M. Haas, </author> <title> "Distributed Deadlock Detection," </title> <journal> ACM Trans. on Computer Systems, </journal> <month> May </month> <year> 1983, </year> <pages> pp. 144-156. </pages>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., [1, 2, 3, 9, 13, 14, 15, 17, 19]). Originally proposed by Chandy, Misra and Hass <ref> [1, 2] </ref>, an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. Sinha and Natarajan [19] proposed the use of priorities to reduce the number of probe messages. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected.
Reference: [3] <author> A.N. Choudhary, W.H. Kohler, J.A. Stankovic, and D. Towsley, </author> <title> "A Modified Priority Based Probe Algorithm for Distributed Deadlock Detection and Resolution," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 15, No. 1, </volume> <month> Jan. </month> <year> 1989, </year> <month> pp.10-17. </month>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> They presented a basic algorithm for deadlock detection and resolution for the single-request model and an extended version for the multiple-request model. These algorithms were not implemented, nor was their correctness formally established. Choudhary et. al. <ref> [3] </ref> pointed out some errors in the basic algorithm of [19], and they proposed some modifications for correction. The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. <p> Choudhary et. al. <ref> [3] </ref> pointed out some errors in the basic algorithm of [19], and they proposed some modifications for correction. The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. Kshemkalyani and Singhal [9] proposed some modifications to this algorithm, and offered a correctness proof. These algorithms [3, 9, 19] all include a scheme for deadlock resolution. <p> The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. Kshemkalyani and Singhal [9] proposed some modifications to this algorithm, and offered a correctness proof. These algorithms <ref> [3, 9, 19] </ref> all include a scheme for deadlock resolution. After a deadlock is detected, a special message called token is sent to visit every node in the detected deadlock. <p> Only after the token has traversed the entire deadlock cycle and returned to its initiator, the deadlock is resolved by aborting a so-called victim in the deadlock cycle. The simulation study of <ref> [3] </ref> observed an average deadlock size of ten. The need to wait for a token to traverse a detected deadlock cycle considerably prolongs the average deadlock persistence time (i.e., the time from the formation of a deadlock to its resolution) and increases the average response time of a request. <p> When 2 the holder of a data item unlocks the data item (with a data-release message to the data manager), the data manager grants a request in the waiting queue (by sending a data-grant message to the transaction of that request). As in <ref> [3, 9] </ref>, a data item can be locked by at most one transaction. A transaction can be in one of two states: active or wait. Once a transaction sends a lock request to a data manager, it enters the wait state. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected. <p> Once a deadlock is detected, a widely used method for resolving the deadlock is to abort some process involved in the deadlock. In the above example, suppose d is the victim to be aborted. In previous algorithms <ref> [3, 9, 19] </ref>, before d gets aborted, it has to send a special message called token to visit every node in the detected deadlock. Only after the token returns back to d, the process gets aborted. <p> Then, for our algorithm, DT = 0:5L, RT = 0, and DP T = 0:5L. For previous algorithms <ref> [3, 9, 19] </ref>, DT = 0:5L, RT = L, and DP T = 1:5L.
Reference: [4] <author> A.N. Choudhary, W.H. Kohler, J.A. Stankovic, and D. Towsley, </author> <title> "Correction to `A Modified Priority Based Probe Algorithm for Distributed Deadlock Detection and Resolution'," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 15, No. 12, </volume> <month> Dec. </month> <year> 1989, </year> <note> p. 1644. </note>
Reference-contexts: Choudhary et. al. [3] pointed out some errors in the basic algorithm of [19], and they proposed some modifications for correction. The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode <ref> [4, 16] </ref>. Kshemkalyani and Singhal [9] proposed some modifications to this algorithm, and offered a correctness proof. These algorithms [3, 9, 19] all include a scheme for deadlock resolution. After a deadlock is detected, a special message called token is sent to visit every node in the detected deadlock.
Reference: [5] <author> A.K. Elmagarmid, N. Soundararajan, and M.T. Liu, </author> <title> "A Distributed Deadlock Detection and Resolution Algorithm and Its Correctness," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 14, No. 10, </volume> <month> Oct. </month> <year> 1988, </year> <pages> pp. 1443-1452. </pages>
Reference-contexts: However, a proof of correctness is a must, in view that so many published distributed algorithms without a correctness proof turn out incorrect, as has been observed in [8, 18]. Elmagarmid et. al. <ref> [5] </ref> have employed a CSP axiomatic proof system [20] to prove the correctness of their algorithm. This approach is very formal, but apt to become tedious. In this paper, we adopt the assertional proof style of [10].
Reference: [6] <author> K.P. Eswaran, J.N. Gray, R.A. Lorie, </author> <title> and I.L. Traiger, "The Notion of Consistancy and Predicate Locks in a Database System," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 19, </volume> <month> Nov. </month> <year> 1976, </year> <pages> pp. 624-633. </pages>
Reference-contexts: It is not necessary for a data manager to manage only one data item. However, for ease of understanding the algorithm, we assume a one-one correspondence between data managers and data items. Transactions use the two-phase locking protocol <ref> [6] </ref> to access data items. To lock a data item, a transaction sends a data-lock request to the manager of that data item. A data manager honors a request if the data item is free (not locked by any other transaction); otherwise it places the request in a queue.
Reference: [7] <author> S.-T. Huang, </author> <title> "A distributed deadlock detection algorithm for CSP-like Communication," </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 12, No. 1, </volume> <month> Jan. </month> <year> 1990, </year> <month> pp.102-122. </month>
Reference: [8] <author> E. Knapp, </author> <title> "Deadlock Detection in Distributed Database Systems," </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 19, No. 4, </volume> <month> Dec. </month> <year> 1987, </year> <pages> pp. 303-327. </pages>
Reference-contexts: 1 Introduction Deadlock detection is an important problem in distributed database systems, and many solutions have been proposed in the research community <ref> [8, 18] </ref>. Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., [1, 2, 3, 9, 13, 14, 15, 17, 19]). <p> However, a proof of correctness is a must, in view that so many published distributed algorithms without a correctness proof turn out incorrect, as has been observed in <ref> [8, 18] </ref>. Elmagarmid et. al. [5] have employed a CSP axiomatic proof system [20] to prove the correctness of their algorithm. This approach is very formal, but apt to become tedious. In this paper, we adopt the assertional proof style of [10].
Reference: [9] <author> A.D. Kshemkalyani and M. Singhal, </author> <title> "Invariant-Based Verification of a Distributed Deadlock Detection Algorithm," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 17, No. 8, </volume> <month> August </month> <year> 1991, </year> <pages> 789-799. </pages>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. Kshemkalyani and Singhal <ref> [9] </ref> proposed some modifications to this algorithm, and offered a correctness proof. These algorithms [3, 9, 19] all include a scheme for deadlock resolution. After a deadlock is detected, a special message called token is sent to visit every node in the detected deadlock. <p> The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. Kshemkalyani and Singhal [9] proposed some modifications to this algorithm, and offered a correctness proof. These algorithms <ref> [3, 9, 19] </ref> all include a scheme for deadlock resolution. After a deadlock is detected, a special message called token is sent to visit every node in the detected deadlock. <p> This approach is very formal, but apt to become tedious. In this paper, we adopt the assertional proof style of [10]. It is about the same level of rigorousness as the correctness proof of <ref> [9] </ref>. This paper is organized as follows. Section 2 describes a distributed database system and an abstract model of it. <p> When 2 the holder of a data item unlocks the data item (with a data-release message to the data manager), the data manager grants a request in the waiting queue (by sending a data-grant message to the transaction of that request). As in <ref> [3, 9] </ref>, a data item can be locked by at most one transaction. A transaction can be in one of two states: active or wait. Once a transaction sends a lock request to a data manager, it enters the wait state. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected. <p> Once a deadlock is detected, a widely used method for resolving the deadlock is to abort some process involved in the deadlock. In the above example, suppose d is the victim to be aborted. In previous algorithms <ref> [3, 9, 19] </ref>, before d gets aborted, it has to send a special message called token to visit every node in the detected deadlock. Only after the token returns back to d, the process gets aborted. <p> Then, for our algorithm, DT = 0:5L, RT = 0, and DP T = 0:5L. For previous algorithms <ref> [3, 9, 19] </ref>, DT = 0:5L, RT = L, and DP T = 1:5L.
Reference: [10] <author> L. Lamport, </author> <title> "An Assertional Correctness Proof of a Distributed Algorithm," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 2, </volume> <year> 1982, </year> <pages> pp. 175-206. </pages>
Reference-contexts: Elmagarmid et. al. [5] have employed a CSP axiomatic proof system [20] to prove the correctness of their algorithm. This approach is very formal, but apt to become tedious. In this paper, we adopt the assertional proof style of <ref> [10] </ref>. It is about the same level of rigorousness as the correctness proof of [9]. This paper is organized as follows. Section 2 describes a distributed database system and an abstract model of it.
Reference: [11] <author> L. Lamport, </author> <title> "A theorem on atomicity in distributed algorithms," </title> <journal> Distributed Computing, </journal> <volume> vol. 4, </volume> <pages> pp. 59-68, </pages> <year> 1990. </year>
Reference-contexts: We prove the correctness of our algorithm by establishing its safety and progress properties as defined in Definition 2; our algorithm obviously has the resolution property. As in <ref> [11] </ref>, we adopt the common approach of defining an execution of a concurrent algorithm to be a sequence of atomic actions in which concurrent actions of separate processes are assumed to be interleaved in an arbitrary manner.
Reference: [12] <author> D.E. Menasce and R.R. Muntz, </author> <title> "Locking and Deadlock Detection in Distributed Databases," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 5, No. 3, </volume> <month> May </month> <year> 1979, </year> <pages> pp. 195-202. </pages>
Reference: [13] <author> D.P. Mitchell and M.J. Merritt, </author> <title> "A distributed algorithm for deadlock detection and resolution," </title> <booktitle> Proc. of the ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1984, </year> <pages> pp. 282-284. 33 </pages>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected.
Reference: [14] <author> M. Roesler and W.A. Burkhard, </author> <title> "Resolution of Deadlocks in Object-Oriented Distributed Systems," </title> <journal> IEEE Trans. Computers, </journal> <volume> Vol. 38, No. 8, </volume> <month> Aug. </month> <year> 1989, </year> <pages> pp. 1212-1224. </pages>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> It is desirable to resolve the deadlock as soon as it is detected, and not to stay idle and wait for a token message to go around the deadlock cycle. The algorithm in <ref> [14] </ref> achieves immediate abortion by allowing phantom deadlock detection and thus unnecessary abortion of victims. (The main contribution of [14] is however not in achieving 1 immediate abortion, but in providing an efficient algorithm for the extended model where a node may have multiple outgoing edges.) In this paper, we propose <p> The algorithm in <ref> [14] </ref> achieves immediate abortion by allowing phantom deadlock detection and thus unnecessary abortion of victims. (The main contribution of [14] is however not in achieving 1 immediate abortion, but in providing an efficient algorithm for the extended model where a node may have multiple outgoing edges.) In this paper, we propose an edge-chasing algorithm that resolves a detected deadlock right away, without waiting for the token to return back to <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected.
Reference: [15] <author> B. Sanders and P.A. Heuberger, </author> <title> "A Distributed Deadlock Detection and Resolution with Probes," </title> <booktitle> proc. of 3rd Int. Workshop on Distributed Algorithms, </booktitle> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected.
Reference: [16] <author> K. Shafer and M. Singhal, </author> <title> "A Correct Priority-based Probe Algorithm for Distributed Deadlock Detection and Resolution and Proof of Its Correctness," </title> <type> Technical Report OSU-CISRC-4/89-TR16, </type> <institution> Computer and Information Science, Ohio State Univ., </institution> <year> 1989. </year>
Reference-contexts: Choudhary et. al. [3] pointed out some errors in the basic algorithm of [19], and they proposed some modifications for correction. The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode <ref> [4, 16] </ref>. Kshemkalyani and Singhal [9] proposed some modifications to this algorithm, and offered a correctness proof. These algorithms [3, 9, 19] all include a scheme for deadlock resolution. After a deadlock is detected, a special message called token is sent to visit every node in the detected deadlock.
Reference: [17] <author> B. Shyam and D.M. Dhamdhere, </author> <title> "A New Priority Based Probe Algorithm for Distributed Deadlock Detection," </title> <type> IIT Bombay Technical Report, </type> <year> 1990. </year>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected.
Reference: [18] <author> M. Singhal, </author> <title> "Deadlock Detection in Distributed Systems," </title> <booktitle> IEEE Computer, </booktitle> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Deadlock detection is an important problem in distributed database systems, and many solutions have been proposed in the research community <ref> [8, 18] </ref>. Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., [1, 2, 3, 9, 13, 14, 15, 17, 19]). <p> However, a proof of correctness is a must, in view that so many published distributed algorithms without a correctness proof turn out incorrect, as has been observed in <ref> [8, 18] </ref>. Elmagarmid et. al. [5] have employed a CSP axiomatic proof system [20] to prove the correctness of their algorithm. This approach is very formal, but apt to become tedious. In this paper, we adopt the assertional proof style of [10]. <p> becomes (0; 0; 0; 0; 0; 0), forcing deadlock (X) to become false; or deadlock (X) becomes false before M (P ) reduces to (0; 0; 0; 0; 0; 0). 2 5 Performance Our main concern of performance is the deadlock persistence time, DP T , which is defined in <ref> [18] </ref> as the period from the time a deadlock occurs to the time it is resolved. The shorter the DPT, the less the system degrades due to deadlocks. DP T consists of two components: the deadlock detection time (DT) and the deadlock resolution time (RT).
Reference: [19] <author> M.K. Sinha and N. Natarajan, </author> <title> "A priority based distributed deadlock detection algorithm," </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. 11, No. 1, </volume> <month> Jan. </month> <year> 1985, </year> <pages> pp. 67-80. </pages>
Reference-contexts: Schemes for deadlock detection could be centralized or distributed. One of the most popular methods for distributed deadlock detection is edge-chasing, which has been the basis of many deadlock detection algorithms (e.g., <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref>). Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. <p> Originally proposed by Chandy, Misra and Hass [1, 2], an edge-chasing algorithm detects a deadlock by propagating special messages called probes along dependency edges. When the initiator of a probe receives the probe back, it knows the existence of a deadlock. Sinha and Natarajan <ref> [19] </ref> proposed the use of priorities to reduce the number of probe messages. They presented a basic algorithm for deadlock detection and resolution for the single-request model and an extended version for the multiple-request model. These algorithms were not implemented, nor was their correctness formally established. <p> They presented a basic algorithm for deadlock detection and resolution for the single-request model and an extended version for the multiple-request model. These algorithms were not implemented, nor was their correctness formally established. Choudhary et. al. [3] pointed out some errors in the basic algorithm of <ref> [19] </ref>, and they proposed some modifications for correction. The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. <p> The resulting algorithm was actually implemented and extensively tested through simulation. However, when the algorithm was published in [3], one line was inadvertently omitted from the pseudocode [4, 16]. Kshemkalyani and Singhal [9] proposed some modifications to this algorithm, and offered a correctness proof. These algorithms <ref> [3, 9, 19] </ref> all include a scheme for deadlock resolution. After a deadlock is detected, a special message called token is sent to visit every node in the detected deadlock. <p> Safety Condition: If a process v claims to have detected a deadlock X, then deadlock (X) is true. Resolution Condition: Once a deadlock X is detected, a temporary process on the deadlock cycle takes some action to make deadlock (X) false. 2.4 Probe-Based Algorithms The probe-based or edge-chasing algorithms <ref> [1, 2, 3, 9, 13, 14, 15, 17, 19] </ref> for deadlock detection are based on a simple idea: each process creates a probe that propagates along dependency edges; should a probe return to its initiator, a deadlock is detected. <p> Once a deadlock is detected, a widely used method for resolving the deadlock is to abort some process involved in the deadlock. In the above example, suppose d is the victim to be aborted. In previous algorithms <ref> [3, 9, 19] </ref>, before d gets aborted, it has to send a special message called token to visit every node in the detected deadlock. Only after the token returns back to d, the process gets aborted. <p> If edge (v; w) is involved in a deadlock cycle, then probe p v will eventually return to v and the deadlock is detected. As in <ref> [19] </ref>, in order to reduce the number of probe messages, a probe p is propagated to a process x only if (the identifier) of x is larger than (that of) the initiator of p. With this scheme, many probes will 6 not be forwarded. <p> Then, for our algorithm, DT = 0:5L, RT = 0, and DP T = 0:5L. For previous algorithms <ref> [3, 9, 19] </ref>, DT = 0:5L, RT = L, and DP T = 1:5L.
Reference: [20] <author> N. Soundararajan, </author> <title> "Axiomatic semantics of CSP," </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 6, </volume> <year> 1984, </year> <pages> pp. 647-662. 34 </pages>
Reference-contexts: However, a proof of correctness is a must, in view that so many published distributed algorithms without a correctness proof turn out incorrect, as has been observed in [8, 18]. Elmagarmid et. al. [5] have employed a CSP axiomatic proof system <ref> [20] </ref> to prove the correctness of their algorithm. This approach is very formal, but apt to become tedious. In this paper, we adopt the assertional proof style of [10]. It is about the same level of rigorousness as the correctness proof of [9]. This paper is organized as follows.
References-found: 20

