URL: http://foxnet.cs.cmu.edu/papers/gc-tr.ps
Refering-URL: http://foxnet.cs.cmu.edu/papers.html
Root-URL: 
Title: Abstract Models of Memory Management  
Author: Greg Morrisett Matthias Felleisen Robert Harper 
Note: Also published as Fox Memorandum CMU-CS-FOX-95-01 This research was sponsored by the Defense Advanced Research Projects Agency, CSTO, under the title "The Fox Project: Advanced Development of Systems Software", ARPA Order No. 8313, issued by ESD/AVS under Contract No. F19628-91-C-0168. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: January 1995  
Pubnum: CMU-CS-95-110  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> S. Aditya and A. Caro. </author> <title> Compiler-directed type reconstruction for polymorphic languages. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 74-82, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Aditya and Caro gave a type-recovery algorithm for an implementation of Id that uses a technique that appears to be equivalent to type passing <ref> [1] </ref> and Aditya, Flood, and Hicks extended this work to garbage collection for Id [2]. There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages [3, 15, 16, 12].
Reference: [2] <author> S. Aditya, C. Flood, and J. Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 12-23, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. <p> Aditya and Caro gave a type-recovery algorithm for an implementation of Id that uses a technique that appears to be equivalent to type passing [1] and Aditya, Flood, and Hicks extended this work to garbage collection for Id <ref> [2] </ref>. There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages [3, 15, 16, 12].
Reference: [3] <author> A. W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: In Section 6, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still 1 reachable. While previous authors have sketched this idea <ref> [6, 3, 16, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well-known interpretation of types as logical relations into our framework. Section 7 discusses related work and Section 8 closes with a summary. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. <p> There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages <ref> [3, 15, 16, 12] </ref>. Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. <p> There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages [3, 15, 16, 12]. Appel <ref> [3] </ref> argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear.
Reference: [4] <author> Z. M. Ariola and M. Felleisen. </author> <title> The call-by-need lambda calculus. </title> <type> Technical Report CIS-TR-94-23, </type> <institution> University of Oregon, </institution> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Finally, Purushothaman and Seaman [28, 32] and Launchbury [21] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics. More recently, Ariola et al. [5] (see also <ref> [4, 22] </ref>) have presented a purely syntactic theory of the call-by-need -calculus that is largely compatible with our work. 8 Summary Our paper provides a unifying semantic framework for a variety of garbage collection ideas including standard copying and mark-sweep collection, generational collection, tag-free collection, and inference-based collection.
Reference: [5] <author> Z. M. Ariola, M. Felleisen, J. Maraist, M. Odersky, and P. Wadler. </author> <title> A call-by-need lambda calculus. </title> <booktitle> In Conference Record of the 22nd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Finally, Purushothaman and Seaman [28, 32] and Launchbury [21] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics. More recently, Ariola et al. <ref> [5] </ref> (see also [4, 22]) have presented a purely syntactic theory of the call-by-need -calculus that is largely compatible with our work. 8 Summary Our paper provides a unifying semantic framework for a variety of garbage collection ideas including standard copying and mark-sweep collection, generational collection, tag-free collection, and inference-based collection.
Reference: [6] <author> H. Baker. </author> <title> Unify and conquer (garbage, updating, aliasing ...) in functional languages. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 218-226, </pages> <year> 1990. </year>
Reference-contexts: In Section 6, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still 1 reachable. While previous authors have sketched this idea <ref> [6, 3, 16, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well-known interpretation of types as logical relations into our framework. Section 7 discusses related work and Section 8 closes with a summary. <p> Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. Baker <ref> [6] </ref> recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result.
Reference: [7] <author> P. Branquart and J. Lewi. </author> <title> A scheme for storage allocation and garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: To illustrate how to refine gc just enough to address this problem, we formalize so-called "tag-free" collection algorithms for explicitly-typed, monomorphic languages such as Pascal and Algol <ref> [7, 36, 8] </ref>. We show how to reconstruct necessary shape information about values from types during garbage collection. We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. <p> There have been a variety of papers regarding inference-based collection for monomorphic <ref> [7, 36, 8] </ref> and polymorphic languages [3, 15, 16, 12].
Reference: [8] <author> D. E. Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: To illustrate how to refine gc just enough to address this problem, we formalize so-called "tag-free" collection algorithms for explicitly-typed, monomorphic languages such as Pascal and Algol <ref> [7, 36, 8] </ref>. We show how to reconstruct necessary shape information about values from types during garbage collection. We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. <p> In this section, we present the basic idea behind type-recovery based garbage collection. In the following subsection, we give a simple overview of the techniques used to record and reconstruct the types of objects in collectors such as Britton's <ref> [8] </ref> and Tolmach's [34]. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. We show how to adapt the free-variable tracing algorithm to recover types of objects in the heap and to use these types in the 12 traversal of heap objects instead of abstract syntax. <p> There have been a variety of papers regarding inference-based collection for monomorphic <ref> [7, 36, 8] </ref> and polymorphic languages [3, 15, 16, 12].
Reference: [9] <author> J. Chirimar, C. A. Gunter, and J. G. Riecke. </author> <title> Proving memory management invariants for a language based on linear logic. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 139-150, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and Riecke give a framework for proving invariants regarding memory management for a language with a linear type system <ref> [9] </ref>. Their low-level semantics specifies explicit memory management based on reference counting. The goal of the work was to determine whether, using the linear type system, in-place update would be a sound optimization. Both Hudak and Chirimar et al. assume a fairly weak approximation of garbage (reference counts).
Reference: [10] <author> A. Demers, M. Weiser, B. Hayes, H. Boehm, D. Bobrow, and S. Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Demers et al. <ref> [10] </ref> give a model of memory parameterized by an abstract notion of a "points-to" relation. As a result, they can characterize reachability-based algorithms including mark-sweep, copying, generational, "conservative," and other sophisticated forms of garbage collection.
Reference: [11] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 89-100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <note> Also appears in: Theoretical Computer Science, 102, </note> <year> 1992. </year>
Reference-contexts: Indeed, since garbage collectors work on the machine representations of abstract values, the very idea of providing a proof of memory safety sounds unrealistic given the lack of simple models of memory operations. The recently developed syntactic approaches to the specification of language semantics by Felleisen and Hieb <ref> [11] </ref> and Mason and Talcott [23, 24] are the first execution models that are intensional enough to permit the specification of memory management actions and yet are sufficiently abstract to permit compact proofs of important properties. <p> We use X n X 0 to denote fx 2 X j x 62 X 0 g. Semantics: The rewriting semantics for gc is an adaptation of the standard reduction function of the v -S calculus <ref> [11] </ref>. Roughly speaking, this kind of semantics describes an abstract machine whose states are programs and whose instructions are relations between programs. The desired final state of this abstract machine is an answer program (A) whose body is a pointer to some value, such as an integer, in the heap. <p> All programs either diverge or evaluate to an answer or a stuck program. Put differently, the evaluation process defines a partial function from gc programs to canonical programs <ref> [11, 37] </ref>. Theorem 2.2 If P is a closed program, then there exists at most one P 0 such that P + R P 0 . Proof (sketch): The theorem relies on the following lemma which shows that at each evaluation step, the instruction expression is uniquely determined. <p> In Section 4.3 we specialize our algorithm to one that takes advantage of a generational partition and in Section 4.4, we show how generational collection works in the presence of assignment. 4.1 The Free-Variable Rule Following Felleisen and Hieb <ref> [11] </ref>, reachability in gc is formalized by considering free variables.
Reference: [12] <author> P. Fradet. </author> <title> Collecting more garbage. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 24-33, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In Section 6, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still 1 reachable. While previous authors have sketched this idea <ref> [6, 3, 16, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well-known interpretation of types as logical relations into our framework. Section 7 discusses related work and Section 8 closes with a summary. <p> There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages <ref> [3, 15, 16, 12] </ref>. Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. <p> They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet <ref> [12] </ref> gave another argument based on Reynolds' abstraction/parametricity theorem [29]. Fradet's formulation is closer to ours than Goldberg and Gloger's, since he represented the evaluation "stack" as a source-language term.
Reference: [13] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <booktitle> In Proceedings of the Second Scandinavian Logic Symposium, edited by J.E. Fenstad. </booktitle> <publisher> North-Holland, Amsterdam, </publisher> <pages> pages 63-92, </pages> <year> 1971. </year>
Reference-contexts: We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. We then sketch how the type-based garbage collection algorithms can be extended to a language with a polymorphic type system in the style of the Girard-Reynold's System F <ref> [13, 14, 30] </ref>. Our formulation leads to a fairly simple proof of the correctness of Tolmach's garbage collector for the Gallium ML compiler [34].
Reference: [14] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year> <month> 31 </month>
Reference-contexts: We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. We then sketch how the type-based garbage collection algorithms can be extended to a language with a polymorphic type system in the style of the Girard-Reynold's System F <ref> [13, 14, 30] </ref>. Our formulation leads to a fairly simple proof of the correctness of Tolmach's garbage collector for the Gallium ML compiler [34].
Reference: [15] <author> B. Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. <p> There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages <ref> [3, 15, 16, 12] </ref>. Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear.
Reference: [16] <author> B. Goldberg and M. Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In Section 6, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still 1 reachable. While previous authors have sketched this idea <ref> [6, 3, 16, 12] </ref>, we are the first to present a formal proof of this result. The proof is obtained by casting the well-known interpretation of types as logical relations into our framework. Section 7 discusses related work and Section 8 closes with a summary. <p> There have been a variety of papers regarding inference-based collection for monomorphic [7, 36, 8] and polymorphic languages <ref> [3, 15, 16, 12] </ref>. Appel [3] argued informally that "tag-free" collection is possible for polymorphic languages such as SML by a combination of recording information statically and performing what amounts to type inference during the collection process, though the connections between inference and collection were not made clear. <p> Baker [6] recognized that Milner-style type inference can be used to prove that reachable objects can be safely collected, but did not give a formal account of this result. Goldberg and Gloger <ref> [16] </ref> recognized that it is not possible to reconstruct the concrete types of all reachable values in an implementation of an ML-style language that does not pass types to polymorphic routines. They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage.
Reference: [17] <author> C. A. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: See Gunter <ref> [17, Chapter 4.4] </ref> for an example of the treatment of unwinding and approximation in the context of a conventional -calculus. 7 Related Work The literature on garbage collection in sequential programming languages per se contains few papers that attempt to provide a compact characterization of algorithms or correctness proofs.
Reference: [18] <author> R. Harper. </author> <title> A simplified account of polymorphic references. </title> <type> Technical Report CMU-CS-93-169, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: H : 0 (prog) ; . H : . e . letrec H in e given type t in 0 are bound to heap values in H of the appropriate type, under the assumptions in . The judgement's definition via the heap rule, similar to Harper's store typing <ref> [18] </ref> and the typing for Wright & Felleisen's Reference ML [37], requires "guessing" the types of the values in the heap and verifying these guesses simultaneously due to potential cycles. The third judgement, . P , asserts the well-typing of a complete program.
Reference: [19] <author> A. L. Hosking, J. E. B. Moss, and D. Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings OOPSLA '92, ACM SIGPLAN Notices, </booktitle> <pages> pages 92-109, </pages> <month> Oct. </month> <year> 1992. </year> <title> Published as Proceedings OOPSLA '92, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 27, number 10. </volume>
Reference-contexts: There are a variety of techniques for determining which values in the older generation must be moved to the younger generation. We refer the interested reader to Hosking et al. <ref> [19] </ref>. 5 Garbage Collection via Type Recovery The delimiters and other tokens of the abstract syntax mark or "tag" heap values with enough information that we can distinguish pairs from functions, pointers from integers, etc..
Reference: [20] <author> P. Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 351-363, </pages> <year> 1986. </year>
Reference-contexts: Like Demers et al., he uses a traditional definition of garbage based on unreachability in the memory graph and purposefully distances the specification from any language evaluation details. 29 Hudak gives a denotational model that tracks reference counts for a first-order language <ref> [20] </ref>. He presents an abstraction of the model and gives an algorithm for computing approximations of reference counts statically. Chirimar, Gunter, and Riecke give a framework for proving invariants regarding memory management for a language with a linear type system [9].
Reference: [21] <author> J. Launchbury. </author> <title> A natural semantics for lazy evaluation. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, SC, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: However, none of these papers gives a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc. Finally, Purushothaman and Seaman [28, 32] and Launchbury <ref> [21] </ref> have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics.
Reference: [22] <author> J. Maraist, M. Odersky, and P. Wadler. </author> <title> The call-by-need lambda calculus (unabridged). </title> <type> Technical Report 28/94, </type> <institution> Universitat Karlsruhe, Fakultat fur Informatik, </institution> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Finally, Purushothaman and Seaman [28, 32] and Launchbury [21] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics. More recently, Ariola et al. [5] (see also <ref> [4, 22] </ref>) have presented a purely syntactic theory of the call-by-need -calculus that is largely compatible with our work. 8 Summary Our paper provides a unifying semantic framework for a variety of garbage collection ideas including standard copying and mark-sweep collection, generational collection, tag-free collection, and inference-based collection.
Reference: [23] <author> I. Mason and C. Talcott. </author> <title> Reasoning about programs with effects. </title> <booktitle> In Proceedings of Programming Language Implementation and Logic Programming, </booktitle> <publisher> LNCS 582. Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The recently developed syntactic approaches to the specification of language semantics by Felleisen and Hieb [11] and Mason and Talcott <ref> [23, 24] </ref> are the first execution models that are intensional enough to permit the specification of memory management actions and yet are sufficiently abstract to permit compact proofs of important properties.
Reference: [24] <author> I. Mason and C. Talcott. </author> <title> Equivalences in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(1), </volume> <year> 1991. </year>
Reference-contexts: The recently developed syntactic approaches to the specification of language semantics by Felleisen and Hieb [11] and Mason and Talcott <ref> [23, 24] </ref> are the first execution models that are intensional enough to permit the specification of memory management actions and yet are sufficiently abstract to permit compact proofs of important properties.
Reference: [25] <author> J. C. Mitchell. </author> <title> Type systems for programming languages. </title> <type> Technical Report STAN-CS-89-1277, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1989. </year>
Reference-contexts: Now by applying the free-variable rule, we can conclude that the binding x 2 = 2 can be safely collected. In subsection 6.1, we introduce type inference for gc based on the presentation of Mitchell <ref> [25, Section 4.5] </ref>. In Section 6.2 we show that if type inference can assign a binding an unconstrained type and the rest of the program still has a valid typing, then the binding can effectively be collected. <p> Our proof of this theorem is based on the method of logical relations, a standard proof technique from type theory. (See Mitchell <ref> [25, Section 3] </ref> for an overview of logical relations and various references.) 6.1 gc and Type Inference We start by considering the original gc language as an implicitly typed, monomorphic language, where the types of the language are the same as for gc-mono except for the addition of type variables: (types)
Reference: [26] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 13(3) </volume> <pages> 342-371, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection.
Reference: [27] <author> S. Nettles. </author> <title> A Larch specification of copying garbage collection. </title> <type> Technical Report CMU-CS-92-219, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: However, their model is intentionally divorced from the programming language and cannot take advantage of any semantic properties of evaluation, such as type preservation. Consequently, their framework cannot easily model the type-based collectors of Sections 5 and 6. Nettles <ref> [27] </ref> provides a concrete specification of a copying garbage collection algorithm using the Larch specification language. Our specification of the free-variable tracing algorithm is essentially a high-level, one-line description of his specification.
Reference: [28] <author> Purushothaman and J. Seaman. </author> <title> An adequate operational semantics of sharing in lazy evaluation. </title> <booktitle> In Proceedings of the 4th European Symposium on Programming, </booktitle> <publisher> LNCS 582. Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: However, none of these papers gives a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc. Finally, Purushothaman and Seaman <ref> [28, 32] </ref> and Launchbury [21] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics.
Reference: [29] <author> J. Reynolds. </author> <title> Types, abstraction, and parametric polymorphism. </title> <booktitle> In Proceedings of Information Processing 83, </booktitle> <pages> pages 513-523, </pages> <year> 1983. </year>
Reference-contexts: They gave an informal argument based on traversal of stack frames to show that such values are semantically garbage. Fradet [12] gave another argument based on Reynolds' abstraction/parametricity theorem <ref> [29] </ref>. Fradet's formulation is closer to ours than Goldberg and Gloger's, since he represented the evaluation "stack" as a source-language term. However, none of these papers gives a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc.
Reference: [30] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation. Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. We then sketch how the type-based garbage collection algorithms can be extended to a language with a polymorphic type system in the style of the Girard-Reynold's System F <ref> [13, 14, 30] </ref>. Our formulation leads to a fairly simple proof of the correctness of Tolmach's garbage collector for the Gallium ML compiler [34].
Reference: [31] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12, </volume> <year> 1965. </year>
Reference-contexts: A unifier S of E is more general than S 1 if there exists a unifier S 2 such that S 1 = S 2 ffi S. Lemma 6.5 (Unification) <ref> [31] </ref> Let E be a set of type equations. There is an algorithm Unify (E) that computes a most general unifier of E if one exists and fails otherwise.
Reference: [32] <author> J. M. Seaman. </author> <title> An Operational Semantics of Lazy Evaluation for Analysis. </title> <type> PhD thesis, </type> <institution> Pennsylvania State University, </institution> <year> 1993. </year>
Reference-contexts: However, none of these papers gives a complete formulation of the underlying dynamic and static semantics of the language and thus the proofs of correctness are necessarily ad hoc. Finally, Purushothaman and Seaman <ref> [28, 32] </ref> and Launchbury [21] have proposed "natural" semantics for call-by-need (lazy) languages where the semantic objects include an explicit heap. This allows sharing and memoization of computations to be expressed in the semantics.
Reference: [33] <author> P. Steenkiste and J. Hennessey. </author> <title> Tags and type checking in LISP: Hardware and software approaches. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-II), </booktitle> <pages> pages 50-59, </pages> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: This allows us to navigate through the memory unambiguously, but placing tags on heap values and stripping them off to perform a computation can impose a heavy overhead on the running time and space requirements of programs <ref> [33] </ref>. An alternative to tagging is the use of types to determine the shape of an object. If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values.
Reference: [34] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1994. </year> <month> 32 </month>
Reference-contexts: Our formulation leads to a fairly simple proof of the correctness of Tolmach's garbage collector for the Gallium ML compiler <ref> [34] </ref>. In Section 6, we justify our semantic definition of garbage by showing that Milner-style type inference can be used to prove that an object is semantically garbage even though the object is still 1 reachable. <p> If types are determined at compile time and evaluation maintains enough information that the types of reachable objects can always be recovered, then there is no need to tag values. A number of researchers have made attempts to explore this alternative <ref> [7, 8, 3, 15, 26, 34, 2] </ref>, but none of them presented concise characterizations of the underlying techniques with correctness proofs. In this section, we present the basic idea behind type-recovery based garbage collection. <p> In this section, we present the basic idea behind type-recovery based garbage collection. In the following subsection, we give a simple overview of the techniques used to record and reconstruct the types of objects in collectors such as Britton's [8] and Tolmach's <ref> [34] </ref>. We then introduce gc-mono, an explicitly typed, monomorphic variant of gc. We show how to adapt the free-variable tracing algorithm to recover types of objects in the heap and to use these types in the 12 traversal of heap objects instead of abstract syntax. <p> Their low-level semantics specifies explicit memory management based on reference counting. The goal of the work was to determine whether, using the linear type system, in-place update would be a sound optimization. Both Hudak and Chirimar et al. assume a fairly weak approximation of garbage (reference counts). Tolmach <ref> [34] </ref> built a type-recovery collector for a variant of SML that passes type information to polymorphic routines during execution, effectively implementing our gc-poly language and the corresponding collector of Subsection 5.5.
Reference: [35] <author> D. Ungar. </author> <title> Generational scavenging: A non-disruptive high performance storage management reclama-tion algorithm. </title> <booktitle> In ACM SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 15-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984. </year>
Reference-contexts: Theorem 4.9 If P gen 7! P 0 , then P fv The third reason generational collection is important is that empirical evidence shows that "objects tend to die young" <ref> [35] </ref>. That is, recently allocated bindings are more likely to become garbage in a small number of evaluation steps.
Reference: [36] <author> P. Wodon. </author> <title> Methods of garbage collection for Algol-68. In Algol-68 Implementation. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1970. </year>
Reference-contexts: To illustrate how to refine gc just enough to address this problem, we formalize so-called "tag-free" collection algorithms for explicitly-typed, monomorphic languages such as Pascal and Algol <ref> [7, 36, 8] </ref>. We show how to reconstruct necessary shape information about values from types during garbage collection. We are able to prove the correctness of the garbage collection algorithm by using a well known type preservation argument. <p> There have been a variety of papers regarding inference-based collection for monomorphic <ref> [7, 36, 8] </ref> and polymorphic languages [3, 15, 16, 12].
Reference: [37] <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> Apr. </month> <year> 1991. </year> <month> 33 </month>
Reference-contexts: All programs either diverge or evaluate to an answer or a stuck program. Put differently, the evaluation process defines a partial function from gc programs to canonical programs <ref> [11, 37] </ref>. Theorem 2.2 If P is a closed program, then there exists at most one P 0 such that P + R P 0 . Proof (sketch): The theorem relies on the following lemma which shows that at each evaluation step, the instruction expression is uniquely determined. <p> The judgement's definition via the heap rule, similar to Harper's store typing [18] and the typing for Wright & Felleisen's Reference ML <ref> [37] </ref>, requires "guessing" the types of the values in the heap and verifying these guesses simultaneously due to potential cycles. The third judgement, . P , asserts the well-typing of a complete program. Figure 6 (Heaps and Programs) contains the necessary inference rules for all of these judgements. <p> Figure 6 (Heaps and Programs) contains the necessary inference rules for all of these judgements. Definition 5.2 (Well Formed gc-mono Programs) A gc-mono program P is well formed if . P is derivable. The calculus gc-mono is type sound in that evaluation of well formed programs cannot get stuck <ref> [37] </ref>. Our proof of soundness uses a subject-reduction based argument in the style of Wright and Felleisen [37]. Theorem 5.3 (Type Soundness) If . <p> P is derivable. The calculus gc-mono is type sound in that evaluation of well formed programs cannot get stuck <ref> [37] </ref>. Our proof of soundness uses a subject-reduction based argument in the style of Wright and Felleisen [37]. Theorem 5.3 (Type Soundness) If . P then either P is an answer or else there exists some P 0 such that P RM Proof (sketch): The first two lemmas (below) are needed to prove properties about the allocation rule.
References-found: 37

