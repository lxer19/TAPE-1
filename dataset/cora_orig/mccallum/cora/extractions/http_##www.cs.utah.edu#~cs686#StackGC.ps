URL: http://www.cs.utah.edu/~cs686/StackGC.ps
Refering-URL: http://www.cs.utah.edu/~cs686/
Root-URL: 
Email: (JMiller@zurich.ai.mit.edu)  (gjr@zurich.ai.mit.edu)  
Title: Garbage Collection is Fast, But a Stack is Faster  
Author: James S. Miller and Guillermo J. Rozas 
Note: This publication can be retrieved by anonymous ftp to publications.ai.mit.edu. The pathname for this publication is: ai-publications/1994/AIM-1462.ps.Z Copyright c Massachusetts Institute of Technology, 1993  
Date: 1462 March, 1994  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY ARTIFICIAL INTELLIGENCE LABORATORY  
Pubnum: A.I. Memo No.  
Abstract: Prompted by claims that garbage collection can outperform stack allocation when sufficient physical memory is available, we present a careful analysis and set of cross-architecture measurements comparing these two approaches for the implementation of continuation (procedure call) frames. When the frames are allocated on a heap they require additional space, increase the amount of data transferred between memory and registers, and, on current architectures, require more instructions. We find that stack allocation of continuation frames outperforms heap allocation in some cases by almost a factor of three. Thus, stacks remain an important implementation technique for procedure calls, even in the presence of an efficient, compacting garbage collector and large amounts of memory. This report describes research done at the Artificial Intelligence Laboratory of the Massachusetts Institute of Technology. Support for the laboratory's artificial intelligence research is provided in part by the Advanced Research Projects Agency of the Department of Defense under Office of Naval Research contract N00014-89-J-3202. keywords: compilers, garbage collection, storage management, performance evaluation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction In a well-known letter, Appel <ref> [1] </ref> argues that optimizing compilers for languages that support garbage collection need not attempt to allocate space using a stack if sufficient physical memory is available. Appel's letter reintroduces the copying collector algorithms [2, 3] which, while popular in implementations, have been largely ignored in the literature.
Reference: [2] <author> H. Baker and C. Hewitt. </author> <title> The incremental garbage collection of processes. AI Memo 454, </title> <address> Mass. </address> <institution> Inst. of Technology, Artificial Intelligence Laboratory, </institution> <month> De-cember </month> <year> 1977. </year> <month> 4 </month>
Reference-contexts: 1 Introduction In a well-known letter, Appel [1] argues that optimizing compilers for languages that support garbage collection need not attempt to allocate space using a stack if sufficient physical memory is available. Appel's letter reintroduces the copying collector algorithms <ref> [2, 3] </ref> which, while popular in implementations, have been largely ignored in the literature.
Reference: [3] <author> R. R. Fenichel and J. C. Yochelson. </author> <title> A lisp garbage-collector for virtual-memory computer systems. </title> <journal> Comm. ACM, </journal> <volume> 12(11) </volume> <pages> 611-612, </pages> <year> 1969. </year>
Reference-contexts: 1 Introduction In a well-known letter, Appel [1] argues that optimizing compilers for languages that support garbage collection need not attempt to allocate space using a stack if sufficient physical memory is available. Appel's letter reintroduces the copying collector algorithms <ref> [2, 3] </ref> which, while popular in implementations, have been largely ignored in the literature.
Reference: [4] <editor> IEEE Std 1178-1990. </editor> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> Institute of Electrical and Electronic Engineers, Inc., </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: &gt; creation s (n) + destruction s (n); and thus even if garbage collection never occurs or costs nothing, the cost of heap allocation exceeds the cost of 1 Technically, P hysMem is the size of a semi-space for a two space garbage collector. 2 In languages with a call-with-current-continuation <ref> [4, 7] </ref> operator or backtracking operations [8, 5] continuation frames do not form a single list, but rather a tree. While stacks can (and are) used to allocate continuation frames in these languages, the performance tradeoffs are not as straightforward as those presented here.
Reference: [5] <author> Roberty Kowalski. </author> <title> Predicate logic as a programming language. </title> <type> Technical Report 70, </type> <institution> University of Edin-burgh, </institution> <year> 1973. </year>
Reference-contexts: s (n); and thus even if garbage collection never occurs or costs nothing, the cost of heap allocation exceeds the cost of 1 Technically, P hysMem is the size of a semi-space for a two space garbage collector. 2 In languages with a call-with-current-continuation [4, 7] operator or backtracking operations <ref> [8, 5] </ref> continuation frames do not form a single list, but rather a tree. While stacks can (and are) used to allocate continuation frames in these languages, the performance tradeoffs are not as straightforward as those presented here. This is an active area of research. stack allocation.
Reference: [6] <author> James S. Miller and Guillermo Juan Rozas. </author> <title> Garbage collection is fast, but a stack is faster. AI Memo 1462, </title> <address> Mass. </address> <institution> Inst. of Technology, Artificial Intelligence Laboratory, </institution> <year> 1993. </year>
Reference: [7] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: &gt; creation s (n) + destruction s (n); and thus even if garbage collection never occurs or costs nothing, the cost of heap allocation exceeds the cost of 1 Technically, P hysMem is the size of a semi-space for a two space garbage collector. 2 In languages with a call-with-current-continuation <ref> [4, 7] </ref> operator or backtracking operations [8, 5] continuation frames do not form a single list, but rather a tree. While stacks can (and are) used to allocate continuation frames in these languages, the performance tradeoffs are not as straightforward as those presented here.
Reference: [8] <author> Gerald Jay Sussman, Terry Winograd, and Eugene Charniak. </author> <title> MicroPlanner reference manual. AI Memo 203a, </title> <address> Mass. </address> <institution> Inst. of Technology, Artificial Intelligence Laboratory, </institution> <year> 1971. </year>
Reference-contexts: s (n); and thus even if garbage collection never occurs or costs nothing, the cost of heap allocation exceeds the cost of 1 Technically, P hysMem is the size of a semi-space for a two space garbage collector. 2 In languages with a call-with-current-continuation [4, 7] operator or backtracking operations <ref> [8, 5] </ref> continuation frames do not form a single list, but rather a tree. While stacks can (and are) used to allocate continuation frames in these languages, the performance tradeoffs are not as straightforward as those presented here. This is an active area of research. stack allocation.
References-found: 8

