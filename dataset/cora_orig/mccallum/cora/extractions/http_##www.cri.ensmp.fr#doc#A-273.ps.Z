URL: http://www.cri.ensmp.fr/doc/A-273.ps.Z
Refering-URL: http://www.cri.ensmp.fr/rapports.html
Root-URL: 
Email: fvouillon, jouvelotg@cri.ensmp.fr  
Title: Type and Effect Systems via Abstract Interpretation  
Author: Jerome Vouillon Pierre Jouvelot 
Keyword: Static analysis, abstract interpretation, type and effect systems, foundations of program semantics, time complexity.  
Date: July 12, 1995  
Address: Paris  
Affiliation: CRI, Ecole des Mines de  
Abstract: Abstract interpretation and type and effect systems are two well-known frameworks for the static analysis of programs. While abstract interpretation uses the program control-flow to approximate its run-time behavior, type and effect systems are based on the program structural syntax. The fundamental result of this paper is to show how these a priori distinct approaches can be related to each other, shedding a new light on their relative expressiveness. A single example of static analysis, namely a straightforward program time complexity estimator for the simply typed lambda-calculus with recursion, is used throughout the paper to present the core ideas. We show how an abstract interpretation and a type and effect system can be designed for this analysis and prove them equivalent, thus paving the way to a better understanding of the relative merits of these two frameworks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Coppo, M., and Ferrari, A. </author> <title> Type Inference, Abstract Interpretation and Strictness Analysis. </title> <note> In Theoretical Computer Science 121 (1993) 113-143. </note>
Reference-contexts: Also, their approach uses a relational model instead of the Galois connections we introduced. Mycroft and Jones were actually interested in strictness analysis in the previous paper. This example is also used by Coppo and Ferrari <ref> [1] </ref>. Here, they use filter domains within their abstract semantics, and are able to relate them to the intersection types used for strictness analysis. We use much simpler domains for our abstract interpretation, and study a different type semantics.
Reference: [2] <author> Cousot, P., and Cousot, R. </author> <title> Abstract Interpretation, a unified lattice model for static analysis of programs by construction of approximation of fixpoints. </title> <booktitle> In ACM Symposium on Principles of Programming Languages. </booktitle> <year> 1977. </year>
Reference-contexts: 1 Introduction Abstract interpretation <ref> [2] </ref> and type and effect systems [6] are two well-known frameworks for the static analysis of programs. <p> It is thus natural to define the abstraction that way: ff (-) = v2 where ff V : V ! P (T ) is still to be specified. We deduce from that (see <ref> [2] </ref>): fl (t ) = fv 2 V =t ff V (v)g The central idea is then to see the abstraction of a value v as the set of ground types compatible (in a sense to be made more precise later on) with it; (P (V ); ) ff fl then
Reference: [3] <author> Cousot, P., and Cousot, R. </author> <title> Inductive Definitions, Semantics and Abstract Interpretation. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Principles of Programming Languages. ACM, </booktitle> <address> New-York, </address> <year> 1992 </year>
Reference-contexts: This line of thought is present in the work of Monsuez [9], although he is working with a much more complex system. We believe the presented approach is simpler and, of course, adds the orthogonal issues of effect information. The paper <ref> [3] </ref> discusses the interplay between abstract interpretation and inductive definitions. However the purpose there is to find a way of relating different static semantics, using abstract interpretation as a vehicle for transition.
Reference: [4] <author> Dornic, V., Jouvelot, P. and Gifford, D. K. </author> <title> Polymorphic Time Systems for Estimating Program Complexity. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> vol. 1, no. 1, </volume> <year> 1992. </year>
Reference-contexts: each other, shedding a new light on their relative expressiveness. fl This paper is partially supported by the ESPRIT BRA project LOMAPS (8130). 1 To motivate and simplify the presentation, a single example of static analysis, namely a straightforward program time complexity estimator for the simply typed lambda-calculus with recursion <ref> [4, 14] </ref>, is used throughout the paper to present the core ideas. In this system, an approximation of the number of function applications and variable lookups is obtained for each non-recursive expression, the special value &gt; being used for recursive ones 1 . <p> In Section 2, we give the general notations used in the paper. Section 3 defines the object language and gives a dynamic semantics instrumented with time information. Section 4 recalls the static type and effect system semantics for program complexity analysis defined in <ref> [4] </ref>. Section 5, after a brief introduction on Galois connections, is dedicated to the definition of a new abstract interpretation for complexity analysis: (1) abstraction function for values and (2) abstract semantics. Section 6 formally relates these two static semantics, introducing the main Theorem 3. <p> For the sake of simplicity in the dynamic semantics, we only allow recursion to be used on explicit function definitions. The classical language syntax is given below: 1 <ref> [4] </ref> used the term long for &gt;. 2 e 2 Exp ::= x Identifier in I x:e Function definition f:x:e Recursive function ee Function application 3.2 Dynamic Semantics Since we use time complexity as our example in this paper, the dynamic semantics of this language departs from the usual one in <p> The first one (Section 4) uses the framework of effect systems, while the second (Section 5) is based on abstract interpretation. The main result of Section 6 formally shows how they relate. 4 Effect System This section quickly recalls the material presented in <ref> [4] </ref>. Since we are not specifically interested here in typing issues, we restrict ourselves to expressions that can be typed using the rules of the simply-typed lambda-calculus [8]. This static system extends the classical simply-typed lambda calculus with effect information. The type B corresponds to basic values b. <p> One now needs to ensure that the abstract values computed by this abstract interpretation is correct with respect to the dynamic semantics. Note that we did not do it for the static semantics of Section 4, since this result is already present in <ref> [4] </ref>. An abstract semantics [[:]] ] is correct with respect to the dynamic semantics whenever: 8e 2 Exp; 8 2 I 9 V; [[e]] 2 fl R ([[e]] (ff E (fg))) that is whenever the abstract semantics does not forget any values with respect to the dynamic semantics.
Reference: [5] <author> Jouvelot, P., and Gifford, D. K. </author> <title> Algebraic Reconstruction of Types and Effects. </title> <booktitle> In Pro ceedings of the 1991 ACM Conference on Principles of Programming Languages. ACM, </booktitle> <address> New-York, </address> <year> 1991. </year>
Reference-contexts: Each expression of the program is associated to a type and an effect, respectively abstracting the value it evaluates to, and the side-effects it performs during evaluation. Effects, which are also included within function types, are usually defined over an algebraic domain <ref> [5, 11] </ref>. This requires non-free unification to be performed during type and effect reconstruction.
Reference: [6] <author> Lucassen, J. M., and Gifford, D. K. </author> <title> Polymorphic Effect Systems. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Principles of Programming Languages. ACM, </booktitle> <address> New-York, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Abstract interpretation [2] and type and effect systems <ref> [6] </ref> are two well-known frameworks for the static analysis of programs.
Reference: [7] <author> Mercouroff, N. </author> <title> Analyse Semantique des Communications entre Processus de Programmes Paralleles. </title> <type> Ph.D. Thesis, </type> <institution> Ecole Polytechnique, </institution> <year> 1990. </year>
Reference-contexts: Indeed, the various effect systems in the literature (e.g., [11, 16]) study various behavioral abstractions of programs in a way similar to the various related analyses performed by abstract interpretation (e.g., <ref> [7, 15] </ref>). 9 Conclusion We showed in this paper how the a priori distinct approaches of abstract interpretation and type and effect systems can be related to each other, shedding a new light on their relative expressiveness.
Reference: [8] <author> Mitchell, J. </author> <title> Type Systems for Programming Languages. In Formal Models and Semantics. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <publisher> Elsevier, </publisher> <year> 1990. </year> <month> 10 </month>
Reference-contexts: The main result of Section 6 formally shows how they relate. 4 Effect System This section quickly recalls the material presented in [4]. Since we are not specifically interested here in typing issues, we restrict ourselves to expressions that can be typed using the rules of the simply-typed lambda-calculus <ref> [8] </ref>. This static system extends the classical simply-typed lambda calculus with effect information. The type B corresponds to basic values b. Function types are decorated with latent effect information; this encapsulates the effect of the function body.
References-found: 8

