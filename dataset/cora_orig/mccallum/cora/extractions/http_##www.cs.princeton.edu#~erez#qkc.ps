URL: http://www.cs.princeton.edu/~erez/qkc.ps
Refering-URL: http://www.cs.princeton.edu/~erez/publications.html
Root-URL: http://www.cs.princeton.edu
Title: Quantifying Knowledge Complexity  
Author: Oded Goldreich Erez Petrank 
Date: July 19, 1996  
Abstract: One of the many contributions of the paper of Goldwasser, Micali and Rackoff is the introduction of the notion of knowledge complexity. Knowledge complexity zero (also known as zero-knowledge) have received most of the attention of the authors and all the attention of their followers. In this paper, we present several alternative definitions of knowledge complexity and investigate the relations between them. fl An extended abstract of this paper appeared in the 32nd Annual IEEE Symposium on the Foundations of Com puter Science (FOCS91) held in San Juan, Puerto Rico, October 1991. y Department of Computer Science and Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel. E-mail: oded@wisdom.weizmann.ac.il. z Computer Science Department, Technion - Israel Institute of Technology, Haifa 32000, Israel. E-mail: erez@cs.technion.ac.il. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiello, W., M. Bellare, and J. H-astad, </author> <title> "Knowledge on the Average Perfect, Statistical, and Logarithmic", </title> <booktitle> Proc. 27th STOC, </booktitle> <pages> pp. 469-478, </pages> <year> 1995. </year>
Reference-contexts: Petrank and Tardos [24] have extended [4] and [13] and showed that languages with logarithmic knowledge complexity are in AM"coAM. Thus, unless the polynomial time hierarchy collapses, N P-complete languages have super logarithmic knowledge complexity. The second direction, pursued by Aiello, Bellare and Venkatesan <ref> [1] </ref>, focuses on knowledge-complexity under the average oracle measure. Firstly, they introduced a more refined definition of average knowledge-complexity and related it to the notion defined in this paper. Secondly, they showed that the perfect and statistical knowledge-complexity hierarchies of languages are close up to a negligible additive term. <p> Completeness: Suppose x 2 L (i.e., x 62 L). The construction of [4] guarantees that (P 00 ; V 00 ) accepts x with probability at least 1 (jxj) when P 00 and V 00 are given access to a proper simulator and where : N ! <ref> [0; 1] </ref> is some negligible fraction. However, by Claim 6.1, (P 00 ; V 00 ) accepts x with this probability also when P 00 and V 00 are given access to any probabilistic polynomial time machine (and not necessarily to a simulator for (P; V )).
Reference: [2] <author> W. Alexi, B. Chor, O. Goldreich, and C. P. Schnorr, </author> <title> "RSA/Rabin Functions: Certain Parts are As Hard As the Whole", </title> <journal> SIAM J. Comp., </journal> <volume> Vol. 17, No. 2, </volume> <month> April </month> <year> 1988, </year> <pages> pp. 194-209. </pages>
Reference-contexts: Example 5 Let N be as in Example 4. Suppose that Alice agrees to provide Bob with the least significant bit of the square root (mod N ) of any quadratic residue mod N of Bob's choice. By <ref> [18, 2] </ref> such an answer (by Alice) does yield knowledge to Bob and furthermore jN j answers of this form allow Bob to factor N . Thus, although each answer yields little knowledge (as can be argued analogously to Example 4), many answers yield substantial knowledge. <p> seems despaired if one believes, as us, that all languages in IP must have at most polynomial knowledge-complexity: in Section 6 we extend the work of Aiello and H-astad [4], who in turn follow Fortnow's ideas [10], showing that languages having polynomial knowledge-complexity in the hint sense are in AM <ref> [2] </ref>. 4 Thus, languages having polynomial knowledge-complexity by the hint measure are unlikely to contain all of IP. 1.4 Relating the various definitions of Knowledge Complexity In order to summarize our results concerning the relations between the various definitions, we present the following unsound notations. 5 Let kc strict oracle (); <p> measure may be much smaller than the oracle measure: For every polyno mial p (jxj), there exists a protocol such that kc oracle () 1 p (jxj) , and kc oracle () p (jxj). 4 We also show that languages having logarithmic knowledge-complexity in the hint sense are in coAM <ref> [2] </ref>. 5 The notations below suggest that knowledge-complexity is a functional which assigns each protocol a unique function (i.e., upper bound). This is inaccurate since actually each protocol is assigned a (countable) set of functions; see Section 2. <p> Thus, also satisfies kc * oracle () = k (jxj). 2 6 Properties of knowledge complexity of languages in the hint sense In this section we investigate the "hint-knowledge complexity" hierarchy of languages and establish two results - KC hint (poly (jxj)) AM <ref> [2] </ref>, and KC hint (O (log (jxj)) coAM [2]. These results are obtained by extending the result proven for zero-knowledge by Fortnow [10] and Aiello and H-astad [4]. In the sequel, we follow the construction of [4] 16 . <p> also satisfies kc * oracle () = k (jxj). 2 6 Properties of knowledge complexity of languages in the hint sense In this section we investigate the "hint-knowledge complexity" hierarchy of languages and establish two results - KC hint (poly (jxj)) AM <ref> [2] </ref>, and KC hint (O (log (jxj)) coAM [2]. These results are obtained by extending the result proven for zero-knowledge by Fortnow [10] and Aiello and H-astad [4]. In the sequel, we follow the construction of [4] 16 . One doesn't have to master the techniques used in that work in order to understand our proofs. <p> A simple enhancement in the construction (see [4, 20]) produces also an interactive proof (P 00 ; V 00 ) for L (the complement of L) which also has a constant number of rounds. (Employing [19] and [5] they get that L and L are in AM <ref> [2] </ref>.) We first note that the use of M in these proof systems is limited. The proof considers only the function f M;x which is defined so that f M;x (r) is the output of M on input x and random string r. <p> Namely, when x 62 L, the only property of f M;x () which is guaranteed by M being a simulator is that f M;x () is computable in polynomial time (in jxj). 16 The AM <ref> [2] </ref> protocol built in [10] for a language L whose complement has a statistical zero-knowledge interactive proof has a flow (see Appendix A in [13] for further details). However, the basic ideas in [10] were extended in [4] to construct an AM [2] protocol for a language L that has a <p> in polynomial time (in jxj). 16 The AM <ref> [2] </ref> protocol built in [10] for a language L whose complement has a statistical zero-knowledge interactive proof has a flow (see Appendix A in [13] for further details). However, the basic ideas in [10] were extended in [4] to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. <p> Theorem 6.2 Let L be a language that has an interactive proof with knowledge complexity k = poly (jxj) in the Hint sense, then L 2 AM <ref> [2] </ref>. Proof: We have a language L accepted by an interactive proof (P; V ), and a simulator M that on the input x, and the hint h (x), produces a conversation. If M gets the right hint, it produces a good simulation of (P; V ). <p> It is clear that if both prover and verifier act according to the protocol, then completeness is ensured. Claim 6.1 implies the soundness of the protocol. The number of rounds is a constant, and using [5] and [19] we get L 2 AM <ref> [2] </ref> as desired. 2 Theorem 6.3 Let L be a language that has an interactive proof with knowledge complexity k = O (log (n)) in the Hint sense, then L 2 coAM [2]. Proof: Let us define 2 k (jxj) new simulators. <p> The number of rounds is a constant, and using [5] and [19] we get L 2 AM <ref> [2] </ref> as desired. 2 Theorem 6.3 Let L be a language that has an interactive proof with knowledge complexity k = O (log (n)) in the Hint sense, then L 2 coAM [2]. Proof: Let us define 2 k (jxj) new simulators. For each ff 2 f0; 1g k , let M 0 ff (x) = M (x; ff) where M is the hint machine which simulates the original interactive proof (P; V ).
Reference: [3] <author> Alon, N., L., Babai and A. Itai, </author> <title> "A Fast and Simple Randomized Algorithm for the Maximal Indepedent Set Problem", </title> <journal> J. of Algorithms, </journal> <volume> Vol. 7, </volume> <year> 1986, </year> <pages> pp. 567-583. </pages>
Reference-contexts: Actually, our analysis becomes even easier if we use a sequence of 3-wise independent random variables. It will be most convenient to use the construction given in Alon et. al. <ref> [3] </ref> which works in the field GF (2 m ), since this field corresponds naturally to the set of m-bit strings. The construction uses t &lt; 2 m arbitrary elements of the field, denoted ff 1 ; ff 2 ; :::; ff t .
Reference: [4] <author> Aiello, W., and J. H-astad, </author> <title> "Perfect Zero-Knowledge Languages can be Recognized in Two Rounds", </title> <journal> JCSS, </journal> <volume> Vol. 42, </volume> <pages> pages 327-345, </pages> <year> 1991. </year>
Reference-contexts: The resulting definition is called statistical (or almost perfect) zero-knowledge. For example, the results of Fortnow [10] and of Aiello and H-astad <ref> [4] </ref> on the "complexity of zero-knowledge" refer to this definition. 3. Most liberal is the requirement that the ensembles are indistinguishable by all probabilistic polynomial time tests. The resulting definition is called computational zero-knowledge. <p> These hopes seems despaired if one believes, as us, that all languages in IP must have at most polynomial knowledge-complexity: in Section 6 we extend the work of Aiello and H-astad <ref> [4] </ref>, who in turn follow Fortnow's ideas [10], showing that languages having polynomial knowledge-complexity in the hint sense are in AM [2]. 4 Thus, languages having polynomial knowledge-complexity by the hint measure are unlikely to contain all of IP. 1.4 Relating the various definitions of Knowledge Complexity In order to summarize <p> In particular it was shown how to transform an interactive proof of statistical knowledge complexity k () (w.r.t. the honest verifier) into an interactive proof of perfect knowledge complexity k ()+log () (w.r.t. the honest verifier). Petrank and Tardos [24] have extended <ref> [4] </ref> and [13] and showed that languages with logarithmic knowledge complexity are in AM"coAM. Thus, unless the polynomial time hierarchy collapses, N P-complete languages have super logarithmic knowledge complexity. The second direction, pursued by Aiello, Bellare and Venkatesan [1], focuses on knowledge-complexity under the average oracle measure. <p> These results are obtained by extending the result proven for zero-knowledge by Fortnow [10] and Aiello and H-astad <ref> [4] </ref>. In the sequel, we follow the construction of [4] 16 . One doesn't have to master the techniques used in that work in order to understand our proofs. Yet, some properties of these techniques, explicitly stated below, are essential to the validity of our proofs. The construction in [4] considers <p> These results are obtained by extending the result proven for zero-knowledge by Fortnow [10] and Aiello and H-astad <ref> [4] </ref>. In the sequel, we follow the construction of [4] 16 . One doesn't have to master the techniques used in that work in order to understand our proofs. Yet, some properties of these techniques, explicitly stated below, are essential to the validity of our proofs. The construction in [4] considers the interactive proof (P; V ) for L and <p> H-astad <ref> [4] </ref>. In the sequel, we follow the construction of [4] 16 . One doesn't have to master the techniques used in that work in order to understand our proofs. Yet, some properties of these techniques, explicitly stated below, are essential to the validity of our proofs. The construction in [4] considers the interactive proof (P; V ) for L and the simulator M of (P; V ) guaranteed by the hypothesis 17 . They use the simulator to build a new interactive proof (P 0 ; V 0 ) for L which is of constant number of rounds. <p> They use the simulator to build a new interactive proof (P 0 ; V 0 ) for L which is of constant number of rounds. A simple enhancement in the construction (see <ref> [4, 20] </ref>) produces also an interactive proof (P 00 ; V 00 ) for L (the complement of L) which also has a constant number of rounds. (Employing [19] and [5] they get that L and L are in AM [2].) We first note that the use of M in these <p> However, the basic ideas in [10] were extended in <ref> [4] </ref> to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. Furthermore, the additional machinery presented in [4] suffices also for proving Fortnow's result (see [20] details of how to use the machinery of [4] to prove Fortnow's result). 17 Note that though the <p> However, the basic ideas in [10] were extended in <ref> [4] </ref> to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. Furthermore, the additional machinery presented in [4] suffices also for proving Fortnow's result (see [20] details of how to use the machinery of [4] to prove Fortnow's result). 17 Note that though the zero-knowledge property implies the existence of many simulators (one for each possible verifier), [4] use only the simulator for the original interactive proof (P; <p> However, the basic ideas in [10] were extended in <ref> [4] </ref> to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. Furthermore, the additional machinery presented in [4] suffices also for proving Fortnow's result (see [20] details of how to use the machinery of [4] to prove Fortnow's result). 17 Note that though the zero-knowledge property implies the existence of many simulators (one for each possible verifier), [4] use only the simulator for the original interactive proof (P; V ), where V is not cheating. 26 Returning to the proof systems in [10, 4], we <p> Furthermore, the additional machinery presented in <ref> [4] </ref> suffices also for proving Fortnow's result (see [20] details of how to use the machinery of [4] to prove Fortnow's result). 17 Note that though the zero-knowledge property implies the existence of many simulators (one for each possible verifier), [4] use only the simulator for the original interactive proof (P; V ), where V is not cheating. 26 Returning to the proof systems in [10, 4], we get that when x 62 L, the properties of these proof systems are maintained also in the case that they are given access <p> machinery of [4] to prove Fortnow's result). 17 Note that though the zero-knowledge property implies the existence of many simulators (one for each possible verifier), [4] use only the simulator for the original interactive proof (P; V ), where V is not cheating. 26 Returning to the proof systems in <ref> [10, 4] </ref>, we get that when x 62 L, the properties of these proof systems are maintained also in the case that they are given access to any polynomial time (in the length of their input x) computable function f () and not necessarily to f M;x (). <p> If M gets the right hint, it produces a good simulation of (P; V ). Otherwise, nothing is guaranteed about the behavior of M , except for polynomial running time. We use the interactive proof (P 0 ; V 0 ) for L given by <ref> [4] </ref> with a preliminary step. In this step, P 0 sends V 0 the hint h (x) associated with the input x. <p> Obviously, M 0 h (x) is a good simulating machine for (P; V ). The interactive proof we build runs (P 00 ; V 00 ), the protocol constructed in <ref> [4] </ref> for L, for 2 k times in parallel. The i th copy uses M 0 i as its black box simulator. Our new verifier will accept the input x iff all the sub-protocols end up accepting. Completeness: Suppose x 2 L (i.e., x 62 L). The construction of [4] guarantees <p> in <ref> [4] </ref> for L, for 2 k times in parallel. The i th copy uses M 0 i as its black box simulator. Our new verifier will accept the input x iff all the sub-protocols end up accepting. Completeness: Suppose x 2 L (i.e., x 62 L). The construction of [4] guarantees that (P 00 ; V 00 ) accepts x with probability at least 1 (jxj) when P 00 and V 00 are given access to a proper simulator and where : N ! [0; 1] is some negligible fraction.
Reference: [5] <author> Babai, L., </author> <title> "Trading group theory for randomness", </title> <booktitle> Proc. 17th STOC, </booktitle> <year> 1985, </year> <pages> pp. 421-429. </pages>
Reference-contexts: A simple enhancement in the construction (see [4, 20]) produces also an interactive proof (P 00 ; V 00 ) for L (the complement of L) which also has a constant number of rounds. (Employing [19] and <ref> [5] </ref> they get that L and L are in AM [2].) We first note that the use of M in these proof systems is limited. <p> It is clear that if both prover and verifier act according to the protocol, then completeness is ensured. Claim 6.1 implies the soundness of the protocol. The number of rounds is a constant, and using <ref> [5] </ref> and [19] we get L 2 AM [2] as desired. 2 Theorem 6.3 Let L be a language that has an interactive proof with knowledge complexity k = O (log (n)) in the Hint sense, then L 2 coAM [2]. Proof: Let us define 2 k (jxj) new simulators.
Reference: [6] <author> Bar-Yehuda, R., B. Chor, and E. Kushilevitz, </author> <title> "Privacy, Additional Information, and Communication", </title> <booktitle> 5th IEEE Structure in Complexity Theory, </booktitle> <month> July </month> <year> 1990, </year> <pages> pp. 55-65. </pages>
Reference-contexts: Hence, the amount of knowledge (in the hint sense) leaked by two executions of the same protocol on the same input, always equals the amount of knowledge leaked by a single execution. We note that the hint-length measure was suggested in <ref> [6] </ref>, and seems adequate in the information theoretic model discussed there. 3 Using the strict oracle measure of knowledge complexity, we only establish a superlogarithmic upper bound; see results below. 5 We have several reasons for objecting to the last measure of knowledge-complexity (i.e., the hint length measure).
Reference: [7] <author> Bellare M. and E. Petrank, </author> <title> "Making Zero Knowledge Provers Efficient", </title> <booktitle> Proc. 24th STOC, </booktitle> <year> 1992, </year> <pages> pp. 711-722. </pages>
Reference-contexts: The first direction, pursued in <ref> [7] </ref>, [13] and [24], focuses on the oracle (or, equivalently fraction) measure of knowledge complexity and is aimed at relating the knowledge complexity of languages to their computational complexity. The first step was taken by Bellare and Petrank [7] who showed that any language having a g ()-round interactive proof of <p> The first direction, pursued in <ref> [7] </ref>, [13] and [24], focuses on the oracle (or, equivalently fraction) measure of knowledge complexity and is aimed at relating the knowledge complexity of languages to their computational complexity. The first step was taken by Bellare and Petrank [7] who showed that any language having a g ()-round interactive proof of (statistical) knowledge complexity k (), where k (n) g (n) = O (log n), resides in BPP N P . <p> Subsequently, Goldreich, Ostrovsky and Pe-trank [13] showed that all languages that have logarithmic (statistical) knowledge complexity are in BPP N P . This was done by providing a refined analysis of a procedure in <ref> [7] </ref> and by relating the hierarchies of statistical and perfect knowledge-complexity with respect to the honest verifier 6 .
Reference: [8] <author> Ben-or, M., O. Goldreich, S. Goldwasser, J. H-astad, J. Kilian, S. Micali, and P. Rogaway, </author> <title> "Everything Provable is Provable in Zero-Knowledge", </title> <booktitle> Advances in Cryptology - Crypto88 (proceedings), </booktitle> <editor> S. Goldwasser (ed.), Springer-Verlag, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 403, </volume> <pages> pp. 37-56, </pages> <year> 1990. </year>
Reference-contexts: As per the knowledge-complexity hierarchies of languages, under some reasonable assumptions, the hierarchy of computational knowledge-complexity is quite dull. That is, assuming the existence of secure bit commitment scheme (i.e., the existence of one-way functions), all languages having interactive proofs have interactive proofs of computational knowledge-complexity zero <ref> [8, 21] </ref>. 3.2 Analyzing the examples of the introduction Alice's behavior in Examples 1 and 2 is zero-knowledge and thus of knowledge-complexity zero under all our definitions. In general, it is easy to see that zero-knowledge coincides with knowledge-complexity zero under all our definitions.
Reference: [9] <author> T.M. Cover and G.A. Thomas, </author> <title> Elements of Information Theory, </title> <publisher> John Wiley & Sons, Inc., </publisher> <address> New-York, </address> <year> 1991. </year>
Reference-contexts: Knowledge complexity is intended to capture this increase in computing ability. Thus, knowledge complexity is a fundamental measure of interaction between parties, and it differs from other measures of interaction such as information entropy <ref> [25, 9] </ref> and communication complexity [26, 22]. The following examples may help to illustrate what we mean. In all these examples we assume that Bob is restricted to probabilistic polynomial-time (in the parameter n), whereas no computation restrictions are placed on Alice.
Reference: [10] <author> Fortnow, L., </author> <title> "The Complexity of Perfect Zero-Knowledge", </title> <booktitle> Advances in Computing Research: a research annual, Vol. 5 (Randomness and Computation, </booktitle> <editor> S. Micali, </editor> <publisher> ed.), </publisher> <pages> pages 327-343, </pages> <year> 1989. </year>
Reference-contexts: The resulting definition is called statistical (or almost perfect) zero-knowledge. For example, the results of Fortnow <ref> [10] </ref> and of Aiello and H-astad [4] on the "complexity of zero-knowledge" refer to this definition. 3. Most liberal is the requirement that the ensembles are indistinguishable by all probabilistic polynomial time tests. The resulting definition is called computational zero-knowledge. <p> These hopes seems despaired if one believes, as us, that all languages in IP must have at most polynomial knowledge-complexity: in Section 6 we extend the work of Aiello and H-astad [4], who in turn follow Fortnow's ideas <ref> [10] </ref>, showing that languages having polynomial knowledge-complexity in the hint sense are in AM [2]. 4 Thus, languages having polynomial knowledge-complexity by the hint measure are unlikely to contain all of IP. 1.4 Relating the various definitions of Knowledge Complexity In order to summarize our results concerning the relations between the <p> These results are obtained by extending the result proven for zero-knowledge by Fortnow <ref> [10] </ref> and Aiello and H-astad [4]. In the sequel, we follow the construction of [4] 16 . One doesn't have to master the techniques used in that work in order to understand our proofs. <p> Namely, when x 62 L, the only property of f M;x () which is guaranteed by M being a simulator is that f M;x () is computable in polynomial time (in jxj). 16 The AM [2] protocol built in <ref> [10] </ref> for a language L whose complement has a statistical zero-knowledge interactive proof has a flow (see Appendix A in [13] for further details). However, the basic ideas in [10] were extended in [4] to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. <p> a simulator is that f M;x () is computable in polynomial time (in jxj). 16 The AM [2] protocol built in <ref> [10] </ref> for a language L whose complement has a statistical zero-knowledge interactive proof has a flow (see Appendix A in [13] for further details). However, the basic ideas in [10] were extended in [4] to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. <p> machinery of [4] to prove Fortnow's result). 17 Note that though the zero-knowledge property implies the existence of many simulators (one for each possible verifier), [4] use only the simulator for the original interactive proof (P; V ), where V is not cheating. 26 Returning to the proof systems in <ref> [10, 4] </ref>, we get that when x 62 L, the properties of these proof systems are maintained also in the case that they are given access to any polynomial time (in the length of their input x) computable function f () and not necessarily to f M;x ().
Reference: [11] <author> Goldreich, O., S. Micali, and A. Wigderson, </author> <title> "Proofs that Yield Nothing But their Validity or All Languages in NP Have Zero-Knowledge proof Systems", </title> <journal> Jour. of ACM., </journal> <volume> Vol. 38, </volume> <year> 1991, </year> <pages> pp. 691-729. </pages>
Reference-contexts: Most liberal is the requirement that the ensembles are indistinguishable by all probabilistic polynomial time tests. The resulting definition is called computational zero-knowledge. For example, the result of <ref> [11] </ref> asserting that "all languages in NP have zero-knowledge proofs provided that commitment schemes exist" refers to this definition. 1.3 Defining Knowledge Complexity Unless otherwise indicated, the following discussion refers to the definitions of knowledge complexity in which the simulated conversations are close to the real one in the statistical sense.
Reference: [12] <author> Goldreich, O. and Y. Oren, </author> <title> "Definitions and Properties of Zero-Knowledge Proof Systems", </title> <journal> Jour. of Cryptology, </journal> <volume> Vol. 7, </volume> <year> 1994, </year> <pages> pp. 1-32. 28 </pages>
Reference: [13] <author> Goldreich, O., R. Ostrovsky, and E. Petrank, </author> <title> "Computational Complexity and Knowledge Complexity", </title> <booktitle> 26th ACM Symp. on Theory of Computation, </booktitle> <month> May </month> <year> 1994. </year> <pages> pp. 534-543. </pages>
Reference-contexts: The first direction, pursued in [7], <ref> [13] </ref> and [24], focuses on the oracle (or, equivalently fraction) measure of knowledge complexity and is aimed at relating the knowledge complexity of languages to their computational complexity. <p> The first step was taken by Bellare and Petrank [7] who showed that any language having a g ()-round interactive proof of (statistical) knowledge complexity k (), where k (n) g (n) = O (log n), resides in BPP N P . Subsequently, Goldreich, Ostrovsky and Pe-trank <ref> [13] </ref> showed that all languages that have logarithmic (statistical) knowledge complexity are in BPP N P . This was done by providing a refined analysis of a procedure in [7] and by relating the hierarchies of statistical and perfect knowledge-complexity with respect to the honest verifier 6 . <p> In particular it was shown how to transform an interactive proof of statistical knowledge complexity k () (w.r.t. the honest verifier) into an interactive proof of perfect knowledge complexity k ()+log () (w.r.t. the honest verifier). Petrank and Tardos [24] have extended [4] and <ref> [13] </ref> and showed that languages with logarithmic knowledge complexity are in AM"coAM. Thus, unless the polynomial time hierarchy collapses, N P-complete languages have super logarithmic knowledge complexity. The second direction, pursued by Aiello, Bellare and Venkatesan [1], focuses on knowledge-complexity under the average oracle measure. <p> f M;x () which is guaranteed by M being a simulator is that f M;x () is computable in polynomial time (in jxj). 16 The AM [2] protocol built in [10] for a language L whose complement has a statistical zero-knowledge interactive proof has a flow (see Appendix A in <ref> [13] </ref> for further details). However, the basic ideas in [10] were extended in [4] to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof.
Reference: [14] <author> Goldreich, O. and E. Petrank, </author> <title> "Quantifying Knowledge Complexity", </title> <booktitle> the 32nd Annual IEEE Symposium on the Foundations of Computer Science, </booktitle> <month> October </month> <year> 1991, </year> <pages> pp. 59-68. </pages>
Reference-contexts: Using Proposition 2.6, 13 the current proposition follows. 2 Remark 4.5 Our original proof of Proposition 4.3 (cf., <ref> [14] </ref>) used a more complicated construction of a "somewhat random" list with no apparent advantage. Furthermore, the additive constant achieved there (i.e., 11) is worse. 4.2 The oracle vs. average oracle measure Proposition 4.6 For any interactive proof , kc oracle () kc 1=2 oracle () + 2.
Reference: [15] <author> S. Goldwasser and S. Micali, </author> <title> "Probabilistic Encryption", </title> <journal> JCSS, </journal> <volume> Vol. 28, No. 2, </volume> <pages> pages 270-299, </pages> <year> 1984. </year> <note> Preliminary version in 14th STOC, </note> <year> 1982. </year>
Reference-contexts: Recall that one fourth of the elements of Z fl N are in QN R + N and that it is considered infeasible to distinguish elements of QN R + N from quadratic residues mod N <ref> [15] </ref>. Suppose that Alice uniformly selects a y 2 QN R + N and sends it to Bob. It seems that Bob has gained some knowledge (as we don't know how to uniformly sample QN R + N in polynomial-time when only given N ).
Reference: [16] <author> Goldwasser, S., S. Micali, and C. Rackoff, </author> <title> "The Knowledge Complexity of Interactive Proofs", </title> <booktitle> Proc. 17th STOC, </booktitle> <year> 1985, </year> <pages> pp. 291-304. </pages>
Reference-contexts: Knowledge complexity is intended to measure the computational advantage gained by interaction. Hence, something that can be obtained without interaction is not considered knowledge. The latter phrase is somewhat qualitative and supplies the intuition underlying the definition of zero-knowledge (i.e., knowledge complexity zero) given in <ref> [16] </ref>. <p> Thus, although each answer yields little knowledge (as can be argued analogously to Example 4), many answers yield substantial knowledge. Examples 3, 4 and 5 demonstrate that there is more to knowledge complexity than merely determining whether a protocol is zero-knowledge or not. Following Goldwasser, Micali and Rackoff <ref> [16] </ref>, we suggest that the knowledge gained by interaction can be quantified. The analogy to information theory and communication complexity is telling: none of these stops at a binary distinction between zero and positive. <p> The analogy to information theory and communication complexity is telling: none of these stops at a binary distinction between zero and positive. Goldwasser, Micali and Rackoff have suggested to characterize languages according to the knowledge complexity of their interactive proof systems <ref> [16] </ref>. The lowest class consists of languages having knowledge complexity zero. This class, also known as zero-knowledge, has received much attention in recent years. The following example may serve as a teaser for the low (non-zero) levels of the knowledge complexity hierarchy: Example 6 composing zero-knowledge languages. <p> Here we consider knowledge complexity in the context of interactive proof systems. The actual definitions apply to any pair of interactive machines. 3 A first attempt. An attempt to formalize the "amount of knowledge" (in case it is not zero) has appeared in the preliminary version of <ref> [16] </ref> but was omitted from the later version of this work [17] since the authors themselves found it inadequate (Micali, private communication). By the preliminary formulation of [16] the knowledge complexity of an interactive proof (P; V ) is said to be k (jxj) if there exists a simulator which can <p> An attempt to formalize the "amount of knowledge" (in case it is not zero) has appeared in the preliminary version of <ref> [16] </ref> but was omitted from the later version of this work [17] since the authors themselves found it inadequate (Micali, private communication). By the preliminary formulation of [16] the knowledge complexity of an interactive proof (P; V ) is said to be k (jxj) if there exists a simulator which can generate a distribution M (x) such that the variation distance 2 of M (x) and (P; V )(x) is bounded above by 1 2 k (jxj) + <p> Also note that Alice behavior in Example 4 is clearly of knowledge complexity 1 according to the definition here. Interestingly, the definition of knowledge complexity as a "logarithm of the good fraction" agrees with the informal discussion in the <ref> [16] </ref> paper (although the formal definition presented there was different see above). In fact, Micali (private communication) has independently discovered the "fraction" definition. We show that knowledge-complexity as per the fraction measure approximates (up to an additive constant) the oracle measure of knowledge-complexity.
Reference: [17] <author> Goldwasser, S., S. Micali, and C. Rackoff, </author> <title> "The Knowledge Complexity of Interactive Proof systems", </title> <journal> SIAM Jour. on Computing, </journal> <volume> Vol. 18, </volume> <year> 1989, </year> <pages> pp. 186-208. </pages>
Reference-contexts: Similarity is interpreted in three possible ways yielding three different definitions of zero-knowledge. 1. The most conservative interpretation is that the ensembles are identical. The resulting definition is called perfect zero-knowledge. An example of a language having a perfect zero knowledge interactive proof is Quadratic Non-Residousity <ref> [17] </ref>. 2. Slightly more liberal is the requirement that the ensembles are statistically close, namely that their variation distance (Norm-1 difference) is negligible (i.e., smaller than any polynomial fraction in the length of the common input). The resulting definition is called statistical (or almost perfect) zero-knowledge. <p> The actual definitions apply to any pair of interactive machines. 3 A first attempt. An attempt to formalize the "amount of knowledge" (in case it is not zero) has appeared in the preliminary version of [16] but was omitted from the later version of this work <ref> [17] </ref> since the authors themselves found it inadequate (Micali, private communication).
Reference: [18] <author> Goldwasser, S., S. Micali, and P. Tong, </author> <title> "Why and How to Establish a Private Code on a Public Network", </title> <booktitle> In 23rd FOCS, </booktitle> <pages> pages 134-144, </pages> <year> 1982. </year>
Reference-contexts: Example 5 Let N be as in Example 4. Suppose that Alice agrees to provide Bob with the least significant bit of the square root (mod N ) of any quadratic residue mod N of Bob's choice. By <ref> [18, 2] </ref> such an answer (by Alice) does yield knowledge to Bob and furthermore jN j answers of this form allow Bob to factor N . Thus, although each answer yields little knowledge (as can be argued analogously to Example 4), many answers yield substantial knowledge.
Reference: [19] <author> Goldwasser, S., and M. Sipser, </author> <title> "Private Coins vs. Public Coins in Interactive Proof Systems", Advances in Computing Research (ed. </title> <editor> S. Micali), </editor> <booktitle> 1989, </booktitle> <volume> Vol. 5, </volume> <pages> pp. 73-90. </pages>
Reference-contexts: A simple enhancement in the construction (see [4, 20]) produces also an interactive proof (P 00 ; V 00 ) for L (the complement of L) which also has a constant number of rounds. (Employing <ref> [19] </ref> and [5] they get that L and L are in AM [2].) We first note that the use of M in these proof systems is limited. <p> It is clear that if both prover and verifier act according to the protocol, then completeness is ensured. Claim 6.1 implies the soundness of the protocol. The number of rounds is a constant, and using [5] and <ref> [19] </ref> we get L 2 AM [2] as desired. 2 Theorem 6.3 Let L be a language that has an interactive proof with knowledge complexity k = O (log (n)) in the Hint sense, then L 2 coAM [2]. Proof: Let us define 2 k (jxj) new simulators.
Reference: [20] <author> H-astad, J., </author> <title> Perfect Zero-Knowledge in AM " coAM. Unpublished (2-page) manuscript explaining the underlying ideas behind [4]. </title> <year> 1994. </year>
Reference-contexts: They use the simulator to build a new interactive proof (P 0 ; V 0 ) for L which is of constant number of rounds. A simple enhancement in the construction (see <ref> [4, 20] </ref>) produces also an interactive proof (P 00 ; V 00 ) for L (the complement of L) which also has a constant number of rounds. (Employing [19] and [5] they get that L and L are in AM [2].) We first note that the use of M in these <p> However, the basic ideas in [10] were extended in [4] to construct an AM [2] protocol for a language L that has a statistical zero-knowledge interactive proof. Furthermore, the additional machinery presented in [4] suffices also for proving Fortnow's result (see <ref> [20] </ref> details of how to use the machinery of [4] to prove Fortnow's result). 17 Note that though the zero-knowledge property implies the existence of many simulators (one for each possible verifier), [4] use only the simulator for the original interactive proof (P; V ), where V is not cheating. 26
Reference: [21] <author> Impagliazzo, R., and M. Yung, </author> <title> "Direct Minimum-Knowledge Computations", </title> <booktitle> Advances in Cryptology - Crypto87 (proceedings), </booktitle> <editor> C. Pomerance (ed.), Springer-Verlag, </editor> <booktitle> Lectures Notes in Computer Science, </booktitle> <volume> vol. 293, </volume> <year> 1987, </year> <pages> pp. 40-51. </pages>
Reference-contexts: As per the knowledge-complexity hierarchies of languages, under some reasonable assumptions, the hierarchy of computational knowledge-complexity is quite dull. That is, assuming the existence of secure bit commitment scheme (i.e., the existence of one-way functions), all languages having interactive proofs have interactive proofs of computational knowledge-complexity zero <ref> [8, 21] </ref>. 3.2 Analyzing the examples of the introduction Alice's behavior in Examples 1 and 2 is zero-knowledge and thus of knowledge-complexity zero under all our definitions. In general, it is easy to see that zero-knowledge coincides with knowledge-complexity zero under all our definitions.
Reference: [22] <author> E. Kushilevitz and N. Nisan, </author> <title> Communication Complexity, </title> <type> preprint, </type> <year> 1995. </year>
Reference-contexts: Knowledge complexity is intended to capture this increase in computing ability. Thus, knowledge complexity is a fundamental measure of interaction between parties, and it differs from other measures of interaction such as information entropy [25, 9] and communication complexity <ref> [26, 22] </ref>. The following examples may help to illustrate what we mean. In all these examples we assume that Bob is restricted to probabilistic polynomial-time (in the parameter n), whereas no computation restrictions are placed on Alice.
Reference: [23] <author> G. L. Miller, </author> <title> "Riemann's Hypothesis and Tests for Primality", </title> <journal> JCSS, </journal> <volume> Vol. 13, </volume> <year> 1976, </year> <pages> pp. 300-317. </pages>
Reference-contexts: The same holds with respect to the oracle measure (cf., Proposition 4.3). An obvious bound with respect to the hint measure is the length of the smallest element in QN R + N (which under ERH has length O (log jN j) <ref> [23] </ref>), and it is not clear if one can provide a better bound. As per Example 5, Alice sends a single bit which can be easily simulated by one oracle query (or by a good subspace of density 1/2).
Reference: [24] <author> E. Petrank and G. Tardos, </author> <title> "On the Knowledge Complexity of NP", </title> <note> In 37th FOCS 1996, to appear. </note>
Reference-contexts: The first direction, pursued in [7], [13] and <ref> [24] </ref>, focuses on the oracle (or, equivalently fraction) measure of knowledge complexity and is aimed at relating the knowledge complexity of languages to their computational complexity. <p> In particular it was shown how to transform an interactive proof of statistical knowledge complexity k () (w.r.t. the honest verifier) into an interactive proof of perfect knowledge complexity k ()+log () (w.r.t. the honest verifier). Petrank and Tardos <ref> [24] </ref> have extended [4] and [13] and showed that languages with logarithmic knowledge complexity are in AM"coAM. Thus, unless the polynomial time hierarchy collapses, N P-complete languages have super logarithmic knowledge complexity. The second direction, pursued by Aiello, Bellare and Venkatesan [1], focuses on knowledge-complexity under the average oracle measure.
Reference: [25] <author> Shannon, C.E., </author> <title> "A mathematical theory of communication", </title> <journal> Bell Sys. Tech. J., </journal> <volume> Vol. 27, </volume> <year> 1948, </year> <pages> pp. 623-656. </pages>
Reference-contexts: Knowledge complexity is intended to capture this increase in computing ability. Thus, knowledge complexity is a fundamental measure of interaction between parties, and it differs from other measures of interaction such as information entropy <ref> [25, 9] </ref> and communication complexity [26, 22]. The following examples may help to illustrate what we mean. In all these examples we assume that Bob is restricted to probabilistic polynomial-time (in the parameter n), whereas no computation restrictions are placed on Alice.
Reference: [26] <author> A.C. Yao, </author> <title> "Some complexity questions related to distributive computing", </title> <booktitle> In 11th STOC, </booktitle> <pages> pages 209-213, </pages> <year> 1979. </year>
Reference-contexts: Knowledge complexity is intended to capture this increase in computing ability. Thus, knowledge complexity is a fundamental measure of interaction between parties, and it differs from other measures of interaction such as information entropy [25, 9] and communication complexity <ref> [26, 22] </ref>. The following examples may help to illustrate what we mean. In all these examples we assume that Bob is restricted to probabilistic polynomial-time (in the parameter n), whereas no computation restrictions are placed on Alice.
Reference: [27] <author> A.C. Yao, </author> <title> "Theory and Application of Trapdoor Functions", </title> <booktitle> In 23rd FOCS, </booktitle> <pages> pages 80-91, </pages> <year> 1982. </year> <month> 29 </month>
References-found: 27

