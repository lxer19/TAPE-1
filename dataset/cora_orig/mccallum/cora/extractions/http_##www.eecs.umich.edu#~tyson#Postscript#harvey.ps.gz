URL: http://www.eecs.umich.edu/~tyson/Postscript/harvey.ps.gz
Refering-URL: http://www.eecs.umich.edu/~tyson/publications.html
Root-URL: http://www.cs.umich.edu
Email: tysoncs.ucr.edu  
Title: Graphical User Interface for Compiler Optimizations with Simple-SUIF  
Author: Brian Harvey Gary Tyson 
Web: briancs.ucr.edu  
Address: Riverside, CA 92521  Riverside, CA 92521  RIVERSIDE  
Affiliation: Department of Computer Science  Department of Computer Science University of California  Department of Computer Science University of California  C COLLEGE OF ENGINEERING UNIVERSITY OF CALIFORNIA  
Pubnum: UCR-CS-96-5 Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: principles, techniques, tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: It is a common misconception that the process of compiling source code into an executable is performed by a single program. In actuality, this process is performed by an entire set of programs, each with its specific task, that together form a language-processing system <ref> [1] </ref>. <p> This language-processing system and its components are shown in Figure 1.1. This figure shows how the original source code transforms into the final executable program. The functionality of the compiler module in a language-processing system can be separated into two main components <ref> [1] </ref>. The front end takes source code, performs lexical, syntactic, and semantic analysis on it and produces an intermediate representation of that code. The back end takes the intermediate representation, optimizes it, and generates assembly code for the target machine. <p> In this way, VSSC can be a teaching tool for the study of compiler back ends. Students can also benefit from using VSSC when writing their own optimizations. In a typical optimizing compiler course, students implement such standard optimizations as dead-code elimination, common subexpression elimination, and others described in <ref> [1] </ref>. Students can use VSSC to facilitate their understanding of what happens during one of these optimizations. VSSC can show them the results of a particular data flow analysis and the effects of a transformation. <p> The flow graphs generated by dflo look very nice and the data-flow equations are easy to construct. Figure 3.1 shows the dflo data-flow equations to compute liveness. LIVE edge - [0] = any succs ( LIVE ) * TRANSUP + EXPOSEUP; LIVE.in node - <ref> [1] </ref> = LIVE.out * TRANS + EXPOSEUP ; LIVE.out node - [1] = any succs ( LIVE.in ) - Unfortunately, dflo uses the commercial Motif graphical user interface as its GUI front end. <p> Figure 3.1 shows the dflo data-flow equations to compute liveness. LIVE edge - [0] = any succs ( LIVE ) * TRANSUP + EXPOSEUP; LIVE.in node - <ref> [1] </ref> = LIVE.out * TRANS + EXPOSEUP ; LIVE.out node - [1] = any succs ( LIVE.in ) - Unfortunately, dflo uses the commercial Motif graphical user interface as its GUI front end. <p> An example in which live-variable analysis is performed followed by dead-code elimination is shown in Section 5.3. Finally, Section 5.4 shows an example in which available-expression analysis is performed followed by copy propagation. The algorithms discussed in this section are described in <ref> [1] </ref> and [30]. 56 5.2 Example Graphs Graph data structures are used throughout a compiler. The front end uses a parse tree (an acyclic graph with a single node recognized as the "root") when parsing the source code during syntax analysis. <p> Therefore, the directed edges in a flow graph represent edges to successors. It should also be noted that a basic block can have multiple predecessors and multiple successors. Before a flow graph can be constructed, the basic blocks of a procedure need to be determined. Algorithm 9.1 in <ref> [1] </ref> described a two-step method: 1. First determine the set of leaders, the first statements of basic blocks. <p> This information can be used to find common subexpressions (those expressions that are computed more than once) as well as determining which statements in the block could have their value used outside the block. Nodes within a DAG are labeled using the following rules <ref> [1] </ref>: 1. Each leaf in the graph is labeled by a unique identifier, which is either a constant value such as "4" or "56", a register, or a symbol name. 2. Interior nodes are labeled by an operator symbol. These nodes represent computations with one or two operands. <p> Table 5.1: Bitsets used during live variable analysis Given the def and use bitsets computed for each basic block, the algorithm <ref> [1] </ref> in Figure 5.8 will perform live variable analysis computing the in and out bitsets for each basic block. foreach basic block B B.in = Empty Set while there are any changes to any B.in's - foreach basic block B - B.out = union of all S.in's for each successor S
Reference: [2] <author> Kristy Andrews, Robert R. Henry, and Wayne K. Yamamoto. </author> <title> Design and implementation of the UW illustrated compiler. </title> <type> Technical Report 88-03-07, </type> <institution> University of Washington, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Like VSSC, it is also uses Tcl/Tk for its GUI interface. 3.2.2 UW Illustrated Compiler The University of Washington developed the UW Illustrated Compiler (icomp) <ref> [2] </ref>, which lets a user interactively browse through textual and graphical views of control and data structures during the compilation of a program.
Reference: [3] <author> Giuseppe Di Battista, Peter Eades, Roberto Tamassia, and Ioannis G. Tollis. </author> <title> Algorithms for drawing graphs: an annotated bibliography, </title> <month> June </month> <year> 1994. </year>
Reference-contexts: The second part of this chapter is a discussion of several compiler visualization projects similar to VSSC. 3.1 Graph Drawing Tools The graph drawing process is complicated. There is an large amount of research being done in this field <ref> [3] </ref> and many algorithms have been designed to draw graphs that look aesthetically pleasing. As a result of this research, many graph drawing tools exist to demonstrate the feasibility of these graph drawing algorithms. Such tools include: ffgraph [15], daVinci [16], Graph Ed [19], and DOT [21].
Reference: [4] <author> Manuel E. Benitez and Jack W. Davidson. </author> <title> A portable global optimizer and linker. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 329-338, </pages> <address> Atlanta, Georgia, USA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: who used the system provided positive feedback regarding its use and its presentation of information. 3.2.3 xvpodb The tool that most closely matches the goals of VSSC is xvpodb, designed by Micky Boyd and David Whalley of Florida State University. xvpodb is a graphical optimization viewer for the vpo optimizer <ref> [4] </ref>.
Reference: [5] <author> Mickey R. Boyd and David B. Whalley. </author> <title> Graphical visualization of compiler optimizations. </title> <journal> Journal of Programming Languages, </journal> <pages> pages 69-94, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: It had the following design goals <ref> [5] </ref>: * The program should appear in a easily readable display that is automatically updated each time the data structure is changed. * Indicate the exact portions of the representations that were altered during a transformation. * Allow data breakpoints to be used. * Provide the capability to examine the effect <p> This log, implemented as a linked-list, is shown in Figure 4.7. It is similar in design to the Optimization List used in xvpodb <ref> [5] </ref> except that each log entry can have more than one event.
Reference: [6] <author> G. J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-105. </pages> <publisher> ACM, ACM, </publisher> <year> 1982. </year> <note> Available as SIGPLAN Notices 17(6) June 1982. 82 </note>
Reference-contexts: In other words, two symbolic registers that have overlapping live ranges will not collide, because they will be stored in two different physical machine registers. The problem of graph coloring is NP-complete. However, several heuristic algo rithms exist. One such heuristic is Chaitin's <ref> [6] </ref> graph coloring heuristic. Assuming that the register spilling is not being performed and the number of physical ma chine registers is k, this heuristic can be implemented by applying the algorithm shown in Figure 5.17 to an existing register-interference graph.
Reference: [7] <author> Cliff Click and Keith D. Cooper. </author> <title> Combining analyses, combining optimiza-tions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 181-196, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: The phase-ordering problem can be difficult to avoid. Research in this area has proposed several solutions for specific transformations in which the phases are combined. A framework for describing optimizations and an example framework in which constant propagation, value numbering and unreachable-code elimination are combined is presented in <ref> [7] </ref>. Combining these phases allows for more information about the program to be discovered and thus more opportunities for optimization. In [25], register allocation and instruction scheduling are combined. A heuristic algorithm is used in which weights are used for controlling register pressure and instruction parallelism.
Reference: [8] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A code generation interface for ANSI C. </title> <type> Technical Report TR-270-90, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: The target-independent front end and the target-dependent back end of lcc exist together in a single executable glued together by an efficient interface. This interface consists of only 18 functions and the C code being compiled is represented by a 36-operator dag language <ref> [8] </ref>. This language is the intermediate format of lcc and represents the source program as it goes from the front end to the back end in the compilation process. The dag language has gone through many changes during the development of lcc.
Reference: [9] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10) </volume> <pages> 29-43, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In this section we look at three popular retargetable compilers in order to determine which one best supports the VSSC framework. These compilers are: the GNU gcc compiler [34] developed by Richard Stallman (and numerous other people), the lcc compiler <ref> [9] </ref> developed by Christopher W. Fraser at AT&T Bell Laboratories and David R. Hanson at Princeton University, and the SUIF compiler [42] developed by Monica Lam at Stanford University. <p> These limitations make it very difficult to implement the functionality planned for VSSC using the GCC compiler. 2.3 LCC The lcc compiler <ref> [9] </ref> [10] is an ANSI C compliant retargetable compiler that can generate code for VAX, Motorola 68020, i386, SPARC, and MIPS R3000 architectures. Developed by Christopher W. Fraser at AT&T Bell Laboratories and David R.
Reference: [10] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <publisher> Benjamin/Cummings Pub. Co., </publisher> <address> Redwood City, CA, USA, </address> <year> 1995. </year>
Reference-contexts: These limitations make it very difficult to implement the functionality planned for VSSC using the GCC compiler. 2.3 LCC The lcc compiler [9] <ref> [10] </ref> is an ANSI C compliant retargetable compiler that can generate code for VAX, Motorola 68020, i386, SPARC, and MIPS R3000 architectures. Developed by Christopher W. Fraser at AT&T Bell Laboratories and David R. <p> The simple and compact design of lcc makes it one of the smallest and fastest ANSI C compilers available. Probably the most useful feature of lcc is the quality of its the documentation. The authors used the noweb [31] system to generate a textbook <ref> [10] </ref> and the source code for lcc from a single source. Therefore, the textbook, which describes the implementation of lcc, includes most of the code of lcc along with the explanation of that code and how it contributes to the implementation.
Reference: [11] <author> Christopher W. Fraser, David R. Hanson, and T. A. Proebsting. </author> <title> Engineering a simple, efficient code generator generator. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 213-226, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Some tools exist to help compiler writers with this functionality of the back end. These tools, such as iburg <ref> [11] </ref>, burg [12], and Twig [38], act as code generator generators. Each of these tools reads in a specification and generates C code to perform the code generation based on the specification. The specification usually specifies the cost of operands and instruction in the intermediate format.
Reference: [12] <author> Christopher W. Fraser, Robert R. Henry, and Todd A. Proebsting. </author> <title> BURG-fast optimal instruction selection and tree parsing. </title> <type> Technical Report TR 1066, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Some tools exist to help compiler writers with this functionality of the back end. These tools, such as iburg [11], burg <ref> [12] </ref>, and Twig [38], act as code generator generators. Each of these tools reads in a specification and generates C code to perform the code generation based on the specification. The specification usually specifies the cost of operands and instruction in the intermediate format.
Reference: [13] <author> Christopher W. Fraser and Alan L. Wendt. </author> <title> Integrating code generation and optimization. </title> <booktitle> In SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 242-248, </pages> <address> Palo Alto, CA, </address> <month> June </month> <year> 1986. </year> <institution> Association for Computing Machinery, SIGPLAN. </institution>
Reference-contexts: In [25], register allocation and instruction scheduling are combined. A heuristic algorithm is used in which weights are used for controlling register pressure and instruction parallelism. Finally, a compiler in which the code generation phase and a machine-directed peephole optimizer are tightly integrated is described in <ref> [13] </ref> and [14]. These two components can be combined because they are both simple pattern matchers. A peephole optimizer replaces patterns of code with more efficient code while a code generator matches patterns of intermediate code and replaces them with assembly code.
Reference: [14] <author> Christopher W. Fraser and Alan L. Wendt. </author> <title> Automatic generation of fast optimizing code generators. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 79-84, </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: In [25], register allocation and instruction scheduling are combined. A heuristic algorithm is used in which weights are used for controlling register pressure and instruction parallelism. Finally, a compiler in which the code generation phase and a machine-directed peephole optimizer are tightly integrated is described in [13] and <ref> [14] </ref>. These two components can be combined because they are both simple pattern matchers. A peephole optimizer replaces patterns of code with more efficient code while a code generator matches patterns of intermediate code and replaces them with assembly code.
Reference: [15] <author> Carsten Friedrich. </author> <title> The ffgraph library. </title> <type> Technical Report MIP-9520, </type> <institution> Fakultat fur Mathematik und Informatik, Universitat Passau, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: As a result of this research, many graph drawing tools exist to demonstrate the feasibility of these graph drawing algorithms. Such tools include: ffgraph <ref> [15] </ref>, daVinci [16], Graph Ed [19], and DOT [21]. Most tools are stand-alone programs, while others such as DOT can be integrated into an existing GUI such as Tcl/Tk [28] [40].
Reference: [16] <author> M. Frohlich and M. Werner. </author> <title> The graph visualization system daVinci A user interface for applications. </title> <type> Technical Report 5/94, </type> <institution> Department of Computer Science; University of Bremen, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: As a result of this research, many graph drawing tools exist to demonstrate the feasibility of these graph drawing algorithms. Such tools include: ffgraph [15], daVinci <ref> [16] </ref>, Graph Ed [19], and DOT [21]. Most tools are stand-alone programs, while others such as DOT can be integrated into an existing GUI such as Tcl/Tk [28] [40].
Reference: [17] <author> E. R. Gansner, E. Koutsofios, S. C. North, and K.-P. Vo. </author> <title> A technique for drawing directed graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 214-230, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: We chose to integrate the DOT [21] package with VSSC to implement the graph drawing capabilities VSSC provides. DOT is a general graph drawing tool which draws directed graphs using a four-step algorithm <ref> [17] </ref>: 1. Assigns discrete ranks to nodes. These ranks determine the Y coordinates in the final drawing. 2. Orders nodes within ranks to avoid crossings. 3. Assigns X coordinates to nodes while keeping edges short. 4. Routes edge splines between nodes that have edges.
Reference: [18] <author> James Gosling and Henry McGilton. </author> <title> The java language environment A whitepaper. </title> <type> Technical report, </type> <institution> Sum Microsystems, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: This machine-independent feature means that the intermediate code can be retargeted to many different architectures simply by using a different back end and the compiler can use a machine-independent code optimizer in the back end. The importance of a good intermediate representation is prevalent even in today's technologies. Java <ref> [18] </ref>, a popular Internet programming language, translates Java source code into a bytecode format which acts as an assembly language for a virtual machine. This bytecode is the intermediate format between the source code and a running program.
Reference: [19] <author> Michael Himsolt. </author> <title> Graph Ed User Manual, </title> <year> 1990. </year>
Reference-contexts: As a result of this research, many graph drawing tools exist to demonstrate the feasibility of these graph drawing algorithms. Such tools include: ffgraph [15], daVinci [16], Graph Ed <ref> [19] </ref>, and DOT [21]. Most tools are stand-alone programs, while others such as DOT can be integrated into an existing GUI such as Tcl/Tk [28] [40].
Reference: [20] <author> S. C. Johnson. </author> <title> YACC: Yet another compiler compiler. </title> <institution> Computer Science Technical Report #32, Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1975. </year>
Reference-contexts: This process includes checking the syntax of the source code and checking the semantics of the source code. There exist several well-known tools to help compiler writers with the front end. These tools, which include lex [23], yacc <ref> [20] </ref>, and ANTLR [29], use a specification of the source language to generate a translator from the source language to an intermediate specification. This is often accomplished by using combinations of these tools targeting each to a portion of the translation.
Reference: [21] <author> E. Koutsofios and S. C. </author> <title> North. Drawing graphs with dot. </title> <type> Technical report, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: As a result of this research, many graph drawing tools exist to demonstrate the feasibility of these graph drawing algorithms. Such tools include: ffgraph [15], daVinci [16], Graph Ed [19], and DOT <ref> [21] </ref>. Most tools are stand-alone programs, while others such as DOT can be integrated into an existing GUI such as Tcl/Tk [28] [40]. <p> These tools are designed to be standalone programs, which are difficult to incorporate into a larger package like VSSC. We chose to integrate the DOT <ref> [21] </ref> package with VSSC to implement the graph drawing capabilities VSSC provides. DOT is a general graph drawing tool which draws directed graphs using a four-step algorithm [17]: 1. Assigns discrete ranks to nodes. These ranks determine the Y coordinates in the final drawing. 2. <p> Rather than implement custom graph drawing algorithms within the VSSC GUI, we chose to integrate an existing graph drawing package in the VSSC framework. We chose to use tcldot [22], which is part of a larger package, DOT <ref> [21] </ref>, developed by Eleftherios Koutsofios and Stephen C. North at AT&T Bell Laboratories. tcldot is a version of DOT that can be used to produce graphs in a Tk canvas widget.
Reference: [22] <author> E. Koutsofios and S. C. North. TCLDOT(1). </author> <title> Unix Manual Page, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Rather than implement custom graph drawing algorithms within the VSSC GUI, we chose to integrate an existing graph drawing package in the VSSC framework. We chose to use tcldot <ref> [22] </ref>, which is part of a larger package, DOT [21], developed by Eleftherios Koutsofios and Stephen C. North at AT&T Bell Laboratories. tcldot is a version of DOT that can be used to produce graphs in a Tk canvas widget. <p> North at AT&T Bell Laboratories. tcldot is a version of DOT that can be used to produce graphs in a Tk canvas widget. VSSC embeds tcldot within its framework and uses it to draw graphs on a canvas located in the Graph Component of the GUI. The DOT/tcldot API <ref> [22] </ref>, part of which is shown in Table 4.2, includes many commands such as creating and destroying graph nodes and edges between nodes.
Reference: [23] <author> M. E. Lesk and E. Schmidt. </author> <title> Lex A lexical analyzer generator. </title> <institution> Computer Science Technical Report #39, Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1975. </year>
Reference-contexts: This process includes checking the syntax of the source code and checking the semantics of the source code. There exist several well-known tools to help compiler writers with the front end. These tools, which include lex <ref> [23] </ref>, yacc [20], and ANTLR [29], use a specification of the source language to generate a translator from the source language to an intermediate specification. This is often accomplished by using combinations of these tools targeting each to a portion of the translation.
Reference: [24] <author> Jing Yee Lim. </author> <title> A visual browser for SUIF. </title> <booktitle> In SUIF Compiler Workshop, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Several compiler visualization tools that influenced the design of VSSC are presented in this section. 3.2.1 Visual SUIF Browser One the many tools that have been written for SUIF include a visual SUIF browser <ref> [24] </ref>. Here is the official description [41]: The Visual Browser is a graphical user interface, which runs under X, for browsing through SUIF intermediate representation code.
Reference: [25] <author> Rajeev Motwani, Krishna V. Palem, Vivek Sarkar, and Salem Reyen. </author> <title> Combining register allocation and instruction scheduling. </title> <type> Technical Note STAN//CS-TN-95-22, </type> <institution> Stanford University, Department of Computer Science, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: A framework for describing optimizations and an example framework in which constant propagation, value numbering and unreachable-code elimination are combined is presented in [7]. Combining these phases allows for more information about the program to be discovered and thus more opportunities for optimization. In <ref> [25] </ref>, register allocation and instruction scheduling are combined. A heuristic algorithm is used in which weights are used for controlling register pressure and instruction parallelism. Finally, a compiler in which the code generation phase and a machine-directed peephole optimizer are tightly integrated is described in [13] and [14].
Reference: [26] <author> S. Naher. </author> <title> LEDA | a library of efficient data types and algorithms. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 665:710-??, </address> <year> 1993. </year>
Reference-contexts: Writing compiler optimizations (or any large project) requires that you manage complex data structures. Commonly used data structures in compiler optimiza tions and compiler tools include lists, trees, arrays, bit sets, and graphs. There are many popular data structure libraries that work well. One such library is LEDA <ref> [26] </ref>. LEDA was considered for use in VSSC during the design phase, but it was rejected because it would add another package to the list of packages VSSC already requires. Fortunately, the SUIF libraries include most of the commonly used data struc tures needed in compiler tools.
Reference: [27] <author> Stephen C. North and Eleftherios Koutsofios. </author> <title> Application of graph visualization. </title> <booktitle> In Proceedings of Graphics Interface '94, </booktitle> <pages> pages 235-245, </pages> <address> Banff, Alberta, Canada, </address> <month> May </month> <year> 1994. </year> <booktitle> Canadian Information Processing Society. </booktitle>
Reference-contexts: The transformation log is described in detail in Section 4.3.5. 4.3.2 Incorporating tcldot into VSSC A graphical user interface for a compiler tool should be able to display the types of graph data structures that are commonly used in compiler tools. Applications of graph visualization are discussed in <ref> [27] </ref>, while the issue of graph visualization from the viewpoint of compilers is discussed in detail in [33]. Rather than implement custom graph drawing algorithms within the VSSC GUI, we chose to integrate an existing graph drawing package in the VSSC framework.
Reference: [28] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1994. </year>
Reference-contexts: Such tools include: ffgraph [15], daVinci [16], Graph Ed [19], and DOT [21]. Most tools are stand-alone programs, while others such as DOT can be integrated into an existing GUI such as Tcl/Tk <ref> [28] </ref> [40]. There are several other graph drawing tools that are more specialized in their functionality in that they are used to draw many of the data structures present in compilers: flow graphs, syntax trees, call graphs, and data dependence graphs. Two such tools are dflo [44] and VCG [32]. <p> Such an interface is generally easier to use. No typing is necessary; just point and click. The interaction between the VSSC compiler and its user is completely graphical. The GUI is implemented using Tcl/Tk <ref> [28] </ref> [40]. Further information about Tcl/Tk is presented in section 4.3.1 below. * VSSC should facilitate classroom instruction of compiler optimizations. Very few tools exist today that can be used to teach students compiler optimiza tions graphically. <p> The GUI is also the key component that allows the user to select which transformations to perform and in what order to execute them. Tcl/Tk <ref> [28] </ref> [40], developed by John Ousterhout at the University of California, Berkeley, is a scripting language. The Tcl/Tk graphical user interface is used to implement VSSC's GUI. It is a simple and portable toolkit that can be easily integrated with C/C++ code.
Reference: [29] <author> T. J. Parr and R. W. Quong. </author> <title> ANTLR: A predicated-LL(k) parser generator. </title> <journal> Software Practice and Experience, </journal> <volume> 25(7) </volume> <pages> 789-810, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: This process includes checking the syntax of the source code and checking the semantics of the source code. There exist several well-known tools to help compiler writers with the front end. These tools, which include lex [23], yacc [20], and ANTLR <ref> [29] </ref>, use a specification of the source language to generate a translator from the source language to an intermediate specification. This is often accomplished by using combinations of these tools targeting each to a portion of the translation.
Reference: [30] <author> Thomas H. Payne. </author> <title> Compiler design. </title> <booktitle> CS201 Lecture Notes, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: An example in which live-variable analysis is performed followed by dead-code elimination is shown in Section 5.3. Finally, Section 5.4 shows an example in which available-expression analysis is performed followed by copy propagation. The algorithms discussed in this section are described in [1] and <ref> [30] </ref>. 56 5.2 Example Graphs Graph data structures are used throughout a compiler. The front end uses a parse tree (an acyclic graph with a single node recognized as the "root") when parsing the source code during syntax analysis. During syntax-directed translation, syntax trees are used to represent language constructs. <p> This algorithm propagates liveness information backwards through the flow graph until no new information gets propagated, i.e., stability has been achieved. intermediate representation of the bubblesort example. 5.3.3 Eliminating Dead Code in Bubblesort Example to the algorithm in <ref> [30] </ref>. More often than not, the source program is not responsible for dead code that appears in the intermediate code. <p> Determining the availability of an instruction is discussed in Section 5.4.2. This valid transformation can cause many copy instructions to become dead. They can then be removed by dead-code elimination. A slightly different version of copy propagation is presented in <ref> [30] </ref>. In this version, a modified version of available-expression analysis is performed. Instead of 3 In Simple-SUIF, this instruction is the CPY OP instruction, which copies the value in the src1 register into the dest register. looking for available expressions, available instruction forms are discovered.
Reference: [31] <author> Norman Ramsey. </author> <title> Literate-Programming can be simple and extensible. </title> <type> Technical report, </type> <institution> Department of Computer Science, Princeton University, Princeton, </institution> <address> New Jersey, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: The simple and compact design of lcc makes it one of the smallest and fastest ANSI C compilers available. Probably the most useful feature of lcc is the quality of its the documentation. The authors used the noweb <ref> [31] </ref> system to generate a textbook [10] and the source code for lcc from a single source. Therefore, the textbook, which describes the implementation of lcc, includes most of the code of lcc along with the explanation of that code and how it contributes to the implementation.
Reference: [32] <author> G. Sander. </author> <title> VCG visualization of compiler graphs. User documentation V1.130, </title> <month> February </month> <year> 1995. </year>
Reference-contexts: There are several other graph drawing tools that are more specialized in their functionality in that they are used to draw many of the data structures present in compilers: flow graphs, syntax trees, call graphs, and data dependence graphs. Two such tools are dflo [44] and VCG <ref> [32] </ref>. VCG is used to graphically display typical data structures found in a compiler, while dlfo can be used to solve data-flow equations. 3.1.1 VCG Textual representations of compiler data structures, such as trees or graphs, can often be confusing or unreadable.
Reference: [33] <author> G. Sander. </author> <title> Graph layout for applications in compiler construction. </title> <type> Technical Report A/01/96, </type> <institution> Universitat des Saarlandes, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: Applications of graph visualization are discussed in [27], while the issue of graph visualization from the viewpoint of compilers is discussed in detail in <ref> [33] </ref>. Rather than implement custom graph drawing algorithms within the VSSC GUI, we chose to integrate an existing graph drawing package in the VSSC framework. We chose to use tcldot [22], which is part of a larger package, DOT [21], developed by Eleftherios Koutsofios and Stephen C.
Reference: [34] <author> Richard Stallman. </author> <title> Using and porting GNU CC. Free Software Foundation, </title> <address> 675 Mass Ave, Cambridge, MA 02139, USA, Tel: (617) 876-3296, USA, </address> <note> last updated 26 november 1995 for version 2.7.2 edition, </note> <year> 1995. </year>
Reference-contexts: In this section we look at three popular retargetable compilers in order to determine which one best supports the VSSC framework. These compilers are: the GNU gcc compiler <ref> [34] </ref> developed by Richard Stallman (and numerous other people), the lcc compiler [9] developed by Christopher W. Fraser at AT&T Bell Laboratories and David R. Hanson at Princeton University, and the SUIF compiler [42] developed by Monica Lam at Stanford University. <p> Fraser at AT&T Bell Laboratories and David R. Hanson at Princeton University, and the SUIF compiler [42] developed by Monica Lam at Stanford University. These systems are briefly evaluated below. 2.2 GNU C Compiler (GCC) The GNU C Compiler (GCC) <ref> [34] </ref>, which can compile C, C++, and Objective-C code, is arguably the world's most popular free compiler. GCC's greatest strength is that fact that GCC has been ported to and has been retargeted to many different operating systems and architectures.
Reference: [35] <author> Richard Stallman and Roland H. Pesch. </author> <title> Debugging with GDB: the GNU source-level debugger. </title> <address> 675 Mass Ave, Cambridge, MA 02139, USA, Tel: (617) 876-3296, USA, 4.12, </address> <note> for GDB version 4.14 edition, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: Perhaps one of the most important benefits provided by VSSC is the ability to step through an optimization. Much in the same way that you can step through code in a code debugger such as GDB <ref> [35] </ref>, the VSSC package allows the optimiza tion writer to configure steps within the optimization and when the optimization is performed in the VSSC compiler, the GUI user can step through the optimization at his or her own pace.
Reference: [36] <author> Stanford Compiler Group. </author> <title> The Simple-SUIF Compiler Guide, 1.0 edition. A simple interface to SUIF for compiler courses. </title>
Reference-contexts: The SUIF Compiler group at Stanford developed a package called Simple-SUIF <ref> [36] </ref> which acts as a wrapper for SUIF by providing a simplified interface to the intermediate format generated by the SUIF compiler. When using Simple-SUIF, the SUIF intermediate format remains the same internally, but differs in the way the programmer interacts with the system. <p> Each basic block contains the bitsets shown in Table 5.1. The bits in a bitset map directly to the variable with the same number. For example, bit 4 in a bitset refers to register 4. It is important to note that the Simple-SUIF intermediate representation <ref> [36] </ref> guarantees that a temporary register is defined only once and it is used only once within the same basic block in which it was defined. For this reason, live-variable analysis only keeps track of Simple-SUIF pseudo registers.
Reference: [37] <author> Stanford Compiler Group. </author> <title> The SUIF Library, 1.0 edition. A set of core routines for manipulating SUIF data structures. </title>
Reference-contexts: The VSSC framework uses many of the generic data structures provided by SUIF. These data structures are described in more detail in section A.5.5 of Appendix A and Chapter 11 of the SUIF Library Documentation <ref> [37] </ref>. 4.3.4 Simple-SUIF One of the major design goals of the VSSC framework is to use an intermediate format that is simple, easy to read, and familiar looking.
Reference: [38] <author> Steven Tjiang. </author> <title> Twig reference manual. </title> <institution> Comp. Sci. </institution> <type> Tech. Rep. 120, </type> <institution> AT&T Bell Laboratories, </institution> <month> January </month> <year> 1986. </year>
Reference-contexts: Some tools exist to help compiler writers with this functionality of the back end. These tools, such as iburg [11], burg [12], and Twig <ref> [38] </ref>, act as code generator generators. Each of these tools reads in a specification and generates C code to perform the code generation based on the specification. The specification usually specifies the cost of operands and instruction in the intermediate format.
Reference: [39] <author> Steven W. K. Tjiang and John L. Hennessy. </author> <title> Sharlit|A tool for building optimizers. </title> <booktitle> In ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 82-93, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: This compiler uses a single rule-based pattern matching system which makes the compiler simple, fast, and retargetable. 1.3.1 Constructing Code Optimizers Currently, few tools exist to help construct code optimizers. This is slowly changing as the importance of optimization grows. One such tool to appear is Sharlit <ref> [39] </ref>. Built to work with the SUIF compiler system, Sharlit helps in constructing data flow analyzers and the transformations that use data flow analysis information.
Reference: [40] <author> Brent Welch. </author> <title> Practical Programming in Tcl and Tk. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ 07632, USA, </address> <year> 1995. </year>
Reference-contexts: Such tools include: ffgraph [15], daVinci [16], Graph Ed [19], and DOT [21]. Most tools are stand-alone programs, while others such as DOT can be integrated into an existing GUI such as Tcl/Tk [28] <ref> [40] </ref>. There are several other graph drawing tools that are more specialized in their functionality in that they are used to draw many of the data structures present in compilers: flow graphs, syntax trees, call graphs, and data dependence graphs. Two such tools are dflo [44] and VCG [32]. <p> Such an interface is generally easier to use. No typing is necessary; just point and click. The interaction between the VSSC compiler and its user is completely graphical. The GUI is implemented using Tcl/Tk [28] <ref> [40] </ref>. Further information about Tcl/Tk is presented in section 4.3.1 below. * VSSC should facilitate classroom instruction of compiler optimizations. Very few tools exist today that can be used to teach students compiler optimiza tions graphically. <p> The GUI is also the key component that allows the user to select which transformations to perform and in what order to execute them. Tcl/Tk [28] <ref> [40] </ref>, developed by John Ousterhout at the University of California, Berkeley, is a scripting language. The Tcl/Tk graphical user interface is used to implement VSSC's GUI. It is a simple and portable toolkit that can be easily integrated with C/C++ code.
Reference: [41] <author> Chris Wilson. </author> <title> Announcing the new SUIF visual browser package. suif-announcesuif.stanford.edu mailing list, </title> <month> April </month> <year> 1996. </year>
Reference-contexts: Several compiler visualization tools that influenced the design of VSSC are presented in this section. 3.2.1 Visual SUIF Browser One the many tools that have been written for SUIF include a visual SUIF browser [24]. Here is the official description <ref> [41] </ref>: The Visual Browser is a graphical user interface, which runs under X, for browsing through SUIF intermediate representation code.
Reference: [42] <author> Robert Wilson, Robert French, Christopher Wilson, Saman Amarasinghe, Jennifer Anderson, Steve Tjiang, Shih-Wei Liao, Chau-Wen Tseng, Mary Hall, Monica Lam, and John Hennessy. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(12) </volume> <pages> 31-37, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: More efficient development of optimization routines should be the result of using such a tool. In order to develop such a tool, the intermediate format used in the compiler needs to be well designed and should not change between code transformations; the SUIF (Stanford University Intermediate Format) compiler <ref> [42] </ref> has such an intermediate format. The SUIF system is organized as a set of compiler passes built on top of a kernel that defines the intermediate format. <p> These compilers are: the GNU gcc compiler [34] developed by Richard Stallman (and numerous other people), the lcc compiler [9] developed by Christopher W. Fraser at AT&T Bell Laboratories and David R. Hanson at Princeton University, and the SUIF compiler <ref> [42] </ref> developed by Monica Lam at Stanford University. These systems are briefly evaluated below. 2.2 GNU C Compiler (GCC) The GNU C Compiler (GCC) [34], which can compile C, C++, and Objective-C code, is arguably the world's most popular free compiler. <p> This modularity allows a researcher to concentrate only on what they need to, without worrying about how it affects the rest of the compiler system. 2.4 SUIF Compiler System The SUIF research compiler system <ref> [42] </ref> [43], developed by a team of researchers under the direction of Monica Lam at Stanford University, is centered around the robust design of its intermediate format called SUIF (Stanford University Intermediate Format).
Reference: [43] <author> Robert Wilson, Robert French, Christopher Wilson, Saman Amarasinghe, Jennifer Anderson, Steve Tjiang, Shih-Wei Liao, Chau-Wen Tseng, Mary Hall, Monica Lam, and John Hennessy. </author> <title> An Overview of the SUIF Compiler System. </title>
Reference-contexts: This modularity allows a researcher to concentrate only on what they need to, without worrying about how it affects the rest of the compiler system. 2.4 SUIF Compiler System The SUIF research compiler system [42] <ref> [43] </ref>, developed by a team of researchers under the direction of Monica Lam at Stanford University, is centered around the robust design of its intermediate format called SUIF (Stanford University Intermediate Format). <p> The SUIF system is organized into two components. The kernel of the SUIF compiler defines the central core of the compiler. The design goals of the kernel are <ref> [43] </ref>: * to make all program information necessary for scalar and parallel compiler optimizations easily available * to foster code reuse, sharing, and modularity * to support experimentation and system prototyping.
Reference: [44] <author> Michael Wolfe. </author> <title> dflo compiler graph display tool. </title> <note> USENET posting to comp.compilers, </note> <month> August </month> <year> 1996. </year>
Reference-contexts: There are several other graph drawing tools that are more specialized in their functionality in that they are used to draw many of the data structures present in compilers: flow graphs, syntax trees, call graphs, and data dependence graphs. Two such tools are dflo <ref> [44] </ref> and VCG [32]. VCG is used to graphically display typical data structures found in a compiler, while dlfo can be used to solve data-flow equations. 3.1.1 VCG Textual representations of compiler data structures, such as trees or graphs, can often be confusing or unreadable. <p> Constructed graphs can be folded allowing unimportant parts of the graph to be hidden, while important components can be shown in more detail. The output of the constructed graph can viewed using a self-contained X-windows tool or saved as a postscript file. 3.1.2 dflo dflo <ref> [44] </ref> is a tool that inputs: a description of a flow graph, the variables assigned and expressions computed in each flow graph node, and a system of data-flow equations. It then solves the data-flow equations and allows the user to interactively view the results.
References-found: 44

