URL: file://ftp.cs.wisc.edu/tech-reports/reports/91/tr994.ps.Z
Refering-URL: http://www.cs.wisc.edu/exodus/exodus.papers.html
Root-URL: 
Title: Caching Tradeoffs in Client-Server DBMS Architectures  
Author: Michael J. Carey Michael J. Franklin Miron Livny Eugene Shekita 
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Note: Data  This research was partially supported by the Defense Advanced Research Projects Agency under contracts N00014-88-K-0303 and NAG 2-618 and by the National Science Foundation under grant IRI-8657323.  
Abstract: An abridged version of this paper appears in: Proceedings of the ACM SIGMOD International Conference on the Management of Data, Denver CO, May 1991. Computer Sciences Technical Report #994 January 1991 
Abstract-found: 1
Intro-found: 1
Reference: [Agra87] <author> Agrawal, R., Carey, M., and Livny, M., </author> <title> "Concurrency Control Performance Modeling: Alternatives and Implications," </title> <journal> ACM Trans. on Database Sys. </journal> <volume> 12, 4, </volume> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: It is well-known that optimistic concurrency control algorithms outperform traditional locking algorithms in the presence of data contention when resources are plentiful <ref> [Fran85, Agra87] </ref>, and this is precisely the difference between the algorithms here. 4.8.
Reference: [Arch86] <author> Archibald, J., and Baer, J.-L., </author> <title> "Cache Coherence Protocols: Evaluation Using a Multiprocessor Simulation Model," </title> <journal> ACM Trans. on Comp. Sys. </journal> <volume> 4, 4, </volume> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: In addition, it should be noted that our work is also loosely related to studies of multiprocessor cache coherency algorithms (e.g., <ref> [Arch86] </ref>) and to work on caching in distributed file systems (e.g., [Howa88, Nels88, Gray89]). We will return to the topic of related work again once we have presented our performance results. <p> In that work, two algorithms were developed and analyzed. One of the algorithms was developed by viewing cached pages as snapshots of server pages and characterizing them according to their current state relative to the server's version; this is similar to approaches found in multiprocessor cache coherency algorithms <ref> [Arch86] </ref>. The other algorithm is based on an analogy with notification ideas from the active database area. Both of these algorithms required that certain conditions be checked and later rechecked in order to avoid potential race conditions between transactions.
Reference: [Bell90] <author> Bellew, M., Hsu, M., and Tam, V.-O., </author> <title> "Update Propagation in Distributed Memory Hierarchy," </title> <booktitle> Proc. 6th Int'l. Conf. on Data Eng., </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: Second, we study a range of cache consistency algorithms that goes beyond those found in the shared-disk literature, including algorithms that propagate changes to other caches rather than invalidating other cached copies. The final example of closely related work is the recent Harvard work on transaction-oriented distributed memory hierarchies <ref> [Bell90] </ref>. In contrast to our work, their work assumes a decentralized, shared-nothing architecture and a communications network with hardware broadcast support, yielding a very different set of resource-related performance tradeoffs. <p> Comparison With Related Work As described in the introduction, the studies most closely related to this one are shared-disk performance studies [Bhid88, Yu87, Dan90], the client-server data caching study that was described in [Wilk90], and the transaction-oriented distributed memory hierarchy work of <ref> [Bell90] </ref>. As explained earlier, client-server DBMS architectures tend to be larger than shared-disk DBMS configurations, and the existence of a central server changes the nature of the performance problem somewhat (e.g., consider the various client-server buffer interactions, and server CPU limitations, that have been important here). <p> We have gone further in this regard, proposing and investigating the O2PL-D algorithm as a solution to the performance sensitivity of the propagation approach. Lastly, in comparison to the work of <ref> [Bell90] </ref>, where consistency control algorithms based on both invalidation and (periodic) propagation were also considered, we have observed a very different set of resource-related performance tradeoffs due to major architectural differences between the systems studied. 5.
Reference: [Bern87] <author> Bernstein, P., Hadzilacos, V., and Goodman, N., </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Thus, all of the well-known results on replica management theory and algorithms <ref> [Bern87] </ref> can be applied to the client-server cache consistency problem. Given this observation, we now present five candidate algorithms for maintaining client-server cache con - 4 - sistency. 2 The first algorithm is a basic two-phase locking scheme, based on the primary copy approach to replica management [Bern87], in which data <p> theory and algorithms <ref> [Bern87] </ref> can be applied to the client-server cache consistency problem. Given this observation, we now present five candidate algorithms for maintaining client-server cache con - 4 - sistency. 2 The first algorithm is a basic two-phase locking scheme, based on the primary copy approach to replica management [Bern87], in which data is not cached between client transactions. The second algorithm extends the first to allow for inter-transaction data caching. <p> This allows the server to handle future requests for the modified data directly even if the client workstation is turned off or crashes in the meantime. 2.2. Basic Two-Phase Locking (B2PL) The first algorithm is a primary copy locking algorithm <ref> [Bern87] </ref> in which the client database process discards cached data between transactions. Transactions set read locks on the data pages that they access, upgrading their read locks to write locks if an item is to be updated. <p> This is accomplished by piggybacking a list of recently discarded pages on the next message that it sends to the server. 2.4. Optimistic Two-Phase Locking (O2PL) The next three algorithms, referred to collectively as the O2PL family of cache consistency algorithms, are all based on a read-one/write-all <ref> [Bern87] </ref> optimistic locking scheme studied in [Care89b] for distributed replica management. These algorithms differ from C2PL in that, prior to transaction commit time, clients set read and write locks locally without obtaining locks at the server.
Reference: [Bhid88] <author> Bhide, A., and Stonebraker, M., </author> <title> "An Analysis of Three Transaction Processing Architectures," </title> <booktitle> Proc. 14th VLDB Conf., </booktitle> <address> Los Angeles, CA, </address> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: First, we employ a much more detailed model of buffering, the importance of which will be clear from our results. Second, we study a broader range of DBMS workloads. Our work is also related to studies of shared-disk architectures, including the work by Bhide <ref> [Bhid88] </ref> and by a DBMS performance group at IBM Yorktown (reported in [Yu87, Dan90] and other related papers). Again, our work differs from these efforts in several ways. First, shared-disk and client-server DBMS architectures are qualitatively different. <p> Comparison With Related Work As described in the introduction, the studies most closely related to this one are shared-disk performance studies <ref> [Bhid88, Yu87, Dan90] </ref>, the client-server data caching study that was described in [Wilk90], and the transaction-oriented distributed memory hierarchy work of [Bell90].
Reference: [Care84] <author> Carey, M., and Stonebraker, M., </author> <title> "The Performance of Concurrency Control Algorithms for Database Management Systems," </title> <booktitle> Proc. 10th VLDB Conf., </booktitle> <address> Singapore, </address> <month> Aug. </month> <year> 1984. </year>
Reference: [Care89a] <author> Carey, M., et al, </author> <title> "Storage Management for Objects in EXODUS," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Prototypes based on object-level interactions include Orion [Kim90] and O2 [Deux90], among others. Among the prototypes based on page-level (or multi-page block) interactions are ObServer [Horn87] and the current version of the EXODUS storage manager <ref> [Care89a, Zwil90] </ref>; the ObjectStore system from Object Design [ODI90] is an example of a commercial OODBMS product based on page-level interactions. <p> This approach, also referred to as the block server approach [Ston90b], was shown to perform well for CAD-style data access patterns in a recent performance study [DeWi90]. Also, our work was motivated by a desire to understand performance tradeoffs in our own page-based, client-server storage managers <ref> [Care89a, Shek90, Zwil90] </ref>. Given this set of cache consistency algorithms, we then describe a detailed simulation model that was developed to study their performance over a wide range of workloads and system resource configurations. The performance of transaction-oriented cache consistency algorithms has been examined in several related contexts.
Reference: [Care89b] <author> Carey, M., and Livny, M., </author> <title> "Conflict Detection Tradeoffs for Replicated Data," </title> <note> submitted to ACM Trans. on Database Sys.. (Available as Comp. Sci. Tech. Report No. 826, </note> <institution> University of Wisconsin, </institution> <month> March </month> <year> 1989.) </year>
Reference-contexts: The second algorithm extends the first to allow for inter-transaction data caching. The other three algorithms are each based on an optimistic variant of two-phase locking, studied in <ref> [Care89b] </ref>, where updates to remote copies of replicated data are deferred until end-of-transaction. <p> Optimistic Two-Phase Locking (O2PL) The next three algorithms, referred to collectively as the O2PL family of cache consistency algorithms, are all based on a read-one/write-all [Bern87] optimistic locking scheme studied in <ref> [Care89b] </ref> for distributed replica management. These algorithms differ from C2PL in that, prior to transaction commit time, clients set read and write locks locally without obtaining locks at the server. <p> A conflict between an update-copy lock and a write lock indicates an impending distributed deadlock, and it can be resolved as such without further delay <ref> [Care89b] </ref>.
Reference: [Catt90a] <author> Cattell, R., and Skeen, J., </author> <title> Engineering Database Benchmark, </title> <type> Tech. Rep., </type> <institution> Database Eng. Group, Sun Microsystems, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Thus, the potential consequences of adding caching to a client-server DBMS range from a significant improvement in performance to a notable degradation in performance. An example of a workload where caching can be highly beneficial is the Sun Engineering Database Benchmark <ref> [Catt90a] </ref>. In this paper, we examine the data caching performance tradeoffs discussed above. We begin by presenting a range of lock-based cache consistency algorithms that result from recognizing that cache consistency is simply a variant of the replicated data management problem studied by distributed DBMS researchers.
Reference: [Catt90b] <author> Cattell, R., </author> <type> personal communication, </type> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This situation is of interest because some OODBMS developers expect skewed client access distributions to be common in OODBMS applications <ref> [Catt90b, Wein90] </ref>. 4.2.1. HOTCOLD Workload, Small Client Buffer Pool (ClientBufSize = 5% of the database size). Figure 5 shows the corresponding average transaction response time results.
Reference: [Dan90] <author> Dan, A., Dias, D., and Yu, P., </author> <title> "The Effect of Skewed Data Access on Buffer Hits and Data Contention in a Data Sharing Environment," </title> <booktitle> Proc. 16th VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Second, we study a broader range of DBMS workloads. Our work is also related to studies of shared-disk architectures, including the work by Bhide [Bhid88] and by a DBMS performance group at IBM Yorktown (reported in <ref> [Yu87, Dan90] </ref> and other related papers). Again, our work differs from these efforts in several ways. First, shared-disk and client-server DBMS architectures are qualitatively different. <p> Comparison With Related Work As described in the introduction, the studies most closely related to this one are shared-disk performance studies <ref> [Bhid88, Yu87, Dan90] </ref>, the client-server data caching study that was described in [Wilk90], and the transaction-oriented distributed memory hierarchy work of [Bell90].
Reference: [Deux90] <editor> Deux, O., et al, </editor> <title> "The Story of O 2 ," IEEE Trans. </title> <journal> on Knowledge and Data Eng. </journal> <volume> 2, 1, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: In order to offload processing to client workstations, it is common for client-server interactions in an OODBMS to take place at the level of individual objects or pages of objects rather than queries [DeWi90]. Prototypes based on object-level interactions include Orion [Kim90] and O2 <ref> [Deux90] </ref>, among others. Among the prototypes based on page-level (or multi-page block) interactions are ObServer [Horn87] and the current version of the EXODUS storage manager [Care89a, Zwil90]; the ObjectStore system from Object Design [ODI90] is an example of a commercial OODBMS product based on page-level interactions.
Reference: [DeWi90] <author> DeWitt, D., et al, </author> <title> "A Study of Three Alternative Workstation-Server Architectures for Object-Oriented Database Systems," </title> <booktitle> Proc. 16th VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: In order to offload processing to client workstations, it is common for client-server interactions in an OODBMS to take place at the level of individual objects or pages of objects rather than queries <ref> [DeWi90] </ref>. Prototypes based on object-level interactions include Orion [Kim90] and O2 [Deux90], among others. <p> For concreteness, we focus our attention on systems where client-server interactions are page-based. This approach, also referred to as the block server approach [Ston90b], was shown to perform well for CAD-style data access patterns in a recent performance study <ref> [DeWi90] </ref>. Also, our work was motivated by a desire to understand performance tradeoffs in our own page-based, client-server storage managers [Care89a, Shek90, Zwil90].
Reference: [Fran85] <author> Franaszek, P., and Robinson, J., </author> <title> "Limitations of Concurrency in Transaction Processing," </title> <journal> ACM Trans. on Database Sys. </journal> <volume> 10, 1, </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: It is well-known that optimistic concurrency control algorithms outperform traditional locking algorithms in the presence of data contention when resources are plentiful <ref> [Fran85, Agra87] </ref>, and this is precisely the difference between the algorithms here. 4.8.
Reference: [Gray89] <author> Gray, C., and Cheriton, D., "Leases: </author> <title> An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency," </title> <booktitle> in Proc. 12th ACM Symp. on Op. Sys. </booktitle> <address> Prin., Litchfield Park, AZ, </address> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: In addition, it should be noted that our work is also loosely related to studies of multiprocessor cache coherency algorithms (e.g., [Arch86]) and to work on caching in distributed file systems (e.g., <ref> [Howa88, Nels88, Gray89] </ref>). We will return to the topic of related work again once we have presented our performance results.
Reference: [Horn87] <author> M. Hornick and S. Zdonik, </author> <title> "A Shared, Segmented Memory System for an Object-Oriented Database," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5, 1, </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: Prototypes based on object-level interactions include Orion [Kim90] and O2 [Deux90], among others. Among the prototypes based on page-level (or multi-page block) interactions are ObServer <ref> [Horn87] </ref> and the current version of the EXODUS storage manager [Care89a, Zwil90]; the ObjectStore system from Object Design [ODI90] is an example of a commercial OODBMS product based on page-level interactions.
Reference: [Howa88] <author> Howard, J., et al, </author> <title> "Scale and Performance in a Distributed File System," </title> <journal> ACM Trans. on Comp. Sys. </journal> <volume> 6, 1, </volume> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: This research was partially supported by the Defense Advanced Research Projects Agency under contracts N00014-88-K-0303 and NAG-2-618 and by the National Science Foundation under grant IRI-8657323. 1 If the client workstations have local disks, it is also possible to cache data on secondary storage, as in the Andrew file system <ref> [Howa88] </ref>. Local disk caching is beyond the scope of this paper, however, and will not be discussed further. server interaction, lessening the network traffic and message processing overhead for both the server and its clients. <p> In addition, it should be noted that our work is also loosely related to studies of multiprocessor cache coherency algorithms (e.g., [Arch86]) and to work on caching in distributed file systems (e.g., <ref> [Howa88, Nels88, Gray89] </ref>). We will return to the topic of related work again once we have presented our performance results.
Reference: [Kim90] <author> Kim, W., et al, </author> <title> "The Architecture of the ORION Next-Generation Database System," </title> <journal> IEEE Trans. on Knowledge and Data Eng. </journal> <volume> 2, 1, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: In order to offload processing to client workstations, it is common for client-server interactions in an OODBMS to take place at the level of individual objects or pages of objects rather than queries [DeWi90]. Prototypes based on object-level interactions include Orion <ref> [Kim90] </ref> and O2 [Deux90], among others. Among the prototypes based on page-level (or multi-page block) interactions are ObServer [Horn87] and the current version of the EXODUS storage manager [Care89a, Zwil90]; the ObjectStore system from Object Design [ODI90] is an example of a commercial OODBMS product based on page-level interactions.
Reference: [Lazo86] <author> Lazowska, E., et al, </author> <title> "File Access Performance of Diskless Workstations," </title> <journal> ACM Trans. on Comp. Sys. </journal> <volume> 4, 3, </volume> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: This cost assumption has been found to provide reasonably accurate performance results despite its simplicity <ref> [Lazo86] </ref>. 4. EXPERIMENTS AND RESULTS In this section, we present performance results for the various client-server cache consistency algorithms and discuss their associated tradeoffs.
Reference: [Livn88] <author> Livny, M., </author> <note> DeNet User's Guide, Version 1.0, Comp. </note> <institution> Sci. Dept., Univ. of Wisconsin, Madison, </institution> <year> 1988. </year>
Reference-contexts: Certain aspects of the system, such as consistency control and buffer management, are modeled in their full detail; other aspects, such as the database and the workload, are modeled more abstractly. The model has been implemented using the DeNet simulation language <ref> [Livn88] </ref>. iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Parameter Meaning iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii DatabaseSize Size of database in pages PageSize Size of a page NumClients Number of client workstations iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ThinkTime Mean think time between client transactions TransactionSize Mean number of pages accessed per transaction PerPageInst Mean number of instructions per page on read (doubled on write) HotBounds
Reference: [Nels88] <author> Nelson, M., Welch, B., and Ousterhout, J., </author> <title> "Caching in the Sprite Network File System," </title> <journal> ACM Trans. on Comp. Sys. </journal> <volume> 6, 1, </volume> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: In addition, it should be noted that our work is also loosely related to studies of multiprocessor cache coherency algorithms (e.g., [Arch86]) and to work on caching in distributed file systems (e.g., <ref> [Howa88, Nels88, Gray89] </ref>). We will return to the topic of related work again once we have presented our performance results.
Reference: [ODI90] <institution> Object Design, Inc., </institution> <type> ObjectStore Technical Overview, </type> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Prototypes based on object-level interactions include Orion [Kim90] and O2 [Deux90], among others. Among the prototypes based on page-level (or multi-page block) interactions are ObServer [Horn87] and the current version of the EXODUS storage manager [Care89a, Zwil90]; the ObjectStore system from Object Design <ref> [ODI90] </ref> is an example of a commercial OODBMS product based on page-level interactions.
Reference: [Sarg76] <author> Sargent, R., </author> <title> "Statistical Analysis of Simulation Output Data," </title> <booktitle> Proc. 4th Annual Symp. on the Simulation of Computer Systems, </booktitle> <month> August </month> <year> 1976. </year>
Reference-contexts: To ensure the statistical validity of our results, we verified that the 90% confidence intervals for transaction response times (computed using batch means <ref> [Sarg76] </ref>) were sufficiently tight. The size of these confidence intervals was within a few percent of the mean in almost all cases, which is more than sufficient for our purposes. Throughout the paper we discuss only performance differences that were found to be statistically significant.
Reference: [Shek90] <author> Shekita, E., and Zwilling, M., "Cricket: </author> <title> A Mapped Persistent Object Store," </title> <booktitle> Proc. 4th Int'l. Workshop on Pers. Obj. Sys., </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: This approach, also referred to as the block server approach [Ston90b], was shown to perform well for CAD-style data access patterns in a recent performance study [DeWi90]. Also, our work was motivated by a desire to understand performance tradeoffs in our own page-based, client-server storage managers <ref> [Care89a, Shek90, Zwil90] </ref>. Given this set of cache consistency algorithms, we then describe a detailed simulation model that was developed to study their performance over a wide range of workloads and system resource configurations. The performance of transaction-oriented cache consistency algorithms has been examined in several related contexts. <p> Server concern ourselves with the details of how the client application and database processes interact within a client workstation; this is system-dependent, and may be handled through database library calls (based on local IPC or shared memory) or through virtual memory assisted page-faulting (a la <ref> [Shek90] </ref>). All that matters here is that client applications can somehow submit requests to the client database process in order to control (i.e., begin, commit, and abort) transactions and to read and write objects in the database.
Reference: [Ston79] <author> Stonebraker, M., </author> <title> "Concurrency Control and Consistency of Multiple Copies of Data in Distributed INGRES," </title> <journal> IEEE Trans. on Softw. Eng. </journal> <volume> SE-5, 3, </volume> <month> May </month> <year> 1979. </year> <month> - 28 </month> - 
Reference-contexts: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 If an update-copy lock request is made for a page that is no longer cached at a given client site, the site simply ignores this lock request. - 6 - database processes check for local deadlocks, and by having the server periodically check for distributed deadlocks a la <ref> [Ston79] </ref>. 2.4.1. Update Invalidation (O2PL-I) In the invalidation variant of O2PL, the variant-specific action is the invalidation of other cached copies of updated pages. That is, a committing update transaction acquires update-copy locks on all copies (i.e., at the server and at any clients) of the updated pages.
Reference: [Ston90a] <author> Stonebraker, M., et al, </author> <title> "Third-Generation Data Base System Manifesto," </title> <booktitle> SIGMOD Record 19, </booktitle> <volume> 3, </volume> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Most commercial relational database management systems today are based on client-server architectures, with SQL queries and their results serving as the basis for client-server interactions <ref> [Ston90a] </ref>. In the past few years, a number of object-oriented DBMS (OODBMS) prototypes and products have appeared, virtually all of which are based on client-server architectures. Compared to relational database systems, these systems generally take a different approach when it comes to client-server interactions.
Reference: [Ston90b] <author> Stonebraker, M., </author> <title> "Architecture of Future Database Systems, </title> <journal> Data Eng. </journal> <volume> 13, 4, </volume> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: For concreteness, we focus our attention on systems where client-server interactions are page-based. This approach, also referred to as the block server approach <ref> [Ston90b] </ref>, was shown to perform well for CAD-style data access patterns in a recent performance study [DeWi90]. Also, our work was motivated by a desire to understand performance tradeoffs in our own page-based, client-server storage managers [Care89a, Shek90, Zwil90].
Reference: [Wein90] <author> Weinreb, D., </author> <type> personal communication, </type> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This situation is of interest because some OODBMS developers expect skewed client access distributions to be common in OODBMS applications <ref> [Catt90b, Wein90] </ref>. 4.2.1. HOTCOLD Workload, Small Client Buffer Pool (ClientBufSize = 5% of the database size). Figure 5 shows the corresponding average transaction response time results. <p> Thus, there is no read/write sharing of data in this workload. This workload is intended to represent situations such as large, CAD-based engineering projects in which each engineer might work on disjoint portions of an overall design while read-sharing a standard library of components <ref> [Wein90] </ref>; it can also be viewed as a more extreme version of the previous workload. 8 since the nature of the workloads is similar. B2PL and C2PL perform very much like in Figure 8, for virtually identical reasons.
Reference: [Wilk90] <author> Wilkinson, W., and Neimat, M.-A., </author> <title> "Maintaining Consistency of Client Cached Data," </title> <booktitle> Proc. 16th VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: The performance of transaction-oriented cache consistency algorithms has been examined in several related contexts. The only other client-server data caching study that we know of is a recent simulation study at HP Laboratories <ref> [Wilk90] </ref>. Our work differs from their work in several ways. First, we employ a much more detailed model of buffering, the importance of which will be clear from our results. Second, we study a broader range of DBMS workloads. <p> Finally, since the database client processes are separate from client application processes, their state outlives client transactions. Thus, they are free to cache data both within and across transaction boundaries as long as system-wide cache consistency is maintained. Other recent work on client-server cache consistency <ref> [Wilk90] </ref> has approached the problem from first principles. In that work, two algorithms were developed and analyzed. <p> This algorithm is of interest because it is a simple starting point, it is currently in use in the client-server EXODUS storage manager [Zwil90], and it was also used as a baseline algorithm in <ref> [Wilk90] </ref>. 2.3. Caching Two-Phase Locking (C2PL) The second algorithm is a refinement of B2PL in which inter-transaction data caching is permitted. As in B2PL, all locking and deadlock detection duties are the responsibility of the server. <p> Comparison With Related Work As described in the introduction, the studies most closely related to this one are shared-disk performance studies [Bhid88, Yu87, Dan90], the client-server data caching study that was described in <ref> [Wilk90] </ref>, and the transaction-oriented distributed memory hierarchy work of [Bell90]. <p> Despite these differences, our results on the good performance of O2PL-I as compared with server-locking agree qualitatively with related findings for shared-disk algorithms, such as the success of a semi-optimistic locking scheme in [Yu87]. As for the related client-server caching study in <ref> [Wilk90] </ref>, our study employed a much more detailed buffering model and also covered a wider range of workloads and parameter settings than the work reported there; the importance of both differences should be clear from the results. However, again there is agreement to be found at a qualitative level. <p> However, again there is agreement to be found at a qualitative level. For example, <ref> [Wilk90] </ref> also found that the - 26 - performance of a propagation-based cache consistency algorithm, roughly similar to our O2PL-P algorithm, per-formed badly when propagated data was infrequently referenced.
Reference: [Yu87] <author> Yu, P., et al, </author> <title> "Analysis of Affinity Based Routing in Multi-System Data Sharing, Perf. Evaluation 7, </title> <type> 2, </type> <month> June </month> <year> 1987. </year>
Reference-contexts: Second, we study a broader range of DBMS workloads. Our work is also related to studies of shared-disk architectures, including the work by Bhide [Bhid88] and by a DBMS performance group at IBM Yorktown (reported in <ref> [Yu87, Dan90] </ref> and other related papers). Again, our work differs from these efforts in several ways. First, shared-disk and client-server DBMS architectures are qualitatively different. <p> The server keeps track of which client caches have current copies of which pages. Note that optimistic locking schemes have also been proposed for shared-disk systems, for example, the semi-optimistic ``pass-the-buck'' locking scheme of <ref> [Yu87] </ref>. In the O2PL algorithms, client updates are performed locally, but they are are not permitted to migrate back to the server's buffer pool until the associated update transaction enters its commit phase. <p> Comparison With Related Work As described in the introduction, the studies most closely related to this one are shared-disk performance studies <ref> [Bhid88, Yu87, Dan90] </ref>, the client-server data caching study that was described in [Wilk90], and the transaction-oriented distributed memory hierarchy work of [Bell90]. <p> Also, we have not encountered propagation-based algorithms in the shared-disk literature. Despite these differences, our results on the good performance of O2PL-I as compared with server-locking agree qualitatively with related findings for shared-disk algorithms, such as the success of a semi-optimistic locking scheme in <ref> [Yu87] </ref>. As for the related client-server caching study in [Wilk90], our study employed a much more detailed buffering model and also covered a wider range of workloads and parameter settings than the work reported there; the importance of both differences should be clear from the results.
Reference: [Zwil90] <author> Zwilling, M., </author> <title> Using the EXODUS Storage Manager V2.0 (alpha), EXODUS Project Document, </title> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Prototypes based on object-level interactions include Orion [Kim90] and O2 [Deux90], among others. Among the prototypes based on page-level (or multi-page block) interactions are ObServer [Horn87] and the current version of the EXODUS storage manager <ref> [Care89a, Zwil90] </ref>; the ObjectStore system from Object Design [ODI90] is an example of a commercial OODBMS product based on page-level interactions. <p> This approach, also referred to as the block server approach [Ston90b], was shown to perform well for CAD-style data access patterns in a recent performance study [DeWi90]. Also, our work was motivated by a desire to understand performance tradeoffs in our own page-based, client-server storage managers <ref> [Care89a, Shek90, Zwil90] </ref>. Given this set of cache consistency algorithms, we then describe a detailed simulation model that was developed to study their performance over a wide range of workloads and system resource configurations. The performance of transaction-oriented cache consistency algorithms has been examined in several related contexts. <p> Deadlock resolution involves aborting the transaction with the most recent initial startup time among those involved in the deadlock. This algorithm is of interest because it is a simple starting point, it is currently in use in the client-server EXODUS storage manager <ref> [Zwil90] </ref>, and it was also used as a baseline algorithm in [Wilk90]. 2.3. Caching Two-Phase Locking (C2PL) The second algorithm is a refinement of B2PL in which inter-transaction data caching is permitted. As in B2PL, all locking and deadlock detection duties are the responsibility of the server.
References-found: 31

