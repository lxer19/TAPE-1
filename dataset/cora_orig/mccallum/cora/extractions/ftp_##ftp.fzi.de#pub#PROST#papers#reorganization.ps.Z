URL: ftp://ftp.fzi.de/pub/PROST/papers/reorganization.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Title: III. The Automatic Reorganization of Object Oriented Hierarchies A Case Study  
Author: Eduardo Casais 
Keyword: 3.1 Object-Oriented Design and Redesign 3.1.1 Building Reusable Classes  
Abstract: Software components developed with an object-oriented language require frequent revisions before they become stable, reusable classes. Class evolution is a complex task, and appropriate support in the form of tools and methodologies is required to help software engineers redesign object-oriented libraries. Recently, several approaches have been proposed to restructure inheritance hierarchies, to discover missing abstractions and to enforce programming style guidelines. We describe such an approach and examine in detail the results of its application to the Eiffel library. This analysis gives interesting insights into the suitability of automatic class reorganization for object-oriented software engineering. Object-oriented languages are currently considered as one of the most promising approaches for coping with the problems plaguing software development. This fa-vour finds its explanation in the tight integration of a comprehensive set of abstraction facilities namely, classification, encapsulation, inheritance and delayed binding within a single programming framework [9]. It is generally assumed that these powerful mechanisms, together with a comprehensive set of interactive programming tools provide the basic functionality required for the large-scale production of highly reusable software components. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bruce Anderson and Sanjiv Gossain, </author> <title> Hierarchy Evolution and the Software Lifecycle, </title> <booktitle> in Proc. 2nd TOOLS Conference, </booktitle> <editor> ed. Jean Bzivin, Bertrand Meyer and Jean-Marc Nerson, pp. </editor> <address> 4150, Paris, </address> <year> 1990. </year>
Reference-contexts: It should 68 Eduardo Casais therefore be used sparingly, and every utilization of this mechanism should warrant a serious attempt to find an alternative design. An important conclusion is the fact that, as suggested in one previous research on class evolution <ref> [1] </ref>, further reorganization is unavoidable even after repeatedly recasting a hierarchy. Factorising abstractions out of concrete, specialized descriptions and discovering intermediate modelling concepts are essential activities during object-oriented programming [15]; we therefore expect reorganization algorithms to fulfil a significant role as an interactive tool for object-oriented design and maintenance.
Reference: [2] <author> Jay Banerjee, Won Kim, Hyoung-Joo Kim and Henry F. Korth, </author> <title> Semantics and Implementation of Schema Evolution in Object-Oriented Databases, </title> <journal> SIGMOD Record (special issue on SIGMOD 87), </journal> <volume> vol. 16, no. 3, </volume> <pages> pp. 311322, </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1987. </year>
Reference: [3] <author> Gilles Barbedette, </author> <title> Schema Modification in the LISPO 2 Persistent Object-Oriented Language, </title> <booktitle> in Proc. 5th ECOOP Conference, </booktitle> <editor> ed. Pierre America, </editor> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 512, </volume> <pages> pp. 77-96, </pages> <publisher> Springer Verlag, </publisher> <address> Geneva, </address> <month> 15-19 July </month> <year> 1991. </year>
Reference: [4] <author> Anders Bjrnerstedt and Christer Hultn, </author> <title> Version Control in an Object-Oriented Architecture, in Object-Oriented Concepts, Databases, and Applications, </title> <editor> ed. Won Kim and Frederic H. Lochovsky, </editor> <booktitle> Frontier Series, </booktitle> <pages> pp. 451485, </pages> <publisher> Addison-Wesley/ACM Press, </publisher> <year> 1989. </year>
Reference: [5] <author> Eduardo Casais, </author> <title> An Incremental Class Reorganization Approach, </title> <booktitle> in Proc. 6th ECOOP Conference, </booktitle> <editor> ed. Ole Lehrmann Madsen, </editor> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 615, </volume> <pages> pp. 114-132, </pages> <publisher> Springer Verlag, </publisher> <address> Utrecht 29 June-3 July 1992. </address>
Reference-contexts: The question whether our factorisation algorithm uncovers all situations where it can be applied successfully is easily settled <ref> [5] </ref>. Because the algorithm works incrementally and manipulates only local information, it cannot extract missing abstractions when the definitions to be compared are located in disjoint subclassing paths. To achieve this goal, one must resort to global restructuring algorithms that operate on the entire inheritance graph 1 [12].
Reference: [6] <author> Eduardo Casais, </author> <title> Managing Evolution in Object-Oriented Environments: An Algorithmic Approach, </title> <type> PhD Thesis, </type> <institution> Universit de Genve, Geneva, </institution> <year> 1991. </year>
Reference-contexts: The final illustration shows the new class ACE with the additional nodes A and C needed for its integration in the hierarchy. It should be noted that the more general factorisation procedure extracts more complex information from subclassing patterns to build the auxiliary nodes <ref> [6] </ref>. <p> To achieve this goal, one must resort to global restructuring algorithms that operate on the entire inheritance graph 1 [12]. However, it should be noted that glo 1. The conditions under which an incremental factorisation produces the same (optimal) results as a global reorganization are discussed in <ref> [6] </ref>.
Reference: [7] <author> William R. Cook, </author> <title> Interfaces and Specifications for the Smalltalk-80 Collection Classes, </title> <journal> SIGPLAN Notices (special issue on OOPSLA 92), </journal> <volume> vol. 27, nr. 10, </volume> <pages> pp. 1-15, </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year> <note> 70 Eduardo Casais </note>
Reference-contexts: Thus, an analysis has shown that 5 additional abstractions are necessary to restructure the Smalltalk collection hierarchy (originally comprising 12 components) so as to enforce behavioural compatibility between classes a 42% increase in the size of the library <ref> [7] </ref>. Carrying out the same analysis on the basis of purely syntactical elements produces an almost identical, albeit imperfect hierarchy containing 6 supplementary definitions i.e. 50% more classes.
Reference: [8] <author> Bernard Coulange and Alain Roan, </author> <title> Object-Oriented Techniques at Work: Facts and Statistics, </title> <booktitle> in Proceedings 10th TOOLS Conference, </booktitle> <editor> Versailles, eds. Boris Magnusson, Bertrand Meyer and Jean-Franois Perrot, </editor> <publisher> Prentice-Hall, </publisher> <year> 1993, </year> <pages> pp. 89-94. </pages>
Reference-contexts: For classes with large interfaces, there is a greater probability of finding some identical methods in the list of exported features, as well as 1. For an alternative view on the structural characteristics of very large object-oriented libraries, the reader is referred to <ref> [8] </ref>, which includes a comprehensive compilation of statistics describing a system written in an Eiffel-like language. 100755025 Introduced classes 25 75 Additional auxiliary classes and all other graphs the original classes of the Eiffel library are introduced according to the topological sort described in 3.3.1.
Reference: [9] <author> Adele Goldberg and Daniel Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference: [10] <author> Daniel C. Halbert and Patrick D. OBrien, </author> <title> Using Types and Inheritance in Object-Oriented Programming, </title> <journal> IEEE Software, </journal> <pages> pp. 7179, </pages> <publisher> IEEE, </publisher> <month> September </month> <year> 1987. </year>
Reference: [11] <author> Ralph E. Johnson and Brian Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pp. 2235, </pages> <month> June-July </month> <year> 1988. </year>
Reference: [12] <author> Karl J. Lieberherr, Paul Bergstein and Ignacio Silva-Lepe, </author> <title> From Objects to Classes: Algorithms for Optimal Object-Oriented Design, </title> <journal> BCS/IEE Software Engineering Journal, </journal> <pages> pp. 205-228, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Because the algorithm works incrementally and manipulates only local information, it cannot extract missing abstractions when the definitions to be compared are located in disjoint subclassing paths. To achieve this goal, one must resort to global restructuring algorithms that operate on the entire inheritance graph 1 <ref> [12] </ref>. However, it should be noted that glo 1. The conditions under which an incremental factorisation produces the same (optimal) results as a global reorganization are discussed in [6].
Reference: [13] <author> K. Lieberherr, I. Holland and A. Riel, </author> <title> Object-Oriented Programming: an Objective Sense of Style, </title> <journal> SIGPLAN Notices (special issue on OOPSLA 88), </journal> <volume> vol. 23, no. 11, </volume> <pages> pp. 323334, </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1988. </year>
Reference: [14] <author> Bertrand Meyer, </author> <title> Object-Oriented Software Construction, </title> <booktitle> Series in Computer Science, Prentice-Hall International, </booktitle> <year> 1988. </year>
Reference-contexts: All other attributes remain hidden inside objects. Interfaces, method signatures and pre and post-conditions are instrumental in enforcing a discipline of programming by contract and in achieving modularization <ref> [14] </ref>. As a consequence, interfaces, together with inheritance relationships, should suffice to get a good understanding of how functionality is organized in an object-oriented library. However, this assumption holds only if the relationships between the interface of a subclass and those of its ancestors follow some regular patterns.
Reference: [15] <author> Bertrand Meyer, </author> <title> Tools for the New Culture: Lessons from the Design of the Eiffel Libraries, </title> <journal> Communications of the ACM, </journal> <volume> vol. 33, no. 9, </volume> <pages> pp. 6888, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Eiffel is an interesting case to study: the language was designed around high-level constructs and with an elegant syntax, in order to promote good programming practices; the library has undergone major redesigns, which have been partly documented <ref> [15] </ref>; and its designers attitude towards object-oriented design often departs from mainstream approaches. First, various utility programs were used to parse the source code of all classes in the library and to transform it into a representation suitable for manipulation by the LISP program. <p> Actually, the designers of Eiffel acknowledged that version 2.1 of the system lacked consistency in the terminology used for naming classes and their services <ref> [15] </ref> a problem that shows up for example when related data structures export analogous operations under different names, ultimately resulting in decompositions. <p> A case in point are the two window classes present in the Eiffel library one dealing with character-oriented terminals, the other interfacing with X-Windows that do not derive from a common window abstraction <ref> [15] </ref>. 3.4.3 Future Issues Our study of the automatic reorganization of the Eiffel library mostly confirms design guidelines advocated by developers of object-oriented libraries [11][15]: classes with small interfaces are easier to understand and to use more complex functionality is better distributed among several components; method signatures must be standardized according <p> An important conclusion is the fact that, as suggested in one previous research on class evolution [1], further reorganization is unavoidable even after repeatedly recasting a hierarchy. Factorising abstractions out of concrete, specialized descriptions and discovering intermediate modelling concepts are essential activities during object-oriented programming <ref> [15] </ref>; we therefore expect reorganization algorithms to fulfil a significant role as an interactive tool for object-oriented design and maintenance.
Reference: [16] <author> William F. Opdyke, </author> <title> Refactoring Object-Oriented Frameworks, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Finally, it is doubtful that a global reorganization can achieve significantly better results without additional processing to extract the structural similarities between class interfaces or method signatures that are hidden because of diverging naming and programming conventions <ref> [16] </ref>. <p> The statistics presented in table 3 show that this approach, focusing on inheritance relationships, must nevertheless be supplemented with methods for analysing and standardising naming and signature patterns among classes, and for transforming inadequate inheritance links into component relationships <ref> [16] </ref>. The question of performance after reorganizations remains to be settled.
Reference: [17] <author> D. Jason Penney and Jacob Stein, </author> <title> Class Modification in the GemStone Object-Oriented DBMS, </title> <journal> SIGPLAN Notices (special issue on OOPSLA 87), </journal> <volume> vol. 22, no. 12, </volume> <pages> pp. 111 117, </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1987. </year>
Reference: [18] <author> Emmanuel Waller, </author> <title> Schema Updates and Consistency, </title> <booktitle> in DOOD91 Proceedings, </booktitle> <editor> eds. Claude Delobel, Michael Kifer and Yoshifumi Yasunaga, Springer Verlag, </editor> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 566, </volume> <month> December </month> <year> 1991, </year> <pages> pp. 167188. </pages>
Reference-contexts: On the other hand, replacing inheritance links with component relationships introduce additional indirections that can be difficult to get rid of for example with code inlining techniques. Finally, there are important issues related to the preservation of class behaviour across reorganizations which, so far, have been addressed only partially <ref> [18] </ref>. Building an effective object-oriented redesign environment requires integrating the various approaches to class evolution discussed in the introduction incremental reorganization, refactoring, class modification primitives and versioning with browsing and debugging utilities.
Reference: [19] <author> Roberto Zicari, </author> <title> A Framework for Schema Updates in an Object-Oriented Database System, in Building an Object-Oriented Database System The Story of O 2 , eds. </title> <editor> Franois Bancilhon, Claude Delobel and Paris Kanellakis, </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1992, </year> <pages> pp. 146182. </pages>
References-found: 19

