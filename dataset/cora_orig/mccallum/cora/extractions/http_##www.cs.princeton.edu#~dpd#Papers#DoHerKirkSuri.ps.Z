URL: http://www.cs.princeton.edu/~dpd/Papers/DoHerKirkSuri.ps.Z
Refering-URL: http://www.cs.princeton.edu/~dpd/Research.html
Root-URL: http://www.cs.princeton.edu
Title: Computing the Intersection-Depth of Polyhedra  
Author: David Dobkin John Hershberger David Kirkpatrick Subhash Suri 
Abstract: Given two intersecting polyhedra P , Q and a direction d, find the smallest translation of Q along d that renders the interiors of P and Q disjoint. The same problem can also be posed without specifying the direction, in which case the minimum translation over all directions is sought. These are fundamental problems that arise in robotics and computer vision. We develop techniques for implicitly building and searching convolutions and apply them to derive efficient algorithms for these problems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Agarwal. </author> <title> Ray shooting and other applications of spanning trees with low stabbing number. </title> <booktitle> Proc. of 5th ACM Symposium on Computational Geometry, </booktitle> <pages> 315-325, </pages> <year> 1989. </year>
Reference-contexts: Finding d (P; Q q ) is a ray-shooting problem: we want to find the first point where the ray 10 q+td hits the boundary of R. After some preprocessing, we can apply the ray-shooting techniques of Guibas, Overmars and Sharir [19] and Agarwal <ref> [1] </ref>. The preprocessing takes O (n log n + m) time and O (n + m) space; queries take O (n 2=3+ffi + log m) time, for ffi &gt; 0 and arbitrarily small. <p> The point of intersection can be found in O (log m) time. To prepare R for ray-shooting, we cut off all its ears. This leaves a polygonal region bounded by O (n) line segments. We preprocess this region for ray-shooting <ref> [1, 19] </ref>, which takes O (n log n) time and O (n) space. We also preprocess the ears for point location; the preprocessing takes O (n log (n + m)), after which a point location query can be answered in O (log (n + m)) time [15].
Reference: [2] <author> A. Aggarwal, L. Guibas, J. Saxe, and P. Shor. </author> <title> A linear time algorithm for computing the Voronoi diagram of a convex polygon. </title> <journal> Discrete and Computational Geometry, </journal> <volume> 4 </volume> <pages> 591-604, </pages> <year> 1989. </year>
Reference-contexts: To handle these queries, we compute the medial axis of the polygon P (Q) and build a point-location structure for it, using O (n) time altogether <ref> [2, 15, 26] </ref>. (The medial axis of a polygon P is the locus of all points in P that are equidistant from at least two points on the boundary of P . <p> The medial axis of a convex polygon of n vertices can be computed in O (n) time <ref> [2] </ref>.) Given a query placement Q y , we can find the closest point to y on the boundary of P (Q) in O (log n) time by point location in the medial-axis diagram. This establishes the following theorem.
Reference: [3] <author> T. Asano. </author> <title> An efficient algorithm for finding the visibility polygons for a polygonal region with holes. </title> <journal> Transactions of IECE of Japan, </journal> <volume> E-68:557-559, </volume> <year> 1985. </year>
Reference-contexts: We start by computing an implicit representation of the visibility polygon V of q with respect to the boundary of R. This takes O (n log (n + m)) time and O (n + m) space using a variant of a standard visibility polygon algorithm <ref> [3, 30] </ref>, which we now describe. On each arc of Q in the implicit representation of R, there are at most two points x such that the ray * qx is tangent to the arc. We find these points in O (n log m) time altogether.
Reference: [4] <author> B. S. Baker, S. F. Fortune and S. R. Mahaney. </author> <title> Polygon containment under translation. </title> <journal> Journal of Algorithms, </journal> <pages> 532-548, </pages> <year> 1986. </year>
Reference-contexts: 2 ) time? How fast can the minimum intersection-depth be computed for two nonconvex polygons? An O (n 4 ) time bound can be obtained by explicitly computing the convolution of the two polygons. (The convolution of two n-vertex polygons can have (n 4 ) size in the worst case <ref> [4] </ref>, and so a sub-quartic algorithm must avoid building the entire convolution.) Can some nontrivial lower bounds be proved for these problems? For two convex polyhedra P and Q in three dimensions, we gave an O (log 2 n) time procedure for determining the directional depth of intersection.
Reference: [5] <author> J. Bentley and T. A. Ottman. </author> <title> Algorithms for reporting and counting geometric intersections, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28:643-647, </volume> <year> 1979. </year>
Reference-contexts: The algorithm we use is due to Ottman, Widmeyer and Wood [28], which in turn is based on a technique of Bentley and Ottman <ref> [5] </ref> for counting and reporting the intersections in a collection of planar line segments.
Reference: [6] <author> C. E. Buckley and L. J. Leifer. </author> <title> A proximity metric for continuum path planning. </title> <booktitle> Proc. 9th International Joint Conference on Artificial Intelligence, </booktitle> <pages> 1096-1102, </pages> <year> 1985. </year>
Reference-contexts: Whenever two objects intersect, this distance measure is zero. Thus, it fails to provide any information about the extent of penetration. The notion of negative distance has been proposed by Buckley and Leifer <ref> [6] </ref> and Cameron and Cul-ley [7] to rectify this discrepancy. We follow Keerthi and Sridharan [25] and define the following measure of negative distance. fl Department of Computer Science, Princeton University, NJ 08544, U.S.A., and Bell Communications Research, Morristown, NJ 07960, U.S.A.
Reference: [7] <author> S. A. Cameron and R. K. Culley. </author> <title> Determining the minimum translation distance between two convex polyhedra. </title> <booktitle> Proc. IEEE International Conference on Robotics and Automation, </booktitle> <pages> 591-596, </pages> <year> 1986. </year>
Reference-contexts: Whenever two objects intersect, this distance measure is zero. Thus, it fails to provide any information about the extent of penetration. The notion of negative distance has been proposed by Buckley and Leifer [6] and Cameron and Cul-ley <ref> [7] </ref> to rectify this discrepancy. We follow Keerthi and Sridharan [25] and define the following measure of negative distance. fl Department of Computer Science, Princeton University, NJ 08544, U.S.A., and Bell Communications Research, Morristown, NJ 07960, U.S.A. <p> The minimum intersection-depth between P and Q, denoted (P; Q), is defined as the minimum of d (P; Q) over all directions d. The definition of (P; Q) agrees with the measure proposed by Cameron and Culley <ref> [7] </ref>. The fixed-direction intersection-depth problem can be reduced to a separation problem: move one of the polyhedra sufficiently far in direction d to ensure that the two polyhedra are disjoint, and then find their directional separation. The intersection-depth can be inferred by subtracting the separation from the initial displacement. <p> The problem of computing the intersection-depth between two intersecting objects is addressed by Cameron and Culley <ref> [7] </ref>; however, the complexity of their algorithm is not analyzed. Keerthi and Sridharan [25] consider the problem for two convex polygons.
Reference: [8] <author> B. Chazelle. </author> <title> Efficient polygon triangulation. </title> <booktitle> Proc. of IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> 220-230, </pages> <year> 1990. </year>
Reference-contexts: Step 1 is easily accomplished in O (n log n) time, using any of the well-known triangulation algorithms [17, 23]; in fact the time complexity can be reduced to O (n) using a recent algorithm of Chazelle <ref> [8] </ref>. Pick a reference point r i for each of the triangles T i ; for instance, we may pick the vertex closest to the origin. Step 2 computes an implicit representation of the convolutions of these triangles with the convex polygon (Q).
Reference: [9] <author> B. Chazelle and D. Dobkin. </author> <title> Intersection of convex objects in two and three dimensions. </title> <journal> J. of ACM, </journal> <volume> 34 </volume> <pages> 1-27, </pages> <year> 1987. </year>
Reference-contexts: We can also perform a binary search directly in the object space, rather than the convolution (i.e., the configuration space) to compute d (P; Q), using a method similar to Chazelle and Dobkin's method for detecting the intersection between two convex polygons <ref> [9] </ref>. The procedure repeatedly selects the median edges on the two polygonal chains and then, based on some local computations involving the median edges, discards half of one of the chains. For further details, we refer the reader to [9]. <p> and Dobkin's method for detecting the intersection between two convex polygons <ref> [9] </ref>. The procedure repeatedly selects the median edges on the two polygonal chains and then, based on some local computations involving the median edges, discards half of one of the chains. For further details, we refer the reader to [9]. Next, to solve the problem of finding the minimum intersection-depth over all directions, we first compute the convolution P (Q), in O (n) time; we assume 4 that each of the polygons has at most n vertices.
Reference: [10] <author> F. Chin and C. A. Wang. </author> <title> Optimal algorithms for the intersection and the minimum distance problems between planar polygons. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-32:1203-1207, </volume> <year> 1983. </year>
Reference-contexts: Consider, for instance, the problem of collision detection in robot motion planning. The Euclidean distance is a commonly used measure in these areas. Numerous efficient algorithms are known for computing the minimum distance between two polyhedra in two and three dimensions (see <ref> [10, 12, 14] </ref>). Whenever two objects intersect, this distance measure is zero. Thus, it fails to provide any information about the extent of penetration. The notion of negative distance has been proposed by Buckley and Leifer [6] and Cameron and Cul-ley [7] to rectify this discrepancy.
Reference: [11] <author> D. Dobkin and D. Kirkpatrick. </author> <title> Fast detection of polyhedral intersections. </title> <booktitle> Proc. of ICALP '82, </booktitle> <pages> 154-165, </pages> <year> 1982. </year> <note> Lecture Notes in Computer Science 140. </note>
Reference-contexts: For suitably preprocessed polyhedra P and Q, we can determine d (P; Q) in time O (log n log m), for any direction d. The representation assumed for the polyhedra is the hierarchical representation, originally proposed by Dobkin and Kirkpatrick <ref> [11, 12, 13] </ref>, which can be built in linear time. The unifying idea in all our algorithms is implicitly searching the convolution of two polytopes. It is well known that if two polytopes P and Q intersect, then the difference of their reference vectors lies in their convolution [21]. <p> We show that if P and Q are suitably preprocessed, then their directional intersection-depth can be determined in O (log 2 n) time. The representation of each polyhedron consists of an inner polyhedral hierarchy and an outer polyhedral hierarchy. These hierarchical representations were introduced by Dobkin and Kirkpatrick <ref> [11, 12, 13] </ref>, who used them for determining the separation of two convex polyhedra. <p> Using the hierarchical representation of a polytope, we can answer various extremal queries involving points, lines or planes in logarithmic time. These queries are later used by our intersection-depth algorithm. The reader may refer to the papers of Dobkin and Kirkpatrick <ref> [11, 13] </ref> or the book by Mehlhorn [27] for proofs of the following lemmas. Lemma 5.2 Given a directed line l, we can find its first intersection with P i , for any 1 i k, in O (log n) time.
Reference: [12] <author> D. Dobkin and D. Kirkpatrick. </author> <title> A linear algorithm for determining the separation of convex polyhedra. </title> <journal> J. of Algorithms, </journal> <volume> 6 </volume> <pages> 381-392, </pages> <year> 1985. </year>
Reference-contexts: Consider, for instance, the problem of collision detection in robot motion planning. The Euclidean distance is a commonly used measure in these areas. Numerous efficient algorithms are known for computing the minimum distance between two polyhedra in two and three dimensions (see <ref> [10, 12, 14] </ref>). Whenever two objects intersect, this distance measure is zero. Thus, it fails to provide any information about the extent of penetration. The notion of negative distance has been proposed by Buckley and Leifer [6] and Cameron and Cul-ley [7] to rectify this discrepancy. <p> For suitably preprocessed polyhedra P and Q, we can determine d (P; Q) in time O (log n log m), for any direction d. The representation assumed for the polyhedra is the hierarchical representation, originally proposed by Dobkin and Kirkpatrick <ref> [11, 12, 13] </ref>, which can be built in linear time. The unifying idea in all our algorithms is implicitly searching the convolution of two polytopes. It is well known that if two polytopes P and Q intersect, then the difference of their reference vectors lies in their convolution [21]. <p> We show that if P and Q are suitably preprocessed, then their directional intersection-depth can be determined in O (log 2 n) time. The representation of each polyhedron consists of an inner polyhedral hierarchy and an outer polyhedral hierarchy. These hierarchical representations were introduced by Dobkin and Kirkpatrick <ref> [11, 12, 13] </ref>, who used them for determining the separation of two convex polyhedra.
Reference: [13] <author> D. Dobkin and D. Kirkpatrick. </author> <title> Determining the separation of preprocessed polyhedra|a unified approach. </title> <booktitle> Proc. of ICALP '90, </booktitle> <pages> 400-413, </pages> <year> 1990. </year> <note> Lecture Notes in Computer Science 443. </note>
Reference-contexts: For suitably preprocessed polyhedra P and Q, we can determine d (P; Q) in time O (log n log m), for any direction d. The representation assumed for the polyhedra is the hierarchical representation, originally proposed by Dobkin and Kirkpatrick <ref> [11, 12, 13] </ref>, which can be built in linear time. The unifying idea in all our algorithms is implicitly searching the convolution of two polytopes. It is well known that if two polytopes P and Q intersect, then the difference of their reference vectors lies in their convolution [21]. <p> We show that if P and Q are suitably preprocessed, then their directional intersection-depth can be determined in O (log 2 n) time. The representation of each polyhedron consists of an inner polyhedral hierarchy and an outer polyhedral hierarchy. These hierarchical representations were introduced by Dobkin and Kirkpatrick <ref> [11, 12, 13] </ref>, who used them for determining the separation of two convex polyhedra. <p> Using the hierarchical representation of a polytope, we can answer various extremal queries involving points, lines or planes in logarithmic time. These queries are later used by our intersection-depth algorithm. The reader may refer to the papers of Dobkin and Kirkpatrick <ref> [11, 13] </ref> or the book by Mehlhorn [27] for proofs of the following lemmas. Lemma 5.2 Given a directed line l, we can find its first intersection with P i , for any 1 i k, in O (log n) time.
Reference: [14] <author> H. Edelsbrunner. </author> <title> Computing the extreme distances between two convex polygons. </title> <journal> J. of Algorithms, </journal> <volume> 6 </volume> <pages> 213-224, </pages> <year> 1985. </year>
Reference-contexts: Consider, for instance, the problem of collision detection in robot motion planning. The Euclidean distance is a commonly used measure in these areas. Numerous efficient algorithms are known for computing the minimum distance between two polyhedra in two and three dimensions (see <ref> [10, 12, 14] </ref>). Whenever two objects intersect, this distance measure is zero. Thus, it fails to provide any information about the extent of penetration. The notion of negative distance has been proposed by Buckley and Leifer [6] and Cameron and Cul-ley [7] to rectify this discrepancy.
Reference: [15] <author> H. Edelsbrunner, L. Guibas, and J. Stolfi. </author> <title> Optimal point location in a monotone subdivision. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15 </volume> <pages> 317-340, </pages> <year> 1986. </year>
Reference-contexts: To handle these queries, we compute the medial axis of the polygon P (Q) and build a point-location structure for it, using O (n) time altogether <ref> [2, 15, 26] </ref>. (The medial axis of a polygon P is the locus of all points in P that are equidistant from at least two points on the boundary of P . <p> We also preprocess the ears for point location; the preprocessing takes O (n log (n + m)), after which a point location query can be answered in O (log (n + m)) time <ref> [15] </ref>. At query time, we try to locate q in the ears. If q lies in an ear, we check whether q + td hits the arc or the segment of the ear. If it hits the arc, we are done.
Reference: [16] <author> H. El Gindy and D. Avis. </author> <title> A linear algorithm for computing the visibility polygon from a point. </title> <journal> J. of Algorithms, </journal> <volume> 2 </volume> <pages> 186-197, </pages> <year> 1981. </year>
Reference-contexts: The horizontal separation can be inferred from the visibility profile, and by subtracting it from the initial displacement we arrive at the complete separation. The procedure runs in linear time since we can compute the horizontal visibility profile in O (n) time using a standard visibility-polygon algorithm <ref> [16] </ref>. (The key observation here is that since P and Q are separated by a vertical line, it suffices to consider the horizontal visibility profile of only the left and right envelopes of P and Q; the vertices not on the envelopes don't matter.
Reference: [17] <author> M. Garey, D. S. Johnson, F. P. Preparata and R. E. Tarjan. </author> <title> Triangulating a simple polygon. </title> <journal> Information Processing Letters, </journal> <volume> 7 </volume> <pages> 175-179, </pages> <year> 1978. </year>
Reference-contexts: Step 1 is easily accomplished in O (n log n) time, using any of the well-known triangulation algorithms <ref> [17, 23] </ref>; in fact the time complexity can be reduced to O (n) using a recent algorithm of Chazelle [8]. Pick a reference point r i for each of the triangles T i ; for instance, we may pick the vertex closest to the origin.
Reference: [18] <author> B. Grunbaum. </author> <title> Convex Polytopes. </title> <publisher> John Wiley and Sons, Ltd. </publisher> <year> 1967. </year>
Reference-contexts: distance between q and the boundary of P (Q): (P; Q q ) = min (t 0 j 9d with jdj = 1 and q + td =2 P (Q)): (2) 3 Convex Polygons It is well known that the Minkowski sum of two convex polyhedra is a convex polyhedron <ref> [18] </ref>. In two dimensions, if P and Q are convex polygons of n and m vertices, respectively, then P Q is a convex polygon of n+m vertices; an exception occurs if P and Q have parallel edges, in which case the convolved polygon has fewer than n + m vertices.
Reference: [19] <author> L. Guibas, M. Overmars, and M. Sharir. </author> <title> Intersecting line segments, ray shooting, and other applications of geometric partitioning techniques. </title> <booktitle> In Proc. of the First Scandinavian Workshop on Algorithm Theory, </booktitle> <pages> pages 64-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Lecture Notes in Computer Science 318. </note>
Reference-contexts: Finding d (P; Q q ) is a ray-shooting problem: we want to find the first point where the ray 10 q+td hits the boundary of R. After some preprocessing, we can apply the ray-shooting techniques of Guibas, Overmars and Sharir <ref> [19] </ref> and Agarwal [1]. The preprocessing takes O (n log n + m) time and O (n + m) space; queries take O (n 2=3+ffi + log m) time, for ffi &gt; 0 and arbitrarily small. <p> The point of intersection can be found in O (log m) time. To prepare R for ray-shooting, we cut off all its ears. This leaves a polygonal region bounded by O (n) line segments. We preprocess this region for ray-shooting <ref> [1, 19] </ref>, which takes O (n log n) time and O (n) space. We also preprocess the ears for point location; the preprocessing takes O (n log (n + m)), after which a point location query can be answered in O (log (n + m)) time [15].
Reference: [20] <author> L. Guibas, L. Ramshaw and J. Stolfi. </author> <title> A kinetic framework for computational geometry. </title> <booktitle> Proc. 24th Foundations of Computer Science, </booktitle> <pages> 100-111, </pages> <month> Nov. </month> <year> 1983. </year> <month> 18 </month>
Reference-contexts: In the plane, P Q has a particularly simple characterization: its edges are those of P and Q, merged in slope order <ref> [20] </ref>. This fact allows one to compute P Q in linear time. Theorem 3.1 ([20]) Given two convex polygons P and Q, with n and m vertices, respectively, we can compute their convolution P Q in time O (n + m). <p> Recall that if A and B are two convex polygons, then the boundary of A B consists of edges of A and B merged in slope order <ref> [20] </ref>. To compute T i (Q), therefore, we need only to locate the slopes of each of the three edges of T i among the slopes of the edges of (Q), which takes three binary searches and O (log m) time.
Reference: [21] <author> L. J. Guibas and J. Stolfi. Ruler, </author> <title> compass, and computer: The design and analysis of geometric algorithms. </title> <note> Research Report 37, DEC Systems Research Center, 1989. Also appeared in Theoretical Foundations of Computer Graphics and CAD, Springer-Verlag. </note>
Reference-contexts: The unifying idea in all our algorithms is implicitly searching the convolution of two polytopes. It is well known that if two polytopes P and Q intersect, then the difference of their reference vectors lies in their convolution <ref> [21] </ref>. In fact, the problem 2 of computing the intersection-depth reduces to calculating the distance between the boundary of a convolution and a point inside it. <p> The directional intersection-depth between P and Q can be computed by implicitly building that portion of P (Q) that intersects the ray from q in direction d. Guibas and Stolfi <ref> [21] </ref> use a similar method to detect whether two given convex polygons intersect. Observe that testing whether P intersects Q q is equivalent to checking if q 2 P (Q).
Reference: [22] <author> J. Hershberger and L. Guibas. </author> <title> An O(n 2 ) shortest path algorithm for a nonrotating convex body. </title> <journal> Journal of Algorithms, </journal> <volume> 9 </volume> <pages> 18-46, </pages> <year> 1988. </year>
Reference-contexts: Fortunately, a result of Kedem et al. [24] shows that a collection of convolved triangles is "well-behaved"; we use that result to construct a linear-space implicit representation of the boundary of R. Our approach is similar in spirit to that of Hershberger and Guibas <ref> [22] </ref>. We use the following two facts proved in Kedem et al. [24]. Fact 4.1 ([24], p. 66) Let A 1 and A 2 be two convex polygons with disjoint interiors, and let B be another convex polygon.
Reference: [23] <author> S. Hertel and K. Mehlhorn. </author> <title> Fast triangulation of simple polygons. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 158, </volume> <pages> 207-218, </pages> <year> 1983. </year>
Reference-contexts: Step 1 is easily accomplished in O (n log n) time, using any of the well-known triangulation algorithms <ref> [17, 23] </ref>; in fact the time complexity can be reduced to O (n) using a recent algorithm of Chazelle [8]. Pick a reference point r i for each of the triangles T i ; for instance, we may pick the vertex closest to the origin.
Reference: [24] <author> K. Kedem, R. Livne, J. Pach and M. Sharir. </author> <title> On the union of Jordan regions and collision-free translational motion amidst polygonal obstacles. </title> <journal> Discrete and Computational Geometry, </journal> <volume> 1 </volume> <pages> 59-71, </pages> <year> 1986. </year>
Reference-contexts: This alone still does not suffice since, in general, even the boundary of the union of s triangles can have quadratic size. Fortunately, a result of Kedem et al. <ref> [24] </ref> shows that a collection of convolved triangles is "well-behaved"; we use that result to construct a linear-space implicit representation of the boundary of R. Our approach is similar in spirit to that of Hershberger and Guibas [22]. We use the following two facts proved in Kedem et al. [24]. <p> al. <ref> [24] </ref> shows that a collection of convolved triangles is "well-behaved"; we use that result to construct a linear-space implicit representation of the boundary of R. Our approach is similar in spirit to that of Hershberger and Guibas [22]. We use the following two facts proved in Kedem et al. [24]. Fact 4.1 ([24], p. 66) Let A 1 and A 2 be two convex polygons with disjoint interiors, and let B be another convex polygon. Then the boundaries of A 1 B and A 2 B intersect in at most two points. Fact 4.2 ([24], p. 61) Let A i
Reference: [25] <author> S. S. Keerthi and K. Sridharan. </author> <title> Efficient algorithms for computing two measures of depth of collision between convex polygons. </title> <type> Technical Report, </type> <institution> Department of Computer Science and Automation, IIS, Banglore, India, </institution> <year> 1989. </year>
Reference-contexts: Whenever two objects intersect, this distance measure is zero. Thus, it fails to provide any information about the extent of penetration. The notion of negative distance has been proposed by Buckley and Leifer [6] and Cameron and Cul-ley [7] to rectify this discrepancy. We follow Keerthi and Sridharan <ref> [25] </ref> and define the following measure of negative distance. fl Department of Computer Science, Princeton University, NJ 08544, U.S.A., and Bell Communications Research, Morristown, NJ 07960, U.S.A. <p> The problem of computing the intersection-depth between two intersecting objects is addressed by Cameron and Culley [7]; however, the complexity of their algorithm is not analyzed. Keerthi and Sridharan <ref> [25] </ref> consider the problem for two convex polygons. Given two intersecting convex polygons P and Q of n and m vertices, respectively, they propose an O (log n log m) time algorithm for computing the directional intersection-depth, d (P; Q).
Reference: [26] <author> D. Kirkpatrick. </author> <title> Optimal search in planar subdivisions. </title> <journal> SIAM Journal on Computing, </journal> <volume> 12 </volume> <pages> 28-35, </pages> <year> 1983. </year>
Reference-contexts: To handle these queries, we compute the medial axis of the polygon P (Q) and build a point-location structure for it, using O (n) time altogether <ref> [2, 15, 26] </ref>. (The medial axis of a polygon P is the locus of all points in P that are equidistant from at least two points on the boundary of P .
Reference: [27] <author> K. Mehlhorn. </author> <title> Multi-dimensional Searching and Computational Geometry, </title> <booktitle> EATCS Monographs on Theoretical Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Using the hierarchical representation of a polytope, we can answer various extremal queries involving points, lines or planes in logarithmic time. These queries are later used by our intersection-depth algorithm. The reader may refer to the papers of Dobkin and Kirkpatrick [11, 13] or the book by Mehlhorn <ref> [27] </ref> for proofs of the following lemmas. Lemma 5.2 Given a directed line l, we can find its first intersection with P i , for any 1 i k, in O (log n) time. Lemma 5.3 Suppose l is a line translating from infinity in direction d.
Reference: [28] <author> T. A. Ottman, P. Widmeyer and D. Wood. </author> <title> A fast algorithm for Boolean mask operations. </title> <institution> Inst. f. Angewandte Mathematik und Formale Beschreibungsverfahren, D-7500 Karlsruhe, </institution> <note> Report no. 112, </note> <year> 1982. </year>
Reference-contexts: The algorithm we use is due to Ottman, Widmeyer and Wood <ref> [28] </ref>, which in turn is based on a technique of Bentley and Ottman [5] for counting and reporting the intersections in a collection of planar line segments.
Reference: [29] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Computing the boundary of the union of two sets of polygons, each set free of self-intersections, is the boolean mask operation we use. Readers unfamiliar with the paradigm of plane sweep are encouraged to refer to Preparata and Shamos <ref> [29] </ref>.) In our case, the collection consists of straight-line segments as well as implicitly represented arcs of a convex polygon. The algorithm of Ottman et al. works just as efficiently in this setting too, with one minor modification.
Reference: [30] <author> S. Suri and J. O'Rourke. </author> <title> Worst-case optimal algorithms for constructing visibility polygons with holes. </title> <booktitle> Proc. of 2nd ACM Symposium on Computational Geometry, </booktitle> <pages> 14-23, </pages> <year> 1986. </year>
Reference-contexts: We start by computing an implicit representation of the visibility polygon V of q with respect to the boundary of R. This takes O (n log (n + m)) time and O (n + m) space using a variant of a standard visibility polygon algorithm <ref> [3, 30] </ref>, which we now describe. On each arc of Q in the implicit representation of R, there are at most two points x such that the ray * qx is tangent to the arc. We find these points in O (n log m) time altogether.
References-found: 30

