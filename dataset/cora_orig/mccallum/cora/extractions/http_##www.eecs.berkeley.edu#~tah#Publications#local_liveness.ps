URL: http://www.eecs.berkeley.edu/~tah/Publications/local_liveness.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/local_liveness.html
Root-URL: 
Phone: 2  
Title: Local Liveness for Compositional Modeling of Fair Reactive Systems  
Author: Rajeev Alur and Thomas A. Henzinger ?? 
Address: Murray Hill, NJ  Ithaca, NY  
Affiliation: 1 AT&T Bell Laboratories,  Department of Computer Science, Cornell University,  
Abstract: We argue that the standard constraints on liveness conditions in nonblocking trace models|machine closure for closed systems, and receptiveness for open systems|are unnecessarily weak and complex, and that liveness should, instead, be specified by augmenting transition systems with acceptance conditions that satisfy a locality constraint. First, locality implies machine closure and receptiveness, and thus permits the composition and modular verification of live transition systems. Second, while machine closure and receptiveness are based on infinite games, locality is based on repeated finite games, and thus easier to check. Third, no expressive power is lost by the restriction to local live-ness conditions. We illustrate the appeal of local liveness using the model of Fair Reactive Systems, a nonblocking trace model of communicating processes.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: For live processes, it can be ensured that the parallel composition of two consistent processes is again consistent by requiring that processes are receptive <ref> [1, 6, 8] </ref>; that is, a process cannot be prevented, by any possible environment, from achieving its liveness condition. 4 The receptiveness requirement for processes has the added benefits that live specifications can be executed in a stepwise fashion, and that the liveness condition can be ignored for proving safety properties
Reference: [2] <author> M. Abadi, L. Lamport. </author> <title> Conjoining Specifications. </title> <type> Technical Report 118, </type> <institution> DEC-SRC, </institution> <year> 1993. </year>
Reference-contexts: Modular (assumption-guarantee) reasoning Modular verification rules have been presented for a variety of specific notations <ref> [2, 9, 15, 16, 17] </ref>. We present a simple and powerful rule for receptive live reactive systems. Consider two compatible live reactive systems S 1 and S 2 , an abstraction T 1 of S 1 , and an abstraction T 2 of S 2 .
Reference: [3] <author> M. Abadi, L. Lamport, P. Wolper. </author> <title> Realizable and unrealizable specifications of reactive systems. Automata, </title> <journal> Languages, and Programming, </journal> <volume> LNCS 372, </volume> <pages> pp. 1-17. </pages> <publisher> Springer, </publisher> <year> 1989. </year>
Reference-contexts: The corresponding live reactive system (S; fl F ) is defined as in the case of structures. The problem of checking if a finite-state Streett reactive system is receptive is computationally hard (exponential in the number of states) <ref> [3, 12] </ref>. By contrast, it can be checked in polynomial time if a finite-state Streett reactive system is locally receptive. First, each Streett constraint can be checked individually for local receptiveness. Second, the locality check of a single Streett constraint can be set up as a finite game.
Reference: [4] <author> R. Alur, T.A. Henzinger. </author> <title> Fair Reactive Systems. </title> <type> Technical Report, </type> <institution> Computer Science Department, Cornell University, </institution> <year> 1995. </year>
Reference-contexts: While checking machine closure is quadratic in k and checking receptiveness requires time exponential in k, local liveness and local receptiveness can be checked in time linear in k. We develop the locality concept using the model of Fair Reactive Systems <ref> [4] </ref>, where each process communicates with its environment through interface variables that can be observed by other processes. A process cannot constrain the interface variables of other processes, and changes in the interface components of two different processes cannot causally depend on each other. <p> Let (K; F ) be a Streett automaton with n states, m transitions, and k Streett constraints. It can be checked in time O (k (m + n)) if (K; F ) is locally live. 3 Fair Reactive Systems This section introduces the model of Fair Reactive Systems <ref> [4] </ref>, which equips Kripke structures with a communication interface. 3.1 Safe Reactive Systems A reactive system is situated within an environment. Some changes of the environment are visible to the system and cause reactions by the system. Other system actions are independent of the environment. <p> Consequently, asynchronous models such I/O automata have a natural embedding into reactive systems. We refer the reader to <ref> [4] </ref> for a discussion of modeling issues and examples. An S-execution is a K S -execution, and we write [S] = [K S ] for the set of infinite S-executions. The definitions of regions, actions, properties, liveness conditions, and Streett constraints for structures apply to reactive systems also.
Reference: [5] <author> K. Apt, N. Francez, S. Katz. </author> <title> Appraising fairness in languages for distributed programming. </title> <journal> Distributed Computing, </journal> <volume> 2(4) </volume> <pages> 226-241, </pages> <year> 1988. </year>
Reference-contexts: 3 For closed processes, which do not interact with any environment, the nonblocking requirement says that every reachable state has a successor state (deadlock-freedom). 4 For closed live processes, the receptiveness requirement says that every finite execution can be extended to an infinite execution that satisfies the liveness condition (machine-closure <ref> [5] </ref>). 5 For closed processes, the local restriction of machine closure is called local liveness. 2 viewed as game-theoretic version of strong fairness. The justification of the locality restriction on liveness conditions can thus be summarized as follows.
Reference: [6] <author> D. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Parallel composition corresponds to the intersection of trace sets (or conjunction), and implementation corresponds to the inclusion of trace sets (or logical implication). These definitions, which are adopted by a variety of formalisms (including I/O automata [13], TLA [11], trace theory <ref> [6] </ref>, and Cospan [10]), support a compositional verification rule. <p> For live processes, it can be ensured that the parallel composition of two consistent processes is again consistent by requiring that processes are receptive <ref> [1, 6, 8] </ref>; that is, a process cannot be prevented, by any possible environment, from achieving its liveness condition. 4 The receptiveness requirement for processes has the added benefits that live specifications can be executed in a stepwise fashion, and that the liveness condition can be ignored for proving safety properties
Reference: [7] <author> E.A. Emerson, C. Lei. </author> <title> Modalities for model checking: branching time strikes back. </title> <booktitle> Symp. Principles of Programming Languages, </booktitle> <pages> pp. 84-95. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: If K is a structure with n states and m transitions, and F is a set of k Streett K-constraints, then the problem of checking if the Streett structure (K; F ) is machine-closed requires time O (k 2 (m + n)) <ref> [7] </ref>. Local liveness conditions Machine closure can be defined as a two-player game. Given a live structure (K; fl), the adversary provides a finite K-execution s, and the protagonist attempts to extend s to an infinite K-execution in fl.
Reference: [8] <author> R. Gawlick, R. Segala, J. Sogaard-Andersen, N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <type> Technical Report MIT/LCS/TR-587, </type> <institution> MIT, </institution> <year> 1993. </year>
Reference-contexts: For live processes, it can be ensured that the parallel composition of two consistent processes is again consistent by requiring that processes are receptive <ref> [1, 6, 8] </ref>; that is, a process cannot be prevented, by any possible environment, from achieving its liveness condition. 4 The receptiveness requirement for processes has the added benefits that live specifications can be executed in a stepwise fashion, and that the liveness condition can be ignored for proving safety properties
Reference: [9] <author> O. Grumberg, D. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM TOPLAS, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Modular (assumption-guarantee) reasoning Modular verification rules have been presented for a variety of specific notations <ref> [2, 9, 15, 16, 17] </ref>. We present a simple and powerful rule for receptive live reactive systems. Consider two compatible live reactive systems S 1 and S 2 , an abstraction T 1 of S 1 , and an abstraction T 2 of S 2 .
Reference: [10] <author> R. Kurshan. </author> <title> Computer-aided Verification: The Automata-theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: Parallel composition corresponds to the intersection of trace sets (or conjunction), and implementation corresponds to the inclusion of trace sets (or logical implication). These definitions, which are adopted by a variety of formalisms (including I/O automata [13], TLA [11], trace theory [6], and Cospan <ref> [10] </ref>), support a compositional verification rule.
Reference: [11] <author> L. Lamport. </author> <title> The Temporal Logic of Actions. </title> <type> Technical Report 79, </type> <institution> DEC-SRC, </institution> <year> 1991. </year>
Reference-contexts: Parallel composition corresponds to the intersection of trace sets (or conjunction), and implementation corresponds to the inclusion of trace sets (or logical implication). These definitions, which are adopted by a variety of formalisms (including I/O automata [13], TLA <ref> [11] </ref>, trace theory [6], and Cospan [10]), support a compositional verification rule. <p> This is because, technically, receptiveness is a property of infinite games ("process versus environment"), and because receptive liveness conditions are not closed under intersection. In practice, therefore, receptiveness is ensured syntactically, by specifying liveness conditions using fairness constraints <ref> [11, 14] </ref>. The types and forms of fairness constraints, however, depend on the syntax of the specific process description language that is used. We propose a semantic restriction of receptiveness|called local receptiveness 5 |that, while abstract and more general, retains the benefits of fairness constraints.
Reference: [12] <author> H. Lescow. </author> <title> On polynomial-size programs winning finite-state games. Computer-aided Verification, </title> <publisher> LNCS. Springer, </publisher> <year> 1995. </year>
Reference-contexts: The corresponding live reactive system (S; fl F ) is defined as in the case of structures. The problem of checking if a finite-state Streett reactive system is receptive is computationally hard (exponential in the number of states) <ref> [3, 12] </ref>. By contrast, it can be checked in polynomial time if a finite-state Streett reactive system is locally receptive. First, each Streett constraint can be checked individually for local receptiveness. Second, the locality check of a single Streett constraint can be set up as a finite game.
Reference: [13] <author> N. Lynch, M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> Symp. Principles of Distributed Computing, </booktitle> <pages> pp. 137-151. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Parallel composition corresponds to the intersection of trace sets (or conjunction), and implementation corresponds to the inclusion of trace sets (or logical implication). These definitions, which are adopted by a variety of formalisms (including I/O automata <ref> [13] </ref>, TLA [11], trace theory [6], and Cospan [10]), support a compositional verification rule.
Reference: [14] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: This is because, technically, receptiveness is a property of infinite games ("process versus environment"), and because receptive liveness conditions are not closed under intersection. In practice, therefore, receptiveness is ensured syntactically, by specifying liveness conditions using fairness constraints <ref> [11, 14] </ref>. The types and forms of fairness constraints, however, depend on the syntax of the specific process description language that is used. We propose a semantic restriction of receptiveness|called local receptiveness 5 |that, while abstract and more general, retains the benefits of fairness constraints.
Reference: [15] <author> J. Misra, K. Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 7(4) </volume> <pages> 417-426, </pages> <year> 1981. </year>
Reference-contexts: Modular (assumption-guarantee) reasoning Modular verification rules have been presented for a variety of specific notations <ref> [2, 9, 15, 16, 17] </ref>. We present a simple and powerful rule for receptive live reactive systems. Consider two compatible live reactive systems S 1 and S 2 , an abstraction T 1 of S 1 , and an abstraction T 2 of S 2 .
Reference: [16] <author> P. Pandya, M. Joseph. </author> <title> P-A logic|a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5(1) </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference-contexts: Modular (assumption-guarantee) reasoning Modular verification rules have been presented for a variety of specific notations <ref> [2, 9, 15, 16, 17] </ref>. We present a simple and powerful rule for receptive live reactive systems. Consider two compatible live reactive systems S 1 and S 2 , an abstraction T 1 of S 1 , and an abstraction T 2 of S 2 .
Reference: [17] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pp. 123-144. </pages> <publisher> Springer, </publisher> <year> 1984. </year>
Reference-contexts: Modular (assumption-guarantee) reasoning Modular verification rules have been presented for a variety of specific notations <ref> [2, 9, 15, 16, 17] </ref>. We present a simple and powerful rule for receptive live reactive systems. Consider two compatible live reactive systems S 1 and S 2 , an abstraction T 1 of S 1 , and an abstraction T 2 of S 2 .
References-found: 17

