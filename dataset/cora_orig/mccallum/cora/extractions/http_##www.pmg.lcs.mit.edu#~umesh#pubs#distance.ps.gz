URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/distance.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/
Root-URL: 
Title: Collecting Cyclic Distributed Garbage by Controlled Migration  
Author: Umesh Maheshwari Barbara Liskov 
Address: Cambridge, MA 02139  
Affiliation: M.I.T. Laboratory for Computer Science  
Abstract: Distributed reference counting provides timely and fault-tolerant garbage collection in large distributed systems, but it fails to collect cyclic garbage distributed across nodes. A common proposal is to migrate all objects on a garbage cycle to a single node, where they can be collected by the local collector. However, existing schemes have practical problems due to unnecessary migration of objects. We present solutions to these problems: our scheme avoids migration of live objects, batches objects to avoid a cascade of migration messages, and short-cuts the migration path to avoid multiple migrations. We use simple estimates to detect objects that are highly likely to be cyclic garbage and to select a node to which such objects are migrated. The scheme has low overhead, and it preserves the decentralized and fault-tolerant nature of distributed reference counting and migration. 
Abstract-found: 1
Intro-found: 1
Reference: [Ali84] <author> K. A. M. Ali. </author> <title> Garbage Collection Schemes for Distributed Storage Systems. </title> <booktitle> Proceedings of Workshop on Implementation of Functional Languages, </booktitle> <pages> pages 422-428, </pages> <address> Aspenas, Sweden, </address> <month> February </month> <year> 1985. </year>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136. using a complementary marking scheme to collect cyclic garbage <ref> [Ali84, JJ92, LQP92] </ref>, or by migrating objects so that cyclic garbage ends up in a single node and is collected by the local collector [Bis77, SGP90, GF93]. The advantage of migration is that, like distributed reference counting, it is decentralized and fault-tolerant. <p> Different variants of distributed reference counting employ different methods and information to track the secondary roots, ranging from one-bit counts <ref> [Ali84, JJ92] </ref> to weighted reference counts [Bev87] to reference lists, in which each node tracks the identities of the nodes that refer to its objects [Bis77, SDP92, BENOW93]. <p> Destination propagation is used only as an optimization to reduce the number of migrations before the objects converge. 6 5 Related Work Distributed reference counting can be augmented in various ways to collect cyclic distributed garbage. Some systems periodically invoke global marking to collect cyclic garbage <ref> [Ali84, JJ92] </ref>. Lang et al. proposed marking within groups of nodes such that each round can tolerate failures of nodes outside the group [LQP92]. However, the formation, management, and reconfiguration of groups is still complex and speculative.
Reference: [Bag91] <author> N. Bagherzadeh. </author> <title> A Parallel Asynchronous Garbage Collection Algorithm for Distributed Systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol. 3, No. 1, </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: Therefore, migration is an attractive solution in large-scale systems that allow objects to migrate between nodes. However, existing migration schemes have some practical problems. First, they tend to migrate live objects along with garbage. Most schemes migrate locally unreachable objects, either immediately <ref> [Bis77, Bag91] </ref> or if the objects are not used for some time period [GF93]. In a persistent store, however, live objects may not be accessed for long periods (say, weeks or months), so even systems that wait will migrate live objects.
Reference: [BE86] <author> M. J. Beckerle and K. Eknadham. </author> <title> Distributed Garbage Collection With No Global Synchronization, </title> <type> Research Report RC 11667, </type> <institution> IBM T. J. Watson Research Center, </institution> <address> Yorktown Heights, New York. </address>
Reference-contexts: Our scheme is based on a fault-tolerant variant of reference counting described in Section 2, and adds very little space and time overhead to the base scheme. Unlike some other schemes <ref> [BE86, KA93] </ref>, ours does not require the local collector to trace the object graph multiple times. It also preserves the naturally decentralized and fault-tolerant nature of distributed reference counting and migration. <p> Further, the centralized service, albeit replicated, can become a bottleneck in a large system. Beckerle et al. proposed that each node send information regarding which outlist entries are reachable from each secondary root to a fixed node in the system <ref> [BE86] </ref>. The fixed node uses the information to detect unreachable cycles between nodes. This scheme has two problems. First, the fixed node is a bottleneck. Second, to obtain the full set of outlist entries reachable from any secondary root, the local collector must trace from each secondary root independently.
Reference: [BENOW93] <author> A. Birrell, D. Evers, G. Nelson, S. Owicki, and E. Wobber. </author> <title> Distributed Garbage Collection for Network Objects. </title> <note> Systems Research Center Technical Report 116, Digital, De-cember 1993. </note>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> Different variants of distributed reference counting employ different methods and information to track the secondary roots, ranging from one-bit counts [Ali84, JJ92] to weighted reference counts [Bev87] to reference lists, in which each node tracks the identities of the nodes that refer to its objects <ref> [Bis77, SDP92, BENOW93] </ref>. We use reference listing because it handles catastrophic node failures and provides better fault-tolerance for messages. (For a full description see [ML94].) Our scheme works as follows: 1.
Reference: [Bev87] <author> D. I. Bevan. </author> <title> Distributed Garbage Collection Using Reference Counting. </title> <booktitle> Lecture Notes in Computer Science 259, </booktitle> <pages> pages 176-187, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> Different variants of distributed reference counting employ different methods and information to track the secondary roots, ranging from one-bit counts [Ali84, JJ92] to weighted reference counts <ref> [Bev87] </ref> to reference lists, in which each node tracks the identities of the nodes that refer to its objects [Bis77, SDP92, BENOW93]. We use reference listing because it handles catastrophic node failures and provides better fault-tolerance for messages. (For a full description see [ML94].) Our scheme works as follows: 1.
Reference: [Bis77] <author> P. B. Bishop. </author> <title> Computer Systems with a Very Large Address Space, and Garbage Collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge MA, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: 1 Introduction Systems that store objects on multiple nodes need distributed garbage collection to reclaim storage of inaccessible objects. These systems can use either global marking [HK82] or distributed reference counting <ref> [Bis77] </ref>. Global marking requires the cooperation of all nodes before it can collect any garbage. Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. <p> Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136. using a complementary marking scheme to collect cyclic garbage [Ali84, JJ92, LQP92], or by migrating objects so that cyclic garbage ends up in a single node and is collected by the local collector <ref> [Bis77, SGP90, GF93] </ref>. The advantage of migration is that, like distributed reference counting, it is decentralized and fault-tolerant. The collection of a cycle requires the cooperation of only those nodes that contain it, and progress can be made even if other nodes or other parts of the network fail. <p> Therefore, migration is an attractive solution in large-scale systems that allow objects to migrate between nodes. However, existing migration schemes have some practical problems. First, they tend to migrate live objects along with garbage. Most schemes migrate locally unreachable objects, either immediately <ref> [Bis77, Bag91] </ref> or if the objects are not used for some time period [GF93]. In a persistent store, however, live objects may not be accessed for long periods (say, weeks or months), so even systems that wait will migrate live objects. <p> Different variants of distributed reference counting employ different methods and information to track the secondary roots, ranging from one-bit counts [Ali84, JJ92] to weighted reference counts [Bev87] to reference lists, in which each node tracks the identities of the nodes that refer to its objects <ref> [Bis77, SDP92, BENOW93] </ref>. We use reference listing because it handles catastrophic node failures and provides better fault-tolerance for messages. (For a full description see [ML94].) Our scheme works as follows: 1. <p> The scheme suggested in [KA93] uses probes to confirm the liveness of suspected objects. It, too, requires multiple tracing. Bishop first proposed migration of objects to collect cycles between separately traced partitions <ref> [Bis77] </ref>. In his scheme, locally unreachable objects are migrated immediately to the partition they are referenced from. Shapiro et al. proposed restricting the direction of migration according to a total order among nodes to ensure that all objects on a cycle converge on the same node [SGP90].
Reference: [DLMM93] <author> M. Day, B. Liskov, U. Maheshwari, and A. Myers. </author> <title> References to Remote Mobile Objects in Thor. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <year> 1994. </year>
Reference-contexts: At any time, an object resides at one node, although it can be migrated to another node. Objects contain references to other objects, which may reside at any node. For efficient access, a reference to an object contains the identity of the node where the object resides <ref> [DLMM93] </ref>. Objects are clustered within nodes so that internode (remote) object references are rarer than intra-node (local) references. Persistence of objects is determined by reachability from the persistent root objects, which may be on any node. <p> We assume the system already possesses a mechanism for migrating objects and updating the references to them in other objects <ref> [SGP90, DLMM93] </ref>. We discuss how to batch objects for migration, and how to determine where to send the migrating objects.
Reference: [GF93] <author> A. Gupta and W. K. Fuchs. </author> <title> Garbage Collection in a Distributed Object-Oriented System. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol. 5, No. 2, </volume> <month> April </month> <year> 1993. </year>
Reference-contexts: Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136. using a complementary marking scheme to collect cyclic garbage [Ali84, JJ92, LQP92], or by migrating objects so that cyclic garbage ends up in a single node and is collected by the local collector <ref> [Bis77, SGP90, GF93] </ref>. The advantage of migration is that, like distributed reference counting, it is decentralized and fault-tolerant. The collection of a cycle requires the cooperation of only those nodes that contain it, and progress can be made even if other nodes or other parts of the network fail. <p> However, existing migration schemes have some practical problems. First, they tend to migrate live objects along with garbage. Most schemes migrate locally unreachable objects, either immediately [Bis77, Bag91] or if the objects are not used for some time period <ref> [GF93] </ref>. In a persistent store, however, live objects may not be accessed for long periods (say, weeks or months), so even systems that wait will migrate live objects. Migration of live objects is undesirable because it wastes processor and network bandwidth. Also, it interferes with load balancing. <p> We migrate only objects with very large estimates. We also do the actual migration of objects efficiently. Consolidating a distributed garbage cycle may involve migrating objects multiple times before they converge on the same node. Some schemes avoid this problem by migrating objects to a fixed dump node <ref> [GF93] </ref>, but having a single dump node in a large system can be a performance or fault-tolerance bottleneck. We have a simple way of selecting one of the nodes 1 containing a garbage cycle as the destination, and we migrate all objects on the cycle directly to that node. <p> In Figure 4, z will be traced from the root r, and x and y will be batched together. 4.2 Where to Migrate The goal is to migrate all objects on a garbage cycle to a single node. Some schemes migrate objects to a fixed dump node <ref> [GF93] </ref>, but this can be a performance or fault-tolerance bottleneck in a large system. The dump node might be far away from the nodes containing the garbage cycle, or it might be unavailable when it is time to migrate the cycle. <p> Thus, a logical space may span a number of nodes. Each logical space is collected by marking, so that a local collection may require internode marking messages. Gupta et al. proposed migrating objects to a fixed dump node in the system <ref> [GF93] </ref>. This scheme works with reference counts because it does not require the knowledge of the referencing node. Also, it does not suffer from the problem of multiple migrations. However, moving objects to a fixed node is not scalable or fault-tolerant.
Reference: [FS94] <author> P. Ferreira and M. Shapiro. </author> <title> Garbage Collection and DSM Consistency. </title> <booktitle> Proceedings of the Third International Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 229-241, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: However, the formation, management, and reconfiguration of groups is still complex and speculative. Ferreira et al. group partitions that are cached in memory on the same node, and thus collect any inter-partition cyclic garbage that lies within the group <ref> [FS94] </ref>. Hughes's algorithm propagates timestamps from the roots to the outlists [Hug85]. The timestamps of the persistent roots are advanced to the current clock time before each local collection. The persistent and the secondary roots are then traced in the order of decreasing timestamps.
Reference: [HK82] <author> P. Hudak, and R. Keller. </author> <title> Garbage Collection and Task Deletion in Distributed Applicative Processing Systems. </title> <booktitle> ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 168-178, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Systems that store objects on multiple nodes need distributed garbage collection to reclaim storage of inaccessible objects. These systems can use either global marking <ref> [HK82] </ref> or distributed reference counting [Bis77]. Global marking requires the cooperation of all nodes before it can collect any garbage. Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage.
Reference: [Hug85] <author> J. Hughes. </author> <title> A Distributed Garbage Collection Algorithm. </title> <booktitle> Functional Programming and Computer Architecture (Lecture Notes in Computer Science 201), </booktitle> <pages> pages 256-272, </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1985. </year>
Reference-contexts: As with other practical schemes, once an object has been traced, it is not traced again. When an outlist entry is created, its distance is set to one plus the distance of the root being traced. This technique is similar to timestamp propagation in <ref> [Hug85] </ref>, which is described in Section 5. As before, outlists are sent to other nodes after a collection. When a node receives an outlist, it uses it to replace its inlist for the sender, including the associated distance fields. This scheme has little space and time overhead. <p> Ferreira et al. group partitions that are cached in memory on the same node, and thus collect any inter-partition cyclic garbage that lies within the group [FS94]. Hughes's algorithm propagates timestamps from the roots to the outlists <ref> [Hug85] </ref>. The timestamps of the persistent roots are advanced to the current clock time before each local collection. The persistent and the secondary roots are then traced in the order of decreasing timestamps. As outlists are exchanged, each node records the minimum timestamp that it has yet to propagate.
Reference: [JJ92] <author> N. C. Juul, E. </author> <month> Jul. </month> <title> Comprehensive and Robust Garbage Collection in a Distributed System. </title> <booktitle> 1992 International Workshop on Memory Management, (Lecture Notes in Computer Science 637), </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136. using a complementary marking scheme to collect cyclic garbage <ref> [Ali84, JJ92, LQP92] </ref>, or by migrating objects so that cyclic garbage ends up in a single node and is collected by the local collector [Bis77, SGP90, GF93]. The advantage of migration is that, like distributed reference counting, it is decentralized and fault-tolerant. <p> Different variants of distributed reference counting employ different methods and information to track the secondary roots, ranging from one-bit counts <ref> [Ali84, JJ92] </ref> to weighted reference counts [Bev87] to reference lists, in which each node tracks the identities of the nodes that refer to its objects [Bis77, SDP92, BENOW93]. <p> Destination propagation is used only as an optimization to reduce the number of migrations before the objects converge. 6 5 Related Work Distributed reference counting can be augmented in various ways to collect cyclic distributed garbage. Some systems periodically invoke global marking to collect cyclic garbage <ref> [Ali84, JJ92] </ref>. Lang et al. proposed marking within groups of nodes such that each round can tolerate failures of nodes outside the group [LQP92]. However, the formation, management, and reconfiguration of groups is still complex and speculative.
Reference: [KA93] <author> R. Kordale and M. Ahamad. </author> <title> A Scalable Cyclic Garbage Detection Algorithm for Distributed Systems. </title> <booktitle> OOPSLA'93 Workshop on Memory Management and Garbage Collection, </booktitle> <month> September </month> <year> 1993. </year> <title> Contact: </title> <publisher> kram@cc.gatech.edu. </publisher>
Reference-contexts: Our scheme is based on a fault-tolerant variant of reference counting described in Section 2, and adds very little space and time overhead to the base scheme. Unlike some other schemes <ref> [BE86, KA93] </ref>, ours does not require the local collector to trace the object graph multiple times. It also preserves the naturally decentralized and fault-tolerant nature of distributed reference counting and migration. <p> Even if separate sets of trial counts are maintained for trial deletions started by different nodes, multiple tracings of the object graph from different roots would be required to propagate the information. The scheme suggested in <ref> [KA93] </ref> uses probes to confirm the liveness of suspected objects. It, too, requires multiple tracing. Bishop first proposed migration of objects to collect cycles between separately traced partitions [Bis77]. In his scheme, locally unreachable objects are migrated immediately to the partition they are referenced from.
Reference: [LDS92] <author> B. Liskov, M. Day, and L. Shrira. </author> <title> Distributed Object Management in Thor. Distributed Object Management, </title> <editor> ed. M. T. Ozsu, U. Dayal, and P. Valduriez, </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Section 4 discusses how we migrate objects efficiently. Section 5 surveys related work in collection of distributed cyclic garbage, and Section 6 contains our conclusions. 2 The Problem Context Our algorithm is designed for use in the Thor object-oriented database system <ref> [LDS92] </ref>, although it is applicable to a wide range of similar distributed systems. Thor stores persistent objects at geographically distributed nodes. At any time, an object resides at one node, although it can be migrated to another node. Objects contain references to other objects, which may reside at any node.
Reference: [LeL77] <author> G. LeLann. </author> <title> Distributed Systems, towards a formal approach. </title> <booktitle> IFIP Congress, </booktitle> <pages> pages 155-160, </pages> <address> Torornto, </address> <year> 1977. </year>
Reference-contexts: The cycle and the front of the chain (object u) will migrate to N 2 , while the trailing part of the chain (object w) would migrate to N 3 . The objects will not migrate further, however, so multiple migrations are still avoided. Unlike some leader election algorithms <ref> [LeL77] </ref>, ours does not incorporate termination detection, so nodes must guess when destination propagation has completed; we discuss how to make this guess in the next section.
Reference: [LL92] <author> R. Ladin, and B. Liskov. </author> <title> Garbage Collection of a Distributed Heap. </title> <booktitle> Int. Conference on Distributed Computing Systems, </booktitle> <pages> pages 708-715, </pages> <address> Yokohoma, Japan, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> Ladin et al. proposed the use of a logically centralized service that tracks all inter-node references and uses Hughes's algorithm to collect cyclic garbage <ref> [LL92] </ref>. The centralized service avoids the need for a distributed algorithm to compute the global threshold. However, collection of cyclic garbage still depends on timely correspondence between the service and all nodes in the system. Further, the centralized service, albeit replicated, can become a bottleneck in a large system.
Reference: [LQP92] <author> B. Lang, C. Queinnec, and J. Piquer. </author> <title> Garbage Collecting the World. </title> <booktitle> Proceedings of the 19th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 39-50, </pages> <address> Albuquerque, </address> <month> Jan </month> <year> 1992. </year>
Reference-contexts: This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136. using a complementary marking scheme to collect cyclic garbage <ref> [Ali84, JJ92, LQP92] </ref>, or by migrating objects so that cyclic garbage ends up in a single node and is collected by the local collector [Bis77, SGP90, GF93]. The advantage of migration is that, like distributed reference counting, it is decentralized and fault-tolerant. <p> Some systems periodically invoke global marking to collect cyclic garbage [Ali84, JJ92]. Lang et al. proposed marking within groups of nodes such that each round can tolerate failures of nodes outside the group <ref> [LQP92] </ref>. However, the formation, management, and reconfiguration of groups is still complex and speculative. Ferreira et al. group partitions that are cached in memory on the same node, and thus collect any inter-partition cyclic garbage that lies within the group [FS94].
Reference: [ML94] <author> U. Maheshwari, and B. Liskov. </author> <title> Fault-Tolerant Distributed Garbage Collection in a Client-Server Object-Oriented Database. </title> <booktitle> Proceedings of the third Internation Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 239-248, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> We use reference listing because it handles catastrophic node failures and provides better fault-tolerance for messages. (For a full description see <ref> [ML94] </ref>.) Our scheme works as follows: 1. A node N 1 keeps, for every other node N 2 , a list of objects in N 1 that N 2 may hold references to. We call the list the inlist for N 2 at N 1 . 2.
Reference: [Piq91] <author> J. M. Piquer. </author> <title> Indirect Reference Counting: A Distributed Garbage Collection Algorithm. </title> <booktitle> PARLE '91 Parallel Architecture and Languages (Lecture Notes in Computer Science 505), </booktitle> <pages> pages 150-165, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss.
Reference: [SDP92] <author> M. Shapiro, P. Dickman, and D. Plainfosse. </author> <title> Robust, Distributed References and Acyclic garbage Collection. </title> <booktitle> Symposium on Principles of Distributed Computing, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> Different variants of distributed reference counting employ different methods and information to track the secondary roots, ranging from one-bit counts [Ali84, JJ92] to weighted reference counts [Bev87] to reference lists, in which each node tracks the identities of the nodes that refer to its objects <ref> [Bis77, SDP92, BENOW93] </ref>. We use reference listing because it handles catastrophic node failures and provides better fault-tolerance for messages. (For a full description see [ML94].) Our scheme works as follows: 1.
Reference: [SGP90] <author> M. Shapiro, O. Gruber, and D. Plainfosse. </author> <title> A Garbage Detection Protocol for a Realistic Distributed Object-Support System. </title> <note> Research Report 1320, INRIA-Rocquencourt, Novem-ber 1990. </note>
Reference-contexts: Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136. using a complementary marking scheme to collect cyclic garbage [Ali84, JJ92, LQP92], or by migrating objects so that cyclic garbage ends up in a single node and is collected by the local collector <ref> [Bis77, SGP90, GF93] </ref>. The advantage of migration is that, like distributed reference counting, it is decentralized and fault-tolerant. The collection of a cycle requires the cooperation of only those nodes that contain it, and progress can be made even if other nodes or other parts of the network fail. <p> We assume the system already possesses a mechanism for migrating objects and updating the references to them in other objects <ref> [SGP90, DLMM93] </ref>. We discuss how to batch objects for migration, and how to determine where to send the migrating objects. <p> Other schemes migrate objects to nodes that refer to them. To ensure that all objects in a cycle converge on the same node instead of following each other in circles, nodes are totally ordered and migration is allowed only in one direction <ref> [SGP90] </ref>. However, objects on a multi-node cycle may require multiple migrations before converging on the same destination node. <p> In his scheme, locally unreachable objects are migrated immediately to the partition they are referenced from. Shapiro et al. proposed restricting the direction of migration according to a total order among nodes to ensure that all objects on a cycle converge on the same node <ref> [SGP90] </ref>. Shapiro also considered virtual migration to collect cyclic garbage. Here, a locally unreachable object is not physically moved between nodes; instead, the object merely changes the logical space it belongs to. Thus, a logical space may span a number of nodes.
Reference: [Ves87] <author> S. C. Vestal. </author> <title> Garbage Collection: An Exercise in Distributed, Fault-Tolerant Programming. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <month> January </month> <year> 1987. </year> <month> 8 </month>
Reference-contexts: Distributed reference counting is preferred for systems with large numbers of nodes because it is more fault-tolerant and scalable, and quicker at collecting distributed garbage. Many variants of distributed reference counting schemes have been proposed to enhance fault-tolerance and reduce overheads <ref> [Ali84, Bev87, Ves87, Piq91, LL92, SDP92, BENOW93, ML94] </ref>. Distributed reference counting algorithms cannot collect multi-node cycles of garbage objects. This is particularly undesirable in long-lived systems such as persistent object stores, where even small amounts of uncollected garbage can accumulate over time to cause a significant storage loss. <p> Note that both distance and timestamp propagation exploit an ordering on the root set to avoid multiple tracings. Vestal proposed trial deletion of objects suspected to be garbage <ref> [Ves87] </ref>. A separate set of reference counts is used to propagate the effect of trial deletions. If the trial count of a trial-deleted object drops to zero, it confirms that the object was cyclic garbage.
References-found: 22

