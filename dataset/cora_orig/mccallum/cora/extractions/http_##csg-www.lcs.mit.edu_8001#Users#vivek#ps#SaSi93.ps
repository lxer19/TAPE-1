URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/ps/SaSi93.ps
Refering-URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/sark_pub.html
Root-URL: 
Email: (fvivek sarkar,simonsg@vnet.ibm.com)  
Title: Parallel Program Graphs and their Classification  
Author: Vivek Sarkar Barbara Simons 
Address: 555 Bailey Avenue, San Jose, CA 95141  
Affiliation: IBM Santa Teresa Laboratory,  
Abstract: We categorize and compare different representations of program dependence graphs, including the Control Flow Graph (CFG) which is a sequential representation lacking data dependences, the Program Dependence Graph (PDG) which is a parallel representation of a sequential program and is comprised of control and data dependences, and more generally, the Parallel Program Graph (PPG) which is a parallel representation of sequential and (inherently) parallel programs and is comprised of parallel control flow edges and synchronization edges. PPGs are classified according to their graphical structure and properties related to deadlock detection and serializability.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: It differs from the usual definition <ref> [1, 15] </ref> by the inclusion of a set of labels for edges and a mapping of node types. The label set fT; F; U g is used to distinguish between conditional execution (labels T and F ) and unconditional execution (label U ). Definition 1. <p> For reducibility, we extend the definition used for CFGs so that it is applicable to PPGs as well: a PPG is reducible if each strongly connected region of its control edges has a single entry node <ref> [2, 21, 1] </ref>; otherwise, a PPG is said to be irreducible. This classification of a PPG's control edges as acyclic/reducible/arbitrary is interesting because of the characterizations that can then be made. Note that each class is properly contained within the next, with irreducible PPGs being the most general case.
Reference: 2. <author> F. E. Allen. </author> <title> Control flow analysis. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(6) </volume> <pages> 13-24, </pages> <year> 1970. </year>
Reference-contexts: For reducibility, we extend the definition used for CFGs so that it is applicable to PPGs as well: a PPG is reducible if each strongly connected region of its control edges has a single entry node <ref> [2, 21, 1] </ref>; otherwise, a PPG is said to be irreducible. This classification of a PPG's control edges as acyclic/reducible/arbitrary is interesting because of the characterizations that can then be made. Note that each class is properly contained within the next, with irreducible PPGs being the most general case.
Reference: 3. <author> Frances Allen, Michael Burke, Philippe Charles, Ron Cytron, and Jeanne Ferrante. </author> <title> An Overview of the PTRAN Analysis System for Multiprocessing. </title> <booktitle> Proceedings of the ACM 1987 International Conference on Supercomputing, </booktitle> <year> 1987. </year> <note> Also published in The Journal of Parallel and Distributed Computing, </note> <month> Oct., </month> <year> 1988, </year> <pages> 5(5) pages 617-640. </pages>
Reference-contexts: PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization [15], vectorization [7], code generation for VLIW machines [19], merging versions of programs [22], and automatic detection and management of parallelism <ref> [3, 33, 32] </ref>. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25]. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. <p> The serialization problem has been addressed in some prior work. Generating a CFG from the CDG's of well-structured programs is reported in [22, 23]; such CDG's are trees and do not require any duplication. The IBM PTRAN system <ref> [3, 9, 33] </ref> generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs. The work presented in [14, 16] uses assumptions about the structure of CFG's derived from sequential programs, thereby limiting its applicability.
Reference: 4. <author> Randy Allen and Ken Kennedy. </author> <title> Automatic Translation of FORTRAN Programs to Vector Form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 491-592, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Direction vectors [40] and distance vectors [26] are common approaches to representing contexts of data dependences; the gist [30] and the last-write tree [27] are newer representations for data dependence contexts that provide more information. Context information can identify a data dependence as being loop-independent or loop-carried <ref> [4] </ref>. In the absence of any other information, the context of a data dependence edge in a PDG must at least be plausible [8] i.e. the execution instances participating in the data dependences must be consistent with the sequential ordering represented by the CFG from which the PDG is derived.
Reference: 5. <author> Arvind, </author> <title> M.L. Dertouzos, R.S. Nikhil, and G.M. Papadopoulos. Project Dataflow: A parallel computing system based on the Monsoon architecture and the Id programming language. </title> <type> Technical report, </type> <institution> MIT Lab for Computer Science, </institution> <month> March </month> <year> 1988. </year> <note> Computation Structures Group Memo 285. </note>
Reference-contexts: in PPGs can be used to model program constructs that cannot be modelled with data dependence edges in PDGs e.g. a PPG may enforce a synchronization with distance vector (1), from the "next" iteration of a loop to the "previous" iteration, as in (say) Haskell array constructors [24] or I-structures <ref> [5] </ref>, while such data dependences are prohibited in PDGs because they are not plausible with reference to the sequential program from which the PDG was derived. Definition 3.
Reference: 6. <author> Thomas Ball and Susan Horwitz. </author> <title> Constructing Control Flow from Data Dependence. </title> <type> Technical report, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1992. </year> <note> TR No. 1091. </note>
Reference-contexts: In order to determine when a PPG can be serialized, we need some notion of equivalence between a CDG and a CFG. One approached, taken by Ball and Horwitz <ref> [6] </ref>, is to say that a CFG G 0 is a corresponding CFG of CDG G if and only if the CDG that is constructed from G 0 is isomorphic to G, with the isomorphism respecting node and edge labels. <p> The complexity involves the analysis of the control dependences. Constructing a CFG and reconstituting a CDG. The algorithm presented in <ref> [6] </ref> determines orderings that must exist in any CFG G 0 that "corresponds" to the CDG G 6 . <p> Restriction c) limits their PPGs from being 6 The model presented in <ref> [6] </ref> differs somewhat from that of [37, 36]. However, the models are essentially equivalent. able to represent CFGs.
Reference: 7. <author> William Baxter and J. R. Bauer, III. </author> <title> The Program Dependence Graph in Vectorization. </title> <booktitle> Sixteenth ACM Principles of Programming Languages Symposium, </booktitle> <pages> pages 1 - 11., </pages> <month> January 11-13 </month> <year> 1989. </year> <institution> Austin, Texas. </institution>
Reference-contexts: The Control Flow Graph (CFG), in turn, is required once portions of the PPG have been mapped onto individual processors. PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization [15], vectorization <ref> [7] </ref>, code generation for VLIW machines [19], merging versions of programs [22], and automatic detection and management of parallelism [3, 33, 32]. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25].
Reference: 8. <author> Michael Burke and Ron Cytron. </author> <title> Interprocedural Dependence Analysis and Par-allelization. </title> <booktitle> Proceedings of the Sigplan '86 Symposium on Compiler Construction, </booktitle> <volume> 21(7) </volume> <pages> 162-175, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Context information can identify a data dependence as being loop-independent or loop-carried [4]. In the absence of any other information, the context of a data dependence edge in a PDG must at least be plausible <ref> [8] </ref> i.e. the execution instances participating in the data dependences must be consistent with the sequential ordering represented by the CFG from which the PDG is derived. TYPE, a node type mapping. TYPE (n) identifies the type of node n as one of the following values: START, PREDICATE, COMPUTE, REGION.
Reference: 9. <author> Michael Burke, Ron Cytron, Jeanne Ferrante, and Wilson Hsieh. </author> <title> Automatic Generation of Nested, Fork-Join Parallelism. </title> <journal> Journal of Supercomputing, </journal> <volume> 2(3) </volume> <pages> 71-88, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The serialization problem has been addressed in some prior work. Generating a CFG from the CDG's of well-structured programs is reported in [22, 23]; such CDG's are trees and do not require any duplication. The IBM PTRAN system <ref> [3, 9, 33] </ref> generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs. The work presented in [14, 16] uses assumptions about the structure of CFG's derived from sequential programs, thereby limiting its applicability.
Reference: 10. <author> Robert Cartwright and Mathias Felleisen. </author> <title> The Semantics of Program Dependence. </title> <booktitle> SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-27, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: PPGs are useful for determining the semantic equivalence of parallel programs <ref> [35, 10, 34] </ref>, and also have applications to automatic code generation [25]. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. <p> The semantics of PDGs has been examined in past work by Selke, by Cartwright and Felleisen, and by Sarkar. In [35], Selke presented an operational semantics for PDGs based on graph rewriting. In <ref> [10] </ref>, Cartwright and Felleisen presented a denotational semantics for PDGs, and showed how it could be used to generate an equivalent functional, dataflow program. Both those approaches assumed a restricted programming language (the language W), and presented a value-oriented semantics for PDGs.
Reference: 11. <author> Ron Cytron, Jeanne Ferrante, and Vivek Sarkar. </author> <title> Experiences Using Control Dependence in PTRAN. </title> <booktitle> Proceedings of the Second Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1989. </year> <title> In Languages and Compilers for Parallel Computing, </title> <editor> edited by D. Gelernter, A. Nicolau, and D. Padua, </editor> <publisher> MIT Press, </publisher> <pages> 1990 (pages 186-212). </pages>
Reference-contexts: Finally, section 7 discusses related work, and section 8 contains the conclusions of this paper and an outline of possible directions for future work. 2 Definition of PPGs 2.1 Control Flow Graphs (CFGs) We begin with the definition of a control flow graph as presented in <ref> [31, 11, 33] </ref>. It differs from the usual definition [1, 15] by the inclusion of a set of labels for edges and a mapping of node types.
Reference: 12. <author> Ron Cytron, Jeanne Ferrante, and Vivek Sarkar. </author> <title> Compact Representations for Control Dependence. </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <pages> pages 337-351, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: A node with TYPE = REGION serves as a summary node for a set of control dependence successors in a PDG. Region nodes are also useful for factoring sets of control dependence successors <ref> [15, 12] </ref>. 2 2.3 Parallel Program Graphs (PPGs) The Parallel Program Graph (PPG) is a general intermediate representation of parallel programs that includes PDGs and CFGs.
Reference: 13. <author> Ron Cytron, Michael Hind, and Wilson Hsieh. </author> <title> Automatic Generation of DAG Parallelism. </title> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, Portland, Oregon, </booktitle> <volume> 24(7) </volume> <pages> 54-68, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: This idea is an extension of the control sequencing transformation used in the PTRAN system to replace a data synchronization by sequential control <ref> [13, 33] </ref>.
Reference: 14. <author> J. Ferrante and M. E. Mace. </author> <title> On Linearizing Parallel Code. </title> <booktitle> Conf. Rec. Twelfth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 179-189, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Serialization is the process of transforming a PPG into a semantically equivalent sequential CFG with neither node duplication nor creation of Boolean guards. It has already been shown that there exist PPGs that are not serializable <ref> [14, 38] </ref>, which is another reason why PPGs are more general than PDGs. In section 6, we further study the serialization problem by characterizing the serializability of different classes of PPGs. <p> When duplication is required, the algorithm can be used as the basis of a heuristic that duplicates subgraphs or adds guard variables. 7 Related Work The idea of extending PDGs to PPGs was introduced by Ferrante and Mace in <ref> [14] </ref>, extended by Simons, Alpern, and Ferrante in [38], and further extended by Sarkar in [34]. The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. <p> The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. The PPG definition used in <ref> [14, 38] </ref> imposed several restrictions: a) the PPGs could not contain loop-carried data dependences (synchronizations), b) only reducible loops were considered, c) PPGs had to satisfy the no-post-dominator rule, and d) PPGs had to satisfy the pred-anc rule. The PPGs defined in this paper have none of these restrictions. <p> Generating a CFG from the CDG's of well-structured programs is reported in [22, 23]; such CDG's are trees and do not require any duplication. The IBM PTRAN system [3, 9, 33] generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs. The work presented in <ref> [14, 16] </ref> uses assumptions about the structure of CFG's derived from sequential programs, thereby limiting its applicability.
Reference: 15. <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The Program Dependence Graph and its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: The Control Flow Graph (CFG), in turn, is required once portions of the PPG have been mapped onto individual processors. PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization <ref> [15] </ref>, vectorization [7], code generation for VLIW machines [19], merging versions of programs [22], and automatic detection and management of parallelism [3, 33, 32]. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25]. <p> It differs from the usual definition <ref> [1, 15] </ref> by the inclusion of a set of labels for edges and a mapping of node types. The label set fT; F; U g is used to distinguish between conditional execution (labels T and F ) and unconditional execution (label U ). Definition 1. <p> A CF G is also the target for code generation from parallel to sequential code. 2.2 Program Dependence Graphs (PDGs) The Program Dependence Graph (PDG) <ref> [15] </ref> is a standard representation of control and data dependences derived from a sequential program and its CFG. Like CFG nodes, a PDG node represents an arbitrary sequential computation e.g. a basic block, a statement, or an operation. <p> Definition 2. A Program Dependence Graph P DG = (N; E cd ; E dd ; TYPE) is a rooted directed multigraph in which every node is reachable from the root. It consists of <ref> [15] </ref>: - N , a set of nodes. - E cd N fi N fi fT; F; U g, a set of labelled control dependence edges. Edge (a; b; L) 2 E cd identifies a control dependence from node a to node b with label L. <p> If TYPE = PREDICATE and if a's predicate value is evaluated to be L, then it causes an execution instance of b to be created. If TYPE = REGION, then an execution instance of b is always created <ref> [15, 33] </ref>. - E dd N fi N fi Contexts, a set of data dependence edges. Edge (a; b; C) 2 E dd identifies a data dependence from node a to node b with context C. <p> A node with TYPE = REGION serves as a summary node for a set of control dependence successors in a PDG. Region nodes are also useful for factoring sets of control dependence successors <ref> [15, 12] </ref>. 2 2.3 Parallel Program Graphs (PPGs) The Parallel Program Graph (PPG) is a general intermediate representation of parallel programs that includes PDGs and CFGs.
Reference: 16. <author> Jeanne Ferrante, Mary Mace, and Barbara Simons. </author> <title> Generating Sequential Code From Parallel Code. </title> <booktitle> Proceedings of the ACM 1988 International Conference on Supercomputing, </booktitle> <pages> pages 582-592, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: In this section, we analyze a restricted model of a PPG, as defined in <ref> [16, 38, 37] </ref>. We allow only the MGOTO node to have multiple control in-edges. <p> Generating a CFG from the CDG's of well-structured programs is reported in [22, 23]; such CDG's are trees and do not require any duplication. The IBM PTRAN system [3, 9, 33] generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs. The work presented in <ref> [14, 16] </ref> uses assumptions about the structure of CFG's derived from sequential programs, thereby limiting its applicability. <p> The IBM PTRAN system [3, 9, 33] generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs. The work presented in [14, 16] uses assumptions about the structure of CFG's derived from sequential programs, thereby limiting its applicability. The results presented in <ref> [16] </ref> consider the general problem in an informal manner by determining the order restrictions that had to hold for region node children of a region node. 8 Conclusions and Future Work In this paper, we have presented definitions and classifications of Parallel Program Graphs (PPGs), a general parallel program representation that
Reference: 17. <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractibility: A Guide to the Theory of NP-Completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: We now show that determining if there exists an execution sequence that deadlocks in a PPG with acyclic control edges is NP-hard. The transformation is from 3-SAT <ref> [17] </ref>: Given a Boolean expression E = (a1 i _a1 j _a1 k )^(a2 i _a2 j _ a2 k ) ^ : : :^ (am i _ am j _ am k ), with each clause c p = (ap i _ ap j _ ap k ) containing 3
Reference: 18. <author> Miland Girkar and Constantine Polychronopoulos. </author> <title> The HTG: An Intermediate Representation for Programs Based on Control and Data Dependences. </title> <type> Technical report, </type> <institution> Center for Supercomputing Res. and Dev.-University of Illinois, </institution> <month> May </month> <year> 1991. </year> <note> CSRD Rpt. No.1046. </note>
Reference-contexts: In practice, a control-independent synchronization is implemented by simple semaphore operations without needing to examine the execution histories at run-time <ref> [18] </ref>. As an optimization, one may observe that the three-way branching at the MGOTO node (S0) in Figure 3 can be replaced by two-way branching without any loss of parallelism. This is because node S5 has to wait for nodes S2 and S4 to complete before it can start execution. <p> Restriction d) limits their PPGs from representing thread-based parallel programs in their full generality e.g. the PPG from Figure 2 cannot be expressed in their PPG model because it is possible for node S4 to be executed twice. The Hierarchical Task Graph (HTG) proposed by Girkar and Polychronopou-los <ref> [18] </ref> is another variant of the PPG, applicable only to structured programs that can be represented by the hierarchy defined in the HTG. One of the central issues in defining PDGs and PPGs is in defining their parallel execution semantics.
Reference: 19. <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Region Scheduling. </title> <booktitle> Proc. of the Second International Conferenece on Supercomputing, </booktitle> <volume> 3 </volume> <pages> 141-148, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization [15], vectorization [7], code generation for VLIW machines <ref> [19] </ref>, merging versions of programs [22], and automatic detection and management of parallelism [3, 33, 32]. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25].
Reference: 20. <author> P. Brinch Hansen. </author> <title> The programming language Concurrent Pascal. </title> <journal> IEEE Transactions on Software engineering, </journal> <volume> SE-1(2):199-206, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: With code duplication, this PPG can be made serializable by splitting node S4 into two copies, one for parent node S2 and one for parent node S3. construct [29], which is similar to the cobegin-coend construct <ref> [20] </ref>. This PPG contains both control edges and synchronization edges.
Reference: 21. <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, Inc., </publisher> <year> 1977. </year>
Reference-contexts: For reducibility, we extend the definition used for CFGs so that it is applicable to PPGs as well: a PPG is reducible if each strongly connected region of its control edges has a single entry node <ref> [2, 21, 1] </ref>; otherwise, a PPG is said to be irreducible. This classification of a PPG's control edges as acyclic/reducible/arbitrary is interesting because of the characterizations that can then be made. Note that each class is properly contained within the next, with irreducible PPGs being the most general case.
Reference: 22. <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> Integrating Non-Interfering Versions of Programs. </title> <booktitle> Conf. Rec. Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-145, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization [15], vectorization [7], code generation for VLIW machines [19], merging versions of programs <ref> [22] </ref>, and automatic detection and management of parallelism [3, 33, 32]. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25]. <p> An equivalent problem can arise when trying automatically to merge different versions of a program which have been updated in parallel by several people <ref> [22, 23] </ref>. Serialization customarily involves transforming the PPG to a CFG, from which the sequential code is then derived. Whenever possible, the CFG is constructed without duplicating nodes or inserting Boolean guard variables. <p> The serialization problem has been addressed in some prior work. Generating a CFG from the CDG's of well-structured programs is reported in <ref> [22, 23] </ref>; such CDG's are trees and do not require any duplication. The IBM PTRAN system [3, 9, 33] generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs.
Reference: 23. <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> On the Adequacy of Program Dependence Graphs for Representing Programs. </title> <booktitle> Conf. Rec. Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146-157, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: An equivalent problem can arise when trying automatically to merge different versions of a program which have been updated in parallel by several people <ref> [22, 23] </ref>. Serialization customarily involves transforming the PPG to a CFG, from which the sequential code is then derived. Whenever possible, the CFG is constructed without duplicating nodes or inserting Boolean guard variables. <p> The serialization problem has been addressed in some prior work. Generating a CFG from the CDG's of well-structured programs is reported in <ref> [22, 23] </ref>; such CDG's are trees and do not require any duplication. The IBM PTRAN system [3, 9, 33] generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs.
Reference: 24. <editor> Paul Hudak and Philip Wadler et al. </editor> <title> Report on the Functional Programming Language Haskell. </title> <type> Technical report, </type> <institution> Yale University, </institution> <year> 1988. </year> <note> Research Report YALEU/DCS/RR-666. </note>
Reference-contexts: Synchronization edges in PPGs can be used to model program constructs that cannot be modelled with data dependence edges in PDGs e.g. a PPG may enforce a synchronization with distance vector (1), from the "next" iteration of a loop to the "previous" iteration, as in (say) Haskell array constructors <ref> [24] </ref> or I-structures [5], while such data dependences are prohibited in PDGs because they are not plausible with reference to the sequential program from which the PDG was derived. Definition 3.
Reference: 25. <author> Peter Ladkin and Barbara Simons. </author> <title> Compile-Time Analysis of Communicating Processes. </title> <booktitle> Proc. of the ACM 1992 International Conference on Supercomputing, </booktitle> <pages> pages 248-259, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation <ref> [25] </ref>. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. PPGs contain control edges that represent parallel flow of control, and synchronization edges that impose ordering constraints on execution instances of PPG nodes.
Reference: 26. <author> L. Lamport. </author> <title> The Parallel Execution of DO Loops. </title> <journal> Communications of the ACM, </journal> <volume> 17(2) </volume> <pages> 83-93, </pages> <month> February </month> <year> 1974. </year>
Reference-contexts: Edge (a; b; C) 2 E dd identifies a data dependence from node a to node b with context C. The context C identifies the pairs of execution instances of nodes a and b that must be synchronized. Direction vectors [40] and distance vectors <ref> [26] </ref> are common approaches to representing contexts of data dependences; the gist [30] and the last-write tree [27] are newer representations for data dependence contexts that provide more information. Context information can identify a data dependence as being loop-independent or loop-carried [4].
Reference: 27. <author> Dror E. Maydan, Saman P. Amarasinghe, and Monica S. Lam. </author> <title> Array Data-Flow Analysis and its Use in Array Privatization. </title> <booktitle> Conf. Rec. Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: The context C identifies the pairs of execution instances of nodes a and b that must be synchronized. Direction vectors [40] and distance vectors [26] are common approaches to representing contexts of data dependences; the gist [30] and the last-write tree <ref> [27] </ref> are newer representations for data dependence contexts that provide more information. Context information can identify a data dependence as being loop-independent or loop-carried [4].
Reference: 28. <author> Samuel Midkiff, David Padua, and Ron Cytron. </author> <title> Compiling Programs with User Parallelism. </title> <booktitle> Proceedings of the Second Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1989. </year>
Reference-contexts: There has been some recent work in the area of program analysis in the presence of structured parallel language constructs <ref> [28, 39] </ref>. However, just as the control flow graph is the representation of choice (due to its simplicity and generality) for analyzing sequential programs, it would be desirable to use the PPG representation as a simple and general representation for parallel programs.
Reference: 29. <author> PCF. </author> <title> Parallel Computing Forum, </title> <type> Final Report. Technical report, </type> <institution> Kuck and Associates, Incorporated, </institution> <year> 1990. </year> <note> In preparation. </note>
Reference-contexts: With code duplication, this PPG can be made serializable by splitting node S4 into two copies, one for parent node S2 and one for parent node S3. construct <ref> [29] </ref>, which is similar to the cobegin-coend construct [20]. This PPG contains both control edges and synchronization edges.
Reference: 30. <author> W. Pugh and D. Wonnacott. </author> <title> Eliminating false data dependences using the omega test. </title> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, California, </address> <pages> pages 140-151, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The context C identifies the pairs of execution instances of nodes a and b that must be synchronized. Direction vectors [40] and distance vectors [26] are common approaches to representing contexts of data dependences; the gist <ref> [30] </ref> and the last-write tree [27] are newer representations for data dependence contexts that provide more information. Context information can identify a data dependence as being loop-independent or loop-carried [4].
Reference: 31. <author> Vivek Sarkar. </author> <title> Determining Average Program Execution Times and their Variance. </title> <booktitle> Proceedings of the 1989 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <volume> 24(7) </volume> <pages> 298-312, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Finally, section 7 discusses related work, and section 8 contains the conclusions of this paper and an outline of possible directions for future work. 2 Definition of PPGs 2.1 Control Flow Graphs (CFGs) We begin with the definition of a control flow graph as presented in <ref> [31, 11, 33] </ref>. It differs from the usual definition [1, 15] by the inclusion of a set of labels for edges and a mapping of node types.
Reference: 32. <author> Vivek Sarkar. </author> <title> Automatic Partitioning of a Program Dependence Graph into Parallel Tasks. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 35(5/6), </volume> <year> 1991. </year>
Reference-contexts: PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization [15], vectorization [7], code generation for VLIW machines [19], merging versions of programs [22], and automatic detection and management of parallelism <ref> [3, 33, 32] </ref>. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25]. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. <p> Fig. 3. Example of structured PPG with control and synchronization edges parallelism. As future work, it would be interesting to extend existing algorithms for selecting useful parallelism from PDGs (e.g. <ref> [32] </ref>) to operate more generally on PPGs. 4 Classification of PPGs 4.1 Classification criteria In this subsection, we characterize PPGs based on the nature of their control edges and synchronization edges. Control edges.
Reference: 33. <author> Vivek Sarkar. </author> <title> The PTRAN Parallel Programming System. </title> <booktitle> Parallel Functional Programming Languages and Compilers, </booktitle> <pages> pages 309-391, </pages> <year> 1991. </year>
Reference-contexts: PPGs are a generalization of Program Dependence Graphs (PDGs), which have been shown to be useful for solving a variety of problems, including optimization [15], vectorization [7], code generation for VLIW machines [19], merging versions of programs [22], and automatic detection and management of parallelism <ref> [3, 33, 32] </ref>. PPGs are useful for determining the semantic equivalence of parallel programs [35, 10, 34], and also have applications to automatic code generation [25]. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. <p> Finally, section 7 discusses related work, and section 8 contains the conclusions of this paper and an outline of possible directions for future work. 2 Definition of PPGs 2.1 Control Flow Graphs (CFGs) We begin with the definition of a control flow graph as presented in <ref> [31, 11, 33] </ref>. It differs from the usual definition [1, 15] by the inclusion of a set of labels for edges and a mapping of node types. <p> If TYPE = PREDICATE and if a's predicate value is evaluated to be L, then it causes an execution instance of b to be created. If TYPE = REGION, then an execution instance of b is always created <ref> [15, 33] </ref>. - E dd N fi N fi Contexts, a set of data dependence edges. Edge (a; b; C) 2 E dd identifies a data dependence from node a to node b with context C. <p> This idea is an extension of the control sequencing transformation used in the PTRAN system to replace a data synchronization by sequential control <ref> [13, 33] </ref>. <p> The serialization problem has been addressed in some prior work. Generating a CFG from the CDG's of well-structured programs is reported in [22, 23]; such CDG's are trees and do not require any duplication. The IBM PTRAN system <ref> [3, 9, 33] </ref> generates CFGs from the CDGs of unstructured (i.e. not necessarily trees) FORTRAN programs. The work presented in [14, 16] uses assumptions about the structure of CFG's derived from sequential programs, thereby limiting its applicability.
Reference: 34. <author> Vivek Sarkar. </author> <title> A Concurrent Execution Semantics for Parallel Program Graphs and Program Dependence Graphs (Extended Abstract). </title> <type> Technical Report YALEU/DCS/RR-915, </type> <institution> Yale University, Department of Computer Science, </institution> <month> August </month> <year> 1992. </year> <booktitle> Conference Record of the 5th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <institution> Yale University, </institution> <month> August 3-5, </month> <year> 1992. </year>
Reference-contexts: PPGs are useful for determining the semantic equivalence of parallel programs <ref> [35, 10, 34] </ref>, and also have applications to automatic code generation [25]. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. <p> Control edges in PPGs can be used to model program constructs that cannot be modelled by control dependence edges in PDGs e.g. PPGs can represent non-serializable parallel programs <ref> [37, 36, 34] </ref>. <p> Definition 3. A Parallel Program Graph P P G = (N; E cont ; E sync ; TYPE) is a rooted directed multigraph in which every node is reachable from the root using only control edges. It consists of <ref> [34] </ref>: 1. N , a set of nodes. 2. E cont N fi N fi fT; F; U g, a set of labelled control edges. Edge (a; b; L) 2 E cont identifies a control edge from node a to node b with label L. 3. <p> The control edges of a PPG specify how execution instances of PPG nodes are created (unravelled), and the synchronization edges of a PPG specify how execution instances need to be synchronized. A formal definition of the execution semantics of mgoto edges and synchronization edges is given in <ref> [34] </ref>. We would like to have a definition for synchronization edges that corresponds to the notion of loop-independent data dependence edges in sequential programs [40]. <p> x of PPG node x with execution history H (I x ) =&lt; u 1 ; L 1 ; : : : ; u i ; : : : ; u j ; : : : ; u k ; L k &gt;, u k = x (as defined in <ref> [34] </ref>). We define nodeprefix (H (I x ); a) (the nodeprefix of execution history H (I x ) with respect to the PPG node a) as follows. If there is no occurrence of node a in H (I x ), then nodeprefix (H (I x ); a) =?. <p> the algorithm can be used as the basis of a heuristic that duplicates subgraphs or adds guard variables. 7 Related Work The idea of extending PDGs to PPGs was introduced by Ferrante and Mace in [14], extended by Simons, Alpern, and Ferrante in [38], and further extended by Sarkar in <ref> [34] </ref>. The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. <p> adds guard variables. 7 Related Work The idea of extending PDGs to PPGs was introduced by Ferrante and Mace in [14], extended by Simons, Alpern, and Ferrante in [38], and further extended by Sarkar in <ref> [34] </ref>. The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. <p> extending PDGs to PPGs was introduced by Ferrante and Mace in [14], extended by Simons, Alpern, and Ferrante in [38], and further extended by Sarkar in <ref> [34] </ref>. The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. <p> Also, the control structures in the language W were restricted to if-then-else and while-do; the semantics did not cover programs with arbitrary control flow. In contrast, the semantics defined by Sarkar <ref> [34] </ref> is applicable to PDGs with arbitrary (unstructured) control flow and arbitrary data read and write accesses, and more generally to PPGs as defined in this paper. The serialization problem has been addressed in some prior work. <p> Develop a common compilation and execution environment for different par allel programming languages The PPG can be used as the basis for a common compilation and execution environment for parallel programs written in different languages. The scheduling system defined in <ref> [34] </ref> can be developed into a PPG-based interpreter, debugger, or runtime system for parallel programs, that provides feedback to the user about the parallel program's execution (e.g. parallelism profiles, detection of read-write or write-write hazards, detection of deadlock, etc.).
Reference: 35. <author> Rebecca Parsons Selke. </author> <title> A Rewriting Semantics for Program Dependence Graphs. </title> <booktitle> Sixteenth ACM Principles of Programming Languages Symposium, </booktitle> <month> January 11-13 </month> <year> 1989. </year> <institution> Austin, Texas. </institution>
Reference-contexts: PPGs are useful for determining the semantic equivalence of parallel programs <ref> [35, 10, 34] </ref>, and also have applications to automatic code generation [25]. In section 2, we define PPGs as a more general intermediate representation of parallel programs than PDGs. <p> One of the central issues in defining PDGs and PPGs is in defining their parallel execution semantics. The semantics of PDGs has been examined in past work by Selke, by Cartwright and Felleisen, and by Sarkar. In <ref> [35] </ref>, Selke presented an operational semantics for PDGs based on graph rewriting. In [10], Cartwright and Felleisen presented a denotational semantics for PDGs, and showed how it could be used to generate an equivalent functional, dataflow program.
Reference: 36. <author> B. Simons. </author> <title> Constructing a Constructing a Control Flow Graph for Parallel Code. </title> <type> Technical report. </type> <note> To appear. </note>
Reference-contexts: Control edges in PPGs can be used to model program constructs that cannot be modelled by control dependence edges in PDGs e.g. PPGs can represent non-serializable parallel programs <ref> [37, 36, 34] </ref>. <p> We have chosen a definition that does not depend on isomorphism <ref> [37, 36] </ref>. Given two graphs G and G 0 , where G is an acyclic CDG and G 0 is a CFG, we say that G 0 is semantically equivalent to G if: 1. <p> Because a CDG G has no post-dominance, one can prove that the following condition must hold in any CFG G 0 that corresponds to an acyclic CDG G that satisfies the pred-anc cond <ref> [36] </ref>. 3. Suppose a and b are PREDICATE or COMPUTE nodes in G. Then if a precedes b in G, then no copy of b precedes a copy of a in G 0 . <p> Although the algorithm does not explicitly deal with data dependences, it can be modified to do so. The difficulty with the above approach is that when the algorithm fails, it does not provide any information as to why it fails. Algorithm Sequentialize. Algorithm Sequentialize <ref> [37, 36] </ref> is based on analysis that states that a CFG G 0 can be constructed from a PDG G without node duplication if and only if there is no "forbidden subgraph". <p> Restriction c) limits their PPGs from being 6 The model presented in [6] differs somewhat from that of <ref> [37, 36] </ref>. However, the models are essentially equivalent. able to represent CFGs. Restriction d) limits their PPGs from representing thread-based parallel programs in their full generality e.g. the PPG from Figure 2 cannot be expressed in their PPG model because it is possible for node S4 to be executed twice.
Reference: 37. <author> B. Simons and J. Ferrante. </author> <title> An Efficient Algorithm for Constructing a Control Flow Graph for Parallel Code. </title> <type> Technical report, </type> <institution> IBM, </institution> <month> February </month> <year> 1993. </year> <type> Technical Report TR 03.465-1. </type>
Reference-contexts: Control edges in PPGs can be used to model program constructs that cannot be modelled by control dependence edges in PDGs e.g. PPGs can represent non-serializable parallel programs <ref> [37, 36, 34] </ref>. <p> In this section, we analyze a restricted model of a PPG, as defined in <ref> [16, 38, 37] </ref>. We allow only the MGOTO node to have multiple control in-edges. <p> For the remainder of this section, we assume as input a PPG that satisfies the pred-anc cond and the node restrictions discussed above. Even if the pred-anc cond is satisfied, there are PPGs for which node duplication or guard variable insertion is unavoidable <ref> [37] </ref>. The Control Dependence Graph (CDG) is the subgraph of the PPG that represents only the control dependences (or control edges). The CDG encapsulates the difficulty of translating the PPG into a CFG. <p> We have chosen a definition that does not depend on isomorphism <ref> [37, 36] </ref>. Given two graphs G and G 0 , where G is an acyclic CDG and G 0 is a CFG, we say that G 0 is semantically equivalent to G if: 1. <p> Although the algorithm does not explicitly deal with data dependences, it can be modified to do so. The difficulty with the above approach is that when the algorithm fails, it does not provide any information as to why it fails. Algorithm Sequentialize. Algorithm Sequentialize <ref> [37, 36] </ref> is based on analysis that states that a CFG G 0 can be constructed from a PDG G without node duplication if and only if there is no "forbidden subgraph". <p> Restriction c) limits their PPGs from being 6 The model presented in [6] differs somewhat from that of <ref> [37, 36] </ref>. However, the models are essentially equivalent. able to represent CFGs. Restriction d) limits their PPGs from representing thread-based parallel programs in their full generality e.g. the PPG from Figure 2 cannot be expressed in their PPG model because it is possible for node S4 to be executed twice.
Reference: 38. <author> Barbara Simons, David Alpern, and Jeanne Ferrante. </author> <title> A Foundation for Sequen-tializing Parallel Code. </title> <booktitle> Proceedings of the ACM 1990 Symposium on Parallel Algorithms and Architecture, </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: Serialization is the process of transforming a PPG into a semantically equivalent sequential CFG with neither node duplication nor creation of Boolean guards. It has already been shown that there exist PPGs that are not serializable <ref> [14, 38] </ref>, which is another reason why PPGs are more general than PDGs. In section 6, we further study the serialization problem by characterizing the serializability of different classes of PPGs. <p> In this section, we analyze a restricted model of a PPG, as defined in <ref> [16, 38, 37] </ref>. We allow only the MGOTO node to have multiple control in-edges. <p> When duplication is required, the algorithm can be used as the basis of a heuristic that duplicates subgraphs or adds guard variables. 7 Related Work The idea of extending PDGs to PPGs was introduced by Ferrante and Mace in [14], extended by Simons, Alpern, and Ferrante in <ref> [38] </ref>, and further extended by Sarkar in [34]. The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. <p> The definition of PPGs used in this paper is similar to the definition from [34]; the only difference is that the definition in [34] used mgoto edges instead of mgoto nodes. The PPG definition used in <ref> [14, 38] </ref> imposed several restrictions: a) the PPGs could not contain loop-carried data dependences (synchronizations), b) only reducible loops were considered, c) PPGs had to satisfy the no-post-dominator rule, and d) PPGs had to satisfy the pred-anc rule. The PPGs defined in this paper have none of these restrictions.
Reference: 39. <author> Harini Srinivasan and Michael Wolfe. </author> <title> Analyzing Programs with Explicit Parallelism. </title> <booktitle> Proceedings of the Fourth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1991. </year> <note> To be published by Springer-Verlag. </note>
Reference-contexts: There has been some recent work in the area of program analysis in the presence of structured parallel language constructs <ref> [28, 39] </ref>. However, just as the control flow graph is the representation of choice (due to its simplicity and generality) for analyzing sequential programs, it would be desirable to use the PPG representation as a simple and general representation for parallel programs.
Reference: 40. <author> Michael J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> Pitman, London and The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year> <title> In the series, Research Monographs in Parallel and Distributed Computing. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Edge (a; b; C) 2 E dd identifies a data dependence from node a to node b with context C. The context C identifies the pairs of execution instances of nodes a and b that must be synchronized. Direction vectors <ref> [40] </ref> and distance vectors [26] are common approaches to representing contexts of data dependences; the gist [30] and the last-write tree [27] are newer representations for data dependence contexts that provide more information. Context information can identify a data dependence as being loop-independent or loop-carried [4]. <p> A formal definition of the execution semantics of mgoto edges and synchronization edges is given in [34]. We would like to have a definition for synchronization edges that corresponds to the notion of loop-independent data dependence edges in sequential programs <ref> [40] </ref>. If nodes a and x are in a loop in a sequential program and have a loop-independent data dependence between them, then whenever x is executed in an iteration of the loop, an instance of a also must be executed prior to x in that same loop iteration. <p> Restrictions a) and b) limit their PPGs from being able to represent all PDGs that can be derived from sequential programs; restriction a) is a serious limitation in practice, given the important role played by loop-carried data dependences in representing loop parallelism <ref> [40] </ref>. Restriction c) limits their PPGs from being 6 The model presented in [6] differs somewhat from that of [37, 36]. However, the models are essentially equivalent. able to represent CFGs.
References-found: 40

