URL: http://www.cms.dmu.ac.uk:80/Research/CSTR/1995/cstr95-7.ps.gz
Refering-URL: http://www.cms.dmu.ac.uk:80/Research/CSTR/1995/
Root-URL: 
Phone: 2  
Title: Parallel composition of assumption-commitment specifications a unifying approach for shared variable and distributed message passing concurrency  
Author: A.Cau ? and P.Collette ?? 
Address: Kiel, D-24105 Kiel, Germany  B-1348 Louvain-la-Neuve, Belgium  
Affiliation: 1 Institut fur Informatik und Praktische Mathematik II, Christian-Albrechts-Universitat zu  Departement d'Ingenierie Informatique, Universite Catholique de Louvain,  
Abstract: We unify the parallel composition rule of assumption-commitment specifications for respectively state-based and message-based concurrent processes. Without providing language- dependent definitions, we first assume that the model of a process can be given as a set of `sequences' (e.g., traces, state sequences). Then we assume the existence of a merging operator that captures the compositionality of that model. On this basis, we formulate a semantic parallel composition rule for assumption-commitment specifications wherein the merging operator behaves as a parameter. Then, by providing suitable language-specific definitions for the model of a process and the merging operator, we transform the semantic rule into syntactic ones, both for the state-based and message-based approaches to concurrency.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abadi, M., Lamport, L.: </author> <title> An old-fashioned recipe for real time. </title> <editor> In: de Bakker, J.W., Huizing, C., de 21 Roever, W.-P., Rozenberg, G. (eds.) </editor> <title> Real time: </title> <note> theory in practice. (Lect. Notes Comput. Sci., vol. 600, pp 1-27) Springer-Verlag 1992 </note>
Reference-contexts: Nevertheless, we believe that other instances of our semantic rule can be derived. In particular, the commitment may include (liveness) temporal formulas like 2 (P ) 3Q); examples are given in <ref> [1, 11] </ref>. Previous work by Pandya and Joseph in message-based concurrency [19, 21] indicates that asynchronous channels might be incorporated at a reasonable cost: configurations record the sequence of buffered messages and specifications distinguish between traces of sent messages and traces of received ones.
Reference: 2. <author> Abadi, M., Lamport, L.: </author> <title> Composing specifications. </title> <journal> ACM Trans. on Prog. Lang. and Syst. </journal> <volume> 15 (1), </volume> <month> 73-132 </month> <year> (1993) </year>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> To achieve this goal, we show that the parallel rules for state-based and message-based approaches are particular instances of the same semantic rule. This semantic rule, which is independent of the communication mechanism, takes its origin in <ref> [2, 4] </ref> and has been further investigated in [12]; however, the version proposed here is slightly different and more similar to the one in [3]. It is also more abstract in the sense that parallel composition is represented by a semantic merging operator that can be instantiated in several ways. <p> We then use C to denote the pair (SC; OC). This notation indicates that the safety commitments, represented by SC at the semantic level, are clearly identified from other commitments. The rules in <ref> [2, 3] </ref> focus on the particular case where SC is the smallest safety set greater than SC " OC but keeping this generality allows a direct mapping into the specifications of [17, 21] that we want to consider in this paper. Example 1. <p> Example 1. We later consider a tuple (pre; rely; guar; post) of predicates. Then, SA, SC, and OC are the sets of computations allowed by (pre; rely), (guar), and (post) respectively. Given these sets, assumption-commitment specifications can be interpreted in several ways (see <ref> [2, 3, 13] </ref> for a detailed discussion). The simplest interpretation is given by SA ! C: if the (complete) computation satisfies the assumptions, it must satisfy all the commitments. <p> fi 1 fi 2 : 2 SA ^ 1 2 OC 1 ^ 2 2 OC 2 ) 2 OC] N fi 2 M (P 2 ) (SAfi ! C) (3) Although carried out in another framework, the proof of Theorem 1 (see appendix) is similar to other proofs in <ref> [2, 3, 4, 12] </ref>. A comparison with the rule of [3], also based on the interpretation SAfi ! C, will be given in Sect. 6. <p> This interpretation is classical in (synchronous) message-based concurrency [18, 21, 31] but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained <ref> [2, 14, 26, 27, 30] </ref>. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work [2] on composing assumption-commitment specifications at the semantic level. <p> In the latter case, only the part SA ! C is retained [2, 14, 26, 27, 30]. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work <ref> [2] </ref> on composing assumption-commitment specifications at the semantic level. The composition rule of [2] is based on the interpretation SA ! C; it certainly covers the specifications of state-based processes in Sect. 4 but its additional hypotheses do not hold for the specifications of message-based processes in Sect. 5. <p> However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work <ref> [2] </ref> on composing assumption-commitment specifications at the semantic level. The composition rule of [2] is based on the interpretation SA ! C; it certainly covers the specifications of state-based processes in Sect. 4 but its additional hypotheses do not hold for the specifications of message-based processes in Sect. 5.
Reference: 3. <author> Abadi, M., Lamport, L.: </author> <title> Conjoining specifications, </title> <institution> Digital Equipment Corporation Systems Research Center, </institution> <note> Research Report 118, </note> <year> 1993. </year>
Reference-contexts: This semantic rule, which is independent of the communication mechanism, takes its origin in [2, 4] and has been further investigated in [12]; however, the version proposed here is slightly different and more similar to the one in <ref> [3] </ref>. It is also more abstract in the sense that parallel composition is represented by a semantic merging operator that can be instantiated in several ways. Actually, this operator reflects the compositionality of the computational model. <p> We then use C to denote the pair (SC; OC). This notation indicates that the safety commitments, represented by SC at the semantic level, are clearly identified from other commitments. The rules in <ref> [2, 3] </ref> focus on the particular case where SC is the smallest safety set greater than SC " OC but keeping this generality allows a direct mapping into the specifications of [17, 21] that we want to consider in this paper. Example 1. <p> Example 1. We later consider a tuple (pre; rely; guar; post) of predicates. Then, SA, SC, and OC are the sets of computations allowed by (pre; rely), (guar), and (post) respectively. Given these sets, assumption-commitment specifications can be interpreted in several ways (see <ref> [2, 3, 13] </ref> for a detailed discussion). The simplest interpretation is given by SA ! C: if the (complete) computation satisfies the assumptions, it must satisfy all the commitments. <p> fi 1 fi 2 : 2 SA ^ 1 2 OC 1 ^ 2 2 OC 2 ) 2 OC] N fi 2 M (P 2 ) (SAfi ! C) (3) Although carried out in another framework, the proof of Theorem 1 (see appendix) is similar to other proofs in <ref> [2, 3, 4, 12] </ref>. A comparison with the rule of [3], also based on the interpretation SAfi ! C, will be given in Sect. 6. <p> A comparison with the rule of <ref> [3] </ref>, also based on the interpretation SAfi ! C, will be given in Sect. 6. <p> The composition rule of [2] is based on the interpretation SA ! C; it certainly covers the specifications of state-based processes in Sect. 4 but its additional hypotheses do not hold for the specifications of message-based processes in Sect. 5. In their subsequent work <ref> [3] </ref>, Abadi and Lamport have proposed a new rule, based on the interpretation SAfi ! C where SC is the smallest safety set greater than OC " SC. In order to obtain the latter from our semantic rule, we first observe that, in their TLA approach, composition is conjunction. <p> " SC 2 SA 1 " SA 2 SA " OC 1 " OC 2 OC Then, we observe (see last proof step of Theorem 1 in the appendix) that the second premise above can be replaced with SA + " SC 1 " SC 2 SC where SA + <ref> [3] </ref> captures the `one step delay': j k 2 SA + j k1 2 SA.
Reference: 4. <author> Abadi, M., Plotkin, G.D.: </author> <title> A logical view of composition. </title> <note> TCS 114 3-30 (1993) </note>
Reference-contexts: To achieve this goal, we show that the parallel rules for state-based and message-based approaches are particular instances of the same semantic rule. This semantic rule, which is independent of the communication mechanism, takes its origin in <ref> [2, 4] </ref> and has been further investigated in [12]; however, the version proposed here is slightly different and more similar to the one in [3]. It is also more abstract in the sense that parallel composition is represented by a semantic merging operator that can be instantiated in several ways. <p> fi 1 fi 2 : 2 SA ^ 1 2 OC 1 ^ 2 2 OC 2 ) 2 OC] N fi 2 M (P 2 ) (SAfi ! C) (3) Although carried out in another framework, the proof of Theorem 1 (see appendix) is similar to other proofs in <ref> [2, 3, 4, 12] </ref>. A comparison with the rule of [3], also based on the interpretation SAfi ! C, will be given in Sect. 6.
Reference: 5. <author> Aczel, P.: </author> <title> On an inference rule for parallel composition. </title> <type> Unpublished, </type> <institution> University of Manchester 1983 </institution>
Reference-contexts: A major characteristic of the proposed model is its compositionality. To achieve this, we adopt Aczel's view of parallel composition <ref> [5, 23] </ref> and incorporate environment steps in computations. 5 3.1 Syntax Definition 5 (Basis). Let P V be the set of process variables and Chan be the set of channel names. <p> In message-based concurrency, compositional trace models of P can be obtained by linking successive transitions. In state-based concurrency, compositionality is achieved only if the model copes with interferences [17], i.e. modifications of the shared variables by the environment of P . As proposed by Aczel <ref> [5] </ref>, it suffices to extend the set of transitions by allowing arbitrary environment transitions. These new transitions, that we label with e, are defined in Table 3; a similar construction can be found in [6, 23, 26, 27, 30].
Reference: 6. <author> Barringer, H., Kuiper, R., Pnueli, A.: </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In: Proc. 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pp. </pages> <month> 51-63 </month> <year> 1984 </year>
Reference-contexts: As proposed by Aczel [5], it suffices to extend the set of transitions by allowing arbitrary environment transitions. These new transitions, that we label with e, are defined in Table 3; a similar construction can be found in <ref> [6, 23, 26, 27, 30] </ref>.
Reference: 7. <author> Barringer, H., Kuiper, R., Pnueli, A.: </author> <title> A compositional temporal approach to a CSP-like language. </title> <editor> In: Neuhold, E.J., Chroust, G. (eds.) </editor> <booktitle> Formal Models of Programming. </booktitle> <publisher> Elsevier 1985 </publisher>
Reference-contexts: Table 3: State-based concurrency: extended semantics ` (P; s) ! fi (P; s 0 ) where s 0 dX = sdX In order to meet the requirements (1) and (2), we follow <ref> [7] </ref> and extend this construction to message-based concurrency: successive transitions of P can be interleaved with arbitrary communications over channels not connected to P and computation steps of the environment not involving P . These new transitions are defined in Table 4.
Reference: 8. <author> Brookes, </author> <title> S.D., Hoare, C.A.R., Roscoe, A.W.: A theory of communicating sequential processes. </title> <journal> J. ACM 31, </journal> <month> 560-599 </month> <year> (1984) </year>
Reference-contexts: In this paper, we focus on parallel composition only and refer to [21] for a treatment of network abstraction. The ready set Ready (P; s) (based on <ref> [8] </ref>) is defined in Table 2.
Reference: 9. <author> Broy, M.: </author> <title> Functional specification of time-sensitive communicating systems. </title> <journal> ACM Trans. on Soft. Eng. and Meth. </journal> <volume> 2 (1), </volume> <month> 1-46 </month> <year> (1993) </year>
Reference-contexts: Another possible extension of this work is the comparison of this semantic rule with rules for assumption-commitment specifications [28] of stream processing functions <ref> [9] </ref>. Indeed, stream processing functions define traces (that are `sequences') and the composition of functions corresponds to operations on traces (instances of ). Although it is sufficient for our purpose, a main restriction of the semantic rule in Sect. 2 is that it applies to safety assumptions only.
Reference: 10. <author> Cau, A., Kuiper, R., de Roever, W.-P.: </author> <title> Formalizing Dijkstra's development strategy within Stark's formalism. </title> <editor> In: Jones, C.B., Shaw, R.C. Denvir, T. (eds.) </editor> <booktitle> Proc. 5th BCS-FACS Refinement Workshop, </booktitle> <pages> pp 4-42. </pages> <publisher> Springer-Verlag 1992 </publisher>
Reference-contexts: Although it is sufficient for our purpose, a main restriction of the semantic rule in Sect. 2 is that it applies to safety assumptions only. Other rules have been devised to cope with liveness in the assumptions <ref> [10, 20, 22, 25] </ref>. In [20, 22], the mutual dependency problem is solved by the explicit construction of an ordering between assumption-commitment specifications; the premises then correspond to a proof by induction on that ordering. <p> Other rules have been devised to cope with liveness in the assumptions [10, 20, 22, 25]. In [20, 22], the mutual dependency problem is solved by the explicit construction of an ordering between assumption-commitment specifications; the premises then correspond to a proof by induction on that ordering. In <ref> [10, 25] </ref> the mutual dependency problem is solved by defining an acyclicity condition on the assumptions and commitments. However, the exact relation between rules with and without liveness assumptions is still unclear.
Reference: 11. <author> Collette, P.: </author> <title> Application of the composition principle to UNITY-like specifications. </title> <editor> In: Gaudel, M.- C., Jouannaud, J.-P., (eds.) </editor> <booktitle> Proc. TAPSOFT' 93. </booktitle> <address> (Lect. </address> <note> Notes Comput. Sci., vol 668, pp 230-242) Springer-Verlag 1993 </note>
Reference-contexts: Nevertheless, we believe that other instances of our semantic rule can be derived. In particular, the commitment may include (liveness) temporal formulas like 2 (P ) 3Q); examples are given in <ref> [1, 11] </ref>. Previous work by Pandya and Joseph in message-based concurrency [19, 21] indicates that asynchronous channels might be incorporated at a reasonable cost: configurations record the sequence of buffered messages and specifications distinguish between traces of sent messages and traces of received ones.
Reference: 12. <author> Collette,P.: </author> <title> An explanatory presentation of composition rules for assumption-commitment specifica-tions. </title> <journal> Inf. Proc. Letters (50), </journal> <pages> 31-35. </pages>
Reference-contexts: To achieve this goal, we show that the parallel rules for state-based and message-based approaches are particular instances of the same semantic rule. This semantic rule, which is independent of the communication mechanism, takes its origin in [2, 4] and has been further investigated in <ref> [12] </ref>; however, the version proposed here is slightly different and more similar to the one in [3]. It is also more abstract in the sense that parallel composition is represented by a semantic merging operator that can be instantiated in several ways. <p> fi 1 fi 2 : 2 SA ^ 1 2 OC 1 ^ 2 2 OC 2 ) 2 OC] N fi 2 M (P 2 ) (SAfi ! C) (3) Although carried out in another framework, the proof of Theorem 1 (see appendix) is similar to other proofs in <ref> [2, 3, 4, 12] </ref>. A comparison with the rule of [3], also based on the interpretation SAfi ! C, will be given in Sect. 6.
Reference: 13. <author> Collette, P.: </author> <title> Design of compositional proof systems based on assumption-commitment Specifications Application to UNITY. </title> <type> Ph.D. Thesis, </type> <institution> Universite Catholique de Louvain, </institution> <year> 1994. </year>
Reference-contexts: Example 1. We later consider a tuple (pre; rely; guar; post) of predicates. Then, SA, SC, and OC are the sets of computations allowed by (pre; rely), (guar), and (post) respectively. Given these sets, assumption-commitment specifications can be interpreted in several ways (see <ref> [2, 3, 13] </ref> for a detailed discussion). The simplest interpretation is given by SA ! C: if the (complete) computation satisfies the assumptions, it must satisfy all the commitments. <p> Nevertheless, if all processes can be proved to be divergence-free and deadlock-free, then termination is ensured. Notice that including a progress property in the definition of M (P ) would not alter the validity of the discussion (see <ref> [13, 27] </ref>): although proofs must be adapted, Theorems 2 and 3 still hold. Theorem 3 asserts that the interpretations SA ! C and SAfi ! C are equivalent for the assumption-commitment specifications of state-based processes. This establishes point 3. of our check-list at the end of Sect. 2. Theorem 3.
Reference: 14. <author> Grtnning, P., Nielsen, T.Q., Lovengreen, H.H.: </author> <title> Refinement and composition of transition-based relyguarantee specifications with auxiliary variables. </title> <editor> In: Veni Madhavan, C.E., Nori, K.V. (eds.) </editor> <booktitle> Proc. Foundations of Software Technology and Theoretical Computer Science. </booktitle> <address> (Lect. </address> <note> Notes Comput. Sci., vol 472, pp 332-348) Springer-Verlag 1991 </note>
Reference-contexts: This interpretation is classical in (synchronous) message-based concurrency [18, 21, 31] but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained <ref> [2, 14, 26, 27, 30] </ref>. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work [2] on composing assumption-commitment specifications at the semantic level.
Reference: 15. <author> Hennessy, M.: </author> <title> The semantics of programming languages. </title> <publisher> Wiley 1990 </publisher>
Reference-contexts: A variant of a state s with respect to a variable y and a value , denoted by (s : y 7! ), is given by (s : y 7! )(z) = , if z y where denotes syntactic equality. The operational semantics of processes (based on <ref> [15, 26] </ref>) is given in Table 1, by structural induction on the syntax of processes.
Reference: 16. <author> Jones, C.B.: </author> <title> Development methods for computer programs including a notion of interference. </title> <type> Ph.D. Thesis, </type> <institution> Oxford University, </institution> <year> 1981. </year>
Reference: 17. <author> Jones, C.B.: </author> <title> Tentative steps towards a development method for interfering programs. </title> <journal> ACM Trans. on Prog. Lang. and Syst. </journal> <volume> 5 (4), </volume> <month> 596-619 </month> <year> (1983) </year>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> of the rule for deducing a specification of P 1 kP 2 from the specifications of P 1 and P 2 is of the form A _ C 1 ) A 2 ? Partially Supported by ESPRIT Project 6021 (REACT). ?? Supported by National Fund for Scientific Research (Belgium). 1 <ref> [17, 27, 29, 30] </ref>, where A is the assumption of P 1 kP 2 , C 1 the commitment of P 1 , and A 2 the as-sumption of P 2 , i.e., the most prominent operator is disjunction. <p> The rules in [2, 3] focus on the particular case where SC is the smallest safety set greater than SC " OC but keeping this generality allows a direct mapping into the specifications of <ref> [17, 21] </ref> that we want to consider in this paper. Example 1. We later consider a tuple (pre; rely; guar; post) of predicates. Then, SA, SC, and OC are the sets of computations allowed by (pre; rely), (guar), and (post) respectively. <p> The former [18, 21, 31] are interpreted by SAfi ! C whereas the latter <ref> [17, 27, 30] </ref> are interpreted by SA ! C. Fortunately, as proved in Sect. 4, the latter can be equivalently interpreted by SAfi ! C which is thus the appropriate candidate for formulating the semantic rule. <p> In message-based concurrency, compositional trace models of P can be obtained by linking successive transitions. In state-based concurrency, compositionality is achieved only if the model copes with interferences <ref> [17] </ref>, i.e. modifications of the shared variables by the environment of P . As proposed by Aczel [5], it suffices to extend the set of transitions by allowing arbitrary environment transitions. <p> Theorem 2 (Compositionality). M (P 1 kP 2 ) = M (P 1 ) fi 1 N This completes points 1. and 2. of the check list at the end of Sect. 2. 4 State-based rule We first recall the format of assumption-commitment specifications for state-based processes <ref> [17, 27, 30] </ref> and interpret correctness formulas in terms of sets of computations. We then derive the corresponding syntactic parallel rule from the semantic rule by considering the points 3. and 4. of our check-list. 4.1 State-based process specifications First, the syntax and semantics of binary assertions is given. <p> Example 4. By combining Rule (4) with other adaptation rules, we may weaken the premise post 1 ^ post 2 ) post into dinv ^ post 1 ^ post 2 ) post. The additional binary assertion dinv (dynamic invariant <ref> [17] </ref>) expresses a relation between the initial state and any further state in a computation; this must be checked against the assertions pre (initially), rely (environment transition), guar 1 (transition of P 1 ), and guar 2 (transition of P 2 ).
Reference: 18. <author> Misra, J., Chandy, K.M.: </author> <title> Proofs of networks of processes. </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> 7 (4), </volume> <month> 417-426 </month> <year> (1981) </year>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> In the message-based approach, the corresponding premise is of the form A ^ C 1 ) A 2 <ref> [18, 21, 31, 32] </ref>, where A, C 1 and A 2 are as before, i.e., the most prominent operator is conjunction. <p> The former <ref> [18, 21, 31] </ref> are interpreted by SAfi ! C whereas the latter [17, 27, 30] are interpreted by SA ! C. Fortunately, as proved in Sect. 4, the latter can be equivalently interpreted by SAfi ! C which is thus the appropriate candidate for formulating the semantic rule. <p> In state-based concurrency, this label is always i. Notice that, following <ref> [18, 21] </ref>, we distinguish parallel composition from network abstraction (hiding of internal communications); introducing network abstraction requires an additional rule that transforms internal communications (labels of the form C:w) into computation steps (label i). <p> This interpretation is classical in (synchronous) message-based concurrency <ref> [18, 21, 31] </ref> but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained [2, 14, 26, 27, 30]. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). <p> In [10, 25] the mutual dependency problem is solved by defining an acyclicity condition on the assumptions and commitments. However, the exact relation between rules with and without liveness assumptions is still unclear. Nevertheless, Pandya [20] has shown that Misra-Chandy's rule for safety assumptions <ref> [18] </ref> can be derived from his rule. 7 Summary This paper has highlighted the relation between the parallel rules for (pre; rely;wait; guar; post) and (pre; rely; guar; post) specifications of state-based and message-based processes respectively. It has been shown that both are instances of the same semantic rule.
Reference: 19. <author> Pandya, P.K.: </author> <title> Compositional verification of distributed programs. </title> <type> Ph.D. Thesis, </type> <institution> University of Bombay 1988. </institution>
Reference-contexts: Nevertheless, we believe that other instances of our semantic rule can be derived. In particular, the commitment may include (liveness) temporal formulas like 2 (P ) 3Q); examples are given in [1, 11]. Previous work by Pandya and Joseph in message-based concurrency <ref> [19, 21] </ref> indicates that asynchronous channels might be incorporated at a reasonable cost: configurations record the sequence of buffered messages and specifications distinguish between traces of sent messages and traces of received ones.
Reference: 20. <author> Pandya, P.K.: </author> <title> Some comments on the assumption-commitment framework for compositional verifica-tion of distributed programs. </title> <editor> In: de Bakker, J.W., de Roever, W.-P., Rozenberg, G. (eds.) </editor> <title> Stepwise refinement of distributed systems. </title> <journal> (Lect. Notes Comput. Sci., </journal> <volume> vol 430, </volume> <pages> pp 622-640) Springer-Verlag 1990 </pages>
Reference-contexts: Although it is sufficient for our purpose, a main restriction of the semantic rule in Sect. 2 is that it applies to safety assumptions only. Other rules have been devised to cope with liveness in the assumptions <ref> [10, 20, 22, 25] </ref>. In [20, 22], the mutual dependency problem is solved by the explicit construction of an ordering between assumption-commitment specifications; the premises then correspond to a proof by induction on that ordering. <p> Although it is sufficient for our purpose, a main restriction of the semantic rule in Sect. 2 is that it applies to safety assumptions only. Other rules have been devised to cope with liveness in the assumptions [10, 20, 22, 25]. In <ref> [20, 22] </ref>, the mutual dependency problem is solved by the explicit construction of an ordering between assumption-commitment specifications; the premises then correspond to a proof by induction on that ordering. In [10, 25] the mutual dependency problem is solved by defining an acyclicity condition on the assumptions and commitments. <p> In [10, 25] the mutual dependency problem is solved by defining an acyclicity condition on the assumptions and commitments. However, the exact relation between rules with and without liveness assumptions is still unclear. Nevertheless, Pandya <ref> [20] </ref> has shown that Misra-Chandy's rule for safety assumptions [18] can be derived from his rule. 7 Summary This paper has highlighted the relation between the parallel rules for (pre; rely;wait; guar; post) and (pre; rely; guar; post) specifications of state-based and message-based processes respectively.
Reference: 21. <author> Pandya, P.K., Joseph, M.: </author> <title> P-A logic a compositional proof system for distributed programs. Distrib. </title> <journal> Comp. </journal> <volume> 5, </volume> <month> 37-54 </month> <year> (1991) </year> <month> 22 </month>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> In the message-based approach, the corresponding premise is of the form A ^ C 1 ) A 2 <ref> [18, 21, 31, 32] </ref>, where A, C 1 and A 2 are as before, i.e., the most prominent operator is conjunction. <p> The rules in [2, 3] focus on the particular case where SC is the smallest safety set greater than SC " OC but keeping this generality allows a direct mapping into the specifications of <ref> [17, 21] </ref> that we want to consider in this paper. Example 1. We later consider a tuple (pre; rely; guar; post) of predicates. Then, SA, SC, and OC are the sets of computations allowed by (pre; rely), (guar), and (post) respectively. <p> The former <ref> [18, 21, 31] </ref> are interpreted by SAfi ! C whereas the latter [17, 27, 30] are interpreted by SA ! C. Fortunately, as proved in Sect. 4, the latter can be equivalently interpreted by SAfi ! C which is thus the appropriate candidate for formulating the semantic rule. <p> In state-based concurrency, this label is always i. Notice that, following <ref> [18, 21] </ref>, we distinguish parallel composition from network abstraction (hiding of internal communications); introducing network abstraction requires an additional rule that transforms internal communications (labels of the form C:w) into computation steps (label i). <p> Notice that, following [18, 21], we distinguish parallel composition from network abstraction (hiding of internal communications); introducing network abstraction requires an additional rule that transforms internal communications (labels of the form C:w) into computation steps (label i). In this paper, we focus on parallel composition only and refer to <ref> [21] </ref> for a treatment of network abstraction. The ready set Ready (P; s) (based on [8]) is defined in Table 2. <p> : 6= ffi ) (s 0 :; s k :) j= wait 8k : P k : = ffi ) (s 0 :; s k :) j= post % Definition of WAIT; POST; OC 2 OC 5 Message-based rule We first recall the format of assumption-commitment specifications for message-based processes <ref> [21, 31, 32] </ref> and interpret correctness formulas in terms of sets of computations. We then derive the corresponding syntactic parallel rule from the semantic rule by considering the points 3. and 4. of our check-list. 5.1 Message-based process specifications First, the syntax and semantics of assertions is given. <p> The informal interpretation is as follows: guar holds initially and, if pre holds initially and rely holds initially and after each communication, then guar holds after each communication and post holds when the program terminates. As discussed in <ref> [21] </ref>, deadlock-freedom can be expressed within guar. For example, if the basis of P is ffA; Bg; fB; Cg; ;; Xg, the commitment for deadlock freedom is u _ en (fl) _ en (A?) _ en (C!) _ (en (B!) ^ en (B?)). <p> Since m; n; p; q are freeze variables, the specifications of P 1 and P 2 can be rewritten by replacing n,p,q with m,m,m + 3 respectively. Then, the premises of Rule (5) can be checked easily. If guar i includes flags, suitable renaming must be done <ref> [21] </ref>: the premise guar 1 ^guar 2 ) guar must be replaced by M erge ^ guar 1 [u 1 =u; en (fl 1 )=en (fl)] ^ guar 2 [u 2 =u; en (fl 2 )=en (fl)] ) guar where M erge = (u , u 1 ^ u 2 ) <p> This interpretation is classical in (synchronous) message-based concurrency <ref> [18, 21, 31] </ref> but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained [2, 14, 26, 27, 30]. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). <p> Nevertheless, we believe that other instances of our semantic rule can be derived. In particular, the commitment may include (liveness) temporal formulas like 2 (P ) 3Q); examples are given in [1, 11]. Previous work by Pandya and Joseph in message-based concurrency <ref> [19, 21] </ref> indicates that asynchronous channels might be incorporated at a reasonable cost: configurations record the sequence of buffered messages and specifications distinguish between traces of sent messages and traces of received ones.

Reference: 25. <author> Stark, </author> <title> E.W.: A proof technique for rely/guarantee properties. </title> <booktitle> In: Proc. Foundations of Software Technology and Theoretical Computer Science. </booktitle> <address> (Lect. </address> <note> Notes Comput. Sci., vol 206, pp 369-391) Springer-Verlag 1985 </note>
Reference-contexts: Although it is sufficient for our purpose, a main restriction of the semantic rule in Sect. 2 is that it applies to safety assumptions only. Other rules have been devised to cope with liveness in the assumptions <ref> [10, 20, 22, 25] </ref>. In [20, 22], the mutual dependency problem is solved by the explicit construction of an ordering between assumption-commitment specifications; the premises then correspond to a proof by induction on that ordering. <p> Other rules have been devised to cope with liveness in the assumptions [10, 20, 22, 25]. In [20, 22], the mutual dependency problem is solved by the explicit construction of an ordering between assumption-commitment specifications; the premises then correspond to a proof by induction on that ordering. In <ref> [10, 25] </ref> the mutual dependency problem is solved by defining an acyclicity condition on the assumptions and commitments. However, the exact relation between rules with and without liveness assumptions is still unclear.
Reference: 26. <author> Stirling, C.: </author> <title> A generalization of Owicki-Gries Hoare logic for a concurrent while language. </title> <type> TCS 58, </type> <month> 347-359 </month> <year> (1988) </year>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> A variant of a state s with respect to a variable y and a value , denoted by (s : y 7! ), is given by (s : y 7! )(z) = , if z y where denotes syntactic equality. The operational semantics of processes (based on <ref> [15, 26] </ref>) is given in Table 1, by structural induction on the syntax of processes. <p> As proposed by Aczel [5], it suffices to extend the set of transitions by allowing arbitrary environment transitions. These new transitions, that we label with e, are defined in Table 3; a similar construction can be found in <ref> [6, 23, 26, 27, 30] </ref>. <p> This motivates the definition of the merge operator , similar to previous definitions in <ref> [23, 26, 27, 30] </ref>. Definition 10 (State-based conjoining). <p> This interpretation is classical in (synchronous) message-based concurrency [18, 21, 31] but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained <ref> [2, 14, 26, 27, 30] </ref>. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work [2] on composing assumption-commitment specifications at the semantic level.
Reference: 27. <author> Sttlen, K.: </author> <title> A method for the development of totally correct shared-state parallel programs. </title> <editor> In: Baeten, J.C.M., Groote, J.F., (eds.), </editor> <booktitle> Proc. Concur '91. (Lect. Notes Comput. Sci., </booktitle> <volume> vol 527, </volume> <pages> pp 510525.) </pages> <publisher> Springer-Verlag 1991 </publisher>
Reference-contexts: of the rule for deducing a specification of P 1 kP 2 from the specifications of P 1 and P 2 is of the form A _ C 1 ) A 2 ? Partially Supported by ESPRIT Project 6021 (REACT). ?? Supported by National Fund for Scientific Research (Belgium). 1 <ref> [17, 27, 29, 30] </ref>, where A is the assumption of P 1 kP 2 , C 1 the commitment of P 1 , and A 2 the as-sumption of P 2 , i.e., the most prominent operator is disjunction. <p> The former [18, 21, 31] are interpreted by SAfi ! C whereas the latter <ref> [17, 27, 30] </ref> are interpreted by SA ! C. Fortunately, as proved in Sect. 4, the latter can be equivalently interpreted by SAfi ! C which is thus the appropriate candidate for formulating the semantic rule. <p> As proposed by Aczel [5], it suffices to extend the set of transitions by allowing arbitrary environment transitions. These new transitions, that we label with e, are defined in Table 3; a similar construction can be found in <ref> [6, 23, 26, 27, 30] </ref>. <p> This motivates the definition of the merge operator , similar to previous definitions in <ref> [23, 26, 27, 30] </ref>. Definition 10 (State-based conjoining). <p> Theorem 2 (Compositionality). M (P 1 kP 2 ) = M (P 1 ) fi 1 N This completes points 1. and 2. of the check list at the end of Sect. 2. 4 State-based rule We first recall the format of assumption-commitment specifications for state-based processes <ref> [17, 27, 30] </ref> and interpret correctness formulas in terms of sets of computations. We then derive the corresponding syntactic parallel rule from the semantic rule by considering the points 3. and 4. of our check-list. 4.1 State-based process specifications First, the syntax and semantics of binary assertions is given. <p> Nevertheless, if all processes can be proved to be divergence-free and deadlock-free, then termination is ensured. Notice that including a progress property in the definition of M (P ) would not alter the validity of the discussion (see <ref> [13, 27] </ref>): although proofs must be adapted, Theorems 2 and 3 still hold. Theorem 3 asserts that the interpretations SA ! C and SAfi ! C are equivalent for the assumption-commitment specifications of state-based processes. This establishes point 3. of our check-list at the end of Sect. 2. Theorem 3. <p> A proof system <ref> [27, 30] </ref> indeed includes adaptation rules such as weakening rules. Nevertheless, our formulation better highlights the relation with the semantic rule. <p> This interpretation is classical in (synchronous) message-based concurrency [18, 21, 31] but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained <ref> [2, 14, 26, 27, 30] </ref>. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work [2] on composing assumption-commitment specifications at the semantic level.
Reference: 28. <author> Sttlen, K., Dederichs, F., Weber, R.: </author> <title> Assumption/commitment rules for networks of asynchronously communicating agents. </title> <type> Technical Report SFB 342/2/93, </type> <institution> Technical University of Munich 1993 </institution>
Reference-contexts: Another possible extension of this work is the comparison of this semantic rule with rules for assumption-commitment specifications <ref> [28] </ref> of stream processing functions [9]. Indeed, stream processing functions define traces (that are `sequences') and the composition of functions corresponds to operations on traces (instances of ).
Reference: 29. <author> Woodcock, J.C.P., Dickinson, B.: </author> <title> Using VDM with rely and guarantee-conditions, </title> <editor> in Bloomfield, R., Marshall, L., Jones, R. (eds.). </editor> <title> Proc. VDM '88, The Way Ahead. </title> <journal> (Lect. Notes Comput. Sci., </journal> <volume> vol 328, </volume> <pages> pp 434-458.) </pages> <publisher> Springer-Verlag 1988 </publisher>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> of the rule for deducing a specification of P 1 kP 2 from the specifications of P 1 and P 2 is of the form A _ C 1 ) A 2 ? Partially Supported by ESPRIT Project 6021 (REACT). ?? Supported by National Fund for Scientific Research (Belgium). 1 <ref> [17, 27, 29, 30] </ref>, where A is the assumption of P 1 kP 2 , C 1 the commitment of P 1 , and A 2 the as-sumption of P 2 , i.e., the most prominent operator is disjunction.
Reference: 30. <author> Xu, Q., Jifeng, H.: </author> <title> A theory of state-based parallel programming: Part I. </title> <editor> In Morris, J. (ed.) </editor> <booktitle> Proc. 4th BCS-FACS Refinement Workshop, </booktitle> <pages> pp 326-359. </pages> <publisher> Springer-Verlag 1991 </publisher>
Reference-contexts: of the rule for deducing a specification of P 1 kP 2 from the specifications of P 1 and P 2 is of the form A _ C 1 ) A 2 ? Partially Supported by ESPRIT Project 6021 (REACT). ?? Supported by National Fund for Scientific Research (Belgium). 1 <ref> [17, 27, 29, 30] </ref>, where A is the assumption of P 1 kP 2 , C 1 the commitment of P 1 , and A 2 the as-sumption of P 2 , i.e., the most prominent operator is disjunction. <p> The former [18, 21, 31] are interpreted by SAfi ! C whereas the latter <ref> [17, 27, 30] </ref> are interpreted by SA ! C. Fortunately, as proved in Sect. 4, the latter can be equivalently interpreted by SAfi ! C which is thus the appropriate candidate for formulating the semantic rule. <p> As proposed by Aczel [5], it suffices to extend the set of transitions by allowing arbitrary environment transitions. These new transitions, that we label with e, are defined in Table 3; a similar construction can be found in <ref> [6, 23, 26, 27, 30] </ref>. <p> This motivates the definition of the merge operator , similar to previous definitions in <ref> [23, 26, 27, 30] </ref>. Definition 10 (State-based conjoining). <p> Theorem 2 (Compositionality). M (P 1 kP 2 ) = M (P 1 ) fi 1 N This completes points 1. and 2. of the check list at the end of Sect. 2. 4 State-based rule We first recall the format of assumption-commitment specifications for state-based processes <ref> [17, 27, 30] </ref> and interpret correctness formulas in terms of sets of computations. We then derive the corresponding syntactic parallel rule from the semantic rule by considering the points 3. and 4. of our check-list. 4.1 State-based process specifications First, the syntax and semantics of binary assertions is given. <p> A proof system <ref> [27, 30] </ref> indeed includes adaptation rules such as weakening rules. Nevertheless, our formulation better highlights the relation with the semantic rule. <p> This interpretation is classical in (synchronous) message-based concurrency [18, 21, 31] but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained <ref> [2, 14, 26, 27, 30] </ref>. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3). This work has been influenced by Abadi and Lamport's previous work [2] on composing assumption-commitment specifications at the semantic level.
Reference: 31. <author> Zwiers, J., de Bruin, A., de Roever, W.-P.: </author> <title> A proof system for partial correctness of dynamic networks of processes. </title> <booktitle> In: Proc. Conference on Logics of Programs 1983. </booktitle> <address> (Lect. </address> <note> Notes Comput. Sci., vol 164, pp 513-527) Springer-Verlag 1984 </note>
Reference-contexts: In both cases, certain compositional methods for the development of parallel or distributed systems are based on the assumption-commitment paradigm as this approach is called within the message-based concurrency community, also referred to as the rely-guarantee paradigm within the state-based concurrency community. Examples may be found in e.g. <ref> [2, 17, 18, 21, 22, 26, 29, 31] </ref>. Intuitively, an assumption-commitment specification of an open system (a process or a process network) asserts that the commitment of a system holds provided that the system operates in an environment that respects the assumption. <p> In the message-based approach, the corresponding premise is of the form A ^ C 1 ) A 2 <ref> [18, 21, 31, 32] </ref>, where A, C 1 and A 2 are as before, i.e., the most prominent operator is conjunction. <p> The former <ref> [18, 21, 31] </ref> are interpreted by SAfi ! C whereas the latter [17, 27, 30] are interpreted by SA ! C. Fortunately, as proved in Sect. 4, the latter can be equivalently interpreted by SAfi ! C which is thus the appropriate candidate for formulating the semantic rule. <p> : 6= ffi ) (s 0 :; s k :) j= wait 8k : P k : = ffi ) (s 0 :; s k :) j= post % Definition of WAIT; POST; OC 2 OC 5 Message-based rule We first recall the format of assumption-commitment specifications for message-based processes <ref> [21, 31, 32] </ref> and interpret correctness formulas in terms of sets of computations. We then derive the corresponding syntactic parallel rule from the semantic rule by considering the points 3. and 4. of our check-list. 5.1 Message-based process specifications First, the syntax and semantics of assertions is given. <p> This interpretation is classical in (synchronous) message-based concurrency <ref> [18, 21, 31] </ref> but is less usual in state-based concurrency. In the latter case, only the part SA ! C is retained [2, 14, 26, 27, 30]. However, in state-based concurrency, SAfi ! C and SA ! C often admit the same set of implementations (Theorem 3).
Reference: 32. <author> Zwiers, J., de Roever, W.-P., van Emde Boas,P.: </author> <title> Compositionality and concurrent networks: sound-ness and completeness of a proof system. </title> <type> Technical Report 57, </type> <institution> University of Nijmegen 1984. </institution>
Reference-contexts: In the message-based approach, the corresponding premise is of the form A ^ C 1 ) A 2 <ref> [18, 21, 31, 32] </ref>, where A, C 1 and A 2 are as before, i.e., the most prominent operator is conjunction. <p> : 6= ffi ) (s 0 :; s k :) j= wait 8k : P k : = ffi ) (s 0 :; s k :) j= post % Definition of WAIT; POST; OC 2 OC 5 Message-based rule We first recall the format of assumption-commitment specifications for message-based processes <ref> [21, 31, 32] </ref> and interpret correctness formulas in terms of sets of computations. We then derive the corresponding syntactic parallel rule from the semantic rule by considering the points 3. and 4. of our check-list. 5.1 Message-based process specifications First, the syntax and semantics of assertions is given.
Reference: 33. <author> Zwiers, J.: </author> <title> Compositionality, concurrency and partial correctness. </title> <journal> (Lect. </journal> <note> Notes Comput. Sci., vol 321) Springer-Verlag 1989 </note>
References-found: 30

