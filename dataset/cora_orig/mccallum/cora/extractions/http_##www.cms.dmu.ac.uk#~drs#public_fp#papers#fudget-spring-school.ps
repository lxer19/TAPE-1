URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/fudget-spring-school.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Note: Lecture Notes 4 augusti 1995  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Carlsson & T. Hallgren, </author> <title> Fudgets - A Graphical User Interface in a Lazy Functional Language, </title> <booktitle> in FPCA 93 - Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 321--330, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The special arrangement is called a fudget, and was first presented in <ref> [1] </ref>. 4.1 The Fudget Type A fudget is a stream processor which has low level streams for communication with the input/output system and high level streams for communication with other fudgets. Fudgets can be composed with a set of combinators like the ones for plain stream processors presented above.
Reference: [2] <author> M. Carlsson & T. Hallgren, </author> <title> The Fudget distribution, </title> <note> See ftp://ftp.cs.chalmers.se/pub/haskell/chalmers/ </note>
Reference: [3] <author> A. D. Gordon, </author> <title> Functional Programming and Input/Output, </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year> <note> ISBN 0-521-47103-6. </note>
Reference-contexts: We will write sp1 parSP sp2 instead of parSP sp1 sp2 2 Input/Output in Functional Languages In this chapter we give a brief introduction to Input/Output in functional languages. Several models of I/O for lazy functional languages have been developed during the years. Good surveys can be found in <ref> [3] </ref> and [6]. Here, we present Landins stream model of I/O and the synchronized streams used in Haskell. We present continuation based I/O and monadic I/O as abstractions from streams and note that they are sequential in nature.
Reference: [4] <editor> A. D. Gordon et al, </editor> <title> Haskell 1.3 Monadic I/O Definition. </title> <note> At http://www.cl.cam.ac.uk/users/adg/io.html </note>
Reference-contexts: An I/O system based on monads is proposed for version 1.3 of Haskell <ref> [4] </ref>. doRequest :: Request fi (Response fi Dialogue) fi Dialogue doRequest request continuation responses = request : case responses of response : responses fi continuation response responses done:: Dialogue done [] = [] Fig. 4.
Reference: [5] <author> T. Hallgren & M. Carlsson, </author> <note> The Fudgets Home Page. At http://www.cs.chalmers.se/Fudgets/ </note>
Reference-contexts: Extend the extended counter to a pocket calculator. (Dont worry about the layout of the buttons at this point.) 5.4 More GUI elements In this section we present some common GUI elements provided by the Fudget Library. For more information, consult the reference manual, which is available via WWW <ref> [5] </ref>. 5.4.1 Buttons We have already seen buttonF in the examples above. It provides command buttons, i.e., buttons that you press to trigger some action. The Fudget library also provides toggle but Fig. 26.
Reference: [6] <author> P. Hudak & R. S. Sundaresh. </author> <title> On the expressiveness of purely functional I/O systems. </title> <institution> Research Report YALEU/DCS/RR-665, Yale University Department of Computer Science, </institution> <month> March </month> <year> 1989. </year> <month> 49 </month>
Reference-contexts: Several models of I/O for lazy functional languages have been developed during the years. Good surveys can be found in [3] and <ref> [6] </ref>. Here, we present Landins stream model of I/O and the synchronized streams used in Haskell. We present continuation based I/O and monadic I/O as abstractions from streams and note that they are sequential in nature.
Reference: [7] <editor> Paul Hudak et al., </editor> <title> Report on the Programming Language Haskell: A Non-Strict, Purely Functional Language, </title> <month> March </month> <year> 1992. </year> <note> Version 1.2. Also in Sigplan Notices, </note> <month> May </month> <year> 1992. </year>
Reference-contexts: Readers mainly interested in GUI construction may want to skip directly to Section 5 and then go back to the earlier sections to learn more about what stream processors and fud-gets really are. 1.3 Notation All programs in these lecture notes are written in the pure functional language Haskell <ref> [7] </ref>. We deviate from Haskell syntax on two points: We write fi instead of -&gt;.
Reference: [8] <author> P.J. Landin. </author> <title> A correspondence between ALGOL 60 and Churchs lambda-notation: Parts I and II. </title> <journal> Communications of the ACM, </journal> <volume> 8(2,3):89-101, </volume> <pages> 158-165, </pages> <month> February and March </month> <year> 1965. </year>
Reference-contexts: As an example, a program like map toUpper (where toUpper converts lower case letters to upper case letters) reads, processes and outputs one character at a time. The above described I/O method is Landins streams model of I/O <ref> [8] </ref>. Program Characters Characters Fig. 2. Landins Stream I/O model. 8 2.2.2 I/O Based on Synchronized Streams I/O in Haskell is also based on streams, but to allow more general I/O operations the elements in the streams are not just characters (Figure 3).
Reference: [9] <author> J. McCarthy. </author> <title> A basis for a mathematical theory of computations. </title> <editor> In P. Brattort and D. Hirschberg, editors, </editor> <booktitle> Computer Programming and Formal Systems, </booktitle> <pages> pages 3370. </pages> <publisher> North-Holland, </publisher> <year> 1963. </year>
Reference-contexts: But so should (sp2 parSP sp1) ^, so ??? must be an expression that chooses the one of ys and zs which happens to be non-bottom. This can clearly not be done in an ordinary purely functional language. We would need a bottom-avoiding operator, like amb, McCarthys ambivalent operator <ref> [9] </ref>.
Reference: [10] <author> R. Milner, </author> <title> Communication and concurrency, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1989. </year> <note> ISBN 0-13-114984-9. </note>
Reference: [11] <author> R. Noble & C. Runciman, </author> <title> Functional Languages and Graphical User Interfaces a review and a case study, </title> <type> Technical report YCS-94-223, </type> <institution> Dept. of Comp. Sci., Univ. of York, </institution> <address> Heslington, York, Y01 5DD, England, </address> <year> 1994. </year> <note> At ftp://minster.york.ac.uk/reports/YCS-94-223.ps.Z </note>
Reference-contexts: You can then define a new stream processor sp new which can pass on old mes sages directly to sp old and handle the new messages in the appropriate way, on its own or by translating them to messages that sp old understands. (See also section 3.1.1 in <ref> [11] </ref>.) In the composition loopThroughRightSP sp 1 sp 2 all communication with the outside world is handled by sp 1 . sp 2 is connected only to sp 1 and is in this sense encapsulated inside sp 1 . Fig. 13.
Reference: [12] <author> Simon L. Peyton Jones, Cordelia V. Hall, Kevin Hammond, </author> <title> Will Partain, and Philip Wadler "The Glasgow Haskell compiler: a technical overview" In Proc. </title> <booktitle> UK Joint Framework for Information Technology (JFIT) Technical Conference, </booktitle> <month> July 93. </month> <note> At ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/papers/grasp-jfit.ps.Z </note>
Reference-contexts: If the stream model for Haskell I/O is used, the request and response data types need to be extended in order to implement this, something which has been done in the Chalmers Haskell B Compiler. 5 If monadic I/O is used (or rather the C monad, as in Glasgow Haskell <ref> [12] </ref>), there is no need to change the run-time system. 4.4.4 Fudgets in other I/O models If we implement fudgets on top of monadic I/O, we might want to perform any monadic I/O operation in a fudget, without the old-fashioned coding in request and response values.
Reference: [13] <author> R. Plasmeijer, </author> <note> Cleans Home Page. At http://www.cs.kun.nl/~clean/ </note>
Reference-contexts: Implement ioF and the fudget combinators for the suggested fudget type suitable for monadic I/O. 10. Implement fudgets on top of Cleans I/O system <ref> [13] </ref>. One approach is to implement monadic I/O first. 5.
Reference: [14] <author> P. Wadler, </author> <title> "Monads for functional programming". </title> <booktitle> In Lecture Notes on Advanced Functional Programming Techniques (i.e., this volume), </booktitle> <publisher> LNCS, Springer-Verlag 1995. </publisher>
Reference-contexts: (ReadFile filename) $ " response fi case response of Str contents fi continuation contents Failure error fi failcont error In Haskell there are predefined functions like readFile for most I/O requests. 2.2.4 I/O in Monadic Style An abstraction that has proved to be useful for many purposes is the monad <ref> [14] </ref>. An I/O system based on monads is proposed for version 1.3 of Haskell [4]. doRequest :: Request fi (Response fi Dialogue) fi Dialogue doRequest request continuation responses = request : case responses of response : responses fi continuation response responses done:: Dialogue done [] = [] Fig. 4.
References-found: 14

