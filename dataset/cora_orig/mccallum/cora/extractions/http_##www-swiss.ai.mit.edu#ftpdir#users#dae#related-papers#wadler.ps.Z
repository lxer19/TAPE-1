URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/related-papers/wadler.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Title: The essence of functional programming  
Author: Philip Wadler, 
Affiliation: University of Glasgow  
Abstract: This paper explores the use monads to structure functional programs. No prior knowledge of monads or category theory is required. Monads increase the ease with which programs may be modified. They can mimic the effect of impure features such as exceptions, state, and continuations; and also provide effects not easily achieved with such features. The types of a program reflect which effects occur. The first section is an extended example of the use of monads. A simple interpreter is modified to support various extra features: error messages, state, output, and non-deterministic choice. The second section describes the relation between monads and continuation-passing style. The third section sketches how monads are used in a compiler for Haskell that is written in Haskell. 
Abstract-found: 1
Intro-found: 1
Reference: [AJ89] <author> A. Appel and T. Jim, </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In 16'th Symposium on Principles of Programming Languages, </booktitle> <institution> Austin, Texas; ACM, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Continuation-passing style was first developed for use with denotational semantics [Rey72, Plo75]. It provides fine control over the execution order of a program, and has become popular as an intermediate language for compilers <ref> [SS76, AJ89] </ref>.
Reference: [BW87] <author> R. Bird and P. Wadler, </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: The examples will be given in Haskell, but no knowledge of that is needed either. What the reader will require is a passing familiarity with the basics of pure and impure functional programming; for general background see <ref> [BW87, Pau91] </ref>. The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi [Mog89a, Mog89b].
Reference: [DF90] <author> O. Danvy and A. Filinski, </author> <title> Abstracting control. </title> <booktitle> In Conference on Lisp and Functional Programming, Nice, France; ACM, </booktitle> <month> June </month> <year> 1990. </year> <month> 21 </month>
Reference-contexts: It provides fine control over the execution order of a program, and has become popular as an intermediate language for compilers [SS76, AJ89]. This paper stresses the modularity afforded by CPS, and in this sense has similar goals to the work of Danvy and Filinski <ref> [DF90] </ref>. 3.1 CPS interpreter The monad of continuations is defined as follows. type K a = (a -&gt; Answer) -&gt; Answer unitK a = "c -&gt; c a m `bindK` k = "c -&gt; m ("a -&gt; k a c) In CPS, a value a (of type a) is represented by
Reference: [DHM91] <author> B. Duba, R. Harper, and D. MacQueen, </author> <title> Typing first-class continuations in ML. </title> <booktitle> In 18'th Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, </address> <publisher> Florida; ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Other choices for the Answer type will be considered in Section 3.3 3.2 Call with current continuation Having converted our interpreter to CPS, it is now straightforward to add the call with current continuation (callcc) operation, found in Scheme [RC86] and Standard ML of New Jersey <ref> [DHM91] </ref>.
Reference: [GH90] <author> J. Guzman and P. Hudak, </author> <title> Single-threaded polymorphic lambda calculus. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia, </address> <publisher> Pennsylvania; IEEE, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: The effect is similar to the "abstract continuations" used in Hope+C [Per87]. How do monads compare to other approaches to state? Several new approaches to state in pure functional languages have emerged recently, based on various type disciplines <ref> [GH90, SRI91, Wad91] </ref>. These need to be compared with each other and with the monad approach. Can type inference help? By examining where monads appear in the types of a program, one determines in effect where impure features are used.
Reference: [GL86] <author> D. K. Gifford and J. M. Lucassen, </author> <title> Integrating functional and imperative programming. </title> <booktitle> In Conference on Lisp and Functional Programming, </booktitle> <pages> 28-39, </pages> <institution> Cam-bridge, Massachusetts; ACM, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: In this sense, the use of monads is similar to the use of effect systems as advocated by Gifford, Jouvelot, and others, in which a type system infers where effects occur <ref> [GL86, JG91] </ref>. An intriguing question is whether a similar form of type inference could apply to a language based on monads. 5.2 The past Finally, something should be said about the origin of these ideas. The notion of monad comes from category theory [Mac71, LS86].
Reference: [Han87] <author> P. Hancock, </author> <title> A type checker. Chapter 9 of Simon Peyton Jones, </title> <booktitle> The Implementation of Functional Programming Languages, </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: In each case, the use of a monad greatly simplifies bookkeeping. The type inferencer would be extremely cluttered if it was necessary to mention explicitly at each step how the current substitution, name supply, and error information are propagated; for a hint of the problems, see <ref> [Han87] </ref>. The monads used have been altered several times without difficulty. The change to the interpreter described in Section 2.4 was based on a similar change made to the compiler. The compiler has just begun to generate code, and a full assesment lies in the future.
Reference: [HPW91] <editor> P. Hudak, S. Peyton Jones and P. Wadler, editors, </editor> <title> Report on the Programming Language Haskell: Version 1.1. </title> <type> Technical report, </type> <institution> Yale University and Glasgow University, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The examples will be given in Haskell, but no knowledge of that is needed either. What the reader will require is a passing familiarity with the basics of pure and impure functional programming; for general background see [BW87, Pau91]. The languages refered to are Haskell <ref> [HPW91] </ref>, Miranda 1 [Tur90], Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi [Mog89a, Mog89b]. Of these matters more will be said in the conclusion.
Reference: [JG91] <author> P. Jouvelot and D. Gifford, </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In 18'th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: In this sense, the use of monads is similar to the use of effect systems as advocated by Gifford, Jouvelot, and others, in which a type system infers where effects occur <ref> [GL86, JG91] </ref>. An intriguing question is whether a similar form of type inference could apply to a language based on monads. 5.2 The past Finally, something should be said about the origin of these ideas. The notion of monad comes from category theory [Mac71, LS86].
Reference: [LS86] <author> J. Lambek and P. Scott, </author> <title> Introduction to Higher Order Categorical Logic, </title> <publisher> Cam-bridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Often, monads are defined not in terms of unitM and bindM, but rather in terms of unitM, jointM, and mapM <ref> [Mac71, LS86, Mog89a, Wad90] </ref>. The three monad laws are replaced by the first seven of the eight laws above. If one defines bindM by the eighth law, then the three monad laws follow. Hence the two definitions are equivalent. <p> An intriguing question is whether a similar form of type inference could apply to a language based on monads. 5.2 The past Finally, something should be said about the origin of these ideas. The notion of monad comes from category theory <ref> [Mac71, LS86] </ref>. It first arose in the area of homological algebra, but later was recognised (due to the work of Kleisli and of Eilenberg and Moore) to have much wider applications.
Reference: [Mac71] <author> S. Mac Lane, </author> <title> Categories for the Working Mathematician, </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: Often, monads are defined not in terms of unitM and bindM, but rather in terms of unitM, jointM, and mapM <ref> [Mac71, LS86, Mog89a, Wad90] </ref>. The three monad laws are replaced by the first seven of the eight laws above. If one defines bindM by the eighth law, then the three monad laws follow. Hence the two definitions are equivalent. <p> An intriguing question is whether a similar form of type inference could apply to a language based on monads. 5.2 The past Finally, something should be said about the origin of these ideas. The notion of monad comes from category theory <ref> [Mac71, LS86] </ref>. It first arose in the area of homological algebra, but later was recognised (due to the work of Kleisli and of Eilenberg and Moore) to have much wider applications.
Reference: [Mog89a] <author> E. Moggi, </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Symposium on Logic in Computer Science, Asilomar, California; IEEE, </booktitle> <month> June </month> <year> 1989. </year> <note> (A longer version is available as a technical report from the University of Edinburgh.) </note>
Reference-contexts: The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi <ref> [Mog89a, Mog89b] </ref>. Of these matters more will be said in the conclusion. For now, please note that the word "essence" is used in a technical sense: I wish to argue that the technique described in this paper is helpful, not that it is necessary. <p> Often, monads are defined not in terms of unitM and bindM, but rather in terms of unitM, jointM, and mapM <ref> [Mac71, LS86, Mog89a, Wad90] </ref>. The three monad laws are replaced by the first seven of the eight laws above. If one defines bindM by the eighth law, then the three monad laws follow. Hence the two definitions are equivalent. <p> There is no general technique for combining two arbitrary monads. However, Section 3.3 shows how to combine continuations with any other monad; and similar techniques are available for the state, exception, and output monads <ref> [Mog89a, Mog89b] </ref>. One might form a library of standard monads with standard ways of combining them. This would be aided by parameterised modules, which are present in Miranda and Standard ML, but absent in Haskell. <p> Its importance emerged slowly: in early days, it was not even given a proper name, but called simply a "standard construction" or a "triple". The formulation used here is due to Kleisli. Eugenio Moggi proposed that monads provide a useful structuring tool for denotational semantics <ref> [Mog89a, Mog89b] </ref>. He showed how lambda calculus could be given call-by-value and call-by-name semantics in an arbitrary monad, and how monads could encapsulate a wide variety of programming language features such as state, exception handling, and continuations.
Reference: [Mog89b] <author> E. Moggi, </author> <title> An abstract view of programming languges. Course notes, </title> <institution> University of Edinburgh. </institution>
Reference-contexts: The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi <ref> [Mog89a, Mog89b] </ref>. Of these matters more will be said in the conclusion. For now, please note that the word "essence" is used in a technical sense: I wish to argue that the technique described in this paper is helpful, not that it is necessary. <p> There is no general technique for combining two arbitrary monads. However, Section 3.3 shows how to combine continuations with any other monad; and similar techniques are available for the state, exception, and output monads <ref> [Mog89a, Mog89b] </ref>. One might form a library of standard monads with standard ways of combining them. This would be aided by parameterised modules, which are present in Miranda and Standard ML, but absent in Haskell. <p> Its importance emerged slowly: in early days, it was not even given a proper name, but called simply a "standard construction" or a "triple". The formulation used here is due to Kleisli. Eugenio Moggi proposed that monads provide a useful structuring tool for denotational semantics <ref> [Mog89a, Mog89b] </ref>. He showed how lambda calculus could be given call-by-value and call-by-name semantics in an arbitrary monad, and how monads could encapsulate a wide variety of programming language features such as state, exception handling, and continuations.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper, </author> <title> The definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: What the reader will require is a passing familiarity with the basics of pure and impure functional programming; for general background see [BW87, Pau91]. The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML <ref> [MTH90] </ref>, and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi [Mog89a, Mog89b]. Of these matters more will be said in the conclusion.
Reference: [Pau91] <author> L. C. Paulson, </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: The examples will be given in Haskell, but no knowledge of that is needed either. What the reader will require is a passing familiarity with the basics of pure and impure functional programming; for general background see <ref> [BW87, Pau91] </ref>. The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi [Mog89a, Mog89b].
Reference: [Per87] <author> N. Perry, Hope+C, </author> <title> a continuation extension for Hope+. </title> <institution> Imperial College, Department of Computing, </institution> <type> Technical report IC/FPR/LANG/2.5.1/21, </type> <month> November </month> <year> 1987. </year>
Reference-contexts: Kevin Hammond and I have built an interface that allows Haskell programs to call C routines, using monads to sequence the calls and preserve referential transparency. The effect is similar to the "abstract continuations" used in Hope+C <ref> [Per87] </ref>. How do monads compare to other approaches to state? Several new approaches to state in pure functional languages have emerged recently, based on various type disciplines [GH90, SRI91, Wad91]. These need to be compared with each other and with the monad approach.
Reference: [Plo75] <author> G. Plotkin, </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year> <month> 22 </month>
Reference-contexts: The equiv alence of the two translations follows from the monad laws. 14 3 Continuing monads The purpose of this section is to compare the monadic style advocated in Section 2 with continuation-passing style (CPS). Continuation-passing style was first developed for use with denotational semantics <ref> [Rey72, Plo75] </ref>. It provides fine control over the execution order of a program, and has become popular as an intermediate language for compilers [SS76, AJ89].
Reference: [RC86] <editor> J. Rees and W. Clinger (eds.), </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <year> 1986. </year>
Reference-contexts: What the reader will require is a passing familiarity with the basics of pure and impure functional programming; for general background see [BW87, Pau91]. The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML [MTH90], and Scheme <ref> [RC86] </ref>. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi [Mog89a, Mog89b]. Of these matters more will be said in the conclusion. <p> Evaluating test term0 returns "42", as before. Other choices for the Answer type will be considered in Section 3.3 3.2 Call with current continuation Having converted our interpreter to CPS, it is now straightforward to add the call with current continuation (callcc) operation, found in Scheme <ref> [RC86] </ref> and Standard ML of New Jersey [DHM91].
Reference: [Rey72] <author> J. Reynolds, </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In 25'th ACM National Conference, </booktitle> <pages> 717-740, </pages> <year> 1972. </year>
Reference-contexts: The equiv alence of the two translations follows from the monad laws. 14 3 Continuing monads The purpose of this section is to compare the monadic style advocated in Section 2 with continuation-passing style (CPS). Continuation-passing style was first developed for use with denotational semantics <ref> [Rey72, Plo75] </ref>. It provides fine control over the execution order of a program, and has become popular as an intermediate language for compilers [SS76, AJ89]. <p> But the vital unitM and bindM operations do not appear in Reynolds' work. This is not the only time that John Reynolds has been a decade ahead of the rest of us. Among other things, he was an early promoter of continuation-passing style <ref> [Rey72] </ref> and the first to apply category theory to language design [Rey80, Rey81]. One intriguing aspect of his recent work is the use of intersection types [Rey89a, Rey89b, Rey91], so perhaps we should expect an upsurge of interest in that topic early in the next millenium.
Reference: [Rey80] <author> J. Reynolds, </author> <title> Using category theory to design implicit conversion and generic operators. </title> <editor> In N. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, </booktitle> <pages> 211-258, </pages> <publisher> Berlin; LNCS 94, Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: This is not the only time that John Reynolds has been a decade ahead of the rest of us. Among other things, he was an early promoter of continuation-passing style [Rey72] and the first to apply category theory to language design <ref> [Rey80, Rey81] </ref>. One intriguing aspect of his recent work is the use of intersection types [Rey89a, Rey89b, Rey91], so perhaps we should expect an upsurge of interest in that topic early in the next millenium.
Reference: [Rey81] <author> J. Reynolds, </author> <title> The essence of Algol. </title> <editor> In de Bakker and van Vliet, editors, </editor> <booktitle> Algorithmic Languages, </booktitle> <pages> 345-372, </pages> <publisher> North Holland, </publisher> <year> 1981. </year>
Reference-contexts: The languages refered to are Haskell [HPW91], Miranda 1 [Tur90], Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds <ref> [Rey81] </ref> and that the use of monads was inspired by Moggi [Mog89a, Mog89b]. Of these matters more will be said in the conclusion. <p> In a call-by-value language, functions take values into computations (as in a -&gt; M b); in a call-by-name language, functions take computations into computations (as in M a -&gt; M b). John Reynolds made exactly the same point a decade ago <ref> [Rey81] </ref>. The essence of Algol, according to Reynolds, is a programming language that distinguishes data types from phrase types. <p> This is not the only time that John Reynolds has been a decade ahead of the rest of us. Among other things, he was an early promoter of continuation-passing style [Rey72] and the first to apply category theory to language design <ref> [Rey80, Rey81] </ref>. One intriguing aspect of his recent work is the use of intersection types [Rey89a, Rey89b, Rey91], so perhaps we should expect an upsurge of interest in that topic early in the next millenium.
Reference: [Rey89a] <author> J. Reynolds, </author> <title> Preliminary design of the programming language Forsythe. </title> <institution> Carnegie Mellon University technical report CMU-CS-88-159, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: In his work data types (such as int) play the roles of values, and phrase types (such as int exp) play the role of computations, and the same distinction between call-by-value and call-by-name appears. These ideas form the basis for the design of Forsythe <ref> [Rey89a] </ref>. But the vital unitM and bindM operations do not appear in Reynolds' work. This is not the only time that John Reynolds has been a decade ahead of the rest of us. <p> Among other things, he was an early promoter of continuation-passing style [Rey72] and the first to apply category theory to language design [Rey80, Rey81]. One intriguing aspect of his recent work is the use of intersection types <ref> [Rey89a, Rey89b, Rey91] </ref>, so perhaps we should expect an upsurge of interest in that topic early in the next millenium.
Reference: [Rey89b] <author> J. C. Reynolds, </author> <title> Syntactic control of interference, part II. </title> <booktitle> In International Colloquium on Automata, Languages, and Programming, </booktitle> <year> 1989. </year>
Reference-contexts: Among other things, he was an early promoter of continuation-passing style [Rey72] and the first to apply category theory to language design [Rey80, Rey81]. One intriguing aspect of his recent work is the use of intersection types <ref> [Rey89a, Rey89b, Rey91] </ref>, so perhaps we should expect an upsurge of interest in that topic early in the next millenium.
Reference: [Rey91] <author> J. Reynolds, </author> <title> The coherrence of languages with intersection types. </title> <booktitle> In International Conference on Theoretical Aspects of Computer Software, Sendai, </booktitle> <address> Japan, </address> <publisher> LNCS, Springer Verlag, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Among other things, he was an early promoter of continuation-passing style [Rey72] and the first to apply category theory to language design [Rey80, Rey81]. One intriguing aspect of his recent work is the use of intersection types <ref> [Rey89a, Rey89b, Rey91] </ref>, so perhaps we should expect an upsurge of interest in that topic early in the next millenium.
Reference: [Spi90] <author> M. Spivey, </author> <title> A functional theory of exceptions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 25-42, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Independent of Moggi, but at about the same time, Michael Spivey proposed that monads provide a useful structuring tool for exception handling in pure functional languages, and demonstrated this thesis with an elegant program for term rewriting <ref> [Spi90] </ref>. He showed how monads could treat exceptions (as in Section 2.3) and non-deterministic choice (as in Section 2.7) in a common framework, thus capturing precisely a notion that 20 I had groped towards years earlier [Wad85].
Reference: [SRI91] <author> V. Swarup, U. S. Reddy, and E. Ireland, </author> <title> Assignments for applicative languages. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, </address> <publisher> Massachusetts; LNCS 523, Springer Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: The effect is similar to the "abstract continuations" used in Hope+C [Per87]. How do monads compare to other approaches to state? Several new approaches to state in pure functional languages have emerged recently, based on various type disciplines <ref> [GH90, SRI91, Wad91] </ref>. These need to be compared with each other and with the monad approach. Can type inference help? By examining where monads appear in the types of a program, one determines in effect where impure features are used.
Reference: [SS76] <author> G. L. Steele, Jr. and G. Sussman, </author> <title> Lambda, the ultimate imperative. </title> <publisher> MIT, </publisher> <address> AI Memo 353, </address> <month> March </month> <year> 1976. </year>
Reference-contexts: Continuation-passing style was first developed for use with denotational semantics [Rey72, Plo75]. It provides fine control over the execution order of a program, and has become popular as an intermediate language for compilers <ref> [SS76, AJ89] </ref>.
Reference: [Tur90] <author> D. A. Turner, </author> <title> An overview of Miranda. </title> <editor> In D. A. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The examples will be given in Haskell, but no knowledge of that is needed either. What the reader will require is a passing familiarity with the basics of pure and impure functional programming; for general background see [BW87, Pau91]. The languages refered to are Haskell [HPW91], Miranda 1 <ref> [Tur90] </ref>, Standard ML [MTH90], and Scheme [RC86]. Some readers will recognise that the title of this paper is a homage to Reynolds [Rey81] and that the use of monads was inspired by Moggi [Mog89a, Mog89b]. Of these matters more will be said in the conclusion.
Reference: [Wad85] <author> P. Wadler, </author> <title> How to replace failure by a list of successes. </title> <booktitle> Conference on Functional Programming Languages and Computer Architecture, Nancy, </booktitle> <publisher> France; LNCS 201, Springer-Verlag, </publisher> <month> September </month> <year> 1985. </year>
Reference-contexts: He showed how monads could treat exceptions (as in Section 2.3) and non-deterministic choice (as in Section 2.7) in a common framework, thus capturing precisely a notion that 20 I had groped towards years earlier <ref> [Wad85] </ref>. Inspired by Moggi and Spivey, I proposed monads as a general technique for structuring functional programs. My early proposals were based on a special syntax for monads, that generalised list comprehensions [Wad90]. This was unfortunate, in that it led many to think a special syntax was needed.
Reference: [Wad90] <author> P. Wadler, </author> <title> Comprehending monads. </title> <booktitle> In Conference on Lisp and Functional Programming, Nice, France; ACM, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Often, monads are defined not in terms of unitM and bindM, but rather in terms of unitM, jointM, and mapM <ref> [Mac71, LS86, Mog89a, Wad90] </ref>. The three monad laws are replaced by the first seven of the eight laws above. If one defines bindM by the eighth law, then the three monad laws follow. Hence the two definitions are equivalent. <p> The three monad laws are replaced by the first seven of the eight laws above. If one defines bindM by the eighth law, then the three monad laws follow. Hence the two definitions are equivalent. As described in <ref> [Wad90] </ref>, the list comprehension notation generalises to an arbitrary monad. <p> It may be better to provide an alternative syntax. One possibility is to provide letM a &lt;- m in k a as alternative syntax for m `bindM` ("a -&gt; k a). Another possiblity arises from monad comprehensions <ref> [Wad90] </ref>. What about efficiency? The style advocated here makes heavy use of data abstraction and higher-order functions. It remains to be seen what impact this has on efficiency, and the GRASP team looks forward to examining the performance of our completed Haskell compiler. <p> Should certain monads be provided as primitive? Monads may encapsulate impure effects in a pure way. For example, when the state is an array, the state monad can safely update the array by overwriting, as described in <ref> [Wad90] </ref>. Kevin Hammond and I have built an interface that allows Haskell programs to call C routines, using monads to sequence the calls and preserve referential transparency. The effect is similar to the "abstract continuations" used in Hope+C [Per87]. <p> Inspired by Moggi and Spivey, I proposed monads as a general technique for structuring functional programs. My early proposals were based on a special syntax for monads, that generalised list comprehensions <ref> [Wad90] </ref>. This was unfortunate, in that it led many to think a special syntax was needed. This new presentation is designed to convey that monads can be profitably applied to structure programs today with existing languages.
Reference: [Wad91] <institution> Is there a use for linear logic? Conference on Partial Evaluation and Semantics-Based Program Manipulation (PEPM), New Haven, Connecticut; ACM, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: The effect is similar to the "abstract continuations" used in Hope+C [Per87]. How do monads compare to other approaches to state? Several new approaches to state in pure functional languages have emerged recently, based on various type disciplines <ref> [GH90, SRI91, Wad91] </ref>. These need to be compared with each other and with the monad approach. Can type inference help? By examining where monads appear in the types of a program, one determines in effect where impure features are used.
References-found: 31

