URL: http://www-ccs.cs.umass.edu/~kamath/sigir96.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/mdds.html
Root-URL: 
Email: fkamath,krithig@cs.umass.edu  
Title: Efficient Transaction Support for Dynamic Information Retrieval Systems  
Author: Mohan Kamath and Krithi Ramamritham 
Address: Amherst MA 01003-4610 USA  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: To properly handle concurrent accesses to documents by updates and queries in information retrieval (IR) systems, efforts are on to integrate IR features with database management system (DBMS) features. However, initial research has revealed that DBMS features optimized for traditional databases, display degraded performance while handling text databases. Since efficiency is critical in IR systems, infras-tructural extensions are necessary for several DBMS features, transaction support being one of them. This paper focuses on developing efficient transaction support for IR systems where updates and queries arrive dynamically, by exploiting the data characteristics of the indexes as well as of the queries and updates that access the indexes. Results of performance tests on a prototype system demonstrate the superior performance of our algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [BCC94] <author> E.W. Brown, J.P. Callan, and W.B. Croft. </author> <title> Fast incremental indexing for full-text information retrieval. </title> <booktitle> In Proc. of Intl. Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: Hence the new documents are analyzed first in a batch and the keywords extracted, and all the inverted-lists are updated at the end in an incremental fashion as shown in figure 1. The incremental strategy also obviates the need to rebuild indexes <ref> [BCC94, TGMS94] </ref>. Given the keywords relevant to a query, the set of inverted-lists corresponding to these keywords is identified. After reading the inverted-lists, the document IDs and other required information are extracted from the inverted-lists.
Reference: [BCCM94] <author> E.W. Brown, J.P. Callan, W.B. Croft, and J.E.B Moss. </author> <title> Supporting Full-Text Information Retrieval with a Persistent Object Store. </title> <booktitle> In Proc. of Intl. Conference on Extending Database Technology, </booktitle> <address> Cambridge, UK, </address> <year> 1994. </year>
Reference-contexts: Providing transaction semantics for concurrent accesses by updates and queries to documents has been a long recognized goal. Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features <ref> [Fuh93, BCCM94, DDS + 95] </ref>. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases [DDS + 95].
Reference: [BGAS94] <author> C. Buckley, G.Salton, J. Allan, and A. Singhal. </author> <title> Automatic Query Expansion Using SMART: </title> <booktitle> TREC3. In Third Text REtrieval Conference (TREC-3), </booktitle> <pages> pages 69-80, </pages> <address> Gaithersburg, Mary-land, </address> <year> 1994. </year>
Reference-contexts: The query goes through an optional query expansion phase by referring to the context dictionary, i:e:; a user specified query is transformed to have more semantic context (by changing/adding new keywords) before it reads the inverted-lists <ref> [LK94, BGAS94] </ref>. Any changes made to the context dictionary should also be reflected in the system at the earliest. 2.2 Query and Update Processing When a document is added to the database, the indexes must be updated to reflect the addition of the new document to the database.
Reference: [BHG87] <author> P.A. Bernstein, V. Hadzilacos, and N. Good-man. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Isolation requirements can be usually specified based on the dependencies between the read (R) and write (W) operations. The three dependencies we need to consider are W-W, W-R and R-W <ref> [BHG87] </ref>. * W-W dependencies: Since updates are in the form of appends and appends to a set can be considered to be idempotent 3 . Appends also commute and hence these dependencies need not be tracked.
Reference: [Bro95] <author> E.W. Brown. </author> <title> Fast Evaluation of Structured Queries for Information Retrieval. </title> <booktitle> In Proc. of SIGIR Intl. Conf. on Research and Development in Information Retrieval, </booktitle> <year> 1995. </year>
Reference-contexts: Once the docu-ment IDs are determined, query processing is complete and the user is presented with the basic information about the documents like the abstract or the first few lines. Several optimizations can be performed to truncate the search process <ref> [Bro95] </ref>. The highlighted phases in figure 1 show the scope of the transactions during query and update processing.
Reference: [Cro95] <author> W. B. Croft. </author> <title> What do People Want from Information Retrieval? In D-Lib Magazine. </title> <note> Available at http://www.dlib.org/dlib/november95/ 11croft.html, </note> <year> 1995. </year>
Reference-contexts: An example of a system that handles dynamic queries is an on-line search system for web pages and news articles (like Infoseek search). Here documents arriving over the network with rates sometimes as high as 100 MB/hour <ref> [Cro95] </ref> are continuously analyzed and added to the system, while several thousand queries are processed every hour. In many IR systems, for example, news retrieval systems, the most recently added items are often the most relevant ones.
Reference: [DDS + 95] <author> S. DeFazio, A. Daoud, L. Smith, J. Srinivasan, B. Croft, and J. Callan. </author> <title> Integrating IR and RDBMS Using Cooperative Indexing. </title> <booktitle> In Proc. of SIGIR Intl. Conf. on Research and Development in Information Retrieval, </booktitle> <pages> pages 84-92, </pages> <year> 1995. </year>
Reference-contexts: Providing transaction semantics for concurrent accesses by updates and queries to documents has been a long recognized goal. Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features <ref> [Fuh93, BCCM94, DDS + 95] </ref>. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases [DDS + 95]. <p> Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features [Fuh93, BCCM94, DDS + 95]. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases <ref> [DDS + 95] </ref>. Efficiency is a critical factor that governs the success of large IR systems and hence successful integration of IR and DBMS features requires careful analysis and redesign of some of the DBMS features. <p> Hence it can be used in the integration of IR with any type of DBMS | RDBMS or an OODBMS and with any index structure like hashing or B-tree and its variants. Since our schemes are independent of the index structure used, applications can store and interpret the indexes <ref> [LS88, DDS + 95] </ref>. <p> The total size of a batch is about 0.45 MB, which is close to that used in <ref> [DDS + 95] </ref>. Notice that updates are long since on an average 1694 inverted-lists are to be updated. To avoid deadlocks arising from long duration updates in the DB-locking scheme, we rearranged the keywords whose inverted-lists are to be updated in an alphabetical order.
Reference: [Fuh93] <author> N. Fuhr. </author> <title> A probabilistic relational model for the integration of IR and databases. </title> <booktitle> In Proc. of SIGIR Intl. Conf. on Research and Development in Information Retrieval, </booktitle> <pages> pages 309-317, </pages> <year> 1993. </year>
Reference-contexts: Providing transaction semantics for concurrent accesses by updates and queries to documents has been a long recognized goal. Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features <ref> [Fuh93, BCCM94, DDS + 95] </ref>. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases [DDS + 95].
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: There are several ways in which the inverted-lists (secondary index) themselves can be linked to a keyword in a B-tree node <ref> [GR93] </ref>, especially for non-unique keyword additions. The choice reflects the tradeoff in the number and type of accesses. The type of structure used for maintaining the keyword-index or the inverted-list is not relevant to us since the techniques we are proposing in this paper are independent of the structure used. <p> Thus updates are performed on a large number of inverted-lists, increasing the duration of such updates. When updates are of long duration, queries will also have longer response times and the probability of transactions deadlocks also increase <ref> [GR93] </ref>. We now focus on performance and correctness considerations, so that we can exploit them to design high performance concurrency control and recovery schemes tailored for DIRSs. <p> Towards this end we have introduced the notion of operation reordering as discussed in section 4. Because dependencies need not be tracked, the update can be programmed as a 3 The append operation can be implemented in an idempotent manner to avoid duplicates. mini-batch 4 <ref> [GR93] </ref>. Since there no dependencies between index entries and there are no operations that can lead to logical errors, logical failures are rare. <p> This way the lock waiting time for queries is drastically reduced and we can ensure that the query sees the most recent documents without paying a high price. The locking mechanisms and data structures are similar to the ones described in <ref> [GR93] </ref>. The main data structure is a hash table and each hash chain contains records identifying inverted-lists and other relevant information like lock status.
Reference: [LK94] <author> X. A. Lu and R. B. Keefer. </author> <title> Query Expansion/Reduction and its Impact on Retrieval Effectiveness. </title> <booktitle> In Third Text REtrieval Conference (TREC-3), </booktitle> <pages> pages 231-240, </pages> <address> Gaithersburg, Mary-land, </address> <year> 1994. </year>
Reference-contexts: The query goes through an optional query expansion phase by referring to the context dictionary, i:e:; a user specified query is transformed to have more semantic context (by changing/adding new keywords) before it reads the inverted-lists <ref> [LK94, BGAS94] </ref>. Any changes made to the context dictionary should also be reflected in the system at the earliest. 2.2 Query and Update Processing When a document is added to the database, the indexes must be updated to reflect the addition of the new document to the database.
Reference: [LS88] <author> C. Lynch and M. Stonebraker. </author> <title> Extended user-defined indexing with application to textual databases. </title> <booktitle> In Proc. Int'l. Conf. on Very Large Data Bases, </booktitle> <pages> page 306, </pages> <address> Los Angeles, CA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Hence it can be used in the integration of IR with any type of DBMS | RDBMS or an OODBMS and with any index structure like hashing or B-tree and its variants. Since our schemes are independent of the index structure used, applications can store and interpret the indexes <ref> [LS88, DDS + 95] </ref>.
Reference: [LS92] <author> D. Lomet and B. Salzberg. </author> <title> Access method con-currency with recovery. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 351, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different type of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager (figure 2).
Reference: [ML92] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> An efficient and high-concurrency index management method using write-ahead logging. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 371, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different type of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager (figure 2).
Reference: [MN92] <author> C. Mohan and I. Narang. </author> <title> Algorithms for creating indexes for very large tables without qui-escing updates. </title> <booktitle> In ACM SIGMOD Conf. on the Management of Data, </booktitle> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different type of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager (figure 2).
Reference: [Moh90] <author> C. Mohan. ARIES/KVL: </author> <title> A key-value locking method for concurrency control of multiac-tion transactions operating on BTree indexes. </title> <booktitle> In Proceedings of the 16th Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufman pubs. </publisher> <address> (Los Altos CA), Brisbane, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different type of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager (figure 2).
Reference: [SC91] <author> V. Srinivasan and M. J. Carey. </author> <title> Performance of B-tree concurrency control algorithms. </title> <booktitle> In ACM SIGMOD Conf. on the Management of Data, </booktitle> <address> Boulder, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Thus our idea of operation reordering has a huge pay off and contributes to good recency. The 0.5 % we miss in terms of latest documents can be attributed to update transactions that start while query transactions are in progress. Similar to the compensation based on-line query processing technique <ref> [SC91] </ref>, we could force the query to check if there are new updates before it completes and if so re-execute the query.
Reference: [SC92] <author> V. Srinivasan and M. J. Carey. </author> <title> Compensation-based on-line query processing. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 331, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different type of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager (figure 2).
Reference: [TGMS94] <author> A. Thomasic, H. Garcia-Molina, and K. Shoens. </author> <title> Incremental Updates of Inverted Lists for Text Document Retrieval. </title> <booktitle> In Proc. of SIGMOD Intl. Conference on Management of Data, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Hence the new documents are analyzed first in a batch and the keywords extracted, and all the inverted-lists are updated at the end in an incremental fashion as shown in figure 1. The incremental strategy also obviates the need to rebuild indexes <ref> [BCC94, TGMS94] </ref>. Given the keywords relevant to a query, the set of inverted-lists corresponding to these keywords is identified. After reading the inverted-lists, the document IDs and other required information are extracted from the inverted-lists.
Reference: [TGNO92] <author> D. Terry, D. Goldberg, D. Nichols, and B. </author> <title> Oki. Continuous queries over append-only databases. </title> <booktitle> In Proc ACM SIGMOD Conf., </booktitle> <pages> pages 321-330, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: In this paper, we primarily focus on dynamic IR systems (DIRS) where queries and updates arriving dynamically are processed. Thus the articles of interest to a user are known only when a query arrives. This is unlike systems like SIFT [YGM95a] and Tapestry <ref> [TGNO92] </ref> which are geared to continuously respond to statically specified queries or filters. In these systems, a new document that arrives is routed to a user if it passes the filtering criterion specified by that user.
Reference: [TR84] <author> A. Tantawi and M. Ruschitzka. </author> <title> Performance analysis of checkpointing strategies. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 123-144, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Hence we force the log records of the committed mini-batch to the disk at commit time. A checkpoint is to be taken periodically. Several factors have to be considered before determin 8 For e:g:; interest computation for all accounts in a bank ing the frequency of checkpointing <ref> [TR84] </ref>. When a check-point is taken, all system inverted-list database buffers are flushed to the disk and a checkpoint record that contains the LSN (log sequence number) of the last log record processed is also flushed to the disk.
Reference: [YGM95a] <author> T. W. Yan and H. Garcia-Molina. </author> <title> SIFT ATool for Wide-Area Information Dissemination. </title> <booktitle> In In Proc. of 1995 USENIX Technical Conference, </booktitle> <pages> pages 177-186, </pages> <year> 1995. </year>
Reference-contexts: In this paper, we primarily focus on dynamic IR systems (DIRS) where queries and updates arriving dynamically are processed. Thus the articles of interest to a user are known only when a query arrives. This is unlike systems like SIFT <ref> [YGM95a] </ref> and Tapestry [TGNO92] which are geared to continuously respond to statically specified queries or filters. In these systems, a new document that arrives is routed to a user if it passes the filtering criterion specified by that user. <p> Thus the queries will be routed to the best site based on the latest available information without incurring much overheads. 3. In the context of static continuous queries, when a user submits a new profile or makes a profile modification, the profile inverted-lists <ref> [YGM95a] </ref> corresponding to these profiles are to be updated. The document analyzer reads the profile inverted-lists only after the profile inverted-lists have been updated to reflect the profile modification performed by the user. The documents received by a user from the IR system will thus immediately reflect the profile changes.
Reference: [YGM95b] <author> T.W. Yan and H. Garcia-Molina. </author> <title> Information Finding in a Digital Library: the Stanford Perspective. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 24(3), </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: Thus, all efforts should be made to consider the most latest documents for processing a query. A similar situation exists in distributed IR systems, comprised of thousands of independent text databases. In the text-database discovery problem <ref> [YGM95b] </ref>, before answering a query, the most appropriate site which contains documents that best match a query is to be determined. This is achieved by accessing a local database that is continuously updated using meta-information arriving from other sites.
References-found: 22

