URL: http://www.neci.nj.nec.com/homepages/pny/papers/likeit/likeit.ps
Refering-URL: http://www.neci.nj.nec.com/homepages/pny/papers/likeit/main.html
Root-URL: 
Email: Email: pny@research.nj.nec.com.  
Title: The LikeIt Intelligent String Comparison Facility  
Author: Peter N. Yianilos Kirk G. Kanzelberger 
Keyword: String Comparison/Similarity, Text/Database Search/Retrieval, Bi partite Matching/Assignment, Edit Distance.  
Address: 4 Independence Way, Princeton, NJ 08540.  
Affiliation: NEC Research Institute,  
Note: Both authors are with the  
Abstract: NEC Research Institute Technical Report fl May 1997 Abstract A highly-efficient ANSI-C facility is described for intelligently comparing a query string with a series of database strings. The bipartite weighted matching approach taken tolerates ordering violations that are problematic for simple automaton or string edit distance methods|yet common in practice. The method is character and polygraph based and does not require that words are properly formed in a query. Database characters are processed at a rate of approximately 2.5 million per second using a 200MHz Pentium Pro processor. A subroutine-level API is described along with an simple executable utility supporting both command-line and Web interfaces. An optimized Web interface is also reported consisting of a daemon that preloads multiple databases, and a corresponding CGI stub. The daemon may be initiated manually or via inetd. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. R. Buss and P. N. Yianilos, </author> <title> Linear and o(n log n) time minimum-cost matching algorithms for quasi-convex tours, </title> <booktitle> in Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> pp. </pages> <month> 65-76. </month> <title> To appear SIAM Journal on Computing. [2] , A bipartite matching approach to approximate string comparison and search, </title> <type> tech. rep., </type> <institution> NEC Research Insitute, </institution> <address> 4 Independence Way, Princeton, NJ, </address> <year> 1995. </year>
Reference-contexts: The result was that small database could be searched on early personal computers without using the PF474 chip. The computational heart of Friendly Finder was also made available under license, and named "P2." 4. A transition to the bipartite matching viewpoint took place with <ref> [1, 2] </ref>, the algorithms being improved and in some cases simplified. The result is entirely new algorithms that are still of the same family. The LikeIt facility is the first implementation based on these new developments. <p> A transition to the bipartite matching viewpoint took place with [1, 2], the algorithms being improved and in some cases simplified. The result is entirely new algorithms that are still of the same family. The LikeIt facility is the first implementation based on these new developments. The algorithms of <ref> [1] </ref> lead to linear time algorithms for a large class of graph cost functions, including the simple linear costs used by LikeIt. Linear time matching algorithms for this particularly simple special case were first presented in [6]. <p> The next stage, F 2, begins with a left-aligned query, and decomposes the matching problem into subproblems for each level as defined in <ref> [1] </ref>. Each such 12 level consists of polygraph occurrences that alternate between the query and database string. If the number of occurrences is even, the matching is uniquely defined. If odd, then LikeIt approximates the optimal matching by omitting either the first or last occurrence.
Reference: [3] <author> M. Damashek, </author> <title> Gauging similarity with n-grams: Language-independent categorization of text, </title> <booktitle> Science, 267 (1995), </booktitle> <pages> pp. 843-848. </pages>
Reference-contexts: Words as such receive no special treatment. In this sense it is related to the document retrieval approach of <ref> [3, 5] </ref>. An alternative approach to string comparison computes edit distance [4, 12], i.e., the minimum-cost transformation of one string into another via some set of elementary operations. Most commonly, weighted insertion, deletion, and substitution operations are used, and the edit distance computation is a straightforward dynamic program.
Reference: [4] <author> P. A. V. Hall and G. R. Dowling, </author> <title> Approximate string matching, </title> <journal> Computing Surveys, </journal> <volume> 12 (1980), </volume> <pages> pp. 381-402. </pages>
Reference-contexts: Words as such receive no special treatment. In this sense it is related to the document retrieval approach of [3, 5]. An alternative approach to string comparison computes edit distance <ref> [4, 12] </ref>, i.e., the minimum-cost transformation of one string into another via some set of elementary operations. Most commonly, weighted insertion, deletion, and substitution operations are used, and the edit distance computation is a straightforward dynamic program.
Reference: [5] <author> S. Huffman and M. Damashek, Acquaintance: </author> <title> A novel vector-space n-gram technique for document categorization, </title> <booktitle> in Proceedings Text RE 18 trieval Conference (TREC-3), </booktitle> <address> Washington, D.C., </address> <year> 1995, </year> <pages> NIST, pp. </pages> <month> 305--310. </month>
Reference-contexts: Words as such receive no special treatment. In this sense it is related to the document retrieval approach of <ref> [3, 5] </ref>. An alternative approach to string comparison computes edit distance [4, 12], i.e., the minimum-cost transformation of one string into another via some set of elementary operations. Most commonly, weighted insertion, deletion, and substitution operations are used, and the edit distance computation is a straightforward dynamic program.
Reference: [6] <author> R. M. Karp and S.-Y. R. Li, </author> <title> Two special cases of the assignment problem, </title> <journal> Discrete Mathematics, </journal> <volume> 13 (1975), </volume> <pages> pp. 129-142. </pages>
Reference-contexts: The algorithms of [1] lead to linear time algorithms for a large class of graph cost functions, including the simple linear costs used by LikeIt. Linear time matching algorithms for this particularly simple special case were first presented in <ref> [6] </ref>. The LikeIt approach, used in effect by Friendly Finder [10], is to build an optimal weighted matching of the letters and multigraphs in the query, and those in each database record. Words as such receive no special treatment.
Reference: [7] <author> D. E. Knuth, J. J. H. Morris, and V. R. Pratt, </author> <title> Fast pattern matching in strings, </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 (1977), </volume> <pages> pp. 323-350. </pages>
Reference-contexts: Second, the edit distance approach is highly sensitive to global permutation, e.g., changing word order. Humans frequently are not, and LikeIt deals well with this issue. The automaton-based approach to fast string matching introduced in <ref> [7] </ref> deals with exact matches only. A natural generalization relaxes the requirement of exact equality and allows a bounded (and in practice small) number of errors. Each such error is typically restricted to be either an insertion, deletion, substitution, or sometimes a transposition of adjacent symbols.
Reference: [8] <author> U. Manber and S. Wu, GLIMPSE: </author> <title> A tool to search through entire file systems, </title> <booktitle> in Proceedings of the Winter 1994 USENIX Conference, </booktitle> <year> 1994, </year> <pages> pp. 23-32. </pages>
Reference-contexts: Given a query string, it is then possible to build an automaton to detect it, or any match within the error bounds, within a second string. The recent work of <ref> [8, 14] </ref> demonstrates that text can be scanned at very high speeds within this framework for comparison. The LikeIt framework, on the other hand, can satisfy queries that do not fall within the practical capabilities of the automaton approach because they are too different from the desired database record.
Reference: [9] <author> M. J. Miller, </author> <title> First look friendly program doesn't need exact match to find database search objects, </title> <publisher> INFO WORLD, </publisher> <year> (1987). </year>
Reference-contexts: Today's software matches and even exceeds the performance of this device, although the comparison is not entirely fair, since the PF474 was clocked at only 4 Mhz. The same design implemented today would still result in a 1-2 order of magnitude hardware advantage. 3. The Friendly Finder software utility <ref> [10, 9] </ref>, first introduced in 1987 by Proximity Technology, implemented the algorithm together with software accelerations and special treatment for bigrams. The result was that small database could be searched on early personal computers without using the PF474 chip.
Reference: [10] <author> Proximity Technology, Inc., </author> <title> Friendly finder. Commercial Software for the IBM-PC, </title> <year> 1987. </year>
Reference-contexts: Today's software matches and even exceeds the performance of this device, although the comparison is not entirely fair, since the PF474 was clocked at only 4 Mhz. The same design implemented today would still result in a 1-2 order of magnitude hardware advantage. 3. The Friendly Finder software utility <ref> [10, 9] </ref>, first introduced in 1987 by Proximity Technology, implemented the algorithm together with software accelerations and special treatment for bigrams. The result was that small database could be searched on early personal computers without using the PF474 chip. <p> The algorithms of [1] lead to linear time algorithms for a large class of graph cost functions, including the simple linear costs used by LikeIt. Linear time matching algorithms for this particularly simple special case were first presented in [6]. The LikeIt approach, used in effect by Friendly Finder <ref> [10] </ref>, is to build an optimal weighted matching of the letters and multigraphs in the query, and those in each database record. Words as such receive no special treatment. In this sense it is related to the document retrieval approach of [3, 5].
Reference: [11] <author> S. Rosenthal, </author> <title> The PF474 a coprocessor for string comparison, </title> <journal> BYTE Magazine, </journal> <year> (1984). </year>
Reference-contexts: The linguistic software components developed by these companies were used under license in word-processing programs from hundreds of publishers, in typewriters, and in tens of millions of hand-held spelling devices. 2. The PF474 VLSI chip was a special purpose pipelined processor <ref> [16, 11] </ref> that implemented the algorithm of [15]. Today's software matches and even exceeds the performance of this device, although the comparison is not entirely fair, since the PF474 was clocked at only 4 Mhz.
Reference: [12] <author> D. Sankoff and J. B. Kruskal, </author> <title> Macromolecules: The Theory and Practice of Sequence Comparison, </title> <publisher> Addison-Wesley, </publisher> <year> 1983, 1983. </year>
Reference-contexts: Words as such receive no special treatment. In this sense it is related to the document retrieval approach of [3, 5]. An alternative approach to string comparison computes edit distance <ref> [4, 12] </ref>, i.e., the minimum-cost transformation of one string into another via some set of elementary operations. Most commonly, weighted insertion, deletion, and substitution operations are used, and the edit distance computation is a straightforward dynamic program.
Reference: [13] <author> J. Seiferas, </author> <title> A large bibliography on theory/foundations of computer science. </title> <booktitle> ftp://ftp.cs.rochester.edu, </booktitle> <pages> 1996-7. </pages>
Reference-contexts: There is no query language, and the comparison function is rather robust with respect to typical errors, missing or extra information, and overall ordering (see figure 1 based on the database of <ref> [13] </ref>). Also, the LikeIt facility includes no natural language-specific considerations. It operates on byte strings and as such may be used across languages and perhaps for applications that have nothing to do with language (such as DNA sequence comparison). <p> The final argument '&lt;query&gt;' provides the search query, and must be enclosed in single or double quotes if it contains whitespace. A facility self-test ("big") may be run by the special usage: likeit -t. The following example using the sample database <ref> [13] </ref> provided with the LikeIt distribution illustrates command-line mode: % likeit -n 2 rochester.lst "optimldictionryproblm" 6263703.0 Andersson, Optimal Bounds on the Dictionary 3 In fact, they are mapped to space characters like other non-alphanumerics. 7 Problem|LNCS|401|1989 6272296.0 Li & Probst, Optimal VLSI Dictionary Machines Without Compress Instructions|IEEETC|39|1990 % The numeric value <p> In addition to supporting customization using the filter types included with the distribution, this architecture anticipates the creation of new types. 7 Timings We measure the facility's time performance by applying the likeit program to the database of <ref> [13] </ref>. This database is a listing of 50,360 papers in theoretical computer science. Each line gives the authors, title, journal or conference, and date. We reordered fields to match this description and added `|' between them. The resulting file is 4,278,967 bytes.
Reference: [14] <author> S. Wu and U. Manber, </author> <title> Fast test searching allowing errors, </title> <journal> Communications of the ACM, </journal> <volume> 35 (1993), </volume> <pages> pp. 83-91. </pages>
Reference-contexts: Given a query string, it is then possible to build an automaton to detect it, or any match within the error bounds, within a second string. The recent work of <ref> [8, 14] </ref> demonstrates that text can be scanned at very high speeds within this framework for comparison. The LikeIt framework, on the other hand, can satisfy queries that do not fall within the practical capabilities of the automaton approach because they are too different from the desired database record.
Reference: [15] <author> P. N. Yianilos, </author> <title> The definition, computation and application of symbol string similarity functions, </title> <type> Master's thesis, </type> <institution> Emory University, Department of Mathematics, </institution> <year> 1978. </year> <title> [16] , A dedicated comparator matches symbol strings fast and intelligently, in Electronics Magazine, </title> <publisher> McGraw-Hill, </publisher> <month> December </month> <year> 1983. </year> <title> [17] , Data structures and algorithms for nearest neighbor search in general metric spaces, </title> <booktitle> in Proceedings of the 4th ACM-SIAM Symposium on Discrete Algorithms (SODA'93), </booktitle> <year> 1993, </year> <pages> pp. 311-321. 19 </pages>
Reference-contexts: So 100,000 records of 30 characters each can be processed in 0:15 seconds. LikeIt is in some sense a fourth generation implementation of the following general approach: 2 1. Algorithms of the general type used by LikeIt were introduced in <ref> [15] </ref>, and were later used in the commercial spelling correctors of Proximity Technology, Inc., and Franklin Electronic Publishers. The linguistic software components developed by these companies were used under license in word-processing programs from hundreds of publishers, in typewriters, and in tens of millions of hand-held spelling devices. 2. <p> The linguistic software components developed by these companies were used under license in word-processing programs from hundreds of publishers, in typewriters, and in tens of millions of hand-held spelling devices. 2. The PF474 VLSI chip was a special purpose pipelined processor [16, 11] that implemented the algorithm of <ref> [15] </ref>. Today's software matches and even exceeds the performance of this device, although the comparison is not entirely fair, since the PF474 was clocked at only 4 Mhz. The same design implemented today would still result in a 1-2 order of magnitude hardware advantage. 3.
References-found: 14

