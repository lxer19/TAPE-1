URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/fall97/papers/mcmillan.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/fall97/abstract/mcmillan.html
Root-URL: http://www.cs.berkeley.edu
Email: mcmillan@cadence.com  
Title: A compositional rule for hardware design refinement  
Author: K. L. McMillan 
Address: 1919 Addison St., suite 303 Berkeley, CA 94704-1144  
Affiliation: Cadence Berkeley Labs  
Abstract: We present an approach to designing verified digital systems by a sequence of small local refinements. Refinements in this approach are not limited to a library of predefined transformations for which theorems have been previously established. Rather, the approach relies on localizing the refinement steps in such a way that they can be verified efficiently by model checking. Toward this end, a compositional rule is proposed by which each design refinement may be verified independently, in an abstract environment. This rule supports the use of downward refinement maps, which translate abstract behavior detailed behavior. These maps may involve temporal transformations, including delay. The approach is supported by a verification tool based on symbolic model checking.
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> R. Alur and T. A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In 11th annual IEEE symp. Logic in Computer Science (LICS '96), </booktitle> <year> 1996. </year>
Reference-contexts: The circularity is broken inductively, as a result of the delay of one time unit from input to output of the Moore machines. Alur and Henzinger <ref> [AH96] </ref> extended this to the case of Mealy machines where there are no combinational cycles. A limitation of this kind of proof rule is that the abstract processes P 0 and Q 0 do not typically have the same inputs and outputs as the detailed processes P and Q.
Reference: [BB94] <author> D. L. Beatty and R. E. Bryant. </author> <title> Formally verifying a microprocessor using a simulation methodology. </title> <booktitle> In 31st Design Automation Conference, </booktitle> <pages> pages 596-602, </pages> <year> 1994. </year>
Reference-contexts: This effectively puts the verification of P in an abstract context, an observation has been made in the context of symbolic simulation by Bryant and Beatty <ref> [BB94] </ref> and in the context of theorem provers by Cyrluk [Cyr96]. Note also that upward maps can be very complex. In the case of pipelines, for example, the upward abstraction map involves flushing the entire state of the pipeline, which may contain many instructions.
Reference: [BD94] <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Conf. Computer-Aided Verification (CAV '94), volume 818 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In the case of pipelines, for example, the upward abstraction map involves flushing the entire state of the pipeline, which may contain many instructions. Although in some cases this complexity can be dealt with, using BDD's [BF89] or sophisticated decision procedures <ref> [BD94, JDB95] </ref>, we would prefer a methodology that decomposes the verification problem into small subproblems. In the case of pipelines, for example, downward refinement maps involving delay can yield separate verification subproblems for each stage of the pipeline.
Reference: [BF89] <author> S. Bose and A. Fisher. </author> <title> Verifying pipelined hardware using symbolic logic simulation. </title> <booktitle> In IEEE International Conference on Computer Design, </booktitle> <year> 1989. </year>
Reference-contexts: Note also that upward maps can be very complex. In the case of pipelines, for example, the upward abstraction map involves flushing the entire state of the pipeline, which may contain many instructions. Although in some cases this complexity can be dealt with, using BDD's <ref> [BF89] </ref> or sophisticated decision procedures [BD94, JDB95], we would prefer a methodology that decomposes the verification problem into small subproblems. In the case of pipelines, for example, downward refinement maps involving delay can yield separate verification subproblems for each stage of the pipeline.
Reference: [Cyr96] <author> D. Cyrluk. </author> <title> Inverting the abstraction mapping: a methodology for hardware verification. </title> <editor> In M. Srivas and A. Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design (FMCAD '96), volume 1166 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This effectively puts the verification of P in an abstract context, an observation has been made in the context of symbolic simulation by Bryant and Beatty [BB94] and in the context of theorem provers by Cyrluk <ref> [Cyr96] </ref>. Note also that upward maps can be very complex. In the case of pipelines, for example, the upward abstraction map involves flushing the entire state of the pipeline, which may contain many instructions.
Reference: [GL94] <author> O. Grumberg and D. E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: One commonly proposed specification language for these properties is temporal logic [Pnu85], and systems of compositional inference rules have been developed to support "assume-guarantee" style proofs [Lam83] using various temporal logics (e.g., <ref> [GL94] </ref>). In a compositional proof, one reasons thus: P; j= P k Q j= Here, P and Q are processes, and is an environment assumption, necessary to prove that P satisfies specification . Typically, however, the environment assumptions needed to verify interacting processes are interdependent.
Reference: [JDB95] <author> R. B. Jones, D. L. Dill, and J. R. Burch. </author> <title> Efficient validity checking for processor verification. </title> <booktitle> In IEEE/ACM Int. Conf. on Computer Aided Design (ICCAD '95), </booktitle> <year> 1995. </year>
Reference-contexts: In the case of pipelines, for example, the upward abstraction map involves flushing the entire state of the pipeline, which may contain many instructions. Although in some cases this complexity can be dealt with, using BDD's [BF89] or sophisticated decision procedures <ref> [BD94, JDB95] </ref>, we would prefer a methodology that decomposes the verification problem into small subproblems. In the case of pipelines, for example, downward refinement maps involving delay can yield separate verification subproblems for each stage of the pipeline.
Reference: [Kur87] <author> R. P. Kurshan. </author> <title> Reducibility in analysis of coordination. </title> <booktitle> In LNCS, </booktitle> <volume> volume 103, </volume> <pages> pages 19-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Such an inductive argument cannot be expressed in the above rule. If one attempts it, the result is a circular argument. One way to break the circularity is to model the environment as an abstract process. Kurshan <ref> [Kur87, Kur94] </ref> introduced the following style of reasoning for Moore machines: 1 P k Q 0 ) P 0 P k Q ) P 0 k Q 0 where ) can be replaced by any suitable process preorder.
Reference: [Kur94] <author> R. P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes. </title> <publisher> Princeton, </publisher> <year> 1994. </year>
Reference-contexts: Such an inductive argument cannot be expressed in the above rule. If one attempts it, the result is a circular argument. One way to break the circularity is to model the environment as an abstract process. Kurshan <ref> [Kur87, Kur94] </ref> introduced the following style of reasoning for Moore machines: 1 P k Q 0 ) P 0 P k Q ) P 0 k Q 0 where ) can be replaced by any suitable process preorder.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: One commonly proposed specification language for these properties is temporal logic [Pnu85], and systems of compositional inference rules have been developed to support "assume-guarantee" style proofs <ref> [Lam83] </ref> using various temporal logics (e.g., [GL94]). In a compositional proof, one reasons thus: P; j= P k Q j= Here, P and Q are processes, and is an environment assumption, necessary to prove that P satisfies specification .
Reference: [McM93] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer, </publisher> <year> 1993. </year>
Reference-contexts: This flexibility to choose an arbitrary decomposition of the specification can be used to simplify the resulting verification subproblems. The system is implemented on top of the SMV symbolic model checker <ref> [McM93] </ref>. 2 A compositional rule for Mealy machines We begin by introducing a compositional rule for Mealy machines. For the present purposes, a Mealy machine will be defined as a collection of recurrence equations involving either zero delay or unit delay.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This means that properties of individual modules or components of a large system are verified in isolation, and these properties are then combined to prove properties of the system as a whole. One commonly proposed specification language for these properties is temporal logic <ref> [Pnu85] </ref>, and systems of compositional inference rules have been developed to support "assume-guarantee" style proofs [Lam83] using various temporal logics (e.g., [GL94]).
Reference: [Wol83] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56 </volume> <pages> 72-99, </pages> <year> 1983. </year>
References-found: 13

