URL: http://www.csl.sri.com/reports/postscript/tpcd94-tutorial.ps.gz
Refering-URL: http://www.csl.sri.com/pvs.html
Root-URL: 
Email: srivasg@csl.sri.com  
Title: A Tutorial on Using PVS for Hardware Verification  
Author: S. Owre, J. M. Rushby, N. Shankar and M. K. Srivas fowre, rushby, shankar, 
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory, SRI International,  
Abstract: PVS stands for "Prototype Verification System." It consists of a specification language integrated with support tools and a theorem prover. PVS tries to provide the mechanization needed to apply formal methods both rigorously and productively. This tutorial serves to introduce PVS and its use in the context of hardware verification. In the first section, we briefly sketch the purposes for which PVS is intended and the rationale behind its design, mention some of the uses that we and others are making of it. We give an overview of the PVS specification language and proof checker. The PVS language, system, and theorem prover each have their own reference manuals, 1;2;3 which you will need to study in order to make productive use of the system. A pocket reference card, summarizing all the features of the PVS language, system, and prover is also available. The purpose of this tutorial is not to describe in detail the features of PVS and how to use the system. Rather, its purpose is to introduce some of the more unique and powerful capabilities that are provided by PVS and demonstrate how these features can be used in the context of hardware verification. We present completely worked out proofs of two hardware examples. One of the examples is a pipelined microprocessor that has been used as benchmark for model checkers and the other is a parameterized implementation of an N-bit ripple-carry adder. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Mark D. Aagard, Miriam E. Leeser, and Phillip J. Windley. </author> <title> Toward a super duper hardware tactic. </title> <booktitle> In Proceedings of the HOL User's Group Workshop, </booktitle> <pages> pages 401-414, </pages> <year> 1993. </year>
Reference-contexts: The proof of the microprocessor property shown below follows a certain general pattern that works successfully for most hardware proofs. This general proof pattern, variants of which have been used in other verification exercises <ref> [1, 18] </ref>, consists of the following sequence of general proof tasks. Quantifier elimination: Since the decision procedures work on ground formulas, the user must eliminate the relevant universal quantifiers by skolemiza-tion or selecting variables on which to induct and existential quantifiers by suitable instantiation. <p> In the present case, each of these goals can be discharged by assert. The compound proof step appearing on lines 4 through 6 of the proof accomplishes the case-splitting task. correctness : |------- <ref> [1] </ref> (stall (t!1)) f2g aluop (opcode (t!1), IF src1 (t!1) = dstnd (t!1) & NOT stalld (t!1) THEN aluop (opcoded (t!1), opreg1 (t!1), opreg2 (t!1)) ELSIF src1 (t!1) = dstndd (t!1) & NOT stalldd (t!1) THEN wbreg (t!1) ELSE regfile (t!1)(src1 (t!1)) ENDIF, ....
Reference: 2. <author> Heather Alexander and Val Jones. </author> <title> Software Design and Prototyping using me too. </title> <publisher> Prentice Hall International, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1990. </year>
Reference-contexts: We do expect to provide these in a later release, but using a different approach than EHDM. 5 Directly executable specification languages (e.g., <ref> [2, 17] </ref>) support validation of spec 3 1.2 Uses of PVS PVS has so far been applied to several small demonstration examples, and a growing number of significant verifications.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF [15], Nuprl [7], Coq [8], and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm <ref> [3, 4] </ref> and Otter [21]. We feel that the low-level systems over-emphasize the formal correctness of proofs at the expense of their cogency, and the highly automated systems emphasize theorems at the expense of their proofs.
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF [15], Nuprl [7], Coq [8], and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm <ref> [3, 4] </ref> and Otter [21]. We feel that the low-level systems over-emphasize the formal correctness of proofs at the expense of their cogency, and the highly automated systems emphasize theorems at the expense of their proofs.
Reference: 5. <author> J. R. Burch, E. M. Clarke, K. L McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 2 20 states and beyond. </title> <booktitle> In 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: The design and the property verified are both based on the processor example given in <ref> [5] </ref>. The example has been used as a benchmark for evaluating how well finite state-enumeration based tools, such as model checkers, can handle datapath-oriented circuits with a large number of states by varying the size of the datapath.
Reference: 6. <author> F. J. Cantu. </author> <title> Verifying an n-bit arithmetic logic unit. Blue book note 935, </title> <institution> University of Edinburgh, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The strategy is parameterized with respect to induction scheme to be used and the set of rewrite rules to be used for unfolding. We have used the strategy to prove an N-bit ALU <ref> [6] </ref> that executes 12 microoperations by cascading N 1-bit ALU slices. 19 7 Summary This tutorial gives an overview of some of the unique and important capabilities of PVS.
Reference: 7. <author> R. L. Constable, et al. </author> <title> Implementing Mathematics with the Nuprl. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1986. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF [15], Nuprl <ref> [7] </ref>, Coq [8], and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [3, 4] and Otter [21].
Reference: 8. <author> T. Coquand and G. P. Huet. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In Proceedings of EUROCAL 85, </booktitle> <address> Linz (Austria), Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF [15], Nuprl [7], Coq <ref> [8] </ref>, and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [3, 4] and Otter [21].
Reference: 9. <author> Costas Courcoubetis, </author> <title> editor. Computer-Aided Verification, </title> <booktitle> CAV '93, volume 697 of Lecture Notes in Computer Science, </booktitle> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: 10. <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <editor> In Ramayya Kumar and Thomas Kropf, editors, </editor> <booktitle> Preliminary Proceedings of the Second Conference on Theorem Provers in Circuit Design, </booktitle> <pages> pages 287-305, </pages> <address> Bad Herrenalb (Blackforest), Germany, </address> <month> September </month> <year> 1994. </year> <institution> Forschungszen-trum Informatik an der Universitat Karlsruhe, </institution> <note> FZI Publication 4/94. </note>
Reference-contexts: PVS also provides an efficient conditional rewriter that interacts very closely with its decision procedures to simplify conditions during rewriting. More details about the rewriting and the decision procedures used in PVS are described in <ref> [10] </ref>. The capabilities of the inference and decision procedures, which play a central role in almost all proofs in PVS are made available to the user by means of the following primitive inference steps. 1. Bddsimp performs efficient BDD-based propositional simplification on the current goal. 2.
Reference: 11. <author> David Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Examples of this scale can typically be completed within a day. More substantial examples include the correspondence between the programmer and RTL level of a simple hardware processor <ref> [11] </ref>, the correctness of a real-time railroad crossing controller [29], a variant of the Schroder-Bernstein theorem, and the correctness of a distributed agreement protocol for a hybrid fault model consisting of Byzantine, symmetric, and crash faults [19]. These harder examples can take from several days to a week.
Reference: 12. <author> N. G. de Bruijn. </author> <title> A survey of the project Automath. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 589-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH <ref> [12] </ref>, LCF [15], Nuprl [7], Coq [8], and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [3, 4] and Otter [21].
Reference: 13. <author> B. Elspas, M. Green, M. Moriconi, and R. Shostak. </author> <title> A JOVIAL verifier. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System <ref> [13] </ref>, the Hierarchical Development Methodology (HDM) [25, 26], STP [30], and EHDM [22, 27]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: 14. <author> W. M. Farmer, J. D. Guttman, and F. J. Thayer. IMPS: </author> <title> An interactive mathematical proof system. </title> <type> Technical Report M90-19, </type> <institution> Mitre Corporation, </institution> <year> 1991. </year>
Reference-contexts: There are about 20 basic commands and a similar number of commonly used high-level strategies. 7 The Ontic system [20] is a proof checker where decision procedures are ubiquitously used. Nqthm [3,4], Eves [24], and IMPS <ref> [14] </ref> also rely heavily on the use of decision procedures. 6 4 Rest of the Tutorial In the following sections we introduce some of the details of PVS system by working the complete proof of correctness of two examples.
Reference: 15. <author> M. Gordon, R. Milner, and C. Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF <ref> [15] </ref>, Nuprl [7], Coq [8], and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [3, 4] and Otter [21].
Reference: 16. <author> M. J. C. Gordon. </author> <title> HOL: A proof generating system for higher-order logic. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 73-128. </pages> <publisher> Kluwer, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1988. </year>
Reference-contexts: In following these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF [15], Nuprl [7], Coq [8], and HOL <ref> [16] </ref>, but provides more user control over the structure of the proof than highly automated systems such as Nqthm [3, 4] and Otter [21].
Reference: 17. <author> Sharam Hekmatpour and Darrel Ince. </author> <title> Software Prototyping, Formal Methods, and VDM. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1988. </year> <month> 21 </month>
Reference-contexts: We do expect to provide these in a later release, but using a different approach than EHDM. 5 Directly executable specification languages (e.g., <ref> [2, 17] </ref>) support validation of spec 3 1.2 Uses of PVS PVS has so far been applied to several small demonstration examples, and a growing number of significant verifications.
Reference: 18. <author> R. Kumar, K. Schneider, and T. Kropf. </author> <title> Structuring and automating hardware proofs in a higher-order therem proving environment. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2(2) </volume> <pages> 165-223, </pages> <year> 1993. </year>
Reference-contexts: The proof of the microprocessor property shown below follows a certain general pattern that works successfully for most hardware proofs. This general proof pattern, variants of which have been used in other verification exercises <ref> [1, 18] </ref>, consists of the following sequence of general proof tasks. Quantifier elimination: Since the decision procedures work on ground formulas, the user must eliminate the relevant universal quantifiers by skolemiza-tion or selecting variables on which to induct and existential quantifiers by suitable instantiation.
Reference: 19. <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Courcoubetis [9], </booktitle> <pages> pages 292-304. </pages>
Reference-contexts: include the correspondence between the programmer and RTL level of a simple hardware processor [11], the correctness of a real-time railroad crossing controller [29], a variant of the Schroder-Bernstein theorem, and the correctness of a distributed agreement protocol for a hybrid fault model consisting of Byzantine, symmetric, and crash faults <ref> [19] </ref>. These harder examples can take from several days to a week.
Reference: 20. <author> D. A. McAllester. ONTIC: </author> <title> A Knowledge Representation System for Mathematics. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The advanced user will also need to understand how to define proof strategies that capture repetitive patterns of proof commands, and commands used for displaying, editing, and replaying proofs. There are about 20 basic commands and a similar number of commonly used high-level strategies. 7 The Ontic system <ref> [20] </ref> is a proof checker where decision procedures are ubiquitously used.
Reference: 21. <author> W. McCune. </author> <title> Otter 2.0 users guide. </title> <type> Technical Report ANL-90/9, </type> <institution> Argonne National Laboratory, </institution> <year> 1990. </year>
Reference-contexts: these design assumptions, the PVS proof checker is more automated than a low-level proof checker such as AUTOMATH [12], LCF [15], Nuprl [7], Coq [8], and HOL [16], but provides more user control over the structure of the proof than highly automated systems such as Nqthm [3, 4] and Otter <ref> [21] </ref>. We feel that the low-level systems over-emphasize the formal correctness of proofs at the expense of their cogency, and the highly automated systems emphasize theorems at the expense of their proofs.
Reference: 22. <author> P. Michael Melliar-Smith and John Rushby. </author> <title> The Enhanced HDM system for specification and verification. </title> <booktitle> In Proc. VerkShop III, </booktitle> <pages> pages 41-43, </pages> <address> Watsonville, CA, </address> <month> February </month> <year> 1985. </year> <booktitle> Published as ACM Software Engineering Notes, </booktitle> <volume> Vol. 10, No. 4, </volume> <month> Aug. 85. </month>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [13], the Hierarchical Development Methodology (HDM) [25, 26], STP [30], and EHDM <ref> [22, 27] </ref>. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: 23. <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Some lessons learned. </title> <editor> In J. C. P. Woodcock and P. G. Larsen, editors, </editor> <booktitle> FME '93: Industrial-Strength Formal Methods, </booktitle> <pages> pages 482-500, </pages> <address> Odense, Denmark, </address> <month> April </month> <year> 1993. </year> <booktitle> Volume 670 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The second example illustrates proof by induction. 1.1 Design Goals for PVS The design of PVS was shaped by our experience in doing or contemplating early-lifecycle applications of formal methods. Many of the larger examples we 2 have done concern algorithms and architectures for fault-tolerance (see <ref> [23] </ref> for an overview). We found that many of the published proofs that we attempted to check were in fact, incorrect, as was one of the important algorithms. We have also found that many of our own specifications are subtly flawed when first written.
Reference: 24. <author> W. Pase and M. Saaltink. </author> <title> Formal verification in m-EVES. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> Current Trends in Hardware Verification and Theorem Proving, </booktitle> <pages> pages 268-302, </pages> <address> New York, NY, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: There are about 20 basic commands and a similar number of commonly used high-level strategies. 7 The Ontic system [20] is a proof checker where decision procedures are ubiquitously used. Nqthm [3,4], Eves <ref> [24] </ref>, and IMPS [14] also rely heavily on the use of decision procedures. 6 4 Rest of the Tutorial In the following sections we introduce some of the details of PVS system by working the complete proof of correctness of two examples.
Reference: 25. <author> L. Robinson, K. N. Levitt, and B. A. Silverberg. </author> <title> The HDM Handbook. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> June </month> <year> 1979. </year> <title> Three Volumes. </title>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [13], the Hierarchical Development Methodology (HDM) <ref> [25, 26] </ref>, STP [30], and EHDM [22, 27]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: 26. <author> Lawrence Robinson and Karl N. Levitt. </author> <title> Proof techniques for hierarchically structured programs. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 271-283, </pages> <month> April </month> <year> 1976. </year>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [13], the Hierarchical Development Methodology (HDM) <ref> [25, 26] </ref>, STP [30], and EHDM [22, 27]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: 27. <author> John Rushby, Friedrich von Henke, and Sam Owre. </author> <title> An introduction to formal specification and verification using Ehdm. </title> <type> Technical Report SRI-CSL-91-2, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [13], the Hierarchical Development Methodology (HDM) [25, 26], STP [30], and EHDM <ref> [22, 27] </ref>. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: 28. <author> N. Shankar. </author> <title> Abstract datatypes in PVS. </title> <type> Technical Report SRI-CSL-93-9, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The smaller examples include the specification and verification of ordered binary tree insertion <ref> [28] </ref>, the Boyer-Moore majority algorithm, an abstract pipelined processor, Fischer's real-time mutual exclusion protocol, and the Oral Messages protocol for Byzantine agreement. Examples of this scale can typically be completed within a day. <p> Type parametricity (or polymorphism) is used to capture those concepts or results that can be stated uniformly for all types. PVS also has a facility for automatically generating abstract datatype theories (containing recursion and induction schemes) for a class of abstract datatypes <ref> [28] </ref>. 3 The PVS Proof Checker The central design assumptions in PVS are that The purpose of an automated proof checker is not merely to prove theorems but also to provide useful feedback from failed and partial proofs by serving as a rigorous skeptic.
Reference: 29. <author> Natarajan Shankar. </author> <title> Verification of real-time systems using PVS. </title> <booktitle> In Courcoubetis [9], </booktitle> <pages> pages 280-291. </pages>
Reference-contexts: Examples of this scale can typically be completed within a day. More substantial examples include the correspondence between the programmer and RTL level of a simple hardware processor [11], the correctness of a real-time railroad crossing controller <ref> [29] </ref>, a variant of the Schroder-Bernstein theorem, and the correctness of a distributed agreement protocol for a hybrid fault model consisting of Byzantine, symmetric, and crash faults [19]. These harder examples can take from several days to a week.
Reference: 30. <author> R. E. Shostak, R. Schwartz, and P. M. Melliar-Smith. STP: </author> <title> A mechanized logic for specification and verification. </title> <editor> In D. Loveland, editor, </editor> <booktitle> 6th International Conference on Automated Deduction (CADE), </booktitle> <address> New York, NY, </address> <year> 1982. </year> <booktitle> Volume 138 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: PVS is the most recent in a line of specification languages, theorem provers, and verification systems developed at SRI, dating back over 20 years. That line includes the Jovial Verification System [13], the Hierarchical Development Methodology (HDM) [25, 26], STP <ref> [30] </ref>, and EHDM [22, 27]. We call PVS a "Prototype Verification System," because it was built partly as a lightweight prototype to explore "next generation" technology for EHDM, our main, heavyweight, verification system.
Reference: 31. <editor> M.K. Srivas, et. al. </editor> <title> Hardware verification using pvs: A tutorial. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1994. </year> <note> A Forthcoming Technical Report. 22 </note>
Reference-contexts: The microprocessor specification is organized into three theories, selected parts of which are shown in Figures 2 and 3. (The complete specification can be found in <ref> [31] </ref>.) The theory pipe (Figure 2) contains a specification of the design and a statement of the correctness property to be proved. The theories signal and time (Figure 3) imported by pipe declares the types signal and time used in pipe. <p> The additional proof steps required for a predicative specification essentially unwind the component predicates using their definitions and then appropriately instantiate the existentially quantified variables. An automatic way of performing this translation is discussed in <ref> [31] </ref>, which illustrates more examples of hardware design verification using PVS. Getting back to our example, the microprocessor specification in pipe consists of two parts. The first part declares all the signals used in the design|the inputs to the design and the internal wires that denote the outputs of components.
References-found: 31

