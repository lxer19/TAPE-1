URL: http://www.cs.jhu.edu/~cypher/pubs/repeat.ps
Refering-URL: http://www.cs.jhu.edu/~cypher/pubs/pubs.html
Root-URL: http://www.cs.jhu.edu
Email: cypher@watson.ibm.com leu@almaden.ibm.com  
Title: Repeatable and Portable Message-Passing Programs  
Author: Robert Cypher Eric Leu 
Address: P.O. Box 218 650 Harry Road Yorktown Heights, NY 10598, U.S.A. San Jose, CA 95120, U.S.A.  
Affiliation: IBM Research Division IBM Research Division T.J. Watson Research Center Almaden Research Center  
Abstract: This paper makes two main contributions. First, it defines a set of program executions (called safe executions) that are guaranteed to be repeatable and portable. Safe program executions are defined for applications that utilize both blocking and nonblocking send and receive primitives, synchronous and asynchronous sends, and receives that select on the basis of source and/or tag values. To the best of our knowledge, this is the first time that conditions for repeatable and portable executions have been created for such rich message-passing models. Second, this paper gives precise characterizations of safe executions. The safety of an execution is shown to depend on the message-ordering properties of the underlying communication system, and two different message-ordering properties are examined in detail. In addition to providing insight into safe executions, these characterizations lead to polynomial time algorithms that determine whether or not an execution is safe. In the near future, we plan to use these results to create software that will automatically determine the safety of an execution from a trace of its communication events, thus greatly aiding the development of portable applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Beguelin, J. Dongarra, A. Geist et al., </author> <title> A user's guide to PVM Parallel Virtual Machine, </title> <type> ORNL Technical Report, </type> <institution> ORNL/TM-11826, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture. Fortunately, several message-passing libraries run (or will run) on a large number of hardware platforms <ref> [1, 7, 8, 16] </ref>, thus providing the possibility for creating truly portable applications. However, the interactions between the blocking, synchronization, selectivity, and message-ordering properties of these libraries can be quite subtle, thus complicating the creation of repeatable and portable programs.
Reference: [2] <author> K. M. Chandy, C. Kesselman, </author> <title> Compositional C++: Compositional Parallel Programming, </title> <booktitle> Proc. 5th Intl. Workshop on Languages and Compilers, </booktitle> <editor> U. Banerjee (ed.), </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 124-144, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: As a result of these difficulties, there is a need for a systematic understanding of the application properties that ensure repeatability and portability. Several languages have been created with the goal of supporting the development of repeatable applications <ref> [9, 2, 3] </ref>. However, these languages have communication primitives that are fundamentally different from those studied here. For example, the Fortran M language [9] performs messages passing using only blocking sends and receives, assumes an infinite amount of system buffer space, and addresses messages to ports rather than processes. <p> For example, the Fortran M language [9] performs messages passing using only blocking sends and receives, assumes an infinite amount of system buffer space, and addresses messages to ports rather than processes. Languages that communicate via single-assignment logic variables, such as PCN [3] and Compositional C++ <ref> [2] </ref>, do not have the concepts of nonblocking communication, synchronous communication, buffer limitations or message ordering properties. This paper makes two main contributions. First, it defines a set of program executions (called safe executions) that are guaranteed to be repeatable and portable.
Reference: [3] <author> K. M. Chandy, S. Taylor, </author> <title> The Composition of Concurrent Programs, </title> <booktitle> Proc. Supercomputing '89, </booktitle> <pages> pp. 557-561, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: As a result of these difficulties, there is a need for a systematic understanding of the application properties that ensure repeatability and portability. Several languages have been created with the goal of supporting the development of repeatable applications <ref> [9, 2, 3] </ref>. However, these languages have communication primitives that are fundamentally different from those studied here. For example, the Fortran M language [9] performs messages passing using only blocking sends and receives, assumes an infinite amount of system buffer space, and addresses messages to ports rather than processes. <p> For example, the Fortran M language [9] performs messages passing using only blocking sends and receives, assumes an infinite amount of system buffer space, and addresses messages to ports rather than processes. Languages that communicate via single-assignment logic variables, such as PCN <ref> [3] </ref> and Compositional C++ [2], do not have the concepts of nonblocking communication, synchronous communication, buffer limitations or message ordering properties. This paper makes two main contributions. First, it defines a set of program executions (called safe executions) that are guaranteed to be repeatable and portable.
Reference: [4] <author> R. Curtis, L. Wittie, BugNet: </author> <title> A Debugging System for Parallel Programming Environments, </title> <booktitle> Proc. 3rd International Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 394-399, </pages> <month> Oct. </month> <year> 1982. </year>
Reference-contexts: A fundamental issue in the use of message-passing systems is the creation of repeatable and portable programs. Repeatable program behavior is critical for debugging message-passing programs, both because repeatability allows the programmer to recreate erroneous behavior <ref> [4, 11, 14, 15, 17] </ref>, and because the non-repeatability of an application that should be deterministic implies the existence of an error. Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture.
Reference: [5] <author> R. Cypher, E. Leu, </author> <title> Message-Passing Semantics and Portable Parallel Programs, </title> <type> IBM Research Report 9654, </type> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: This paper makes two main contributions. First, it defines a set of program executions (called safe executions) that are guaranteed to be repeatable and portable. Safe program executions are defined for two message-passing models, namely the unordered and weakly ordered communication models <ref> [5, 6] </ref>, 2 both of which include both blocking and nonblocking send and receive primitives, synchronous and asynchronous sends, and receives that select on the basis of source and/or tag values. <p> Section 3 defines safe program executions and proves that they are repeatable and portable. Finally, safe program executions are precisely characterized in Section 4. Many proofs are omitted due to space limitations, but can be found in the full version of the paper <ref> [5] </ref>. 2 Preliminaries 2.1 Message-Passing Primitives We will consider programs that utilize the following message-passing commands: 1. POST-SEND (buffer, destination, tag) returns id. This command, abbreviated "PS", initiates the send operation, but does not complete it. <p> WAIT-FOR-RECEIVE-TO-BE-MATCHED (id) abbreviated "WR". A WR completes only after a message has been stored into the receive buffer. All of the message-passing primitives mentioned in Section 1 map directly to one or more of the above commands <ref> [5] </ref>. For example, a blocking-synchronous-send maps to a PS immediately followed by a WS, a blocking-asynchronous-send maps to a PS immediately followed by a WB, a nonblocking-send maps to a PS, and a blocking-receive maps to a PR immediately followed by a WR. <p> Property F4 states that each WS and WR operation blocks until it has been matched. 6 Property F5 states that PS and PR operations never deadlock. Finally, property F6 states that matched WB, WS and WR operations never deadlock. An additional property F7, formally defined in <ref> [5] </ref>, states that the message that is received is actually the same as the message that was sent. The following two message ordering properties will be guaranteed by one of our models, but not by the other. These properties apply to both partial and total pro gram executions. <p> As another example, writing into a receive (send) buffer after the PR (PS) was posted and before its matching WR (WB or WS) completed can result in unpredictable contents of messages being received or sent. These restrictions are captured by the notion of a clean execution (see <ref> [5] </ref> for a formal definition): Definition.
Reference: [6] <author> R. Cypher, E. Leu, </author> <title> The Semantics of Blocking and Nonblocking Send and Receive Primitives, </title> <booktitle> Proc. of 8th IEEE International Parallel Processing Symposium, </booktitle> <pages> pp. 729-735, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: This paper makes two main contributions. First, it defines a set of program executions (called safe executions) that are guaranteed to be repeatable and portable. Safe program executions are defined for two message-passing models, namely the unordered and weakly ordered communication models <ref> [5, 6] </ref>, 2 both of which include both blocking and nonblocking send and receive primitives, synchronous and asynchronous sends, and receives that select on the basis of source and/or tag values.
Reference: [7] <author> J. Dongarra, R. Hempel, A. Hey, D. Walker, </author> <title> A Proposal for a User-Level, Message-Passing Interface in a Distributed Memory Environment, </title> <type> ORNL Technical Report, </type> <institution> ORNL/TM-12231, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process. <p> It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives [7, 8, 10, 16, 18, 19, 20], and some systems support both synchronous and asynchronous sends <ref> [7, 16] </ref>. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process. <p> Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture. Fortunately, several message-passing libraries run (or will run) on a large number of hardware platforms <ref> [1, 7, 8, 16] </ref>, thus providing the possibility for creating truly portable applications. However, the interactions between the blocking, synchronization, selectivity, and message-ordering properties of these libraries can be quite subtle, thus complicating the creation of repeatable and portable programs. <p> Furthermore, differences in the amount of system buffering and the protocols that allocate system buffers can cause a program that works correctly on one hardware system to deadlock on another one <ref> [10, 7, 16] </ref>. In fact many systems allocate buffers based on the arrival times of messages, so a program that works correctly one time can deadlock when run a second time with the same input on the same hardware system.
Reference: [8] <institution> Express 3.0 Introductory Guide, Parasoft Corporation, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process. <p> Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture. Fortunately, several message-passing libraries run (or will run) on a large number of hardware platforms <ref> [1, 7, 8, 16] </ref>, thus providing the possibility for creating truly portable applications. However, the interactions between the blocking, synchronization, selectivity, and message-ordering properties of these libraries can be quite subtle, thus complicating the creation of repeatable and portable programs.
Reference: [9] <author> I. Foster, R. Olson, S. Tuecke, </author> <title> Programming in Fortran M, </title> <type> Technical Report ANL-93/26, </type> <institution> Argonne National Laboratory, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: As a result of these difficulties, there is a need for a systematic understanding of the application properties that ensure repeatability and portability. Several languages have been created with the goal of supporting the development of repeatable applications <ref> [9, 2, 3] </ref>. However, these languages have communication primitives that are fundamentally different from those studied here. For example, the Fortran M language [9] performs messages passing using only blocking sends and receives, assumes an infinite amount of system buffer space, and addresses messages to ports rather than processes. <p> Several languages have been created with the goal of supporting the development of repeatable applications [9, 2, 3]. However, these languages have communication primitives that are fundamentally different from those studied here. For example, the Fortran M language <ref> [9] </ref> performs messages passing using only blocking sends and receives, assumes an infinite amount of system buffer space, and addresses messages to ports rather than processes.
Reference: [10] <author> D. Frye, R. Bryant, H. Ho, R. Lawrence, M. Snir, </author> <title> An External User Interface for Scalable Parallel Systems, </title> <type> Technical Report, </type> <institution> IBM Highly Parallel SuperComputing Systems Laboratory, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process. <p> Furthermore, differences in the amount of system buffering and the protocols that allocate system buffers can cause a program that works correctly on one hardware system to deadlock on another one <ref> [10, 7, 16] </ref>. In fact many systems allocate buffers based on the arrival times of messages, so a program that works correctly one time can deadlock when run a second time with the same input on the same hardware system.
Reference: [11] <author> M. Hurfin, N. Plouzeau, M. Raynal, EREBUS: </author> <title> A Debugger for Asynchronous Distributed Systems, </title> <booktitle> Proc. 3rd Int. IEEE Workshop on Future Trends in Distributed Computing Systems, </booktitle> <pages> pp. 93-98, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: A fundamental issue in the use of message-passing systems is the creation of repeatable and portable programs. Repeatable program behavior is critical for debugging message-passing programs, both because repeatability allows the programmer to recreate erroneous behavior <ref> [4, 11, 14, 15, 17] </ref>, and because the non-repeatability of an application that should be deterministic implies the existence of an error. Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture.
Reference: [12] <author> L. Lamport, </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> Comm. of the ACM 21(7), </journal> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: The following theorems give precise characterizations of system buffer dependency for these two models. They are based on the following 7 Note that R + u and R + w , the transitive closures of these relations, are similar to Lamport's happened-before relation <ref> [12] </ref>, except that they have been extended to apply to events and matches, and to synchronous and nonblocking communication primitives. 6 properties regarding acyclic relations. Let hE; M i be a partial or total program execution, and let a and b be arbitrary events in E.
Reference: [13] <author> L. Lamport, </author> <title> How to Make a Multiprocessor Computer that Correctly Executes Multiprocess Programs, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9), </volume> <pages> pp. 690-691, </pages> <year> 1979. </year>
Reference-contexts: Note that the definition of a feasible unordered execution is based on the existence of a suitable interleaving of the events and matches, and is thus analogous to the definition of a sequentially consistent execution in the shared memory model <ref> [13] </ref>. Definition. Given any total execution hE; M i and any set of properties F , complete (hE; M i ; F ) iff for all events a; b 2 E, :R M (a; b) ) :satisfies (hE; M [ f (a; b)gi ; F ).
Reference: [14] <author> T. Leblanc, J. Mellor-Crummey, </author> <title> Debugging Parallel Programs with Instant Replay, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4), </volume> <pages> pp. 471-482, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: A fundamental issue in the use of message-passing systems is the creation of repeatable and portable programs. Repeatable program behavior is critical for debugging message-passing programs, both because repeatability allows the programmer to recreate erroneous behavior <ref> [4, 11, 14, 15, 17] </ref>, and because the non-repeatability of an application that should be deterministic implies the existence of an error. Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture.
Reference: [15] <author> E. Leu, A. Schiper, A. Zramdini, </author> <title> Efficient Execution Replay Technique for Distributed Memory Architectures, </title> <booktitle> Proc. of 2nd European Distributed Memory Computing Conference, </booktitle> <publisher> LNCS 487, Springer-Verlag, </publisher> <pages> pp. 315-324, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: A fundamental issue in the use of message-passing systems is the creation of repeatable and portable programs. Repeatable program behavior is critical for debugging message-passing programs, both because repeatability allows the programmer to recreate erroneous behavior <ref> [4, 11, 14, 15, 17] </ref>, and because the non-repeatability of an application that should be deterministic implies the existence of an error. Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture.
Reference: [16] <editor> Document for a Standard Message-Passing Interface, </editor> <title> Draft, Message Passing Interface Forum, </title> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process. <p> It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives [7, 8, 10, 16, 18, 19, 20], and some systems support both synchronous and asynchronous sends <ref> [7, 16] </ref>. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process. <p> Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture. Fortunately, several message-passing libraries run (or will run) on a large number of hardware platforms <ref> [1, 7, 8, 16] </ref>, thus providing the possibility for creating truly portable applications. However, the interactions between the blocking, synchronization, selectivity, and message-ordering properties of these libraries can be quite subtle, thus complicating the creation of repeatable and portable programs. <p> Furthermore, differences in the amount of system buffering and the protocols that allocate system buffers can cause a program that works correctly on one hardware system to deadlock on another one <ref> [10, 7, 16] </ref>. In fact many systems allocate buffers based on the arrival times of messages, so a program that works correctly one time can deadlock when run a second time with the same input on the same hardware system.
Reference: [17] <author> R. Netzer, B. Miller, </author> <title> Optimal Tracing and Replay for Debugging Message-Passing Parallel Programs, </title> <booktitle> Proc. of SuperComputing 92 Conf., </booktitle> <pages> pp. 502-511, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: A fundamental issue in the use of message-passing systems is the creation of repeatable and portable programs. Repeatable program behavior is critical for debugging message-passing programs, both because repeatability allows the programmer to recreate erroneous behavior <ref> [4, 11, 14, 15, 17] </ref>, and because the non-repeatability of an application that should be deterministic implies the existence of an error. Portability of message-passing applications is essential for efficient software development, as it is impractical to develop a separate version of each program for each message-passing architecture.
Reference: [18] <institution> Paragon XP/S Overview, Intel Corp., </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process.
Reference: [19] <author> G. Regnier, </author> <title> Delta Message Passing Protocol, Proc. of First Intel Delta Applications Workshop, </title> <type> also Tech. Report CCSF-14-92, </type> <pages> pp. 173-178, </pages> <address> Cal-Tech, </address> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process.
Reference: [20] <institution> The Connection Machine CM-5 Technical Summary, Thinking Machines Corp., </institution> <month> Oct. </month> <year> 1991. </year> <month> 7 </month>
Reference-contexts: 1 Introduction Many parallel and distributed systems support a message-passing model in which processes operate asynchronously and communicate solely by posting matching send and receive commands. It is becoming increasingly common for these systems to support both blocking and nonblocking send and receive primitives <ref> [7, 8, 10, 16, 18, 19, 20] </ref>, and some systems support both synchronous and asynchronous sends [7, 16]. The synchronization and blocking properties of the send and receive primitives specify when they return to the calling process.
References-found: 20

