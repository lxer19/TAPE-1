URL: http://www.research.microsoft.com/lampson/50-CorrectnessAMOMessages\Postscript.ps
Refering-URL: http://www.research.microsoft.com/lampson/Publications.html
Root-URL: http://www.research.microsoft.com
Title: Correctness of At-Most-Once Message Delivery Protocols  
Author: Butler W. Lampson a Nancy A. Lynch b and Jtrgen F. Stgaard-Andersen cfl 
Keyword: Keyword Codes: C.2.2; D.2.4; F.1.1 Keywords: Computer Systems Organization, Network Protocols; Software, Program Verification; Theory of Computation, Models of Computation  
Address: Cambridge, MA 02139, USA.  Square, Cambridge, MA 02139, USA.  Denmark, Building 344, DK-2800 Lyngby, Denmark.  
Affiliation: a Cambridge Research Laboratory, DEC,  b Lab. for Computer Science, MIT, 545 Tech.  c Department of Computer Science, Technical University of  
Abstract: This paper addresses the issues of formal description and verification for communication protocols. Specifically, we present the results of a project concerned with proving correctness of two different solutions to the at-most-once message delivery problem. The two implementations are the well-known five-packet handshake protocol and a timing-based protocol developed for networks with bounded message delays. We use an operational automaton-based approach to formal specification of the problem statement and the implementations, plus intermediate levels of abstraction in a step-wise development from specification to implementations. We use simulation techniques for proving correctness. In the project we deal with safety, timing, and liveness properties. In this paper, however, we concentrate on safety and timing properties. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Recent advances include the development of formal models that allow reasoning about timed systems as well as untimed systems, e.g., [2, 5, 13], and the development of simulation techniques (including refinement mappings and forward and backward simulations) for proving that one protocol implements another, e.g., <ref> [1, 5-7, 13] </ref>. In this paper, we show how these techniques can be used to verify an important class of communication protocols those for at-most-once message delivery. <p> The main distinction between forward and backward simulations, which are abstract representations of history [16] and prophecy <ref> [1] </ref> variables, respectively, lies in the way these corresponding sequences of steps of the specification are found given a step of the implementation: in a forward simulation it must be shown that from each state of the specification which is related to the pre-state of the step of the implementation, there
Reference: 2. <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In J. W. de Dakker, C. Huizing, and G. Rozenberg, editors, </editor> <booktitle> Proceedings of REX Workshop "Real-Time: Theory in Practice", Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1991, </year> <booktitle> number 600 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-27. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 16 </month>
Reference-contexts: Recent advances include the development of formal models that allow reasoning about timed systems as well as untimed systems, e.g., <ref> [2, 5, 13] </ref>, and the development of simulation techniques (including refinement mappings and forward and backward simulations) for proving that one protocol implements another, e.g., [1, 5-7, 13].
Reference: 3. <author> D. Belsnes. </author> <title> Single message communication. </title> <journal> IEEE Transactions on Communications, </journal> <volume> Com-24(2), </volume> <month> February </month> <year> 1976. </year>
Reference-contexts: In this work, we consider two protocols that are important in practice: the clock-based protocol of Liskov, Shrira and Wroclawski [10] and the five-packet handshake protocol of Belsnes <ref> [3] </ref>. The latter is the standard protocol for setting up network connections, used in TCP, ISO TP-4, and many other transport protocols. It is sometimes called the three-way handshake, because only three packets are needed for message delivery; the additional packets are required for acknowledgement and cleaning up the state.
Reference: 4. <author> Stephen J. Garland and John V. Guttag. </author> <title> A guide to LP, the Larch Prover. </title> <type> Technical Report 82, </type> <institution> DEC, Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: In [17] bounded identifier spaces are dealt with for similar protocols. Third, we would like to automate our simulation proofs using a mechanical theorem prover. We have already begun this work, by proving the equivalence of versions of S and D using the Larch Prover <ref> [18, 4] </ref>. We have been pleased with the preliminary results: the prover has not only been able to check our hand proofs, but in fact has been able to fill in many of the details.
Reference: 5. <author> R. Gawlick, N. Lynch, R. Segala, and J. Stgaard-Andersen. </author> <title> Liveness in timed and untimed systems. </title> <type> Technical report, </type> <institution> MIT, Laboratory for Computer Science, </institution> <year> 1993. </year>
Reference-contexts: Recent advances include the development of formal models that allow reasoning about timed systems as well as untimed systems, e.g., <ref> [2, 5, 13] </ref>, and the development of simulation techniques (including refinement mappings and forward and backward simulations) for proving that one protocol implements another, e.g., [1, 5-7, 13]. <p> Both protocols are sufficiently complicated that formal specification and proof seems useful. The basic model we use is based on the (timed ) automaton model of Lynch and Vaandrager [13] with an extra added component to express liveness <ref> [5] </ref>. We express both protocols, as well as the formal specification of the at-most-once message delivery problem, in terms of this model. In the project we carry out complete correctness proofs for both protocols. <p> In doing so we present the delayed-decision specification D. Finally, we give concluding remarks in Section 7. 2. THE UNDERLYING THEORY The general model we use to specify safety and timing properties at all levels of abstraction is based on the (timed ) automaton model of <ref> [5, 13] </ref> and the I/O automaton model of [11, 12]. An automaton is a state machine with named actions associated with its transitions. Thus, an automaton consists of * a (possibly infinite) set of states. <p> In timed systems these actions are furthermore paired with their time of occurrence to form timed traces. One automaton, A, safely implements another automaton, B, if the set of (timed) traces of A is included in that of B. The papers <ref> [6, 13, 5] </ref> present a collection of simulation proof techniques (refinement mappings, forward and backward simulations, etc.) for showing that one (timed) automaton safely implements another. Each of these techniques involves describing a relation between the states of an implementation automaton and those of a specification automaton.
Reference: 6. <author> B. Jonsson. </author> <title> Simulations between specifications of distributed systems. </title> <editor> In J. C. M. Baeten and J. F. Groote, editors, </editor> <booktitle> Proceedings of CONCUR '91. 2nd International Conference on Concurrency Theory, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1991, </year> <booktitle> number 527 in Lecture Notes in Computer Science, </booktitle> <pages> pages 346-360. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In timed systems these actions are furthermore paired with their time of occurrence to form timed traces. One automaton, A, safely implements another automaton, B, if the set of (timed) traces of A is included in that of B. The papers <ref> [6, 13, 5] </ref> present a collection of simulation proof techniques (refinement mappings, forward and backward simulations, etc.) for showing that one (timed) automaton safely implements another. Each of these techniques involves describing a relation between the states of an implementation automaton and those of a specification automaton.
Reference: 7. <author> S. S. Lam and A. U. Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Transactions on Software Engeneering, </journal> <volume> 10(4), </volume> <year> 1984. </year>
Reference: 8. <author> B. Lampson, N. Lynch, and J. Stgaard-Andersen. </author> <title> Reliable at-most-once message delivery protocols. </title> <type> Technical report, </type> <institution> MIT, Laboratory for Computer Science, </institution> <year> 1993. </year> <note> Full report. </note>
Reference-contexts: Our intention with this paper is to give an overview of our work and to convey our experiences with specifying and verifying practical communication protocols. For this reason we have left out many formal details. We refer to our full report <ref> [8] </ref> for such details. The full report also contains an exhaustive treatment of liveness properties of the protocols. The rest of the paper is organized as follows. We start in Section 2 by giving an introduction to our model. <p> CORRECTNESS PROOFS In this section we sketch the proofs of safe implementation for the different levels of abstraction in our work. We will not be strictly formal. For such formal treatment and full proofs we refer to our full report <ref> [8] </ref>. 6.1. Correctness of G To prove that G is a safe implementation of S, we need a backward simulation. <p> If current-ok = true ^ mode s = needid then good s good r . The proof that G safely implements D is now discharged by exhibiting a refinement mapping from G to D. Again, we do not give details, but refer to <ref> [8] </ref> for the complete proofs. Together, the existence of the backward simulation from D to S and the refinement mapping from G to D allow us to conclude that G safely implements S. 6.2.
Reference: 9. <author> B. Liskov. </author> <title> Practical uses of synchronized clocks in distributed systems. </title> <booktitle> In Proceedings of the Tenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-10, </pages> <year> 1991. </year>
Reference-contexts: It is sometimes called the three-way handshake, because only three packets are needed for message delivery; the additional packets are required for acknowledgement and cleaning up the state. The former protocol was developed as an example to show the usefulness of clocks in network protocols <ref> [9] </ref> and has been implemented at M.I.T. Both protocols are sufficiently complicated that formal specification and proof seems useful. The basic model we use is based on the (timed ) automaton model of Lynch and Vaandrager [13] with an extra added component to express liveness [5].
Reference: 10. <author> B. Liskov, L. Shrira, and J. Wroclawski. </author> <title> Efficient at-most-once messages based on synchronized clocks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 125-142, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: A desirable property, which is not directly related to correctness, is that the implementations offer a way of cleaning up "old" information when this cannot affect the future behavior. In this work, we consider two protocols that are important in practice: the clock-based protocol of Liskov, Shrira and Wroclawski <ref> [10] </ref> and the five-packet handshake protocol of Belsnes [3]. The latter is the standard protocol for setting up network connections, used in TCP, ISO TP-4, and many other transport protocols.
Reference: 11. <author> N. Lynch and M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <type> Technical Report MIT/LCS/TR-387, </type> <institution> MIT, Laboratory for Computer Science, </institution> <address> Cambridge, MA, 02139, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: Finally, we give concluding remarks in Section 7. 2. THE UNDERLYING THEORY The general model we use to specify safety and timing properties at all levels of abstraction is based on the (timed ) automaton model of [5, 13] and the I/O automaton model of <ref> [11, 12] </ref>. An automaton is a state machine with named actions associated with its transitions. Thus, an automaton consists of * a (possibly infinite) set of states. <p> A recover action, at the side where the crash occurred, then signals the end of the recovery phase, after which no messages can be lost unless new crashes occur. The following code describes the specification S in a simple precondition-effect style commonly used for I/O-automata protocols <ref> [11, 12] </ref>.
Reference: 12. <author> N. Lynch and M. Tuttle. </author> <title> An introduction to Input/Output automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Finally, we give concluding remarks in Section 7. 2. THE UNDERLYING THEORY The general model we use to specify safety and timing properties at all levels of abstraction is based on the (timed ) automaton model of [5, 13] and the I/O automaton model of <ref> [11, 12] </ref>. An automaton is a state machine with named actions associated with its transitions. Thus, an automaton consists of * a (possibly infinite) set of states. <p> A recover action, at the side where the crash occurred, then signals the end of the recovery phase, after which no messages can be lost unless new crashes occur. The following code describes the specification S in a simple precondition-effect style commonly used for I/O-automata protocols <ref> [11, 12] </ref>.
Reference: 13. <author> N. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In J. W. de Dakker, C. Huizing, and G. Rozenberg, editors, </editor> <booktitle> Proceedings of REX Workshop "Real-Time: Theory in Practice", Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1991, </year> <booktitle> number 600 in Lecture Notes in Computer Science, </booktitle> <pages> pages 397-446. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Recent advances include the development of formal models that allow reasoning about timed systems as well as untimed systems, e.g., <ref> [2, 5, 13] </ref>, and the development of simulation techniques (including refinement mappings and forward and backward simulations) for proving that one protocol implements another, e.g., [1, 5-7, 13]. <p> Recent advances include the development of formal models that allow reasoning about timed systems as well as untimed systems, e.g., [2, 5, 13], and the development of simulation techniques (including refinement mappings and forward and backward simulations) for proving that one protocol implements another, e.g., <ref> [1, 5-7, 13] </ref>. In this paper, we show how these techniques can be used to verify an important class of communication protocols those for at-most-once message delivery. <p> Both protocols are sufficiently complicated that formal specification and proof seems useful. The basic model we use is based on the (timed ) automaton model of Lynch and Vaandrager <ref> [13] </ref> with an extra added component to express liveness [5]. We express both protocols, as well as the formal specification of the at-most-once message delivery problem, in terms of this model. In the project we carry out complete correctness proofs for both protocols. <p> In doing so we present the delayed-decision specification D. Finally, we give concluding remarks in Section 7. 2. THE UNDERLYING THEORY The general model we use to specify safety and timing properties at all levels of abstraction is based on the (timed ) automaton model of <ref> [5, 13] </ref> and the I/O automaton model of [11, 12]. An automaton is a state machine with named actions associated with its transitions. Thus, an automaton consists of * a (possibly infinite) set of states. <p> In timed systems these actions are furthermore paired with their time of occurrence to form timed traces. One automaton, A, safely implements another automaton, B, if the set of (timed) traces of A is included in that of B. The papers <ref> [6, 13, 5] </ref> present a collection of simulation proof techniques (refinement mappings, forward and backward simulations, etc.) for showing that one (timed) automaton safely implements another. Each of these techniques involves describing a relation between the states of an implementation automaton and those of a specification automaton.
Reference: 14. <author> Eric Madelaine and Didier Vergamini. </author> <title> Specification and verification of a sliding window protocol in LOTOS. </title> <editor> In K. R. Parker and G. A. Rose, editors, </editor> <booktitle> Formal Description Techniques, IV, </booktitle> <pages> pages 495-510. </pages> <publisher> North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: We believe that this work yields important insights into the protocols, and also serves to show the adequacy of the model and proof techniques. Similar protocols have been verified formally, using different techniques. LOTOS has, for instance, been used in <ref> [14] </ref>. There is a considerable amount of further work remaining.
Reference: 15. <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time-constrained automata. </title> <booktitle> In Proceedings of CONCUR'91. 2nd International Conference on Concurrency Theory, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1991, </year> <booktitle> number 527 in Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We have aligned the send pkt and corresponding receive pkt actions to increase readability. We treat timing requirements implicitly by giving upper time bounds on certain classes of actions. This corresponds to the way timing requirements are specified in <ref> [15] </ref>.
Reference: 16. <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Infor-matica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: The main distinction between forward and backward simulations, which are abstract representations of history <ref> [16] </ref> and prophecy [1] variables, respectively, lies in the way these corresponding sequences of steps of the specification are found given a step of the implementation: in a forward simulation it must be shown that from each state of the specification which is related to the pre-state of the step of <p> We only consider C. The first step, a technical one, in the correctness proof involves adding a history variable <ref> [16] </ref> deadline to C to get an equivalent version of the protocol (which we still call C).
Reference: 17. <author> A. U. Shankar. </author> <title> Verified data transfer protocols with variable flow control. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 281-316, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Second, there are other algorithms that solve the at-most-once message delivery problem, for example, using bounded identifier spaces or cryptographic assumptions. We would like also to verify these, again reusing as much of our proofs as possible. In <ref> [17] </ref> bounded identifier spaces are dealt with for similar protocols. Third, we would like to automate our simulation proofs using a mechanical theorem prover. We have already begun this work, by proving the equivalence of versions of S and D using the Larch Prover [18, 4].
Reference: 18. <author> Jtrgen F. Stgaard-Andersen, Stephen J. Garland, John V. Guttag, Nancy A. Lynch, and Anna Pogosyants. </author> <title> Computer-assisted simulation proofs. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification. 5th International Conference, CAV '93. Elounda, Greece, June/July 1993, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 305-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In [17] bounded identifier spaces are dealt with for similar protocols. Third, we would like to automate our simulation proofs using a mechanical theorem prover. We have already begun this work, by proving the equivalence of versions of S and D using the Larch Prover <ref> [18, 4] </ref>. We have been pleased with the preliminary results: the prover has not only been able to check our hand proofs, but in fact has been able to fill in many of the details.
References-found: 18

