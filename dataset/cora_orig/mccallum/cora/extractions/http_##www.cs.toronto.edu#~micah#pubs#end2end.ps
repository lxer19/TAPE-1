URL: http://www.cs.toronto.edu/~micah/pubs/end2end.ps
Refering-URL: http://www.cs.toronto.edu/~micah/pubs/pubs.html
Root-URL: http://www.cs.toronto.edu
Title: The Complexity of End-to-End Communication in Memoryless Networks  
Author: Micah Adler and Faith Fich 
Address: Toronto, Ontario CANADA M5S 3G4  
Affiliation: Department of Computer Science University of Toronto  
Abstract: Two problems are studied: sending a single message through a network and sending a stream of messages through a network. We provide lower bounds and upper bounds on the size of the headers needed to transmit information from the sender S to the receiver R. We prove that, for the complete network of n processors or any network that contains it as a minor (such as the n 2 input butterfly), headers of length (log n) are necessary to ensure delivery of one message, without ever generating an infinite amount of packet traffic. This lower bound holds even if only static link faults are allowed. It also matches the upper bound achieved by the simple "hop count" protocol that uses packet headers to count the number of hops packets have traveled. For other network topologies, we develop new protocols that use substantially smaller headers. For example, if the network has a known feedback vertex set of size f, then headers of length dlog 2 (f + 1)e suffice. For the sequence transmission problem, we prove lower bounds as a function of the network topology, implying, for example, that fixed degree meshes with n nodes and the complete graph on n nodes require headers of length (n) and (n log n), respectively. In many cases, including these graphs and all series parallel graphs, our lower bounds match the upper bounds achieved by Dolev and Welch's bounded sequence number protocol. 
Abstract-found: 1
Intro-found: 1
Reference: [AAF+94] <author> Afek, Attiya, Fekete, Fischer, Lynch, Man-sour, Wang, and Zuck, </author> <title> Reliable Communication Over Unreliable Channels, </title> <journal> JACM, </journal> <volume> vol. 41, no. 6, </volume> <year> 1994, </year> <pages> pages 1267-1297. </pages>
Reference-contexts: Moreover, any protocol that tolerates arbitrary packet reordering and duplication requires unbounded sequence numbers [WZ89]. Similarly, any protocol that tolerates both packet reordering and loss requires either unbounded sequence numbers or requires that R receive an unbounded number of packets per message <ref> [AAF+94] </ref>. For arbitrary networks, it is possible to send a stream of messages by attaching sequence numbers to the packets sent by S [V83, AE86, AAG87]. Each intermediate processor remembers the largest sequence number it has seen and only forwards a packet containing the next higher number. <p> Instead of using sequence numbers, there are algorithms in which S sends a rapidly increasing number of packets for each successive message it wants to send to R <ref> [AAF+94] </ref>. Processor R determines when it has a new message by keeping track of the number of copies of each different packet it has received.
Reference: [AAG87] <author> Afek, Awerbuch, and Gafni, </author> <title> Applying Static Network Protocols to Dynamic Networks, </title> <booktitle> 28th FOCS, </booktitle> <year> 1987, </year> <pages> pages 358-370. </pages>
Reference-contexts: For arbitrary networks, it is possible to send a stream of messages by attaching sequence numbers to the packets sent by S <ref> [V83, AE86, AAG87] </ref>. Each intermediate processor remembers the largest sequence number it has seen and only forwards a packet containing the next higher number.
Reference: [AAG+97] <author> Afek, Awerbuch, Gafni, Mansour, Rosen, and Shavit, </author> <title> Slide-The Key to Polynomial End-to-End Communication, </title> <journal> Journal of Algorithms, </journal> <volume> vol. 22, no. 1, </volume> <year> 1997, </year> <pages> pages 158-186. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network. <p> If one assumes that each individual link delivers packets in order and without duplication, then this restricts the possible reorderings and duplications that the network as a whole (if viewed as a virtual link) can produce. Protocols for arbitrary networks can take advantage of this. There are sophisticated algorithms <ref> [AG91, AAG+97, KOR95] </ref> that use no header bits and perform only a polynomial (in n) amount of communication for each message. However, processors must store packets and auxiliary information (using space bounded by a logarithmic or polynomial function of n) for each of their incident links.
Reference: [AG88] <author> Afek and Gafni, </author> <title> End-to End Communication in Unreliable Networks, </title> <booktitle> 7th PODC, </booktitle> <year> 1988, </year> <pages> pages 131-148. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network. <p> Although these protocols do not handle packet losses, they can be adapted to the dynamic model by performing the alternating bit protocol along each link and using buffers at each node to hold any packet that might not yet have been successfully transmitted along some incident link <ref> [AG88] </ref>. If no packet losses, duplications or reorderings occur on any link of the network (but operational links can become inoperational), then a stream of messages can be sent without using memory at internal processors by treating each simple S-R path separately.
Reference: [AG91] <author> Afek and Gafni, </author> <title> Bootstrap Network Resynchro-nization, </title> <booktitle> 10th PODC, </booktitle> <year> 1991, </year> <pages> pages 295-307. </pages>
Reference-contexts: If one assumes that each individual link delivers packets in order and without duplication, then this restricts the possible reorderings and duplications that the network as a whole (if viewed as a virtual link) can produce. Protocols for arbitrary networks can take advantage of this. There are sophisticated algorithms <ref> [AG91, AAG+97, KOR95] </ref> that use no header bits and perform only a polynomial (in n) amount of communication for each message. However, processors must store packets and auxiliary information (using space bounded by a logarithmic or polynomial function of n) for each of their incident links.
Reference: [AE86] <author> Awerbuch and Even, </author> <title> Reliable Broadcast Protocols in Unreliable Networks, </title> <journal> Networks, </journal> <volume> 16, </volume> <year> 1986, </year> <pages> pages 381-396. </pages>
Reference-contexts: For this network, the straightforward scheme in which S uses sequence numbers as packet headers and R sends the sequence numbers back as acknowledgment is sufficient to ensure reliable delivery of a sequence of messages, while tolerating packet loss, duplication and reordering on the link <ref> [S76, V83, AE86] </ref>. Unfortunately, the length of packet headers grows without bound. The alternating bit protocol [BSW69, LLT98] uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers [FL90]. <p> For arbitrary networks, it is possible to send a stream of messages by attaching sequence numbers to the packets sent by S <ref> [V83, AE86, AAG87] </ref>. Each intermediate processor remembers the largest sequence number it has seen and only forwards a packet containing the next higher number.
Reference: [AGH90] <author> Awerbuch, Goldreich, and Herzberg, </author> <title> A Quantitative Approach to Dynamic Networks, </title> <booktitle> 9th PODC, </booktitle> <year> 1990, </year> <pages> 189-203. </pages>
Reference-contexts: Clearly, if there is a permanent S-R cut of inoperational links, then it is not possible to send messages from S to R. Thus, assumptions regarding the behavior of faulty links are necessary. Here, we assume infinitely frequent path stability <ref> [AGH90, H92] </ref>: infinitely often there is some path P from S to R, such that a packet sent from S along path P will arrive at R. 1.2 Our results In this paper, we consider two problems: sending a single message from S to R and sending an infinite sequence of
Reference: [AMS89] <author> Awerbuch, Mansour, and Shavit, </author> <title> Polynomial End to End Communication, </title> <booktitle> 30th FOCS, </booktitle> <year> 1989, </year> <pages> pages 358-363. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network.
Reference: [APV96] <author> Awerbuch, Patt-Shamir, and Varghese, </author> <title> Self-stabilizing End-to-End Communication, </title> <journal> Journal of High Speed Networks, </journal> <volume> vol. 5, no. 4, </volume> <year> 1996, </year> <pages> pages 365-381. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network.
Reference: [BSW69] <author> Bartlett, Scantleburg, and Wilkinson, </author> <title> A Note on Reliable, Full-Duplex Transmission over Half-Duplex Links, </title> <journal> CACM, </journal> <volume> vol. 12, </volume> <year> 1969, </year> <pages> pages 260-261. </pages>
Reference-contexts: Unfortunately, the length of packet headers grows without bound. The alternating bit protocol <ref> [BSW69, LLT98] </ref> uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers [FL90]. Moreover, any protocol that tolerates arbitrary packet reordering and duplication requires unbounded sequence numbers [WZ89].
Reference: [DW97] <author> Dolev and Welch, </author> <title> Crash Relient Communication in Dynamic Networks, </title> <journal> IEEE Transactions of Computers, </journal> <volume> vol. 46, </volume> <year> 1997, </year> <pages> pages 14-26. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network. <p> We prove lower bounds for this problem in the dynamic fault model as a function of the network topology. For many networks, including the complete graph, series parallel graphs, and finite degree meshes, our resulting lower bounds match an upper bound by Dolev and Welch <ref> [DW97] </ref>, showing that their protocol is optimal. For the sequence transmission lower bounds, we provide two different proofs that make incomparable assumptions about the computation performed by S and R. <p> One problem with this protocol is that R uses an unbounded amount of memory. Dolev and Welch <ref> [DW97] </ref> combine this approach with bounded sequence numbers to obtain a protocol with O (log p) bit headers that uses O (log p) bits of storage at R and O (p log p) bits of storage at S. <p> These lower bounds match, to within a constant factor, the O (log (number of simple S-R paths)) upper bounds shown by Dolev and Welch <ref> [DW97] </ref>. Also, as in the single message case, lower bounds for a particular graph extend to all graphs that contain it as a minor.
Reference: [FL90] <author> Fekete and Lynch, </author> <title> The Need for Headers: An Impossibility Result for Communication over Unreliable Channels, </title> <booktitle> CONCUR '90, Lecture Notes in Computer Science, </booktitle> <volume> vol. 458, </volume> <publisher> Springer-Verlag, </publisher> <year> 1990, </year> <pages> pages 199-215. </pages>
Reference-contexts: Unfortunately, the length of packet headers grows without bound. The alternating bit protocol [BSW69, LLT98] uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers <ref> [FL90] </ref>. Moreover, any protocol that tolerates arbitrary packet reordering and duplication requires unbounded sequence numbers [WZ89]. Similarly, any protocol that tolerates both packet reordering and loss requires either unbounded sequence numbers or requires that R receive an unbounded number of packets per message [AAF+94].
Reference: [F98] <author> Fich, </author> <title> End-to-end Communication, </title> <booktitle> Proceedings of 2nd OPODIS, </booktitle> <address> Amiens, France, </address> <year> 1998, </year> <pages> pages 37-43. </pages>
Reference-contexts: By incorporating a version of the alternating bit protocol along each path, the protocol can also tolerate packet losses. More detail concerning related work can be found in the survey article <ref> [F98] </ref>. 3 Reliable Delivery of One Message In this section we provide lower and upper bounds for the delivery of a single message. Our lower bounds are proven in the static fault model and, thus, also apply to the dynamic fault model.
Reference: [H92] <author> Herzberg, </author> <title> Connection-Based Communication in Dynamic Networks, </title> <booktitle> 11th PODC, </booktitle> <year> 1992, </year> <pages> pages 13-24. </pages>
Reference-contexts: Clearly, if there is a permanent S-R cut of inoperational links, then it is not possible to send messages from S to R. Thus, assumptions regarding the behavior of faulty links are necessary. Here, we assume infinitely frequent path stability <ref> [AGH90, H92] </ref>: infinitely often there is some path P from S to R, such that a packet sent from S along path P will arrive at R. 1.2 Our results In this paper, we consider two problems: sending a single message from S to R and sending an infinite sequence of
Reference: [K30] <author> Kuratowski, </author> <title> Sur le Probleme des Courbes Gauches en Topologie, </title> <journal> Fund. Math., </journal> <volume> vol. 15, </volume> <year> 1930, </year> <pages> pages 271-283. </pages>
Reference-contexts: Also, for the butterfly and the mesh graphs mentioned above, we are within a small constant multiplicative factor of the "hop count" algorithm. However, any planar graph, including the 2-dimensional mesh, does not contain the complete graph on 5 nodes as a minor <ref> [K30] </ref>. Hence, other techniques are needed to prove lower bounds for such networks. 3.2 Upper Bounds There is a simple improvement to the "hop count" algorithm based on the observation that, for any feedback vertex set F , any simple path visits vertices in F at most jF j times.
Reference: [KOR95] <author> Kushilevitz, Ostrovsky, and Rosen, </author> <title> Log-Space Polynomial End-to-End Communication, </title> <booktitle> 28th STOC, </booktitle> <year> 1995, </year> <pages> pages 559-568. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network. <p> If one assumes that each individual link delivers packets in order and without duplication, then this restricts the possible reorderings and duplications that the network as a whole (if viewed as a virtual link) can produce. Protocols for arbitrary networks can take advantage of this. There are sophisticated algorithms <ref> [AG91, AAG+97, KOR95] </ref> that use no header bits and perform only a polynomial (in n) amount of communication for each message. However, processors must store packets and auxiliary information (using space bounded by a logarithmic or polynomial function of n) for each of their incident links.
Reference: [LLT98] <author> Ladner, LaMarca, and Tempero, </author> <title> Counting Protocols for Reliable End-to-End Transmission, </title> <journal> JCSS, </journal> <volume> vol. 56, no. 1, </volume> <year> 1998, </year> <pages> pages 96-111. </pages>
Reference-contexts: Essentially, a good protocol for end-to-end communication allows distributed algorithms to treat an unreliable network as a reliable channel. Many different protocols for end-to-end communication have been developed when links and/or intermediate processors may fail, either by losing messages, or by ceasing to transmit any information <ref> [AAG+97, AG88, AMS89, APV96, DW97, KOR95, LLT98] </ref>. Their performance is measured in terms of the amount of communication performed over the links of the network and the amount of storage space used by intermediate nodes of the network. <p> Unfortunately, the length of packet headers grows without bound. The alternating bit protocol <ref> [BSW69, LLT98] </ref> uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers [FL90]. Moreover, any protocol that tolerates arbitrary packet reordering and duplication requires unbounded sequence numbers [WZ89].
Reference: [L92] <author> Leighton, </author> <title> Introduction to Parallel Algorithms and Architectures, </title> <publisher> Morgan Kaugmann, </publisher> <year> 1992. </year>
Reference-contexts: Thus, the 2 2k (2k + 1)-node butterfly requires headers of size k 3 to ensure correct delivery. We can also demonstrate comparable results for other hypercubic networks, such as the hypercube, the shu*e-exchange graph, the de Bruijn graph, and the cube connected cycles graph. See <ref> [L92] </ref> for descriptions of these networks. Note that, for the complete graph, we are within an additive constant of 3 of the upper bound obtained by counting the number of steps the packet has taken. <p> For the (4r + 2) fi k mesh, we see that we have the 2 fi m mesh as a minor, for m = (2r + 1)(k 2) + 1. This mesh appears in a "snakelike" ordering (e.g., see <ref> [L92] </ref>, page 144) in the original mesh.
Reference: [P81] <author> Postel, </author> <title> Internet Protocol, Network Working Group Request for Comments 791, </title> <month> September </month> <year> 1981. </year>
Reference-contexts: For these networks, the lower bound matches the upper bound achieved by a simple protocol that uses packet headers to keep track of the number of hops packets have traveled <ref> [P81] </ref>. This protocol applies to both the static failure model, as well as the dynamic failure model. For other network topologies, we develop new protocols that can be adapted to both fault models, and use substantially smaller headers. <p> Thus, it suffices to use packet headers that count the number of intermediate processors the packet has passed through (including duplicate visits) <ref> [P81] </ref>. To send a message to R, processor S sends a packet with header 0 and the message to each of its neighbors.
Reference: [S76] <author> Stenning, </author> <title> A Data Transfer Protocol, </title> <journal> Computer Net., </journal> <volume> vol. 1, </volume> <year> 1976, </year> <pages> pages 99-110. </pages>
Reference-contexts: For this network, the straightforward scheme in which S uses sequence numbers as packet headers and R sends the sequence numbers back as acknowledgment is sufficient to ensure reliable delivery of a sequence of messages, while tolerating packet loss, duplication and reordering on the link <ref> [S76, V83, AE86] </ref>. Unfortunately, the length of packet headers grows without bound. The alternating bit protocol [BSW69, LLT98] uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers [FL90].
Reference: [V83] <author> Vishkin, </author> <title> A Distributed Orientation Algorithm, </title> <journal> IEEE Trans. on Information Theory, </journal> <volume> vol. 29, </volume> <year> 1983. </year>
Reference-contexts: For this network, the straightforward scheme in which S uses sequence numbers as packet headers and R sends the sequence numbers back as acknowledgment is sufficient to ensure reliable delivery of a sequence of messages, while tolerating packet loss, duplication and reordering on the link <ref> [S76, V83, AE86] </ref>. Unfortunately, the length of packet headers grows without bound. The alternating bit protocol [BSW69, LLT98] uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers [FL90]. <p> For arbitrary networks, it is possible to send a stream of messages by attaching sequence numbers to the packets sent by S <ref> [V83, AE86, AAG87] </ref>. Each intermediate processor remembers the largest sequence number it has seen and only forwards a packet containing the next higher number.
Reference: [WZ89] <author> Wang and Zuck, </author> <title> Tight Bounds for the Sequence Transmission Problem, </title> <booktitle> 8th PODC, </booktitle> <year> 1989, </year> <pages> pages 73-83. </pages>
Reference-contexts: The alternating bit protocol [BSW69, LLT98] uses single bit headers, but only tolerates packet loss and duplication, not reordering of packets. With message loss, there is no correct protocol without headers [FL90]. Moreover, any protocol that tolerates arbitrary packet reordering and duplication requires unbounded sequence numbers <ref> [WZ89] </ref>. Similarly, any protocol that tolerates both packet reordering and loss requires either unbounded sequence numbers or requires that R receive an unbounded number of packets per message [AAF+94].
References-found: 22

