URL: http://polaris.cs.uiuc.edu/reports/1245.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Email: [llchen|harrison]@csrd.uiuc.edu  
Title: Efficient Computation of Fixpoints that Arise in Complex Program Analysis  
Author: Li-Ling Chen and Williams Ludwell Harrison III 
Address: 1308 West Main Street, Urbana, IL 61801  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: This paper presents an efficient algorithm for solving the fixpoints that arise in complex program analysis based on abstract interpretation. The algorithm behaves like those based upon interval analysis of a flow graph, but without requiring the flow graph to be given a priori. In the general case, the structure of the fix-point computation is not known prior to analysis. In the algorithm, the entailment graph, representing the structure of the fixpoint computation, is developed during analysis; it is precise and thus results in an efficient analysis. The strategies, which underlie the algorithm, for determining the evaluation order are described. Based on these strategies, local knowledge of the entailment graph at each node is exploited to determine dynamically an effective order of evaluations. The algorithm is implemented, and experiments are conducted to compare it to other iterative algorithms for solving such problems. The results show that the algorithm is flexible, efficient, and consistently better than the others. fl This project is supported by Department of Energy under contact DE-FG02-85ER25001
Abstract-found: 1
Intro-found: 1
Reference: [AC76] <author> F.E. Allen and J. Cocke. </author> <title> A Program Data Flow Analysis Procedure. </title> <journal> Communication of ACM, </journal> <volume> 19(3) </volume> <pages> 137-147, </pages> <month> August </month> <year> 1976. </year>
Reference-contexts: Because the relation between the unknowns is given as an input to the problem in the form of the control flow graph, it is possible to solve for the unknowns efficiently. This is the purpose of interval analysis <ref> [AC76] </ref>: to consider the unknowns of the dataflow problem in an order that will allow their final values to be determined most quickly; the order can be obtained by examination of the control flow graph.
Reference: [AH87] <editor> Samson Abramsky and Chris Hankin. </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract interpretation <ref> [CC77, CC79, AH87] </ref> is a powerful and promising framework for constructing program analyses, especially in the presence of difficult language constructs, such as first-class procedures [BHA86] and pointers. In abstract interpretation, we express an analysis problem as the least fixpoint of a semantic functional over abstract domains (see Section 2.1).
Reference: [ASU86] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: There are several methods for solving for a related but simpler class of fixpoint problems efficiently in traditional dataflow analysis. In these problems, monotone functions are associated with the edges of a control flow graph <ref> [ASU86] </ref>. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively [KU76, AU76, HDT87] or by elimination [Tar72, GW76, HU77] until they are stable (that is, until a fixpoint is reached).
Reference: [AU76] <author> A. Aho and J. Ullman. </author> <title> Node listings for reducible flowgraphs. </title> <journal> Journal Computing System Science, </journal> <volume> 13 </volume> <pages> 286-299, </pages> <year> 1976. </year>
Reference-contexts: In these problems, monotone functions are associated with the edges of a control flow graph [ASU86]. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively <ref> [KU76, AU76, HDT87] </ref> or by elimination [Tar72, GW76, HU77] until they are stable (that is, until a fixpoint is reached).
Reference: [BHA86] <author> G.L. Burn, C.L. Hankin, and S. Abramsky. </author> <title> The Theory and practice of strictness analysis for higher order functions. In Programs as Data Objects, </title> <booktitle> Lecture Notes in Computer Science 217, </booktitle> <pages> pages 43-62. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Abstract interpretation [CC77, CC79, AH87] is a powerful and promising framework for constructing program analyses, especially in the presence of difficult language constructs, such as first-class procedures <ref> [BHA86] </ref> and pointers. In abstract interpretation, we express an analysis problem as the least fixpoint of a semantic functional over abstract domains (see Section 2.1). To "solve" the analysis problem to compute the least fixpoint of the associated functional.
Reference: [CC77] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of program by construction or approximation of fix-points. </title> <booktitle> In ACM 4th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Abstract interpretation <ref> [CC77, CC79, AH87] </ref> is a powerful and promising framework for constructing program analyses, especially in the presence of difficult language constructs, such as first-class procedures [BHA86] and pointers. In abstract interpretation, we express an analysis problem as the least fixpoint of a semantic functional over abstract domains (see Section 2.1).
Reference: [CC79] <author> Patrick Cousot and Radhia Cousot. </author> <title> Systematic sesign of program analysis frameworks. </title> <booktitle> In ACM 6th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Abstract interpretation <ref> [CC77, CC79, AH87] </ref> is a powerful and promising framework for constructing program analyses, especially in the presence of difficult language constructs, such as first-class procedures [BHA86] and pointers. In abstract interpretation, we express an analysis problem as the least fixpoint of a semantic functional over abstract domains (see Section 2.1).
Reference: [CJ85] <author> Chris Clack and Simon L. Peyton Jones. </author> <title> Strictness analysis a practical approach. </title> <booktitle> In IFIP Symposium on Functional Programming Languages and Computer Architecture, Lecture Notes in Computer Science 201, </booktitle> <pages> pages 35-49. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In this setting, the methods obtained for dataflow analysis which require the flow graph as a prerequisite are not applicable. Several methods have been proposed for solving the fixpoint problems that arise in abstract interpretation. In particular, the frontiers algorithm presented in <ref> [CJ85, MH87, HH91] </ref> is an efficient means of computing certain least fixpoints. Frontiers are a compact representation of functions over two-point lattices, for example, that of strictness analysis [Myc81]. Using frontiers, it is easy to compare two functions for equality to determine if a fixpoint is reached.
Reference: [ea88] <author> W. T. Vertterling et al. </author> <title> Numerical Recipes: Example Book (C). </title> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: A detailed description of a similar analysis for Scheme programs is given in [Har89]. The test programs|matmul (matrix multiplication), gauss (Gauss elimination), simplex, and amoeba, are widely used numerical programs. The programs, gauss, simplex, and amoeba are examples from a book of numerical recipe <ref> [ea88] </ref>.
Reference: [et al89] <author> M. Berry et al. </author> <title> The perfect club benchmarks: Effective performance evaluation of supercomputers. </title> <journal> Int'l. Journal of Supercomputer Application, </journal> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The test programs|matmul (matrix multiplication), gauss (Gauss elimination), simplex, and amoeba, are widely used numerical programs. The programs, gauss, simplex, and amoeba are examples from a book of numerical recipe [ea88]. TIS is a program from the Perfect Benchmarks <ref> [et al89] </ref>. testme and nonlin1 are our simple test programs. 29 5.2 Performance The algorithm that we compare are: the algorithm that choose a node randomly from the worklist, the algorithm using a LIFO (depth-first) ordering, the "leading nodes first" algorithm, and the "least recently evaluated" algorithm that chooses a node
Reference: [GW76] <author> Susan L. Graham and Mark Wegman. </author> <title> A fast and usually linear algorithm for global flow analysis. </title> <journal> JACM, </journal> <volume> 23(1) </volume> <pages> 172-202, </pages> <month> January </month> <year> 1976. </year> <month> 33 </month>
Reference-contexts: In these problems, monotone functions are associated with the edges of a control flow graph [ASU86]. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively [KU76, AU76, HDT87] or by elimination <ref> [Tar72, GW76, HU77] </ref> until they are stable (that is, until a fixpoint is reached). Because the relation between the unknowns is given as an input to the problem in the form of the control flow graph, it is possible to solve for the unknowns efficiently.
Reference: [HA92] <author> W. L. Harrison III and Zahira Ammarguellat. </author> <title> A program's eye view of Miprac. </title> <booktitle> In 5th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 339-354, </pages> <year> 1992. </year> <month> YALEU/DCS/RR-915. </month>
Reference-contexts: Experiments are conducted to verify that the algorithm is efficient, flexible, and consistently better than the others. This work was motivated by the abstract interpretation used in MIPRAC <ref> [HA92] </ref>. MIPRAC analyzes and compiles an intermediate language, called MIL, which includes first-class procedures, dynamic allocation, and unrestricted pointer manipulation. The compiler performs whole-program analysis of the intermediate form by abstract interpretation. The rest of the paper is organized as follows. <p> Results and Discussion We have conducted experiments to compare the performance of the guided-entailment method with that of other iterative algorithms. 5.1 Program Analyses and Test Programs The analysis we have experimented with is the interprocedural analysis of side-effects, object lifetimes and the dependence analysis performed by the MIPRAC compiler <ref> [HA92] </ref>. This analysis is a complex abstract interpretation of programs in the intermediate language MIL. MIPRAC translates C, Fortran and Lisp programs into MIL prior to analyzing and compiling them. MIL provides first-class procedures and memory pointers. Therefore these program analyses are complicated and thus time-consuming.
Reference: [Har89] <author> Williams Ludwell Harrison III. </author> <title> The interprocedural analysis and automatic par-allelization of scheme programs. Lisp and Symbolic Computation: </title> <journal> An International Journal, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: MIPRAC translates C, Fortran and Lisp programs into MIL prior to analyzing and compiling them. MIL provides first-class procedures and memory pointers. Therefore these program analyses are complicated and thus time-consuming. A detailed description of a similar analysis for Scheme programs is given in <ref> [Har89] </ref>. The test programs|matmul (matrix multiplication), gauss (Gauss elimination), simplex, and amoeba, are widely used numerical programs. The programs, gauss, simplex, and amoeba are examples from a book of numerical recipe [ea88].
Reference: [HDT87] <author> S. Horwitz, A. Demers, and T. Teitelbaum. </author> <title> An efficient general iterative algorithm for dataflow analysis. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 679-694, </pages> <year> 1987. </year>
Reference-contexts: In these problems, monotone functions are associated with the edges of a control flow graph [ASU86]. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively <ref> [KU76, AU76, HDT87] </ref> or by elimination [Tar72, GW76, HU77] until they are stable (that is, until a fixpoint is reached).
Reference: [HH91] <author> Sebastian Hunt and Chris Hankin. </author> <title> Fixed Points and Frontiers: A New Perspective. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 91-120, </pages> <year> 1991. </year>
Reference-contexts: In this setting, the methods obtained for dataflow analysis which require the flow graph as a prerequisite are not applicable. Several methods have been proposed for solving the fixpoint problems that arise in abstract interpretation. In particular, the frontiers algorithm presented in <ref> [CJ85, MH87, HH91] </ref> is an efficient means of computing certain least fixpoints. Frontiers are a compact representation of functions over two-point lattices, for example, that of strictness analysis [Myc81]. Using frontiers, it is easy to compare two functions for equality to determine if a fixpoint is reached.
Reference: [HU77] <author> M. S. Hetch and J. D. Ullman. </author> <title> A simple algorithm for global dataflow problmes. </title> <journal> SIAM Journal of Computing, </journal> <volume> 4(4) </volume> <pages> 519-532, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: In these problems, monotone functions are associated with the edges of a control flow graph [ASU86]. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively [KU76, AU76, HDT87] or by elimination <ref> [Tar72, GW76, HU77] </ref> until they are stable (that is, until a fixpoint is reached). Because the relation between the unknowns is given as an input to the problem in the form of the control flow graph, it is possible to solve for the unknowns efficiently.
Reference: [JM86] <author> Neil Jones and Alan Mycroft. </author> <title> Data flow analysis of applicative programs using minimal function graphs: abridged version. </title> <booktitle> In ACM 13th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 296-306, </pages> <year> 1986. </year>
Reference-contexts: A node is evaluated only when it is ready to be; that is, when the values of nodes on which it is dependent are available. It takes advantage of the principles of minimal function graph presented in <ref> [JM86] </ref> and dynamic ordering based on the local knowledge of the 3 entailment graph to minimize redundant work. Experiments are conducted to verify that the algorithm is efficient, flexible, and consistently better than the others. This work was motivated by the abstract interpretation used in MIPRAC [HA92]. <p> Only those nodes related, directly or indirectly, to the start node, x 0 2 X, need to be represented in the resulting fixpoint, if we are interested only in the states that can arise from a particular (abstract) starting condition. This is the concept of a minimal function graph <ref> [JM86] </ref>. It is no accident that the relationship of the elements in X resembles a flow graph (see Section 2.2). We will define the relationship, which we call entailment, and the least fixpoint based on this relation.
Reference: [KU76] <author> John B. Kan and Jeffrey D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of ACM, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: In these problems, monotone functions are associated with the edges of a control flow graph [ASU86]. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively <ref> [KU76, AU76, HDT87] </ref> or by elimination [Tar72, GW76, HU77] until they are stable (that is, until a fixpoint is reached).
Reference: [MH87] <author> Chris Martin and Chris Hankin. </author> <title> Finding fixed points in finite lattices. </title> <booktitle> In Proc. 3rd International Conf. on Functional Programming Languages and Computer Architecture, Lecture Notes in Computer Science 274, </booktitle> <pages> pages 426-445. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In this setting, the methods obtained for dataflow analysis which require the flow graph as a prerequisite are not applicable. Several methods have been proposed for solving the fixpoint problems that arise in abstract interpretation. In particular, the frontiers algorithm presented in <ref> [CJ85, MH87, HH91] </ref> is an efficient means of computing certain least fixpoints. Frontiers are a compact representation of functions over two-point lattices, for example, that of strictness analysis [Myc81]. Using frontiers, it is easy to compare two functions for equality to determine if a fixpoint is reached.
Reference: [Myc81] <author> Alan Mycroft. </author> <title> Abstract Interpretation and Optimising Transformations for Applicative Programs. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: In particular, the frontiers algorithm presented in [CJ85, MH87, HH91] is an efficient means of computing certain least fixpoints. Frontiers are a compact representation of functions over two-point lattices, for example, that of strictness analysis <ref> [Myc81] </ref>. Using frontiers, it is easy to compare two functions for equality to determine if a fixpoint is reached. However, this algorithm is suitable only for the binary lattice; for general lattices, it is not obvious how to define frontiers.
Reference: [RP86] <author> B. G. Ryder and M. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(3) </volume> <pages> 277-315, </pages> <year> 1986. </year>
Reference-contexts: Application of F to the third approximation will not raise its value, so the least fixpoint is reached. 2 7 2.2 Abstraction Interpretation and Dataflow Analysis A traditional dataflow analysis problem can be formulated as a system of simultaneous equations <ref> [RP86] </ref>. To solve an analysis problem is to solve the set of equations. The computation of the least fixpoint of a semantic functional F in abstract interpretation can also be represented as a system of equations like a dataflow analysis problem.
Reference: [Sch86] <author> D.A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <year> 1986. </year>
Reference-contexts: F is repeatedly applied to the current approximation until it produces an approximation the same as the previous one. That is, 6 F 0 ? = f 0 = x:? Y The approximations F i ? form an Ascending Kleene Chain <ref> [Sch86] </ref>. That is, 8i F i ? v F i+1 ?. If f n = f n+1 , then the least fixpoint f ixF = f n . Example 2 Consider the definedness problem in Example 1.
Reference: [Tar72] <author> R. E. Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 2(1) </volume> <pages> 146-159, </pages> <year> 1972. </year> <month> 34 </month>
Reference-contexts: In these problems, monotone functions are associated with the edges of a control flow graph [ASU86]. These functions are initially unknown; they are the variables to be solved for in the dataflow problem. They are given an initial value and are computed iteratively [KU76, AU76, HDT87] or by elimination <ref> [Tar72, GW76, HU77] </ref> until they are stable (that is, until a fixpoint is reached). Because the relation between the unknowns is given as an input to the problem in the form of the control flow graph, it is possible to solve for the unknowns efficiently.
References-found: 23

