URL: http://www.win.tue.nl/cs/pa/janz/yarrow/report.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/janz/yarrow/liter.html
Root-URL: http://www.win.tue.nl
Title: A Graphical User Interface for the Proof Assistant Yarrow  
Author: Eric Raijmakers 
Degree: Supervisor: dr. ir. Kees Hemerik Advisor: drs. Jan Zwanenburg  
Date: august, 1997  
Affiliation: Eindhoven University of Technology Department of Mathematics and Computing Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jan Zwanenburg. </author> <title> The Yarrow homepage. </title> <institution> Eindhoven University of Technology. </institution> <note> HTTP://www.win.tue.nl/win/cs/pa/janz/index.html </note>
Reference-contexts: With a simple session with the program I will illustrate the use of the textual interface. Also, several disadvantages of that interface are described here, to give an idea why a graphical user interface will be implemented. 1.1 Textual Yarrow and its Interface Yarrow (see <ref> [1] </ref>) is a proof assistant. This means that it aids the user in constructing a formal proof of a certain lemma. Yarrow is in fact an implementation of Pure Type Systems (see [2]) extended with Definitions (see [3]). <p> If any of these imported modules has changed since it was included in the import list, the context defined in name will be type-checked again, to ensure consistency. For more precise information about Textual Yarrow 1 see <ref> [1] </ref>. For an example session with this program see appendix A. 1.2 Disadvantages of Textual Yarrow In Textual Yarrow, the user types a command (a string) in the same window in which the program puts its output.
Reference: [2] <author> Henk Barendregt. </author> <title> Lambda Calculi with Types. In D.M. </title> <editor> Gabbai, S. Abramsky, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: This means that it aids the user in constructing a formal proof of a certain lemma. Yarrow is in fact an implementation of Pure Type Systems (see <ref> [2] </ref>) extended with Definitions (see [3]). The fact that Yarrow is an implementation of Pure Type Systems implies that theorems and proofs are "coded" in typed lambda terms. One of the most important aspects of the program is the fact that it has two Modes.
Reference: [3] <author> Paula Severi and Erik Poll. </author> <title> Pure Type Systems with Definitions. </title> <note> Computing Science Note 93/24. </note> <institution> Eindhoven University of Technology. </institution>
Reference-contexts: This means that it aids the user in constructing a formal proof of a certain lemma. Yarrow is in fact an implementation of Pure Type Systems (see [2]) extended with Definitions (see <ref> [3] </ref>). The fact that Yarrow is an implementation of Pure Type Systems implies that theorems and proofs are "coded" in typed lambda terms. One of the most important aspects of the program is the fact that it has two Modes.
Reference: [4] <author> Paul Hudak and Joseph H. Fasel. </author> <title> A Gentle Introduction to Haskell. </title> <note> See [7]. </note>
Reference-contexts: Instead it is the task of the user interface to make it as easy as possible for a user to send a command to the Yarrow engine. 2.2 The Programming Environment Yarrow is written in the functional programming language Haskell (see <ref> [4] </ref>, [5], [6] and [7]), which runs on many platforms, like PC's and Unix systems. Haskell has two important properties. First, it is strongly typed (also called typeful). Secondly, it uses lazy evaluation, which means 9 that expressions will be evaluated when their value is needed, but not sooner.
Reference: [5] <author> John Peterson, Kevin Hammond et al. </author> <title> Report on the Programming Language Haskell. A Non-strict, Purely Functional Language. </title> <note> See [7]. </note>
Reference-contexts: Instead it is the task of the user interface to make it as easy as possible for a user to send a command to the Yarrow engine. 2.2 The Programming Environment Yarrow is written in the functional programming language Haskell (see [4], <ref> [5] </ref>, [6] and [7]), which runs on many platforms, like PC's and Unix systems. Haskell has two important properties. First, it is strongly typed (also called typeful). Secondly, it uses lazy evaluation, which means 9 that expressions will be evaluated when their value is needed, but not sooner.
Reference: [6] <author> Kevin Hammond, John Peterson et al. </author> <title> Standard Libraries for the Haskell Programming Language. </title> <note> Version 1.4. April 1997. see [7]. </note>
Reference-contexts: Instead it is the task of the user interface to make it as easy as possible for a user to send a command to the Yarrow engine. 2.2 The Programming Environment Yarrow is written in the functional programming language Haskell (see [4], [5], <ref> [6] </ref> and [7]), which runs on many platforms, like PC's and Unix systems. Haskell has two important properties. First, it is strongly typed (also called typeful). Secondly, it uses lazy evaluation, which means 9 that expressions will be evaluated when their value is needed, but not sooner.
Reference: [7] <institution> The Haskell homepage. </institution> <note> HTTP://haskell.org/ </note>
Reference-contexts: Instead it is the task of the user interface to make it as easy as possible for a user to send a command to the Yarrow engine. 2.2 The Programming Environment Yarrow is written in the functional programming language Haskell (see [4], [5], [6] and <ref> [7] </ref>), which runs on many platforms, like PC's and Unix systems. Haskell has two important properties. First, it is strongly typed (also called typeful). Secondly, it uses lazy evaluation, which means 9 that expressions will be evaluated when their value is needed, but not sooner.
Reference: [8] <institution> The HBC homepage. </institution> <address> HTTP://www.cs.chalmers.se/ augustss/hbc/index.html </address>
Reference-contexts: Haskell has two important properties. First, it is strongly typed (also called typeful). Secondly, it uses lazy evaluation, which means 9 that expressions will be evaluated when their value is needed, but not sooner. The Haskell compiler I use is the compiler HBC, from Chalmers University of Technology (see <ref> [8] </ref>). For the GUI the Fudgets library (see [9]) will be used. This library contains various functions for creating graphical user interfaces in Haskell. In this library the graphical building blocks are called Fudgets (Functional Widgets). For more precise information see chapter 5.
Reference: [9] <author> Magnus Carlsson and Thomas Hallgren. </author> <note> The Fudgets Homepage. HTTP://www.cs.chalmers.se/ComputingScience/Research/Functional/Fudgets/ </note>
Reference-contexts: Secondly, it uses lazy evaluation, which means 9 that expressions will be evaluated when their value is needed, but not sooner. The Haskell compiler I use is the compiler HBC, from Chalmers University of Technology (see [8]). For the GUI the Fudgets library (see <ref> [9] </ref>) will be used. This library contains various functions for creating graphical user interfaces in Haskell. In this library the graphical building blocks are called Fudgets (Functional Widgets). For more precise information see chapter 5. <p> The first one of these will be the Default Task. All Task names will be put in a Pop-up Menu, therefore the Mode Indicator also needs all other Task Window names. The Messages to the Display Bars are simply a couple of a ColorSpec (see <ref> [9] </ref>), indicating the colour of the message, and the message itself. Input Messages A message coming from a Task will be tagged with the identity of the Task. The only part of a Task that will not output anything is the Display Bar.
Reference: [10] <author> A. G. Sutcliffe, </author> <title> Human-Computer Interface Design (second edition). </title> <publisher> MacMillan Press LTD. </publisher> <address> London, </address> <year> 1995. </year>
Reference-contexts: This model proposes three layers: the application layer that carries out the functional processing of the system, the dialogue layer which controls the conversation between user and application and finally the presentation layer that deals with surface level display and input/output (see <ref> [10] </ref>). Yarrow will be changed, so that it can be used within an implementation of the Seeheim Model. In this implementation Yarrow will be the application layer. The user interface will include both the dialogue and the presentation layer. This will also make Yarrow accessible for multiple user interfaces.
Reference: [11] <author> Sun Microsystems, Inc. </author> <title> OPEN LOOK Graphical User Interface Application Style Guidelines. </title> <publisher> Addison-Wesley Publishing Company, Inc. </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: It is based on the method "select-then-operate", as described by Sun Microsystems (see <ref> [11] </ref>). The idea is as follows: First, the user selects an object, which means a variable or a term in this case.
Reference: [12] <author> Magnus Carlsson and Thomas Hallgren. FUDGETS. </author> <title> Graphical User Interfaces and I/O in Lazy Functional Languages. </title> <institution> Chalmers University of Technology. Goteborg, Sweden, </institution> <month> May 18, </month> <year> 1993. </year> <note> See [9]. </note>
Reference-contexts: Most of the text was taken from <ref> [12] </ref> and [13], by Thomas Hallgren and Magnus Carlsson. 5.1 The Fudget Type A fudget is a stream function consuming both high and low level events (input messages) and producing high level and low level commands (output messages).
Reference: [13] <author> Thomas Hallgren and Magnus Carlsson. </author> <title> Programming with Fudgets. </title> <booktitle> in First International Spring School on Advanced Functional Programming Techniques. </booktitle> <institution> Chalmers University of Technology, Goteborg, Sweden, </institution> <month> May </month> <year> 1995. </year> <note> See [9]. </note>
Reference-contexts: Most of the text was taken from [12] and <ref> [13] </ref>, by Thomas Hallgren and Magnus Carlsson. 5.1 The Fudget Type A fudget is a stream function consuming both high and low level events (input messages) and producing high level and low level commands (output messages). The low level events and commands are received and sent via low level connections.
Reference: [14] <author> Philip Wadler. </author> <title> Monads for Functional Programming. In Advanced Functional Programming (J. </title> <editor> Jeuring and E. Meijer, editors). </editor> <booktitle> Proceedings of the Bastad Spring School. </booktitle> <publisher> Springer Verlag Lecture Notes, </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: The Controller uses global variables, which will be put in its "State". In the module GUI State.hs I define this State. Information can be put in or extracted from this State by using monadic functions (see <ref> [14] </ref>). For more specific information see the Input Handlers themselves, since the annotation should make most things clear. 51 8.2 Reused Code Several functions that were already present in Textual Yarrow have been adapted for use in the new interface-engine structure.
Reference: [15] <author> Yves Bertot, Gilles Kahn and Laurent Thery. </author> <title> Proof by Pointing. </title> <institution> INRIA Sophia-Antipolis, </institution> <address> France. FTP://babar.inria.fr/pub/croap/BraTypes/proof-by-pointing.ps.gz 119 </address>
Reference-contexts: Entering terms is now done by typing them in some string input field. Structure editing for these lambda terms could make this a lot more convenient. Finally, one of the most powerful things to add is proof by pointing (see <ref> [15] </ref>). When selecting a term, not only the parameter to a tactic will be derived, but also the tactic to use itself.
References-found: 15

