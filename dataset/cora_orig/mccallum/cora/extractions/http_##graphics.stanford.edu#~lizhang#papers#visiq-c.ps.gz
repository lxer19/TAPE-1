URL: http://graphics.stanford.edu/~lizhang/papers/visiq-c.ps.gz
Refering-URL: http://graphics.stanford.edu/~lizhang/interests.html
Root-URL: http://www.cs.stanford.edu
Phone: 2  3  
Title: Visibility Queries in Simple Polygons and Applications  
Author: Boris Aronov Leonidas J. Guibas Marek Teichmann and Li Zhang 
Address: NY 11201-3840, USA.  Stanford, CA 94305, USA.  Cambridge, MA 02139, USA.  
Affiliation: 1 Department of Computer and Information Science, Polytechnic University, Brooklyn,  Department of Computer Science, Stanford University,  Laboratory for Computer Science, MIT,  
Abstract: In this paper we explore some novel aspects of visibility for stationary and moving points inside a simple polygon P . We provide a mechanism for expressing the visibility polygon from a point as the disjoint union of logarithmically many canonical pieces using a quadratic-space data structure. This allows us to report visibility polygons in time proportional to their size, but without the cubic space overhead of earlier methods. The same canonical decomposition can be used to determine visibility within a frustum, or to compute various attributes of the visibility polygon efficiently. By exploring the connection between visibility polygons and shortest path trees, we obtain a kinetic algorithm that can track the visibility polygon as the viewpoint moves along polygonal paths inside P , at a polylogarithmic cost per combinatorial change in the visibility. The combination of the static and kinetic algorithms leads to a space query-time tradeoff for the visibility from a point problem and an output-sensitive algorithm for the weak visibility from a segment problem.
Abstract-found: 1
Intro-found: 1
Reference: [BGH97] <author> J. Basch, L. Guibas, and J. Hershberger. </author> <title> Data structures for mobile data. </title> <booktitle> In Proc. 8th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 747756, </pages> <year> 1997. </year>
Reference-contexts: In addition, our algorithm maintains the visibility in an online fashion, namely, once the motion of the point changes, the data structure can be updated efficiently. In fact, our algorithm fits the framework of kinetic data structures in <ref> [BGH97] </ref> very well and satisfies all the efficiency criteria proposed in their paper. 4.1 Combinatorial changes of the shortest-path tree Fig. 2. Events in the maintenance of the shortest-path tree Instead of maintaining the visibility polygon, we will maintain the shortest-path tree of p.
Reference: [BLM92] <author> P. Bose, A. Lubiw, and J. I. Munro. </author> <title> Efficient visibility queries in simple polygons. </title> <booktitle> In Proc. 4th Canad. Conf. Comput. Geom., </booktitle> <pages> pages 2328, </pages> <year> 1992. </year>
Reference-contexts: For the visibility query problem, there are methods for reporting the visibility polygon of a query point in O (jV (q)j log n) time after O (n) preprocessing time. Note, however, the appearance of a multiplicative overhead in the query bound. In <ref> [BLM92] </ref> and ? Boris Aronov has been partially supported by NSF Grant CCR-92-11541 and a Sloan Research Fellowship. Leonidas Guibas and Li Zhang were supported in part by Army Research Office MURI grant 5-23542-A and NSF grant CCR-9623851.
Reference: [CD96] <author> D. Z. Chen and O. Daescu. </author> <title> Maintaining visibility of a polygon with a moving point of view. </title> <booktitle> In Proc. 8th Canad. Conf. Comput. Geom., </booktitle> <pages> pages 240245, </pages> <year> 1996. </year>
Reference-contexts: We also consider the problem of maintaining visibility from a linearly moving viewpoint. A similar problem is studied in <ref> [CD96] </ref>. In their problem, the point moves along a given line segment, i.e. the motion is fixed. Here, we allow the motion of the point to be updated in an on-line fashion.
Reference: [Cha82] <author> B. Chazelle. </author> <title> A theorem on polygon cutting with applications. </title> <booktitle> In Proc. 23rd Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 339349, </pages> <year> 1982. </year>
Reference-contexts: The balanced triangulation of a simple polygon P is based on the observation that there always exists a diagonal e of a simple polygon P that cuts P into two pieces, each with at most 2n=3 vertices <ref> [Cha82] </ref>. By recursively subdividing, a balanced binary tree can be created where all the leaves are triangles and each interior node i corresponds to a sub-polygon P i and a diagonal e i .
Reference: [GH89] <author> L. J. Guibas and J. Hershberger. </author> <title> Optimal shortest path queries in a simple polygon. </title> <institution> J. Comput. Syst. Sci., 39:126152, </institution> <year> 1989. </year>
Reference-contexts: If we take possible collinearity into account, it suffices to consider the two edges nearest to q on each shortest path. We omit the details in this version of the paper. In <ref> [GH89] </ref>, it is shown that a data structure can be built in linear time and using linear space so that, for any two query points, the length of the shortest path between them can be reported in O (log n) time.
Reference: [GHL + 87] <author> L. J. Guibas, J. Hershberger, D. Leven, M. Sharir, and R. E. Tarjan. </author> <title> Linear-time algorithms for visibility and shortest path problems inside triangulated simple polygons. </title> <journal> Algorithmica, </journal> <volume> 2:209233, </volume> <year> 1987. </year>
Reference-contexts: By duality, t can be maintained by a dynamic convex hull algorithm with O (log 2 n) cost per update. Therefore, we obtain the following algorithm. Preprocessing. First, we construct the shortest-path tree T (p) from the initial position of p to all vertices of P as in <ref> [GHL + 87] </ref>. Further, obtain, for each vertex v, the doubly-linked list of its children, sorted around v, with pointers to the first and last. In each vertex, we store a pointer to its principal child.
Reference: [GMR92] <author> L. J. Guibas, R. Motwani, and P. Raghavan. </author> <title> The robot localization problem in two dimensions. </title> <booktitle> In Proc. 3rd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 259268, </pages> <year> 1992. </year>
Reference-contexts: Leonidas Guibas and Li Zhang were supported in part by Army Research Office MURI grant 5-23542-A and NSF grant CCR-9623851. Marek Teichmann is supported by the National Science and Engineering Council of Canada. <ref> [GMR92] </ref>, an optimal query time without multiplicative overhead is achieved. The query time of their algorithms is O (log n + jV (q)j), but the storage and preprocessing time is cubic in n. In their methods, a full visibility decomposition is built to answer visibility queries.
Reference: [HS93] <author> J. Hershberger and S. Suri. </author> <title> A pedestrian approach to ray shooting: Shoot a ray, take a walk. </title> <booktitle> In Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 5463, </pages> <year> 1993. </year>
Reference-contexts: Note that once p crosses a constraint line that passes through the vertices u; v, only the visibility of the edge hit by the extension of ! uv (or ! vu) can change. Therefore, a ray-shooting data structure, such as the one in <ref> [HS93] </ref>, suffices to detect which edge it is in O (log n) time. The motion of p is updated. Since p's motion is linear, we perform a binary search to determine which edge on the boundary of t p is going to cross next.
Reference: [Ove83] <author> M. H. Overmars. </author> <title> The Design of Dynamic Data Structures, </title> <booktitle> volume 156 of Lecture Notes Comput. </booktitle> <publisher> Sci. Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1983. </year>
Reference-contexts: We store (the dual of) t into a dynamic convex hull structure of <ref> [Ove83] </ref>, which can be initialized in O (n log n) time using O (n) space and updated in O (log 2 n) time per insertion and deletion. We also compute the time when p crosses the boundary of t along the current direction. Updating. <p> Furthermore, the structures are updated by eliminating and adding the appropriate constraints into the dynamic data structure representing the face t that contains p. Since there are only O (1) changes on T (p), this operation takes O (log 2 n) time <ref> [Ove83] </ref>. Finally, we compute the next time when p crosses the boundary of t by performing a binary search on the updated t in O (log n) time. To maintain V (p), we need to maintain the edges visible to p as well as the vertices.
Reference: [ST86] <author> N. Sarnak and R. E. Tarjan. </author> <title> Planar point location using persistent search trees. </title> <journal> Com-mun. ACM, </journal> <volume> 29:669679, </volume> <year> 1986. </year>
Reference-contexts: An immediate connection between V (p) and T (p) is that the vertices of P visible from p are exactly the children of p in T (p). In Section 4, we will see more connections between T (p) and V (p). In the paper, we use persistent data structures <ref> [ST86] </ref> to reduce storage requirements. A persistent data structure is one that accepts an arbitrarily long sequence of updates, but is able to remember at any time all its earlier versions. Here, we focus our attention on persistent red-black trees. <p> Let the version at time t, for 1 t `, be the set resulting from applying the first t updates in the sequence to an empty set. The following fact is due to Sarnak and Tarjan <ref> [ST86] </ref>. Fact 4 ([ST86]). A persistent red-black tree can be built so that any version can be accessed with the same time bounds as if the items were stored in a normal red-black tree. <p> For the persistent data structure in <ref> [ST86] </ref>, this can be done, for any version, in O (log n + k) time where k is the output size. Therefore, we have Theorem 1.
References-found: 10

