URL: http://csgrad.cs.vt.edu/~mateescu/ft.ps
Refering-URL: http://csgrad.cs.vt.edu/~mateescu/
Root-URL: http://www.cs.vt.edu
Email: mateescu@csgrad.cs.vt.edu  
Title: SOFTWARE FAULT ELIMINATION AND SOFTWARE FAULT TOLERANCE  
Author: Gabriel Mateescu 
Date: December 02, 1996  
Address: VA 24061, USA  
Affiliation: Computer Science Department Virginia Polytechnic Institute and State University Blacksburg,  
Abstract-found: 0
Intro-found: 1
Reference: [AC77] <author> A. Avizienis and L. Chen. </author> <title> On the implementation of N-version programming for software fault tolerance during program execution. </title> <booktitle> In Proc. COMPSAC 77, </booktitle> <address> Chicago, IL, </address> <month> November </month> <year> 1977. </year>
Reference-contexts: N-version programming This approach has been proposed by Avizienis <ref> [Avi77, AC77] </ref>. Design diversity is implemented by developing a number of N independent programs, called versions, that are solving the same problem.
Reference: [AK84] <author> A. Avizienis and J. P. J. Kelly. </author> <title> Fault tolerance by design diversity: Concepts and experiments. </title> <journal> Computer, </journal> <volume> 17(8) </volume> <pages> 67-80, </pages> <month> August </month> <year> 1984. </year>
Reference: [Avi77] <author> A. Avizienis. </author> <title> The N-version approach to fault-tolerant systems. </title> <booktitle> In Proc. COMPSAC 77, </booktitle> <address> Chicago, IL, </address> <month> November </month> <year> 1977. </year>
Reference-contexts: N-version programming This approach has been proposed by Avizienis <ref> [Avi77, AC77] </ref>. Design diversity is implemented by developing a number of N independent programs, called versions, that are solving the same problem.
Reference: [Bal96] <author> O. </author> <title> Balci. Software Engineering, CS6704, class notes. </title> <institution> Dept. of Computer Science, Virginia Tech, Blacksburg, VA, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: We will consider only one such model, namely, the waterfall model for software life cycle. The waterfall model of the software process is derived from the the system engineering process. The waterfall model, as envisioned by Balci <ref> [Bal96] </ref>, is shown in Figure 1. The model exposes the importance of verification, validation, and testing (VV&T ) at every stage in the software development process.
Reference: [BEH + 86] <author> P. G. Bishop, D. G. Esp, P. Humphreys, G. Dahl, and J. Lahta. </author> <title> PODS A project on diverse software. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 12(9) </volume> <pages> 929-940, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Avizienis and Chen [1977] suggest that the use of different programming teams is the "baseline dimension for software diversity". The role of different development practices and of multiple specification and programming languages in achieving independent failures has been investigated by several researchers ([AK84], <ref> [BEH + 86] </ref>). The experiments indicate a correlation between the failures in different versions. Other experiments ([KL86], [ECK + 91], [SL91]) confirm that significant correlation between failures exist in this approach.
Reference: [Boe79] <author> B. W. Boehm. </author> <title> Software engineering: R & d trends and defense needs. </title> <editor> In P. Wegner, editor, </editor> <booktitle> Directions in Software Technology, </booktitle> <address> Cambridge, MA, 1979. </address> <publisher> MIT Press. </publisher>
Reference-contexts: According to Boehm <ref> [Boe79] </ref>, performing verification involves answering the question "Are we building the Software Fault Elimination and Software Fault Tolerance 8 product right?", while validation involves answering the question "Are we building the right product?" Balci [1996] defines verification as "substantiating that the software has been transformed from one form to another as
Reference: [ECK + 91] <author> D. E. Eckhardt, A. K. Caglayan, J. C. Knight, L. D. Lee, D. F. McAllister, M. A. Vouk, and J. P. J. Kelly. </author> <title> An experimental evaluation of software redundancy as a strategy for improving reliability. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 17(7) </volume> <pages> 692-702, </pages> <month> July </month> <year> 1991. </year> <title> Software Fault Elimination and Software Fault Tolerance 45 </title>
Reference-contexts: The role of different development practices and of multiple specification and programming languages in achieving independent failures has been investigated by several researchers ([AK84], [BEH + 86]). The experiments indicate a correlation between the failures in different versions. Other experiments ([KL86], <ref> [ECK + 91] </ref>, [SL91]) confirm that significant correlation between failures exist in this approach. Analytical arguments ([EL85]) also indicate that failures in redundant soft Software Fault Elimination and Software Fault Tolerance 32 ware components are unlikely to be independent.
Reference: [EL85] <author> D. E. Eckhardt and L. D. Lee. </author> <title> A theoretical basis for the analysis of multiversion software subject to coincident errors. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 11(12) </volume> <pages> 1511-1517, </pages> <month> December </month> <year> 1985. </year>
Reference: [Fag86] <author> M. E. Fagan. </author> <title> Advances in software inspections. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 12(7) </volume> <pages> 744-751, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Experiments conducted by Basili and Selby [1987] suggest that black-box testing is more effective at revealing software faults than white-box testing. However they have found that the number of faults discovered per unit time is similar. Static verification appears to be more cost-effective than defect testing. Fa-gan <ref> [Fag86] </ref> has found that more than 60% of the faults in a program can be detected using informal program inspections. Mills et al. [1987] have conjectured that formal verification techniques can detect more than 80% of the software faults.
Reference: [IEE83] <institution> IEEE. Glossary of Software Engineering Terminology. ANSI IEEE Standard 729-1983, </institution> <year> 1983. </year>
Reference-contexts: Increasing system complexity has transformed software testing into a vital component of the software process. The realm of testing has evolved from the activity of debugging to a set of strategies, techniques and tools that are applied to the entire software development process. A fault is defined by IEEE <ref> [IEE83] </ref> as "an accidental condition that causes a functional unit to fail to perform its required function." A failure is defined by Software Fault Elimination and Software Fault Tolerance 5 Shimeall et al. [1991] as "an output value that varies from the specified standard due to a fault." Several faults can
Reference: [KL86] <author> J. C. Knight and N. G. Leveson. </author> <title> Experimental evaluation of the assumption of independence in multiversion programming. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 12(1) </volume> <pages> 96-109, </pages> <month> January </month> <year> 1986. </year>
Reference: [LABK90] <author> J.-C. Laprie, J. Arlat, C. Beounes, and K. Kanoun. </author> <title> Definition and analysis of hardware- and software-fault-tolerant architectures. </title> <journal> Computer, </journal> <volume> 23(7) </volume> <pages> 39-51, </pages> <month> July </month> <year> 1990. </year>
Reference: [LCKS90] <author> N. G. Leveson, S. S. Cha, J. C. Knigh, and T. J. Shimeall. </author> <title> The use of self checks and voting in software error detection: An empirical study. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 16(4) </volume> <pages> 432-443, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: This is why back-to-back testing detects failures rather than errors. In contrast, traditional testing methods (such as white-box testing and self checks) are able to detect errors which do not cause failures (as proved by the experiments reported in <ref> [LCKS90, SL91] </ref>). Moreover, whereas testing techniques can be designed so as to detect the failures caused by a particular type of fault, N-version voting is only partially effective at detecting such failures, as Leveson et al. [1990] have observed. <p> Besides finding that self-testing and N-version voting usually detect different faults, the authors also observe that none of the two strategies identifies all the faults detected by the other. Moreover <ref> [LCKS90] </ref>: The fact that the self checks uncovered new faults that were not detected by voting on the same input cases implies that self checking may have important advantages over voting.
Reference: [MDL87] <author> H. D. Mills, M. Dyer, and R. </author> <title> Linger. </title> <journal> Cleanroom software engineering. IEEE Software, </journal> <volume> 4(5) </volume> <pages> 19-25, </pages> <year> 1987. </year>
Reference: [Mye79] <author> G. J. Myers. </author> <title> The Art of Software Testing. </title> <publisher> John Wiley & Sons, Inc., </publisher> <address> New York, NY, </address> <year> 1979. </year> <title> Software Fault Elimination and Software Fault Tolerance 46 </title>
Reference-contexts: Sommerville defines software engineering as the discipline studying "the specification, management and evolution of software systems" [Som96, page v]. Software testing is aimed at discovering errors in software. The classical work of Myers <ref> [Mye79] </ref> has contributed to a better understanding of the testing process: the purpose of testing should be to find errors, not to show the absence of errors. Increasing system complexity has transformed software testing into a vital component of the software process.
Reference: [Pha92] <author> H. Pham. </author> <title> Fault-Tolerant Software Systems: Techniques and Applications. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1992. </year>
Reference-contexts: Residual faults are usually related to hard to reproduce conditions such as race conditions and unusual hardware behavior. When the occurrence of software faults depends on the realization of some special context, it is very likely that the software fault will occur very rarely. Pham <ref> [Pha92] </ref> gives the following example: Consider the cost (and likelihood) of a fairly reliable software program subjected to continuous testing and debugging and guaranteed to have no more than five faults throughout its life cycle. <p> Depending on how recovery is performed, we distinguish between hardware and software fault tolerance. Software fault tolerance is defined by Pham <ref> [Pha92] </ref> as "the reliance on design diversity to mask residual design faults present in software programs". Design diversity means building to or more systems delivering the same service but using separate designs and implementations. <p> The scheme uses a primary module P and a set of alternate (or redundant) modules Q 1 ; : : : ; Q n that perform the same function as P . Software Fault Elimination and Software Fault Tolerance 29 The scheme is illustrated by Pham <ref> [Pha92] </ref> as shown in Figure 4. The scheme works as follows. Initially, the primary module P is designated to execute the critical software functions.
Reference: [Pre97] <author> R. S. Pressman. </author> <title> Software Engineering: A Practitioner's Approach. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <note> fourth edition, </note> <year> 1997. </year>
Reference-contexts: Sommerville [1996, page 453] considers back-to-back testing a testing strategy, while other authors include back-to-back testing among the black-box testing methods (for example <ref> [Pre97] </ref>). An approach to testing which is not classified as a testing strategy is incremental testing. The idea of incremental testing is to integrate the components of a system using increments rather than integrating them all at once. An increment consists of a number of sub-systems.
Reference: [SL91] <author> T. J. Shimeall and N. G. Leveson. </author> <title> An empirical comparison of software fault tolerance and fault elimination. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 17(2) </volume> <pages> 173-182, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: The role of different development practices and of multiple specification and programming languages in achieving independent failures has been investigated by several researchers ([AK84], [BEH + 86]). The experiments indicate a correlation between the failures in different versions. Other experiments ([KL86], [ECK + 91], <ref> [SL91] </ref>) confirm that significant correlation between failures exist in this approach. Analytical arguments ([EL85]) also indicate that failures in redundant soft Software Fault Elimination and Software Fault Tolerance 32 ware components are unlikely to be independent. Furthermore, coincident failures do not necessarily result from similar design faults (see Figure 2). <p> This is why back-to-back testing detects failures rather than errors. In contrast, traditional testing methods (such as white-box testing and self checks) are able to detect errors which do not cause failures (as proved by the experiments reported in <ref> [LCKS90, SL91] </ref>). Moreover, whereas testing techniques can be designed so as to detect the failures caused by a particular type of fault, N-version voting is only partially effective at detecting such failures, as Leveson et al. [1990] have observed.
Reference: [Som96] <author> I. Sommerville. </author> <title> Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, fifth edition, </address> <year> 1996. </year>
Reference-contexts: In Section 9 we formulate the concluding remarks. 2 Background and Terminology In this section we define certain key concepts such as error, fault, failure, dependability, and reliability. Sommerville defines software engineering as the discipline studying "the specification, management and evolution of software systems" <ref> [Som96, page v] </ref>. Software testing is aimed at discovering errors in software. The classical work of Myers [Mye79] has contributed to a better understanding of the testing process: the purpose of testing should be to find errors, not to show the absence of errors. <p> While defect testing is intended to discover the defects in the software, debugging is performed to identify software components where the defects exist and to remove the defects. Based on the distinct characteristics of testing and debugging, Sommerville considers them to be two distinct processes <ref> [Som96, page 447] </ref>: Testing establishes the existence of defects. Debugging is concerned with locating and correcting these errors. Defect testing and debugging techniques are designed to expose and remove faults. However, no reasonable test suite can remove all software faults. <p> To improve reliability such that only two faults are tolerated, the effort and cost would be enormous. An alternate approach to increasing reliability is to provide redundancy. Redundancy has been accepted as a viable approach for obtaining reliability with unreliable components. Sommerville makes the following point <ref> [Som96, page 464] </ref>: It is practically impossible for defect testing to be exhaustive. Exhaustive testing requires every statement in the program and every possible path combination through the program to be executed.
Reference: [Vog86] <author> U. Voges. </author> <title> Application of design diversity in computerized control systems. </title> <booktitle> In Proc. IFIP Workshop on Design Diversity in Action, </booktitle> <address> Vienna, Austria, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The estimates proposed by Laprie are consistent with other results published on this topic, such as the work of Voges <ref> [Vog86] </ref>.
References-found: 20

