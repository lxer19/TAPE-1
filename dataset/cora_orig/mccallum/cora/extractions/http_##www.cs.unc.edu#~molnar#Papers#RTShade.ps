URL: http://www.cs.unc.edu/~molnar/Papers/RTShade.ps
Refering-URL: http://www.cs.unc.edu/~molnar/
Root-URL: http://www.cs.unc.edu
Title: on Interactive 3D Graphics. 1  
Author: Anselmo Lastra, Steven Molnar, Marc Olano, Yulan Wang 
Keyword: Real-Time Programmable Shading  
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Note: To appear in the Proceedings of the 1995 Symposium  
Abstract: One of the main techniques used by software renderers to produce stunningly realistic images is programmable shadingexecuting an arbitrarily complex program to compute the color at each pixel. Thus far, programmable shading has only been available on software rendering systems that run on general-purpose computers. Rendering each image can take from minutes to hours. Parallel rendering engines, on the other hand, have steadily increased in generality and in performance. We believe that they are nearing the point where they will be able to perform moderately complex shading at real-time rates. Some of the obstacles to this are imposed by hardware, such as limited amounts of frame-buffer memory and the enormous computational resources that are needed to shade in real time. Other obstacles are imposed by software. For example, users generally are not granted access to the hardware at the level required for programmable shading. This paper first explores the capabilities that are needed to perform programmable shading in real time. We then describe the design issues and algorithms for a prototype shading architecture on PixelFlow, an experimental graphics engine under construction. We demonstrate through examples and simulation that PixelFlow will be able to perform high-quality programmable shading at real-time (30 to 60 Hz) rates. We hope that our experience will be useful to shading implementors on other hardware graphics systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Cook, R. L., L. Carpenter and E. Catmull, </author> <title> "The Reyes Image Rendering Architecture", </title> <note> SIGGRAPH 87 , pp. 95 - 102. </note>
Reference-contexts: We don't claim that all of the techniques used for high-quality shading can now be done interactively, but a very large class of renderers, those dealing with local lighting effects, can be computed in real time. A notable example of this class is the Reyes renderer <ref> [1] </ref>. As evidenced by the quality of the work produced at Pixar, local effects can produce striking images. Cook, et. al. observed that many global effects can be approximated using tables, such as environment and shadow maps [1]. <p> A notable example of this class is the Reyes renderer <ref> [1] </ref>. As evidenced by the quality of the work produced at Pixar, local effects can produce striking images. Cook, et. al. observed that many global effects can be approximated using tables, such as environment and shadow maps [1]. If a rendering system can be designed to fit the traditional rendering pipeline, communication patterns can be kept well structured, and global communications can be limited, very complex geometry with complex shading models can be rendered to produce very high quality images. This paper consists of two main parts.
Reference: [2] <author> Whitted T., and D. M. Weimer, </author> " <title> A Software Testbed for the Development of 3D Raster Graphics Systems", </title> <journal> ACM Transactions on Graphics , Vol. </journal> <volume> 1, No. 1, </volume> <month> Jan. </month> <year> 1982, </year> <pages> pp. 43-58. </pages>
Reference-contexts: with performance simulations that justify this claim. 2 TOWARD REAL-TIME SHADING In order to achieve real-time programmable shading, we must identify the crucial requirements of software renderers and combine them with the real-time capabilities of hardware renderers, as indicated in Figure 1. 2.1 Programmability A number of computer graphics researchers <ref> [2, 3, 4] </ref> have argued that a fixed shading model, even with adjustable parameters, is not sufficiently powerful to shade realistic images. The wide variety of surfaces makes it difficult, if not impossible, to create a single, comprehensive, shading program. Programmability allows the practitioner to create any desired effect. <p> software 2 Quality Speed Fully programmable Unlimited memory Serial execution Fixed shading model Limited memory Highly parallel Software Renderers Hardware Renderers Real-time shading Programmable Bounded memory Highly parallel Combine/ adapt hardware renderers. systems designed for high-quality rendering allow users to specify the shading algorithm either in a traditional high-level language <ref> [2] </ref>, or in a language specifically designed for shading [3, 4, 5].
Reference: [3] <author> Cook, R. L., </author> <title> "Shade Trees", </title> <booktitle> SIGGRAPH 84, </booktitle> <pages> pp. 223-231. </pages>
Reference-contexts: with performance simulations that justify this claim. 2 TOWARD REAL-TIME SHADING In order to achieve real-time programmable shading, we must identify the crucial requirements of software renderers and combine them with the real-time capabilities of hardware renderers, as indicated in Figure 1. 2.1 Programmability A number of computer graphics researchers <ref> [2, 3, 4] </ref> have argued that a fixed shading model, even with adjustable parameters, is not sufficiently powerful to shade realistic images. The wide variety of surfaces makes it difficult, if not impossible, to create a single, comprehensive, shading program. Programmability allows the practitioner to create any desired effect. <p> execution Fixed shading model Limited memory Highly parallel Software Renderers Hardware Renderers Real-time shading Programmable Bounded memory Highly parallel Combine/ adapt hardware renderers. systems designed for high-quality rendering allow users to specify the shading algorithm either in a traditional high-level language [2], or in a language specifically designed for shading <ref> [3, 4, 5] </ref>. On the other hand, computers designed for interactive graphics typically have powerful hardware for interpolating color and depth values, and more recently for computing image-based textures, but only support a fixed shading algorithm with a few adjustable parametersmost commonly linear interpolation of colors or intensities between vertices. <p> This data typically consists of constants, such as intrinsic colors, or interpolated parameters, such as surface normal vectors, texture coordinates, etc. (Cook refers to these as appearance parameters <ref> [3] </ref>. We will use this term in the remainder of the paper). A second pass of the algorithm loops over the pixels, shading each one. Deferred shading divides the cost of shading by the depth complexity of the image. This can be substantial for complex scenes.
Reference: [4] <author> Hanrahan, P. and J. Lawson, </author> <title> "A Language for Shading and Lighting Calculations", </title> <booktitle> SIGGRAPH 90, </booktitle> <pages> pp. 289-298. </pages>
Reference-contexts: with performance simulations that justify this claim. 2 TOWARD REAL-TIME SHADING In order to achieve real-time programmable shading, we must identify the crucial requirements of software renderers and combine them with the real-time capabilities of hardware renderers, as indicated in Figure 1. 2.1 Programmability A number of computer graphics researchers <ref> [2, 3, 4] </ref> have argued that a fixed shading model, even with adjustable parameters, is not sufficiently powerful to shade realistic images. The wide variety of surfaces makes it difficult, if not impossible, to create a single, comprehensive, shading program. Programmability allows the practitioner to create any desired effect. <p> execution Fixed shading model Limited memory Highly parallel Software Renderers Hardware Renderers Real-time shading Programmable Bounded memory Highly parallel Combine/ adapt hardware renderers. systems designed for high-quality rendering allow users to specify the shading algorithm either in a traditional high-level language [2], or in a language specifically designed for shading <ref> [3, 4, 5] </ref>. On the other hand, computers designed for interactive graphics typically have powerful hardware for interpolating color and depth values, and more recently for computing image-based textures, but only support a fixed shading algorithm with a few adjustable parametersmost commonly linear interpolation of colors or intensities between vertices. <p> These considerations are useful and important, but they need not preclude programmable shading. Just as access to geometry rendering hardware is provided by portable graphics libraries, such as PEX and OpenGL, programmable shading can be provided by a portable language, such as the RenderMan shading language <ref> [4] </ref>. The shading language can be compiled for the particular hardware, or in low-end machines, software execution. As with current machines, more powerful, expensive workstations will shade at interactive rates, while cheaper models will produce the same images much more slowly. <p> Uniform vs. varying parameters. In the design of the RenderMan shading language, Hanrahan recognized that a potentially powerful optimization is to calculate expressions that are independent of position on a surface only once <ref> [4] </ref>. To take advantage of this, the language allows the programmer to specify whether a variable is uniform, its value is constant across a surface, or varying, its value depends on position. <p> We then explain the techniques that we use to achieve interactive programmable shading. Finally, we outline the programming models of the system: the existing low-level model, and a high-level language we are implementing that is similar to the RenderMan shading language <ref> [4] </ref>. We believe that this system, when the hardware is complete, will be able to render the types of images previously seen only on software renderers, at interactive rates. 3.1 Hardware Overview PixelFlow consists of a set of nodes, each of which is essentially a complete graphics computer.
Reference: [5] <author> Perlin, K., </author> <title> "An Image Synthesizer", </title> <booktitle> SIGGRAPH 85, </booktitle> <pages> pp. 287-296. </pages>
Reference-contexts: execution Fixed shading model Limited memory Highly parallel Software Renderers Hardware Renderers Real-time shading Programmable Bounded memory Highly parallel Combine/ adapt hardware renderers. systems designed for high-quality rendering allow users to specify the shading algorithm either in a traditional high-level language [2], or in a language specifically designed for shading <ref> [3, 4, 5] </ref>. On the other hand, computers designed for interactive graphics typically have powerful hardware for interpolating color and depth values, and more recently for computing image-based textures, but only support a fixed shading algorithm with a few adjustable parametersmost commonly linear interpolation of colors or intensities between vertices. <p> We have written a library of auxiliary shading functions to use with this programming model. It provides basic vector operations, functions to support procedural texturing <ref> [5, 13] </ref>, basic lighting functions, image-based texture mapping [14], bump mapping [15], and higher-level procedures for generating and using reflection maps [16] and shadow maps [17, 18]. It is perfectly feasible to program at this level.
Reference: [6] <author> Upstill, S., </author> <title> The RenderMan Companion, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Local Memory. Let us examine the demand for local memory first. In our experience, procedural texturing is the operation that consumes the most local memory. For example, Figure 2 illustrates the amount of memory used by several of the shaders that are shipped with the RenderMan software package <ref> [6] </ref>. Shader Local variables carpet 24 marble 26 stippled 33 stone 23 shaders. Our experience is that storage for 30 to 40 local variables is adequate, though this does not count all of the necessary global parameters such as normals, intrinsic color, etc. <p> The examplebowling pins being scattered by a bowling ballwas inspired by the well-known Textbook Strike cover image of the RenderMan Companion <ref> [6] </ref>. We cannot guarantee that the dynamics of motion are computable in real-time, but we are confident that a modest-sized PixelFlow system (less than one card cage) can render the images at 30 frames per second. The accompanying video was rendered on the PixelFlow functional simulator.
Reference: [7] <author> Akeley, K., </author> <title> Reality Engine Graphics, </title> <booktitle> SIGGRAPH 93, </booktitle> <pages> pp. 109-116. </pages>
Reference-contexts: More sophisticated algorithms, such as bump mapping, shadow mapping, procedural textures, and antialiasing, can multiply these requirements by an order of magnitude or more. Large-scale parallelism. The only way to achieve computation rates such as these is to employ large-scale parallelism. Current graphics engines employ dozens to hundreds <ref> [7] </ref> (or even thousands [8]) of processors to perform visibility and relatively simple shading. Even more are needed for programmable shading. Fortunately, many features of general-purpose processors are not needed here, so processors can be specialized for rendering.
Reference: [8] <author> Fuchs H., J. Poulton, J. Eyles, T. Greer, J. Goldfeather, D. Ellsworth, S. Molnar, G. Turk, B. Tebbs, and L. Israel, </author> <title> "Pixel-Planes 5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories", </title> <booktitle> SIGGRAPH 89, </booktitle> <pages> pp. 79-88. </pages>
Reference-contexts: Large-scale parallelism. The only way to achieve computation rates such as these is to employ large-scale parallelism. Current graphics engines employ dozens to hundreds [7] (or even thousands <ref> [8] </ref>) of processors to perform visibility and relatively simple shading. Even more are needed for programmable shading. Fortunately, many features of general-purpose processors are not needed here, so processors can be specialized for rendering.
Reference: [9] <author> Deering, M., S. Winner, B. Schediwy, C. Duffy, and N. Hunt, </author> <title> The Triangle Processor and Normal Vector Shader: </title>
Reference-contexts: This wasted work can be avoided by delaying shading calculations until after primitives have been rasterized, a technique known as deferred shading <ref> [9, 10] </ref>. Figure 3b illustrates a pipeline modified for deferred shading. The only work that is performed in the loop over primitives is to determine visibility and to store the raw data the shader will need to compute the pixel colors later.
References-found: 9

