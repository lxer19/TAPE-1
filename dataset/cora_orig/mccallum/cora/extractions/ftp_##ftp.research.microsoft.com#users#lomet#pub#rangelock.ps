URL: ftp://ftp.research.microsoft.com/users/lomet/pub/rangelock.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/pub/default.htm
Root-URL: http://www.research.microsoft.com
Title: Key Range Locking Strategies for Improved Concurrency  
Author: David B. Lomet 
Address: One Kendall Square, Bldg 700 Cambridge, MA 02139  
Affiliation: DEC Cambridge Research Lab  
Abstract: Phantoms" are records inserted into a concurrently selected set of records specified by a predicate such that the selection does not see a transaction consistent result. The usual locking strategy is to lock only existing records. However, records that satisfy the selection predicate must be locked even when they are not present in the database to prevent their insertion. One way to cope with phantoms is through range locking, a limited form of predicate locking. We investigate lock modes for ranges and describe new lock modes that greatly increase concurrency. We explore locking strategies involving range, key, and record resources that permit trade-offs between concurrency and lock overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bernstein, P., Hadzilacos, V. and Goodman, N. </author> <title> Concurrency Control and Recovery in Database Systems Addison Wesley, </title> <address> Reading MA (1987) </address>
Reference-contexts: Predicate locking [2] is a complete solution to the phantom problem, but conventional lock managers (LMs) do not directly handle predicate locks. LMs need to have excellent performance and even rather restricted predicate locking can be expensive and difficult. Index locking, with or without the index, has been suggested <ref> [1] </ref>. The locking described there coped with phantoms when the predicates involved were equality predicates. Predicates that specify ranges of values were not handled. 1.2 Ranges as Lockable Granules System R performed range locking within its B-tree indexing. This is credited to Eswaran and Blasgen in [4].
Reference: [2] <author> Eswaren, K., Gray, J., Lorie, R., and Traiger, I. </author> <title> The notions of consistency and predicate locks in a database system. </title> <journal> Communications of the ACM 19,11 (Nov. </journal> <year> 1976) </year> <month> 624-633. </month>
Reference-contexts: For example, one can lock a table whenever a subset of the table is selected. The goal has been to find a solution that has high concurrency and low lock overhead. Locking an entire table has low overhead but bad concurrency. Predicate locking <ref> [2] </ref> is a complete solution to the phantom problem, but conventional lock managers (LMs) do not directly handle predicate locks. LMs need to have excellent performance and even rather restricted predicate locking can be expensive and difficult. Index locking, with or without the index, has been suggested [1].
Reference: [3] <author> Gray, J.N., Lorie, R. A., Putzulo, G. R., and Traiger, I. L. </author> <title> Granularity of locks and degrees of consistency in a shared data base. </title> <booktitle> IFIP Working Conf on Modeling of Data Base Management Systems (1976) 1-29. </booktitle>
Reference-contexts: a technique invented to cope with such preplanned predicates by regarding the predicates as resource "granules" that Mode IS IX S SIX X IS x x x x S x x X Table 1: The lock mode compatibility matrix for multi-granularity locking include or partially overlap with other resource granules <ref> [3] </ref>. MGL locking can be used for range locking. MGL locking exploits lock modes in addition to the exclusion oriented S (Share) and X (eXclusive) modes. These additional modes are known as "intention" modes.
Reference: [4] <author> Gray, J. and Reuter, A. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kauf-mann, </publisher> <address> San Mateo, CA (1992) </address>
Reference-contexts: The locking described there coped with phantoms when the predicates involved were equality predicates. Predicates that specify ranges of values were not handled. 1.2 Ranges as Lockable Granules System R performed range locking within its B-tree indexing. This is credited to Eswaran and Blasgen in <ref> [4] </ref>. Recent papers [6, 7] have described this earlier work and have introduced improvements in both concurrency and lock overhead by showing how multi-granularity lock modes can be exploited. Our work builds on these papers. <p> This list defines disjoint semi-open ranges (k i ; k i+1 ]. Each range can be identified by the value of its upper attribute. To lock the range (k i ; k i+1 ], we map k i+1 to a resource id and lock it. <ref> [4] </ref>. (Note that we could also define our ranges as [k i ; k i+1 ) and identify them by k i .
Reference: [5] <author> Lomet, D. </author> <title> Private Lock Management Digital Equipment Corp. </title> <type> Tech Report CRL 92/9 (Nov. </type> <institution> 1992) Cambridge Research Lab, </institution> <address> Cambridge, MA. </address>
Reference-contexts: We can use either intention locks or covering locks (i.e. X or S locks) at the range level. We assume here that keys are unique. 2.2.1 Scans For scans, one needs to lock ranges to prevent phantoms. The locks needed must be covering locks <ref> [5] </ref>, i.e., locks that make it unnecessary to lock contained records since we have no way of explicitly locking each potential record of the range. Hence, scans need S locks on the ranges that they touch. An S range lock implicitly locks all records in the range.
Reference: [6] <author> Mohan, C. ARIES/KVL: </author> <title> A key-value locking method for concurrency control of multiaction transactions operating on B-tree indexes, </title> <booktitle> Proc. Very Large Databases Conf. </booktitle> <address> Brisbane, AU (Aug 1990). </address>
Reference-contexts: The locking described there coped with phantoms when the predicates involved were equality predicates. Predicates that specify ranges of values were not handled. 1.2 Ranges as Lockable Granules System R performed range locking within its B-tree indexing. This is credited to Eswaran and Blasgen in [4]. Recent papers <ref> [6, 7] </ref> have described this earlier work and have introduced improvements in both concurrency and lock overhead by showing how multi-granularity lock modes can be exploited. Our work builds on these papers. <p> Unfortunately, since SIX conflicts with IX, it prevents record k i+1 from being updated, even when the key is not locked. 3.3.3 ARIES/KVL and ARIES/IM By distinguishing range from keys, we gain extra concurrency compared with ARIES/KVL <ref> [6] </ref> or ARIES/IM [7], which also use existing lock modes but do not distinguish ranges from keys. In particular, we can use an SIX lock for delete ranges instead of an X lock. Our cost is extra overhead, sometimes needing key locks as well as range locks. <p> Here, the key value identifies both itself and the range for which it is an upper bound. 4.1.1 Key Value Locks (KVL) The best locking protocol for range locking using existing MGL lock modes is ARIES/KVL <ref> [6] </ref>. It does not distinguish range from key lock modes. usually locks with modes which are the least upper bound of the range and key lock modes on the separate resources are used. <p> Then, one might, for example, insert a new rid into a set of rids associated with a key anywhere that was convenient. The result, however, is a more complex protocol. ARIES/KVL <ref> [6] </ref> discusses the nonunique key case when keys, not records, are the lockable resources, and illustrates the less restrictive locking that might be exploited. The concurrency advantages of the ARIES/KVL approach versus ordering entries by &lt; key; rid &gt; and using KRL locking are not clear.
Reference: [7] <author> Mohan, C. and Levine, F. ARIES/IM: </author> <title> an efficient and high concurrency index management method using write-ahead logging. </title> <institution> IBM Research Report RJ 6846, (Aug 1989) Almaden Research Center, </institution> <address> San Jose, CA. </address>
Reference-contexts: The locking described there coped with phantoms when the predicates involved were equality predicates. Predicates that specify ranges of values were not handled. 1.2 Ranges as Lockable Granules System R performed range locking within its B-tree indexing. This is credited to Eswaran and Blasgen in [4]. Recent papers <ref> [6, 7] </ref> have described this earlier work and have introduced improvements in both concurrency and lock overhead by showing how multi-granularity lock modes can be exploited. Our work builds on these papers. <p> Unfortunately, since SIX conflicts with IX, it prevents record k i+1 from being updated, even when the key is not locked. 3.3.3 ARIES/KVL and ARIES/IM By distinguishing range from keys, we gain extra concurrency compared with ARIES/KVL [6] or ARIES/IM <ref> [7] </ref>, which also use existing lock modes but do not distinguish ranges from keys. In particular, we can use an SIX lock for delete ranges instead of an X lock. Our cost is extra overhead, sometimes needing key locks as well as range locks. <p> One solution is to acquire record locks as well as key/range locks in an index. 4.2.2 Record Locks One can short circuit the additional locking described above by treating the lock needed for range, key, and record as a single resource, as proposed in ARIES/IM <ref> [7] </ref>, described briefly below. The penalty of doing such consolidation of resources is less concurrency. Can KRL locking be applied when this is done? The answer is yes. ARIES/IM uses a lock on a record identifier instead of a key value lock as the way to lock a range.
References-found: 7

