URL: http://www.cs.vt.edu/~chitra/docs/95tr-15.ps.gz
Refering-URL: http://www.cs.vt.edu/~chitra/PublicationList.html
Root-URL: http://www.cs.vt.edu
Email: abrams@cs.vt.edu  
Title: Geometric Performance Analysis of Periodic Behavior in Detail  
Author: Marc Abrams 
Date: September 5, 1995  
Address: VA 24061-0106  
Affiliation: Computer Science Department, Virginia Tech, Blacksburg,  
Abstract: A fundamental problem in designing parallel programs that achieve a desired performance goal is the ability to exactly analyze program performance, given a specification of the process synchronization structure and the execution timings of all code segments. This paper presents a novel performance analysis method based on geometry. Given a definition of program state, an execution of a program can be represented by a timed execution sequence (TES). A TES is a sequence of states that the program passes through in an execution, along with the duration of time spent in each state. In some parallel programs, all TESs that can arise in any execution contain a suffix that consists of the repetition of a finite sequence of states, excluding deadlocks and nondeterministic behavior. The repeated sequence is termed the limit cycle execution sequence. This paper derives, for all possible process starting times, a representation of the set of all possible limit cycle execution sequences in which a process blocks. The paper makes two contributions. First, it employs a novel analysis method to derive TESs from a geometric program execution model, using timed progress graphs (TPGs). TPGs represent the progress of each process by an axis in a Cartesian graph; process synchronization by line segments; and a TES by a directed, continuous path that does not cross a segment. Second, it solves for TESs in TPGSs not by a computational geometric algorithm, as employed by most solutions in the literature to (untimed) progress graphs, but by an analytic solution.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abrams. </author> <title> Performance Analysis of Unconditionally Synchronizing Distributed Computer Programs Using The Geometric Concurrency Model. </title> <type> PhD thesis, </type> <institution> Computer Sci. Dept., Univ. of MD, </institution> <month> Aug. </month> <year> 1986. </year> <month> TR-1696. </month>
Reference-contexts: The program was executed on a shared memory multiprocessor (a Sequent Symmetry), and produces a LCES with up to nine philosophers. The second <ref> [1, Ch. 6] </ref> uses a dining philosophers algorithm in which each resource is controlled by a separate monitor process that runs on a dedicated processor. <p> One may ask how accurately the TPGs of this paper model programs that are otherwise representable as timed transition diagrams. Our experience so far indicates that the model is highly accurate <ref> [1, 4] </ref>. Open problems include relaxing the assumptions in x1.3 to permit geometric modeling of a broader class of programs; characterizing the necessary and sufficient conditions for a program to reach a LCES; and model analysis for irrational cycle times 0 and 1 (Chaotic behavior may exist for these values.).
Reference: [2] <author> M. Abrams. </author> <title> An example of deriving performance properties from a visual represention of program execution. </title> <type> Technical Report TR 95-09, </type> <institution> Computer Sci. Dept., Virginia Tech, Blacksburg, </institution> <address> VA 24061-0106, </address> <month> June </month> <year> 1995. </year> <note> Available from World Wide Web location http://www.cs.vt.edu/reports. </note>
Reference-contexts: The assumptions give sufficient (but not necessary) conditions for a program to always reaches a LCES if it does not deadlock, excluding nondeterministic behavior. The assumptions are sufficient but not necessary conditions because they can be relaxed. For example, <ref> [2, Fig. 1] </ref> shows a program that uses message passing with one buffer for inter-process communication (violating A2.3 and A3) that reaches a LCES. The assumptions are, however, necessary and sufficient to use the geometric performance modeling approach and the analytic solution of this paper. <p> Because we develop our solution method by starting with a program as a transition system, we lay the foundation for relaxing the remaining assumptions to study other parallel program classes with geometry (see <ref> [2] </ref> for other programs). Timed Progress Graphs: We propose a novel way to analyze program performance: using timed progress graphs (TPG). <p> ((8; 0); (10; 0)) dead point (13; 4) Table 1: Behaviors present in Fig. 8 TPGS. f 2m (X) (4,1) (9,4) unnecessary (1,2) (4,4) (9,7) Table 2: Quantities required by Algorithm A0 for Fig. 5 (b). algorithm A0 below is a solution to (2); (1) is addressed in part in <ref> [2] </ref>. The algorithm uses the following notation. For any point G, if jjf (G)jj = 1 ^ f (G) = fG 0 g, we drop the set notation and write f (G) = G 0 . <p> We use here a predominately analytic method. The method is not purely analytic because the formula for C L (f (X)) is based on a list of constraint line intersections, obtained from a computational geometric algorithm. A purely computational geometric method is given in <ref> [2] </ref>, based on ray shooting. Finding g (G) is equivalent to the following integer programming problem: minimize the length of a slope one diagonal ray rooted at G subject to the constraint that the final ray point lies on some constraint line generated by an element of fl.
Reference: [3] <author> M. Abrams and A. K. Agrawala. </author> <title> Performance study of distributed resource sharing algorithms. </title> <journal> IEEE Dist. Processing Technical Committee Newsletter, </journal> <volume> 7(3) </volume> <pages> 18-26, </pages> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Periodic behavior has been observed experimentally several times in the literature: in queue length and packet traffic in a communication protocol [39]; in periodic tasks, such as operating system daemons [10]; in a commercial TCP/IP protocol [5]; and in dining philosophers programs <ref> [3, 5] </ref>. fl This work was supported in part by National Science Foundation grant NCR-9211342. 1 Geometric Performance Analysis of Periodic Behavior in Detail 2 1.1 Related Work Three methods of deriving performance measures from programs given a representation of process synchronization structure and code segment timings are simulation, logic, and
Reference: [4] <author> M. Abrams and A. K. Agrawala. </author> <title> Automated measurement and prediction of unconditionally synchronizing distributed algorithms. </title> <booktitle> In Proc. of the 7th International Conf. on Distributed Computing Systems, </booktitle> <pages> pages 498-505, </pages> <address> Berlin, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: One may ask how accurately the TPGs of this paper model programs that are otherwise representable as timed transition diagrams. Our experience so far indicates that the model is highly accurate <ref> [1, 4] </ref>. Open problems include relaxing the assumptions in x1.3 to permit geometric modeling of a broader class of programs; characterizing the necessary and sufficient conditions for a program to reach a LCES; and model analysis for irrational cycle times 0 and 1 (Chaotic behavior may exist for these values.).
Reference: [5] <author> M. Abrams, N. Doraswamy, and A. Mathur. Chitra: </author> <title> Visual analysis of parallel and distributed programs in the time, event, and frequency domain. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 3(6) </volume> <pages> 672-685, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Periodic behavior has been observed experimentally several times in the literature: in queue length and packet traffic in a communication protocol [39]; in periodic tasks, such as operating system daemons [10]; in a commercial TCP/IP protocol <ref> [5] </ref>; and in dining philosophers programs [3, 5]. fl This work was supported in part by National Science Foundation grant NCR-9211342. 1 Geometric Performance Analysis of Periodic Behavior in Detail 2 1.1 Related Work Three methods of deriving performance measures from programs given a representation of process synchronization structure and code <p> Periodic behavior has been observed experimentally several times in the literature: in queue length and packet traffic in a communication protocol [39]; in periodic tasks, such as operating system daemons [10]; in a commercial TCP/IP protocol [5]; and in dining philosophers programs <ref> [3, 5] </ref>. fl This work was supported in part by National Science Foundation grant NCR-9211342. 1 Geometric Performance Analysis of Periodic Behavior in Detail 2 1.1 Related Work Three methods of deriving performance measures from programs given a representation of process synchronization structure and code segment timings are simulation, logic, and <p> Dynamic systems may reach a limit cycle behavior, analogous to the repetitions of limit cycle execution trajectories studied here. Furthermore, we have some experimental evidence of the similarity from two sets of experiments. The first <ref> [5] </ref> uses a dining philosophers program similar to Fig. 6, except that spinlocks rather than binary semaphores are used, and the order of acquiring and releasing spinlocks differs from the order of semaphores shown in the figure.
Reference: [6] <author> V. S. Adve and M. K. Vernon. </author> <title> The influence of random delays on parallel execution times. </title> <booktitle> In Proc. SIGMETRICS, </booktitle> <pages> pages 61-73, </pages> <address> Santa Clara, CA, </address> <month> June </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: Chandy and Misra [12] view all computations as non-terminating transition systems that reach a fixed point. Regarding A2.5, Adve and Vernon <ref> [6] </ref> conclude based on seven parallel applications that "it appears reasonable to ignore the variability in execution times when estimating synchronization delays." Furthermore, an exponential task time assumption could actually lead to more severe errors than a constant-time assumption.
Reference: [7] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., <ref> [7] </ref>), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., [8, 22]), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]).
Reference: [8] <author> G. Balbo, G. Chiola, and S. C. Bruell. </author> <title> An example of model and evaluation of a concurrent program using colored stochastic Petri nets: Lamport's fast mutual exclusion algorithm. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 3(2) </volume> <pages> 221-240, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., <ref> [8, 22] </ref>), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]). <p> The assumptions are, however, necessary and sufficient to use the geometric performance modeling approach and the analytic solution of this paper. We argue next that the assumptions are not unreasonable. Although the analysis is constrained to two processes (A1), a recent performance analysis of Lamport's mutual exclusion algorithm <ref> [8] </ref> using Petri nets requires so much computation that its numeric solution is limited to only four processes. In addition, the initial solutions to other problems in parallel programming such as shared memory mutual exclusion algorithms were initially solved only for two processes.
Reference: [9] <author> J. L. Bentley and T. A. Ottman. </author> <title> Algorithms for reporting and counting geometric intersections. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-28(9):643-647, </volume> <month> Sept. </month> <year> 1978. </year>
Reference-contexts: Applying the definition of C N and simplifying yields the expression for C L in the theorem. 2 Known computational geometric algorithms for reporting intersections of line segments (e.g., <ref> [9] </ref>) may be used to compute h8L; 8L 0 : L 2 fl ^ L 0 2 fl ^ L 6= L 0 :: L " L 0 i, which is required in Theorem 2. 7.2 Analytic Solution of C R (G), g (G), and g (f (G)) The solution method <p> Step A2.0: Step A2.0 requires O (N ) time due to the universal quantifier. Step A2.1: The intersection may be computed using an algorithm that reports the points of intersection of horizontal and vertical line segments (e.g., algorithm 4.1 in <ref> [9] </ref>). Rather than reporting all intersections, the algorithm is modified to store in ML [K] the intersection point furthest from the origin found so far for the instance of constraint line K that the algorithm considers.
Reference: [10] <author> R. F. Berry and J. L. Hellerstein. </author> <title> Characterizing and interpreting periodic behavior in computer systems. </title> <booktitle> In Proc. SIGMETRICS, </booktitle> <pages> pages 241-242, </pages> <address> Newport, RI, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: The chief assumption is that the program displays periodic behavior: processes loop forever repeating the same code segments. Periodic behavior has been observed experimentally several times in the literature: in queue length and packet traffic in a communication protocol [39]; in periodic tasks, such as operating system daemons <ref> [10] </ref>; in a commercial TCP/IP protocol [5]; and in dining philosophers programs [3, 5]. fl This work was supported in part by National Science Foundation grant NCR-9211342. 1 Geometric Performance Analysis of Periodic Behavior in Detail 2 1.1 Related Work Three methods of deriving performance measures from programs given a representation
Reference: [11] <author> S. D. Carson and J. P. F. Reynolds. </author> <title> The geometry of semaphore programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 25-53, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: A TPG adds timing information to an untimed progress graph (UPG), which Carson and Reynolds define as "a multidimensional, Cartesian graph in which the progress of each of a set of concurrent processes is measured along an independent time axis" <ref> [11] </ref>. To our knowledge, TPGs were first used in operations research to find schedules that minimize the last job completion time in a job shop with two jobs and an arbitrary number of machines [33, pp. 262-263]. <p> UPGs were later used by Dijkstra [13] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood [24, 28, 37, 38] to detect deadlocks in lock-based transaction systems; and Carson and Reynolds <ref> [11] </ref> to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. TPGs differ from UPGs in two ways: First, TPGs represent the time required for transitions, which permits performance analysis. <p> One final distinction is that we do not use a computational geometric algorithm to analyze progress graphs, as do most past solutions, but rather derive an analytic solution based on number theory. Combining Carson and Reynold's <ref> [11] </ref> work with this paper shows that one model can be used to verify both liveness and analyze performance of semaphore programs. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [11, 24, 28, 37, 38] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [20]. Time is represented by nonnegative real numbers. <p> Presented in 2 Carson and Reynolds' deadlock detection algorithm <ref> [11] </ref> cannot directly be applied, because a consequence of the Geometric Performance Analysis of Periodic Behavior in Detail 13 For initial point: TET contains: on ((0; 5); (0; 10)) non-blocking limit cycle (0; 5) nondeterministic point at (7; 12) on ((0; 2); (0; 5)) blocking limit cycle (0; 2) nondeterministic point <p> To illustrate, consider the three database transactions used by Lipski and Papadimitriou (Fig. 11 in [24]) and later by Carson and Reynolds (Appendix in <ref> [11] </ref>). A TET in three dimensions can be constructed by drawing one TPG for every pair of processes, as shown in Fig. 14. (See [24] for a true three dimensional sketch.) Each axis in each graph is labeled by one of three transaction numbers (T1, T2, or T3).
Reference: [12] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: As for A2.2, certain programs can be considered non-terminating for the purpose of analysis: long running programs that execute the same code repeatedly, such as simulations, and reactive programs <ref> [12] </ref>, such as operating system algorithms, that react to external stimuli. Chandy and Misra [12] view all computations as non-terminating transition systems that reach a fixed point. <p> As for A2.2, certain programs can be considered non-terminating for the purpose of analysis: long running programs that execute the same code repeatedly, such as simulations, and reactive programs <ref> [12] </ref>, such as operating system algorithms, that react to external stimuli. Chandy and Misra [12] view all computations as non-terminating transition systems that reach a fixed point. <p> t i ! r ? i 1, for i 0, is that if, for exactly t i r time units, control of process r has resided at vertex i, then control will move to vertex i 1 at the earliest time at which the 1 We use the notation from <ref> [12] </ref> h &lt;quantified variable&gt; : &lt;domain of quantification&gt; :: &lt;quantified formula&gt; i, and omit &lt;domain of quantification&gt; when it is obvious from context. Geometric Performance Analysis of Periodic Behavior in Detail 8 control point of process r is not a label in c i r .
Reference: [13] <author> E. G. Coffman, M. J. Elphick, and A. Shoshani. </author> <title> System deadlocks. </title> <journal> ACM Comp. Surv., </journal> <volume> 3(2) </volume> <pages> 70-71, </pages> <month> June </month> <year> 1971. </year> <title> Geometric Performance Analysis of Periodic Behavior in Detail 24 </title>
Reference-contexts: To our knowledge, TPGs were first used in operations research to find schedules that minimize the last job completion time in a job shop with two jobs and an arbitrary number of machines [33, pp. 262-263]. UPGs were later used by Dijkstra <ref> [13] </ref> to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood [24, 28, 37, 38] to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [11] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4.
Reference: [14] <author> E. W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <type> Technical Report EWD-123, </type> <institution> Technological University, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1965. </year>
Reference-contexts: proved. x9 illustrates that TPGs can be used to calculate TESs for programs with more than two processes; however the algorithm proposed here to find all blocking LCESs can no longer be used. 2 Illustration of Solution Method We illustrate our approach using Dijkstra's dining philosophers problem with two philosophers <ref> [14] </ref>. Two philosophers eating a meal share two chopsticks. A philosopher must wait upon attempting to acquire the chopsticks while the other is eating. Figure 1 shows a program solution in which P and V operations on a semaphore correspond to acquiring and releasing chopsticks, respectively.
Reference: [15] <author> E. W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 67-68. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: A2: Each process meets the following assumptions: (A2.1) A process executes on a dedicated processor. (A2.2) A process executes a nonterminating loop. (A2.3) A process synchronizes with other processes through binary semaphores <ref> [15] </ref>. (A2.4) Binary semaphore operations are executed unconditionally. (A2.5) The execution time of each code segment within each process that either (1) starts at the initial statement of the loop body and continues to and includes the first semaphore operation, or (2) follows each semaphore operation and continues to and includes
Reference: [16] <author> E. Gelenbe, A. Lichnewsky, and A. Staphylopatis. </author> <title> Experience with the parallel solution of partial differential equations on a distributed computing system. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-31(12):1157-1164, </volume> <month> Dec. </month> <year> 1982. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., [8, 22]), stochastic processes (e.g., <ref> [16] </ref>), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]). Of these, consistent Petri nets (i.e., nets that return to their initial marking) in which a deterministic firing time is associated with each transition are most related to this paper.
Reference: [17] <author> R. Govindarajan and G. R. Gao. </author> <title> A novel framework for multi-rate scheduling in dsp applications. </title> <booktitle> In Proc. Inter. Conf. on Application-Specific Array Processors, </booktitle> <pages> pages 77-88, </pages> <address> Venice, Italy, Oct. 1993. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., [8, 22]), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., <ref> [17, 32] </ref>). Of these, consistent Petri nets (i.e., nets that return to their initial marking) in which a deterministic firing time is associated with each transition are most related to this paper.
Reference: [18] <editor> G. Haring and G. Kotsis, editors. </editor> <booktitle> Performance Measurement and Visualization of Parallel Systems, volume 7 of Advances in Parallel Computing. </booktitle> <publisher> North-Holland, </publisher> <address> Moravany, Czechoslovakia, </address> <year> 1993. </year> <booktitle> Proc. of the Workshop on Performance Measurement and Visualization, </booktitle> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: In fact, the idea of analyzing execution sequences is quite popular, as witnessed by recent work on software performance visualization systems (e.g., <ref> [18, 35] </ref>) that include the ability to display program event traces.
Reference: [19] <author> P. Heidelberger and K. S. Trivedi. </author> <title> Analytic queueing models for programs with internal concurrency. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-32(1):73-82, </volume> <month> Jan. </month> <year> 1983. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., [8, 22]), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., <ref> [19] </ref>), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]). Of these, consistent Petri nets (i.e., nets that return to their initial marking) in which a deterministic firing time is associated with each transition are most related to this paper.
Reference: [20] <author> T. A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal proof methodologies for timed transition systems. </title> <type> Technical Report TR 93-1330, </type> <institution> Dept. of Comp. Sci., Cornell Univ., </institution> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: Given an initial state, simulation steps through an initial subsequence of one possible execution sequence. Uses of logic include Henzinger, Manna, and Pnueli's <ref> [20] </ref> proof system for real time systems using lower and upper bounds on transition times, Shaw's [34] extension of Hoare logic to reason about time in software; and Ramshaw's [31] generation of recurrence equations about program timings using Hoare style axioms. <p> Because UPGs have been used extensively for analysis of deadlocks [11, 24, 28, 37, 38], deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams <ref> [20] </ref>. Time is represented by nonnegative real numbers. Let R, R + , and Z denote, respectively, the set of nonnegative reals, positive reals, and nonnegative integers. We assume that h8n : n 2 Z :: n 1i 1 to simplify our notation.
Reference: [21] <author> T. J. Hickey, J. Cohen, H. Hotta, and T. Petitjean. </author> <title> Computer-assisted microanalysis of parallel programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 14(1) </volume> <pages> 54-106, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., <ref> [21] </ref>), Petri nets (e.g., [8, 22]), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]).
Reference: [22] <author> M. A. Holliday and M. K. Vernon. </author> <title> A generalized timed Petri net model for performance analysis. </title> <booktitle> In Proc. Int. Workshop on Timed Petri Nets, </booktitle> <month> July </month> <year> 1985. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., <ref> [8, 22] </ref>), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]). <p> Also proved are complexity results for systems of processes with communication by buffers. The problem considered here, of processes synchronizing only to achieve mutual exclusion, cannot be represented by decision-free or persistent Petri nets. Instead, Holliday and Vernon <ref> [22] </ref> use Petri nets with frequency expressions (i.e., probabilities) to resolve deterministically which transition fires when a token enables two or more transitions simultaneously. 1.2 Problem Statement Let the state of a program be the control point of each process.
Reference: [23] <author> B. W. Jones. </author> <title> The Theory of Numbers. </title> <publisher> Rinehart, </publisher> <address> New York, </address> <year> 1955. </year>
Reference-contexts: Therefore equation (6) is a Diophantine equation. A necessary and sufficient condition for a solution to equation (6) to exist is that the greatest common divisor of 1 and 0 divides s 0 , by Jones' Theorem 3.3 <ref> [23] </ref>. Therefore a solution exists iff interval I (G; W; X) contains an integer value. Applying equation (1) establishes the following theorem. <p> The rewritting is done Geometric Performance Analysis of Periodic Behavior in Detail 19 by expressing unknown i 1 in terms of unknown s 0 and an integer parameter ff by applying the solution technique for three variable Diophantine equations in <ref> [23] </ref>, pp. 67-68. There are an infinite number of solutions, which parameter ff expresses. The solution to (6) is i 1 = us 0 + 0 ff; (9) where u is an integer satisfying 1 u 1 (mod 0 ).
Reference: [24] <author> W. Lipski and C. H. Papadimitriou. </author> <title> A fast algorithm for testing for safety and detecting deadlocks in locked transaction systems. </title> <journal> J. Alg., </journal> <volume> 2(3) </volume> <pages> 211-226, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: UPGs were later used by Dijkstra [13] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [24, 28, 37, 38] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [11] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [11, 24, 28, 37, 38] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [20]. Time is represented by nonnegative real numbers. <p> To illustrate, consider the three database transactions used by Lipski and Papadimitriou (Fig. 11 in <ref> [24] </ref>) and later by Carson and Reynolds (Appendix in [11]). A TET in three dimensions can be constructed by drawing one TPG for every pair of processes, as shown in Fig. 14. (See [24] for a true three dimensional sketch.) Each axis in each graph is labeled by one of three <p> To illustrate, consider the three database transactions used by Lipski and Papadimitriou (Fig. 11 in <ref> [24] </ref>) and later by Carson and Reynolds (Appendix in [11]). A TET in three dimensions can be constructed by drawing one TPG for every pair of processes, as shown in Fig. 14. (See [24] for a true three dimensional sketch.) Each axis in each graph is labeled by one of three transaction numbers (T1, T2, or T3). We denote the graphs as 1 fi 2 (for the graph with axes T1 and T2), 1 fi 3, and 3 fi 2.
Reference: [25] <author> J. Magott. </author> <title> Performance evaluation of concurrent systems using Petri nets. </title> <journal> Information Processing Letters, </journal> <volume> 18 </volume> <pages> 7-13, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: Methods to compute bounds on the MCT of conservative, general Petri nets are given; finding the exact value is proved NP-complete. Magott <ref> [25] </ref> formulates the MCT problem for decision-free and persistent Petri nets as a linear programming problem, and therefore solvable in polynomial time. He gives an improved lower bound and shows that it also applies to non-conservative general Petri nets.
Reference: [26] <author> J. Magott. </author> <title> Performance evaluation of systems of cyclic processes with mutual exclusion using Petri nets. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 229-232, </pages> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Magott [25] formulates the MCT problem for decision-free and persistent Petri nets as a linear programming problem, and therefore solvable in polynomial time. He gives an improved lower bound and shows that it also applies to non-conservative general Petri nets. Magott <ref> [26] </ref> gives an O (N ) algorithm to compute MCT for nets consisting of a set of N cyclic processes that mutually exclusively share a single resource. Finally, Magott [27] extends his earlier paper [26] by showing that finding MCT in most nets with more complex resource sharing is NP-hard. <p> Magott <ref> [26] </ref> gives an O (N ) algorithm to compute MCT for nets consisting of a set of N cyclic processes that mutually exclusively share a single resource. Finally, Magott [27] extends his earlier paper [26] by showing that finding MCT in most nets with more complex resource sharing is NP-hard. Also proved are complexity results for systems of processes with communication by buffers. The problem considered here, of processes synchronizing only to achieve mutual exclusion, cannot be represented by decision-free or persistent Petri nets.
Reference: [27] <author> J. Magott. </author> <title> Performance evaluation of systems of cyclic sequential processes with mutual exclusion and communication by buffers using timed Petri nets. </title> <booktitle> In Proc. Int. Workshop on Timed Petri Nets, </booktitle> <pages> pages 146-153, </pages> <address> Madison WI, 1987. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: He gives an improved lower bound and shows that it also applies to non-conservative general Petri nets. Magott [26] gives an O (N ) algorithm to compute MCT for nets consisting of a set of N cyclic processes that mutually exclusively share a single resource. Finally, Magott <ref> [27] </ref> extends his earlier paper [26] by showing that finding MCT in most nets with more complex resource sharing is NP-hard. Also proved are complexity results for systems of processes with communication by buffers.
Reference: [28] <author> C. H. Papadimitriou. </author> <title> Concurrency control by locking. </title> <journal> SIAM J. on Computing, </journal> <volume> 12(2) </volume> <pages> 215-226, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: UPGs were later used by Dijkstra [13] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [24, 28, 37, 38] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [11] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [11, 24, 28, 37, 38] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [20]. Time is represented by nonnegative real numbers.
Reference: [29] <author> B. Plateau and K. Atif. </author> <title> Stochastic automata network for modeling parallel systems. </title> <journal> IEEE Trans. on Software Engineering, </journal> 1991(10) 1093-1109, Oct. 1991. 
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., [8, 22]), stochastic processes (e.g., [16]), stochastic automata <ref> [29] </ref>, queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., [17, 32]). Of these, consistent Petri nets (i.e., nets that return to their initial marking) in which a deterministic firing time is associated with each transition are most related to this paper.
Reference: [30] <author> C. V. Ramamoorthy and G. S. Ho. </author> <title> Performance evaluation of asynchronous concurrent systems using Petri nets. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-6(5):440-448, </volume> <month> Sept. </month> <year> 1980. </year>
Reference-contexts: Of these, consistent Petri nets (i.e., nets that return to their initial marking) in which a deterministic firing time is associated with each transition are most related to this paper. Ramamoorthy and Ho <ref> [30] </ref> consider minimum cycle time (MCT) calculation, or the minimum time required for the program to return to its initial state (corresponding to an initial marking of the Petri net).
Reference: [31] <author> L. H. Ramshaw. </author> <title> Formalizing the Analysis of Algorithms. </title> <type> PhD thesis, </type> <institution> Computer Sci. Dept., Stanford Univ., </institution> <month> June </month> <year> 1979. </year> <month> STAN-CS-79-741. </month>
Reference-contexts: Uses of logic include Henzinger, Manna, and Pnueli's [20] proof system for real time systems using lower and upper bounds on transition times, Shaw's [34] extension of Hoare logic to reason about time in software; and Ramshaw's <ref> [31] </ref> generation of recurrence equations about program timings using Hoare style axioms.
Reference: [32] <author> R. Reiter. </author> <title> Scheduling parallel computations. </title> <journal> JACM, </journal> <volume> 15(4) </volume> <pages> 590-599, </pages> <month> Oct. </month> <year> 1968. </year> <title> Geometric Performance Analysis of Periodic Behavior in Detail 25 </title>
Reference-contexts: Analytic methods include complexity analysis (e.g., [7]), micro-analysis using difference equations (e.g., [21]), Petri nets (e.g., [8, 22]), stochastic processes (e.g., [16]), stochastic automata [29], queueing networks (e.g., [19]), and analysis of graphs whose nodes represent code segments (e.g., <ref> [17, 32] </ref>). Of these, consistent Petri nets (i.e., nets that return to their initial marking) in which a deterministic firing time is associated with each transition are most related to this paper.
Reference: [33] <author> M. Sasieni, A. Yaspan, and L. Friedman. </author> <title> Operations Research Methods and Problems. </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1959. </year>
Reference-contexts: To our knowledge, TPGs were first used in operations research to find schedules that minimize the last job completion time in a job shop with two jobs and an arbitrary number of machines <ref> [33, pp. 262-263] </ref>.
Reference: [34] <author> A. J. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Given an initial state, simulation steps through an initial subsequence of one possible execution sequence. Uses of logic include Henzinger, Manna, and Pnueli's [20] proof system for real time systems using lower and upper bounds on transition times, Shaw's <ref> [34] </ref> extension of Hoare logic to reason about time in software; and Ramshaw's [31] generation of recurrence equations about program timings using Hoare style axioms.
Reference: [35] <author> M. Simmons and R. Koskela, </author> <title> editors. Performance Instrumentation and Visualization. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year> <booktitle> Based on the Workshop on Parallel Computer Systems: Instrumentation and Visualization, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: In fact, the idea of analyzing execution sequences is quite popular, as witnessed by recent work on software performance visualization systems (e.g., <ref> [18, 35] </ref>) that include the ability to display program event traces.
Reference: [36] <author> C. J. Smith. </author> <title> Performance Engineering of Software Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction The ability to analyze program performance lies at the heart of integrating into the software development life cycle what Smith <ref> [36] </ref> terms software performance engineering. The requirements life cycle phase states performance goals. Ideally, we would like to establish whether a program under development meets the performance goals long before the integrated testing life cycle phase.
Reference: [37] <author> E. Soisalon-Soininen and D. Wood. </author> <title> An optimal algorithm for testing for safety and detecting deadlocks in locked transaction system. </title> <booktitle> In Symp. on Principles of Database Systems, </booktitle> <pages> pages 108-116, </pages> <address> Los Angeles, </address> <month> Mar. </month> <year> 1982. </year> <note> ACM. </note>
Reference-contexts: UPGs were later used by Dijkstra [13] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [24, 28, 37, 38] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [11] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [11, 24, 28, 37, 38] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [20]. Time is represented by nonnegative real numbers.
Reference: [38] <author> M. Yannakakis, C. H. Papadimitriou, and H. T. Kung. </author> <title> Locking policies: Safety and freedom from deadlock. </title> <booktitle> In 20th ACM Symp. on the Foundations of Computer Sci., </booktitle> <pages> pages 283-287, </pages> <year> 1979. </year>
Reference-contexts: UPGs were later used by Dijkstra [13] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [24, 28, 37, 38] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [11] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [11, 24, 28, 37, 38] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [20]. Time is represented by nonnegative real numbers.
Reference: [39] <author> L. Zhang, S. Shenker, and D. D. Clark. </author> <title> Observations on the dynamics of a congestion control algorithm: the effects of two-way traffic. </title> <booktitle> In Proc. SIGCOMM, </booktitle> <pages> pages 133-147, </pages> <address> Zurich, </address> <month> Sept. </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: The chief assumption is that the program displays periodic behavior: processes loop forever repeating the same code segments. Periodic behavior has been observed experimentally several times in the literature: in queue length and packet traffic in a communication protocol <ref> [39] </ref>; in periodic tasks, such as operating system daemons [10]; in a commercial TCP/IP protocol [5]; and in dining philosophers programs [3, 5]. fl This work was supported in part by National Science Foundation grant NCR-9211342. 1 Geometric Performance Analysis of Periodic Behavior in Detail 2 1.1 Related Work Three methods
References-found: 39

