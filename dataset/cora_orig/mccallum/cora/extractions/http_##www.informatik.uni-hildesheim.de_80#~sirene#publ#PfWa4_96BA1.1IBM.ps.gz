URL: http://www.informatik.uni-hildesheim.de:80/~sirene/publ/PfWa4_96BA1.1IBM.ps.gz
Refering-URL: http://www.informatik.uni-hildesheim.de:80/~sirene/lit/sirene.lit.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: pfitzb@informatik.uni-hildesheim.de  email: wmi@zurich.ibm.com  
Title: Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/ 3  
Author: Birgit Pfitzmann Michael Waidner 
Address: Samelsonplatz 1 D-31141 Hildesheim, Germany  Sumerstrasse 4 CH-8803 Rschlikon, Switzerland  
Affiliation: Research Division Almaden T.J. Watson Tokyo Zurich  Institut fr Informatik Universitt Hildesheim  IBM Research Division Zrich Research Laboratory  
Note: RZ 2882 (#90830) 11/18/96 Computer Science/Mathematics 25 pages Research Report LIMITED DISTRIBUTION NOTICE  
Abstract: This report has been submitted for publication outside of IBM and will probably be copyrighted if accepted for publication. It has been issued as a Research Report for early dissemination of its contents and will be distributed outside of IBM up to one year after the date indicated at the top of this page. In view of the transfer of copyright to the outside publisher, its distribution outside of IBM prior to publication should be limited to peer communications and specific requests. After outside publication, requests should be filled only by reprints or legally obtained copies of the article (e.g., payment of royalties). 
Abstract-found: 1
Intro-found: 1
Reference: [B71] <author> Herbert O. </author> <title> Burton: </title> <journal> Inversionless Decoding of Binary BCH Codes; IEEE Transactions on Information Theory 17/4 (1971) pp. </journal> <pages> 464-466. </pages>
Reference-contexts: Any such set is called a solution. The algorithm is described in <ref> [BB90, B71, R80] </ref>; it has a security parameter g and an error probability of at most 2 g . <p> Proof. Without loss of generality, let the correct processors be P 1 , , P k . a) It follows from <ref> [BB90, B71, R80] </ref> that for any values S 1 , S 3 , , S 2n1 , the set of equations described in Step [2] has at most one solution.
Reference: [BB90] <author> Jurjen Bos, Bert den Boer: </author> <title> Detection of Disrupters in the DC Protocol; Proc. </title> <booktitle> Eurocrypt 89, Lecture Notes in Computer Science 434, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> pp. 320-327. </pages>
Reference-contexts: Any such set is called a solution. The algorithm is described in <ref> [BB90, B71, R80] </ref>; it has a security parameter g and an error probability of at most 2 g . <p> If P j finds neither a faulty processor nor a faulty key, it outputs S faulty. Power sums were first used to reconstruct individual messages in <ref> [BB90] </ref>, but only the first n of them were used and thus faults could not be detected. A different mechanism to detect faults is used in [CR91], but its security is not proven and it is not more efficient than ours in the given application. <p> Proof. Without loss of generality, let the correct processors be P 1 , , P k . a) It follows from <ref> [BB90, B71, R80] </ref> that for any values S 1 , S 3 , , S 2n1 , the set of equations described in Step [2] has at most one solution.
Reference: [BMD93] <author> Michael Barborak, Miroslaw Malek, Anton Dahbura: </author> <booktitle> The Consensus Problem in Fault-Tolerant Computing; ACM Computing Surveys 25/2 (1993) pp. </booktitle> <pages> 171-220. </pages>
Reference-contexts: Faulty processors may behave maliciously. Byzantine agreement was introduced in [PSL80], where it was proved that perfect Byzan-tine agreement is only possible if t &lt; n/3. Many subsequent papers have studied upper and lower bounds on the attainable efficiency of such protocols, see <ref> [CD89, BMD93] </ref> for overviews. However, if digital signatures [DH76, GMR88] can be used, Byzantine agreement is possible for any t &lt; n, even in polynomial time [DS83]. Such protocols are called authenticated protocols.
Reference: [BPW91] <author> Birgit Baum-Waidner, Birgit Pfitzmann, Michael Waidner: </author> <title> Unconditional Byzantine Agreement with Good Majority; Proc. </title> <booktitle> 8th Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science 480, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, Germany, </address> <year> 1991, </year> <pages> pp. 285-295. </pages>
Reference-contexts: By [GY89], the remaining protocol therefore has an error probability of at least 1/3. Averaging over pub yields that also the complete protocol has an error probability of at least 1/3. We presented the first information-theoretic Byzantine agreement protocol for t n/3 in <ref> [BPW91] </ref>. The model is the same as here, but the number of faulty processors was still restricted to t &lt; n/2.
Reference: [BS88] <editor> Ernest F. Brickell, Doug R. Stinson: </editor> <booktitle> Authentication Codes with Multiple Arbiters; Proc. Eurocrypt 88, Lecture Notes in Computer Science 330, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1988, </year> <pages> pp. 51-55. </pages>
Reference-contexts: This is a kind of transfer to one specific party. Most of these schemes only guarantee unforgeability and the other three properties if the arbiter is correct, and are therefore not applicable in a Byzantine scenario. In <ref> [BS88] </ref>, multiple arbiters jointly decide whether a message was authenticated, and a dishonest minority of them cannot forge.
Reference: [C88] <author> David Chaum: </author> <title> The Dining Cryptographers Problem: </title> <journal> Unconditional Sender and Recipient Untrace-ability; Journal of Cryptology 1/1 (1988) pp. </journal> <pages> 65-75. </pages>
Reference-contexts: Essentially, instead of the originators processor, the recipients processors generate the keys intended for them and send them to the originators processor anonymously. The basic method for information-theoretically secure anonymous sending over an untrusted network is the DC protocol in <ref> [C88] </ref>. <p> Proof. Parts a) and b) follow from <ref> [C88] </ref>, and c) (and also a)) can easily be verified. Now the protocol is extended such that the set of all inputs, instead of their sum, can be received, and that faults can be detected and localized. <p> A different mechanism to detect faults is used in [CR91], but its security is not proven and it is not more efficient than ours in the given application. Once a fault has been detected, the localization of a faulty processor or key is as in <ref> [C88] </ref>.
Reference: [CD89] <author> Benny Chor, Cynthia Dwork: </author> <title> Randomization in Byzantine Agreement; Advances in Computing Research Vol. 5, </title> <publisher> JAI Press, </publisher> <address> Greenwich, Connecticut, </address> <year> 1989, </year> <pages> pp. 443-497. </pages>
Reference-contexts: Faulty processors may behave maliciously. Byzantine agreement was introduced in [PSL80], where it was proved that perfect Byzan-tine agreement is only possible if t &lt; n/3. Many subsequent papers have studied upper and lower bounds on the attainable efficiency of such protocols, see <ref> [CD89, BMD93] </ref> for overviews. However, if digital signatures [DH76, GMR88] can be used, Byzantine agreement is possible for any t &lt; n, even in polynomial time [DS83]. Such protocols are called authenticated protocols.
Reference: [CR91] <author> David Chaum, Sandra Roijakkers: </author> <title> Unconditionally Secure Digital Signatures; Proc. </title> <booktitle> Crypto 90, Lecture Notes in Computer Science 537, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1991, </year> <pages> pp. 206-214. </pages>
Reference-contexts: We call it pseudosignatures. We present properties and types of authentication schemes in Section 2 and the concrete construction of a pseudosignature scheme in Section 3. This construction extends and improves the scheme in <ref> [CR91] </ref>. 1 . 1 Models of Byzantine Agreement Recall that n is the number of processors and s a security parameter so that an error probability of 2 s is acceptable. Let l I N be the length of the values to be agreed upon. <p> We therefore need an additional parameter maxtest in initialization, and any correct recipients processor will carry out at most maxtest tests of pseudosignatures corresponding to this initialization. 3 Construction of Pseudosignatures In the following, we present information-theoretically secure pseudosignatures. Our scheme is a generalization of the scheme in <ref> [CR91] </ref>, which dealt with the special case of only one transfer and did not consider active attacks on recipients. 6 Furthermore, we improve some details of that scheme. <p> an independently chosen key of an information-theoretically secure authentication code with each recipients processor, and that a pseudosignature consists of n parts, called 5 It can be generalized further, e.g., by allowing a constant c &lt; 1 or even a rational transformation in the exponent. 6 In Section 5 of <ref> [CR91] </ref>, a scheme is sketched that should work for general finite transferability. <p> Implicitly, this scheme assumes that the originator of the message is honest, and thus this extension is not applicable here. (For readers familiar with <ref> [CR91, Sect. 5] </ref>: The hash functions used there are useful only if they are unknown to the faulty processors, but are known to the originator.) 10 Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/3 IBM Research Report RZ 2882 (#90830) 11/18/96 minisignatures, one for each potential recipient. <p> Forgery is obviously only possible with exponentially small probability. However, this scheme offers no transferability if the originators processor is faulty: A dishonest originator can issue a pseudosignature in which the minisignature for the first recipient is correct, but those for all other recipients are wrong. The idea in <ref> [CR91] </ref> that would guarantee at least one transfer was therefore that the originator should not know which minisignature is for whom and that there are many minisignatures for each recipient. Assume for a moment that this can be done. <p> Power sums were first used to reconstruct individual messages in [BB90], but only the first n of them were used and thus faults could not be detected. A different mechanism to detect faults is used in <ref> [CR91] </ref>, but its security is not proven and it is not more efficient than ours in the given application. Once a fault has been detected, the localization of a faulty processor or key is as in [C88].
Reference: [CW79] <author> J. Lawrence Carter, Mark N. Wegman: </author> <title> Universal Classes of Hash Functions; Journal of Computer and System Sciences 18 (1979) pp. </title> <type> 143-154. </type>
Reference-contexts: This implies |X| 2 t . In particular, we can use the authentication code of [WC81] and as its underlying strongly universal 2 class of functions the multiplicative scheme of <ref> [CW79] </ref> over GF (2 t+1 ). Then the length of authenticators is t+1 bits, and keylen (l, t) is logarithmic in l and linear in t. We only construct a one-time pseudosignature scheme, i.e., N = 1, as this will be sufficient for Byzantine agreement.
Reference: [DD91] <author> Danny Dolev, Cynthia Dwork: </author> <title> On-The-Fly Generation of Names and Communication Primitives; IBM Research Division, </title> <institution> Almaden Research Center, </institution> <address> San Jose, </address> <note> received Dec. 1991; result already referred to by P. </note> <author> Feldman and S. Micali, </author> <note> STOC 88. </note>
Reference-contexts: Broadcast in the precomputation phase: It is sketched in <ref> [DD91] </ref> that even if secret channels are given a protocol without broadcast in a precomputation phase has an error probability of at least 1/3, which is not a small error probability. <p> However, still only one transfer is possible, and thus the scheme cannot be used in known authenticated Byzantine agreement protocols for t &gt; 1. Actually, <ref> [DD91] </ref> sketches that any authentication mechanism that does not guarantee at least t transfers is insufficient for any Byzantine agreement protocol with malicious faults. An interesting related scheme is the check vector scheme of [R94]. It has an originator, one first and one or more second recipients.
Reference: [DH76] <author> Whitfield Diffie, Martin E. Hellman: </author> <booktitle> New Directions in Cryptography; IEEE Transactions on Information Theory 22/6 (1976) pp. </booktitle> <pages> 644-654. </pages>
Reference-contexts: Byzantine agreement was introduced in [PSL80], where it was proved that perfect Byzan-tine agreement is only possible if t &lt; n/3. Many subsequent papers have studied upper and lower bounds on the attainable efficiency of such protocols, see [CD89, BMD93] for overviews. However, if digital signatures <ref> [DH76, GMR88] </ref> can be used, Byzantine agreement is possible for any t &lt; n, even in polynomial time [DS83]. Such protocols are called authenticated protocols. Digital signatures exist if and only if one-way functions exist, which is an unproven computational assumption that implies PNP [R90]. <p> In practice, this seems a smaller problem than broadcast in the precomputation phase. Secret channels are not used in typical authenticated protocols, but typical concrete computational assumptions imply them: the existing authentic channels could be used for the exchange of a secret key, see <ref> [DH76, RSA78] </ref> for well-known, but not provably secure examples. <p> S ) and obtained the output acc = true, he can transfer it to any other honest recipient, i.e., if they make consistent inputs for a transfer, the second recipient will also obtain the output acc = true. 2 . 3 Existing Authentication Schemes in this Framework Digital signature schemes <ref> [DH76, GMR88] </ref> are authentication schemes with arbitrary transferability and a particularly simple structure: All transactions are noninteractive. In initialization, the originators processor executes a probabilistic algorithm gen to generate a pair (sk, pk) of a secret and a public key, and broadcasts pk to the other processors.
Reference: [DS83] <author> Danny Dolev, H. Raymond Strong: </author> <note> Authenticated Algorithms for Byzantine Agreement; SIAM Journal on Computing 12/4 (1983) pp. 656-666. </note>
Reference-contexts: Many subsequent papers have studied upper and lower bounds on the attainable efficiency of such protocols, see [CD89, BMD93] for overviews. However, if digital signatures [DH76, GMR88] can be used, Byzantine agreement is possible for any t &lt; n, even in polynomial time <ref> [DS83] </ref>. Such protocols are called authenticated protocols. Digital signatures exist if and only if one-way functions exist, which is an unproven computational assumption that implies PNP [R90]. This has led to the folklore that Byzan-tine agreement for t n/3 necessarily relies on computational assumptions. <p> The aspects we need are presented in more detail in Section 2.4. 2 . 2 Transferability Byzantine agreement protocols such as <ref> [DS83] </ref> use an additional transaction transfer that allows one recipient to transfer the authentication of a message to another recipient. The first recipient inputs (transfer, msg, id S ), the second one (test, msg, id S ). The second recipient obtains a Boolean output acc. <p> More precisely, the existence of digital signatures in this sense implies the existence of a one-way function [R90]. Authenticated Byzantine agreement protocols like <ref> [DS83] </ref> are formulated in terms of digital signatures in this sense; at least they assume that signing and transfers are noninteractive. However, one can quite easily see that any authentication scheme with arbitrary transferability could be used. (Of course, the number of rounds of the protocols would increase accordingly). <p> to P or Q; the whole information from the active attack lies in the decisions whether this node is reached in this event.) Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/3 19 IBM Research Report RZ 2882 (#90830) 11/18/96 4 Byzantine Agreement We modify the authenticated Byzantine agreement protocol from <ref> [DS83, Theorem 3] </ref> so that it can be implemented with pseudosignatures rather than with ordinary digital signatures. In particular, we determine the levels of acceptance and minimize the information that can be gained by active attacks. <p> Note that here the requirements in their original form, i.e., as predicates on sequences of inputs and outputs, are meant, not their embedding into probabilistic statements as in Section 2.4.2. Proof. The proof follows the outline in <ref> [DS83, Theorem 3] </ref>. a) Correctness. If the transmitter P 1 is correct, it sends its value as prescribed in Round [0]. This message is 1-consistent for all correct processors P i , and thus they all add v to ACC i in Round [1]. <p> First we show that if a correct processor P i relays a message M containing a value v in any round [k] (which implies k t), then v ACC j for all correct processors P j at the end. 7 In <ref> [DS83] </ref>, the signatures in k-consistent messages are not just on v, but on the entire message. Our construction results in smaller messages to be signed and does not restrict the fault tolerance.
Reference: [DY90] <author> Yvo Desmedt, Moti Yung: </author> <note> Asymmetric and Securely-Arbitrated Unconditional Authentication Systems; submitted to IEEE Transactions on Information Theory, accepted pending revisions, </note> <year> 1990. </year>
Reference-contexts: In [BS88], multiple arbiters jointly decide whether a message was authenticated, and a dishonest minority of them cannot forge. Socalled schemes with security against the arbiter [DY91, JS95] eliminate the problem of forgeability, and in <ref> [DY90] </ref> it is also shown how effectiveness of authentication can be guaranteed even if the arbiter is faulty (in initialization). However, still only one transfer is possible, and thus the scheme cannot be used in known authenticated Byzantine agreement protocols for t &gt; 1.
Reference: [DY91] <author> Yvo Desmedt, Moti Yung: </author> <title> Arbitrated Unconditionally Secure Authentication can be Unconditionally Protected Against Arbiters Attacks; Proc. </title> <booktitle> Crypto 90, Lecture Notes in Computer Science 537, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1991, </year> <pages> pp. 177-188. </pages>
Reference-contexts: In [BS88], multiple arbiters jointly decide whether a message was authenticated, and a dishonest minority of them cannot forge. Socalled schemes with security against the arbiter <ref> [DY91, JS95] </ref> eliminate the problem of forgeability, and in [DY90] it is also shown how effectiveness of authentication can be guaranteed even if the arbiter is faulty (in initialization).
Reference: [ES74] <author> Paul Erds, Joel Spencer: </author> <title> Probabilistic Methods in Combinatorics; Probability and Mathematical Statistics 17, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: This happens with probability P (g, h) := B h (min-xg, g+hxD1-) B h ( 2 h 2 For each d 0, it follows from <ref> [ES74, Equation (3.8)] </ref> that B h ( 2 1 ) ( z ) 2 h &lt; exp ( h This implies P (g, h) &lt; exp ( 2h To prove P (g, h) 2 r * , it therefore remains to be shown that D 2 2hr * ln (2).
Reference: [GJ79] <author> Michael R. Garey, David S. Johnson: </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness; W. </title> <editor> H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Initialization usually is only for one recipient, i.e., ids R is this recipients identity. Either of the originators and the recipients processor executes a probabilistic algorithm gen to generate a key ak and sends it to the other processor. 3 Roughly, this means NP for search problems; see <ref> [GJ79] </ref>.
Reference: [GMR88] <author> Shafi Goldwasser, Silvio Micali, Ronald L. Rivest: </author> <title> A Digital Signature Scheme Secure Against Adaptive Chosen-Message Attacks; SIAM Journal on Computing 17/2 (1988) pp. </title> <type> 281-308. </type>
Reference-contexts: Byzantine agreement was introduced in [PSL80], where it was proved that perfect Byzan-tine agreement is only possible if t &lt; n/3. Many subsequent papers have studied upper and lower bounds on the attainable efficiency of such protocols, see [CD89, BMD93] for overviews. However, if digital signatures <ref> [DH76, GMR88] </ref> can be used, Byzantine agreement is possible for any t &lt; n, even in polynomial time [DS83]. Such protocols are called authenticated protocols. Digital signatures exist if and only if one-way functions exist, which is an unproven computational assumption that implies PNP [R90]. <p> S ) and obtained the output acc = true, he can transfer it to any other honest recipient, i.e., if they make consistent inputs for a transfer, the second recipient will also obtain the output acc = true. 2 . 3 Existing Authentication Schemes in this Framework Digital signature schemes <ref> [DH76, GMR88] </ref> are authentication schemes with arbitrary transferability and a particularly simple structure: All transactions are noninteractive. In initialization, the originators processor executes a probabilistic algorithm gen to generate a pair (sk, pk) of a secret and a public key, and broadcasts pk to the other processors. <p> the second recipient inputs (test, msg, id S , l), the second recipient also obtains the output acc = true. 2 . 4 . 2 Active Attacks Restricted active attacks on recipients may sound strange at first, because with ordinary digital signature schemes, active attacks are only considered against originators <ref> [GMR88] </ref>. However, in a more general authentication scheme, in which recipients processors also have secrets, active attacks against them must also be considered.
Reference: [GMS74] <author> E. N. Gilbert, F. J. Mac Williams, N. J. A. Sloane: </author> <title> Codes which Detect Deception; The Bell System Technical Journal 53/3 (1974) pp. </title> <type> 405-424. </type>
Reference-contexts: Thus any such scheme in which all five requirements were fulfilled information-theoretically would easily yield information-theoretic Byzantine agreement for any t. Let us now investigate known authentication schemes with information-theoretic security. Socalled authentication codes have been known for a long time <ref> [GMS74, WC81] </ref>. In the following, we will need them as subprotocols. Initialization usually is only for one recipient, i.e., ids R is this recipients identity.
Reference: [GY89] <author> Ronald L. Graham, Andrew C. Yao: </author> <title> On the Improbability of Reaching Byzantine Agreements; Proc. </title> <booktitle> 21st Symposium on Theory of Computing (STOC), ACM, </booktitle> <address> New York, </address> <year> 1989, </year> <pages> pp. 467-478. </pages>
Reference-contexts: Broadcast in the precomputation phase: It is sketched in [DD91] that even if secret channels are given a protocol without broadcast in a precomputation phase has an error probability of at least 1/3, which is not a small error probability. The best published result is <ref> [GY89] </ref>, building upon unpublished work by Karlin and Yao; it shows a slightly larger error proba bility if no secret channels are given. Secret channels in the precomputation phase: We show that the result of [GY89] can be used even if there is broadcast in a precomputation phase. <p> The best published result is <ref> [GY89] </ref>, building upon unpublished work by Karlin and Yao; it shows a slightly larger error proba bility if no secret channels are given. Secret channels in the precomputation phase: We show that the result of [GY89] can be used even if there is broadcast in a precomputation phase. Let pub denote the entire data sent during an execution of the precomputation. <p> This is possible because the result in <ref> [GY89] </ref> does not rely on restrictions on the computational abilities of the correct processors. By [GY89], the remaining protocol therefore has an error probability of at least 1/3. Averaging over pub yields that also the complete protocol has an error probability of at least 1/3. <p> This is possible because the result in <ref> [GY89] </ref> does not rely on restrictions on the computational abilities of the correct processors. By [GY89], the remaining protocol therefore has an error probability of at least 1/3. Averaging over pub yields that also the complete protocol has an error probability of at least 1/3. We presented the first information-theoretic Byzantine agreement protocol for t n/3 in [BPW91].
Reference: [IR89] <author> Russell Impagliazzo, Steven Rudich: </author> <title> Limits on the Provable Consequences of One-way Permutations; Proc. </title> <booktitle> 21st Symposium on Theory of Computing (STOC), ACM, </booktitle> <address> New York, </address> <year> 1989, </year> <pages> pp. 44-61. </pages>
Reference-contexts: However, secret key exchange is not known to exist under equally weak conditions as digital signatures <ref> [IR89] </ref>. 1 . 2 Optimality of Our Result We now show that our model is optimal for information-theoretic Byzantine agreement with t n/3, i.e., it is not possible to eliminate any of the remaining restrictions.
Reference: [JS95] <author> Thomas Johansson, Ben Smeets: </author> <booktitle> On A^2-Codes Including Arbiters Attacks; Proc. Eurocrypt 94, Lecture Notes in Computer Science 950, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1995, </year> <pages> pp. 456-460. </pages>
Reference-contexts: In [BS88], multiple arbiters jointly decide whether a message was authenticated, and a dishonest minority of them cannot forge. Socalled schemes with security against the arbiter <ref> [DY91, JS95] </ref> eliminate the problem of forgeability, and in [DY90] it is also shown how effectiveness of authentication can be guaranteed even if the arbiter is faulty (in initialization).
Reference: [LSP82] <author> Leslie Lamport, Robert Shostak, Marshall Pease: </author> <booktitle> The Byzantine Generals Problem; ACM Transactions on Programming Languages and Systems 4/3 (1982) pp. </booktitle> <pages> 382-401. </pages>
Reference-contexts: It depends on the application whether one can implement it or has to hope that t &lt; n/3. In some applications, however, it is quite realistic. The Byzantine generals of the original example in <ref> [LSP82] </ref> could carry out a precomputation phase while they are together in a tent before the campaign and thus have oral broadcast communication available.
Reference: [P93] <author> Birgit Pfitzmann: </author> <title> Sorting Out Signature Schemes; Proc. </title> <booktitle> 1st ACM Conference on Computer and Communications Security, ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 74-85. </pages>
Reference-contexts: This is useful for a clear definition of pseudosignatures and for discussing in detail why previous types of authentication schemes could not be used to provide information-theoretic Byzantine agreement. The framework is an extension of one for different types of signature schemes described in <ref> [P93, P96] </ref>. It may look unfamiliar because it primarily considers the interface behavior of the authentication systems, not internal objects such as keys and signatures. This approach is useful for a unified treatment of systems that, e.g., have interactive protocols where others simply have a key or a signature. <p> The easiest way to do this is to recognize that what is called a processor here is a software entity, of which there may be many in a hardware device, and to require that new entities are instantiated for each initialization <ref> [P93] </ref>. <p> Otherwise, one needs initialization identifiers. 6 Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/3 IBM Research Report RZ 2882 (#90830) 11/18/96 <ref> [P93, P96] </ref> sketch what it means for such requirements to be fulfilled under active attacks and in an information-theoretic or computational sense, i.e., several types of cryptologic semantics of temporal requirements on in and outputs.
Reference: [P96] <author> Birgit Pfitzmann: </author> <title> Digital Signature Schemes: General Framework and FailStop Signatures; Lecture Notes in Computer Science 1100, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1996. </year>
Reference-contexts: This is useful for a clear definition of pseudosignatures and for discussing in detail why previous types of authentication schemes could not be used to provide information-theoretic Byzantine agreement. The framework is an extension of one for different types of signature schemes described in <ref> [P93, P96] </ref>. It may look unfamiliar because it primarily considers the interface behavior of the authentication systems, not internal objects such as keys and signatures. This approach is useful for a unified treatment of systems that, e.g., have interactive protocols where others simply have a key or a signature. <p> Otherwise, one needs initialization identifiers. 6 Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/3 IBM Research Report RZ 2882 (#90830) 11/18/96 <ref> [P93, P96] </ref> sketch what it means for such requirements to be fulfilled under active attacks and in an information-theoretic or computational sense, i.e., several types of cryptologic semantics of temporal requirements on in and outputs.
Reference: [PSL80] <author> Marshall Pease, Robert Shostak, Leslie Lamport: </author> <title> Reaching Agreement in the Presence of Faults; Journal of the ACM 27/2 (1980) pp. 228-234. Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/3 25 IBM Research Report RZ 2882 (#90830) 11/18/96 </title>
Reference-contexts: Let n be the number of processors and t an upper bound on the number of faulty ones. Faulty processors may behave maliciously. Byzantine agreement was introduced in <ref> [PSL80] </ref>, where it was proved that perfect Byzan-tine agreement is only possible if t &lt; n/3. Many subsequent papers have studied upper and lower bounds on the attainable efficiency of such protocols, see [CD89, BMD93] for overviews. <p> This has led to the folklore that Byzan-tine agreement for t n/3 necessarily relies on computational assumptions. However, to be more precise, the model used in authenticated protocols is weaker than that in the impossibility proof in <ref> [PSL80] </ref> in three ways: Computational assumptions: This means both the restriction of faulty processors to polynomial-time computations and an unproven assumption that certain problems are not computable in polynomial time. In contrast, a protocol in which the computational power of faulty processors is not restricted is called information-theoretic. <p> We consider synchronous protocols, i.e., they proceed in rounds of fixed length. More benign fault models and less benign models of time are also known, but we do not refer to them in the following. As in the original model of <ref> [PSL80] </ref>, we assume that an authentic point-to-point channel is available between any pair of processors. A precomputation phase is a phase before the transmitter knows the value v it wants to send. We call the phase after v is known the main phase of the agreement protocol. <p> Error probability: First, one can see that the proof in <ref> [PSL80] </ref>, primarily intended for information-theoretic deterministic protocols without precomputation, holds for any deter ministic protocol, even if broadcast and secret channels are available in a precomputation phase.
Reference: [PW92] <author> Birgit Pfitzmann, Michael Waidner: </author> <title> Unconditionally Untraceable and Fault-tolerant Broadcast and Secret Ballot Election; Hildesheimer Informatik-Berichte 3/92, </title> <type> ISSN 0941-3014, </type> <institution> University of Hildesheim, Institut fr Informatik, </institution> <year> 1992. </year>
Reference-contexts: Furthermore, we exploit that only random messages will be sent. One advantage of random messages is that they need not be kept secret in the fault localization procedure, another will be seen in Lemma 2b). (The case of normal messages is sketched in <ref> [PW92] </ref> for an anonymous broadcast channel.) Within the pseudosignature scheme, the random messages will be the authentication keys, and if a fault has been detected and localized, the protocol will be repeated with new keys. 12 Information-Theoretic Pseudosignatures and Byzantine Agreement for t n/3 IBM Research Report RZ 2882 (#90830) 11/18/96
Reference: [R80] <author> Michael O. Rabin: </author> <note> Probabilistic Algorithms in Finite Fields; SIAM Journal on Computing 9/2 (1980) pp. 273-280. </note>
Reference-contexts: Any such set is called a solution. The algorithm is described in <ref> [BB90, B71, R80] </ref>; it has a security parameter g and an error probability of at most 2 g . <p> Proof. Without loss of generality, let the correct processors be P 1 , , P k . a) It follows from <ref> [BB90, B71, R80] </ref> that for any values S 1 , S 3 , , S 2n1 , the set of equations described in Step [2] has at most one solution.
Reference: [R90] <author> John Rompel: </author> <title> One-Way Functions are Necessary and Sufficient for Secure Signatures; Proc. </title> <booktitle> 22nd Symposium on Theory of Computing (STOC), ACM, </booktitle> <address> New York, </address> <year> 1990, </year> <pages> pp. 387-394. </pages>
Reference-contexts: However, if digital signatures [DH76, GMR88] can be used, Byzantine agreement is possible for any t &lt; n, even in polynomial time [DS83]. Such protocols are called authenticated protocols. Digital signatures exist if and only if one-way functions exist, which is an unproven computational assumption that implies PNP <ref> [R90] </ref>. This has led to the folklore that Byzan-tine agreement for t n/3 necessarily relies on computational assumptions. <p> For instance, an NP-easy 3 forging algorithm is that a forger guesses a signature s * and verifies this guess with test (pk, msg, s * ). More precisely, the existence of digital signatures in this sense implies the existence of a one-way function <ref> [R90] </ref>. Authenticated Byzantine agreement protocols like [DS83] are formulated in terms of digital signatures in this sense; at least they assume that signing and transfers are noninteractive.
Reference: [R94] <author> Tal Rabin: </author> <title> Robust Sharing of Secrets when the Dealer Is Honest or Cheating; Journal of the ACM 41/6 (1994) pp. </title> <type> 1089-1109. </type>
Reference-contexts: Actually, [DD91] sketches that any authentication mechanism that does not guarantee at least t transfers is insufficient for any Byzantine agreement protocol with malicious faults. An interesting related scheme is the check vector scheme of <ref> [R94] </ref>. It has an originator, one first and one or more second recipients. The first recipient can transfer a value received from the originator to any of the second recipients.
Reference: [RSA78] <author> R. L. Rivest, A. Shamir, L. Adleman: </author> <title> A Method for Obtaining Digital Signatures and Public-Key Cryptosystems; Communications of the ACM 21/2 (1978) pp. </title> <type> 120-126, </type> <note> reprinted: 26/1 (1983) pp. 96-99. </note>
Reference-contexts: In practice, this seems a smaller problem than broadcast in the precomputation phase. Secret channels are not used in typical authenticated protocols, but typical concrete computational assumptions imply them: the existing authentic channels could be used for the exchange of a secret key, see <ref> [DH76, RSA78] </ref> for well-known, but not provably secure examples.
Reference: [S90] <author> Gustavus J. Simmons: </author> <title> A Cartesian Product Construction for Unconditionally Secure Authentication Codes that Permit Arbitration; Journal of Cryptology 2/2 (1990) pp. </title> <type> 77-104. </type>
Reference-contexts: In arbitrated authentication codes, as introduced in <ref> [S90] </ref>, one specific third party, called arbiter, takes part in initialization with one originator and one recipient, and the recipient can later convince this arbiter of an authentication. This is a kind of transfer to one specific party.
Reference: [W91] <author> Michael Waidner: </author> <note> Byzantinische Verteilung ohne kryptographische Annahmen trotz beliebig vieler Fehler (in German); Dissertation, </note> <institution> University of Karlsruhe, Fakultt fr Informatik, </institution> <year> 1991. </year>
Reference-contexts: We presented the first information-theoretic Byzantine agreement protocol for t n/3 in [BPW91]. The model is the same as here, but the number of faulty processors was still restricted to t &lt; n/2. This result was extended to a protocol with an expected constant number of rounds in <ref> [W91] </ref>. 2 Properties and Types of Authentication Schemes In this section, we present a framework for the definition and classification of different types of authentication schemes.
Reference: [WC81] <author> Mark N. Wegman, J. Lawrence Carter: </author> <title> New Hash Functions and Their Use in Authentication and Set Equality; Journal of Computer and System Sciences 22 (1981) pp. </title> <type> 265-279. </type>
Reference-contexts: Thus any such scheme in which all five requirements were fulfilled information-theoretically would easily yield information-theoretic Byzantine agreement for any t. Let us now investigate known authentication schemes with information-theoretic security. Socalled authentication codes have been known for a long time <ref> [GMS74, WC81] </ref>. In the following, we will need them as subprotocols. Initialization usually is only for one recipient, i.e., ids R is this recipients identity. <p> Furthermore, we assume that membership in X can be decided in time polynomial in l and t, and that gen generates keys with uniform distribution in X. This implies |X| 2 t . In particular, we can use the authentication code of <ref> [WC81] </ref> and as its underlying strongly universal 2 class of functions the multiplicative scheme of [CW79] over GF (2 t+1 ). Then the length of authenticators is t+1 bits, and keylen (l, t) is logarithmic in l and linear in t.
References-found: 33

