URL: http://www.cse.psu.edu/~catuscia/papers/Correttezza/POPL94/ccc.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: Proving Concurrent Constraint Programs Correct  
Author: Frank S. de Boer Maurizio Gabbrielli Elena Marchiori Catuscia Palamidessi DISI 
Affiliation: Free University  CWI  CWI  
Abstract: We develop a compositional proof-system for the partial correctness of concurrent constraint programs. Soundness and (relative) completeness of the system are proved with respect to a denotational semantics based on the notion of strongest postcondition. The strongest postcondition semantics provides a justification of the declarative nature of concurrent constraint programs, since it allows to view programs as theories in the specification logic. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky. </author> <title> Domain Theory in Logical Form. </title> <booktitle> Proceedings, Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 47-53, </pages> <note> IEEE CS, 1987. Extended version in Annals of Pure and Applied Logic, </note> <month> 51: </month> <pages> 1-77, </pages> <year> 1991. </year>
Reference-contexts: Technically such a denotational semantics is used to prove R1 hD:tell (c); di ! hD:Stop; c t di R2 hD: i=1 ask (c i ) ! A i ; di ! hD:A j ; di j 2 <ref> [1; n] </ref> and d ` c i hD:A; ci ! hD:A 0 ; c 0 i hD:B k A; ci ! hD:B k A 0 ; c 0 i hD:A; d t 9 x ci ! hD:B; d 0 i xB; c t 9 x d 0 i R6 hD:p (x); <p> The agent P n R2 l h i=1 ask (c i ) ! A i ; di ! hask (c j ) ! A j ; di j 2 <ref> [1; n] </ref>; n &gt; 1 Table 4: The transition rule for local non-determinism. deterministically select one j 2 [1; n] and hence behave like ask (c j ) ! A j (which is a shorthand for P 1 i=1 ask (c j ) ! A j ) even if ask (c <p> The agent P n R2 l h i=1 ask (c i ) ! A i ; di ! hask (c j ) ! A j ; di j 2 <ref> [1; n] </ref>; n &gt; 1 Table 4: The transition rule for local non-determinism. deterministically select one j 2 [1; n] and hence behave like ask (c j ) ! A j (which is a shorthand for P 1 i=1 ask (c j ) ! A j ) even if ask (c j ) is not enabled in the current store. <p> The significance of such a line was eventually made clear by Abramsky <ref> [1] </ref> who exploited a seminal idea in [29]: the classic Stone representation theorem for Boolean algebras is the key to establish a correspondence (actually a duality of categories) between denotational semantics (spaces of points which are denotations of computational pro-cesses) and program logics (lattices of properties of processes).
Reference: [2] <author> K.R. Apt. </author> <title> Formal justification of a proof system for Communicating Sequential Processes. </title> <journal> Journal of the ACM, </journal> <volume> 30 </volume> <pages> 197-216, </pages> <year> 1983. </year>
Reference-contexts: On the other hand, proof systems for imperative concurrent languages are often designed by using an "ad hoc ingenuity" and their soundness and completeness are proved wrt an operational semantics using elaborate techniques <ref> [2] </ref>. &gt;From a pragmatic point of view, for any real programming language the importance of formal tools to reason about the correctness of programs is evident. The concurrent constraint paradigm has already proved its usefulness in several implementations, including a commercial one [14].
Reference: [3] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference: [4] <author> K.R. Apt, N. Francez and W. P. de Roever. </author> <title> A proof system for Communicating Sequential Processes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2 </volume> <pages> 359-385, </pages> <year> 1980. </year>
Reference-contexts: A calculus for the strongest postcondition semantics in the general case then would require additional proof-techniques similar to those used for imperative languages (e.g. test for interference freedom [20], cooperation test <ref> [4] </ref>).
Reference: [5] <author> J.A. Bergstra and J.W. Klop. </author> <title> Process algebra: specification and verification in bisimulation semantics. </title> <booktitle> In Mathematics and Computer Science II, CWI Monographs, </booktitle> <pages> pp. 61 - 94. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference: [6] <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> The failure of failures: Towards a paradigm for asynchronous communication. </title> <booktitle> In Proceedings of Concur '91, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 527, </pages> <address> Amsterdam, The Nether-lands, </address> <month> August </month> <year> 1991. </year>
Reference: [7] <author> F.S. de Boer and C. Palamidessi. </author> <title> A Fully Abstract Model for Concurrent Constraint Programming. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proc. of TAPSOFT/CAAP, </booktitle> <volume> LNCS 493, </volume> <pages> pages 296-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [8] <author> F.S. de Boer and C. Palamidessi. </author> <title> A process algebra of concurrent constraint programming. </title> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <address> JIC-SLP'92. </address>
Reference-contexts: For logic languages like Prolog the proof techniques of Hoare-Logic ([16]) have been applied in [10] to reason about properties of the flow of control and a process algebra for ccp has been developed in <ref> [8] </ref> along the lines of ACP ([5]). The focus of this paper concerns more generally the development of calculi for the correctness of ccp programs with respect to a first-order specification of what the program is supposed to compute.
Reference: [9] <author> M. Codish, M. Falaschi, K. Marriott, and W. Winsborough. </author> <title> Efficient Analysis of Concurrent Constraint Logic Programs. </title> <editor> In A. Lingas, editor, </editor> <booktitle> Proc. of the 20th International Colloquium on Automata, Languages, and Programming, volume 700 of Lecture Notes in Computer Science, </booktitle> <pages> pages 633-644. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference: [10] <author> L. Colussi, E. Marchiori. </author> <title> Proving Correctness of Logic Programs Using Axiomatic Semantics. </title> <booktitle> Proceedings of the 8th International Conference on Logic Programming, </booktitle> <publisher> The MIT Press, </publisher> <pages> pp. 629-644, </pages> <year> 1991. </year>
Reference-contexts: The issue of the design of proof systems appropriate to proving correctness of ccp programs has received no attention so far. For logic languages like Prolog the proof techniques of Hoare-Logic ([16]) have been applied in <ref> [10] </ref> to reason about properties of the flow of control and a process algebra for ccp has been developed in [8] along the lines of ACP ([5]).
Reference: [11] <author> S.A. Cook. </author> <title> Soundness and completeness of an axiom system for program verification. </title> <journal> SIAM J. Computation, </journal> <volume> 7(1) </volume> <pages> 70-90, </pages> <year> 1978. </year>
Reference: [12] <author> E.W. Dijkstra. </author> <title> A discipline of programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference: [13] <author> M. Falaschi, M. Gabbrielli, K. Marriott, and C. Palamidessi. </author> <title> Compositional Analysis for Concurrent Constraint Programming. </title> <booktitle> In Proc. Eighth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 210-221. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1993. </year>
Reference-contexts: Soundness and (relative) completeness of this calculus can be proved analogously to the previous case. Note that the semantics resulting from table 2 modified by equation D2 l is the one introduced in [18] for angelic ccp. The same semantics was used in <ref> [13] </ref> to approximate the operational semantics obtained from rules R1-R6 (i.e. with global choice) by observing the upward closure of the set of the resting points of a process P for a given input c.
Reference: [14] <author> I. Foster and S. Taylor. Strand: </author> <title> New concepts in parallel programming. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The concurrent constraint paradigm has already proved its usefulness in several implementations, including a commercial one <ref> [14] </ref>. Techniques based on abstract interpretation have been used to analyze properties of ccp computations ([9, 13]), but as far as we know, our is the first attempt to develop a formal calculus for (partial) correctness.
Reference: [15] <editor> L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras (Part I). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference: [16] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) 576-580,583, </volume> <year> 1969. </year>
Reference: [17] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference: [18] <author> R. Jagadeesan, V.A. Saraswat, and V. Shanbhogue. </author> <title> Angelic non-determinism in concurrent constraint programming. </title> <type> Technical report, </type> <institution> Xerox Park, </institution> <year> 1991. </year>
Reference-contexts: Soundness and (relative) completeness of this calculus can be proved analogously to the previous case. Note that the semantics resulting from table 2 modified by equation D2 l is the one introduced in <ref> [18] </ref> for angelic ccp. The same semantics was used in [13] to approximate the operational semantics obtained from rules R1-R6 (i.e. with global choice) by observing the upward closure of the set of the resting points of a process P for a given input c.
Reference: [19] <author> E.-R. Olderog. </author> <title> Nets, Terms and Formulas. </title> <booktitle> Cam-bridge Tracts in Theoretical Computer Science 23, </booktitle> <publisher> Cambridge Univ. Press, </publisher> <year> 1991. </year>
Reference-contexts: Section 4 contains the strongest postcondition semantics and the proof system for ccp. In section 5 we show how the proof system can be used for the transformational design of ccp programs along the lines of <ref> [19] </ref>. Section 6 concludes. 2 Preliminaries In this section we give the basic definitions of ccp languages following [25]. We refer to that paper for more details. The ccp languages are defined parametrically wrt to a given constraint system.
Reference: [20] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: A calculus for the strongest postcondition semantics in the general case then would require additional proof-techniques similar to those used for imperative languages (e.g. test for interference freedom <ref> [20] </ref>, cooperation test [4]).
Reference: [21] <author> P. Panangaden, V.A. Saraswat, P.J. Scott and R.A.G. Seely. </author> <title> A Hyperdoctrinal View of Concurrent Constraint Programming. </title> <booktitle> In Proc. REX Workshop, </booktitle> <volume> LNCS 666, </volume> <pages> pages 457-476, </pages> <year> 1992. </year>
Reference-contexts: It should be noted that for the deterministic fragment of ccp there exists an elegant denotational semantics based on closure operators [26], which in <ref> [21] </ref> are shown to be intimately related to the logic of constraints. The main result of this paper is the introduction of a proof-theory for ccp, i.e. a calculus for proving correctness of ccp programs (or, in other words, an axiomatic semantics) which does provide a declarative interpretation of ccp.
Reference: [22] <author> G. Plotkin. </author> <title> Dijkstra's predicate transformers and Smyth's powerdomains, </title> <publisher> LNCS 86, </publisher> <year> 1980. </year>
Reference-contexts: A very relevant line of research has been devoted in the past few years to establish closer links between denotational and axiomatic semantics of programming languages, via a better understanding of the relations between topology (and domain-theory) and logics <ref> [22, 27, 29, 23] </ref>.
Reference: [23] <author> E. Robinson. </author> <title> Logical aspects of denotational semantics, </title> <publisher> LNCS 283, </publisher> <year> 1987. </year>
Reference-contexts: A very relevant line of research has been devoted in the past few years to establish closer links between denotational and axiomatic semantics of programming languages, via a better understanding of the relations between topology (and domain-theory) and logics <ref> [22, 27, 29, 23] </ref>.
Reference: [24] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1989. </year> <note> Published by The MIT Press, </note> <institution> U.S.A., </institution> <year> 1991. </year>
Reference: [25] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. of POPL, </booktitle> <pages> pages 232-245, </pages> <year> 1990. </year>
Reference-contexts: In section 5 we show how the proof system can be used for the transformational design of ccp programs along the lines of [19]. Section 6 concludes. 2 Preliminaries In this section we give the basic definitions of ccp languages following <ref> [25] </ref>. We refer to that paper for more details. The ccp languages are defined parametrically wrt to a given constraint system. The notion of con straint system has been formalized in [25] following Scott's treatment of information systems ([27]). <p> Section 6 concludes. 2 Preliminaries In this section we give the basic definitions of ccp languages following <ref> [25] </ref>. We refer to that paper for more details. The ccp languages are defined parametrically wrt to a given constraint system. The notion of con straint system has been formalized in [25] following Scott's treatment of information systems ([27]). The basic ingredients are a set of primitive constraints D, each expressing some partial information, and a compact entailment relation ` defined on D. This gives basically an information system with the consistency structure removed.
Reference: [26] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantics foundations of Concurrent Constraint Programming. </title> <booktitle> In Proc. of POPL, </booktitle> <year> 1991. </year>
Reference-contexts: It should be noted that for the deterministic fragment of ccp there exists an elegant denotational semantics based on closure operators <ref> [26] </ref>, which in [21] are shown to be intimately related to the logic of constraints. <p> In rule D5 the variable y is assumed to be different from the formal parameter and in rule D6 on the other hand x is assumed to be the formal parameter. For deterministic agents the semantics [[P ]](e) coincides with the denotational semantics of <ref> [26] </ref>, which associates with each deterministic agent its set of resting points and which is a fully abstract characterization of its input/output behaviour.
Reference: [27] <author> D. Scott. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. of ICALP, </booktitle> <year> 1982. </year>
Reference-contexts: A very relevant line of research has been devoted in the past few years to establish closer links between denotational and axiomatic semantics of programming languages, via a better understanding of the relations between topology (and domain-theory) and logics <ref> [22, 27, 29, 23] </ref>.
Reference: [28] <author> D. Scott and J.W. de Bakker. </author> <title> A theory of programs. </title> <type> Technical Report Unpublished, </type> <institution> Notes of the IBM Vienna Seminar, </institution> <year> 1969. </year>
Reference-contexts: Note that 9x both in the languages of properties and agents has the same meaning, which is different from the one of 9 x in the constraint system. Reasoning about recursion is formalized in terms of a meta-rule (Scott-induction <ref> [28] </ref>) which allows to conclude that the agent p (x) satisfies a property OE whenever the body of p (x) satisfies the same property assuming the conclusion of the rule.
Reference: [29] <author> M. Smyth. </author> <title> Powerdomains and Predicate Transformers: A Topological View. Automata, </title> <booktitle> Languages and Programming, Proceedings 1983, </booktitle> <volume> LNCS 154, </volume> <pages> pp. 662-675, </pages> <year> 1983. </year>
Reference-contexts: A very relevant line of research has been devoted in the past few years to establish closer links between denotational and axiomatic semantics of programming languages, via a better understanding of the relations between topology (and domain-theory) and logics <ref> [22, 27, 29, 23] </ref>. <p> The significance of such a line was eventually made clear by Abramsky [1] who exploited a seminal idea in <ref> [29] </ref>: the classic Stone representation theorem for Boolean algebras is the key to establish a correspondence (actually a duality of categories) between denotational semantics (spaces of points which are denotations of computational pro-cesses) and program logics (lattices of properties of processes).
Reference: [30] <author> J. Zwiers. </author> <title> Compositionalty and Partial Correctness. </title> <publisher> LNCS 321, Springer-Verlag, </publisher> <year> 1989. </year>
References-found: 30

