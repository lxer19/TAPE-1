URL: http://www.cs.caltech.edu/~john-t/research/technical_reports/ccpp_salishan.ps
Refering-URL: http://www.cs.caltech.edu/~john-t/research/technical_reports/
Root-URL: http://www.cs.caltech.edu
Email: john-t@cs.caltech.edu  
Title: Integrating Functional and Imperative Parallel Programming: CC++ Solutions to the Salishan Problems  
Author: John Thornley 
Date: December 6, 1993  
Address: Pasadena, California 91125, USA  
Affiliation: Computer Science Department California Institute of Technology  
Abstract: We investigate the practical integration of functional and imperative parallel programming in the context of a popular sequential object-based language. As the basis of our investigation, we develop solutions to the Salishan Problems, a set of problems intended as a standard by which to compare parallel programming notations. The language that we use is CC++, C++ extended with single-assignment variables, parallel composition, and atomic functions. We demonstrate how deterministic parallel programs can be written that are identical|except for the addition of a few keywords|to sequential programs that satisfy the same specifications.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. R. Andrews. </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <address> Benjamin/Cummings, Redwood City, California, </address> <year> 1991. </year>
Reference-contexts: We are motivated by the observation that the strengths of functional and imperative programming are complementary with respect to our goal. Imperative parallel programming <ref> [1] </ref> expresses a computation operationally, as a group of cooperating concurrent processes, each with its own state and sequential thread of control. Processes communicate and synchronize using, for example, message passing, shared memory with locks, or remote procedure calls.
Reference: [2] <editor> T. Ito and R. H. Halstead, Jr., editors. </editor> <booktitle> Parallel Lisp: Languages and Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1990. </year> <booktitle> Proceedings of US/Japan Workshop on Parallel Lisp. </booktitle>
Reference-contexts: Its weakness is the complexity of expressing parallelism that is not explicit in the problem specification, solely for execution performance on multiprocessor architectures. Functional parallel programming <ref> [2, 3] </ref> expresses a computation nonoper-ationally, as a deterministic mapping from input values onto output values. Programs can be executed in any manner such that operands are evaluated before they are needed. Exploitation of parallelism is mostly the responsibility of the compiler and runtime system, not the programmer.
Reference: [3] <editor> B. K. Szymanski, editor. </editor> <booktitle> Parallel Functional Languages and Compilers. </booktitle> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <year> 1991. </year>
Reference-contexts: Its weakness is the complexity of expressing parallelism that is not explicit in the problem specification, solely for execution performance on multiprocessor architectures. Functional parallel programming <ref> [2, 3] </ref> expresses a computation nonoper-ationally, as a deterministic mapping from input values onto output values. Programs can be executed in any manner such that operands are evaluated before they are needed. Exploitation of parallelism is mostly the responsibility of the compiler and runtime system, not the programmer.
Reference: [4] <author> D. Cann. </author> <title> Retire Fortran? A debate rekindled. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 81-89, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Programs can be executed in any manner such that operands are evaluated before they are needed. Exploitation of parallelism is mostly the responsibility of the compiler and runtime system, not the programmer. Recent work demonstrates that functional programming can provide execution performance comparable to that of imperative programming <ref> [4] </ref>. The strength of functional parallel programming is in representing parallel algorithms for problem specifications that are given as a functional mapping from inputs onto outputs, e.g., many scientific problems. Its weakness is the difficulty of representing state, sequence, and concurrency that are explicit in the specification of many problems.
Reference: [5] <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year> <month> 23 </month>
Reference-contexts: Its weakness is the difficulty of representing state, sequence, and concurrency that are explicit in the specification of many problems. This report investigates the practical integration of the complementary strengths of functional and imperative parallel programming. Our work differs from other work that integrates functional and imperative parallel programming <ref> [5, 6] </ref> in that we choose to build upon an established sequential object-based language. The language that we use is CC++ [7, 8], a simple extension of C++ [9] that supports both functional and imperative parallel programming.
Reference: [6] <author> K. M. Chandy and S. Taylor. </author> <title> An Introduction to Parallel Programming. </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: Its weakness is the difficulty of representing state, sequence, and concurrency that are explicit in the specification of many problems. This report investigates the practical integration of the complementary strengths of functional and imperative parallel programming. Our work differs from other work that integrates functional and imperative parallel programming <ref> [5, 6] </ref> in that we choose to build upon an established sequential object-based language. The language that we use is CC++ [7, 8], a simple extension of C++ [9] that supports both functional and imperative parallel programming.
Reference: [7] <author> K. M. Chandy and C. Kesselman. </author> <title> CC++: A declarative concurrent object oriented programming language. </title> <type> Technical Report CS-TR-92-01, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: Our work differs from other work that integrates functional and imperative parallel programming [5, 6] in that we choose to build upon an established sequential object-based language. The language that we use is CC++ <ref> [7, 8] </ref>, a simple extension of C++ [9] that supports both functional and imperative parallel programming. Previous work with CC++ has concentrated on the definition and use of imperative parallel programming libraries [10].
Reference: [8] <author> P. Carlin, M. Chandy, and C. Kesselman. </author> <title> The Compositional C++ language definition. </title> <type> Technical Report CS-TR-92-02, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: Our work differs from other work that integrates functional and imperative parallel programming [5, 6] in that we choose to build upon an established sequential object-based language. The language that we use is CC++ <ref> [7, 8] </ref>, a simple extension of C++ [9] that supports both functional and imperative parallel programming. Previous work with CC++ has concentrated on the definition and use of imperative parallel programming libraries [10]. <p> A complete definition of the syntax and semantics of CC++ is given by <ref> [8] </ref>. 3 The Salishan Problems The Salishan Problems are a set of four problems proposed as a standard by which to compare parallel programming notations. The problem set was originally defined at the 1988 Salishan High-Speed Computing Conference.
Reference: [9] <author> M. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Our work differs from other work that integrates functional and imperative parallel programming [5, 6] in that we choose to build upon an established sequential object-based language. The language that we use is CC++ [7, 8], a simple extension of C++ <ref> [9] </ref> that supports both functional and imperative parallel programming. Previous work with CC++ has concentrated on the definition and use of imperative parallel programming libraries [10].
Reference: [10] <author> P. Sivilotti. </author> <title> A verified integration of imperative parallel programming paradigms in an object-oriented language. </title> <type> Technical Report CS-TR-93-21, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: The language that we use is CC++ [7, 8], a simple extension of C++ [9] that supports both functional and imperative parallel programming. Previous work with CC++ has concentrated on the definition and use of imperative parallel programming libraries <ref> [10] </ref>. To evaluate the benefits of the integrated use of both functional and imperative parallel programming in this context, we develop solutions to the Salishan 2 Problems [11], a representative set of problems intended as a standard by which to compare parallel programming notations.
Reference: [11] <author> J. T. Feo, </author> <title> editor. A Comparative Study of Parallel Programming Languages: The Salishan Problems, </title> <booktitle> volume 6 of Special Topics in Supercomputing. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1992. </year> <month> 24 </month>
Reference-contexts: Previous work with CC++ has concentrated on the definition and use of imperative parallel programming libraries [10]. To evaluate the benefits of the integrated use of both functional and imperative parallel programming in this context, we develop solutions to the Salishan 2 Problems <ref> [11] </ref>, a representative set of problems intended as a standard by which to compare parallel programming notations. <p> Loosely categorized, those languages were: Ada and Occam (imperative); Haskell, Id, and Sisal (functional); C fl (data-parallel); PCN and Scheme (combined imperative and functional). The Salishan Problems and the original eight sets of solutions are published in <ref> [11] </ref>. 4 Three of the four problems|Hamming's Problem, the Paraffins Prob--lem, and the Skyline Matrix Problem|are functional mappings from input values onto output values, without any concurrency in their problem specifications. For these problems we write deterministic functional parallel programs using sync variables, par-blocks, and parfor statements.
References-found: 11

