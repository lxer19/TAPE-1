URL: http://www.cs.columbia.edu/~gravano/Papers/1996/sigmod96.ps
Refering-URL: http://www.cs.columbia.edu/~gravano/publications.html
Root-URL: http://www.cs.columbia.edu
Email: surajitc@microsoft.com  gravano@cs.stanford.edu  
Title: Optimizing Queries over Multimedia Repositories  
Author: Surajit Chaudhuri Luis Gravano 
Address: Stanford University  
Affiliation: Hewlett-Packard Laboratories  Hewlett-Packard Laboratories  
Abstract: Repositories of multimedia objects having multiple types of attributes (e.g., image, text) are becoming increasingly common. A selection on these attributes will typically produce not just a set of objects, as in the traditional relational query model (filtering), but also a grade of match associated with each object, indicating how well the object matches the selection condition (ranking). Also, multimedia repositories may allow access to the attributes of each object only through indexes. We investigate how to optimize the processing of queries over multimedia repositories. A key issue is the choice of the indexes used to search the repository. We define an execution space that is search-minimal , i.e., the set of indexes searched is minimal. Although the general problem of picking an optimal plan in the search-minimal execution space is NP-hard, we solve the problem efficiently when the predicates in the query are independent. We also show that the problem of optimizing queries that ask for a few top-ranked objects can be viewed, in many cases, as that of evaluating selection conditions. Thus, both problems can be viewed together as an extended filtering problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ronald Fagin. </author> <title> Combining fuzzy information from multiple systems. </title> <booktitle> In 15 th ACM Symposium on Principles of Database Systems, </booktitle> <month> June </month> <year> 1996. </year> <note> Also available as IBM Almaden Research Center Technical Report RJ 9980. </note>
Reference-contexts: First, rarely does a user expect an exact match with the feature of a multimedia object (e.g., color histogram). Rather, an object does not either satisfy or fail a condition, but has instead an associated grade of match <ref> [1] </ref>. Thus, an atomic filter condition will not be an equality between two values (e.g., between a given color c and the color oid.color of an object), but instead an inequality involving the grade of match between the two values and some target grade (e.g., Grade (color, c)(oid) &gt; 0:7). <p> Our paper also contributes to the problem of optimizing the evaluation of a ranking expression. Previous significant work in this area is due to Fagin <ref> [1] </ref>, who shows his algorithm to be asymptotically optimal under broad assumptions. A key contribution of our paper is to show that ranking expressions can be processed "almost" like filter conditions. We prove that our technique is expected not to retrieve more objects than the strategy in [1]. <p> due to Fagin <ref> [1] </ref>, who shows his algorithm to be asymptotically optimal under broad assumptions. A key contribution of our paper is to show that ranking expressions can be processed "almost" like filter conditions. We prove that our technique is expected not to retrieve more objects than the strategy in [1]. Our experimental results indicate that the performance gain from processing ranking expressions as filter conditions can be substantial. This result allows us to process queries with both a filter condition and a ranking expression in a unifying framework. The rest of the paper is organized as follows. <p> Given an object o, an attribute attr, and a constant value, the notion of a grade of match Grade (attr, value)(o) between o and the given value for attribute attr addresses the first requirement. Such a grade is a real number in the <ref> [0; 1] </ref> range and designates the degree of equality (match) between o:attr and value. We address the second requirement by introducing the notion of a filter condition. The atomic filter conditions are of the form Grade (attr, value)(o) grade. <p> Additional filter conditions are generated from the atomic conditions by using the ^ ("and") and _ ("or") boolean connectives. Filter conditions evaluate to either true or false. Following <ref> [1] </ref>, we address the third requirement for the query model through the notion of a ranking expression. The ranking expression computes a composite grade for an object from individual grades of match and the composition functions Min and Max . <p> The answer to such queries is the top objects ordered by the ranking expression that also satisfy the filter condition. We first look at queries consisting only of ranking expressions. Section 4.1 describes an algorithm for processing this type of queries that has been recently presented <ref> [1] </ref>. Section 4.2 presents our main result regarding this class of queries. We show that we can map a given ranking expression into a filter condition, and process the ranking expression "almost" as if it were a filter condition. <p> The experimental results of Section 5.2 show that the number of objects retrieved when processing a ranking expression like a filter condition can be considerably smaller than when processing the ranking expression using the algorithm in <ref> [1] </ref>. A query consisting of only a ranking expression has the form: SELECT oid FROM Repository ORDER [k] by Ranking expression The result of this query is a list of k objects in the repository with the highest grade for the given ranking expression. <p> The ranking expressions are built from atomic expressions that are combined using the Min and Max operators that we defined in Section 2. 4.1 Fagin's Strategy Recently, Fagin presented a novel approach to processing a query consisting of a ranking expression <ref> [1] </ref>. In this section we briefly describe his approach. Consider a ranking expression R = Min (a 1 ; : : : ; a n ), where the a i 's are independent atomic expressions. Suppose that we are interested in k objects with the highest grades for R. <p> In the context of the Garlic project at IBM Al-maden [23], Fagin's recent work <ref> [1] </ref> focuses on how to evaluate queries that ask for a few top matches for a ranking expression. (See Section 4.1.) Our ranking expressions are a special case of Fagin's queries. <p> Acknowledgments We thank Umesh Dayal, Hector Garca-Molina, Jeff Ullman, Tak Yan, and the entire database group at HPLabs for helpful discussions and comments. We also thank Ron Fagin for sending us an early draft of <ref> [1] </ref>.
Reference: [2] <author> Surajit Chaudhuri and Luis Gravano. </author> <title> Optimizing queries over multimedia repositories. </title> <type> Technical report, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> March </month> <year> 1996. </year> <note> Also available as ftp://db.stanford.edu/pub/gravano/- 1996/sigmod.ps. </note>
Reference-contexts: Although the search-minimal execution space is a restricted space, our experiments indicate that a simple post-optimization step leads to plans that are nearly always as good as the plans obtained when plans are not restricted to be search minimal <ref> [2] </ref>. Our paper also contributes to the problem of optimizing the evaluation of a ranking expression. Previous significant work in this area is due to Fagin [1], who shows his algorithm to be asymptotically optimal under broad assumptions. <p> However, the space of all such executions is significantly larger. In <ref> [2] </ref> we consider applying a post-optimization step to the best search-minimal strategy and compare the new strategy against the overall optimal execution. (Neither the post-optimized strategy nor the overall optimal one are necessarily search minimal.) The post-optimization step produces almost optimal strategies most of the time [2]. <p> In <ref> [2] </ref> we consider applying a post-optimization step to the best search-minimal strategy and compare the new strategy against the overall optimal execution. (Neither the post-optimized strategy nor the overall optimal one are necessarily search minimal.) The post-optimization step produces almost optimal strategies most of the time [2]. By searching on a condition using GradeSearch, we obtain a set of objects. However, we may need to do additional probes to determine the subset of objects that satisfy the rest of the filter condition as well. <p> If p is large enough, it might be cheaper to implement the p probes by doing a single search on a, at cost SC (a). This observation is the key of the post-optimization step in <ref> [2] </ref>. We now sketch how to estimate the cost parameters over multimedia repositories for text and image attributes. Consider first a text attribute that is handled by a vector-space retrieval system. Typically, such a system has inverted lists associated with each term in the vocabulary [5]. <p> Then SM f (f ) is an optimal search-minimal condition set for f . The proof of optimality of SM f (f ) (see <ref> [2] </ref>) depends on the fact that the given filter condition f is independent. Nonetheless, we can easily modify the above algorithm to provide a search-minimal condition set when the given filter condition is not independent. However, this set is no longer guaranteed to be optimal [2]. <p> SM f (f ) (see <ref> [2] </ref>) depends on the fact that the given filter condition f is independent. Nonetheless, we can easily modify the above algorithm to provide a search-minimal condition set when the given filter condition is not independent. However, this set is no longer guaranteed to be optimal [2]. This is not surprising given that the general optimality problem is intractable, as the following theorem shows. <p> We use these attributes to build atomic expressions e i = Grade (A i ; v i ), for fixed values v i , i = 1; : : : ; 5. Below we define the selectivities and the search and probe costs associated with the atomic expressions. (See <ref> [2] </ref> for a detailed description of the cost calculations and parameters.) Expressions e 1 and e 2 (text attributes): We define Sel (e 1 ; 1:0) = 3 fi 10 6 and Sel (e 2 ; 1:0) = 7 fi 10 6 , and assume that Sel (e i ; g)
Reference: [3] <author> F. Rabitti. </author> <title> Retrieval of multimedia documents by imprecise query specification. </title> <booktitle> In Proceedings of the 1990 EDBT, </booktitle> <address> Venice, Italy, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: Sections 3 and 4 present the results on evaluating filter conditions and ranking expressions, respectively. Section 5 discusses our experimental results. Finally, Section 6 is devoted to related work. 2 Query Model In this section we introduce a query model to select multimedia objects from a repository. (See <ref> [3] </ref> for a similar model.) Such a query model needs to satisfy the following requirements: 1. Consider that a match between the value of an attribute of a multimedia object and a given constant is not exact, i.e., must account for the grade of match. 2. <p> For example, for k = 10, the filter-condition strategy accesses only an expected 30% of the objects that Fagin's algorithm is expected to retrieve. 6 Related Work The concept of a graded match has been used extensively. For example, the query model in <ref> [3] </ref> allows specifying a grade of match as well as ranking. However, the processing of queries in [3] is based on searches (i.e., no probes are considered). Many database systems support processing user-defined functions [17]. <p> For example, the query model in <ref> [3] </ref> allows specifying a grade of match as well as ranking. However, the processing of queries in [3] is based on searches (i.e., no probes are considered). Many database systems support processing user-defined functions [17]. The QBIC system [4] from IBM Almaden allows users to query image repositories using image attributes like color, texture, and shapes.
Reference: [4] <author> W. Niblack, R. Barber, W. Equitz, M. Flickner, E. Glasman, D. Petkovic, P. Yanker, and C. Faloutsos. </author> <title> The QBIC project: Querying images by content using color, texture, and shape. </title> <booktitle> In Storage and retrieval for image and video databases (SPIE), </booktitle> <pages> pages 173-187, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Indexes also support access to the attribute values of an object given its oid. The following are several storage-level access interfaces that multimedia repositories may support <ref> [4] </ref>. <p> Then, a filter condition on such an attribute may ask for objects whose color histogram matches a given color histogram closely. The QBIC system supports this type of queries <ref> [4] </ref>. A popular data structure to support such queries is the R tree [6] and its variants [7, 8], which may be used to index the feature vectors associated with the attributes. The grade of match between two feature vectors is computed based on the semantics of the attributes. <p> For example, the query model in [3] allows specifying a grade of match as well as ranking. However, the processing of queries in [3] is based on searches (i.e., no probes are considered). Many database systems support processing user-defined functions [17]. The QBIC system <ref> [4] </ref> from IBM Almaden allows users to query image repositories using image attributes like color, texture, and shapes. Another example is Cypress 2 , a picture retrieval system that allows a filter condition to be specified, and returns a set of objects as the answer to the filter condition.
Reference: [5] <author> Gerard Salton. </author> <title> Automatic text processing: the transformation, analysis, and retrieval of information by computer. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year> <month> 101 </month>
Reference-contexts: Next, we briefly describe how text and image attributes may support the above interfaces. Text Attributes: Consider a repository of objects with a textual attribute T . For this attribute, the repository might have an index that handles queries using the vector-space model of document retrieval <ref> [5] </ref>. Given a value for T (i.e., a sequence of words), this index assigns a grade to every object in the repository, according to how similar its value for T and the query value are. Vector-space retrieval systems usually provide the GradeSearch interface, the TopSearch interface, or both. <p> We now sketch how to estimate the cost parameters over multimedia repositories for text and image attributes. Consider first a text attribute that is handled by a vector-space retrieval system. Typically, such a system has inverted lists associated with each term in the vocabulary <ref> [5] </ref>. For each term we can extract the number of documents d that contain the term, and the added weight w of the term in the documents that contain it. <p> We can then apply the methodology of Section 3. 5 Experimental Results We ran a set of experiments using synthetic data. We assumed a database of 1,000,000 objects, with five attributes each. Attributes A 1 and A 2 are text attributes handled by vector-space search engines <ref> [5] </ref>. Attributes A 3 through A 5 are defined over images, and handled by R-trees indexes [6]. We use these attributes to build atomic expressions e i = Grade (A i ; v i ), for fixed values v i , i = 1; : : : ; 5.
Reference: [6] <author> Antonin Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proceedings of the 1984 ACM SIGMOD Conference, </booktitle> <pages> pages 47-57, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Then, a filter condition on such an attribute may ask for objects whose color histogram matches a given color histogram closely. The QBIC system supports this type of queries [4]. A popular data structure to support such queries is the R tree <ref> [6] </ref> and its variants [7, 8], which may be used to index the feature vectors associated with the attributes. The grade of match between two feature vectors is computed based on the semantics of the attributes. <p> We assumed a database of 1,000,000 objects, with five attributes each. Attributes A 1 and A 2 are text attributes handled by vector-space search engines [5]. Attributes A 3 through A 5 are defined over images, and handled by R-trees indexes <ref> [6] </ref>. We use these attributes to build atomic expressions e i = Grade (A i ; v i ), for fixed values v i , i = 1; : : : ; 5.
Reference: [7] <author> Norbert Beckmann, Hans-Peter Kriegel, Ralf Schnei-der, and Bernhard Seeger. </author> <title> The R* tree: An efficient and robust access method for points and rectangles. </title> <booktitle> In Proceedings of the 1990 ACM SIGMOD Conference, </booktitle> <pages> pages 322-331, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Then, a filter condition on such an attribute may ask for objects whose color histogram matches a given color histogram closely. The QBIC system supports this type of queries [4]. A popular data structure to support such queries is the R tree [6] and its variants <ref> [7, 8] </ref>, which may be used to index the feature vectors associated with the attributes. The grade of match between two feature vectors is computed based on the semantics of the attributes.
Reference: [8] <author> Timos Sellis, Nick Roussopoulos, and Christos Falout-sos. </author> <title> The R+-tree: A dynamic index for multidimensional objects. </title> <booktitle> In Proceedings of the 13th Conference on Very Large Databases, </booktitle> <pages> pages 507-518, </pages> <month> Septem-ber </month> <year> 1987. </year>
Reference-contexts: Then, a filter condition on such an attribute may ask for objects whose color histogram matches a given color histogram closely. The QBIC system supports this type of queries [4]. A popular data structure to support such queries is the R tree [6] and its variants <ref> [7, 8] </ref>, which may be used to index the feature vectors associated with the attributes. The grade of match between two feature vectors is computed based on the semantics of the attributes.
Reference: [9] <author> Nick Roussopoulos, Stephen Kelley, and Frederick Vincent. </author> <title> Nearest neighbor queries. </title> <booktitle> In Proceedings of the 1995 ACM SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 71-79, </pages> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: We then process the corresponding range search. Roussopoulos and others <ref> [9] </ref> have recently presented an algorithm to find nearest neighbors on R trees.
Reference: [10] <author> P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Symposium on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1979. </year>
Reference-contexts: The answer contains the top 10 such acceptable records. (For simplicity, we omitted the parameter oid in the atomic conditions below.) 92 SELECT oid FROM Repository WHERE (Grade (v, V) &gt;= .5 AND Grade (p, `on parole') &gt;= .9) OR Grade (f, F) &gt;= .9 ORDER <ref> [10] </ref> BY Max (Grade (f, F), Grade (v, V)) 2.1 Expressivity of the Query Model The filter condition F in a query Q selects the set of objects in the repository that satisfy the condition, whereas the ranking expression R computes a grade for each qualifying object. <p> Similar restrictions have been traditionally adopted <ref> [10] </ref>. <p> We use this estimation technique for our experiments. We will restrict our discussion to optimizing independent filter conditions containing disjunctions and conjunctions. We can compute the selectivities of complex independent filter conditions using the following two rules as in traditional optimization <ref> [10] </ref>: * Sel (e 1 ^ : : : ^ e n ) = n * Sel (e 1 _ : : : _ e n ) = 1 n 3.3 Optimization Algorithm In this section, we present the results on optimization of filter conditions. <p> Our approach to defining the execution space is similar in spirit to [21], but our problem is more complex since probe costs can be significant as well as varied. When the filter condition is restricted to being a conjunction, the optimization problem can be cast as a join-ordering problem <ref> [10, 13, 14] </ref>. However, such a formulation fails to capture characteristics that are particular of selection queries.
Reference: [11] <author> A. Kemper, G. Moerkotte, and M. Steinbrunn. </author> <title> Optimizing boolean expressions in object bases. </title> <booktitle> In Proceedings of the 18th Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufman pubs. </publisher> <address> (Los Altos CA), Vancouver, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: The rest of the conditions will be evaluated by using Probe. In order to efficiently execute the latter step, we will exploit the known techniques in optimizing the probing of expensive filter conditions <ref> [11, 12, 13, 14] </ref>. In this section, we first define a space of search-minimal executions, and sketch the cost model and the optimization criteria. Next, we describe an optimization algorithm and explain the conditions under which it is optimal. <p> Optimizing Evaluation of Residues: Given a residue R (a; f), the task of determining an optimal evaluation for R (a; f ) maps to the well studied problem of optimizing the execution of selection conditions containing expensive predicates <ref> [11] </ref>. (See also [12, 13, 14].) If R (a; f) is a conjunction of atomic conditions a 1 ^ : : : ^ a n with n &gt; 1, there is an efficient algorithm w that finds the optimum probing strategy. <p> We can take a similar approach to order the evaluation of a disjunction of atomic conditions. In case R (a; f) is an arbitrary boolean condition, the problem of evaluating it optimally is known to be intractable. However, several good heuristics are available <ref> [11] </ref>. Therefore, we assume that we exploit one of these available algorithms to optimize the evaluation of residues. As we mentioned above, depending on the strategy w used to evaluate R (a; f), we can parameterize our cost function. <p> The problem of optimizing user-defined filter conditions such as those in Cypress has been addressed in the literature. Work in [12, 13, 14] focuses on conjunctive selection conditions. Techniques to optimize arbitrary boolean selection conditions have been studied in <ref> [11, 18, 19] </ref>. Our work draws upon the known results in this area. (See Section 3.) However, all of the above work focuses on what we have referred to as probing costs, and does not consider the search costs.
Reference: [12] <author> J. M. Hellerstein and M. Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proceedings of the ACM SIGMOD International Symposium on Management of Data, </booktitle> <address> Washington D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The rest of the conditions will be evaluated by using Probe. In order to efficiently execute the latter step, we will exploit the known techniques in optimizing the probing of expensive filter conditions <ref> [11, 12, 13, 14] </ref>. In this section, we first define a space of search-minimal executions, and sketch the cost model and the optimization criteria. Next, we describe an optimization algorithm and explain the conditions under which it is optimal. <p> Optimizing Evaluation of Residues: Given a residue R (a; f), the task of determining an optimal evaluation for R (a; f ) maps to the well studied problem of optimizing the execution of selection conditions containing expensive predicates [11]. (See also <ref> [12, 13, 14] </ref>.) If R (a; f) is a conjunction of atomic conditions a 1 ^ : : : ^ a n with n &gt; 1, there is an efficient algorithm w that finds the optimum probing strategy. <p> The problem of optimizing user-defined filter conditions such as those in Cypress has been addressed in the literature. Work in <ref> [12, 13, 14] </ref> focuses on conjunctive selection conditions. Techniques to optimize arbitrary boolean selection conditions have been studied in [11, 18, 19].
Reference: [13] <author> T. Ibaraki and T. Kameda. </author> <title> On the optimal nesting order for computing N-relational joins. </title> <journal> ACM Transactions on Database Systems, ; ACM CR 8506 0535, </journal> <volume> 9(3), </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: The rest of the conditions will be evaluated by using Probe. In order to efficiently execute the latter step, we will exploit the known techniques in optimizing the probing of expensive filter conditions <ref> [11, 12, 13, 14] </ref>. In this section, we first define a space of search-minimal executions, and sketch the cost model and the optimization criteria. Next, we describe an optimization algorithm and explain the conditions under which it is optimal. <p> Optimizing Evaluation of Residues: Given a residue R (a; f), the task of determining an optimal evaluation for R (a; f ) maps to the well studied problem of optimizing the execution of selection conditions containing expensive predicates [11]. (See also <ref> [12, 13, 14] </ref>.) If R (a; f) is a conjunction of atomic conditions a 1 ^ : : : ^ a n with n &gt; 1, there is an efficient algorithm w that finds the optimum probing strategy. <p> This result is well known and was observed in the database context by <ref> [13, 14] </ref>. We can take a similar approach to order the evaluation of a disjunction of atomic conditions. In case R (a; f) is an arbitrary boolean condition, the problem of evaluating it optimally is known to be intractable. However, several good heuristics are available [11]. <p> The problem of optimizing user-defined filter conditions such as those in Cypress has been addressed in the literature. Work in <ref> [12, 13, 14] </ref> focuses on conjunctive selection conditions. Techniques to optimize arbitrary boolean selection conditions have been studied in [11, 18, 19]. <p> Our approach to defining the execution space is similar in spirit to [21], but our problem is more complex since probe costs can be significant as well as varied. When the filter condition is restricted to being a conjunction, the optimization problem can be cast as a join-ordering problem <ref> [10, 13, 14] </ref>. However, such a formulation fails to capture characteristics that are particular of selection queries.
Reference: [14] <author> R. Krishnamurthy, H. Boral, and C. Zanialo. </author> <title> Optimization of nonrecursive queries. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 128-137, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: The rest of the conditions will be evaluated by using Probe. In order to efficiently execute the latter step, we will exploit the known techniques in optimizing the probing of expensive filter conditions <ref> [11, 12, 13, 14] </ref>. In this section, we first define a space of search-minimal executions, and sketch the cost model and the optimization criteria. Next, we describe an optimization algorithm and explain the conditions under which it is optimal. <p> Optimizing Evaluation of Residues: Given a residue R (a; f), the task of determining an optimal evaluation for R (a; f ) maps to the well studied problem of optimizing the execution of selection conditions containing expensive predicates [11]. (See also <ref> [12, 13, 14] </ref>.) If R (a; f) is a conjunction of atomic conditions a 1 ^ : : : ^ a n with n &gt; 1, there is an efficient algorithm w that finds the optimum probing strategy. <p> This result is well known and was observed in the database context by <ref> [13, 14] </ref>. We can take a similar approach to order the evaluation of a disjunction of atomic conditions. In case R (a; f) is an arbitrary boolean condition, the problem of evaluating it optimally is known to be intractable. However, several good heuristics are available [11]. <p> The problem of optimizing user-defined filter conditions such as those in Cypress has been addressed in the literature. Work in <ref> [12, 13, 14] </ref> focuses on conjunctive selection conditions. Techniques to optimize arbitrary boolean selection conditions have been studied in [11, 18, 19]. <p> Our approach to defining the execution space is similar in spirit to [21], but our problem is more complex since probe costs can be significant as well as varied. When the filter condition is restricted to being a conjunction, the optimization problem can be cast as a join-ordering problem <ref> [10, 13, 14] </ref>. However, such a formulation fails to capture characteristics that are particular of selection queries.
Reference: [15] <author> Luis Gravano and Hector Garca-Molina. </author> <title> Generalizing GlOSS for vector-space databases and broker hierarchies. </title> <booktitle> In Proceedings of the 21st International Conference on Very Large Data Bases (VLDB'95), </booktitle> <pages> pages 78-89, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: For each term we can extract the number of documents d that contain the term, and the added weight w of the term in the documents that contain it. Thus, we can use the methodology in <ref> [15] </ref> to estimate the selectivity of an atomic filter condition, as well as the cost of processing the inverted lists that the condition requires. Consider now an attribute over an image that is handled with an R tree.
Reference: [16] <author> Christos Faloutsos and Ibrahim Kamel. </author> <title> Beyond uniformity and independence: analysis of R trees using the concept of fractal dimension. </title> <booktitle> In 13 th ACM Symposium on Principles of Database Systems, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Consider now an attribute over an image that is handled with an R tree. We can then use the methodology in <ref> [16] </ref>, which uses the concept of the fractal dimension of a data set to estimate the selectivity of atomic conditions, and the expected cost of processing such conditions using the R tree. We use this estimation technique for our experiments. <p> Expressions e 3 , e 4 , and e 5 (image attributes): We assume that these attributes are managed using R trees, and use the methodology of <ref> [16] </ref> to estimate their parameters. The fractal dimension of a data set is a number that characterizes the distribution of the data. <p> For our experiments, we set the dimension of the corresponding feature vectors of attributes A 3 , A 4 , and A 5 to be 9, 7, and 10, respectively, and their fractal dimension to be 9, 3, and 4, respectively. We then use the methodology in <ref> [16] </ref>.
Reference: [17] <author> M. Carey and L. Haas. </author> <title> Extensible database management systems. </title> <booktitle> ACM SIGMOD Record, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: For example, the query model in [3] allows specifying a grade of match as well as ranking. However, the processing of queries in [3] is based on searches (i.e., no probes are considered). Many database systems support processing user-defined functions <ref> [17] </ref>. The QBIC system [4] from IBM Almaden allows users to query image repositories using image attributes like color, texture, and shapes.
Reference: [18] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> Optimizing disjunctive queries with expensive predicates. </title> <booktitle> SIGMOD record, </booktitle> <address> 23(2):336, </address> <year> 1994. </year>
Reference-contexts: The problem of optimizing user-defined filter conditions such as those in Cypress has been addressed in the literature. Work in [12, 13, 14] focuses on conjunctive selection conditions. Techniques to optimize arbitrary boolean selection conditions have been studied in <ref> [11, 18, 19] </ref>. Our work draws upon the known results in this area. (See Section 3.) However, all of the above work focuses on what we have referred to as probing costs, and does not consider the search costs.
Reference: [19] <author> M.T. Ozsu and D. Meechan. </author> <title> Finding heuristics for processing selection queries in relational database systems. </title> <journal> Information Systems, </journal> <volume> 15(3), </volume> <year> 1990. </year>
Reference-contexts: The problem of optimizing user-defined filter conditions such as those in Cypress has been addressed in the literature. Work in [12, 13, 14] focuses on conjunctive selection conditions. Techniques to optimize arbitrary boolean selection conditions have been studied in <ref> [11, 18, 19] </ref>. Our work draws upon the known results in this area. (See Section 3.) However, all of the above work focuses on what we have referred to as probing costs, and does not consider the search costs.
Reference: [20] <author> A. Rosenthal and D. Reiner. </author> <title> An architecture for query optimization. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 246, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1982. </year>
Reference-contexts: On the other hand, the problem of determining an optimal set of conditions to search arises naturally when optimizing single-table queries with multiple indexes <ref> [20, 21] </ref>. The problem of sequencing the order of accesses to subfiles of transposed files is also closely related [22]. However, in the above contexts, the probing cost is either zero or is independent of the predicates.
Reference: [21] <author> C. Mohan. </author> <title> Single table access using multiple indexes: Optimization, execution and concurrency control techniques. </title> <booktitle> In EDBT 90, </booktitle> <address> Venice, </address> <year> 1990. </year> <note> Also published in/as: </note> <institution> IBM Almaden Res.Ctr, Res.R. No.RJ7341, Mar.1990, 15pp. </institution>
Reference-contexts: On the other hand, the problem of determining an optimal set of conditions to search arises naturally when optimizing single-table queries with multiple indexes <ref> [20, 21] </ref>. The problem of sequencing the order of accesses to subfiles of transposed files is also closely related [22]. However, in the above contexts, the probing cost is either zero or is independent of the predicates. <p> The problem of sequencing the order of accesses to subfiles of transposed files is also closely related [22]. However, in the above contexts, the probing cost is either zero or is independent of the predicates. Our approach to defining the execution space is similar in spirit to <ref> [21] </ref>, but our problem is more complex since probe costs can be significant as well as varied. When the filter condition is restricted to being a conjunction, the optimization problem can be cast as a join-ordering problem [10, 13, 14].
Reference: [22] <author> Don S. Batory. </author> <title> On searching transposed files. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(4), </volume> <month> December </month> <year> 1979. </year>
Reference-contexts: On the other hand, the problem of determining an optimal set of conditions to search arises naturally when optimizing single-table queries with multiple indexes [20, 21]. The problem of sequencing the order of accesses to subfiles of transposed files is also closely related <ref> [22] </ref>. However, in the above contexts, the probing cost is either zero or is independent of the predicates. Our approach to defining the execution space is similar in spirit to [21], but our problem is more complex since probe costs can be significant as well as varied.
Reference: [23] <author> M. J. Carey, L. M. Haas, P. M. Schwarz, M. Arya, W. F. Cody, R. Fagin, M. Flickner, A. W. Luniewski, W. Niblack, D. Petkovic, J. Thomas, J. H. Williams, and E. L. Wimmers. </author> <title> Towards heterogeneous multimedia information systems: the Garlic Approach. </title> <booktitle> In RIDE-DOM 1995, </booktitle> <address> Taipei, Taiwan, </address> <year> 1995. </year> <month> 102 </month>
Reference-contexts: In summary, past work in this area does not consider the case where the search cost as well as the probing cost need to be considered for optimization of arbitrarily complex filter conditions containing and's and or's. In the context of the Garlic project at IBM Al-maden <ref> [23] </ref>, Fagin's recent work [1] focuses on how to evaluate queries that ask for a few top matches for a ranking expression. (See Section 4.1.) Our ranking expressions are a special case of Fagin's queries.
References-found: 23

