URL: http://www.cs.wustl.edu/~schmidt/STC-96.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Phone: (TEL) 314-935-7538, (FAX) 314-935-7302  
Title: Using Design Patterns to Develop High-Performance Object-Oriented Communication Software Frameworks  
Author: Douglas C. Schmidtla 
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Abstract: This paper appeared in the Proceedings of the 8 th Annual Software Technology Conference, Salt Lake City, Utah, April 21-26, 1996. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt and P. Stephenson, </author> <title> Experiences Using Design Patterns to Evolve System Software Across Diverse OS Platforms, </title> <booktitle> in Proceedings of the 9 th European Conference 12 on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: Despite dramatic increases in network and host performance, the design and implementation of communication software remains a challenging problem. Moreover, the growing heterogeneity of hardware/software architectures and diversity of operating system platforms often make it hard to directly reuse existing algorithms, detailed designs, interfaces, or implementations <ref> [1] </ref>. Two promising techniques for alleviating communication software complexity are design patterns and object-oriented frameworks. Design patterns capture the static and dynamic structures and collaborations among components in successful solutions to problems that arise when building software [2]. <p> Thus, patterns enable widespread reuse of software architecture, even when reuse of algorithms, implementations, interfaces, or detailed designs is not feasible <ref> [1] </ref>. Likewise, frameworks can be viewed as concrete realizations of design patterns that facilitate direct reuse of design and code. <p> The design patterns and framework components described in this paper have been used extensively throughout large-scale telecommunication and electronic medical imaging projects <ref> [1, 11] </ref>, as well as on academic research projects [4]. <p> Moreover, these strategic patterns express design expertise that can be reused across a broad range of communication software. This family of patterns was discovered based on extensive design and implementation experience with communication systems (including on-line transaction processing systems [16], telecommunication switch management systems <ref> [1] </ref>, electronic medical imaging systems [11], and parallel communication subsystems [4]). Due to space limitations, the strategic Gateway patterns are not described as thoroughly as the patterns in catalogs such as [5, 6], nor are sample implementations provided.
Reference: [2] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: Two promising techniques for alleviating communication software complexity are design patterns and object-oriented frameworks. Design patterns capture the static and dynamic structures and collaborations among components in successful solutions to problems that arise when building software <ref> [2] </ref>. They help to enhance software quality by addressing fundamental challenges in large-scale system development. <p> For instance, the ability to document the intent, structure, and behavior of components in the ACE framework in terms of patterns has significantly reduced software development effort for projects where it has been applied. An in-depth discussion of our experiences and lessons learned using patterns appeared in <ref> [2] </ref>. The object-oriented ACE components described in this paper are freely available via the WWW at http://www.cs.wustl.edu/schmidt/ACE.html. This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ADAPTIVE project [4] at the University of California, Irvine and Washington University.
Reference: [3] <author> R. Johnson and B. Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1, </volume> <pages> pp. 22-35, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: An object-oriented communication framework is an integrated collection of components that cooperate to define a reusable architecture for a family of related communication systems <ref> [3] </ref>. A framework provide a set of semi-complete applications that automate common communication software tasks (such as event demultiplexing, event handler dispatching, connection establishment, routing, configuration of application services, and concurrency control [4]).
Reference: [4] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: A framework provide a set of semi-complete applications that automate common communication software tasks (such as event demultiplexing, event handler dispatching, connection establishment, routing, configuration of application services, and concurrency control <ref> [4] </ref>). The emerging focus on design patterns and communication frameworks in the object-oriented community offers software developers both a language of discourse and a set of directly reusable software components for capturing the essence of successful architectures, components, policies, services, and programming mechanisms. <p> Implementing an object-oriented framework that implements these common patterns The systems described in this paper were implemented with the ADAPTIVE Communication Environment (ACE) software <ref> [4] </ref>. The ACE framework implements a collection of design patterns that recur when building concurrent and reactive [8] communication software. <p> The design patterns and framework components described in this paper have been used extensively throughout large-scale telecommunication and electronic medical imaging projects [1, 11], as well as on academic research projects <ref> [4] </ref>. Both the patterns and the ACE components evolved continuously over time via a continual process of round trip gestalt [7]. 3 An Object-Oriented Framework for the Gateway This section describes how various communication components in the ACE framework were reused and extended to implement the application-level Gateway architecture. <p> 3.1 Applying ACE Components to the Gate way The primary ACE components used in the Gateway include the Reactor [8], which encapsulates the UNIX select event demultiplexing system call; SOCK Stream, SOCK Connector, and SOCK Acceptor [11], which encapsulate the socket network programming interface; and Map Manager and Message Queue <ref> [4] </ref>, which manage communication messages efficiently. These components and their use in the Gateway are described below. * Reactor: The Reactor [8] is a reusable object-oriented event demultiplexing mechanism based on the Reactor pattern (outlined in Section 4.1). <p> This family of patterns was discovered based on extensive design and implementation experience with communication systems (including on-line transaction processing systems [16], telecommunication switch management systems [1], electronic medical imaging systems [11], and parallel communication subsystems <ref> [4] </ref>). Due to space limitations, the strategic Gateway patterns are not described as thoroughly as the patterns in catalogs such as [5, 6], nor are sample implementations provided. Likewise, the tactical patterns shown in Figure 4 are not described in detail either. <p> The Reactor pattern has been used in many single-threaded event-driven frameworks (such as the Motif, Interviews [17], System V STREAMS [18], the ASX object-oriented communication framework <ref> [4] </ref>, and implementations of DCE and CORBA). In addition, it forms as the foundation for the other strategic patterns for application-level Gateways presented below. 4.2 The Connector Pattern Intent: The Connector pattern decouples active 2 service initialization from the tasks performed once a service is initialized. <p> The object-oriented ACE components described in this paper are freely available via the WWW at http://www.cs.wustl.edu/schmidt/ACE.html. This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ADAPTIVE project <ref> [4] </ref> at the University of California, Irvine and Washington University.
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The particular system described in this case study is a reusable object-oriented software architecture for high-performance application-level Gateways. 2.1 System Overview An application-level Gateway routes messages between Peers in a communication system (shown in Figure 1). The Gateway serves as a Mediator <ref> [5] </ref> that decouples co 1 PEERS NETWORK GATEWAY NETWORK PEERS 1: send () 2: recv () 3: route () 4: send () 5: recv () Gateway operating components in a software system and allows them to interact without having direct dependencies on each other [6]. <p> This pattern greatly simplifies the design and quality of service in single-threaded Gateways that use connection-oriented protocols such as TCP/IP or IPX/SPX. Application-level Gateway also utilize many tactical patterns (such as Factories and Iterators <ref> [5] </ref>). Tactical patterns have a relatively localized impact on a software architecture compared with strategic patterns (which have more sweeping implications on software architecture). <p> The Routing Table reuses the ACE Map Manager collection class. A Map Manager is a parameterized collection that efficiently maps external ids (e.g., Peer routing addresses) onto internal ids (e.g., Output Channels). 3 * Channel Connector and Channel Acceptor: The Channel Connector and Channel Acceptor are reusable Factories <ref> [5] </ref> used by the Gateway to actively and passively establish connections with Peers and produce the connected Input Channels and Output Channels described above. These components are based on the Connector pattern (described in Section 4.2) and Acceptor pattern (described in Section 4.3). <p> A design pattern description typically conveys the following information <ref> [5] </ref>: * The intent of the pattern * The design forces that motivate the pattern * The solution to these forces * The related classes and their roles in the solution * The responsibilities and dynamic collaborations among classes * The positive and negative consequences of using the pattern * Guidance <p> Due to space limitations, the strategic Gateway patterns are not described as thoroughly as the patterns in catalogs such as <ref> [5, 6] </ref>, nor are sample implementations provided. Likewise, the tactical patterns shown in Figure 4 are not described in detail either. <p> For instance, Iterator <ref> [5] </ref> is a tactical pattern used in the Gateway to allow Channels in the Routing Table to be processed sequentially without violating data encapsulation. <p> Programmers supply concrete arguments for these types to produce a Concrete Acceptor. Note that a similar degree of decoupling could be achieved via inheritance and dynamic binding by using the Abstract Factory or Factory Method patterns described in <ref> [5] </ref>. Parameterized types were used to implement this pattern since they improve run-time efficiency at the expense of additional compile-time and link-time time and space overhead. Collaboration: Figure 12 illustrates the collaboration among participants in the Acceptor pattern. These collaborations are divided into three phases: 1. <p> When connections arrive, the Reactor calls back to the Acceptor's handle event method. This Template Method <ref> [5] </ref> performs the Acceptor's Svc Handler activation strategy. This strategy assembles the resources necessary to create a new Concrete Svc Handler object, accept the connection into this object, and activate the Svc Handler by calling its open method. 3. <p> Note that the Gateway always returns control to its main event loop immediately after every I/O operation, regardless of whether it sent or received an entire message. This is the essence of the Router pattern it never blocks on any single I/O channel. 5 Related Work <ref> [5, 6, 22] </ref> identify, name, and catalog many fundamental object-oriented design patterns. <p> The Reactor pattern is related to the Observer pattern <ref> [5] </ref>. In the Observer pattern, multiple dependents are updated automatically when a subject changes. In the Reactor pattern, a single handler is dispatched automatically when an event occurs. Thus, For each event the Reactor dispatches a single handler (though there can be multiple sources of events). <p> In the Reactor pattern, a single handler is dispatched automatically when an event occurs. Thus, For each event the Reactor dispatches a single handler (though there can be multiple sources of events). The Reactor pattern also provides a Facade <ref> [5] </ref>. The Facade pattern presents an interface that shields applications from complex object relationships within a subsystem. The Reactor pattern shields applications from complex mechanisms that perform event demultiplexing and event handler dispatching. The mechanism the Reactor uses to dispatch Event Handlers is similar to the Factory Callback pattern [23]. <p> The intent of both patterns is to decoupling event reception from event processing. The primary different is that the Factory Callback is a creational pattern, whereas the Reactor dispatching is a behavioral pattern. The Connector pattern is a variation of the Template Method and Factory Method patterns <ref> [5] </ref>. In the Template Method pattern, an algorithm is written such that some steps are supplied by a derived class. <p> They both are concerned with separating active connection establishment from the subsequent service. The primary difference is that the Connector pattern addresses both syn chronous and asynchronous connection establishment. The Acceptor pattern can also be viewed as a variation of the Template Method and Factory Method patterns <ref> [5] </ref>. The Acceptor pattern is a connection factory that uses a template method (handle event) to create handlers for communication channels. The handle event method implements the algorithm that passively listens for connection requests, then creates and activates a handler when the connection is established.
Reference: [6] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: The Gateway serves as a Mediator [5] that decouples co 1 PEERS NETWORK GATEWAY NETWORK PEERS 1: send () 2: recv () 3: route () 4: send () 5: recv () Gateway operating components in a software system and allows them to interact without having direct dependencies on each other <ref> [6] </ref>. Messages routed through a Gateway typically contain payloads such as commands, status messages, and bulk data exchanged by Peers. These payloads are encapsulated in routing messages. <p> A family of design patterns (also called a pattern language [15] or a pattern system <ref> [6] </ref>) is a set of related patterns that collaborate to solve a broader set of problems that arise in a domain. A pattern family description illustrates how the constituent patterns interact to form a web of design solutions [6]. <p> design patterns (also called a pattern language [15] or a pattern system <ref> [6] </ref>) is a set of related patterns that collaborate to solve a broader set of problems that arise in a domain. A pattern family description illustrates how the constituent patterns interact to form a web of design solutions [6]. Figure 4 illustrates the key strategic and 4 ConnectorConnector ActiveActive ObjectObject ReactorReactor BuilderBuilder IteratorIterator AdapterAdapter TemplateTemplate MethodMethod TACTICALTACTICAL PATTERNSPATTERNS STRATEGIC PATTERNS AcceptorAcceptor RouterRouter ProxyProxy tactical patterns in a family of patterns for singled-threaded, connection-oriented application-level Gateways. <p> Due to space limitations, the strategic Gateway patterns are not described as thoroughly as the patterns in catalogs such as <ref> [5, 6] </ref>, nor are sample implementations provided. Likewise, the tactical patterns shown in Figure 4 are not described in detail either. <p> Note that the Gateway always returns control to its main event loop immediately after every I/O operation, regardless of whether it sent or received an entire message. This is the essence of the Router pattern it never blocks on any single I/O channel. 5 Related Work <ref> [5, 6, 22] </ref> identify, name, and catalog many fundamental object-oriented design patterns. <p> In the Connector pattern, the connect method implements a standard algorithm for initiating a connection and activating a handler when the connection is established. The intent of the Connector pattern is similar to the Client/Dispatcher/Server pattern described in <ref> [6] </ref>. They both are concerned with separating active connection establishment from the subsequent service. The primary difference is that the Connector pattern addresses both syn chronous and asynchronous connection establishment. The Acceptor pattern can also be viewed as a variation of the Template Method and Factory Method patterns [5]. <p> The handler performs a service using data exchanged on the connection. Thus, the service is decoupled from the network programming interface and the transport protocol used to establish the connection. The Router pattern is a specialization of the Gateway pattern in <ref> [6] </ref>. The Gateway pattern decouples cooperating components of a software system and allows them to interact without having direct dependencies among each other. The Router pattern decouples the mechanisms used to process input messages from the mechanisms used to process output mechanisms to prevent blocking.
Reference: [7] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: Figure 2 illustrates the structure, associations, and internal and external collaborations among objects within a reusable software architecture for application-level Gateways. 1 This architecture 1 Relationships between components are illustrated throughout this paper using Booch notation <ref> [7] </ref>. In these figures solid clouds indicate objects; nesting indicates composition relationships between objects; and undirected edges indicate some type of link exists between two objects. <p> Both the patterns and the ACE components evolved continuously over time via a continual process of round trip gestalt <ref> [7] </ref>. 3 An Object-Oriented Framework for the Gateway This section describes how various communication components in the ACE framework were reused and extended to implement the application-level Gateway architecture.
Reference: [8] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The ability to reuse these components so widely stems from two factors: 1. Understanding the strategic design patterns within the domain of communication software Some of these patterns have been documented individually in the patterns literature (such as the Reactor <ref> [8] </ref>, Connector [9], and the Acceptor [10]). Section 4 describes several of these patterns in terms of an integrated system of design patterns that characterize the structure and collaboration of communication software patterns in the context of application-level Gateways. 2. <p> Implementing an object-oriented framework that implements these common patterns The systems described in this paper were implemented with the ADAPTIVE Communication Environment (ACE) software [4]. The ACE framework implements a collection of design patterns that recur when building concurrent and reactive <ref> [8] </ref> communication software. ACE provides a rich set of reusable C++ wrappers, class categories, and frameworks that perform common communication software tasks (such as event demultiplexing, event handler dispatching, connection establishment, routing, dynamic configuration of application services, and concurrency control). <p> Routing TableTable : Map: Map ManagerManager : Output: Output ChannelChannel : Message: Message QueueQueue : SOCK: SOCK StreamStream : Input: Input ChannelChannel : SOCK: SOCK StreamStream : Reactor: Reactor PEERS PEERS 3.1 Applying ACE Components to the Gate way The primary ACE components used in the Gateway include the Reactor <ref> [8] </ref>, which encapsulates the UNIX select event demultiplexing system call; SOCK Stream, SOCK Connector, and SOCK Acceptor [11], which encapsulate the socket network programming interface; and Map Manager and Message Queue [4], which manage communication messages efficiently. <p> These components and their use in the Gateway are described below. * Reactor: The Reactor <ref> [8] </ref> is a reusable object-oriented event demultiplexing mechanism based on the Reactor pattern (outlined in Section 4.1). It channels all external event stimuli in a Gateway to a single demultiplexing point. This permits single-threaded Gateways to wait on events handles, demultiplex events, and dispatch event handlers efficiently.
Reference: [9] <author> D. C. Schmidt, </author> <title> Connector: a Design Pattern for Actively Initializing Network Services, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: The ability to reuse these components so widely stems from two factors: 1. Understanding the strategic design patterns within the domain of communication software Some of these patterns have been documented individually in the patterns literature (such as the Reactor [8], Connector <ref> [9] </ref>, and the Acceptor [10]). Section 4 describes several of these patterns in terms of an integrated system of design patterns that characterize the structure and collaboration of communication software patterns in the context of application-level Gateways. 2.
Reference: [10] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns For Flexibly Configuring Network Services in Distributed Systems, </title> <booktitle> in International Conference on Configurable Distributed Systems, </booktitle> <month> May 6-8 </month> <year> 1996. </year>
Reference-contexts: The ability to reuse these components so widely stems from two factors: 1. Understanding the strategic design patterns within the domain of communication software Some of these patterns have been documented individually in the patterns literature (such as the Reactor [8], Connector [9], and the Acceptor <ref> [10] </ref>). Section 4 describes several of these patterns in terms of an integrated system of design patterns that characterize the structure and collaboration of communication software patterns in the context of application-level Gateways. 2.
Reference: [11] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: The design patterns and framework components described in this paper have been used extensively throughout large-scale telecommunication and electronic medical imaging projects <ref> [1, 11] </ref>, as well as on academic research projects [4]. <p> StreamStream : Input: Input ChannelChannel : SOCK: SOCK StreamStream : Reactor: Reactor PEERS PEERS 3.1 Applying ACE Components to the Gate way The primary ACE components used in the Gateway include the Reactor [8], which encapsulates the UNIX select event demultiplexing system call; SOCK Stream, SOCK Connector, and SOCK Acceptor <ref> [11] </ref>, which encapsulate the socket network programming interface; and Map Manager and Message Queue [4], which manage communication messages efficiently. <p> In a large system several hundred Peers may be connected to a single Gateway. To expedite connection setup initiated from the Gateway to all these Peers, the Gateway uses the asynchronous connection mechanisms provided by the Channel Connector and its underlying ACE SOCK Connector <ref> [11] </ref>. When a SOCK Connector connects two socket endpoints via TCP it produces a SOCK Stream object, which is used to exchange data between that Peer and the Gateway. To decrease connection establishment latency, the Gateway's Channel Connector initiates all connections asynchronously rather than connecting each Peer synchronously. <p> There are several reasons for this decision: * The performance of CORBA implementations has generally not been optimized to eliminate key sources of communication overhead for transmitting bulk data over high-speed, long-delay networks <ref> [11, 13] </ref>. This overhead stems from non-optimized presentation layer conversions, data copying, and memory management, inefficient receiver-side demultiplexing and dispatching operations, synchronous stop-and-wait flow control, and non-adaptive retransmission timer schemes. * CORBA is not well suited to handle the peer-to-peer, asynchronous behavior of the Gateway. <p> Moreover, these strategic patterns express design expertise that can be reused across a broad range of communication software. This family of patterns was discovered based on extensive design and implementation experience with communication systems (including on-line transaction processing systems [16], telecommunication switch management systems [1], electronic medical imaging systems <ref> [11] </ref>, and parallel communication subsystems [4]). Due to space limitations, the strategic Gateway patterns are not described as thoroughly as the patterns in catalogs such as [5, 6], nor are sample implementations provided. Likewise, the tactical patterns shown in Figure 4 are not described in detail either.
Reference: [12] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 1.2 ed., </editor> <year> 1993. </year>
Reference-contexts: In particular, the Gateway does not higher-level distributed object computing tools like CORBA <ref> [12] </ref> for its communication infrastructure. There are several reasons for this decision: * The performance of CORBA implementations has generally not been optimized to eliminate key sources of communication overhead for transmitting bulk data over high-speed, long-delay networks [11, 13].
Reference: [13] <author> D. C. Schmidt, T. H. Harrison, and I. Pyarali, </author> <title> Experience Developing an Object-Oriented Framework for High-Performance Electronic Medical Imaging using CORBA and C++, </title> <booktitle> in Proceedings of the Software Technology Applied to Imaging and Multimedia Applications mini-conference at the Symposium on Electronic Imaging in the International Symposia Photonics West, SPIE, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: There are several reasons for this decision: * The performance of CORBA implementations has generally not been optimized to eliminate key sources of communication overhead for transmitting bulk data over high-speed, long-delay networks <ref> [11, 13] </ref>. This overhead stems from non-optimized presentation layer conversions, data copying, and memory management, inefficient receiver-side demultiplexing and dispatching operations, synchronous stop-and-wait flow control, and non-adaptive retransmission timer schemes. * CORBA is not well suited to handle the peer-to-peer, asynchronous behavior of the Gateway.
Reference: [14] <institution> Object Management Group, </institution> <note> Universal Networked Objects, TC Document 95-3-xx ed., </note> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Many versions of CORBA block a sender when a TCP connection encounters flow control. Therefore, it is hard to write a robust, single-threaded application that will not hang indefinitely. * Legacy communication applications and protocol stacks do not conform to the CORBA interface nor its wire protocol <ref> [14] </ref>. When combined with the output blocking problem described above, the level of effort required to port legacy applications to CORBA clearly exceeds the benefits of using a single OO communication infrastructure.
Reference: [15] <author> J. O. Coplien, </author> <title> A Development Process Generative Pattern Language, in Pattern Languages of Programs (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: A family of design patterns (also called a pattern language <ref> [15] </ref> or a pattern system [6]) is a set of related patterns that collaborate to solve a broader set of problems that arise in a domain. A pattern family description illustrates how the constituent patterns interact to form a web of design solutions [6].
Reference: [16] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Actively and Passively Initializing Network Services, </title> <booktitle> in Workshop on Pattern Languages of Object-Oriented Programs at ECOOP '95, </booktitle> <address> (Aarhus, Denmark), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Moreover, these strategic patterns express design expertise that can be reused across a broad range of communication software. This family of patterns was discovered based on extensive design and implementation experience with communication systems (including on-line transaction processing systems <ref> [16] </ref>, telecommunication switch management systems [1], electronic medical imaging systems [11], and parallel communication subsystems [4]). Due to space limitations, the strategic Gateway patterns are not described as thoroughly as the patterns in catalogs such as [5, 6], nor are sample implementations provided.
Reference: [17] <author> M. A. Linton, J. Vlissides, and P. Calder, </author> <title> Composing User Interfaces with InterViews, </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The Reactor pattern has been used in many single-threaded event-driven frameworks (such as the Motif, Interviews <ref> [17] </ref>, System V STREAMS [18], the ASX object-oriented communication framework [4], and implementations of DCE and CORBA).
Reference: [18] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: The Reactor pattern has been used in many single-threaded event-driven frameworks (such as the Motif, Interviews [17], System V STREAMS <ref> [18] </ref>, the ASX object-oriented communication framework [4], and implementations of DCE and CORBA).
Reference: [19] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Forces: The Connector pattern resolves the following forces that impact the design of connection-oriented communication software (particularly clients) when using lower-level network programming interfaces (like sockets <ref> [19] </ref> and TLI [20]): 1. The need to reuse active connection establishment code for each new service The Connector pattern permits key characteristics of services (such as the concurrency strategy or the data format) to evolve independently and transparently from the mechanisms used to establish the connections. <p> Forces: The Acceptor pattern resolves the following forces that impact the design of connection-oriented communication software (particularly servers) when using lower-level network programming interfaces (like sockets <ref> [19] </ref> and TLI [20]): 1. The need to reuse passive connection establishment code for each new service The Acceptor pattern permits key characteristics of services (such as the concurrency strategy or the data format) to evolve independently and transparently from the mechanisms used to establish the connections. <p> In this case, the Peers connect to Gateway, which uses the Acceptor pattern to decouple the activity of connecting passively from the routing service provided once the connection is established. The intent and general architecture of the Acceptor pattern is also found in network server management tools like inetd <ref> [19] </ref> and listen [20]. These tools utilize a master acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [20] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Forces: The Connector pattern resolves the following forces that impact the design of connection-oriented communication software (particularly clients) when using lower-level network programming interfaces (like sockets [19] and TLI <ref> [20] </ref>): 1. The need to reuse active connection establishment code for each new service The Connector pattern permits key characteristics of services (such as the concurrency strategy or the data format) to evolve independently and transparently from the mechanisms used to establish the connections. <p> Forces: The Acceptor pattern resolves the following forces that impact the design of connection-oriented communication software (particularly servers) when using lower-level network programming interfaces (like sockets [19] and TLI <ref> [20] </ref>): 1. The need to reuse passive connection establishment code for each new service The Acceptor pattern permits key characteristics of services (such as the concurrency strategy or the data format) to evolve independently and transparently from the mechanisms used to establish the connections. <p> The intent and general architecture of the Acceptor pattern is also found in network server management tools like inetd [19] and listen <ref> [20] </ref>. These tools utilize a master acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [21] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Service processing phase which performs the application-specific service processing using the data exchanged between the Svc Handler and its connected peer. Depending on the open method of Svc Handler, this phase may employ the Reactor pattern (or some other type of concurrency mechanisms such as Active Objects <ref> [21] </ref>) to process incoming events. For example, when commands arrive at a Command Handler in the Gateway, the Reactor dispatches Event Handlers to frame the commands, determine outgoing routes, and deliver the commands to their destinations. the Connector pattern using asynchronous connection establishment. <p> Service processing phase once activated, the Svc Handler processes incoming event messages arriving on the PEER STREAM. A Svc Handler will process incoming event messages using the Reactor pattern or some other form of concurrent event handling such as the Active Object pattern <ref> [21] </ref>. The concurrency strategy used by a Svc Handler is defined by its open method. Uses: Figure 13 illustrates how the Acceptor pattern is used by the Gateway. The Gateway uses this pattern when it plays the passive connection role.
Reference: [22] <editor> J. O. Coplien and D. C. Schmidt, eds., </editor> <booktitle> Pattern Languages of Program Design. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Note that the Gateway always returns control to its main event loop immediately after every I/O operation, regardless of whether it sent or received an entire message. This is the essence of the Router pattern it never blocks on any single I/O channel. 5 Related Work <ref> [5, 6, 22] </ref> identify, name, and catalog many fundamental object-oriented design patterns.
Reference: [23] <author> S. Berczuk, </author> <title> A Pattern for Separating Assembly and Processing, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The Facade pattern presents an interface that shields applications from complex object relationships within a subsystem. The Reactor pattern shields applications from complex mechanisms that perform event demultiplexing and event handler dispatching. The mechanism the Reactor uses to dispatch Event Handlers is similar to the Factory Callback pattern <ref> [23] </ref>. The intent of both patterns is to decoupling event reception from event processing. The primary different is that the Factory Callback is a creational pattern, whereas the Reactor dispatching is a behavioral pattern. The Connector pattern is a variation of the Template Method and Factory Method patterns [5].
References-found: 23

