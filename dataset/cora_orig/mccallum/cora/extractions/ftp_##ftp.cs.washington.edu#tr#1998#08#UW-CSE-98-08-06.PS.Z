URL: ftp://ftp.cs.washington.edu/tr/1998/08/UW-CSE-98-08-06.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-date.html
Root-URL: http://www.cs.washington.edu
Email: amir@cs.washington.edu  
Title: Imitation: An Alternative to Generalization in Programming by Demonstration Systems  
Author: Amir Michail 
Web: http://www.cs.washington.edu/homes/amir/Opsis.html  
Address: Washington  
Affiliation: University of  
Pubnum: Technical Report UW-CSE-98-08-06  
Abstract: In this paper, we propose a new mechanism, imitation, which can be used in a programming by demonstration system as an alternative to generalization. A system using imitation always asks the user for help when a new case arises in an algorithm. At this point, the user may demonstrate the steps for this case or tell the system: (1) that this case is similar to another one already demonstrated and (2) in what way it is similar. In this way, the user can use imitation to generate code for the new case based on the one already demonstrated. Generalization is not required at any point while programming using this technique. We demonstrate our imitation method using Opsis, a system we built to teach binary search tree algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. M. Adel'son-Vel'skii and E. M. Landis. </author> <title> An Algorithm for the Organization of Information. </title> <journal> Soviet Math. Doklady, </journal> <volume> 3:12591262, </volume> <year> 1962. </year>
Reference-contexts: In particular, we show how imitation can be useful in demonstrating the double rotations in the AVL tree insertion algorithm <ref> [1] </ref>. 2.1 AVL Tree Insertion An AVL tree is a binary tree in which each node has left and right (possibly empty) subtrees whose height differ by at most one. The balance of a node is the height of its right subtree minus the height of its left subtree.
Reference: [2] <author> G. A. Curry. </author> <title> Programming by Abstract Demonstration. </title> <type> Technical Report 78-03-02, </type> <institution> University of Wash-ington, </institution> <year> 1978. </year> <type> PhD thesis. </type>
Reference-contexts: The student does this by manipulating abstract trees, each of which represents a set of binary trees with particular properties. (Opsis uses programming by abstract demonstration <ref> [2] </ref>.) During such a demonstration, the student would encounter six abstract cases in which a double rotation is required. (See Figure 2. A black node denotes the newly inserted node while a black subtree indicates a subtree containing this node.
Reference: [3] <author> D. C. Halbert. </author> <title> Programming by Example. </title> <type> Technical Report OSD-T8402, </type> <institution> Office Systems Division, Xe-rox Corporation, 1984. Reprint of Berkeley Computer Science PhD thesis. </institution>
Reference-contexts: In this way, users never have to anticipate cases (by providing conditionals ahead of time); they only have to react to the current situation. However, this feature doesn't reduce the number of cases to be demonstrated. Daniel Halbert's SmallStar <ref> [3] </ref> allows the user to demonstrate only one of the cases. Demonstrating the one case generates a straight-line program which users generalize after the fact by manually adding set iteration and conditionals. The generalized code can then be applied to other similar cases. Brad A. <p> Unless the same graphical conventions are used by the system during normal editing, the user would need to learn a new visual language in order to define macros. For this reason, many systems such as Kurlander's Chimera [4] and Halbert's SmallStar <ref> [3] </ref> depict generalizations by using textual annotations along with the particular case demonstrated by the user. However, such a solution still requires the user to interpret a more complicated textual/graphical vocabulary. Concerning problem (2), David C. <p> Of course, in other domains (such as linear algebra), there may be many varieties of imitation mechanisms. As far as we know, replaying commands in one of several distinct ways is unique to our approach. Chimera (and SmallStar <ref> [3] </ref>) actually provide a macro definition mechanism that does handle conditionals and loops. However, this mechanism requires two steps: a demonstration step followed by a generalization step. The demonstration pass is a simple sequence of commands while the generalization pass allows the addition of conditionals and loops.
Reference: [4] <author> D. J. Kurlander. </author> <title> Graphical Editing by Example. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Concerning problem (1), David J. Kurlander writes in <ref> [4] </ref>, p. 168: If the number of generalizations known by the system is large, then the graphical vocabulary must also be large. Unless the same graphical conventions are used by the system during normal editing, the user would need to learn a new visual language in order to define macros. <p> Unless the same graphical conventions are used by the system during normal editing, the user would need to learn a new visual language in order to define macros. For this reason, many systems such as Kurlander's Chimera <ref> [4] </ref> and Halbert's SmallStar [3] depict generalizations by using textual annotations along with the particular case demonstrated by the user. However, such a solution still requires the user to interpret a more complicated textual/graphical vocabulary. Concerning problem (2), David C. <p> We refer the interested reader to [8] for a description of the Opsis implementation of this procedure. 4 Related Work Our imitation mechanism is most closely related to the editable graphical histories of Chimera <ref> [4] </ref>. Ed-itable graphical histories depict important events in the history of the application by using a sequence of panels. A user may make changes to the history sequence, in place, by edits to the panels themselves. Any such changes are propagated automatically to the present state.
Reference: [5] <author> H. Lieberman. </author> <title> Seeing What Your Programs are Doing. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 21:311331, </volume> <year> 1984. </year>
Reference-contexts: David C. Smith's Pygmalion [11, 12], the first programming by demonstration system, requires users to specify the program in full generality so they must anticipate and generalize similar cases of an algorithm ahead of time to avoid repetition in the demonstration. Henry Lieberman's Tinker <ref> [5, 6] </ref> allows users to demonstrate one case at a time and will ask them to provide a predicate to distinguish one case from another. In this way, users never have to anticipate cases (by providing conditionals ahead of time); they only have to react to the current situation.
Reference: [6] <author> H. Lieberman. </author> <title> An Example Based Environment for Beginning Programmers. </title> <institution> Instructional Science, 14:277292, </institution> <year> 1986. </year>
Reference-contexts: David C. Smith's Pygmalion [11, 12], the first programming by demonstration system, requires users to specify the program in full generality so they must anticipate and generalize similar cases of an algorithm ahead of time to avoid repetition in the demonstration. Henry Lieberman's Tinker <ref> [5, 6] </ref> allows users to demonstrate one case at a time and will ask them to provide a predicate to distinguish one case from another. In this way, users never have to anticipate cases (by providing conditionals ahead of time); they only have to react to the current situation.
Reference: [7] <author> A. Michail. </author> <title> Teaching Binary Tree Algorithms through Visual Programming. </title> <booktitle> In Symposium on Visual Languages, </booktitle> <pages> pages 3845. </pages> <publisher> IEEE, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: In this way, the user can use imitation to generate code for the new case based on the one already demonstrated. Generalization is not required at any point while programming using this technique. We demonstrate our imitation method using Opsis <ref> [7] </ref>, a system we built to teach binary search tree algorithms.
Reference: [8] <author> A. Michail. </author> <title> Visual Programming without Procedures. </title> <type> Technical Report UW-CSE-97-05-02, </type> <institution> University of Washington, </institution> <year> 1997. </year>
Reference-contexts: The determineSelectedFragments is a domain dependent heuristic. Our implementation in Opsis is rather complex and allows students not only to imitate similar cases but also to make non-trivial editing changes to the state graph. We refer the interested reader to <ref> [8] </ref> for a description of the Opsis implementation of this procedure. 4 Related Work Our imitation mechanism is most closely related to the editable graphical histories of Chimera [4]. Ed-itable graphical histories depict important events in the history of the application by using a sequence of panels.
Reference: [9] <author> B. A. Myers. </author> <title> Creating User Interfaces by Demonstration. </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: Demonstrating the one case generates a straight-line program which users generalize after the fact by manually adding set iteration and conditionals. The generalized code can then be applied to other similar cases. Brad A. Myers' Peridot <ref> [10, 9] </ref> uses inferencing to generalize a demonstration of one case so that it can be applied to other similar cases. To reduce incorrect generalizations, Peridot asks questions to aid its infer-encing process. <p> As with other inferencing systems, such as Peridot <ref> [10, 9] </ref>, Opsis may ask the user questions throughout the inferencing process. <p> Our approach avoids the generalization step and provides a simpler scheme in which both the demonstration and imitation mechanisms allow conditionals and loops. Finally, we should mention that much of the work on inferencing (such as in Peridot <ref> [10, 9] </ref>) can also be used in our imitation method. However, it is preferable to provide several varieties of imitate methods rather than fewer more unpredictable ones that rely heavily on inferencing.
Reference: [10] <author> B. A. Myers and W. Buxton. </author> <title> Creating Highly Interactive and Graphical User Interfaces by Demonstration. </title> <journal> Computer Graphics, </journal> <volume> 20(4):249268, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Demonstrating the one case generates a straight-line program which users generalize after the fact by manually adding set iteration and conditionals. The generalized code can then be applied to other similar cases. Brad A. Myers' Peridot <ref> [10, 9] </ref> uses inferencing to generalize a demonstration of one case so that it can be applied to other similar cases. To reduce incorrect generalizations, Peridot asks questions to aid its infer-encing process. <p> As with other inferencing systems, such as Peridot <ref> [10, 9] </ref>, Opsis may ask the user questions throughout the inferencing process. <p> Our approach avoids the generalization step and provides a simpler scheme in which both the demonstration and imitation mechanisms allow conditionals and loops. Finally, we should mention that much of the work on inferencing (such as in Peridot <ref> [10, 9] </ref>) can also be used in our imitation method. However, it is preferable to provide several varieties of imitate methods rather than fewer more unpredictable ones that rely heavily on inferencing.
Reference: [11] <author> D. C. Smith. Pygmalion: </author> <title> A Computer Program to Model and Stimulate Creative Thought. </title> <publisher> Birkhauser, Verlag, </publisher> <address> Basel, Stuttgart, </address> <year> 1977. </year> <booktitle> Reprint of 1975 Stan-ford Computer Science PhD thesis. </booktitle>
Reference-contexts: By using generalization, we can abstract out the similarities and avoid having to demonstrate each of these cases separately. How this would be done varies widely among programming by demonstration systems. David C. Smith's Pygmalion <ref> [11, 12] </ref>, the first programming by demonstration system, requires users to specify the program in full generality so they must anticipate and generalize similar cases of an algorithm ahead of time to avoid repetition in the demonstration.
Reference: [12] <author> D. C. Smith. Pygmalion: </author> <title> An Executable Electronic Blackboard. </title> <editor> In A. Cypher, editor, </editor> <title> Watch What I Do: Programming by Demonstration, </title> <booktitle> pages 1947. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year> <month> 9 </month>
Reference-contexts: By using generalization, we can abstract out the similarities and avoid having to demonstrate each of these cases separately. How this would be done varies widely among programming by demonstration systems. David C. Smith's Pygmalion <ref> [11, 12] </ref>, the first programming by demonstration system, requires users to specify the program in full generality so they must anticipate and generalize similar cases of an algorithm ahead of time to avoid repetition in the demonstration. <p> However, such a solution still requires the user to interpret a more complicated textual/graphical vocabulary. Concerning problem (2), David C. Smith writes in <ref> [12] </ref>, p. 32: . . . on the one hand, it (Pygmalion) attempts to make programming accessible to a wider class of users; on the other hand, it relies on the kind of planning which only experienced programmers are good at. Abstracting and generalizing similar cases requires experience and planning.
References-found: 12

