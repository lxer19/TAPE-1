URL: http://www-csag.cs.uiuc.edu/papers/accessregion.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Email: fa-coday,achieng@cs.uiuc.edu  
Title: Access Region Expansion in the Concert Compiler  
Author: Aaron C. Coday and Andrew A. Chien 
Date: March 27, 1998  
Affiliation: Department of Computer Science, University of Illinois at Urbana-Champaign  
Abstract: Concurrent Object Oriented Programming introduces significant challenges for a compiler. We examine one of these challenges, access region expansion, from two perspectives; compiler runtime performance and quality of access region expansion. The work was done within the Concert Compiler framework. We found that with clever modifications the compiler runtime performance could be significantly improved ( 4X). We also found that while there are inherent limitations to the quality of access region expansion, our implementation is overly restrictive. We conclude that further work in this topic needs to be done to fully understand the problem and define an optimal solution.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. A. Chien and W. J. Dally. </author> <title> Concurrent Aggregates (CA). </title> <booktitle> In Proceedings of Second Symposium on Principles and Practice of Parallel Programming. ACM, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: Currently, the compiler supports Concurrent Aggregates <ref> [1] </ref> and ICC++[2], which is a concurrent extension of C++. The compiler builds an internal representation from the input program. The internal representation is then used to do analysis and optimizations.
Reference: [2] <author> Andrew Chien and Uday Reddy. </author> <title> ICC++ language definition. Concurrent Systems Architecture Group Memo, </title> <note> Also available from http://www-csag.cs.uiuc.edu, February 1995. </note>
Reference: [3] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> An efficient method of computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The internal representation is then used to do analysis and optimizations. The compiler finally outputs C code, which can be compiled on several platforms with little additional effort. 2.2 Internal Representation The Concert compiler uses a program dependence graph [5] (PDG) combined with static single-assignment (SSA) <ref> [3] </ref> as the main vehicle of our internal representation. The PDG is especially useful because it explicitly represents both control and data dependencies. Such information makes many transformations easy, such as branch deletion.
Reference: [4] <author> Pedro C. Diniz and Martin C. Rinard. </author> <title> Dynamic feedback: An effective technique for adaptive computing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 71-84, </pages> <year> 1997. </year>
Reference-contexts: There are several notions that are missing from the current algorithm. A good algorithm would need to consider the tradeoff between reducing synchronization overhead and available concurrency. Rinard and Diniz attempted to tackle this problem by making the choice at runtime <ref> [4] </ref>. It is not clear that this decision cannot be made at compile time. A good algorithm needs to consider the optimizing access regions for the entire program. Currently, our access region expansion algorithm only looks within methods.
Reference: [5] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-49, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: The compiler builds an internal representation from the input program. The internal representation is then used to do analysis and optimizations. The compiler finally outputs C code, which can be compiled on several platforms with little additional effort. 2.2 Internal Representation The Concert compiler uses a program dependence graph <ref> [5] </ref> (PDG) combined with static single-assignment (SSA) [3] as the main vehicle of our internal representation. The PDG is especially useful because it explicitly represents both control and data dependencies. Such information makes many transformations easy, such as branch deletion.
Reference: [6] <author> Rakesh Ghiya and Laurie Hendren. </author> <title> Putting pointer analysis to work. </title> <booktitle> In Twenty Fifth Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 121-133, </pages> <year> 1998. </year>
Reference-contexts: Concert uses a variation of store-based analysis for determining aliasing between objects. Store-based analyses typically treat heap allocated objects as a static set of named locations <ref> [6] </ref>. In object oriented languages this would not suffice, since heap allocated objects probably dominate. A simple approach would be to assume that objects of the same type are potentially aliased. One step further than this would be to group dynamically allocated objects by their creation site.
Reference: [7] <author> John Plevyak. </author> <title> Optimization of Object-Oriented and Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <year> 1996. </year> <month> 11 </month>
Reference-contexts: One step further than this would be to group dynamically allocated objects by their creation site. Concert goes one step further. We group objects both by their creation site and the context of the creation site. This information is referred to as an object contour <ref> [7] </ref>. This information can distinguish two objects of the same type and same creation site, if they were created under different contexts. However, it will not be able to distinguish two objects of the same type if they are from the same creation site and context.
Reference: [8] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency in concurrent object-oriented programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 311-321, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The programming model is where each object can act concurrently to update its own state, create new objects, or invoke methods on other objects. Only one of an object's operations may be active at a given time. This translates to associating a monitor style lock to each object <ref> [8] </ref>. One of the key optimizations in the Concert Compiler is speculative inlining. If the target object of a method invocation is local, then the linkage to execute that method should be similar to a regular procedure call. This can also lead to inlining the method itself. <p> Once this is all down, then the second access region is discarded. 3.2.3 Hoisting regions Hoisting an access region above a control flow construct can improve code efficiency by moving access checks outside of a loop <ref> [8] </ref>. There are only two types of control flow in the PDG; if- then-else and while loops. In addition to the correctness properties mentioned before, hoisting access regions requires some additional constraints. While loops require that there be only one access region in the loop body.
Reference: [9] <author> Gregory V. Wilson and Paul Lu, </author> <title> editors. Parallel Programming Using C++. </title> <publisher> MIT Press, </publisher> <year> 1995. </year> <month> 12 </month>
Reference-contexts: Since the Concert Compiler is written in Common Lisp, the standard profiling package in Common Lisp was used. Table 1 shows the total time and total memory allocated by access region expansion algorithm for several benchmark 4 programs 1 . Poly-over is a benchmark from <ref> [9] </ref> that calculates overlays of polygon maps. Silo is an event simulator benchmark from the repository at Colorado 2 . Richards is an operating system benchmark. These are all relatively small benchmarks (&lt;= 1000 lines of code).
References-found: 9

