URL: http://cse.ogi.edu/~sheard/papers/interp2compiler.ps
Refering-URL: http://www.cse.ogi.edu/~sheard/sheard.html
Root-URL: http://www.cse.ogi.edu
Title: From Interpreter to Compiler using Staging and Monads  
Author: Tim Sheard and Zine-el-abidine Benaissa 
Date: April 14, 1998  
Address: P.O. Box 91000 Portland, Oregon 97291-1000 USA  
Affiliation: Pacific Software Research Center Oregon Graduate Institute  
Abstract: In writing this paper we had two goals. First, to promote MetaML, a programming language for writing staged programs, and second, to demonstrate that staging a program can have significant benefits. We do this by example: the derivation of an executable compiler for a small language. We derive the compiler in a rigorous fashion from a semantic description of the language. This is done by staging a de-notational semantics, expressed as a monadic interpreter. The compiler is a program generator, taking a program in the source language (a while-program) as input and producing an ML program as target. The ML program produced is in a restricted subset of ML over which the programmer has complete control. It is encapsulated in a special data-structure called code. The meta-programming capabilities of MetaML allow this data-structure to be directly executed (run-time code generation), or to be analysed. We illustrate this analysis of generated code to build a source to source transformation which applies the monad laws to significantly improve the generated code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anders Bondorf and Olivier Danvy. </author> <title> Automatic autoprojectin of recursive equations with global variables and data types. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 151-195, </pages> <year> 1991. </year>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation <ref> [34, 17, 1, 3, 2, 9] </ref>; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13].
Reference: [2] <author> Anders Bondorf and Jens Palsberg. </author> <title> Compiling actions by partial evaluation. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 308-320, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher> <address> Copenhagen. </address>
Reference-contexts: Because the programmer has complete control over the structure of the residual program this can be a trivial task. Staging of interpreters using partial evaluation has been done before <ref> [2, 4] </ref>. The contribution of this paper is to show that this can all be done in a single program. A system incorporating staging as a first class feature of a language is a powerful tool. <p> Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation <ref> [34, 17, 1, 3, 2, 9] </ref>; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13].
Reference: [3] <author> C. Consel. </author> <title> A tour of schism: A partial evaluation system for higher-order applicative languages. In Partial Evaluation and Semantics-Based Program Manipulation, </title> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993, </year> <pages> pages 145-154. </pages> <address> New York: </address> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation <ref> [34, 17, 1, 3, 2, 9] </ref>; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13].
Reference: [4] <author> O Danvy, J Koslowski, and K Malmkjaer. </author> <title> Compiling monads. </title> <type> Technical Report CIS-92-3, </type> <institution> Kansas State University, Manhattan, Kansas, </institution> <month> December 91. </month>
Reference-contexts: Because the programmer has complete control over the structure of the residual program this can be a trivial task. Staging of interpreters using partial evaluation has been done before <ref> [2, 4] </ref>. The contribution of this paper is to show that this can all be done in a single program. A system incorporating staging as a first class feature of a language is a powerful tool. <p> Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers <ref> [29, 20, 4] </ref>; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul
Reference: [5] <author> Rowan Davies. </author> <title> A temporal-logic approach to binding-time analysis. </title> <booktitle> In Proceedings, 11 th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 184-195, </pages> <address> New Brunswick, New Jersey, 27-30 July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming <ref> [5, 6] </ref> and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work
Reference: [6] <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In 23rd Annual ACM Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St.Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <title> 1 as well as the laws for fi-value, let-normalization, and -value reduction 16 </title>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming <ref> [5, 6] </ref> and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work
Reference: [7] <author> Carsten Sch urmann Frank Pfenning, Jo elle Despeyroux. </author> <title> Primitive recursion for higher-order abstract syntax. </title> <booktitle> In Third International Conference on Typed Lambda Calculi and Applications, number 1210 in LNCS, </booktitle> <pages> pages 147-163. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching <ref> [16, 7] </ref> For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13]. They investigate the derivation of a compiler from a modular monadic interpreter.
Reference: [8] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: First, it declares that the argument ('M : * -&gt; * ) of the type constructor Monad is itself a unary type constructor <ref> [8] </ref>. We say that 'M has kind: * -&gt; *. Second, it declares that the arguments to the constructor Mon must be polymorphic functions [21]. The type variables in brackets, e.g. ['a,'b], are universally quantified.
Reference: [9] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <editor> Series editor C. A. R. </editor> <booktitle> Hoare. Prentice Hall International, International Series in Computer Science, </booktitle> <month> June </month> <year> 1993. </year> <note> ISBN number 0-13-020249-5 (pbk). </note>
Reference-contexts: Splitting the environment into two components is a standard technique (often called a binding time improvement) used by the partial evaluation community <ref> [9] </ref>. <p> Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation <ref> [34, 17, 1, 3, 2, 9] </ref>; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13].
Reference: [10] <author> Paul Hudak Simon Peyton Jones, Philip Wadler, Brian Boutel, John Fairbairn, Joseph Fasel, Maria M. Guzman, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the programming language Haskell. </title> <journal> SIGPLAN Notices, 27(5):Section R, </journal> <year> 1992. </year>
Reference-contexts: In particular, there are two syntactic forms which are aware of the Monad datatype: Do and Return. Do and Return are MetaML's syntactic interface to the unit and bind of a monad. We have modeled them after the do-notation of Haskell <ref> [10, 24] </ref>. An important difference is that MetaML's Do and Return are both parameterized by an expression of type 'M Monad. Users may freely construct their own monads, though they should be very careful that their instantiation meets the monad axioms.
Reference: [11] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Further optimizations, such as arithmetic simplification, or transformations to another form, such as assembly code, could be implemented in the same fashion. 5 Related work Our work was inspired by work in many different areas. Derivation of compilers from specifications and the use of action-semantics <ref> [19, 23, 11, 22] </ref>; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern
Reference: [12] <author> Sheng Liang. </author> <title> Modular Monadi Semantics and Compilation. </title> <type> PhD thesis, </type> <institution> Yale university, </institution> <year> 1998. </year>
Reference-contexts: 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak <ref> [12, 13] </ref>. They investigate the derivation of a compiler from a modular monadic interpreter. Our work is a continuation of their effort of using monads as a standard compilation mechanism.
Reference: [13] <author> Sheng Liang and Paul Hudak. </author> <title> Modular denotational semantics for compiler construction. </title> <booktitle> In ESOP'96: 6th European Symposium on Programming, number 1058 in LNCS, </booktitle> <pages> pages 333-343, </pages> <address> Linkoping, Sweden, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak <ref> [12, 13] </ref>. They investigate the derivation of a compiler from a modular monadic interpreter. Our work is a continuation of their effort of using monads as a standard compilation mechanism.
Reference: [14] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <pages> pages 333-343, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: If expressed in a monadic style, an interpreter can be mapped closer to the underlying system, and the structuring properties of the monad even allow the interpreter to be reused as the system evolves <ref> [32, 14, 27] </ref>. Nevertheless, the effort used to build the interpreter is often considered wasteful since the programmer still needs to re-implement the compiler from scratch after building the interpreter. Our solution to this problem is the following multi-step method. <p> Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular <ref> [32, 27, 14] </ref>; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most
Reference: [15] <author> Erik Meijer. </author> <title> Calculating Compilers. </title> <type> PhD thesis, </type> <institution> Katholieke Universiteit Nijmegen, </institution> <year> 1992. </year>
Reference-contexts: To do this it is necessary to lift all non-standard morphisms through the transformer. This is hard and not completely understood. We may try to duplicate Liang's approach in future work. 14 5.2 Staging and compilation In his thesis Calculating Compilers <ref> [15] </ref> Erik Meijer advocates staging a compiler by using self discipline. Construct a compiler by building it as the composition of compile-time and run-time components. A critical step in this process is finding a representation of every source language construct as a combination of (lower level) target level constructs.
Reference: [16] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Extensions of Logic Programming: International Worksh op, Tubingen, </booktitle> <address> Germany, </address> <month> December </month> <year> 1989, </year> <booktitle> volume 475 of LNCS, </booktitle> <pages> pages 253-281. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: easily expressed as: &lt;fn x =&gt; ~(g &lt;x&gt;)> =&gt; &lt;fn y =&gt; ~(g &lt;y&gt;) + 1&gt; Because higher order meta-variables may appear only in the function position of escaped applications, and the arguments of these escaped applications may only be bracketed bound variables (like &lt;x&gt;), pattern-matching and unification are decidable <ref> [16, 25] </ref>. <p> 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching <ref> [16, 7] </ref> For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13]. They investigate the derivation of a compiler from a modular monadic interpreter.
Reference: [17] <author> Torben Mogenson. </author> <title> Self-applicable partial evaluation for the pure lambda calculus. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <pages> pages 116-121, </pages> <month> June </month> <year> 1992. </year> <institution> Yale University Department of Computer Science Technical Report YALEU/DCS/RR-909. </institution>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation <ref> [34, 17, 1, 3, 2, 9] </ref>; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13].
Reference: [18] <author> Eugenio Moggi. </author> <title> Notions of computations and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general <ref> [18, 31, 26] </ref> and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following
Reference: [19] <author> Peter D. Mosses. </author> <title> SIS-semantics implementation system, reference manual and users guide. </title> <type> Technical Report DAIMI report MD-30, </type> <institution> University of Aarhus, Aarhus, Den-mark, </institution> <year> 1979. </year>
Reference-contexts: Further optimizations, such as arithmetic simplification, or transformations to another form, such as assembly code, could be implemented in the same fashion. 5 Related work Our work was inspired by work in many different areas. Derivation of compilers from specifications and the use of action-semantics <ref> [19, 23, 11, 22] </ref>; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern
Reference: [20] <author> F. Nielson and H. R. Neilson. </author> <title> Two-Level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers <ref> [29, 20, 4] </ref>; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul
Reference: [21] <author> Martin Odersky and Konstantin Laufer. </author> <title> Putting type annotations to work. </title> <booktitle> In Proc. 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 54-67, </pages> <month> Jan-uary </month> <year> 1996. </year>
Reference-contexts: First, it declares that the argument ('M : * -&gt; * ) of the type constructor Monad is itself a unary type constructor [8]. We say that 'M has kind: * -&gt; *. Second, it declares that the arguments to the constructor Mon must be polymorphic functions <ref> [21] </ref>. The type variables in brackets, e.g. ['a,'b], are universally quantified. Because of the explicit type annotations in the datatype definitions the effect of these extensions on the Hindley-Milner type inference system is well known and poses no problems for the MetaML type inference engine.
Reference: [22] <author> Jens Palsberg. </author> <title> A proveably correct compiler generator. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> ESOP '92: 4th European Symposium on Programming, Rennes, France, </booktitle> <pages> pages 418-434, </pages> <address> New York, </address> <month> February </month> <year> 1992. </year> <title> Springer Verlag. </title> <booktitle> Lecture Notes in Computer Science 582. </booktitle>
Reference-contexts: Further optimizations, such as arithmetic simplification, or transformations to another form, such as assembly code, could be implemented in the same fashion. 5 Related work Our work was inspired by work in many different areas. Derivation of compilers from specifications and the use of action-semantics <ref> [19, 23, 11, 22] </ref>; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern
Reference: [23] <author> L. Paulson. </author> <title> Methods and Tools for Compiler Construction, </title> <editor> B. Lorho (editor). </editor> <publisher> Cam-bridge University Press, </publisher> <year> 1984. </year>
Reference-contexts: Further optimizations, such as arithmetic simplification, or transformations to another form, such as assembly code, could be implemented in the same fashion. 5 Related work Our work was inspired by work in many different areas. Derivation of compilers from specifications and the use of action-semantics <ref> [19, 23, 11, 22] </ref>; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern
Reference: [24] <author> John Peterson, Kevin Hammond, et al. </author> <title> Report on the programming language haskell, a non-strict purely-functional programming language, version 1.3. </title> <type> Technical report, </type> <institution> Yale University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: In particular, there are two syntactic forms which are aware of the Monad datatype: Do and Return. Do and Return are MetaML's syntactic interface to the unit and bind of a monad. We have modeled them after the do-notation of Haskell <ref> [10, 24] </ref>. An important difference is that MetaML's Do and Return are both parameterized by an expression of type 'M Monad. Users may freely construct their own monads, though they should be very careful that their instantiation meets the monad axioms.
Reference: [25] <author> Z. Qian. </author> <title> Linear unification of higher-order patterns. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of TAPSOFT'93, volume 668 of LNCS, </booktitle> <pages> pages 391-405. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: easily expressed as: &lt;fn x =&gt; ~(g &lt;x&gt;)> =&gt; &lt;fn y =&gt; ~(g &lt;y&gt;) + 1&gt; Because higher order meta-variables may appear only in the function position of escaped applications, and the arguments of these escaped applications may only be bracketed bound variables (like &lt;x&gt;), pattern-matching and unification are decidable <ref> [16, 25] </ref>.
Reference: [26] <author> Michael Spivey. </author> <title> A functional theory of exceptions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 25-42, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general <ref> [18, 31, 26] </ref> and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following
Reference: [27] <author> Guy Steele. </author> <title> Building interpreters by composing monads. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages (POPL'94), </booktitle> <address> Portland, Oregon, </address> <month> Jan-uary </month> <year> 1994. </year>
Reference-contexts: If expressed in a monadic style, an interpreter can be mapped closer to the underlying system, and the structuring properties of the monad even allow the interpreter to be reused as the system evolves <ref> [32, 14, 27] </ref>. Nevertheless, the effort used to build the interpreter is often considered wasteful since the programmer still needs to re-implement the compiler from scratch after building the interpreter. Our solution to this problem is the following multi-step method. <p> Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular <ref> [32, 27, 14] </ref>; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most
Reference: [28] <author> Walid Taha, Zine-El-Abidine Benaissa, and Tim Sheard. </author> <title> Multi-stage programming: Axiomatization and type safety. </title> <booktitle> In International colloquium on automata, languages, and programming, </booktitle> <publisher> LNCS. Springer-Verlag, </publisher> <month> July </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: The final step, where mswo and become %mswo and %-, occurs because both are free variables and are lexically captured. Now we can state the equivalence relationship between the monadic eval1 and the staged eval2. We use the axiomatic semantics of MetaML <ref> [28] </ref>, in particular the axioms for the annotations, such as the splice axiom above. Proposition 1. For all expressions exp, and list of names index: eval1 exp index = run (eval2 exp index) Proof. We might argue that there is a trivial proof to this proposition. <p> Since eval1 is simply a copy of eval2 with all the staging annotations erased, and that both functions type-check, by the semantics of MetaML they must be equal. We include a more traditional proof in the appendix using the axiomatic semantics of MetaML <ref> [28] </ref> (see appendix A). 9 Interpreter for Commands.
Reference: [29] <author> William L. Scherlis Urlik Jorring. </author> <title> Compilers and staging transformations. </title> <booktitle> In 13thACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 86-96. </pages> <publisher> ACM, ACM Press, </publisher> <month> January </month> <year> 1986. </year>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers <ref> [29, 20, 4] </ref>; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul
Reference: [30] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> Proceedings of the ACM Symposium on Lisp and Functional Programming, Nice, France, </booktitle> <pages> pages 61-78, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Running a piece of code, strips away the enclosing brackets, and evaluates the expression inside. 3 Monads in MetaML We assume the reader has a working knowledge of monads <ref> [30, 33] </ref>. We use the unit and bind formulation of monads [32].
Reference: [31] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2 </volume> <pages> 461-493, </pages> <year> 1992. </year> <booktitle> (Special issue of selected papers from 6'th Conference on Lisp and Functional Programming.). </booktitle>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general <ref> [18, 31, 26] </ref> and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following
Reference: [32] <author> Philip Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In 19'th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: If expressed in a monadic style, an interpreter can be mapped closer to the underlying system, and the structuring properties of the monad even allow the interpreter to be reused as the system evolves <ref> [32, 14, 27] </ref>. Nevertheless, the effort used to build the interpreter is often considered wasteful since the programmer still needs to re-implement the compiler from scratch after building the interpreter. Our solution to this problem is the following multi-step method. <p> Running a piece of code, strips away the enclosing brackets, and evaluates the expression inside. 3 Monads in MetaML We assume the reader has a working knowledge of monads [30, 33]. We use the unit and bind formulation of monads <ref> [32] </ref>. <p> Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular <ref> [32, 27, 14] </ref>; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation [34, 17, 1, 3, 2, 9]; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most
Reference: [33] <author> Philip Wadler. </author> <title> Monads for functional programming. </title> <editor> In J. Jeuring and E. Meijer, editors, </editor> <booktitle> Advanced Functional Programming, volume 925 of LNCS. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Running a piece of code, strips away the enclosing brackets, and evaluates the expression inside. 3 Monads in MetaML We assume the reader has a working knowledge of monads <ref> [30, 33] </ref>. We use the unit and bind formulation of monads [32].
Reference: [34] <author> Daniel Weise, Roland Conybeare, Erik Ruf, and Scott Seligman. </author> <title> Automatic online partial evaluation. </title> <booktitle> In Proceedings Functional Programming Languages and Computer Architecture, 5th ACM Conference, </booktitle> <pages> pages 165-191, </pages> <address> Cambridge, Ma, USA, </address> <month> August </month> <year> 1991. </year> <title> Springer Verlag. </title> <booktitle> Lecture Notes in Computer Science 523. </booktitle> <pages> 18 </pages>
Reference-contexts: Derivation of compilers from specifications and the use of action-semantics [19, 23, 11, 22]; the use of monads to structure programs in general [18, 31, 26] and language implementations in particular [32, 27, 14]; staged programming [5, 6] and its use in structuring compilers [29, 20, 4]; partial evaluation <ref> [34, 17, 1, 3, 2, 9] </ref>; higher order abstract syntax and pattern matching [16, 7] For space considerations we limit detailed discussion to the following areas. 5.1 Monads and compilation Perhaps, the most related work is the work of Sheng Liang and his thesis advisor Paul Hudak [12, 13].
References-found: 34

