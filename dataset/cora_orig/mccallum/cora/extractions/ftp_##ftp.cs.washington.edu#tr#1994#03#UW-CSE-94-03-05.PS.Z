URL: ftp://ftp.cs.washington.edu/tr/1994/03/UW-CSE-94-03-05.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Phone: (206) 685-2094; fax: (206) 543-2969  
Title: Measurement and Application of Dynamic Receiver Class Distributions  
Author: Charles D. Garrett, Jeffrey Dean, David Grove, and Craig Chambers 
Note: -garrett,jdean,grove,chambers-@cs.washington.edu  
Address: Seattle, Washington 98195 USA  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: Technical Report 94-03-05 May 1994 
Abstract-found: 1
Intro-found: 1
Reference: [Ball & Larus 92] <author> Thomas Ball and James R. Larus. </author> <title> Optimally Profiling and Tracing Programs. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1992. </year>
Reference-contexts: For the queens benchmark, the call-site specific prediction version actually ran slower than the global message prediction version. We believe this is an artifact of the direct-mapped instruction cache on the SparcStation IPX used for benchmarking. Profiling the two programs with QPT <ref> [Ball & Larus 92] </ref> revealed that the call-site specific prediction version of queens executed substantially fewer instructions than the global message prediction version.
Reference: [Calder & Grunwald 94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing Indirect Function Call Overhead In C++ Programs. </title> <booktitle> In ACM Principles and Practice of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January, </month> <year> 1994. </year>
Reference-contexts: Finally, our work studies receiver class distributions in several languages and analyzes the stability of profile data; the SELF work to date has reported only bottom-line performance improvements. Calder and Grunwald <ref> [Calder & Grunwald 94] </ref> consider several ways of optimizing dynamically bound calls in C++. They measured both the fraction of calls which had only one receiver class and the fraction which were sent to the most common receiver.
Reference: [Chambers et al. 89] <author> Craig Chambers, David Ungar and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Global message distributions are more exible because they can be applied to call sites that have not been profiled before. 2 Related Work Smalltalk-80 [Deutsch & Schiffman 84] and SELF <ref> [Chambers et al. 89] </ref> implementations have long incorporated techniques analogous to receiver class prediction; this optimization was called type prediction in the SELF work. These implementations in effect incorporated a hard-wired global message distribution table for certain commonly-occurring messages such as + and if. <p> The current Cecil compiler does not include customization or splitting <ref> [Chambers et al. 89] </ref>, two techniques included in the SELF compiler that would improve absolute performance. Because customization transforms polymorphic sends into monomorphic sends statically, the presence of customization would be likely to reduce somewhat the need for profile-based optimizations.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference-contexts: We also did not measure global function calls, member variable accesses, or built-in operators like +. Since we wished to study well-written C++ programs using a heavily object-oriented style, we chose two of the most polymorphic programs we could find, the new <ref> [Chambers & Ungar 91] </ref> and sic [Hlzle & Ungar 94] compilers for the SELF language distributed with SELF version 3. We profiled both compilers while they compiled a small set of SELF benchmarks and while they compiled one large SELF program.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: In this paper we investigate the feasibility of applying dynamic profile information to guide receiver class prediction. First, we study the kinds of distributions that occur in real object-oriented programs written in three distinct languages: C++ [Stroustrup 91], SELF [Ungar & Smith 87], and Cecil <ref> [Chambers 92, Chambers 93] </ref>; our results appear in section 3. This study reveals that most receiver class distributions are heavily skewed towards the most commonly occurring receiver class.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical report #93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March, </month> <year> 1993. </year>
Reference-contexts: In this paper we investigate the feasibility of applying dynamic profile information to guide receiver class prediction. First, we study the kinds of distributions that occur in real object-oriented programs written in three distinct languages: C++ [Stroustrup 91], SELF [Ungar & Smith 87], and Cecil <ref> [Chambers 92, Chambers 93] </ref>; our results appear in section 3. This study reveals that most receiver class distributions are heavily skewed towards the most commonly occurring receiver class.
Reference: [Chang et al. 91] <author> Pohua P. Chang, Scott A. Mahlke and Wen-Mei W. Hwu. </author> <title> Using Profile Information to Assist Classic Code Optimizations. </title> <booktitle> In Software-Practice and Experience 21(12), </booktitle> <pages> pp. 1301-1321, </pages> <month> December, </month> <year> 1991. </year>
Reference: [Chang et al. 92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen and Wen-Mei W. Hwu. </author> <title> Profile-guided Automatic Inline Expansion for C Programs. </title> <booktitle> In Software-Practice and Experience 22(5), </booktitle> <pages> pp. 349-369, </pages> <month> May, </month> <year> 1992. </year>
Reference: [Dean et al. 94] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Identifying Profitable Specialization in Object-Oriented Languages. </title> <booktitle> To appear in Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Orlando, FL, </address> <month> June, </month> <year> 1994. </year>
Reference-contexts: Profiles of object-oriented programs have other applications in compilers for object-oriented languages, such as helping to determine where optimizations such as inlining or customization are most profitable <ref> [Dean et al. 94] </ref>. Acknowledgments This research is supported in part by a National Science Foundation Research Initiation A ward (contract number CCR-9210990) and several gifts from Sun Microsystems, Inc.
Reference: [Deutsch & Schiffman 84] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January, </month> <year> 1984. </year>
Reference-contexts: Global message distributions are more exible because they can be applied to call sites that have not been profiled before. 2 Related Work Smalltalk-80 <ref> [Deutsch & Schiffman 84] </ref> and SELF [Chambers et al. 89] implementations have long incorporated techniques analogous to receiver class prediction; this optimization was called type prediction in the SELF work. These implementations in effect incorporated a hard-wired global message distribution table for certain commonly-occurring messages such as + and if.
Reference: [Deutsch 89] <author> L. Peter Deutsch. </author> <title> Design Reuse and Frameworks for the Smalltalk-80 System. </title> <booktitle> In Software Reusability, </booktitle> <volume> Vol. II, </volume> <editor> T.J. Biggerstaff and Alan. J. Perlis, eds., </editor> <publisher> ACM Press, </publisher> <pages> pp. 57-71, </pages> <year> 1989. </year>
Reference-contexts: This indicates that optimizations such as receiver class prediction that depend only on the most commonly-occurring classes may still be effective when using profiles from older versions of a program. 4.4 Stability Across Programs We expect that in the future shared libraries and frameworks <ref> [Wirfs-Brock & Johnson 90, Deutsch 89] </ref> more and more will form common building blocks from which applications are composed. We wish to learn whether a profile of a library included in one program is a good predictor of the behavior of that library when included in another program.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Even worse, dynamic binding prevents interprocedural optimizations such as inlining. If the frequency of dynamically-bound calls is high, as it is in pure object-oriented languages like Smalltalk <ref> [Goldberg & Robson 83] </ref>, or if a heavily object-oriented style is being used in a hybrid language such as C++ [Stroustrup 91], dynamic binding can be a significant bottleneck in the performance of the system.
Reference: [Graham et al. 82] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> gprof: a Call Graph Execution Profiler. </title> <booktitle> In Proceedings of the SIGPLAN 82 Symposium on Compiler Construction, </booktitle> <pages> pp. 120-126, </pages> <address> Boston, MA, </address> <month> June, </month> <year> 1982. </year> <note> Published as SIGPLAN Notices 17(6), </note> <month> June, </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Profiling is an important tool in the design and implementation of efficient and correct programs. For example, frequency data reveals hot spots where program optimization can have the greatest effect and basic block counts can expose incorrect behavior <ref> [Graham et al. 82] </ref>. Profiles of object-oriented languages can yield new information: the dynamic frequency of occurrence of each class of receiver at a particular call site. Such profile-based information complements static information derived by analyzing the program text.
Reference: [Hlzle et al. 91] <author> Urs Hlzle, Craig Chambers and David Ungar. </author> <title> Optimizing Dynamically-Typed Object Oriented Programming languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: One of the main goals of our work is to provide the benefits of run-time class testing for all code in a program. The current SELF implementation <ref> [Hlzle et al. 91, Hlzle & Ungar 94] </ref> is based on adaptive compilation, where the system recompiles and optimizes parts of a program while it is running. <p> We also profiled a document preparation program, doc, and a graphical editor, idraw, both written on top of the InterViews graphics library. To gather profiles in SELF, we used the polymorphic inline cache runtime system mechanism <ref> [Hlzle et al. 91] </ref> to record distinct receiver classes and invoked methods at dynamically-bound call sites. To make the data more comparable to the C++ data, we measured SELF programs under the new compiler with all optimizations enabled.
Reference: [Hlzle & Ungar 94] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> To appear in Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation, </booktitle> <address> Orlando, FL, </address> <month> June, </month> <year> 1994. </year>
Reference-contexts: One of the main goals of our work is to provide the benefits of run-time class testing for all code in a program. The current SELF implementation <ref> [Hlzle et al. 91, Hlzle & Ungar 94] </ref> is based on adaptive compilation, where the system recompiles and optimizes parts of a program while it is running. <p> We also did not measure global function calls, member variable accesses, or built-in operators like +. Since we wished to study well-written C++ programs using a heavily object-oriented style, we chose two of the most polymorphic programs we could find, the new [Chambers & Ungar 91] and sic <ref> [Hlzle & Ungar 94] </ref> compilers for the SELF language distributed with SELF version 3. We profiled both compilers while they compiled a small set of SELF benchmarks and while they compiled one large SELF program.
Reference: [Rose 88] <author> John R. Rose. </author> <title> Fast Dispatch Mechanisms for Stock Hardware. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <pages> pp. 27-35, </pages> <address> San Diego, CA, </address> <month> October, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year> <month> 28 </month>
Reference-contexts: Even worse, dynamic binding prevents interprocedural optimizations such as inlining. If the frequency of dynamically-bound calls is high, as it is in pure object-oriented languages like Smalltalk [Goldberg & Robson 83], or if a heavily object-oriented style is being used in a hybrid language such as C++ <ref> [Stroustrup 91] </ref>, dynamic binding can be a significant bottleneck in the performance of the system. <p> In this paper we investigate the feasibility of applying dynamic profile information to guide receiver class prediction. First, we study the kinds of distributions that occur in real object-oriented programs written in three distinct languages: C++ <ref> [Stroustrup 91] </ref>, SELF [Ungar & Smith 87], and Cecil [Chambers 92, Chambers 93]; our results appear in section 3. This study reveals that most receiver class distributions are heavily skewed towards the most commonly occurring receiver class.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: In this paper we investigate the feasibility of applying dynamic profile information to guide receiver class prediction. First, we study the kinds of distributions that occur in real object-oriented programs written in three distinct languages: C++ [Stroustrup 91], SELF <ref> [Ungar & Smith 87] </ref>, and Cecil [Chambers 92, Chambers 93]; our results appear in section 3. This study reveals that most receiver class distributions are heavily skewed towards the most commonly occurring receiver class.
Reference: [Wall 91] <author> David W. Wall. </author> <title> Predicting Program Behavior Using Real or Estimated Profiles. </title> <booktitle> In Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 59-70, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(6), </note> <month> June </month> <year> 1991. </year>
Reference-contexts: Our C++ results confirm this general result, but the C++ programs we measured are much larger and appear to be written in a more object-oriented style based on the polymorphism they exhibit. Wall <ref> [Wall 91] </ref> investigated how well profiles predict the execution frequency of call sites, basic blocks, references to global variable references, and other kinds of behavior. He reported that profiles from actual runs of a program are better predictors than static estimates of execution frequency.
Reference: [Wirfs-Brock & Johnson 90] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <booktitle> Surveying Current Research in Object-Oriented Design. In Communications of the ACM 3(9), </booktitle> <pages> pp. 104-124, </pages> <month> September, </month> <year> 1990. </year> <month> 29 </month>
Reference-contexts: This indicates that optimizations such as receiver class prediction that depend only on the most commonly-occurring classes may still be effective when using profiles from older versions of a program. 4.4 Stability Across Programs We expect that in the future shared libraries and frameworks <ref> [Wirfs-Brock & Johnson 90, Deutsch 89] </ref> more and more will form common building blocks from which applications are composed. We wish to learn whether a profile of a library included in one program is a good predictor of the behavior of that library when included in another program.
References-found: 20

