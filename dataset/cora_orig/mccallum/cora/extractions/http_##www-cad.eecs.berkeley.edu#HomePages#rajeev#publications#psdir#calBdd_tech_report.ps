URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/psdir/calBdd_tech_report.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/rajeev/publications/publications.html
Root-URL: http://www.cs.berkeley.edu
Title: High Performance BDD Package Based on Exploiting Memory Hierarchy  
Author: Rajeev K. Ranjan Jagesh V. Sanghavi Robert K. Brayton Alberto Sangiovanni-Vincentelli 
Note: Supported by Motorola Grant Supported by Micro Grant  
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engg. and Computer Science University of California at Berkeley  
Abstract: The success of binary decision diagram (BDD) based algorithms for synthesis and/or verification depend on the availability of a high performance package to manipulate very large BDDs. State-of-the-art BDD packages, based on the conventional depth-first technique, limit the size of the BDDs due to a disorderly memory access patterns that results in unacceptably high elapsed time when the BDD size exceeds the main memory capacity. We present a high performance BDD package that enables manipulation of very large BDDs by using an iterative breadth-first technique directed towards localizing the memory accesses to exploit the memory system hierarchy. The new memory-oriented performance features of this package are 1) an architecture independent customized memory management scheme, 2) the ability to issue multiple independent BDD operations (superscalarity), and 3) the ability to perform multiple BDD operations even when the operands of some BDD operations are the result of some other operations yet to be completed (pipelining). A comprehensive set of BDD manipulation algorithms are implemented using the above techniques. Unlike the breadth-first algorithms presented in the literature, the new package is faster than the state-of-the-art BDD package by a factor of upto 1.5, even for the BDD sizes that fit within the main memory. For BDD sizes that do not fit within the main memory, a performance improvement of more than a factor of 1000 can be achieved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. B. Akers. </author> <title> Binary Decision Diagrams. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-37:509-516, </volume> <month> June </month> <year> 1978. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) <ref> [1, 5] </ref> is the key to success for BDD-based algorithms for simulation [6], synthesis [8, 15], and verification [3, 7, 11] of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs.
Reference: [2] <author> P. Ashar and M. Cheong. </author> <title> Efficient Breadth-First Manipulation of Binary Decision Diagrams. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 622-627, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: This solution also localizes memory accesses to check for duplicate requests during the APPLY phase and redundant nodes during the REDUCE phase. However, it is observed that the QRBDD is several times larger than the corresponding BDD <ref> [2] </ref>, which makes this approach impractical for manipulating very large BDDs. Ashar et al. [2] use a BLOCK-INDEX table to determine the variable index from a BDD pointer by performing an associative lookup. <p> However, it is observed that the QRBDD is several times larger than the corresponding BDD <ref> [2] </ref>, which makes this approach impractical for manipulating very large BDDs. Ashar et al. [2] use a BLOCK-INDEX table to determine the variable index from a BDD pointer by performing an associative lookup. <p> The limitation of this approach is that it has a significant overhead (about a factor of 2.65) as compared to a depth-first based algorithm for manipulating BDDs which fit within the main memory <ref> [2] </ref>. Our approach to handling variable index determination problem differs from the works of Ashar et al. and Ochi et al. in the following aspects: 1. A new BDD node data structure is introduced to determine the variable index while preserving the locality of accesses. <p> To overload the use of the REQUEST data structure with the BDD node data structure <ref> [2] </ref>, the REQUEST data structure is limited to 16 bytes. Before the APPLY phase, each REQUEST represents operand BDDs, each of which requires 6 bytes. Therefore, we allow only two operand operations. <p> Functions and the variables selected are the same for both the packages. We use dfs-ordering in SIS to order the variables. The number of BDD nodes needed to represent a particular circuit may be significantly different from those reported in literature (e.g. <ref> [2] </ref>) due to a different variable ordering. However, this issue is orthogonal to demonstrating the performance of our package.
Reference: [3] <author> A. Aziz, F. Balarin, S.-T. Cheng, R. Hojati, T. Kam, S. C. Krishnan, R. K. Ranjan, T. R. Shiple, V. Singhal, S. Tasiran, H.-Y. Wang, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. HSIS: </author> <title> A BDD-Based Environment for Formal Verification. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 454-459, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) [1, 5] is the key to success for BDD-based algorithms for simulation [6], synthesis [8, 15], and verification <ref> [3, 7, 11] </ref> of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1.
Reference: [4] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year> <month> 22 </month>
Reference-contexts: Therefore, the depth-first algorithms place a severe limit on the size of the BDD that can be effectively manipulated on a given computer system. To a first approximation, the performance of BDD manipulation algorithms is dominated by the perfor 1 For BDD related terminology, please refer to <ref> [4] </ref>. 2 Level Registers Cache Main Memory Disk Storage Typical Size &lt; 1KB &lt; 512KB &lt; 512MB &gt; 1GB Access time (in ns) 10 20 100 20,000,000 Bandwidth (in MB/sec) 800 200 133 4 Managed by Compiler Hardware Operating System OS/User Backed by Cache Main memory Disk Tape Table 1: Typical
Reference: [5] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Trans. Comput., </journal> <volume> C--35:677-691, </volume> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) <ref> [1, 5] </ref> is the key to success for BDD-based algorithms for simulation [6], synthesis [8, 15], and verification [3, 7, 11] of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs.
Reference: [6] <author> R. Bryant. </author> <title> A methodology for hardware verification based on logic simulation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 38(2) </volume> <pages> 299-328, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) [1, 5] is the key to success for BDD-based algorithms for simulation <ref> [6] </ref>, synthesis [8, 15], and verification [3, 7, 11] of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1.
Reference: [7] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill. </author> <title> Sequential Circuit Verification Using Symbolic Model Checking. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) [1, 5] is the key to success for BDD-based algorithms for simulation [6], synthesis [8, 15], and verification <ref> [3, 7, 11] </ref> of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1.
Reference: [8] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of Sequential Machines Based on Symbolic Execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proc. of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) [1, 5] is the key to success for BDD-based algorithms for simulation [6], synthesis <ref> [8, 15] </ref>, and verification [3, 7, 11] of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1.
Reference: [9] <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Therefore, the recursive depth-first traversal leads to an extremely disorderly memory access pattern. In a typical computer system, the memory is organized hierarchically with smaller, faster, and more expensive (per byte) memory closer to the processor <ref> [9] </ref>. A simplified memory hierarchy consists of processor registers, several levels of on- and off-chip caches (SRAM), main memory (DRAM), and a hard disk. The important characteristics of each memory system component are given in Table 1.
Reference: [10] <author> D. E. </author> <title> Long. ROBDD Package. </title> <institution> Carnegie Mellon University, Pittsburgh, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Creating output BDDs of circuits: For the purposes of comparing the performance of our package with a depth-first BDD package we use Long's package <ref> [10] </ref>. We compare the time taken to create the BDDs for the outputs of circuits. The number of nodes in the BDDs range from a few thousands to tens of millions. 2. Demonstrating performance improvement due to superscalarity. 3. Demonstrating performance improvement due to pipelining. 4. <p> A complete package consisting of the whole suite of BDD operations based on these techniques has been built. We demonstrate the performance of our package by 1) comparing with state-of-the-art BDD package <ref> [10] </ref>, and 2) performing a comprehensive set of experiments to substantiate the capability of our approach. We show that our package provides competitive performance on small examples and a performance ratio of more than 1000 on large examples.
Reference: [11] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) [1, 5] is the key to success for BDD-based algorithms for simulation [6], synthesis [8, 15], and verification <ref> [3, 7, 11] </ref> of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1.
Reference: [12] <author> H. Ochi, N. Ishiura, and S. Yajima. </author> <title> Breadth-First Manipulation of SBDD of Boolean Functions for Vector Processing. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 413-416, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Experimental results demonstrating the effectiveness of our technique are presented in Section 6. Finally we conclude and outline the direction of future work in Section 7. 2 Breadth-First Technique for BDD Manipulation Originally proposed by Ochi et al. <ref> [12, 13] </ref>, the iterative breadth-first technique for BDD manipulation attempts to fix the disorderly memory access behavior of the recursive depth-first technique.
Reference: [13] <author> H. Ochi, K. Yasuoka, and S. Yajima. </author> <title> Breadth-First Manipulation of Very Large Binary-Decision Diagrams. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 48-55, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Experimental results demonstrating the effectiveness of our technique are presented in Section 6. Finally we conclude and outline the direction of future work in Section 7. 2 Breadth-First Technique for BDD Manipulation Originally proposed by Ochi et al. <ref> [12, 13] </ref>, the iterative breadth-first technique for BDD manipulation attempts to fix the disorderly memory access behavior of the recursive depth-first technique. <p> In order to preserve the locality of references, it is important to determine the variable index of a BDD node without actually fetching it from memory. In particular, the routine bf apply called with index i should access nodes only at index i. Ochi et al. <ref> [13] </ref> use Quasi-Reduced BDDs (QRBDDs) to solve this problem. Essentially, pad nodes are introduced along each path of the BDD so that consecutive nodes along a path differ in their indices by exactly one.
Reference: [14] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> SIS: A System for Sequential Circuit Synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Performance comparison for various BDD operations: We compare the performance of various BDD operations in our package with those in Long's package. We show that even for small and medium sized examples, our algorithms have competitive performance. 6.1 Experimental Setup We integrated our package with the synthesis tool SIS <ref> [14] </ref>. In addition to using standard ISCAS and MCNC benchmark examples for the set of experiments, we use a series of sub-networks of the MCNC benchmark C6288 in order to systematically analyze the performance of our algorithms as BDD size increases.
Reference: [15] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> Nov. </month> <year> 1990. </year> <month> 23 </month>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams 1 (BDDs) [1, 5] is the key to success for BDD-based algorithms for simulation [6], synthesis <ref> [8, 15] </ref>, and verification [3, 7, 11] of integrated circuits and systems. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1.
References-found: 15

