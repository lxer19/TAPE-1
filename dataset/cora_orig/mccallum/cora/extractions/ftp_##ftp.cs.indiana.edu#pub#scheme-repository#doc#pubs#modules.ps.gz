URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/modules.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Email: Pavel@Xerox.Com  Rauen@LCS.MIT.Edu  
Title: A Module System for Scheme  
Author: Pavel Curtis James Rauen 
Address: 3333 Coyote Hill Rd. Palo Alto, CA 94304  545 Technology Square Cambridge, MA 02139  
Affiliation: Xerox Palo Alto Research Center  Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: This paper presents a module system designed for large-scale programming in Scheme. The module system separates specifications of objects from their implementations, permitting the separate development, compilation, and testing of modules. The module system also includes a robust macro facility. We discuss our design goals, the design of the module system, implementation issues, and our future plans. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alan Bawden and Jonathan Rees. </author> <title> Syntactic closures. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, ACM, </booktitle> <month> July </month> <year> 1988. </year>
Reference-contexts: This environment-specific interpretation is described below. 6.2 Syntactic environments Syntax transformation procedures introduce, examine, and in other ways manipulate identifiers in the code on which they operate. Under certain circumstances (described by Bawden and Rees <ref> [1] </ref>), this can lead to inadvertent name conflicts. Several techniques for "hygenic" syntax transformation have been proposed [1, 6], including one in the forthcoming Revised 4 Report [11]. We currently use a version of the syntactic closure mechanism [1] in order to control the scopes of identifiers manipulated by syntax transformations. <p> Under certain circumstances (described by Bawden and Rees [1]), this can lead to inadvertent name conflicts. Several techniques for "hygenic" syntax transformation have been proposed <ref> [1, 6] </ref>, including one in the forthcoming Revised 4 Report [11]. We currently use a version of the syntactic closure mechanism [1] in order to control the scopes of identifiers manipulated by syntax transformations. A syntactic environment is a static mapping from identifiers to their meanings. <p> Under certain circumstances (described by Bawden and Rees <ref> [1] </ref>), this can lead to inadvertent name conflicts. Several techniques for "hygenic" syntax transformation have been proposed [1, 6], including one in the forthcoming Revised 4 Report [11]. We currently use a version of the syntactic closure mechanism [1] in order to control the scopes of identifiers manipulated by syntax transformations. A syntactic environment is a static mapping from identifiers to their meanings. An identifier may be mapped to any one of the following: * An interface. * A variable.
Reference: [2] <author> Luca Cardelli et al. </author> <type> Modula-3 Report (revised). Technical Report 52, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: However, this checking is tightly coupled with the type systems for these languages, so this approach is not easily adapted for use in a latently-typed language like Scheme. Several languages in the Algol family, such as Ada [15], CLU [7], Mesa [4], and Modula-3 <ref> [2] </ref> were designed to support large-scale programming. They feature a static module structure with explicit, checked interfaces. Most do not provide more than one level of module scoping, with Ada and Mesa being notable exceptions.
Reference: [3] <author> Matthias Felleisen and Daniel P. Friedman. </author> <title> A closer look at export and import statements. </title> <journal> Computer Languages, </journal> <volume> 11(1) </volume> <pages> 29-37, </pages> <year> 1986. </year>
Reference-contexts: In Common Lisp [14], a parse-time mechanism partitions identifiers into runtime structures called "packages". Imperative procedure calls control the sharing of names among the packages; it is difficult or impossible to perform static checks. Further, no names are truly hidden, so abstractions cannot be enforced. Felleisen and Friedman <ref> [3] </ref> describe a simple module system, but it lacks explicit interfaces and support for syntactic extensions. Rees [9] presents a solution to the modularity problems for syntactic extensions. We have adopted much of this approach to syntax, but the module system Rees describes also lacks explicit interfaces.
Reference: [4] <author> Charles M. Geschke, James H. Morris, Jr., and Ed-win H. Satterthwaite. </author> <title> Early experience with Mesa. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 138-152, </pages> <month> March </month> <year> 1977. </year>
Reference-contexts: However, this checking is tightly coupled with the type systems for these languages, so this approach is not easily adapted for use in a latently-typed language like Scheme. Several languages in the Algol family, such as Ada [15], CLU [7], Mesa <ref> [4] </ref>, and Modula-3 [2] were designed to support large-scale programming. They feature a static module structure with explicit, checked interfaces. Most do not provide more than one level of module scoping, with Ada and Mesa being notable exceptions. <p> Mesa was the primary inspiration for our own design. 3 Design goals When we began work on the module system, we had several goals in mind, some of which were inspired by our experience with the Mesa module system <ref> [4] </ref>. Separation: The module system should allow a strong separation between independent pieces of code. All dependencies between modules should be explicitly declared in the program text, making reference to textually disjoint specifications of the interfaces between subsystems.
Reference: [5] <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> The Definition of Standard ML, </title> <type> Version 3. Technical Report ECS-LFCS-89-81, </type> <institution> University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: Rees [9] presents a solution to the modularity problems for syntactic extensions. We have adopted much of this approach to syntax, but the module system Rees describes also lacks explicit interfaces. The module systems for other functional languages like ML <ref> [5] </ref> and FX [13] are more highly structured, including explicit interface-like "signatures" and static checking. However, this checking is tightly coupled with the type systems for these languages, so this approach is not easily adapted for use in a latently-typed language like Scheme.
Reference: [6] <author> Eugene E. Kohlbecker, Jr. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> Technical Report 199, </type> <institution> Indiana University Computer Science Department, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: Under certain circumstances (described by Bawden and Rees [1]), this can lead to inadvertent name conflicts. Several techniques for "hygenic" syntax transformation have been proposed <ref> [1, 6] </ref>, including one in the forthcoming Revised 4 Report [11]. We currently use a version of the syntactic closure mechanism [1] in order to control the scopes of identifiers manipulated by syntax transformations. A syntactic environment is a static mapping from identifiers to their meanings.
Reference: [7] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: However, this checking is tightly coupled with the type systems for these languages, so this approach is not easily adapted for use in a latently-typed language like Scheme. Several languages in the Algol family, such as Ada [15], CLU <ref> [7] </ref>, Mesa [4], and Modula-3 [2] were designed to support large-scale programming. They feature a static module structure with explicit, checked interfaces. Most do not provide more than one level of module scoping, with Ada and Mesa being notable exceptions.
Reference: [8] <institution> Massachusetts Institute of Technology. MIT Scheme Reference. </institution> <note> Scheme Release 7 edition, June 1989. (Draft). </note>
Reference-contexts: Finally, we discuss issues that arise in any implementation of the system. 2 Previous work Many languages contain facilities intended to support large-scale programming. The usual approach taken in Scheme implementations, such as T [12] and MIT Scheme <ref> [8] </ref>, uses first-class environments. Although this approach is elegant, there is little hope for statically checking references between subsystems. In addition, the lack of explicit interfaces hampers the independent development of interacting subsystems. In Common Lisp [14], a parse-time mechanism partitions identifiers into runtime structures called "packages".
Reference: [9] <author> Jonathan Rees. </author> <title> Modular Macros. </title> <type> Master's thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Further, no names are truly hidden, so abstractions cannot be enforced. Felleisen and Friedman [3] describe a simple module system, but it lacks explicit interfaces and support for syntactic extensions. Rees <ref> [9] </ref> presents a solution to the modularity problems for syntactic extensions. We have adopted much of this approach to syntax, but the module system Rees describes also lacks explicit interfaces.
Reference: [10] <editor> Jonathan Rees, William Clinger, et al. </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(12), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Module system programs are an upward-compatible extension of Scheme programs as defined by the Revised 3 Report <ref> [10] </ref>. Expressions include the usual kinds of Scheme expressions. Top-level expressions are usually evaluated for their side-effects, not for the values they compute. Definitions introduce items (variable bindings and syntax descriptions) that can be used throughout the program where they are defined.
Reference: [11] <editor> Jonathan Rees, William Clinger, et al. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <type> (Draft). </type>
Reference-contexts: Under certain circumstances (described by Bawden and Rees [1]), this can lead to inadvertent name conflicts. Several techniques for "hygenic" syntax transformation have been proposed [1, 6], including one in the forthcoming Revised 4 Report <ref> [11] </ref>. We currently use a version of the syntactic closure mechanism [1] in order to control the scopes of identifiers manipulated by syntax transformations. A syntactic environment is a static mapping from identifiers to their meanings.
Reference: [12] <author> Jonathan A. Rees, Norman I. Adams, and James R. Meehan. </author> <title> The T Manual. </title> <institution> Yale University, </institution> <note> fourth edition, </note> <month> January </month> <year> 1984. </year>
Reference-contexts: This is followed by an informal description of the module system itself. Finally, we discuss issues that arise in any implementation of the system. 2 Previous work Many languages contain facilities intended to support large-scale programming. The usual approach taken in Scheme implementations, such as T <ref> [12] </ref> and MIT Scheme [8], uses first-class environments. Although this approach is elegant, there is little hope for statically checking references between subsystems. In addition, the lack of explicit interfaces hampers the independent development of interacting subsystems.
Reference: [13] <author> Mark A. Sheldon. </author> <title> Static Dependent Types for First-Class Modules. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Rees [9] presents a solution to the modularity problems for syntactic extensions. We have adopted much of this approach to syntax, but the module system Rees describes also lacks explicit interfaces. The module systems for other functional languages like ML [5] and FX <ref> [13] </ref> are more highly structured, including explicit interface-like "signatures" and static checking. However, this checking is tightly coupled with the type systems for these languages, so this approach is not easily adapted for use in a latently-typed language like Scheme.
Reference: [14] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language. </title> <publisher> Digital Equipment Corporation (Digital Press), </publisher> <year> 1984. </year>
Reference-contexts: Although this approach is elegant, there is little hope for statically checking references between subsystems. In addition, the lack of explicit interfaces hampers the independent development of interacting subsystems. In Common Lisp <ref> [14] </ref>, a parse-time mechanism partitions identifiers into runtime structures called "packages". Imperative procedure calls control the sharing of names among the packages; it is difficult or impossible to perform static checks. Further, no names are truly hidden, so abstractions cannot be enforced.
Reference: [15] <institution> United States Department of Defense. </institution> <note> Ada Reference Manual. </note> <month> July </month> <year> 1980. </year>
Reference-contexts: However, this checking is tightly coupled with the type systems for these languages, so this approach is not easily adapted for use in a latently-typed language like Scheme. Several languages in the Algol family, such as Ada <ref> [15] </ref>, CLU [7], Mesa [4], and Modula-3 [2] were designed to support large-scale programming. They feature a static module structure with explicit, checked interfaces. Most do not provide more than one level of module scoping, with Ada and Mesa being notable exceptions.
Reference: [16] <author> Mark Weiser, Alan Demers, and Carl Hauser. </author> <title> The Portable Common Runtime approach to interoperability. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 114-122, </pages> <month> Decem-ber </month> <year> 1989. </year>
Reference-contexts: The compiler produces machine-independent C code and the runtime system is built on top of the Portable Common Runtime system <ref> [16] </ref>. We are building (and will make freely available) a portable version of the module system as an add-on to any Scheme implementation.
References-found: 16

