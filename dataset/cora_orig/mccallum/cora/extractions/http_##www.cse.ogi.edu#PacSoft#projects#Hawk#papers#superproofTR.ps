URL: http://www.cse.ogi.edu/PacSoft/projects/Hawk/papers/superproofTR.ps
Refering-URL: http://www.cse.ogi.edu/~krstic/
Root-URL: http://www.cse.ogi.edu
Email: fkrstic,byron,jl,johnmg@cse.ogi.edu  
Title: A correctness proof of a speculative, superscalar, out-of-order, renaming microarchitecture extended  
Author: Sava Krstic, Byron Cook, John Launchbury, and John Matthews 
Affiliation: Oregon Graduate Institute  
Pubnum: technical report  
Abstract: In this paper we provide high-level mathematical specifications for a basic machine and for a speculative, superscalar, out-of-order, renaming machine based on the Intel P6 microarchitecture. We then prove that the visible outputs of the two machines are equivalent.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aagaard, M., and Leeser, M. </author> <title> Reasoning about pipelines with structural hazards. </title> <booktitle> In Second International Conference on Theorem Provers in Circuit Design (Bad Herrenalb, </booktitle> <address> Germany, </address> <month> Sept. </month> <year> 1994). </year> <month> 21 </month>
Reference-contexts: To formalize those entities, we use the concept of transactions <ref> [1, 7] </ref>. A transaction is a package of information which (directly or indirectly) contains the identity of the unique instruction it is associated with plus various data contained in the current machine state that are relevant for the execution of that instruction. <p> components of the dynamic machine have the following types (defined formally in 3.2.2): ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 <ref> [1] </ref> 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . <p> (defined formally in 3.2.2): ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 <ref> [1] </ref> 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 <ref> [1] </ref> 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> The two statements of the lemma immediately follow. tu 4.4 Axioms of the standard machine Proof of SM-1. We want to prove pc ( 1 <ref> [1] </ref>) = startIdx. Let n be the smallest integer such that fetched n 6= ;. By IFU-1, pc (t) = startIdx, where t is the first transaction in fetched n .
Reference: [2] <author> Birch, J., and Dill, D. </author> <title> Automatic verification of pipelined microprocessor control. </title> <booktitle> In 6th International Conference of Computer Aided Verification (Stan-ford, </booktitle> <address> California, </address> <month> June </month> <year> 1994). </year>
Reference-contexts: the dynamic machine have the following types (defined formally in 3.2.2): ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 <ref> [2] </ref> 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . <p> in 3.2.2): ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 <ref> [2] </ref> 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 <ref> [2] </ref> 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> Since res (S n hpi) is in Value, it must be equal to res (S m hpi), and again the desired result follows. tu 5 Related work Burch and Dill's seminal paper <ref> [2] </ref> developed the concept of a pipeline flushing abstraction function to prove an equivalence between an ISA and a pipelined implementation. Any instructions in flight are made to complete by an appropriate insertion of null operations.
Reference: [3] <author> Burch, J. </author> <title> Techniques for verifying superscalar microprocessors. </title> <booktitle> In 33rd annual Design Automation Conference (Las Vegas, </booktitle> <address> Nevada, </address> <month> June </month> <year> 1996). </year>
Reference-contexts: machine have the following types (defined formally in 3.2.2): ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 <ref> [3] </ref> 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . <p> ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 <ref> [3] </ref> 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 <ref> [3] </ref> 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch <ref> [3] </ref>, Windley and Burch [12], and Skakkebk, Jones and Dill [11] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed 19 a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core.
Reference: [4] <author> Cook, B., Launchbury, J., and Matthews, J. </author> <title> Specifying superscalar microprocessors with Hawk. </title> <booktitle> In Workshop on Formal Techniques for Hardware (Maarstrand, </booktitle> <address> Sweden, </address> <month> June </month> <year> 1998). </year>
Reference-contexts: Industry is working hard to find formal verification methods that scale to the problem sizes they face. Our paper attempts to address some aspects of this issue Our research is based on a fairly detailed model of a P6-like microarchitecture <ref> [4, 6] </ref> expressed using Hawk [7]. To prove its correctness, we have constructed a more abstract specification in which each major component is axiomatically specified. <p> the following types (defined formally in 3.2.2): ifu: TransSig; BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 <ref> [4] </ref> 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . <p> BoolSig ! TransSeqSig rob: TransSeqSig; TransSetSig ! TransSeqSig; TransSetSig; TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 <ref> [4] </ref> 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> TransSig; BoolSig rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 <ref> [4] </ref> 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob.
Reference: [5] <author> Damm, W., and Pnueli, A. </author> <title> Verifying out-of-order executions. In Conference on Correct Hardware Design and Verification Methods (Montreal, </title> <address> Canada, </address> <year> 1997). </year>
Reference-contexts: rs: TransSetSig; BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 <ref> [5] </ref> 5 [6] 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. <p> Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch [3], Windley and Burch [12], and Skakkebk, Jones and Dill [11] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli <ref> [5] </ref> constructed 19 a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan [8] verifies the same processor using compositional model-checking techniques. The machine transitions are defined by next-state operations on the full states of the ISA and the Tomasulo machines.
Reference: [6] <author> Gwennap, L. </author> <title> Intel's P6 uses decoupled superscalar design. </title> <type> Microprocessor Report 9, </type> <month> 2 </month> <year> (1995). </year>
Reference-contexts: Industry is working hard to find formal verification methods that scale to the problem sizes they face. Our paper attempts to address some aspects of this issue Our research is based on a fairly detailed model of a P6-like microarchitecture <ref> [4, 6] </ref> expressed using Hawk [7]. To prove its correctness, we have constructed a more abstract specification in which each major component is axiomatically specified. <p> BoolSig ! TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 <ref> [6] </ref> 5 [7] 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob.
Reference: [7] <author> Matthews, J., Launchbury, J., and Cook, B. </author> <title> Specifying microprocessors in Hawk. </title> <booktitle> In IEEE International Conference on Computer Languages (Aug. </booktitle> <year> 1998). </year>
Reference-contexts: Industry is working hard to find formal verification methods that scale to the problem sizes they face. Our paper attempts to address some aspects of this issue Our research is based on a fairly detailed model of a P6-like microarchitecture [4, 6] expressed using Hawk <ref> [7] </ref>. To prove its correctness, we have constructed a more abstract specification in which each major component is axiomatically specified. <p> To formalize those entities, we use the concept of transactions <ref> [1, 7] </ref>. A transaction is a package of information which (directly or indirectly) contains the identity of the unique instruction it is associated with plus various data contained in the current machine state that are relevant for the execution of that instruction. <p> TransSetSig 5 I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 <ref> [7] </ref> 5 [8] . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob.
Reference: [8] <author> McMillan, K. </author> <title> Verification of an implementation of tomasulo's algorithm by compositional model checking. </title> <booktitle> In International Conference on Computer-Aided Verification (Vancouver, </booktitle> <address> Canada, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: I 1 I 2 I 3 I 4 I 5 I 6 I 7 I 8 1 1 [1] 1 [2] 1 [3] 1 [4] 3 3 [1] 3 [2] 3 [3] 3 [4] 5 5 [1] 5 [2] 5 [3] 5 [4] 5 [5] 5 [6] 5 [7] 5 <ref> [8] </ref> . . . . . . . . . . . . . . . The following sections contain axiomatic specifications for ifu, rs and rob. Later in the paper we prove that any dynamic machine satisfying these specifications reproduces the result sequence standard of the standard machine. <p> Since then, Burch [3], Windley and Burch [12], and Skakkebk, Jones and Dill [11] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed 19 a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan <ref> [8] </ref> verifies the same processor using compositional model-checking techniques. The machine transitions are defined by next-state operations on the full states of the ISA and the Tomasulo machines. This results in a large conjunctive formula, each conjunct of which is checked independently.
Reference: [9] <author> Sawada, J., and Hunt, W. </author> <title> Processor verification with precise exceptions and speculative execution. </title> <booktitle> In International Conference on Computer-Aided Verification (Vancouver, </booktitle> <address> Canada, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: As their models rely on being able to apply rewrite rules in any order, it is not clear how their correctness result would translate to a lower-level implementation that did not have this flexibility. In a very recent paper, Sawada and Hunt <ref> [9] </ref> describe a microprocessor verification that has many similarities to our work. They also construct a sequence of transaction-like records, called a Micro-Architecture Execution Trace Table (MAETT). Like our state, the MAETT is permanently enlarged with every completed instruction.
Reference: [10] <author> Shen, X., and Arvind. </author> <title> Design and verification of speculative processors. </title> <booktitle> In Workshop on Formal Techniques for Hardware (Maarstrand, </booktitle> <address> Sweden, </address> <month> June </month> <year> 1998). </year>
Reference-contexts: This encapsulation may provide an additional level of abstraction and modularity to the verification effort, and allow separate teams to develop each component, while ensuring that global processor invariants are maintained. Shen and Arvind <ref> [10] </ref> describe a term-rewriting methodology for verifying superscalar, speculative, out-of-order multiprocessors. Their approach can be considered to be at an even higher level of abstraction than our Hawk designs which provided the basis for our axiomatization. As a result, their specifications are simpler than ours.
Reference: [11] <author> Skakkebaek, J., Jones, R., and Dill, D. </author> <title> Formal verification of out-of-order execution using incremental flushing. </title> <booktitle> In International Conference on Computer-Aided Verification (Vancouver, </booktitle> <address> Canada, </address> <month> July </month> <year> 1998). </year>
Reference-contexts: Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch [3], Windley and Burch [12], and Skakkebk, Jones and Dill <ref> [11] </ref> have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed 19 a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan [8] verifies the same processor using compositional model-checking techniques.
Reference: [12] <author> Windley, P., and Burch, J. </author> <title> Mechanically checking a lemma used in an automatic verification tool. </title> <booktitle> In Formal Methods in Computer-Aided Design (Palo Alto, </booktitle> <address> California, </address> <year> 1996). </year> <month> 22 </month>
Reference-contexts: Any instructions in flight are made to complete by an appropriate insertion of null operations. Since then, Burch [3], Windley and Burch <ref> [12] </ref>, and Skakkebk, Jones and Dill [11] have extended the approach to superscalar pipelined microprocessors. Using a non-deterministic intermediate machine, Damm and Pnueli [5] constructed 19 a refinement relation between a sequential and Tomasulo-style implementation of an out-of-order processor core. McMillan [8] verifies the same processor using compositional model-checking techniques.
References-found: 12

