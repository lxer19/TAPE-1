URL: http://www.cis.ohio-state.edu/volviz/Papers/1993/Vis93.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/volviz/papers_subject.html
Root-URL: 
Title: viewing process consists of, for each screen pixel, the depth and the value (color) of
Author: Roni Yagel and Zhouhong Shi 
Affiliation: The Ohio State University Department of Computer and Information Science  
Date: 62-69.  
Note: Proc. Visualization93, San Jose, CA, October 1993, pp.  1: Introduction Commonly, the outcome of the  from that pixel. However, it is possible to apply different  presented in this paper does not assume a specific  
Abstract: In this paper we present a method for speeding the process of volume animation. It exploits coherency between consecutive images to shorten the path rays take through the volume. Rays are provided with the information needed to leap over the empty space and commence volume traversal at the vicinity of meaningful data. The algorithm starts by projecting the volume onto a C-buffer (Coordinates-buffer) which stores the object-space coordinates of the first non-empty voxel visible from a pixel. Following a change in the viewing parameters, the C-buffer is transformed accordingly. Next, coordinates that possibly became hidden are discarded. The remaining values serve as an estimate of the point where the new rays should start their volume traversal. This method does not require 3D preprocessing and does not suffer from any image degradation. It can be combined with existing acceleration techniques and can support any ray traversal algorithm and material modeling scheme. Visualization is the process of converting complex information to a format that is amenable to human understanding while maintaining the integrity and accuracy of the information. One type of information that can benefit from visualization techniques is volumetric data which consists of information on three-dimensional phenomena. The process of determining, for a given view point, which parts of the volume are visible is called volume viewing. Algorithms for volume viewing operate by scanning through the data points (voxels) in a strict sequence designed to achieve hidden voxel removal. The simplest way to achieve hidden voxel removal is to traverse the volume regarding each voxel as a 3D point, that is, each voxel is transformed by the viewing transformation matrix and then projected onto the screen. Besides its computational burden, another severe limitation of the above method (also called forward projection) is that it is hard to accelerate because any forward viewing algorithm must process all voxels in the dataset. We take the alternate approach, termed backward viewing, and show that we can avoid processing a large portion of the data without affecting image quality. The ray casting algorithm (which is considered a backward projection), casts a ray from each pixel on the screen into the volume along the view vector. While following a ray, the voxels it pierces are sampled and the resulting colors and opacities are accumulated to yield the rays final color [7]. The simplest volume sampling method performs zero-order interpolation to locate the nearest voxel and uses a 3D integer-based line algorithm to generate the ray. A more precise algorithm is based on a continuous line algorithm that can take several samples per voxel. It also uses higher order interpolation to compute the sample value. If the ray is traced as it reects from surfaces (in order to simulate reections, refractions and shadows) we call it ray tracing [14]. In this paper, however, we deal only with ray-casting. Several methods, originating from surface-based ray tracing algorithms, have been suggested to reduce the computation involved in volumetric ray casting. Methods have been described that reduce the cost of tracing each ray by employing adaptive termination [5, 7] or by adaptively reducing the sampling rate along the ray [5, 10]. Alternatively, acceleration can be achieved by reducing the number of rays [8], or by exploiting coherency between rays in orthographic viewing [15]. Another set of acceleration techniques provide the ray traversal algorithm with the means to efficiently traverse or even skip the empty space surrounding the volumetric objects. We call this capability space-leaping. The method described in this paper (Section 4) provides space-leaping capabilities when rendering a sequence of images. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Avila, R., Sobierajski, L. M. and Kaufman, A. E., </author> <title> Towards a Comprehensive Volume Visualization System, </title> <booktitle> Proceed ings Visualization 92, </booktitle> <address> Boston, MA, </address> <month> October </month> <year> 1992, </year> <pages> 13-20. </pages>
Reference-contexts: When a volume consists of one or few objects surrounded by empty space, a common and simple method to provide space-leaping uses bounding-boxes. The PARC (Polygon Assisted Ray Casting) method <ref> [1] </ref> strives to have a better fit by allowing a convex polyhedral envelope to be constructed around the object. These methods however are not suitable for a scene occupied by many small objects and 2.
Reference: [2] <author> Chapman, J., Calvert, T. W. and Dill, J., </author> <title> Exploiting Temporal Coherence in Ray Tracing, </title> <booktitle> Proceedings of Graphics In terface90, </booktitle> <year> 1990, </year> <pages> 196-204. </pages>
Reference-contexts: The coordinates value stored in each pixel indicates the volume coordinates where ray traversal could start, as opposed to starting at the volume boundary - thereby avoiding the repeated traversal of the empty space. The idea of exploiting frame coherency was explored in the case of surface-rendering. In <ref> [2] </ref> a search-based method was proposed that extends the idea of adaptive sampling to the temporal axis. Images are not generated in order and suffer from some level of image degradation. More recently a method was suggested that exploits coherency in ray-object intersections between frames [3].
Reference: [3] <author> Chapman, J., Calvert, T. W. and Dill, J., </author> <title> Spatio-Temporal Coherence in Ray Tracing, </title> <booktitle> Proceedings of Graphics Inter face91, </booktitle> <year> 1991, </year> <pages> 101-108. </pages>
Reference-contexts: In [2] a search-based method was proposed that extends the idea of adaptive sampling to the temporal axis. Images are not generated in order and suffer from some level of image degradation. More recently a method was suggested that exploits coherency in ray-object intersections between frames <ref> [3] </ref>. This method is limited and does not extend to volume rendering. In this paper we present a volume rendering algorithm that exploits Screen Volume (a) (f) (d) volume is represented by a 2D grid while the 2D screen is depicted by a 1D line.
Reference: [4] <author> Cohen, D. and Shefer, Z., </author> <title> Proximity Clouds - An Acceleration Technique for 3D Grid Traversal, </title> <type> Technical Report FC 93-01, </type> <institution> Department of Mathematics and Computer Science, Ben Gurion University of the Negev, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: This approach decomposes the volume into uniform regions that can be represented by nodes in a hierarchical data structure. An adjusted ray traversal algorithm skips the (uniform) empty space by maneuvering through the hierarchical data structure [8, 9]. It was also observed <ref> [4] </ref> that instead of traversing the hierarchical data structure (which is less efficient, compared to regular volume traversal), the uniformity information implied by the octree can be stored in the empty space of the regular 3D volume grid, as shown in Figure 3. <p> Encountering an empty voxel later (un-occupied and not carrying the vicinity ag) can signal a switch back to the rapid traversal algorithm which is employed in the empty space. The proximity-clouds method <ref> [4, 16] </ref> is based on the extension of this idea even further. <p> Figure 5 shows the sample points (small squares) for some rays. The effectiveness of this algorithm is obviously dependent on the ability of the line traversal algorithm to efficiently jump arbitrary number of steps <ref> [4] </ref>. We have shown elsewhere how to efficiently accommodate this feature in the template-based ray casting algorithm [13]. All existing space-leaping methods require 3D preprocessing that needs to be repeated for any change in the volume data.
Reference: [5] <author> Danskin, J. and Hanrahan, P., </author> <title> Fast Algorithms for Volume Ray Tracing, </title> <booktitle> Proceedings of 1992 Workshop on Volume Vi sualization, </booktitle> <address> Boston, MA, </address> <month> October </month> <year> 1992, </year> <pages> 91-105. </pages>
Reference-contexts: In this paper, however, we deal only with ray-casting. Several methods, originating from surface-based ray tracing algorithms, have been suggested to reduce the computation involved in volumetric ray casting. Methods have been described that reduce the cost of tracing each ray by employing adaptive termination <ref> [5, 7] </ref> or by adaptively reducing the sampling rate along the ray [5, 10]. Alternatively, acceleration can be achieved by reducing the number of rays [8], or by exploiting coherency between rays in orthographic viewing [15]. <p> Several methods, originating from surface-based ray tracing algorithms, have been suggested to reduce the computation involved in volumetric ray casting. Methods have been described that reduce the cost of tracing each ray by employing adaptive termination [5, 7] or by adaptively reducing the sampling rate along the ray <ref> [5, 10] </ref>. Alternatively, acceleration can be achieved by reducing the number of rays [8], or by exploiting coherency between rays in orthographic viewing [15]. Another set of acceleration techniques provide the ray traversal algorithm with the means to efficiently traverse or even skip the empty space surrounding the volumetric objects. <p> Sensing the proximity of data voxels can be achieved by having a volume buffer called max 27 which is maintained in addition to the data volume. This buffer contains, in each voxel, the maximum value in the immediate neighborhood of the corresponding voxel in the data volume <ref> [5] </ref>. Rays are traced in the max 27 volume. When a value is encountered that is not transparent the ray algorithm switches into a more accurate algorithm and continues its traversal in the data volume. An alternate solution, called the vicinity-vox-els approach, does not require any additional space.
Reference: [6] <author> Gudmundsson, B. and Randen, M., </author> <title> Incremental Generation of Projections of CT-Volumes, </title> <booktitle> Proceedings of the First Con ference on Visualization in Biomedical Computing, </booktitle> <address> Atlanta, GA, </address> <month> May </month> <year> 1990, </year> <pages> 27-34. </pages>
Reference-contexts: This will when employing space-leaping. drive it to commence following the ray near object B - altogether skipping over object A. Our solution to this problem (see Figure 7) is to employ the following principle, suggested by Gudmundsson and Randen <ref> [6] </ref>: Let us assume that a voxels coordinates [x,y,z] are stored in C-buffer [i,j] and the coordinates of the voxel at [x,y,z] are stored in C-buffer [i,k] such that k &gt; j, as depicted in Figure 7 (a). <p> Therefore, for any background pixel an expensive and fruitless ray traversal must be launched. One solution is to employ bounding boxes or PARC (see Section 3) in conjunction with space-leaping - an approach that requires preprocessing. Alternatively, one could shoot rays only near the silhouettes of the projected objects <ref> [6] </ref> - a method with limited accuracy. Our solution is to regard the back faces of the volume as objects. When a ray exits the volume it returns the coordinates of the exit point. <p> The T_buffer data structure is a temporary storage that can store multiple coordinates in each of its entries. The function elim_hidd goes over these coordinates and eliminates the potentially hidden ones, employing one of the methods described above. Compared to the method proposed by Gudmundsson and Randen <ref> [6] </ref>, which suffers from image degradation and can only support first-opaque ray traversal, our method does not accumulate any image degradation since the values in the C-buffer are refreshed in each view. Our method can support semitransparent rendering as well as maximum-value and weighted summation rendering paradigms.
Reference: [7] <author> Levoy, M., </author> <title> Display of Surfaces from Volume Data, </title> <journal> Com puter Graphics and Applications, </journal> <volume> 8, </volume> <month> 5 (May </month> <year> 1988), </year> <pages> 29-37. </pages>
Reference-contexts: While following a ray, the voxels it pierces are sampled and the resulting colors and opacities are accumulated to yield the rays final color <ref> [7] </ref>. The simplest volume sampling method performs zero-order interpolation to locate the nearest voxel and uses a 3D integer-based line algorithm to generate the ray. A more precise algorithm is based on a continuous line algorithm that can take several samples per voxel. <p> In this paper, however, we deal only with ray-casting. Several methods, originating from surface-based ray tracing algorithms, have been suggested to reduce the computation involved in volumetric ray casting. Methods have been described that reduce the cost of tracing each ray by employing adaptive termination <ref> [5, 7] </ref> or by adaptively reducing the sampling rate along the ray [5, 10]. Alternatively, acceleration can be achieved by reducing the number of rays [8], or by exploiting coherency between rays in orthographic viewing [15].
Reference: [8] <author> Levoy, M., </author> <title> Volume Rendering by Adaptive Refinement, </title> <journal> The Visual Computer, </journal> <volume> 6, </volume> <month> 1 (February </month> <year> 1990), </year> <pages> 2-7. </pages>
Reference-contexts: Methods have been described that reduce the cost of tracing each ray by employing adaptive termination [5, 7] or by adaptively reducing the sampling rate along the ray [5, 10]. Alternatively, acceleration can be achieved by reducing the number of rays <ref> [8] </ref>, or by exploiting coherency between rays in orthographic viewing [15]. Another set of acceleration techniques provide the ray traversal algorithm with the means to efficiently traverse or even skip the empty space surrounding the volumetric objects. We call this capability space-leaping. <p> This approach decomposes the volume into uniform regions that can be represented by nodes in a hierarchical data structure. An adjusted ray traversal algorithm skips the (uniform) empty space by maneuvering through the hierarchical data structure <ref> [8, 9] </ref>. It was also observed [4] that instead of traversing the hierarchical data structure (which is less efficient, compared to regular volume traversal), the uniformity information implied by the octree can be stored in the empty space of the regular 3D volume grid, as shown in Figure 3.
Reference: [9] <author> Samet, H. and Webber, R. E., </author> <title> Hierarchical Data Structures and Algorithms for Computer Graphics, Part II: </title> <journal> Applica tions, IEEE Computer Graphics and Applications, </journal> <volume> 8, </volume> <month> 7 (July </month> <year> 1988), </year> <pages> 59-75. </pages> <note> [10] van Walsum, </note> <author> T., Hin, A. J. S., Versloot, J. and Post, F. H., </author> <title> Efficient Hybrid Rendering of Volume data and Polygons, </title> <booktitle> Sec ond Eurographics Workshop on Visualization in Scientific Computing, </booktitle> <address> Delft, Netherlands, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: This approach decomposes the volume into uniform regions that can be represented by nodes in a hierarchical data structure. An adjusted ray traversal algorithm skips the (uniform) empty space by maneuvering through the hierarchical data structure <ref> [8, 9] </ref>. It was also observed [4] that instead of traversing the hierarchical data structure (which is less efficient, compared to regular volume traversal), the uniformity information implied by the octree can be stored in the empty space of the regular 3D volume grid, as shown in Figure 3.
Reference: [11] <author> Westover, L., </author> <title> Footprint Evaluation for Volume Rendering, </title> <journal> Computer Graphics, </journal> <volume> 24, </volume> <month> 4 (August </month> <year> 1990), </year> <pages> 367-376. </pages>
Reference-contexts: Since the relationship between the two voxels in (a) changed, it serves as an indicator that the voxel at [x, y, z] is potentially hidden (b). (i,k) (x,y,z) (i,k) (x,y,z) (b) Another possible solution involves a variation of the splatting idea <ref> [11] </ref>. When a C-buffer coordinates value is transformed it is not written to the target pixel only. Instead, it is written into a neighborhood of C-buffer pixels. In each pixel, a Z-buffer mechanism is activated for each coordinates value that is mapped to it.
Reference: [12] <author> Yagel, R., Cohen, D., Kaufman, A. and Zhang, Q., </author> <title> Volumetric Ray Tracing, </title> <type> TR 91.01.09, </type> <institution> Computer Science, SUNY at Stony Brook, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: It is obvious that the empty space does not have to be sampled - it has only to be crossed as fast as possible. Therefore, we have proposed <ref> [12] </ref> to utilize a crude but fast line algorithm in the empty space (e.g., integer-based 26-connected line algorithm) and another, more accurate (e.g., integer-based 6 connected or 3D DDA oating point line algorithm), in the vicinity and interior of objects. <p> The effectiveness of this approach depends on its ability to efficiently switch back and forth between the two line algorithms and its ability to efficiently detect the proximity of occupied voxels. We have shown elsewhere the details of how to switch between line connectivities <ref> [12] </ref> and how to efficiently switch between any number of line algorithms when employing the template-based ray casting algorithm [13]. Sensing the proximity of data voxels can be achieved by having a volume buffer called max 27 which is maintained in addition to the data volume.
Reference: [13] <author> Yagel, R., </author> <title> Efficient Methods for Volume Graphics, </title> <institution> Doctor al Dissertation, Department of Computer Science, SUNY at Stony Brook, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: We have shown elsewhere the details of how to switch between line connectivities [12] and how to efficiently switch between any number of line algorithms when employing the template-based ray casting algorithm <ref> [13] </ref>. Sensing the proximity of data voxels can be achieved by having a volume buffer called max 27 which is maintained in addition to the data volume. This buffer contains, in each voxel, the maximum value in the immediate neighborhood of the corresponding voxel in the data volume [5]. <p> The effectiveness of this algorithm is obviously dependent on the ability of the line traversal algorithm to efficiently jump arbitrary number of steps [4]. We have shown elsewhere how to efficiently accommodate this feature in the template-based ray casting algorithm <ref> [13] </ref>. All existing space-leaping methods require 3D preprocessing that needs to be repeated for any change in the volume data.
Reference: [14] <author> Yagel, R., Cohen, D. and Kaufman, A., </author> <title> Discrete Ray Tracing, </title> <journal> IEEE Computer Graphics & Applications, </journal> <volume> 12, </volume> <month> 5 (Sep tember </month> <year> 1992), </year> <pages> 19-28. </pages>
Reference-contexts: It also uses higher order interpolation to compute the sample value. If the ray is traced as it reects from surfaces (in order to simulate reections, refractions and shadows) we call it ray tracing <ref> [14] </ref>. In this paper, however, we deal only with ray-casting. Several methods, originating from surface-based ray tracing algorithms, have been suggested to reduce the computation involved in volumetric ray casting.
Reference: [15] <author> Yagel, R. and Kaufman, A., </author> <title> Template-Based Volume View ing, </title> <journal> Computer Graphics Forum, </journal> <volume> 11, </volume> <month> 3 (September </month> <year> 1992), </year> <pages> 153-157, </pages> <publisher> Blackwell Publishers. </publisher>
Reference-contexts: Alternatively, acceleration can be achieved by reducing the number of rays [8], or by exploiting coherency between rays in orthographic viewing <ref> [15] </ref>. Another set of acceleration techniques provide the ray traversal algorithm with the means to efficiently traverse or even skip the empty space surrounding the volumetric objects. We call this capability space-leaping. The method described in this paper (Section 4) provides space-leaping capabilities when rendering a sequence of images.
Reference: [16] <author> Zuiderveld, K., Koning, A. H. J. and Viergever, M. A., </author> <title> Ac celeration of Ray Casting Using 3D Distance Transforms, </title> <booktitle> Proceedings of Visualization in Biomedical Computing 1992, </booktitle> <volume> 1808, </volume> <month> (October </month> <year> 1992), </year> <pages> 324-335, SPIE. </pages>
Reference-contexts: Encountering an empty voxel later (un-occupied and not carrying the vicinity ag) can signal a switch back to the rapid traversal algorithm which is employed in the empty space. The proximity-clouds method <ref> [4, 16] </ref> is based on the extension of this idea even further.
References-found: 15

