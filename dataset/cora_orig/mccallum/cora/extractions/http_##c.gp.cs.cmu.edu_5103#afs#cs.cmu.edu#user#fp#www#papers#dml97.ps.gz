URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/papers/dml97.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/homepage.html
Root-URL: http://www.cs.cmu.edu
Email: Email: hwxi+@cs.cmu.edu  Email: fp+@cs.cmu.edu  
Title: A Schema for Adding Dependent Types to ML  
Author: Hongwei Xi Frank Pfenning 
Date: July 23, 1997  
Address: 5000 Forbes Avenue Pittsburgh, PA 15213  5000 Forbes Avenue Pittsburgh, PA 15213  
Affiliation: Department of Mathematical Sciences Carnegie Mellon University  Department of Computer Science Carnegie Mellon University  
Abstract: We present an approach to enriching ML's type system with a form of dependent types, where index objects are restricted to some constraint domains C, leading to the DML(C) language schema. Pure inference for the resulting system is no longer possible, but we show that type-checking a sufficiently annotated program can be reduced to constraint satisfaction. We exhibit the unobtrusiveness of our approach through practical examples (including static array bounds checking) and prove that DML(C) is conservative over ML. The main technical contribution of the paper lies in our language design, including its elaboration and type-checking rules which make the approach practical. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Constable, R. L. et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986, </year> <pages> x+299 pp. </pages>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [16], or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl <ref> [1] </ref>, or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. In order to achieve this, the type systems are relatively simple and only elementary properties of programs can be expressed and thus checked by a compiler.
Reference: [2] <author> Dowek, G., Felty, A., Herbelin, H., Huet, G., Murthy, C., Parent, C., Paulin-Mohring, C., and Werner, B. </author> <title> The Coq Proof Assistant User's Guide. Rapport Techniques, no. </title> <type> 154, </type> <institution> INRIA, Rocquencourt, France, </institution> <year> 1993. </year> <note> Version 5.8. </note>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [16], or Haskell [6], and those for small, pure languages such as the ones underlying Coq <ref> [2] </ref>, NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. <p> We plan to consider a combination of these ideas in future work. Parent [14] recently proposed to reverse the process of extracting programs from constructive proofs in Coq <ref> [2] </ref>, synthesizing proof skeletons from annotated programs. Such proof skeletons contain "holes" corresponding to logical propositions not unlike our constraint formulas.
Reference: [3] <author> Freeman, T. and Pfenning, F. </author> <title> Refinement types for ML. </title> <booktitle> in: Proceedings of the SIG-PLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, On-tario, </address> <month> June. </month> <year> 1991, </year> <pages> pp. 268-277. </pages>
Reference-contexts: Since it extends ML conservatively, it can be used sparingly, existing ML programs will work as before (if there is no keyword conflict). When compared to traditional type systems for programming languages, perhaps the closest related work is refinement types <ref> [3] </ref>, which also aims at expressing and checking more properties of programs that are already well-typed in ML, rather than admitting more programs as type correct, which is the goal of most other research on extending type systems. <p> On the other hand, this allows a richer source language with fewer annotations and, in practice, avoids interaction with a theorem prover. Hayashi proposed a type system ATTT [4], which allows a notion of refinement types as in the type system for ML <ref> [3] </ref>, plus intersection and union of refinement types and singleton refinement types. He demonstrated the value of singleton, union and intersection types in extracting realistic programs, which is similar to our use of corresponding logical operators on constraints. <p> The critical issues are poly-morphism (including parameterized datatypes), exceptions, mutable references, and module-level constructs. Since our design explicitly separates indices from ML expressions, we expect these extensions to be mostly straightforward. Another practically important extension may be 10 the introduction of limited forms of intersection types <ref> [3] </ref>, so that more than one dependent type can be assigned to a function without code duplication. Our primary motivation is to allow the programmer to express more program properties through types and thus catch more errors at compile time.
Reference: [4] <author> Hayashi, S. </author> <title> Singleton, union and intersection types for program extraction. </title> <booktitle> in: Proceedings of the International Conference on Theoretical Aspects of Computer Software, Sendai, </booktitle> <address> Japan, </address> <month> September, </month> <title> edited by A. </title> <editor> R. Meyer. </editor> <year> 1991. </year>
Reference-contexts: Our aims and methods are similar, but much less general in the kind of specifications we can express. On the other hand, this allows a richer source language with fewer annotations and, in practice, avoids interaction with a theorem prover. Hayashi proposed a type system ATTT <ref> [4] </ref>, which allows a notion of refinement types as in the type system for ML [3], plus intersection and union of refinement types and singleton refinement types.
Reference: [5] <author> Hayashi, S. and Nakano, H. PX: </author> <title> A Computational Logic. </title> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [16], or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX <ref> [5] </ref>. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. In order to achieve this, the type systems are relatively simple and only elementary properties of programs can be expressed and thus checked by a compiler.
Reference: [6] <editor> Hudak, P., Peyton Jones, S. L., Wadler, P., et al. </editor> <title> A Report on the Functional Language Haskell. </title> <journal> SIGPLAN Notices, </journal> <year> 1992. </year>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [16], or Haskell <ref> [6] </ref>, and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations.
Reference: [7] <author> Jay, C. and Sekanina, M. </author> <title> Shape checking of array programs. no. </title> <institution> 96.09, School of Computer Sciences, University of Technology, </institution> <address> Sydney, Australia, </address> <year> 1996. </year>
Reference-contexts: This embedding translates programing language constructs into type-theoretic expressions, which is a rather involved task requiring complex reasoning about the resulting expressions. We believe that our approach could be used to check some of these properties. Jay and Sekanina <ref> [7] </ref> have introduced a technique for array bounds checking based on the notion of shape types. Shape checking is a kind of partial evaluation and has very different characteristics and source language when compared to DML (C), where C consists of linear integer equality and inequality constraints.
Reference: [8] <author> Kreitz, C. </author> <title> Formal Reasoning about Communication Systems I: Embedding ML into Type Theory. </title> <institution> Cornell University, Department of Computer Science, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Some progress has been made towards bridging this gap, for example, by extracting CAML programs from Coq proofs, by synthesizing proofs from CAML-like programs [14], or by embedding fragments of ML into NuPrl <ref> [8] </ref>. In this paper we take a different approach, conservatively refining the type system of ML by allowing some dependencies, without destroying the desirable properties of ML such as practical and unintrusive type checking. <p> We specify and check less information about functions which avoids general theorem proving. On the other hand, we currently do not address module-level issues, although we believe that our approach should extend naturally to signatures and functors without much additional machinery. Chris Kreitz <ref> [8] </ref> embedded a subset of the OCaml programming language into NuPrl for reasoning about programs written in this subset. The objective is to develop automated tools for the verification and optimization of group communication systems.
Reference: [9] <author> MacQueen, D. B., Plotkin, G. D., and Sethi, R. </author> <title> An Ideal Model for Recursive Polymorphic Types. </title> <journal> Information and Control, </journal> <volume> vol. 71 (1986), </volume> <pages> pp. 95-130. </pages>
Reference-contexts: Note that this is quite different from the use of dependent types to analyze modular structure (as, for example, in <ref> [9] </ref>) We now present a brief example from our implementation before going into further details.
Reference: [10] <author> Milner, R., Tofte, M., and Harper, R. W. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990, </year> <pages> xi+101 pp. </pages>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML <ref> [10] </ref>, CAML [16], or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations.
Reference: [11] <author> Necula, G. </author> <title> Compiling with Proofs. </title> <type> Thesis Proposal, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Our primary motivation is to allow the programmer to express more program properties through types and thus catch more errors at compile time. We are also interested in using this as a front-end for a certifying compiler <ref> [11] </ref> which propagates program properties through a compiler where they can be used for optimizations or be packaged with the binaries in the form of proof-carrying code [12]. 7 Acknowledgement We gratefully acknowledge discussions with Rowan Davies, Peter Lee, and George Necula regarding the subject of this paper.
Reference: [12] <author> Necula, G. </author> <title> Proof-Carrying Code. </title> <booktitle> in: Conference Record of 24th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January, </month> <pages> 15 - 17. </pages> <year> 1997. </year>
Reference-contexts: We are also interested in using this as a front-end for a certifying compiler [11] which propagates program properties through a compiler where they can be used for optimizations or be packaged with the binaries in the form of proof-carrying code <ref> [12] </ref>. 7 Acknowledgement We gratefully acknowledge discussions with Rowan Davies, Peter Lee, and George Necula regarding the subject of this paper.
Reference: [13] <author> Owre, S., Rajan, S., Rushby, J., Shankar, N., and Srivas, M. PVS: </author> <title> Combining Specification, Proof Checking, and Model Checking. in: Computer-Aided Verification, CAV '96, edited by R. </title> <editor> Alur and T. A. Henzinger. </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 1102, </volume> <publisher> Springer-Verlag, </publisher> <address> New Brunswick, NJ, </address> <year> 1996, </year> <pages> pp. 411-414. </pages>
Reference-contexts: This can be achieved by a straightforward transformation of the typing rules and is omitted here due to space constraints. 5 Related work Our work falls in between full program verification, either in type theory or systems such as PVS <ref> [13] </ref>, and traditional type systems for programming languages. When compared to verification, our system is less expressive but more automatic when constraint domains with practical constraint satisfaction problems are chosen.
Reference: [14] <author> Parent, C. </author> <title> Synthesizing proofs from programs in the Calculus of Inductive Constructions. in: Proceedings of Mathematics for Programs Constructions. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 947, </volume> <year> 1995. </year>
Reference-contexts: Some progress has been made towards bridging this gap, for example, by extracting CAML programs from Coq proofs, by synthesizing proofs from CAML-like programs <ref> [14] </ref>, or by embedding fragments of ML into NuPrl [8]. In this paper we take a different approach, conservatively refining the type system of ML by allowing some dependencies, without destroying the desirable properties of ML such as practical and unintrusive type checking. <p> We plan to consider a combination of these ideas in future work. Parent <ref> [14] </ref> recently proposed to reverse the process of extracting programs from constructive proofs in Coq [2], synthesizing proof skeletons from annotated programs. Such proof skeletons contain "holes" corresponding to logical propositions not unlike our constraint formulas.
Reference: [15] <author> Sannella, D. and Tarlecki, A. </author> <title> Toward Formal Development of ML Programs: Foundations and Methodology. no. </title> <institution> ECS-LFCS-89-71, Laboratory for Foundations of Computer Science, Depatment of Computer Science, University of Edinburgh, The King's Buildings, Edinburgh EH9 3JZ, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: He demonstrated the value of singleton, union and intersection types in extracting realistic programs, which is similar to our use of corresponding logical operators on constraints. However, he does not address the practical problem of type checking or partial inference. Sannella and Tarlecki proposed Extended ML <ref> [15] </ref> as a framework for the formal development of programs in a pure fragment of Standard ML. The module system of Extended ML can not only declare the type of a function but also the axioms it satisfies. This leads to the need of theorem proving during type checking.
Reference: [16] <author> Weis, P. and Leroy, X. </author> <title> Le langage Caml. </title> <address> InterEditions, Paris, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML <ref> [16] </ref>, or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations.
References-found: 16

