URL: http://www.informatik.hu-berlin.de/~lenz/Papers94/iclp.ps.gz
Refering-URL: http://www.informatik.hu-berlin.de/~lenz/lenz.publications.html
Root-URL: 
Email: e-mail: fgeske,lenzg@first.gmd.de  
Title: A Type-Based Debugging Tool for Untyped Logic Languages  
Author: Ulrich Geske, Mario Lenz 
Date: January 13, 1995  
Address: Rudower Chaussee 5, 12489 Berlin, Germany  
Affiliation: National Research Center for Computer Science GMD-FIRST  
Abstract: This paper presents a method for debugging type errors in untyped logic programs by generating type information based on abstract interpretation with OLDT resolution. The notion "type" is extended to enable the phenomena in logic programs to be described more precisely. The classes Single Types and Collected Types are introduced. An extended OLDT resolution performs combination of derived single types to collected types. Application of the different types for debugging unmodular and modular logic programs is discussed, and an extension of the module interface format proposed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Beierle, S. Bottcher, and G. Meyer. </author> <title> Draft report of the logic programming language PROTOS-L. </title> <type> IWBS Report 175, </type> <institution> IBM, </institution> <year> 1991. </year>
Reference: [2] <author> M. Bruynooghe and G. Janssens. </author> <title> An instance of abstract interpretation integrating type and mode inferencing. </title> <booktitle> In Proc. 5th International Conference and Symposium on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. <ref> [2, 6, 7, 11, 12, 13] </ref>) and using (e.g. [5, 9]) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be. <p> Rather, a collection of calling and corresponding success patterns is returned which are based on the abstract domain. * Predicates which demand a certain typing of arguments when being called (e.g. arithmetic built-in predicates) are not taken into account at all. Bruynooghe et al <ref> [2, 3] </ref> use abstract interpretation, too, to derive type information for logic programs: An AND-OR-tree is constructed adorned with abstract substitutions yielding type information. Though built-in predicates are handled separately, the problem of required typings of arguments is not addressed. <p> Though built-in predicates are handled separately, the problem of required typings of arguments is not addressed. The notion of type is different from that used by Kanamori and Kawamura. In particular, since the values of the variables of a call "immediately before its execution" <ref> [2] </ref> are used for type information the inferred type is generally different. Mishra defines the type of a procedure as follows: "Predicate p has type T if p (t) fails for all t outside T"([8]).
Reference: [3] <author> M. Bruynooghe, G. Janssens, A. Callebaut, and B. Demoen. </author> <title> Abstract interpretation: Towards the global optimisation of prolog programs. </title> <booktitle> In Proc. Symposium on Logic Programming, </booktitle> <year> 1987. </year>
Reference-contexts: Rather, a collection of calling and corresponding success patterns is returned which are based on the abstract domain. * Predicates which demand a certain typing of arguments when being called (e.g. arithmetic built-in predicates) are not taken into account at all. Bruynooghe et al <ref> [2, 3] </ref> use abstract interpretation, too, to derive type information for logic programs: An AND-OR-tree is constructed adorned with abstract substitutions yielding type information. Though built-in predicates are handled separately, the problem of required typings of arguments is not addressed.
Reference: [4] <author> K. Daessler and C. Pichler. ISO/IEC JTC1 SC22 WG17. </author> <title> Technical Report N111. Pro log. Part2, Modules Working Draft 4.0., International Organization for Standardization, </title> <institution> Deutsches Institut fur Normung e.V., National Physical Laboratory, Teddington, </institution> <address> Middlesex, England, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Anonymous Variables as in Example 7, can be detected since the third argument is unbound even after successful return of path/3 (see the P-type). Hence we can assume that this argument is either never used or misspelled. 10 We use the module syntax of <ref> [4] </ref> extended by type information. 7 Ill-typed Arguments are observed if (according to the given type hierarchy) two or more types of that argument do not have an MSC. E.g. in Example 8 non empty and atom do not have a MCS.
Reference: [5] <author> R. Dietrich. </author> <title> Modes and types for prolog. </title> <institution> Arbeitspapiere der GMD 285, GMD, </institution> <year> 1988. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. [2, 6, 7, 11, 12, 13]) and using (e.g. <ref> [5, 9] </ref>) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be. Even worse, different authors define their types differently. <p> For the purpose of this paper the notion of a logic program is a synonym of a Prolog program. 2 What is a Type | Previous Work Many authors, such as Mycroft and O'Keefe [9] and Dietrich <ref> [5] </ref> try to use given type information either to derive further properties of a logic program or to optimize it. In such contexts, typing places ": : : restrictions on defined predicates: : : " [9] | thus the task is type checking .
Reference: [6] <author> T. W. Fruhwirth. </author> <title> Type inference by program transformation and partial evaluation. </title> <editor> In H. Abramson and M. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <pages> pages 263-282. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. <ref> [2, 6, 7, 11, 12, 13] </ref>) and using (e.g. [5, 9]) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be.
Reference: [7] <author> T. Kanamori and T. Kawamura. </author> <title> Abstract interpretation based on OLDT resolution. </title> <journal> The Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 1-30, </pages> <year> 1993. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. <ref> [2, 6, 7, 11, 12, 13] </ref>) and using (e.g. [5, 9]) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be. <p> In the following, we will briefly sketch how various authors use the notion of types. This list of research is far from being complete but may be considered representative. The analysis of these approaches shows the urgent need for a clear and homogeneous concept of types. Kanamori and Kawamura <ref> [7] </ref> describe OLDT resolution as a method for deriving type information which is based on abstract interpretation. <p> we only want to focus on the obtained type information: * The idea heavily relies on calling patterns of procedures and their instantiation upon suc cessful return: "When the execution (of a call) : : : succeeds, to what data types of terms are (the arguments) : : : instantiated?" <ref> [7] </ref>. * It is not discussed what the derived type stands for, i.e. what kind of type is obtained. * There is no description of how the various parts of type information for each procedure can be merged to obtain the type of the procedure. <p> Similarly, for the path/3 program of Example 4 we compute the A-type path:non emptyfinumberfi'NUMBER'. To obtain this information, we extended the type information handled during OLDT resolution by a second part: * The first part, as in <ref> [7] </ref>, contains the single types, i.e. SU-, SC-, and D-type. * Our additional second part contains information about type requirements to avoid run-time errors due to ill-typed arguments of built-in predicates.
Reference: [8] <author> P. Mishra. </author> <title> Towards a theory of types in prolog. </title> <booktitle> In Proc. IEEE International Symposium on Logic Programming, </booktitle> <year> 1984. </year>
Reference-contexts: What should be the derived type information 3 ? Procedure According to <ref> [8] </ref> Intended type path/4 atom fi atom fi list (atom) fi number atom fi atom fi list (atom) fi number way/3 atom fi atom fi number atom fi atom fi number append/3 list (any) fi any fi any list (any) fi list (any) fi list (any) is int/1 int any smaller/2
Reference: [9] <author> A. Mycroft and R. A. O'Keefe. </author> <title> A polymorphic type system for prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. [2, 6, 7, 11, 12, 13]) and using (e.g. <ref> [5, 9] </ref>) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be. Even worse, different authors define their types differently. <p> For the purpose of this paper the notion of a logic program is a synonym of a Prolog program. 2 What is a Type | Previous Work Many authors, such as Mycroft and O'Keefe <ref> [9] </ref> and Dietrich [5] try to use given type information either to derive further properties of a logic program or to optimize it. In such contexts, typing places ": : : restrictions on defined predicates: : : " [9] | thus the task is type checking . <p> a Type | Previous Work Many authors, such as Mycroft and O'Keefe <ref> [9] </ref> and Dietrich [5] try to use given type information either to derive further properties of a logic program or to optimize it. In such contexts, typing places ": : : restrictions on defined predicates: : : " [9] | thus the task is type checking . The type information is requested from the programmer.
Reference: [10] <author> L. Naish. </author> <title> Types and intended meaning. </title> <editor> In F. Pfenning, editor, </editor> <booktitle> Types in Logic Programming, chapter 6. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: While this kind of type is useful in specific contexts 2 , we have found that it is not sufficient to describe the different uses of procedures within a program, e.g. for test predicates. Naish <ref> [10] </ref> investigates the relations between a logic program, a given specification for that program, and the intended meaning of it. Using straightforward examples, Naish shows that neither the logic program nor an additional specification are sufficient to ": : : fully specify the intended semantics : : : " [10] of <p> Naish <ref> [10] </ref> investigates the relations between a logic program, a given specification for that program, and the intended meaning of it. Using straightforward examples, Naish shows that neither the logic program nor an additional specification are sufficient to ": : : fully specify the intended semantics : : : " [10] of logic programs. Consequently, he demands that type information be supplied by the user. <p> The main advantage of this approach is the combination of the simplicity of a top-down-interpreter with the safety of a bottom-up-strategy. 4 As shown e.g. by Naish <ref> [10] </ref> the actual intention can not be detected automatically. 5 In what follows, the notion of type generally refers to the instantiation of clauses or procedures according to some given abstract domain. 3 Single types Abbr.
Reference: [11] <author> C. Solnon and M. Rueher. </author> <title> Extracting inheritance hierarchies from prolog programs: A system based on the inference of type relations. </title> <booktitle> In Proc. LPAR, </booktitle> <year> 1993. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. <ref> [2, 6, 7, 11, 12, 13] </ref>) and using (e.g. [5, 9]) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be.
Reference: [12] <author> H. Tamaki and T. Sato. </author> <title> OLD resolution with tabulation. </title> <booktitle> In Proc. 3rd ICLP, </booktitle> <year> 1986. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. <ref> [2, 6, 7, 11, 12, 13] </ref>) and using (e.g. [5, 9]) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be.
Reference: [13] <author> R. Warren and M. Hermenegildo. </author> <title> On the practicality of global flow analysis of logic programs. </title> <booktitle> In Proc. 6th International Conference and Symposium on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The tool is being used for both: debugging of logic programs, and translation of Prolog programs into Protos-L ([1]), a Prolog-like language with type concept. In recent years a number of researchers have proposed frameworks for both, deriving (e.g. <ref> [2, 6, 7, 11, 12, 13] </ref>) and using (e.g. [5, 9]) type information of logic programs. However, we realized that none of these approaches is really suitable for the above sketched purposes. Instead,, there is some kind of vague notion of what the type of a procedure should be.
References-found: 13

