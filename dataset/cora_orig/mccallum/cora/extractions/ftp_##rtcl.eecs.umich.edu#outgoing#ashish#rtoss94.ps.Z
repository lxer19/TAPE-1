URL: ftp://rtcl.eecs.umich.edu/outgoing/ashish/rtoss94.ps.Z
Refering-URL: http://www.eecs.umich.edu/~ashish/
Root-URL: http://www.cs.umich.edu
Email: E-mail: fjrexford, ashish, jdolter, farnamg@eecs.umich.edu  
Title: Window-Consistent Replication for Real-Time Applications to handle a higher rate of operations and provide more
Author: Jennifer Rexford, Ashish Mehra, James Dolter and Farnam Jahanian 
Note: Decoupling the transmission of updates to the backups from the processing of client requests permits the primary  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of EECS The University of Michigan  
Abstract: Two widely-studied approaches for structuring fault-tolerant services are the state-machine and the primary-backup replication schemes. For a large class of soft and hard real-time applications, the degree of consistency among servers can be exploited to design replication protocols with predictable timing behavior. This is particularly useful in applications, such as automated process control, in which one can tradeoff the quality or precision for timely availability of data. This paper presents the architecture and prototype implementation of a primary-backup replication service that employs window consistency semantics between the primary data repository and the backups. A client registers a data object with the service by declaring the consistency requirements for the data, in terms of a time window. The primary ensures that each backup site maintains a version of the object that was valid on the primary within the preceding time window by scheduling update messages to the backups. fl The work reported in this paper was supported in part by the National Science Foundation under Grant MIP-9203895. Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the view of the NSF. Also supported by a grant from the Rackham School of Graduate Studies at the University of Michigan. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Mehra, J. Rexford, J. Dolter, and F. Jahanian, </author> <title> "Window-consistent replication service," </title> <type> Technical report, </type> <institution> Department of EECS, University of Michigan, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: For a large class of soft and hard real-time applications, this restriction can be more detrimental than having a slightly stale copy of the data on the backups. This paper presents the architecture of a new primary-backup scheme, referred to as the window-consistent replication service <ref> [1] </ref>, which exploits the ability of many real-time applications to tolerate controlled time-inconsistency of the repository to provide timely availability of this data. The notion of window consistency relaxes atomic or causal consistency among replicas to obtain less expensive replication protocols.
Reference: [2] <author> C. Pu and A. Leff, </author> <title> "Replica control in distributed systems: An asynchronous approach," </title> <booktitle> in Proc. ACM SIGMOD, </booktitle> <pages> pp. 377-386, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Hence, several alternatives have been proposed that eliminate or relax serializability as a correctness criteria for managing consistency in real-time transactions. Among these are *-serializability <ref> [2] </ref>, similarity [3],temporal and external consistency [4], triggered real-time databases [5]. The above correctness criteria allow more concurrency by supporting a limited amount of inconsistency in how a transaction views the database state.
Reference: [3] <author> T.-W. Kuo and A. K. Mok, </author> <title> "Application semantics and con-currency control of real-time data-intensive applications," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference: [4] <author> K.-J. Lin, F. Jahanian, A. Jhingran, and C. D. Locke, </author> <title> "A model of hard real-time transaction systems," </title> <type> Technical Report RC 17515, </type> <institution> IBM T.J. Watson Reseach Center, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Hence, several alternatives have been proposed that eliminate or relax serializability as a correctness criteria for managing consistency in real-time transactions. Among these are *-serializability [2], similarity [3],temporal and external consistency <ref> [4] </ref>, triggered real-time databases [5]. The above correctness criteria allow more concurrency by supporting a limited amount of inconsistency in how a transaction views the database state. The idea of imprecise computation is an interesting related approach that sacrifices accuracy for timeliness in real-time computations [6].
Reference: [5] <author> H. F. Korth, N. Soparkar, and A. Silberschatz, </author> <title> "Triggered real time databases with consistency constraints," </title> <booktitle> in Proc. of the 16th VLDB Conference, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Hence, several alternatives have been proposed that eliminate or relax serializability as a correctness criteria for managing consistency in real-time transactions. Among these are *-serializability [2], similarity [3],temporal and external consistency [4], triggered real-time databases <ref> [5] </ref>. The above correctness criteria allow more concurrency by supporting a limited amount of inconsistency in how a transaction views the database state. The idea of imprecise computation is an interesting related approach that sacrifices accuracy for timeliness in real-time computations [6].
Reference: [6] <author> J. Liu, K.-J. Lin, W.-K. Shih, R. Bettati, and J. Chung, </author> <title> "Imprecise computations," </title> <note> to appear in IEEE Proceedings, Jan-uary 1994. </note>
Reference-contexts: The above correctness criteria allow more concurrency by supporting a limited amount of inconsistency in how a transaction views the database state. The idea of imprecise computation is an interesting related approach that sacrifices accuracy for timeliness in real-time computations <ref> [6] </ref>. Exploiting weak consistency to obtain better performance has also been proposed in other non-real-time applications. For instance, in [7], the notion of quasi-copy is introduced which allows a weaker type of consistency between the central data and its cached copies at remote sites.
Reference: [7] <author> R. Alonso, D. Barbara, and H. Garcia-Molina, </author> <title> "Data caching issues in an information retrieval system," </title> <journal> ACM Trans. Database Systems, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 359-384, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The idea of imprecise computation is an interesting related approach that sacrifices accuracy for timeliness in real-time computations [6]. Exploiting weak consistency to obtain better performance has also been proposed in other non-real-time applications. For instance, in <ref> [7] </ref>, the notion of quasi-copy is introduced which allows a weaker type of consistency between the central data and its cached copies at remote sites.
Reference: [8] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: By casting the transmissions of updates as tasks, the primary US can draw upon real-time task scheduling algorithms. While several task models can accommodate window-consistent scheduling, we initially consider the periodic task model <ref> [8, 9] </ref>. With the periodic model, the primary coordinates transmissions to the backups by scheduling an update task with period p i and service time e i for each object O i 1 . <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. Rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods <ref> [8, 9] </ref>, while earliest-due-date scheduling favors tasks with earlier deadlines [8]. Given a schedulable set of tasks, the primary US ensures that O i is sent to the backup once per period p i , resulting in a maximum time of 2p i between successive transmissions of O i . <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. Rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods [8, 9], while earliest-due-date scheduling favors tasks with earlier deadlines <ref> [8] </ref>. Given a schedulable set of tasks, the primary US ensures that O i is sent to the backup once per period p i , resulting in a maximum time of 2p i between successive transmissions of O i .
Reference: [9] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> "The rate monotonic scheduling algorithm: Exact characterization and average case behavior," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 166-171, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: By casting the transmissions of updates as tasks, the primary US can draw upon real-time task scheduling algorithms. While several task models can accommodate window-consistent scheduling, we initially consider the periodic task model <ref> [8, 9] </ref>. With the periodic model, the primary coordinates transmissions to the backups by scheduling an update task with period p i and service time e i for each object O i 1 . <p> The scheduler always runs the ready task with the highest priority, preempting execution if a higher-priority task arrives. Rate-monotonic scheduling statically assigns higher priority to tasks with shorter periods <ref> [8, 9] </ref>, while earliest-due-date scheduling favors tasks with earlier deadlines [8]. Given a schedulable set of tasks, the primary US ensures that O i is sent to the backup once per period p i , resulting in a maximum time of 2p i between successive transmissions of O i .
Reference: [10] <author> K. G. Shin, D. D. Kandlur, D. L. Kiskis, P. S. Dodd, H. A. Rosenberg, and A. Indiresan, </author> <title> "A distributed real-time operating system," </title> <journal> IEEE Software, </journal> <pages> pp. 58-68, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The prototype implements rate-monotonic scheduling with compression. While Solaris 1.1 provides a stable environment for code development and testing, the platform does not support real-time thread scheduling, bounded communication delays, or synchronized clocks. After initial code development and testing, we will evaluate the service in a real-time distributed system <ref> [10] </ref>. The prototype provides a general framework for comparing the performance of different scheduling algorithms for coordinating update transmissions to the backups. We are currently investigating the distance-constrained task model [11] which assigns priorities based on separation restrictions.
Reference: [11] <author> C.-C. Han and K.-J. Lin, </author> <title> "Scheduling distance-constrained real-time tasks," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 300-308, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: After initial code development and testing, we will evaluate the service in a real-time distributed system [10]. The prototype provides a general framework for comparing the performance of different scheduling algorithms for coordinating update transmissions to the backups. We are currently investigating the distance-constrained task model <ref> [11] </ref> which assigns priorities based on separation restrictions. In addition, we are considering adaptive scheduling algorithms that incorporate knowledge of recent client interaction with the primary.
References-found: 11

