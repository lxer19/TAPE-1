URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/misc/applied-AI.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Email: sonia@deis64.cineca.it  nebel@dfki.uni-sb.de  
Title: Acquisition and Validation of Complex Object Database Schemata Supporting Multiple Inheritance  
Author: Sonia Bergamaschi Bernhard Nebel 
Note: This work was partially supported by the Italian project  Parallelo, subproject 5, objective LOGIDATA of the National Research Council (CNR) and by the German Ministry for Research and Technology (BMFT) under grant ITW 8901 8.  
Address: Italy  Stuhlsatzenhausweg 3 D-66123 Saarbrucken Germany  
Affiliation: Facolta di Ingegneria Universita di Modena CIOC-CNR  German Research Center for Artificial Intelligence (DFKI)  Sistemi informatici e Calcolo  
Abstract: We present an intelligent tool for the acquisition of object oriented schemata supporting multiple inheritance, which preserves taxonomy coherence and performs taxonomic inferences. Its theoretical framework is based on terminological logics, which have been developed in the area of artificial intelligence. The framework includes a rigorous formalization of complex objects, which is able to express cyclic references on the schema and instance level; a subsumption algorithm, which computes all implied specialization relationships between types; and an algorithm to detect incoherent types, i.e., necessarily empty types. Using results from formal analyses of knowledge representation languages, we show that subsumption and incoherence detection are computationally intractable from a theoretical point of view. However, the problems appear to be feasible in almost all practical cases. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD International Conference on Mangement of Data, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: The former kind of class type corresponds to ordinary class-types used in object-oriented database systems, while the latter are similar to relational database 1 For a recent survey on different TL systems see [19]. 1 views or to virtual classes, recently introduced by Abiteboul and Bonner <ref> [1] </ref>. With both base and virtual class-types, the taxonomic reasoner plays the passive role of an inheritance consistency checker and the more active role of an automatic classificator. <p> The idea of introducing virtual classes and subsumption in a database schema has been considered in a number of papers [8, 11, 12]. Our work extends the framework of all the above quoted papers since we allow cyclic virtual classes specification. In <ref> [1] </ref> virtual classes are introduced in an object-oriented database schema, with the aim of introducing a sophisticated view mechanism. Our formalism does not enable all the facilities proposed in this paper, but includes possibilities for populating cyclic virtual classes not considered in this paper.
Reference: [2] <author> S. Abiteboul and R. Hull. </author> <title> IFO: A formal semantic database model. </title> <journal> 29 ACM Transactions on Database Systems, </journal> <volume> 12(3) </volume> <pages> 525-565, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> The interpretation of such a type description is that it only gives the necessary conditions for objects to be instances of the described type. Much research effort has been devoted to formally define and guarantee inheritance consistency of database schemata, based on strict inheritance taxonomies <ref> [2, 20, 5] </ref>. <p> In particular, in [11] a very general theoretical framework (able to express the data semantics of the well-known conceptual models E/R [15], taxis [22], galileo [3], ifo <ref> [2] </ref>), is presented, which supports conceptual schema acquisition and organization by preserving coherence and minimality w.r.t. inheritance exploiting the framework of terminological reasoning. Complex object data models, recently proposed in the areas of deductive databases [2] and object oriented databases [21, 20] are more expressive than implemented terminological logic languages in <p> the data semantics of the well-known conceptual models E/R [15], taxis [22], galileo [3], ifo <ref> [2] </ref>), is presented, which supports conceptual schema acquisition and organization by preserving coherence and minimality w.r.t. inheritance exploiting the framework of terminological reasoning. Complex object data models, recently proposed in the areas of deductive databases [2] and object oriented databases [21, 20] are more expressive than implemented terminological logic languages in some aspects. For instance, most of the complex object data models introduce a distinction between values and objects with identity and, thus, between value types and class types (which are also briefly called classes). <p> In Section 2 we introduce the odl formalism. It is a TL formalism which incorporates well-known notions such as value types, complex values, class types and objects with identity, in full analogy with recent complex object models proposed in the areas of deductive databases <ref> [2] </ref> and object oriented databases [21, 20]. Section 3 contains the algorithms to solve the subsumption 2 and incoherence problems. The approach is to firstly transform an odl schema into a canonical form and then to define subsumption and incoherence algorithms for canonical schemata.
Reference: [3] <author> A. Albano, L. Cardelli, and R. Orsini. </author> <title> Galileo: a strongly typed, interactive conceptual language. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 2 </volume> <pages> 230-260, </pages> <year> 1985. </year>
Reference-contexts: In particular, in [11] a very general theoretical framework (able to express the data semantics of the well-known conceptual models E/R [15], taxis [22], galileo <ref> [3] </ref>, ifo [2]), is presented, which supports conceptual schema acquisition and organization by preserving coherence and minimality w.r.t. inheritance exploiting the framework of terminological reasoning.
Reference: [4] <editor> P. Atzeni, editor. LOGIDATA+: </editor> <title> Deductive Databases with Complex Objects. </title> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1993. </year>
Reference-contexts: Employee h works-in: Department; level: MdmLevel i virtual-class Department = isa Branch h employs: fClerkg i virtual-class Secretary = isa Employee h works-in: Office; level: MdmLevel i virtual-class Office = isa Branch; Sector h employs: fSecretaryg i Table 1: The company domain schema in logidata + syntax Using logidata + <ref> [4] </ref> syntax, the company domain example can be formalized as done in Table 1. Declarations prefixed with the keyword type introduce value-type declarations similar to types used in programming languages. In our case, three integer range types and one type having sets of strings as values are introduced. <p> In fact, our experience with the odl-designer tool, which is described below, supports this hypothesis. 5 The odl-designer Tool The odl-designer prototype [7], which has been developed at CIOC-CNR, Bologna, as part of the logidata + project <ref> [4] </ref>, implements taxonomic reasoning methods and techniques for advanced database management systems handling complex objects data models. It is an active tool which supports automatic building of type taxonomies for complex object database systems, preserving coherence and minimality with respect to inheritance.
Reference: [5] <author> P. Atzeni and D. S. Parker. </author> <title> Formal properties of net-based knowledge representation schemes. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 3 </volume> <pages> 137-147, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> The interpretation of such a type description is that it only gives the necessary conditions for objects to be instances of the described type. Much research effort has been devoted to formally define and guarantee inheritance consistency of database schemata, based on strict inheritance taxonomies <ref> [2, 20, 5] </ref>.
Reference: [6] <author> F. Baader. </author> <title> Terminological cycles in KL-ONE-based knowledge representation languages. </title> <booktitle> In Proceedings of the 8th National Conference of the American Association for Artificial Intelligence, </booktitle> <pages> pages 621-626, </pages> <address> Boston, MA, Aug. 1990. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Finally, we allow circular references in class-type descriptions and extend the semantics using results from knowledge repre 2 sentation research <ref> [6, 25] </ref>. The model, which we call odl, makes it possible to perform the passive coherence check of a database schema including multiple inheritance taxonomies of value-types, base classes and virtual classes. <p> In other words, it is not necessary to "resolve inheritance conflicts" on attributes that inherit different value ranges from multiple classes as in O 2 [21], but the value range of an attribute is simply the intersection over the value ranges of this attribute in all parent classes. 4 See <ref> [6, 25, 9] </ref> for a more detailed description of the various semantics. 13 2.5 Inheritance, Subsumption, and Coherence Based on the definitions above, we now give formal definitions for the notions of subsumption and incoherence. Given a schema oe, there is the question for the semantic relationship between types. <p> Subsumption in odl is even more difficult, as the next theorem shows. 20 Theorem 6 Subsumption is PSPACE-hard. Even a restriction to binary compact systems of atomic types does not help in this case because the language inclusion problem for non-deterministic finite state automata can be reduced to subsumption <ref> [24, 6, 25] </ref>.
Reference: [7] <author> J. P. Ballerini, S. Bergamaschi, and C. Sartori. </author> <title> The ODL-DESIGNER prototype. </title> <editor> In P. Atzeni, editor, LOGIDATA+: </editor> <title> Deductive Databases with complex objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In fact, our experience with the odl-designer tool, which is described below, supports this hypothesis. 5 The odl-designer Tool The odl-designer prototype <ref> [7] </ref>, which has been developed at CIOC-CNR, Bologna, as part of the logidata + project [4], implements taxonomic reasoning methods and techniques for advanced database management systems handling complex objects data models. <p> Second, within the logidata + project, odl-designer is a kernel component which will be connected in the second phase of the project with the graphical user interface supporting class taxonomies and with the object store system developed by other research groups <ref> [7] </ref>. F1: allows the creation of an odl schema, the addition of new classes to a pre-existing odl schema, and the modification of a pre-existing odl schema. It performs coherence control and produces the canonical form of the odl schema.
Reference: [8] <author> H. W. Beck, S. K. Gala, and S. B. Navathe. </author> <title> Classification as a query processing technique in the CANDIDE semantic data model. </title> <booktitle> In Proceedings of the International Data Engineering Conference, IEEE, </booktitle> <pages> pages 572-581, </pages> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1989. </year> <month> 30 </month>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> Applying taxonomic reasoning to traditional semantic data models led to a number of promising results for database schema design [17, 16, 11] and other relevant topics as query processing and data recognition <ref> [8, 12] </ref>. <p> Let us briefly compare our work with some recent works close to our approach. The idea of introducing virtual classes and subsumption in a database schema has been considered in a number of papers <ref> [8, 11, 12] </ref>. Our work extends the framework of all the above quoted papers since we allow cyclic virtual classes specification. In [1] virtual classes are introduced in an object-oriented database schema, with the aim of introducing a sophisticated view mechanism.
Reference: [9] <author> D. Beneventano and S. Bergamaschi. </author> <title> Subsumption for complex object data models. </title> <booktitle> In Proceedings of the International Conference on Database Theory, </booktitle> <address> Berlin, Germany, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In other words, it is not necessary to "resolve inheritance conflicts" on attributes that inherit different value ranges from multiple classes as in O 2 [21], but the value range of an attribute is simply the intersection over the value ranges of this attribute in all parent classes. 4 See <ref> [6, 25, 9] </ref> for a more detailed description of the various semantics. 13 2.5 Inheritance, Subsumption, and Coherence Based on the definitions above, we now give formal definitions for the notions of subsumption and incoherence. Given a schema oe, there is the question for the semantic relationship between types.
Reference: [10] <author> S. Bergamaschi and J. P. Ballerini. </author> <title> Automatic building and validation of complex object database schemata. </title> <type> Technical Report 91, </type> <institution> CIOC-CNR, Bologna, Italy, </institution> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Theorem 2 Any schema oe over S (A; B; N) can be effectively transformed into a schema over S (A; B; N) that is a canonical extension of oe. The algorithm for transforming a given schema into an equivalent canonical schema is given in <ref> [10] </ref>.
Reference: [11] <author> S. Bergamaschi and C. Sartori. </author> <title> On taxonomic resoning in conceptual design. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(3) </volume> <pages> 385-422, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> With both base and virtual class-types, the taxonomic reasoner plays the passive role of an inheritance consistency checker and the more active role of an automatic classificator. Applying taxonomic reasoning to traditional semantic data models led to a number of promising results for database schema design <ref> [17, 16, 11] </ref> and other relevant topics as query processing and data recognition [8, 12]. <p> Applying taxonomic reasoning to traditional semantic data models led to a number of promising results for database schema design [17, 16, 11] and other relevant topics as query processing and data recognition [8, 12]. In particular, in <ref> [11] </ref> a very general theoretical framework (able to express the data semantics of the well-known conceptual models E/R [15], taxis [22], galileo [3], ifo [2]), is presented, which supports conceptual schema acquisition and organization by preserving coherence and minimality w.r.t. inheritance exploiting the framework of terminological reasoning. <p> Further, complex object models often support additional type constructors, such as set and sequence. Most importantly, complex object data models usually support the representation and management of cyclic classes, i.e., classes which directly or indirectly make references to themselves. The aim of this paper, following the approach of <ref> [11] </ref>, is to propose a theoretical framework based on taxonomic reasoning for complex object schema acquisition and organization, preserving inheritance consistency (in the following called coherence) and minimality w.r.t. inheritance. This framework serves as the theoretical kernel of an intelligent tool for advanced database schema design. <p> Let us briefly compare our work with some recent works close to our approach. The idea of introducing virtual classes and subsumption in a database schema has been considered in a number of papers <ref> [8, 11, 12] </ref>. Our work extends the framework of all the above quoted papers since we allow cyclic virtual classes specification. In [1] virtual classes are introduced in an object-oriented database schema, with the aim of introducing a sophisticated view mechanism.
Reference: [12] <author> A. Borgida, R. J. Brachman, D. L. McGuinness, and L. A. Resnick. </author> <title> CLASSIC: a structural data model for objects. </title> <booktitle> In Proceedings of the 1989 ACM SIGMOD International Conference on Mangement of Data, </booktitle> <pages> pages 59-67, </pages> <address> Portland, OR, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> Applying taxonomic reasoning to traditional semantic data models led to a number of promising results for database schema design [17, 16, 11] and other relevant topics as query processing and data recognition <ref> [8, 12] </ref>. <p> Let us briefly compare our work with some recent works close to our approach. The idea of introducing virtual classes and subsumption in a database schema has been considered in a number of papers <ref> [8, 11, 12] </ref>. Our work extends the framework of all the above quoted papers since we allow cyclic virtual classes specification. In [1] virtual classes are introduced in an object-oriented database schema, with the aim of introducing a sophisticated view mechanism.
Reference: [13] <author> R. J. Brachman and J. G. Schmolze. </author> <title> An overview of the KL-ONE knowledge representation system. </title> <journal> Cognitive Science, </journal> <volume> 9(2) </volume> <pages> 171-216, </pages> <month> Apr. </month> <year> 1985. </year>
Reference-contexts: In the area of artificial intelligence, a class of knowledge representation systems, called Terminological Logic Systems [23] (henceforth TL) has been developed, which are based on the ideas developed in connection with the kl-one system <ref> [13] </ref>. 1 These systems assign a more active role to type taxonomies. First, it is possible to specify necessary and sufficient conditions in a type description. Second, based on this, the task of creating the type hierarchy can be delegated to the system.
Reference: [14] <author> L. A. Cardelli. </author> <title> Semantics of multiple inheritance. </title> <booktitle> In Semantics of Data Types, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1984. </year>
Reference-contexts: In the O 2 object-oriented DBMS [21], for example, the introduction of new types which violate strict inheritance semantics is prevented by means of well-known type checking techniques <ref> [14] </ref> (i.e., A can only be a specialization of B if the type of A is a refinement of the type of B). <p> n fi fi p q; v i 2 I [S i ]; 0 i p; o I [4S] = o 2 O fi fiffi (o) 2 I [S] o Note that the interpretation of tuples implies an open world semantics for tuple types similar to the one adopted by Cardelli <ref> [14] </ref>.
Reference: [15] <author> P. P. Chen. </author> <title> The entity-relationship model towards a unified view of data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(1) </volume> <pages> 9-36, </pages> <year> 1976. </year> <month> 31 </month>
Reference-contexts: In particular, in [11] a very general theoretical framework (able to express the data semantics of the well-known conceptual models E/R <ref> [15] </ref>, taxis [22], galileo [3], ifo [2]), is presented, which supports conceptual schema acquisition and organization by preserving coherence and minimality w.r.t. inheritance exploiting the framework of terminological reasoning.
Reference: [16] <author> L. Delcambre and K. Davis. </author> <title> Automatic validation of object-oriented database structures. </title> <booktitle> In 5th International Conference on Data Engineering, </booktitle> <pages> pages 2-9, </pages> <address> Los Angeles, CA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> With both base and virtual class-types, the taxonomic reasoner plays the passive role of an inheritance consistency checker and the more active role of an automatic classificator. Applying taxonomic reasoning to traditional semantic data models led to a number of promising results for database schema design <ref> [17, 16, 11] </ref> and other relevant topics as query processing and data recognition [8, 12].
Reference: [17] <author> T. W. Finin and D. Silverman. </author> <title> Interactive classification as a knowledge acquisition tool. </title> <editor> In L. Kerschberg, editor, </editor> <booktitle> Expert Database Systems|Proceedings From the 1st International Workshop, </booktitle> <pages> pages 79-90. </pages> <address> Benjamin/Cummings, Menlo Park, CA, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> With both base and virtual class-types, the taxonomic reasoner plays the passive role of an inheritance consistency checker and the more active role of an automatic classificator. Applying taxonomic reasoning to traditional semantic data models led to a number of promising results for database schema design <ref> [17, 16, 11] </ref> and other relevant topics as query processing and data recognition [8, 12].
Reference: [18] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability|A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference-contexts: Theorem 5 Checking coherence of a schema can be done in polynomial time provided the system of atomic types is binary compact, and is NP-hard in the general case. The NP-hardness result follows by a reduction from the emptiness of intersection problem for finite state automata, which is NP-hard <ref> [18] </ref>. Subsumption in odl is even more difficult, as the next theorem shows. 20 Theorem 6 Subsumption is PSPACE-hard.
Reference: [19] <author> J. Heinsohn, D. Kudenko, B. Nebel, and H.-J. Profitlich. </author> <title> An empirical analysis of terminological representation systems. </title> <booktitle> In Proceedings of the 10th National Conference of the American Association for Artificial Intelligence, </booktitle> <pages> pages 767-773, </pages> <address> San Jose, CA, July 1992. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The former kind of class type corresponds to ordinary class-types used in object-oriented database systems, while the latter are similar to relational database 1 For a recent survey on different TL systems see <ref> [19] </ref>. 1 views or to virtual classes, recently introduced by Abiteboul and Bonner [1]. With both base and virtual class-types, the taxonomic reasoner plays the passive role of an inheritance consistency checker and the more active role of an automatic classificator. <p> Relating our work to research in knowledge representation, it turns out that odl-designer viewed as a terminological knowledge representation system is one of the few systems that are able to deal correctly with cyclic classes <ref> [19] </ref>.
Reference: [20] <author> C. Lecluse and P. Richard. </author> <title> Modeling complex structures in object-oriented databases. </title> <booktitle> In Proceedings of the 8th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database-Systems, </booktitle> <pages> pages 360-367, </pages> <address> Philadelphia, PA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction and Motivation The organization of types in an inheritance taxonomy in order to describe an application domain constitutes a basic modeling principle in the database area and in artificial intelligence <ref> [2, 5, 17, 16, 20, 11, 8, 12] </ref>. In the database area, the type taxonomy is built by the designer: a type must be described by an explicit declaration of its parent types and its differentiae properties. <p> The interpretation of such a type description is that it only gives the necessary conditions for objects to be instances of the described type. Much research effort has been devoted to formally define and guarantee inheritance consistency of database schemata, based on strict inheritance taxonomies <ref> [2, 20, 5] </ref>. <p> Complex object data models, recently proposed in the areas of deductive databases [2] and object oriented databases <ref> [21, 20] </ref> are more expressive than implemented terminological logic languages in some aspects. For instance, most of the complex object data models introduce a distinction between values and objects with identity and, thus, between value types and class types (which are also briefly called classes). <p> In Section 2 we introduce the odl formalism. It is a TL formalism which incorporates well-known notions such as value types, complex values, class types and objects with identity, in full analogy with recent complex object models proposed in the areas of deductive databases [2] and object oriented databases <ref> [21, 20] </ref>. Section 3 contains the algorithms to solve the subsumption 2 and incoherence problems. The approach is to firstly transform an odl schema into a canonical form and then to define subsumption and incoherence algorithms for canonical schemata. <p> Sectors have exactly a name and a set of activities. Clerks are exactly those employees who work in a department, having a medium level (MdmLevel = 2-7). Departments, in turn, are exactly those branches that enroll only clerks. Sec 2 In <ref> [20] </ref> a relation called refinement is defined which is identical to our subsumption relation if we assume only virtual classes. 3 retaries are exactly those employees working in an office, having a medium level (MdmLevel = 2-7), and offices are exactly those particular branches and sectors that enroll only secretaries. <p> In its specification we basically follow the specification of O 2 <ref> [20] </ref>. However, we assume a richer structure for the system of atomic types, the system of non-decomposable, basic value-types. Besides the atomic types integer, boolean, string, real, and mono-valued types, we consider also the possibility that subsets of these types are used, e.g., intervals of integers. <p> Thus, instead of automatically using conjunctions of types|as we do|the user has to provide a type that refines the inherited types. The computation of the refinement relation is then performed on an internal normalized description, where no further inheritance is needed <ref> [20] </ref>. It is easy to see that this can be done in polynomial time. 6 Since the internal form can be handled efficiently, it must be the case that schemata exist that would lead to exponentially many conflict-resolution requests. However, such schemata are not very likely to appear in practice. <p> However, such schemata are not very likely to appear in practice. Hence, we conclude that transforming a schema to its canonical extension is 6 Polynomiality is guaranteed only if the disjunction operator discussed in that paper is omitted, a point that has been missed by Lecluse and Richard <ref> [20] </ref>. 21 feasible for most cases that appear in practice.
Reference: [21] <author> C. Lecluse and P. Richard. </author> <title> The O 2 database programming language. </title> <booktitle> In Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <pages> pages 411-422, </pages> <address> Amsterdam, The Netherlands, </address> <year> 1989. </year> <month> 32 </month>
Reference-contexts: Much research effort has been devoted to formally define and guarantee inheritance consistency of database schemata, based on strict inheritance taxonomies [2, 20, 5]. In the O 2 object-oriented DBMS <ref> [21] </ref>, for example, the introduction of new types which violate strict inheritance semantics is prevented by means of well-known type checking techniques [14] (i.e., A can only be a specialization of B if the type of A is a refinement of the type of B). <p> Complex object data models, recently proposed in the areas of deductive databases [2] and object oriented databases <ref> [21, 20] </ref> are more expressive than implemented terminological logic languages in some aspects. For instance, most of the complex object data models introduce a distinction between values and objects with identity and, thus, between value types and class types (which are also briefly called classes). <p> The main extensions of this framework with respect to other complex object models are, firstly, the conjunction operator, which permits the expression of multiple inheritance as part of a class-type description. This avoids the specification of explicit redefinitions (cf. <ref> [21] </ref>) in case of multiple inheritance. Secondly, we introduce a distinction between base class-types and virtual class-types. While the set of objects that are instances of a base class has to be provided by the user, the set of instances of a virtual class is computed by the system. <p> In Section 2 we introduce the odl formalism. It is a TL formalism which incorporates well-known notions such as value types, complex values, class types and objects with identity, in full analogy with recent complex object models proposed in the areas of deductive databases [2] and object oriented databases <ref> [21, 20] </ref>. Section 3 contains the algorithms to solve the subsumption 2 and incoherence problems. The approach is to firstly transform an odl schema into a canonical form and then to define subsumption and incoherence algorithms for canonical schemata. <p> In other words, it is not necessary to "resolve inheritance conflicts" on attributes that inherit different value ranges from multiple classes as in O 2 <ref> [21] </ref>, but the value range of an attribute is simply the intersection over the value ranges of this attribute in all parent classes. 4 See [6, 25, 9] for a more detailed description of the various semantics. 13 2.5 Inheritance, Subsumption, and Coherence Based on the definitions above, we now give <p> More evidence for the fact that subsumption computation can be done efficiently in most practical cases can be found in related data models. In the data model O 2 <ref> [21] </ref>, for instance, a relation called refinement is computed. This relation is identical to our subsumption relation if we assume that there are no base classes. Multiple inheritance in O 2 always leads to a request for a "conflict resolution" by the user [21]. <p> In the data model O 2 <ref> [21] </ref>, for instance, a relation called refinement is computed. This relation is identical to our subsumption relation if we assume that there are no base classes. Multiple inheritance in O 2 always leads to a request for a "conflict resolution" by the user [21]. Thus, instead of automatically using conjunctions of types|as we do|the user has to provide a type that refines the inherited types. The computation of the refinement relation is then performed on an internal normalized description, where no further inheritance is needed [20]. <p> Instead of viewing inheritance as a syntactic transformation (as in O 2 <ref> [21] </ref>), inheritance is expressed by conjunctions of types. Additionally, we introduce the notion of virtual classes, which is similar to database views, and allow the definition of cyclic references in class definitions.
Reference: [22] <author> J. Mylopoulos, P. A. Bernstein, and H. K. T. Wong. </author> <title> A language facility for designing interactive database-intensive systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(2) </volume> <pages> 185-207, </pages> <year> 1980. </year>
Reference-contexts: In particular, in [11] a very general theoretical framework (able to express the data semantics of the well-known conceptual models E/R [15], taxis <ref> [22] </ref>, galileo [3], ifo [2]), is presented, which supports conceptual schema acquisition and organization by preserving coherence and minimality w.r.t. inheritance exploiting the framework of terminological reasoning.
Reference: [23] <author> B. Nebel. </author> <title> Reasoning and Revision in Hybrid Representation Systems, </title> <booktitle> volume 422 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1990. </year>
Reference-contexts: In the area of artificial intelligence, a class of knowledge representation systems, called Terminological Logic Systems <ref> [23] </ref> (henceforth TL) has been developed, which are based on the ideas developed in connection with the kl-one system [13]. 1 These systems assign a more active role to type taxonomies. First, it is possible to specify necessary and sufficient conditions in a type description.
Reference: [24] <author> B. Nebel. </author> <title> Terminological reasoning is inherently intractable. </title> <journal> Artificial Intelligence, </journal> <volume> 43 </volume> <pages> 235-249, </pages> <year> 1990. </year>
Reference-contexts: Subsumption in odl is even more difficult, as the next theorem shows. 20 Theorem 6 Subsumption is PSPACE-hard. Even a restriction to binary compact systems of atomic types does not help in this case because the language inclusion problem for non-deterministic finite state automata can be reduced to subsumption <ref> [24, 6, 25] </ref>. <p> As can be shown, there are indeed schemata that lead to exponentially sized canonical extensions. A worst-case example is given in <ref> [24] </ref>. Although these results may suggest that subsumption computation may not be feasible in our model, it turns out that the intractability of the problem does not very often show up in practice|an observation also made in the area of knowledge representation [24], where we have to deal with quite similar <p> A worst-case example is given in <ref> [24] </ref>. Although these results may suggest that subsumption computation may not be feasible in our model, it turns out that the intractability of the problem does not very often show up in practice|an observation also made in the area of knowledge representation [24], where we have to deal with quite similar problems. The reason is probably that schemata are usually formulated in such a way that they are almost canonical, and, as is obvious from the description of the algorithms, coherence checking and subsumption computation on such schemata can be done efficiently.
Reference: [25] <author> B. Nebel. </author> <title> Terminological cycles: Semantics and computational properties. </title> <editor> In J. F. Sowa, editor, </editor> <booktitle> Principles of Semantic Networks, </booktitle> <pages> pages 331-362. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year> <month> 33 </month>
Reference-contexts: Finally, we allow circular references in class-type descriptions and extend the semantics using results from knowledge repre 2 sentation research <ref> [6, 25] </ref>. The model, which we call odl, makes it possible to perform the passive coherence check of a database schema including multiple inheritance taxonomies of value-types, base classes and virtual classes. <p> In other words, it is not necessary to "resolve inheritance conflicts" on attributes that inherit different value ranges from multiple classes as in O 2 [21], but the value range of an attribute is simply the intersection over the value ranges of this attribute in all parent classes. 4 See <ref> [6, 25, 9] </ref> for a more detailed description of the various semantics. 13 2.5 Inheritance, Subsumption, and Coherence Based on the definitions above, we now give formal definitions for the notions of subsumption and incoherence. Given a schema oe, there is the question for the semantic relationship between types. <p> Subsumption in odl is even more difficult, as the next theorem shows. 20 Theorem 6 Subsumption is PSPACE-hard. Even a restriction to binary compact systems of atomic types does not help in this case because the language inclusion problem for non-deterministic finite state automata can be reduced to subsumption <ref> [24, 6, 25] </ref>.
References-found: 25

