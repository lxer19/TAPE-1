URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/fudgets.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: fmagnus,hallgreng@cs.chalmers.se  
Title: Fudgets A Graphical User Interface in a Lazy Functional Language  
Author: Magnus Carlsson, Thomas Hallgren 
Affiliation: Chalmers University of Technology  
Abstract: This paper describes an implementation of a small window-based graphical user interface toolkit for X Windows written in the lazy functional language LML. By using this toolkit, a Haskell or LML programmer can create a user interface with menus, buttons and other graphical interface objects, without conforming to more or less imperative programming paradigms imposed if she were to use a traditional (imperative) toolkit. Instead, the power of the abstraction methods provided by Haskell or LML are used. The main abstraction we use is the fudget. Fudgets are combined in a hierarchical structure, and they interact by message passing. The current implementation is based on a sequential evaluator, but by using non-determinism and oracles, we suggest how the fudgets can evaluate in parallel. We believe that the toolkit can be extended to a full-feathered and practically useful high level graphical toolkit. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Ahlberg. GUIT, </author> <title> a Graphical User Interface Builder for the Fudgets Library. </title> <booktitle> In Proceedings of the Winter Meeting. </booktitle> <institution> Department of Computer Sciences, Chalmers, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: Whenever the button is pressed, the number is increased by one. The example is written in C using the popular toolkit Motif [25]: 2 static int count = 0; static Widget display; static void SetDisplay (Widget display, int i) - char s [10]; Arg wargs <ref> [1] </ref>; sprintf (s, "%d", i); 2 The example has been somewhat stripped; the callback arguments and arguments for determining various widget attributes are omitted, and so is the conversion between C-strings and Motif strings. <p> Code with explicit window geometry information will be generated by the layout program. A prototype layout program has been developed for the Fudgets library <ref> [1] </ref>. combined in the program. Secondly, the program is some-what cluttered with a lot of layout arguments which possibly hide the fudget structure. A solution is to wrap a layout filter around the combined fudgets, where the programmer specifies to the layout filter how the subfudgets should be placed.
Reference: [2] <author> L. Augustsson. </author> <title> Non-deterministic Programming in a Deterministic Functional Language. </title> <type> PMG Memo 66, </type> <institution> Department of Computer Sciences, Chalmers University of Technology, S-412 96 Goteborg, </institution> <year> 1988. </year>
Reference-contexts: We will now introduce the choose operator, which makes this possible. 7.1 Parallel evaluation with choose and oracles The operator choose has been implemented for doing nondeterministic programming in LML <ref> [2] </ref>. It has the type choose: Oracle -&gt; a -&gt; b -&gt; Bool choose o a b will evaluate the arguments a and b to WHNF in parallel (possibly using time slicing), and return True if a terminates first, otherwise False.
Reference: [3] <author> L. Augustsson and T. Johnsson. </author> <title> Lazy ML User's Manual. Programming Methodology Group, </title> <institution> Department of Computer Sciences, Chalmers, S-412 96 Goteborg, Sweden, </institution> <year> 1993. </year> <title> Distributed with the LML compiler. </title>
Reference-contexts: It also puts a larger part of burden of handling a GUI on the functional program, thus requiring the implementation to be more efficient to obtain good performance. The functional languages we work with are Lazy ML <ref> [3] </ref> and Haskell [8] and the window system is X Windows [17]. The interface to X Windows goes through Xlib [11]. Except for one example in C, all code in the paper is given in Haskell.
Reference: [4] <author> M. Carlsson. </author> <title> Fudgets Graphical User Interfaces and I/O in Lazy Functional Languages. </title> <type> Licentiate Thesis, </type> <institution> Chalmers University of Technology and University of Goteborg, Swe-den, </institution> <year> 1993. </year>
Reference-contexts: More issues about fudgets and parallel evaluation can be found in <ref> [4] </ref>. 8 Implementation The Fudgets library is built on top of Xlib [11], which contains a number of routines for creating and managing windows, rendering, reading events, etc. So, the implementation consists of two parts: the Fudgets library itself and an interface to Xlib.
Reference: [5] <author> M. Carlsson and T. Hallgren. </author> <title> The Fudgets library. </title> <institution> Chalmers University. </institution> <note> Anon. FTP: ftp.cs.chalmers.se: /pub/haskell/chalmers/lml-&lt;version&gt;.lmlx.tar.Z, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: So, the implementation consists of two parts: the Fudgets library itself and an interface to Xlib. The implementation (source and documentation) is available via anonymous ftp <ref> [5] </ref>. The Fudgets library is written in LML and consists of about 4000 lines of code.
Reference: [6] <author> E.R. Gansner and J. Reppy. </author> <title> The eXene widgets manual. </title> <institution> Cornell University. </institution> <note> Anon. FTP: ramses.cs.cornell.edu: /pub/eXene-doc.tar.Z, </note> <month> June </month> <year> 1991. </year>
Reference-contexts: A number of interfaces for functional languages have been built on top of existing toolkits, for example Lazy Wafe by Sinclair [18], XView/Miranda by Singh [19] and MIRAX by Tebbs [21]. In general, these interfaces lack combinators useful for structuring large applications. 9.1 eXene eXene, by Reppy and Gansner <ref> [14, 6] </ref>, is a toolkit for X Windows and Standard ML of New Jersey. It is written on top of Concurrent ML (CML) [13], and is thus multi-threaded. eXene aims towards being a full-fledged toolkit, completely written in SML (including the communication with the X server).
Reference: [7] <author> T. Hallgren. </author> <title> Introduction to Real-time Multi-user Games Programming in LML. </title> <type> Technical Report Memo 89, </type> <institution> Department of Computer Sciences, Chalmers, S-412 96 Goteborg, Sweden, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: With this type, the loop combinator from Section 3.2.4 is 9 The definition of pmerge is from <ref> [7] </ref>, where it is used in implementations of real-time multi-user games in LML. not needed as a primitive to recursively connect the differ-ent high level streams of our fudgets, instead we name the streams directly.
Reference: [8] <editor> Paul Hudak et al. </editor> <title> Report on the Programming Language Haskell: A Non-Strict, Purely Functional Language, </title> <month> March </month> <year> 1992. </year> <note> Version 1.2. Also in Sigplan Notices, </note> <month> May </month> <year> 1992. </year>
Reference-contexts: It also puts a larger part of burden of handling a GUI on the functional program, thus requiring the implementation to be more efficient to obtain good performance. The functional languages we work with are Lazy ML [3] and Haskell <ref> [8] </ref> and the window system is X Windows [17]. The interface to X Windows goes through Xlib [11]. Except for one example in C, all code in the paper is given in Haskell. <p> Firstly, the layout of fudgets is connected to the structure of the program. There is no easy way of saying that two fudgets should be placed together if they are not 6 There are other means of doing input/output in Haskell, see <ref> [8] </ref>. 7 Parts of the problem could be solved by using a graphical layout program which lets you place and resize fudgets with the mouse. Code with explicit window geometry information will be generated by the layout program. <p> The Fudgets library is written in LML and consists of about 4000 lines of code. The Xlib interface is outlined below. 8.1 Implementation of the interface to Xlib The facilities provided by XLib have been made available to the functional programs by extending the Haskell I/O system <ref> [8] </ref> (which can be used also in LML programs) with a few new requests and responses: data Request = -- file system requests: | ReadFile String | WriteFile String String . -- New requests for Xlib interface | XDoCommand XWId XCommand | XGetEvents data Response = Success | Str String |
Reference: [9] <author> S.L. Peyton Jones and P. Wadler. </author> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the 1993 Conference on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Thus, ordinary I/O operations can be performed inside fudgets. A few lines of C code for every Xlib call and other constructor, have been added to the run-time system to implement the interface. Using the C monad <ref> [9] </ref> (not currently supported by the Chalmers Haskell compiler), most of this can be written directly in Haskell instead. 9 Related work To our knowledge, Fudgetsis the first implementation of a toolkit in a lazy functional language that is not built on top of an existing toolkit.
Reference: [10] <author> E.G.J.M.H. Nocker, J.E.W. Smetsers, M.C.J.D. van Eekelen, and M.J. Plasmeyer. </author> <title> Concurrent clean. </title> <booktitle> In Proceedings of the PARLE'91 Parallel Architectures and Languages Europe conference (LNCS 505), </booktitle> <address> Eindhoven, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Whenever the button is pressed, the number is increased by one. The example is written in C using the popular toolkit Motif [25]: 2 static int count = 0; static Widget display; static void SetDisplay (Widget display, int i) - char s <ref> [10] </ref>; Arg wargs [1]; sprintf (s, "%d", i); 2 The example has been somewhat stripped; the callback arguments and arguments for determining various widget attributes are omitted, and so is the conversion between C-strings and Motif strings. <p> Whereas the interactions and dialogues might be good for text-based I/O, we do not find them appropriate for dealing with the parallel nature of a GUI. 9.3 Concurrent Clean input/output Concurrent Clean is a lazy language, where parts of the program can be evaluated in parallel <ref> [10] </ref>. The type system is 10 The interactions are a generalization of Dwelly's Dialogue com-binators, which have the same type on the input and output values. extended with so called unique types, which very much re-semble linear types.
Reference: [11] <author> A. Nye. </author> <title> Xlib reference manual, volume 2. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The functional languages we work with are Lazy ML [3] and Haskell [8] and the window system is X Windows [17]. The interface to X Windows goes through Xlib <ref> [11] </ref>. Except for one example in C, all code in the paper is given in Haskell. The main abstraction we use is the fudget, the functional correspondence to what is called the widget in some traditional GUI toolkits. <p> More issues about fudgets and parallel evaluation can be found in [4]. 8 Implementation The Fudgets library is built on top of Xlib <ref> [11] </ref>, which contains a number of routines for creating and managing windows, rendering, reading events, etc. So, the implementation consists of two parts: the Fudgets library itself and an interface to Xlib. The implementation (source and documentation) is available via anonymous ftp [5].
Reference: [12] <author> J. von Groningen P. Achten and R. Plasmeijer. </author> <title> High Level Specification of I/O in Functional Languages. </title> <booktitle> In Proc. of the International Workshop on Functional Languages. Springer Lecture Notes in Computer Science, </booktitle> <year> 1992. </year> <note> Anon. FTP: ftp.cs.kun.nl:/ pub/Clean/papers/CleanIOPaper.ps.Z. </note>
Reference-contexts: The type system is 10 The interactions are a generalization of Dwelly's Dialogue com-binators, which have the same type on the input and output values. extended with so called unique types, which very much re-semble linear types. In <ref> [12] </ref>, objects of unique types are used to model different aspects of the operating system, and functions for manipulating these objects can have instant real world effects, since the objects are unshared. This opens the possibility to do I/O `inside' the program.
Reference: [13] <author> J. Reppy. </author> <title> CML: A Higher-order Concurrent Language. </title> <booktitle> In Proceedings of the SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: In general, these interfaces lack combinators useful for structuring large applications. 9.1 eXene eXene, by Reppy and Gansner [14, 6], is a toolkit for X Windows and Standard ML of New Jersey. It is written on top of Concurrent ML (CML) <ref> [13] </ref>, and is thus multi-threaded. eXene aims towards being a full-fledged toolkit, completely written in SML (including the communication with the X server).
Reference: [14] <author> J. Reppy and E.R. Gansner. </author> <title> The eXene library manual. </title> <institution> Cornell University. </institution> <note> Anon. FTP: ramses.cs.cornell.edu: /pub/eXene-doc.tar.Z, </note> <month> June </month> <year> 1991. </year>
Reference-contexts: A number of interfaces for functional languages have been built on top of existing toolkits, for example Lazy Wafe by Sinclair [18], XView/Miranda by Singh [19] and MIRAX by Tebbs [21]. In general, these interfaces lack combinators useful for structuring large applications. 9.1 eXene eXene, by Reppy and Gansner <ref> [14, 6] </ref>, is a toolkit for X Windows and Standard ML of New Jersey. It is written on top of Concurrent ML (CML) [13], and is thus multi-threaded. eXene aims towards being a full-fledged toolkit, completely written in SML (including the communication with the X server).
Reference: [15] <author> M. Rittri. </author> <title> Using types as search keys in function libraries. </title> <journal> J. of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 71-89, </pages> <year> 1991. </year> <note> Earlier version in Func. Prog. </note> <editor> Lang. </editor> <booktitle> and Comput. Arch., 4th Conf., </booktitle> <publisher> ACM Press 1989. </publisher>
Reference-contexts: the user to zoom in/out, differentiate functions, and search for roots; life: an implementation of Conway's game of life. (See Section 5 for a more detailed description); sss: a simple spread sheet; xlmls: a GUI to a previously written program to search for functions in the LML library by type <ref> [15] </ref>; xmail: a simple mail reader; guit: a graphical user interface builder for the Fudgets library. 10.2 Future work By means of parallel evaluation and oracles, it seems like we could come even closer of capturing the parallel nature of a GUI, and permit a more natural way of connecting stream
Reference: [16] <author> N. Rojemo. </author> <title> Generational garbage collection is Leak-Prone. </title> <note> Submitted to FPCA 1993, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: We hope, however, that program transformations that reduce the amount of garbage generated and/or an appropriately tuned generational garbage collector <ref> [16] </ref> can be used to solve this problem. 10.1 Sample applications We have implemented a number of small applications using the Fudgets library: calc: a pocket calculator providing infinite precision rational numbers; clock: a transparent clock; graph: a program for viewing graphs of real valued functions of one real variable.
Reference: [17] <author> R.W. Scheifler and J. Gettys. </author> <title> The X Window System. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2), </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: It also puts a larger part of burden of handling a GUI on the functional program, thus requiring the implementation to be more efficient to obtain good performance. The functional languages we work with are Lazy ML [3] and Haskell [8] and the window system is X Windows <ref> [17] </ref>. The interface to X Windows goes through Xlib [11]. Except for one example in C, all code in the paper is given in Haskell. The main abstraction we use is the fudget, the functional correspondence to what is called the widget in some traditional GUI toolkits. <p> We take a quick look at the implementation of the interface to Xlib in Section 8. Related work is presented in Section 9 and conclusions are given in Section 10. 2 The X Windows system In the X Windows system <ref> [17] </ref>, you write a client program, which interacts with the user by communicating with a server process (the X server) which handles the lowest level interface with the hardware (display, keyboard, mouse).
Reference: [18] <author> D.C. Sinclair. </author> <title> Lazy Wafe Graphical Interfaces for Functional Languages. </title> <institution> Departement of Computing Science, University of Glasgow, </institution> <year> 1992. </year> <note> Draft. </note>
Reference-contexts: A number of interfaces for functional languages have been built on top of existing toolkits, for example Lazy Wafe by Sinclair <ref> [18] </ref>, XView/Miranda by Singh [19] and MIRAX by Tebbs [21]. In general, these interfaces lack combinators useful for structuring large applications. 9.1 eXene eXene, by Reppy and Gansner [14, 6], is a toolkit for X Windows and Standard ML of New Jersey.
Reference: [19] <author> S. Singh. </author> <title> Using XView/X11 from Miranda. </title> <editor> In Heldal et al., editor, </editor> <booktitle> Glasgow Workshop on Functional Programming, </booktitle> <year> 1991. </year>
Reference-contexts: A number of interfaces for functional languages have been built on top of existing toolkits, for example Lazy Wafe by Sinclair [18], XView/Miranda by Singh <ref> [19] </ref> and MIRAX by Tebbs [21]. In general, these interfaces lack combinators useful for structuring large applications. 9.1 eXene eXene, by Reppy and Gansner [14, 6], is a toolkit for X Windows and Standard ML of New Jersey.
Reference: [20] <author> J. Sparud. </author> <title> Fixing Some Space Leaks without a Garbage Collector. </title> <note> Submitted to FPCA 1993, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: A surprisingly simple method to eliminate space leaks of this kind <ref> [20] </ref>, has been successfully applied to the Fudgets library. 7 Parallelism and nondeterminism Maintaining a graphical user interface is really a task that is parallel in its nature, if you regard it as simultaneously view and update different parts of the interface.
Reference: [21] <author> M. Tebbs. </author> <title> MIRAX An X-window Interface for the Functional Programming Language Miranda. </title> <type> Technical report, </type> <institution> School of Engineering and Applied Science, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: A number of interfaces for functional languages have been built on top of existing toolkits, for example Lazy Wafe by Sinclair [18], XView/Miranda by Singh [19] and MIRAX by Tebbs <ref> [21] </ref>. In general, these interfaces lack combinators useful for structuring large applications. 9.1 eXene eXene, by Reppy and Gansner [14, 6], is a toolkit for X Windows and Standard ML of New Jersey. <p> Interaction a b -&gt; Interaction b c -&gt; Interaction a c sq i1 i2 (in,st) = (rest,st2,out1++out2) where (in1,st1,out1) = i1 (in,st) (in2,st2,out2) = i2 (in1,st1) These interactions have been used by Tebbs to implement an X Window interface in Miranda on top of an imperative toolkit written in C <ref> [21] </ref>. Having polymorphic input and output, the interactions resemble our fudgets.
Reference: [22] <author> S. Thompson. </author> <title> Interactive Functional Programming. In D.A. </title> <editor> Turner, editor, </editor> <booktitle> Research topics in Functional Programming. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990. </year>
Reference-contexts: Drawing is done in a imperative style, by calling drawing procedures. High level events are reported either imperatively or by message passing: e.g., when a button is pressed, a callback routine is called, or a message is output on a channel. 9.2 Interactions In <ref> [22] </ref>, Thompson uses interactions to do I/O: type Interaction a b = (Input,a) -&gt; (Input,b,Output) An Interaction ff fi is a function that, when applied to the input stream, will consume some input and return the rest, together with some output commands.
Reference: [23] <author> P. Wadler. </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <booktitle> In European Symposium on Programming, </booktitle> <pages> pages 344-358, </pages> <address> Nancy, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: A source of inefficiency in many functional programs is the repeated destruction and reconstruction of data structures. The event and command streams processed by fud-gets is a typical example of this. It would be interesting to see to what extent automatic program transformation, like deforestation <ref> [23] </ref>, can be used to eliminate this inefficiency. 11 Acknowledgements We wish to thank Lennart Augustsson, for his assistance in the extension of the run-time system to support the Xlib interface. Jan Sparud's fix of the space leaks suddenly made our programs much more useful.
Reference: [24] <author> P. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> In Proceedings 1992 Symposium on principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Albuquerque, New Mexico, </address> <year> 1992. </year>
Reference-contexts: A straightforward solution would be to stick to the imperative style by using variations of the state monad <ref> [24] </ref>. This suggests a simple way of using an existing imperative toolkit in a functional program.
Reference: [25] <author> D.A. Young. </author> <title> The X window System : programming and Applications with Xt. </title> <address> OSF/Motif Edition. </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Whenever the button is pressed, the number is increased by one. The example is written in C using the popular toolkit Motif <ref> [25] </ref>: 2 static int count = 0; static Widget display; static void SetDisplay (Widget display, int i) - char s [10]; Arg wargs [1]; sprintf (s, "%d", i); 2 The example has been somewhat stripped; the callback arguments and arguments for determining various widget attributes are omitted, and so is the
References-found: 25

