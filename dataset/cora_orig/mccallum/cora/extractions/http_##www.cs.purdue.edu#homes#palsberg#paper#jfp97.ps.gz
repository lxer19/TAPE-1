URL: http://www.cs.purdue.edu/homes/palsberg/paper/jfp97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: Trust in the -calculus  
Author: P. RBK AND J. PALSBERG 
Address: Ny Munkegade bld 540, 8000 Aarhus C, Denmark  
Affiliation: Dept. of Computer Science, University of Aarhus,  
Note: J. Functional Programming, 3(2):75-85, 1997. c Cambridge University Press 1  BRICS, Centre of the Danish National Research Foundation,  
Abstract: This paper introduces trust analysis for higher-order languages. Trust analysis encourages the programmer to make explicit the trustworthiness of data, and in return it can guarantee that no mistakes with respect to trust will be made at run-time. We present a confluent -calculus with explicit trust operations, and we equip it with a trust-type system which has the subject reduction property. Trust information is presented as annotations of the underlying Curry types, and type inference is computable in O(n 3 ) time.
Abstract-found: 1
Intro-found: 1
Reference: <author> Aiken, Alexander, & Murphy, Brian R. </author> <year> (1991). </year> <title> Static Type Inference in a Dynamically Typed Language. </title> <booktitle> Pages 279-290 of: Proc. of the 18'th annual ACM symp. on principles of programming languages (POPL 18). ACM. </booktitle>
Reference: <author> Aiken, Alexander, & Wimmers, Edward. </author> <year> (1993). </year> <title> Type inclusion constraints and type inference. </title> <booktitle> Pages 31-41 of: Proc. conference on functional programming languages and computer architecture. </booktitle>
Reference-contexts: An extension of our type inference algorithm remains to be found. Finding a good type inference algorithm for a type-system with both structural subtyping and polymorphism is a nontrivial task although the work by Aiken and Wimmers <ref> (Aiken & Wimmers, 1993) </ref> and by Eifrig, Smith and Trifonov (Eifrig et al., 1995) is promising. A Trust-case Construction. One could imagine the usefulness of a trust-case construction that would allow dynamic dispatch on the trustworthiness of a value.
Reference: <author> Ban^atre, Jean-Pierre, Bryce, Ciaran, & Metayer, Daniel Le. </author> <year> (1994). </year> <title> Compile-time detection of information flow in sequential programs. Pages 55-73 of: Gollmann, </title> <editor> Dieter (ed), </editor> <booktitle> Computer security - ESORICS 94, 3rd european symp. on research in comp. security. Lecture Notes in Computer Science, </booktitle> <volume> vol. </volume> <pages> 875. </pages> <address> Brighton, UK: </address> <publisher> Springer-Verlag. </publisher>
Reference: <author> Barendregt, Henk P. </author> <year> (1981). </year> <title> The lambda calculus: Its syntax and semantics. </title> <publisher> North-Holland. </publisher>
Reference-contexts: In order to facilitate the proof of the Church-Rosser property of the system, the reduction rules form a reflexive "one step" transition relation. This is inspired by the proof of Church-Rosser for the ordinary -calculus by Tait and Martin-Lof in <ref> (Barendregt, 1981, pp. 59-62) </ref>. The contraction rules exist to eliminate redundant uses of our new constructs in the calculus. <p> Theorem 1 (Church-Rosser) For expressions E, F and G. If E ! fl F and E ! fl G then there is an expression H such that F ! fl H and G ! fl H. Proof By the Diamond lemma below (Lemma 7) and Lemma 3.2.2 of <ref> (Barendregt, 1981) </ref>. <p> Reductions in the ordinary -calculus. 3.4 Simulation The aim of this section is to show that for well-typed terms one may erase all the trust, distrust and check constructs and reduce expressions according to the ordinary -calculus as displayed in Figure 11 (this is taken from Definition 3.2.3 in <ref> (Barendregt, 1981) </ref>.) We use the same symbol for this reduction relation as for our own and it will be clear from the context which reduction relation is meant. Note that the relation defined in Figure 11 is a sub-relation of the reduction relation defined in Figure 3.
Reference: <author> Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B., & Nelson, G. </author> <year> 1989 </year> <month> (Nov.). </month> <note> Modula-3 report (revised). Tech. rept. TR-52. DEC-SRC. </note>
Reference-contexts: Some external programming environment might also be used to ensure that only trustworthy programmers get to write trusted modules. One might also make another distinction among modules, akin to the difference between safe and unsafe modules in Modula-3 <ref> (Cardelli et al., 1989) </ref>, where only unsafe modules are allowed to use arbitrary type casts and unlimited address arithmetic.
Reference: <author> Cardelli, Luca. </author> <year> (1984). </year> <title> A semantics of multiple inheritance. Pages 51-68 of: </title> <editor> Kahn, Gilles, MacQueen, David, & Plotkin, Gordon (eds), </editor> <title> Semantics of data types. </title> <publisher> Springer-Verlag (LNCS 173). </publisher>
Reference-contexts: The ordering between base-types as determined by their trustworthiness is extended to higher types using the usual contra/co-variant structural subtyping idea of Mitchell (Mitchell, 1984), Fuh and Mishra (Fuh & Mishra, 1990), Cardelli <ref> (Cardelli, 1984) </ref> and others. The trust type system differs from many other type systems in that given a bare value (eg. 7) it is not possible to see by just examining the value whether it is trustworthy or not. <p> The type system. structural subtyping by Mitchell (Mitchell, 1984), Fuh and Mishra (Fuh & Mishra, 1990), Cardelli <ref> (Cardelli, 1984) </ref> and others. As in the denotational semantics we denote by _ the least upper bound operation on the trust lattice according to the ordering.
Reference: <author> Denning, Dorothy E. </author> <year> (1976). </year> <title> A Lattice Model of Secure Information Flow. </title> <journal> Communications of the ACM, </journal> <volume> 19(5), </volume> <pages> 236-242. </pages>
Reference-contexts: Notice how the (Constant) rules are patterned after the (Lambda Contraction) rules, and how the trustworthiness of the condition in an if-then-else construct affects the trustworthiness of the result. It shows that our function application rule seamlessly handles what Denning in <ref> (Denning, 1976) </ref> called indirect data dependencies.
Reference: <author> Denning, Dorothy E. </author> <year> (1982). </year> <title> Cryptography and data security. </title> <publisher> Addison-Wesley. </publisher>
Reference: <author> Denning, Dorothy E., & Denning, Peter J. </author> <year> (1977). </year> <title> Certifications of Programs for Secure Information Flow. </title> <journal> Communications of the ACM, </journal> <volume> 20(7), </volume> <pages> 504-512. </pages>
Reference: <author> Eifrig, Jonathan, Smith, Scott, & Trifonov, Valery. </author> <year> (1995). </year> <title> Type inference for recursively constrained types and it application to OOP. Proc. mathematical foundations of programming semantics. </title> <note> To appear. </note>
Reference-contexts: An extension of our type inference algorithm remains to be found. Finding a good type inference algorithm for a type-system with both structural subtyping and polymorphism is a nontrivial task although the work by Aiken and Wimmers (Aiken & Wimmers, 1993) and by Eifrig, Smith and Trifonov <ref> (Eifrig et al., 1995) </ref> is promising. A Trust-case Construction. One could imagine the usefulness of a trust-case construction that would allow dynamic dispatch on the trustworthiness of a value.
Reference: <author> Fuh, You-Chin, & Mishra, Prateek. </author> <year> (1990). </year> <title> Type Inference With Subtypes. </title> <journal> Theoretical computer science, </journal> <volume> 73(1), </volume> <pages> 155-175. </pages>
Reference-contexts: The ordering between base-types as determined by their trustworthiness is extended to higher types using the usual contra/co-variant structural subtyping idea of Mitchell (Mitchell, 1984), Fuh and Mishra <ref> (Fuh & Mishra, 1990) </ref>, Cardelli (Cardelli, 1984) and others. The trust type system differs from many other type systems in that given a bare value (eg. 7) it is not possible to see by just examining the value whether it is trustworthy or not. <p> The type system. structural subtyping by Mitchell (Mitchell, 1984), Fuh and Mishra <ref> (Fuh & Mishra, 1990) </ref>, Cardelli (Cardelli, 1984) and others. As in the denotational semantics we denote by _ the least upper bound operation on the trust lattice according to the ordering.
Reference: <author> Henglein, Fritz. </author> <year> (1992). </year> <title> Dynamic typing. </title> <booktitle> Pages 233-253 of: Proc. esop'92, european symposium on programming. </booktitle> <publisher> Springer-Verlag (LNCS 582). </publisher>
Reference: <author> Mitchell, John. </author> <year> (1984). </year> <title> Coercion and type inference. </title> <booktitle> Pages 175-185 of: Eleventh symposium on principles of programming languages. </booktitle> <editor> rbk, Peter. </editor> <year> (1995). </year> <title> Can you Trust your Data? Pages 575-590 of: </title> <editor> Mosses, P. D. (ed), </editor> <booktitle> Proceedings of the TAPSOFT/FASE'95 conference. Lecture Notes in Computer Science, </booktitle> <volume> vol. </volume> <pages> 915. </pages> <address> Aarhus, Denmark: </address> <publisher> Springer-Verlag. </publisher> <address> URL: ftp://ftp.daimi.aau.dk/pub/empl/- poe/index.html. </address>
Reference-contexts: This leads us to a type system with subtyping, such that an expression of a trusted type can be typed as an untrusted type. The ordering between base-types as determined by their trustworthiness is extended to higher types using the usual contra/co-variant structural subtyping idea of Mitchell <ref> (Mitchell, 1984) </ref>, Fuh and Mishra (Fuh & Mishra, 1990), Cardelli (Cardelli, 1984) and others. The trust type system differs from many other type systems in that given a bare value (eg. 7) it is not possible to see by just examining the value whether it is trustworthy or not. <p> The type system. structural subtyping by Mitchell <ref> (Mitchell, 1984) </ref>, Fuh and Mishra (Fuh & Mishra, 1990), Cardelli (Cardelli, 1984) and others. As in the denotational semantics we denote by _ the least upper bound operation on the trust lattice according to the ordering. <p> This work extends trust analysis to the higher order functional case and formalizes it in terms of an annotated type system. In <ref> (Mitchell, 1984) </ref> Mitchell developed the structural subtyping idea and our type 32 P. rbk and J. Palsberg system borrows some of these ideas to handle automatic coercion from trusted data to untrusted data.
Reference: <author> Palsberg, Jens. </author> <year> (1995). </year> <title> Efficient inference of object types. </title> <journal> Information and computation, </journal> <volume> 123(2), </volume> <pages> 198-209. </pages> <note> Preliminary version in Proc. </note> <editor> LICS'94, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 186-195, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Then we present an extension of the -calculus together with an y An extended abstract of an earlier version of this paper appears in the proceedings of the 1996 Static Analysis Symposium <ref> (Palsberg & rbk, 1995) </ref>. Trust in the -calculus 3 operational reduction calculus. The calculus is shown to have the Church-Rosser property. We also give a denotational semantics for our language and relate it to the reduction rules. We define our static trust analysis in terms of a type system. <p> The converse can be proved by induction on the construction of ( C; D). If we remove all mentioning of trust and subtyping from the type rules in Figure 8 and from the constraints defined earlier in this section, we obtain two equivalent formulations of Curry typability <ref> (Palsberg & Schwartzbach, 1995) </ref>. Clearly, E is Curry typable if and only if jEj is Curry typable. The constraint system (written out below) that expresses Curry typability will be denoted Curry (E). <p> Palsberg Input: A -term E of size n. 1: Construct T (E) = (C; D) (in log space). 2: Close (C; D), yielding ( C; D) (in O (n 3 ) time, see for example <ref> (Palsberg, 1995) </ref>). 3: Check if E is Curry typable (in O (n) time). 4: Check if D is solvable (in O (n 2 ) time). 5: If E is Curry typable and D is solvable, then output "typable" else output "not typable".
Reference: <author> Palsberg, Jens, & rbk, Peter. </author> <year> (1995). </year> <title> Trust in the -calculus. Pages 314-330 of: Mycroft, </title> <editor> Alan (ed), SAS'95: </editor> <title> Static Analysis. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. </volume> <pages> 983. </pages> <address> Glasgow: </address> <note> Springer-Verlag. Trust in the -calculus 35 Palsberg, </note> <author> Jens, & Schwartzbach, Michael I. </author> <year> (1995). </year> <title> Safety analysis versus type inference. </title> <journal> Information and computation, </journal> <volume> 118(1), </volume> <pages> 128-141. </pages>
Reference-contexts: Then we present an extension of the -calculus together with an y An extended abstract of an earlier version of this paper appears in the proceedings of the 1996 Static Analysis Symposium <ref> (Palsberg & rbk, 1995) </ref>. Trust in the -calculus 3 operational reduction calculus. The calculus is shown to have the Church-Rosser property. We also give a denotational semantics for our language and relate it to the reduction rules. We define our static trust analysis in terms of a type system. <p> The converse can be proved by induction on the construction of ( C; D). If we remove all mentioning of trust and subtyping from the type rules in Figure 8 and from the constraints defined earlier in this section, we obtain two equivalent formulations of Curry typability <ref> (Palsberg & Schwartzbach, 1995) </ref>. Clearly, E is Curry typable if and only if jEj is Curry typable. The constraint system (written out below) that expresses Curry typability will be denoted Curry (E). <p> Palsberg Input: A -term E of size n. 1: Construct T (E) = (C; D) (in log space). 2: Close (C; D), yielding ( C; D) (in O (n 3 ) time, see for example <ref> (Palsberg, 1995) </ref>). 3: Check if E is Curry typable (in O (n) time). 4: Check if D is solvable (in O (n 2 ) time). 5: If E is Curry typable and D is solvable, then output "typable" else output "not typable".
Reference: <author> Wall, Larry, & Schwartz, Randal L. </author> <year> (1991). </year> <title> Programming Perl. </title> <publisher> O'Reilly and Associates. </publisher>
Reference-contexts: As an example of a run-time version of trust-checking, the programming language Perl <ref> (Wall & Schwartz, 1991) </ref> has a switch that turns on so-called taint-checks at run-time that will abort the program with an error message if tainted input data are being used in "dangerous" functions such as unlink.
Reference: <author> Wright, Andrew K., & Cartwright, Robert. </author> <year> (1994). </year> <title> A Practical Soft Type System for Scheme. </title> <booktitle> Proceedings of the 1994 ACM conference on lisp and functional programming (lfp'94). ACM. </booktitle> <address> URL: ftp://cs.rice.edu/public/wright/HomePage.html. </address>
References-found: 17

