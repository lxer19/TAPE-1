URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/able/ftp/archmismatch-icse17.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/able/www/paper_abstracts/archmismatch-icse17.html
Root-URL: http://www.cs.cmu.edu
Title: Architectural Mismatch or Why it's hard to build systems out of existing parts  
Author: David Garlan Robert Allen John Ockerbloom 
Address: Pittsburgh, PA 15213, USA  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: Many would argue that future breakthroughs in software productivity will depend on our ability to combine existing pieces of software to produce new applications. An important step towards this goal is the development of new techniques to detect and cope with mismatches in the assembled parts. Some problems of composition are due to low-level issues of interoperability, such as mismatches in programming languages or database schemas. However, in this paper we highlight a different, and in many ways more pervasive, class of problem: architectural mismatch. Specifically, we use our experience in building a family of software design environments from existing parts to illustrate a variety of types of mismatch that center around the assumptions a reusable part makes about the structure of the application in which is to appear. Based on this experience we show how an architectural view of the mismatch problem exposes some fundamental, thorny problems for software composition and suggests possible research avenues needed to solve them. 
Abstract-found: 1
Intro-found: 1
Reference: [AAG93] <author> Gregory Abowd, Robert Allen, and David Garlan. </author> <title> Using style to understand descriptions of software architecture. </title> <booktitle> In Proceedings of SIGSOFT'93: Foundations of Software Engineering, Software Engineering Notes 18(5), </booktitle> <pages> pages 9-20. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: One component of this research is the construction of tools and environments to support architectural design and analysis. The primary thrust of that development effort has been finding effective mechanisms to exploit architectural style <ref> [AAG93, PW92] </ref>. An architectural style is a recurring pattern of system organization that provides an abstract framework for some family of applications.
Reference: [AG94] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <pages> pages 71-80, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This allows tools to register for changes to database objects and to announce significant events to other tools. Typical tools include a graphical editor for creating and browsing architectural designs, and other style-specific tools for carrying out architectural analyses, such as architectural consistency checkers <ref> [AG94] </ref>, code generators, architectural com ponent repositories, etc. The first prototype of the Aesop system was completed in August 1993. A second prototype has recently been constructed. <p> The connectors determine the interactions between the components: client-server protocols, pipes, RPC links, etc. These abstractions are typically expressed informally as box and line drawings, although recently formal notations for architectural description have begun to emerge <ref> [LAK + 95, SDK + 95, AG94, IW95] </ref>. Aesop-generated environment. At this level of abstraction the main components are a collection of tools and the architectural design manager (which consists primarily of a persistent object base). The main connectors are the RPC and event-broadcast mechanism communication links. <p> While documenting assumptions will not make mismatches disappear, at least it will be possible to detect problems early on. Some initial steps towards this goal can be seen in recent work on archi tecture description languages <ref> [AG94, LAK + 95, SDK + 95] </ref>. 2. Construct large pieces of software using orthogonal sub-components. While most large reusable subsystems are themselves constructed out of smaller sub-components, it is rare that one can separate the pieces or change the way in which those sub-components are combined.
Reference: [Bam90] <author> J. Bamberger. </author> <title> STARS/users workshop: Final report issues for discussion groups. </title> <type> Technical Report CMU/SEI-90-TR-32 ADA235776, </type> <institution> Software Engineering Institute (Carnegie Mellon University), </institution> <year> 1990. </year>
Reference-contexts: Here we focus on the latter. Viewed abstractly, the infrastructure required by Aesop environments is hardly novel. Indeed, it is now commonplace to construct environments in this fashion, as open, loosely-integrated collections of tools accessing shared data <ref> [T + 88, Bam90] </ref>. Moreover, graphical editors are common components of drawing packages, case tools and other user interfaces. We were optimistic, therefore, that it would be possible to obtain most of the infrastructure needed for Aesop by building on existing software.
Reference: [BO92] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Ideally one would like to be able to tinker with the architectural assumptions of a reused system by substituting different modules for the ones already there. An example of such orthogonalization can be found in recent work aimed at adopting a building-block approach to systems construction, such as <ref> [BO92, BSST93] </ref>. 3. Provide techniques for bridging mismatches. Even with good documentation and orthogonal modularization, mismatches will inevitably occur. Currently such mismatches must be dealt with by brute force: hacking low-level communication code, interposing special purpose data translators, etc.
Reference: [BP89] <author> Ted J. Biggerstaff and Alan J. Perlis. </author> <title> Software Reusability. </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Over the past decade the broad-based interest in supporting compositional approaches to software has led to considerable investment in research and development in reuse <ref> [BP89, Kru92] </ref>, industry standards for component interaction (e.g., [Cor91]), domain-specific architectures (e.g., [MG92]), toolkits (e.g., [SG86]), and many other related areas. fl This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command,USAF, and the Advanced Research Projects
Reference: [BS92] <author> Barry Boehm and William Scherlis. Megaprogram-ming. </author> <booktitle> In Proceedings of Software Technology Conference, DARPA. ARPA, </booktitle> <year> 1992. </year>
Reference-contexts: 1 Introduction Many would argue that future breakthroughs in software productivity will depend on our ability to combine existing pieces of software to produce new applications <ref> [BS92] </ref>. By constructing new systems out of reusable building blocks it should be possible to create large, high-quality software applications much more rapidly than we now do with the build-from-scratch techniques that dominate most software production.
Reference: [BSST93] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of SIGSOFT'93, </booktitle> <pages> pages 191-199, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Ideally one would like to be able to tinker with the architectural assumptions of a reused system by substituting different modules for the ones already there. An example of such orthogonalization can be found in recent work aimed at adopting a building-block approach to systems construction, such as <ref> [BO92, BSST93] </ref>. 3. Provide techniques for bridging mismatches. Even with good documentation and orthogonal modularization, mismatches will inevitably occur. Currently such mismatches must be dealt with by brute force: hacking low-level communication code, interposing special purpose data translators, etc.
Reference: [Cor91] <editor> The Common Object Request Broker: </editor> <title> Architecture and specification. OMG Document Number 91.12.1, </title> <month> December </month> <year> 1991. </year> <note> Revision 1.1 (Draft 10). </note>
Reference-contexts: Over the past decade the broad-based interest in supporting compositional approaches to software has led to considerable investment in research and development in reuse [BP89, Kru92], industry standards for component interaction (e.g., <ref> [Cor91] </ref>), domain-specific architectures (e.g., [MG92]), toolkits (e.g., [SG86]), and many other related areas. fl This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command,USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330, and by
Reference: [Dra87] <author> R. R. Draves. </author> <title> MIG the MACH interface generator, </title> <month> August </month> <year> 1987. </year> <title> Comment 1 by schlenk, Sat Jul 2 15:08:47 1988 MIG seem very similiar to the SUN rpcgen facility. Parameters are described in a formal language and compiled into stubs. </title>
Reference-contexts: a UI toolkit, together with Unidraw, a reusable frame work for creating drawing editors [LVC89, VL90]. * an event-based tool integration mechanism: Softbench, a commercial event-broadcast mechanism [Ger89]. * a RPC mechanism: Mach RPC Interface Generator (MIG), an RPC stub generator that was well targeted to our host operating system <ref> [Dra87] </ref>. All we had to do was put the subsystems together, a task considerably simplified by the fact they were all written in either C++ or C, had all been used in many projects, and we had source code for all of the parts. A piece of cake? Unfortunately, no.
Reference: [GAO94] <author> David Garlan, Robert Allen, and John Ockerbloom. </author> <title> Exploiting style in architectural design environments. </title> <booktitle> In Proceedings of SIGSOFT'94: Foundations of Software Engineering. </booktitle> <publisher> ACM Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: A complete description of Aesop is beyond the scope of this paper. Here we describe just enough to motivate the problems of system composition that we encountered. See <ref> [GAO94] </ref> for more details on Aesop itself. 2.1 Aesop For the past five years, the ABLE Project at Carnegie Mellon University has been carrying out research aimed at developing a sound engineering discipline of software architecture. <p> Architectural styles can be exploited, for example, by simplified analysis of critical system properties [JC94], by concise, understandable system design notations [MG92], and by tools to aid in the design and implementation of complete systems <ref> [GAO94] </ref>. The Aesop System [GAO94] is our implementation platform for experimenting with style-oriented architectural development environments. Aesop is, in fact, a kind of environment generator: given a description of an architectural style, Aesop produces an environment tailored to that style. <p> Architectural styles can be exploited, for example, by simplified analysis of critical system properties [JC94], by concise, understandable system design notations [MG92], and by tools to aid in the design and implementation of complete systems <ref> [GAO94] </ref>. The Aesop System [GAO94] is our implementation platform for experimenting with style-oriented architectural development environments. Aesop is, in fact, a kind of environment generator: given a description of an architectural style, Aesop produces an environment tailored to that style. <p> For example, OBST provided an extensive library of standard object classes to make general purpose programming easier. However, we only needed a small number of these classes, since we have a constrained, special-purpose, data model. (See <ref> [GAO94] </ref> for a detailed description of that model.) Additionally, some of the packages made assumptions about the kind of components that would be exist in the final system, and therefore used infrastructure that did not match our needs. <p> We need to find ways codify and disseminate principles and rules for composition of software. Progress towards this goal can be seen in the development of handbooks for reuse of design patterns [GHJV94], architectural design environments <ref> [GAO94] </ref>, and design tools for certain application domains [Lan90]. Acknowledgements Aesop embodies many ideas from collaborative work with fellow researchers. In particular, our work has been strongly influenced by Daniel Jackson, Mary Shaw, and Jeannette Wing, whom we gratefully acknowledge.
Reference: [Ger89] <author> Colin Gerety. </author> <title> HP Softbench: A new generation of software development tools. </title> <type> Technical Report SESD-89-25, </type> <institution> Hewlett-Packard Software Engineering Systems Division, Fort Collins, Colorado, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: These were: * an object-oriented database: OBST, a public domain OODB. * a toolkit for constructing graphical user interfaces: InterViews, a UI toolkit, together with Unidraw, a reusable frame work for creating drawing editors [LVC89, VL90]. * an event-based tool integration mechanism: Softbench, a commercial event-broadcast mechanism <ref> [Ger89] </ref>. * a RPC mechanism: Mach RPC Interface Generator (MIG), an RPC stub generator that was well targeted to our host operating system [Dra87].
Reference: [GHJV94] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We need to find ways codify and disseminate principles and rules for composition of software. Progress towards this goal can be seen in the development of handbooks for reuse of design patterns <ref> [GHJV94] </ref>, architectural design environments [GAO94], and design tools for certain application domains [Lan90]. Acknowledgements Aesop embodies many ideas from collaborative work with fellow researchers. In particular, our work has been strongly influenced by Daniel Jackson, Mary Shaw, and Jeannette Wing, whom we gratefully acknowledge.
Reference: [GS93] <author> David Garlan and Mary Shaw. </author> <title> An introduction to software architecture. </title> <editor> In V. Ambriola and G. Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge 6 Engineering, </booktitle> <pages> pages 1-39, </pages> <address> Singapore, </address> <year> 1993. </year> <title> World Sci--entific Publishing Company. </title> <note> Also appears as SCS and SEI technical reports: CMU-CS-94-166, CMU/SEI-94-TR-21, ESC-TR-94-021. </note>
Reference-contexts: To expose the nature of these mismatched assumptions, it is helpful to view the problem from an architectural perspective. Through that lens a system is viewed abstractly as a configuration of components and connectors <ref> [GS93, PW92] </ref>. The components are the primary computational and storage entities of the system: tools, databases, filters, servers, etc. The connectors determine the interactions between the components: client-server protocols, pipes, RPC links, etc.
Reference: [IW95] <author> Paola Inverardi and Alex Wolf. </author> <title> Formal specification and analysis of software architectures using the chemical, abstract machine model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> 1995. To appear. </note>
Reference-contexts: The connectors determine the interactions between the components: client-server protocols, pipes, RPC links, etc. These abstractions are typically expressed informally as box and line drawings, although recently formal notations for architectural description have begun to emerge <ref> [LAK + 95, SDK + 95, AG94, IW95] </ref>. Aesop-generated environment. At this level of abstraction the main components are a collection of tools and the architectural design manager (which consists primarily of a persistent object base). The main connectors are the RPC and event-broadcast mechanism communication links.
Reference: [JC94] <author> G.R. Ribeiro Justo and P.R. Freire Cunha. </author> <title> Deadlock-free configuration programming. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: An architectural style is a recurring pattern of system organization that provides an abstract framework for some family of applications. Architectural styles can be exploited, for example, by simplified analysis of critical system properties <ref> [JC94] </ref>, by concise, understandable system design notations [MG92], and by tools to aid in the design and implementation of complete systems [GAO94]. The Aesop System [GAO94] is our implementation platform for experimenting with style-oriented architectural development environments.
Reference: [Kru92] <author> Charles W. Krueger. </author> <title> Software reuse. </title> <journal> Computing Surveys, </journal> <volume> 24(2) </volume> <pages> 131-183, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Over the past decade the broad-based interest in supporting compositional approaches to software has led to considerable investment in research and development in reuse <ref> [BP89, Kru92] </ref>, industry standards for component interaction (e.g., [Cor91]), domain-specific architectures (e.g., [MG92]), toolkits (e.g., [SG86]), and many other related areas. fl This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command,USAF, and the Advanced Research Projects
Reference: [LAK + 95] <author> David C Luckham, Lary M. Augustin, John J. Kenney, James Veera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> 1995. To appear. </note>
Reference-contexts: The connectors determine the interactions between the components: client-server protocols, pipes, RPC links, etc. These abstractions are typically expressed informally as box and line drawings, although recently formal notations for architectural description have begun to emerge <ref> [LAK + 95, SDK + 95, AG94, IW95] </ref>. Aesop-generated environment. At this level of abstraction the main components are a collection of tools and the architectural design manager (which consists primarily of a persistent object base). The main connectors are the RPC and event-broadcast mechanism communication links. <p> While documenting assumptions will not make mismatches disappear, at least it will be possible to detect problems early on. Some initial steps towards this goal can be seen in recent work on archi tecture description languages <ref> [AG94, LAK + 95, SDK + 95] </ref>. 2. Construct large pieces of software using orthogonal sub-components. While most large reusable subsystems are themselves constructed out of smaller sub-components, it is rare that one can separate the pieces or change the way in which those sub-components are combined.
Reference: [Lan90] <author> Thomas G. Lane. </author> <title> A design space and design rules for user interface software architecture. </title> <type> Technical Report CMU/SEI-90-TR-22 ESD-90-TR-223, </type> <institution> Carnegie Mel-lon University, Software Engineering Institute, </institution> <month> Novem-ber </month> <year> 1990. </year>
Reference-contexts: We need to find ways codify and disseminate principles and rules for composition of software. Progress towards this goal can be seen in the development of handbooks for reuse of design patterns [GHJV94], architectural design environments [GAO94], and design tools for certain application domains <ref> [Lan90] </ref>. Acknowledgements Aesop embodies many ideas from collaborative work with fellow researchers. In particular, our work has been strongly influenced by Daniel Jackson, Mary Shaw, and Jeannette Wing, whom we gratefully acknowledge.
Reference: [LVC89] <author> Mark A. Linton, John M. Vlissides, and Paul R. Calder. </author> <title> Compusing user interfaces with interviews. </title> <journal> IEEE Computer, </journal> <volume> 22(2), </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: These were: * an object-oriented database: OBST, a public domain OODB. * a toolkit for constructing graphical user interfaces: InterViews, a UI toolkit, together with Unidraw, a reusable frame work for creating drawing editors <ref> [LVC89, VL90] </ref>. * an event-based tool integration mechanism: Softbench, a commercial event-broadcast mechanism [Ger89]. * a RPC mechanism: Mach RPC Interface Generator (MIG), an RPC stub generator that was well targeted to our host operating system [Dra87].
Reference: [MG92] <author> Erik Mettala and Marc H. Graham. </author> <title> The domain-specific software architecture program. </title> <type> Technical Report CMU/SEI-92-SR-9, </type> <institution> Carnegie Mellon Software Engineering Institute, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Over the past decade the broad-based interest in supporting compositional approaches to software has led to considerable investment in research and development in reuse [BP89, Kru92], industry standards for component interaction (e.g., [Cor91]), domain-specific architectures (e.g., <ref> [MG92] </ref>), toolkits (e.g., [SG86]), and many other related areas. fl This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command,USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330, and by Siemens Corporate Research. <p> An architectural style is a recurring pattern of system organization that provides an abstract framework for some family of applications. Architectural styles can be exploited, for example, by simplified analysis of critical system properties [JC94], by concise, understandable system design notations <ref> [MG92] </ref>, and by tools to aid in the design and implementation of complete systems [GAO94]. The Aesop System [GAO94] is our implementation platform for experimenting with style-oriented architectural development environments.
Reference: [Par72] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: Construct large pieces of software using orthogonal sub-components. While most large reusable subsystems are themselves constructed out of smaller sub-components, it is rare that one can separate the pieces or change the way in which those sub-components are combined. As Parnas has long argued <ref> [Par72] </ref>, each module should hide certain design assumptions. Unfortunately, the architectural design assumptions of most systems are spread throughout the constituent modules. Ideally one would like to be able to tinker with the architectural assumptions of a reused system by substituting different modules for the ones already there.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the study of software architecture. </title> <journal> ACM SIG-SOFT Software Engineering Notes, </journal> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> Oc-tober </month> <year> 1992. </year>
Reference-contexts: One component of this research is the construction of tools and environments to support architectural design and analysis. The primary thrust of that development effort has been finding effective mechanisms to exploit architectural style <ref> [AAG93, PW92] </ref>. An architectural style is a recurring pattern of system organization that provides an abstract framework for some family of applications. <p> To expose the nature of these mismatched assumptions, it is helpful to view the problem from an architectural perspective. Through that lens a system is viewed abstractly as a configuration of components and connectors <ref> [GS93, PW92] </ref>. The components are the primary computational and storage entities of the system: tools, databases, filters, servers, etc. The connectors determine the interactions between the components: client-server protocols, pipes, RPC links, etc.
Reference: [Rei90] <author> Steven P. Reiss. </author> <title> Connecting tools using message passing in the field program development environment. </title> <journal> IEEE Software, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: The tools run as separate processes and access the database through an RPC mechanism that allows them to make method calls to the database. Additionally, the system includes a tool integration mechanism based on event broadcast <ref> [Rei90] </ref>. This allows tools to register for changes to database objects and to announce significant events to other tools.
Reference: [SDK + 95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Ze-lesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> 1995. To appear. </note>
Reference-contexts: The connectors determine the interactions between the components: client-server protocols, pipes, RPC links, etc. These abstractions are typically expressed informally as box and line drawings, although recently formal notations for architectural description have begun to emerge <ref> [LAK + 95, SDK + 95, AG94, IW95] </ref>. Aesop-generated environment. At this level of abstraction the main components are a collection of tools and the architectural design manager (which consists primarily of a persistent object base). The main connectors are the RPC and event-broadcast mechanism communication links. <p> While documenting assumptions will not make mismatches disappear, at least it will be possible to detect problems early on. Some initial steps towards this goal can be seen in recent work on archi tecture description languages <ref> [AG94, LAK + 95, SDK + 95] </ref>. 2. Construct large pieces of software using orthogonal sub-components. While most large reusable subsystems are themselves constructed out of smaller sub-components, it is rare that one can separate the pieces or change the way in which those sub-components are combined.
Reference: [SG86] <author> Robert W. Scheifler and Jim Gettys. </author> <title> The X window system. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2) </volume> <pages> 79-109, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Over the past decade the broad-based interest in supporting compositional approaches to software has led to considerable investment in research and development in reuse [BP89, Kru92], industry standards for component interaction (e.g., [Cor91]), domain-specific architectures (e.g., [MG92]), toolkits (e.g., <ref> [SG86] </ref>), and many other related areas. fl This research was sponsored by the National Science Foundation under Grant Number CCR-9357792, by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command,USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330, and by Siemens Corporate Research.
Reference: [T + 88] <editor> Richard N. Taylor et al. </editor> <booktitle> Foundations for the Arcadia environment architecture. In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year> <note> Published as SIGPLAN NOTICES, 24(2). </note>
Reference-contexts: Here we focus on the latter. Viewed abstractly, the infrastructure required by Aesop environments is hardly novel. Indeed, it is now commonplace to construct environments in this fashion, as open, loosely-integrated collections of tools accessing shared data <ref> [T + 88, Bam90] </ref>. Moreover, graphical editors are common components of drawing packages, case tools and other user interfaces. We were optimistic, therefore, that it would be possible to obtain most of the infrastructure needed for Aesop by building on existing software.
Reference: [VL90] <author> John M. Vlissides and Mark A. Linton. Unidraw: </author> <title> A framework for building domain-specific graphical editors. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(3) </volume> <pages> 237-268, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: These were: * an object-oriented database: OBST, a public domain OODB. * a toolkit for constructing graphical user interfaces: InterViews, a UI toolkit, together with Unidraw, a reusable frame work for creating drawing editors <ref> [LVC89, VL90] </ref>. * an event-based tool integration mechanism: Softbench, a commercial event-broadcast mechanism [Ger89]. * a RPC mechanism: Mach RPC Interface Generator (MIG), an RPC stub generator that was well targeted to our host operating system [Dra87].
Reference: [YS94] <author> Daniel M. Yellin and Robert E. Strom. </author> <title> Interfaces, protocols, and the semi-automatic construction of software adaptors. </title> <booktitle> Proceedings of OOPSLA'94, </booktitle> <month> October </month> <year> 1994. </year> <month> 7 </month>
Reference-contexts: At the very least it would be desirable to have a cookbook of standard techniques. Better still would be tools to aid with wrapping, data translation, etc. Recent research addressing this issue includes attempts to automate the use of mediating protocols and wrapper construction <ref> [YS94] </ref>. 4. Develop sources of architectural design guidance. Developing good intuitions about what kinds of architectural components work well together is not easy. Currently it is done by trial and error, and it takes skilled designers many years to acquire expertise at putting systems together from parts.
References-found: 28

