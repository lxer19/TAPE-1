URL: http://ftp.cs.indiana.edu/pub/stoller/CAV98.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: fstoller,liug@cs.indiana.edu.  
Title: Efficient Symbolic Detection of Global Properties in Distributed Systems  
Author: Scott D. Stoller and Yanhong A. Liu 
Address: Bloomington, IN 47405, USA  
Affiliation: Computer Science Dept., Indiana University,  
Abstract: A new approach is presented for detecting whether a computation of an asynchronous distributed system satisfies Poss (read "possibly "), meaning the system could have passed through a global state satisfying property . Previous general-purpose algorithms for this problem explicitly enumerate the set of global states through which the system could have passed during the computation. The new approach is to represent this set symbolically, in particular, using ordered binary decision diagrams. We describe an implementation of this approach, suitable for off-line detection of properties, and compare its performance to the enumeration-based algorithm of Alagar & Venkatesan. In typical cases, the new algorithm is significantly faster. We have measured over 400-fold speedup in some cases. 
Abstract-found: 1
Intro-found: 1
Reference: [AV97] <author> Sridhar Alagar and S. Venkatesan. </author> <title> Techniques to tackle state explosion in global predicate detection. </title> <note> Submitted to IEEE Transactions on Software Engineering, 1997. Preliminary version appeared in International Conference on Parallel and Distributed Systems (ICPDS'94), pp. 412-417, </note> <year> 1994. </year>
Reference-contexts: The approach can also be applied to on-line detection. Section 2 provides some background. Section 3 describes our detection algorithm. Section 4 gives performance results from using the new algorithm and (for comparison) an enumeration-based algorithm <ref> [AV97] </ref> to detect violations of invariants in a coherence protocol and a spanning-tree algorithm. For both examples, when the invariant is not violated, the new method is faster by a factor that increases exponentially with the number of processes in the system. <p> Procedure BDD-detection0 can be optimized by distributing the conjunctions over the disjunction, yielding procedure BDD-detection in Figure 1. By testing each disjunct of separately, BDD-detection avoids constructing the potentially large intermediate result . 4 Examples We compare the performance of BDD-detection to Alagar & Venkatesan's offline detection algorithm <ref> [AV97] </ref>, which (to our knowledge) is the most time and space-efficient previously known general-purpose algorithm for detecting Poss. Their algorithm, which we refer to as DFS-detection, performs a depth-first-search search of the lattice of CGSs.
Reference: [BDD] <institution> The BDD Library (ver. </institution> <address> 1.0). http://www.cs.cmu.edu/ modelcheck/bdd.html. </address>
Reference-contexts: All measurements were made on a SGI Power Challenge with ten 75 MHz MIPS R8000 CPUs and 2GB RAM. The algorithms we measured are sequential, so the use of a parallel machine was irrelevant. We use the BDD library developed by E. M. Clarke's group at CMU <ref> [BDD] </ref>. The reported running times are "user times" obtained from the UNIX time command; thus, they reflect the CPU time consumed. For BDD-detection, the variable ordering can affect performance. <p> The memory usage of BDD-detection can be greatly reduced by variable reordering, as discussed next. 4.6 Effect of Variable Reordering We also ran BDD-detection using the two variable-reordering methods, called sift and window3, provided by the BDD package <ref> [BDD] </ref>. Variables were reordered once, immediately after construction of globalState c (x; idx ) ^ bdd consis c (idx ). According to [BDD], the sift method "generally achieves greater size reductions, but is slower" than window3. <p> variable reordering, as discussed next. 4.6 Effect of Variable Reordering We also ran BDD-detection using the two variable-reordering methods, called sift and window3, provided by the BDD package <ref> [BDD] </ref>. Variables were reordered once, immediately after construction of globalState c (x; idx ) ^ bdd consis c (idx ). According to [BDD], the sift method "generally achieves greater size reductions, but is slower" than window3.
Reference: [Bry92] <author> R.E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3), </volume> <year> 1992. </year>
Reference-contexts: 0 ) _ (idx 1 = 1 ^ 1 idx 0 )) ^ ((idx 0 = 0 ^ 0 idx 1 ) _ (idx 0 = 1 ^ 0 idx 1 )) 3.1 Implementation and an Optimization We represent the formula defined by (4) using ordered binary decision diagrams (BDDs) <ref> [Bry92] </ref>. Let true bdd and false bdd denote the BDDs representing true and false, respectively. Let ^ bdd denote conjunction of BDDs. Let a formula with an overline denote a function that returns the BDD representation of that formula.
Reference: [C + 92] <author> E. M. Clarke et al. </author> <title> Automatic verification of sequential circuit design. </title> <editor> In C. A. R. Hoare and M. J. C. Gordon, editors, </editor> <title> Mechanized Reasoning and Hardware Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Further work is needed to characterize the class of examples for which the optimization in BDD-detection is effective. 5 Comparison with Symbolic Model Checking for CTL Detection of Poss can be reduced to CTL model checking <ref> [C + 92] </ref>: a computation is encoded as a transition system whose runs are the histories consistent with the computation, and a CTL model checker is used to check whether that transition system satisfies the CTL formula 9 .
Reference: [CA96] <author> James M. Crawford and Larry D. Auton. </author> <title> Experimental results on the crossover point in random 3-SAT. </title> <journal> Artificial Intelligence, </journal> <volume> 81(1) </volume> <pages> 31-57, </pages> <year> 1996. </year>
Reference-contexts: Directions for future work include extending our algorithm to support on-line detection, applying our symbolic approach to detection of Def , and experimenting with 2 These restricted algorithms do not apply to the examples in Section 4. the use of a satisfiability checker, such as tableau <ref> [CA96] </ref>, instead of BDDs. Our approach does not involve computation of fixed points, so the use of a canonical form, such as BDDs, is not essential. 2 Background 2.1 System Model A (distributed) system is a collection of processes connected by an asynchronous, reliable, and FIFO network.
Reference: [CM91] <author> Robert Cooper and Keith Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, 1991. Appeared as ACM SIGPLAN Notices 26(12) </booktitle> <pages> 167-174, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This leads to an obvious difficulty for detecting whether a global property (i.e., a predicate on global states) held. Cooper and Marzullo's solution to this difficulty involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely") <ref> [CM91] </ref>. These modalities are based on logical time as embodied in the happened-before relation, a partial order that reflects causal dependencies [Lam78]. A history of an asynchronous distributed system can be approximated by a computation, which comprises the local computation of each process together with the happened-before relation. <p> A computation c satisfies Def iff, in all histories consistent with c, the system passes through a global state satisfying . Cooper and Marzullo give centralized algorithms for detecting Poss and Def for an arbitrary predicate <ref> [CM91] </ref>. A stub at each process reports the local states of that process to a central monitor. The central monitor incrementally constructs a lattice whose elements correspond to CGSs of the computation. Poss and Def are evaluated by straightforward traversals of the lattice. Unfortunately, these algorithms can be expensive.
Reference: [FR94] <author> Eddy Fromentin and Michel Raynal. </author> <title> Local states in distributed computations: A few relations and formulas. </title> <journal> Operating Systems Review, </journal> <volume> 28(2), </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: Concurrency of two local states can be tested in constant time using vector timestamps by exploiting the following theorem <ref> [FR94] </ref>: for a local state s 1 of process p 1 and a local state s 2 of process p 2 , s 1 k s 2 j s 1 (vc p 1 )[p 2 ] s 2 (vc p 2 )[p 2 ] ^ s 2 (vc p 2 )[p
Reference: [FR97] <author> Eddy Fromentin and Michel Raynal. </author> <title> Inevitable global states: a concept to detect unstable properties of distributed computations in an observer independent way. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 55(3), </volume> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: This time complexity can be prohibitive, so researchers have sought faster alternatives. One approach is to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW94,TG93]. 2 Another approach is to modify some aspect of the problem|for example, detecting a different modality <ref> [FR97] </ref> or assuming that the system is partially synchronous [MN91,Sto97]. This paper presents an efficient and general approach to detecting Poss .
Reference: [GW94] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3) </volume> <pages> 299-307, </pages> <year> 1994. </year>
Reference-contexts: So, we restrict attention to consistent global states, i.e., global states through which the system might have passed during the computation. We define consistency for global states in terms of the happened-before relation on local states <ref> [GW94] </ref>. Intuitively, a local state s 1 happened-before a local state s 2 (of the same or a different process) if s 1 finished before s 2 started.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year>
Reference-contexts: Cooper and Marzullo's solution to this difficulty involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely") [CM91]. These modalities are based on logical time as embodied in the happened-before relation, a partial order that reflects causal dependencies <ref> [Lam78] </ref>. A history of an asynchronous distributed system can be approximated by a computation, which comprises the local computation of each process together with the happened-before relation.
Reference: [Lyn96] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: a factor of 7 to 10 when c j= Poss C holds, because DFS-detection halts as soon as it finds a consistent global state satisfying the predicate, and with luck, that can happen early in the search. 4.3 Spanning Tree The following algorithm constructs a spanning tree in a network <ref> [Lyn96, Section 15.3] </ref>. For convenience, we assume that process 0 always initiates the algorithm and therefore always becomes the root of the spanning tree. Process 0 initiates the algorithm by sending its level in the tree (namely, 0) to each of its neighbors in the network.
Reference: [Mat89] <author> Friedemann Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Corsnard, editor, </editor> <booktitle> Proc. International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 120-131. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: A history of an asynchronous distributed system can be approximated by a computation, which comprises the local computation of each process together with the happened-before relation. Happened-before is useful for detection algorithms because, using vector clocks <ref> [Mat89] </ref>, it can be determined by processes in the system. 1 An asynchronous distributed system is characterized by lack of synchronized clocks and lack of bounds on processor speed and network latency. Happened-before is not a total order, so it does not uniquely determine the history. <p> A global state is consistent iff its constituent local states are pairwise concurrent. Vector timestamps are useful because they capture the happened-before relation <ref> [Mat89] </ref>. Define a partial order OE on vector timestamps by: v 1 OE v 2 iff (8p 2 PID : v 1 [p] v 2 [p]).
Reference: [MN91] <author> Keith Marzullo and Gil Neiger. </author> <title> Detection of global state predicates. </title> <booktitle> In Proc. 5th Int'l. Workshop on Distributed Algorithms (WDAG '91), volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [SMV] <author> SMV. </author> <note> http://www.cs.cmu.edu/ modelcheck/smv.html. </note>
Reference-contexts: With this encoding, an BDD-based model checker, such as SMV <ref> [SMV] </ref>, would represent sets of CGSs as BDDs, as we do. However, that approach could still differ appreciably in performance from our algorithm, because different intermediate BDDs would be constructed. For example, with our method, the iterative calculations in the construction of globalState and consis are independent of .
Reference: [Sto97] <author> Scott D. Stoller. </author> <title> Detecting global predicates in distributed systems with clocks. </title> <editor> In Marios Mavronikolas, editor, </editor> <booktitle> Proc. 11th International Workshop on Distributed Algorithms (WDAG '97), volume 1320 of Lecture Notes in Computer Science, </booktitle> <pages> pages 185-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference: [TG93] <author> Alexander I. Tomlinson and Vijay K. Garg. </author> <title> Detecting relational global predicates in distributed systems. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, 1993. ACM SIGPLAN Notices 28(12), </booktitle> <month> December </month> <year> 1993. </year>
References-found: 16

