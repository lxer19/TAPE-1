URL: http://ai.fri.uni-lj.si/papers/robnik96-tr-mrbfs.ps
Refering-URL: http://ai.fri.uni-lj.si/papers/index.html
Root-URL: 
Title: Effective use of memory in linear space best first search  
Author: Marko Robnik- Sikonja 
Abstract: Classical best-first search algorithms like A* require space exponential in length of the solution path. To overcome this limitation algorithms like IDA* and RBFS regenerate parts of problem space trading space for time. These algorithms are probably too modest using only a tiny amount of memory today's computers can offer. We present a novel, RBFS based algorithm which uses all available memory. This is achieved by keeping the generated nodes in memory and pruning some of them away when the memory runs out. We describe three pruning methods and experiments confirming the advantage of our approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ivan Bratko, </author> <title> Prolog Programming for Artificial Intelligence, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: then Child [i].Fb := max (Node.Fb, Child [i].f) else Child [i].Fb:=Child [i].f ; sort children in ascending order of Fb while Child <ref> [1] </ref>.Fb B and Child [1].Fb &lt; 1 do - if Node.noChildren = 1 then FbSibling := 1 else FbSibling := Child [2].Fb ; Child [1].Fb := ?RBFS (Child [1], min (B, FbSibling)); insert Child [1] into children table in increasing order of Fb N POT.insert (Child [1]); - return Child [1].Fb; - where lines without marks belong to original algorithm, additional lines marked with S show changes needed for "all" and "subtree" strategies, and additional lines marked with N <p> Child [i].f) else Child [i].Fb:=Child [i].f ; sort children in ascending order of Fb while Child <ref> [1] </ref>.Fb B and Child [1].Fb &lt; 1 do - if Node.noChildren = 1 then FbSibling := 1 else FbSibling := Child [2].Fb ; Child [1].Fb := ?RBFS (Child [1], min (B, FbSibling)); insert Child [1] into children table in increasing order of Fb N POT.insert (Child [1]); - return Child [1].Fb; - where lines without marks belong to original algorithm, additional lines marked with S show changes needed for "all" and "subtree" strategies, and additional lines marked with N show changes needed for "node" strategy. <p> of Fb while Child <ref> [1] </ref>.Fb B and Child [1].Fb &lt; 1 do - if Node.noChildren = 1 then FbSibling := 1 else FbSibling := Child [2].Fb ; Child [1].Fb := ?RBFS (Child [1], min (B, FbSibling)); insert Child [1] into children table in increasing order of Fb N POT.insert (Child [1]); - return Child [1].Fb; - where lines without marks belong to original algorithm, additional lines marked with S show changes needed for "all" and "subtree" strategies, and additional lines marked with N show changes needed for "node" strategy. 3.1 Prune all needed to adopt pruning. "Prune all" strategy contains non-marked <p> Both algorithms, like A*, maintain OPEN and CLOSED lists, while (M)RBFS uses tree, which seems to have smaller overhead at updating nodes. Another overhead of MA* and SMA* is their demand for generation of a single successor. Bratko's best-first search <ref> [1] </ref> searches in the same way as MRBFS and fills the memory with nodes, but it does not prune. Kaindl et al. [4] propose the use of memory in bidirectional search. Because of its ability to cache the best nodes, MRBFS seems to fit nicely into their scheme.
Reference: [2] <author> P.P Chakrabarti, S. Ghose, A. Acharya, and S.C. de Sarkar, </author> <title> `Heuristic search in restricted memory', </title> <journal> Artificial Intelligence, </journal> <volume> 41(2), </volume> <pages> 197-221, </pages> <year> (1989). </year>
Reference-contexts: The MREC algorithm [9] stores nodes in memory until it is almost full, then performs IDA* starting from stored nodes. MREC searches like A* while MRBFS has the properties of RBFS and also prunes the memory thereby reducing the probability for regeneration. MA* <ref> [2] </ref> and SMA* [8] dynamically store the best generated nodes so far and prune away worst nodes when the memory runs out. Both algorithms, like A*, maintain OPEN and CLOSED lists, while (M)RBFS uses tree, which seems to have smaller overhead at updating nodes.
Reference: [3] <author> P.E. Hart, N.J. Nilsson, and B. Raphael, </author> <title> `A formal basis for the heuristic determination of minimum cost paths', </title> <journal> IEEE Transactions on Systems, Science and Cybernetics, </journal> <volume> 4(2), </volume> <pages> 100-107, </pages> <year> (1968). </year>
Reference-contexts: We will assume an admissible heuristic function h (n), which never overestimates the actual cost of the path. Presented algorithms are guaranteed to find an optimal solution in this case <ref> [3] </ref>. Well known disadvantage of classical best-first search algorithms such as A* [3], is their exponential memory requirement which often prevents them from finding optimal solutions to many problems. <p> We will assume an admissible heuristic function h (n), which never overestimates the actual cost of the path. Presented algorithms are guaranteed to find an optimal solution in this case <ref> [3] </ref>. Well known disadvantage of classical best-first search algorithms such as A* [3], is their exponential memory requirement which often prevents them from finding optimal solutions to many problems.
Reference: [4] <author> Hermann Keindl, Gerhard Kainz, Angelika Leeb, and Harald Smetana, </author> <title> `How to use limited memory in heuristic search', </title> <booktitle> in Proceedings IJCAI-95, </booktitle> <editor> ed., Cris S. </editor> <booktitle> Mellish, </booktitle> <pages> pp. 236-242. </pages> <publisher> Mor-gan Kaufmann, </publisher> <year> (1995). </year>
Reference-contexts: Another overhead of MA* and SMA* is their demand for generation of a single successor. Bratko's best-first search [1] searches in the same way as MRBFS and fills the memory with nodes, but it does not prune. Kaindl et al. <ref> [4] </ref> propose the use of memory in bidirectional search. Because of its ability to cache the best nodes, MRBFS seems to fit nicely into their scheme.
Reference: [5] <author> Hermann Keindl, Angelika Leeb, and Harald Smetana, </author> <title> `Improvements on linear-space search algorithms', </title> <booktitle> in Proceedings ECAI-94, </booktitle> <pages> pp. 155-159, </pages> <year> (1994). </year>
Reference-contexts: Kaindl et al. [4] propose the use of memory in bidirectional search. Because of its ability to cache the best nodes, MRBFS seems to fit nicely into their scheme. MRBFS would also fit into a number of suboptimal search schemes eg. <ref> [5] </ref>. 6 Conclusion Memory aware variants of RBFS algorithm keep all the nice properties of the original, but have additional power when there is enough memory available.
Reference: [6] <author> Richard E. Korf, </author> <title> `Depth-first iterative deepening: an optimal admissible tree search', </title> <journal> Artificial Intelligence, </journal> <volume> 27, </volume> <pages> 97-109, </pages> <year> (1985). </year>
Reference-contexts: Additional secondary storage does not help as the nodes are accessed randomly. IDA* (Iterative Deepening A*) <ref> [6] </ref> was the first algorithm which addressed the memory complexity of best-first search. It requires only linear space: O (d). IDA* iteratively deepens search horizon until it reaches an optimal solution. In one iteration it explores nodes in depth-first order up to the current depth (cost).
Reference: [7] <author> Richard E. Korf, </author> <title> `Linear-space best-first search', </title> <journal> Artificial Intelligence, </journal> <volume> 62, </volume> <pages> 41-78, </pages> <year> (1993). </year>
Reference-contexts: This is how IDA* trades space for time. 1 University of Ljubljana, Faculty of Electrical Engineering and Computer Science, Trzaska 25, 61001 Ljubljana, Slovenia, tel.: +386-61-1768386, fax: +386-61-1264630, e-mail: Marko.Robnik@fer.uni-lj.si Korf's RBFS (recursive best first search) algorithm <ref> [7] </ref> is further improvement of IDA*, using slightly more memory (in order of O (bd)) but generating asymptotically less nodes and having also other desirable features regarding nonmonotonic cost function. RBFS keeps essential information of already generated problem space and can regenerate nodes more cleverly. <p> We first present the essentials about RBFS, Section 3 contains description of the improvements and Section 4 deals with the experiments. The last two sections discuss related work and give conclusions. 2 RBFS Our work extends Korf's RBFS (Recursive Best First Search) algorithm <ref> [7] </ref>, therefore we briefly present the way it works. RBFS explores the search space as it were a tree. An example of the search space with cost equal to depth is in Figure 1. to expand and an upper bound on the cost of the node's sub-tree. <p> The proof for it is basically the same as for the original RBFS which can be found in <ref> [7] </ref>. In general the variants do not find the same solution. The reason is that different nodes are stored in the memory. The stored nodes guide the search in the direction of the best frontier node, while regeneration goes in the depth first manner. Section Title 3 M. <p> A large number of distinct estimations gave this approach a chance to differentiate among the paths and cache the most promising. Even for small amounts of memory this approach saved several orders of magnitude in both, the number of generated nodes and time. scales! 5 Related work Korf's RBFS <ref> [7] </ref> inspired us for this study. It also gives some proofs and explanations which we only briefly mention here. The MREC algorithm [9] stores nodes in memory until it is almost full, then performs IDA* starting from stored nodes.
Reference: [8] <author> Stuart Russel, </author> <title> `Efficient memory-bounded search methods', </title> <booktitle> in Proceedings ECAI-92, </booktitle> <editor> ed., B. </editor> <publisher> Neumann, </publisher> <pages> pp. 1-5. </pages> <publisher> John Wiley & Sons, </publisher> <year> (1992). </year>
Reference-contexts: The MREC algorithm [9] stores nodes in memory until it is almost full, then performs IDA* starting from stored nodes. MREC searches like A* while MRBFS has the properties of RBFS and also prunes the memory thereby reducing the probability for regeneration. MA* [2] and SMA* <ref> [8] </ref> dynamically store the best generated nodes so far and prune away worst nodes when the memory runs out. Both algorithms, like A*, maintain OPEN and CLOSED lists, while (M)RBFS uses tree, which seems to have smaller overhead at updating nodes.
Reference: [9] <author> Anup K. Sen and A. Bagchi, </author> <title> `Fast recursive formulations for best-first search that allows controlled use of memory', </title> <booktitle> in Proceedings IJCAI-89, </booktitle> <pages> pp. 297-302, </pages> <year> (1989). </year> <note> Section Title 5 M. Robnik- Sikonja </note>
Reference-contexts: It also gives some proofs and explanations which we only briefly mention here. The MREC algorithm <ref> [9] </ref> stores nodes in memory until it is almost full, then performs IDA* starting from stored nodes. MREC searches like A* while MRBFS has the properties of RBFS and also prunes the memory thereby reducing the probability for regeneration.
References-found: 9

