URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/agsim.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/publications.html
Root-URL: http://www.cs.berkeley.edu
Title: An Assume-Guarantee Rule For Checking Simulation  
Author: T.A. Henzinger S. Qadeer S.K. Rajamani S. Ta~sran 
Address: Berkeley, CA 94720  
Affiliation: EECS Department, University of California at  
Abstract: The simulation preorder on state transition systems is widely accepted as a useful notion of refinement, both in its own right and as an efficiently checkable sufficient condition for trace containment. For composite systems, due to the exponential explosion of the state space, there is a need for decomposing a simulation check of the form P s Q into simpler simulation checks on the components of P and Q. We present an assume-guarantee rule that enables such a decomposition. To the best of our knowledge, this is the first assume-guarantee rule that applies to a refinement relation different from trace containment. Our rule is circular, and its soundness proof requires induction on trace-trees. The proof is constructive: given simulation relations that witness the simulation preorder between components, we provide a procedure for constructing a witness relation for P s Q. We also extend our assume-guarantee rule to account for fairness assumptions on transition systems.
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 207-218. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: Under certain modeling assumptions (namely, non-blocking and finite nondeterminism), the compositional principle can be strengthened to an assume-guarantee principle <ref> [Sta85, CLM89, GL94, AL95, AH96, McM97] </ref>: in order to check P Q, it 2 r 0 msg S 0 R 0 2 :ack 0 s 0 r 0 s 0 msg suffices to check both P 1 kQ 2 Q 1 and Q 1 kP 2 Q 2 . <p> For simplicity we use Moore machines to model systems. The results apply to other non-blocking, finitely non-deterministic models such as Reactive Modules <ref> [AH96] </ref>. Section 2 defines Moore machines and establishes the connection be tween trace-tree containment and simulation. In Section 3 we prove the validity of the assume-guarantee rule for the simulation preorder and describe how the com pound witness simulation relation is constructed from the witnesses for the compo nents. <p> We now present the assume-guarantee proof rule for fair simulation. The same rule was proved for fair trace-trace containment in <ref> [AH96] </ref>.
Reference: [AL88] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 165-175. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: Such witness relations are widely used in verification tools, under various names like homomorphisms [Kur94] and refinement mappings <ref> [AL88, Lyn96] </ref>. Second, even if no witness is available, the existence of a simulation can be checked in polynomial time (the check is quadratic in the number of states of P and Q).
Reference: [AL95] <author> M. Abadi and L. Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 507-534, </pages> <year> 1995. </year>
Reference-contexts: Under certain modeling assumptions (namely, non-blocking and finite nondeterminism), the compositional principle can be strengthened to an assume-guarantee principle <ref> [Sta85, CLM89, GL94, AL95, AH96, McM97] </ref>: in order to check P Q, it 2 r 0 msg S 0 R 0 2 :ack 0 s 0 r 0 s 0 msg suffices to check both P 1 kQ 2 Q 1 and Q 1 kP 2 Q 2 .
Reference: [CLM89] <author> E.M. Clarke, D.E. Long, and K.L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proceedings of the 4th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 353-362. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: Under certain modeling assumptions (namely, non-blocking and finite nondeterminism), the compositional principle can be strengthened to an assume-guarantee principle <ref> [Sta85, CLM89, GL94, AL95, AH96, McM97] </ref>: in order to check P Q, it 2 r 0 msg S 0 R 0 2 :ack 0 s 0 r 0 s 0 msg suffices to check both P 1 kQ 2 Q 1 and Q 1 kP 2 Q 2 .
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Under certain modeling assumptions (namely, non-blocking and finite nondeterminism), the compositional principle can be strengthened to an assume-guarantee principle <ref> [Sta85, CLM89, GL94, AL95, AH96, McM97] </ref>: in order to check P Q, it 2 r 0 msg S 0 R 0 2 :ack 0 s 0 r 0 s 0 msg suffices to check both P 1 kQ 2 Q 1 and Q 1 kP 2 Q 2 .
Reference: [HKR97] <author> T.A. Henzinger, O. Kupferman, and S. K. Rajamani. </author> <title> Fair simulation. </title> <booktitle> In CONCUR 97: Theories of Concurrency, Lecture Notes in Computer Science 1243, </booktitle> <pages> pages 273-287. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1997. </year>
Reference-contexts: We say that Q fair-tree-contains P if (1) Q is refinable by P, and (2) for every fair trace-tree T of P its projection [T ] Q is a fair-trace-tree of Q. Fair Simulation. We will use the generalization of simulation to account for fairness, as given in <ref> [HKR97] </ref>. Consider Moore machines P and Q such that Q is refinable by P . A strategy t of Q with respect to P is a partial function from P fi Q to S Q . <p> Proposition 4 Consider any two fair Moore machines P = hP; F P i and Q = hQ; F Q i. If P F s Q then P s Q. Analogous to the equivalence between simulation and tree-containment, fair simulation can be proved to be equivalent to fair tree-containment <ref> [HKR97] </ref>. Proposition 5 Consider any two fair Moore machines P and Q.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer-aided Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: The converse is not true; that is, simulation is a stronger requirement than trace containment. However, it has been said that trace containment without simulation is more often than not due to coincidence rather than systematic design <ref> [Kur94] </ref>. While trace containment is defined globally, for input-output sequences of arbitrary length, simulation is defined locally, by considering individual input-output pairs for all states. It is this locality in the definition of simulation that leads to significant advantages. <p> Such witness relations are widely used in verification tools, under various names like homomorphisms <ref> [Kur94] </ref> and refinement mappings [AL88, Lyn96]. Second, even if no witness is available, the existence of a simulation can be checked in polynomial time (the check is quadratic in the number of states of P and Q).
Reference: [Lyn96] <author> N. A. Lynch. </author> <title> Distributed Algorithms. </title> <address> Morgan-Kaufman, </address> <year> 1996. </year>
Reference-contexts: Such witness relations are widely used in verification tools, under various names like homomorphisms [Kur94] and refinement mappings <ref> [AL88, Lyn96] </ref>. Second, even if no witness is available, the existence of a simulation can be checked in polynomial time (the check is quadratic in the number of states of P and Q).
Reference: [McM97] <author> K.L. McMillan. </author> <title> A compositional rule for hardware design refinement. </title> <editor> In O. Grum-berg, editor, </editor> <booktitle> CAV 97: Computer Aided Verification, Lecture Notes in Computer Science 1254, </booktitle> <pages> pages 24-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Under certain modeling assumptions (namely, non-blocking and finite nondeterminism), the compositional principle can be strengthened to an assume-guarantee principle <ref> [Sta85, CLM89, GL94, AL95, AH96, McM97] </ref>: in order to check P Q, it 2 r 0 msg S 0 R 0 2 :ack 0 s 0 r 0 s 0 msg suffices to check both P 1 kQ 2 Q 1 and Q 1 kP 2 Q 2 .
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Second International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489. </pages> <publisher> The British Computer Society, </publisher> <year> 1971. </year>
Reference-contexts: This tighter relation is captured mathematically by the notion of a simulation relation. Intuitively, Q simulates P iff, starting from the initial states and continuing ad infinitum, every input-output pair of P can be matched by the same input-output pair in Q <ref> [Mil71] </ref>. Clearly, if Q simulates P , then every trace of P is also a trace of Q. The converse is not true; that is, simulation is a stronger requirement than trace containment.
Reference: [Sta85] <author> E. W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <booktitle> In Proceedings of the 5th Conference on Foundations of Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science 206, </booktitle> <pages> pages 369-391. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Under certain modeling assumptions (namely, non-blocking and finite nondeterminism), the compositional principle can be strengthened to an assume-guarantee principle <ref> [Sta85, CLM89, GL94, AL95, AH96, McM97] </ref>: in order to check P Q, it 2 r 0 msg S 0 R 0 2 :ack 0 s 0 r 0 s 0 msg suffices to check both P 1 kQ 2 Q 1 and Q 1 kP 2 Q 2 .
References-found: 11

