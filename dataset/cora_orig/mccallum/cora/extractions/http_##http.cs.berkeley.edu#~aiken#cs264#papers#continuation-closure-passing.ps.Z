URL: http://http.cs.berkeley.edu/~aiken/cs264/papers/continuation-closure-passing.ps.Z
Refering-URL: http://http.cs.berkeley.edu/~aiken/cs264/papers/node9.html
Root-URL: 
Title: Continuation-Passing, Closure-Passing Style  
Author: Andrew W. Appel* Trevor Jim 
Address: Murray Hill, NJ. Current address:  Cambridge, Mass.  
Affiliation: AT&T Bell Laboratories,  Laboratory for Computer Science, MIT,  
Note: To appear in POPL '89. Supported in part by NSF Grant DCR-8603543 and by a Digital Equipment Corp. Faculty Incentive Grant.  
Date: July 1988 Revised September 1988  
Pubnum: CS-TR-183-88  
Abstract: We implemented a continuation-passing style (CPS) code generator for ML. Our CPS language is represented as an ML datatype in which all functions are named and most kinds of ill-formed expressions are impossible. We separate the code generation into phases that rewrite this representation into ever-simpler forms. Closures are represented explicitly as records, so that closure strategies can be communicated from one phase to another. No stack is used. Our benchmark data shows that the new method is an improvement over our previous, abstract-machine based code generator. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Andrew W. Appel and David B. Mac-Queen, </author> <title> ``A Standard ML compiler,'' </title> <booktitle> in Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pp. 301-324, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: 1. Overview Standard ML of New Jersey <ref> [1] </ref> is a compiler for ML written in ML. Its first code generator, based on an abstract stack machine, produced code with acceptable but not stunning performance. <p> The phases are: 1. Lexical analysis, parsing, typechecking, producing an annotated abstract syntax tree. 2. Translation into lambda-calculus (producing a simple representation described in <ref> [1] </ref>). 3. Optimization of the lambda-calculus (present here for historical reasons; this phase duplicates some of the effort done by our CPS optimizer). 4. Conversion into continuation-passing style, producing a CPS representation described in the next section. 5. Optimization of the CPS expression. 6. <p> Therefore we compromise and leave the branches as unnamed continuation expressions instead of named continuation variables. 3. Conversion into CPS The front end of our compiler produces a lambda-calculus intermediate representation (described in <ref> [1] </ref>). This must be translated into continuation-passing style; the conversion algorithm is similar to Steele's and won't be described in detail here. The conversion process doesn't do many optimi - 4 - zations; it's simpler to do that in a separate phase. <p> The function f may have any calling sequence, and this is chosen on the first call so that countZeros won't have to shuffle any registers. As described in <ref> [1] </ref>, integers are represented with a low-order 1 bit, pointers with a low-order zero. Allocation (e.g. for the closure after L1 below) is in-line, relying on a page fault to tell it when it needs to garbage-collect; register 12 points to the next available allocable space.
Reference: 2. <author> Guy L. Steele, ``Rabbit: </author> <title> a compiler for Scheme,'' </title> <publisher> AI-TR-474, MIT, </publisher> <year> 1978. </year>
Reference-contexts: Generation of target-machine instructions Since modern garbage collectors are so cheap [9] [10] we have dispensed with the stack. This simplifies the code generator, which doesn't need to do the analysis <ref> [2] </ref> [4] [11] necessary to decide which closure records can be allocated on the stack; it also simplifies the runtime system, making it easier to add multiple threads or state-saving operators to the programming environment. Eliminating the stack is advantageous not only because it makes the compiler simpler.
Reference: 3. <author> D. Kranz, R. Kelsey, J. Rees, P. Hudak, J. Philbin, and N. Adams, </author> <title> ``ORBIT: An optimizing compiler for Scheme,'' </title> <booktitle> Proc. Sigplan '86 Symp. on Compiler Construction, vol. 21 (Sigplan Notices), </booktitle> <volume> no. 7, </volume> <pages> pp. 219-233, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Rather than hack a register allocator into the abstract stack machine, we decided to try a continuation-passing style (CPS)[2] code generator. Kranz's ORBIT compiler <ref> [3] </ref> [4] shows how CPS provides a natural context for register allocation and representation decisions. The beauty of continuation passing style is that control flow and data flow can be represented in a clean intermediate language with a known semantics, rather than being hidden inside a ``black box'' code generator.
Reference: 4. <author> David Kranz, </author> <title> ``ORBIT: An Optimizing Compiler for Scheme,'' </title> <type> PhD Thesis, </type> <institution> Yale University, </institution> <year> 1987. </year>
Reference-contexts: Rather than hack a register allocator into the abstract stack machine, we decided to try a continuation-passing style (CPS)[2] code generator. Kranz's ORBIT compiler [3] <ref> [4] </ref> shows how CPS provides a natural context for register allocation and representation decisions. The beauty of continuation passing style is that control flow and data flow can be represented in a clean intermediate language with a known semantics, rather than being hidden inside a ``black box'' code generator. <p> Generation of target-machine instructions Since modern garbage collectors are so cheap [9] [10] we have dispensed with the stack. This simplifies the code generator, which doesn't need to do the analysis [2] <ref> [4] </ref> [11] necessary to decide which closure records can be allocated on the stack; it also simplifies the runtime system, making it easier to add multiple threads or state-saving operators to the programming environment. Eliminating the stack is advantageous not only because it makes the compiler simpler. <p> CPS' Our new code generator with aggressive cross-module optimization enabled. Of course, comparisons between compilers for different programming languages may tell us more about the languages than about the compilers. The programs were: Hanoi The towers of Hanoi benchmark from Kranz's thesis <ref> [4] </ref>. Puzz A compute-bound program from Forest Baskett [4]. LenL A tail-recursive function (or, in Pas-cal, a while loop) to compute the length of a list. LenR A recursive function (not tail-recursive) to compute the length of a list. Comp A 16000-line compilation job in Standard ML. <p> Of course, comparisons between compilers for different programming languages may tell us more about the languages than about the compilers. The programs were: Hanoi The towers of Hanoi benchmark from Kranz's thesis <ref> [4] </ref>. Puzz A compute-bound program from Forest Baskett [4]. LenL A tail-recursive function (or, in Pas-cal, a while loop) to compute the length of a list. LenR A recursive function (not tail-recursive) to compute the length of a list. Comp A 16000-line compilation job in Standard ML.
Reference: 5. <author> Andrew W. Appel, Christopher W. Fraser, David R. Hanson, and Arthur H. Watson, </author> <title> ``Generating code for the Case statement,'' </title> <note> in preparation. </note>
Reference: 6. <author> V. Vyssotsky and P. Wegner, </author> <title> A graph theoretical Fortran source language analyzer, </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray - 11 - Hill, NJ, </address> <year> 1963. </year>
Reference: 7. <author> G. Cousineau, P. L. Curien, and M. Mauny, </author> <title> ``The Categorical Abstract Machine,'' </title> <booktitle> in Functional Programming Languages and Computer Architecture, </booktitle> <volume> LNCS Vol 201, </volume> <editor> ed. J. P. </editor> <booktitle> Jouannaud, </booktitle> <pages> pp. 50-64, </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: All other references to escaping functions become references to closure records. hhhhhhhhhhhhhhhhhh *Mutually-recursive functions complicate the free variable analysis, but this turns out to be a classical dataflow problem (live-variable analysis) that can be solved by classical techniques.[6] This technique has been used in the Categorical Abstract Machine <ref> [7] </ref> fun f x = in g z ...f 3...
Reference: 8. <author> Andrew W. Appel and Trevor Jim, </author> <title> ``Optimizing closure environment representations,'' </title> <type> CS-TR-168-88, </type> <institution> Princeton University, </institution> <year> 1988. </year>
Reference: 9. <author> David Ungar, </author> <title> ``Generation scavenging: a non-disruptive high performance storage reclamation algorithm,'' </title> <booktitle> SIGPLAN Notices (Proc. ACM SIGSOFT/SIGPLAN Software Eng. Symp. on Practical Software Development Environments), </booktitle> <volume> vol. 19, no. 5, </volume> <pages> pp. 157-167, </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Although this might seem expensive, profiling shows that all spill records take up only one or two percent of the total heap allocation in our Vax implementation, where n is 8. 7. Generation of target-machine instructions Since modern garbage collectors are so cheap <ref> [9] </ref> [10] we have dispensed with the stack.
Reference: 10. <author> A. W. Appel, </author> <title> ``Garbage collection can be faster than stack allocation,'' </title> <journal> Information Processing Letters, </journal> <volume> vol. 25, no. 4, </volume> <pages> pp. 275-279, </pages> <year> 1987. </year>
Reference-contexts: Although this might seem expensive, profiling shows that all spill records take up only one or two percent of the total heap allocation in our Vax implementation, where n is 8. 7. Generation of target-machine instructions Since modern garbage collectors are so cheap [9] <ref> [10] </ref> we have dispensed with the stack. <p> 7.52 ORBIT .4 2.1 .9 3.6 Old 1.28 8.81 5.62 5.71 1613 CPS' .21 2.87 1.09 4.53 1224 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c The table above gives execution times in seconds, not including garbage-collection overhead (which can be arbitrarily large or small depending on memory size <ref> [10] </ref>). 9. Results By separating the code generation into easily-understood phases with clean interfaces, we make it easier to produce robust optimizing compilers. Our method is not difficult to implement, and works well in practice.
Reference: 11. <author> David R. Chase, </author> <title> ``Safety considerations for storage allocation optimizations,'' </title> <booktitle> SIG-PLAN '88 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pp. 1-10, </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: Generation of target-machine instructions Since modern garbage collectors are so cheap [9] [10] we have dispensed with the stack. This simplifies the code generator, which doesn't need to do the analysis [2] [4] <ref> [11] </ref> necessary to decide which closure records can be allocated on the stack; it also simplifies the runtime system, making it easier to add multiple threads or state-saving operators to the programming environment. Eliminating the stack is advantageous not only because it makes the compiler simpler.
References-found: 11

