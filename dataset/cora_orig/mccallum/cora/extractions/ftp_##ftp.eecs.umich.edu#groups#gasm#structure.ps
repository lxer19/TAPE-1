URL: ftp://ftp.eecs.umich.edu/groups/gasm/structure.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: may@informatik.uni-freiburg.de  
Title: Specifying Complex and Structured Systems with Evolving Algebras need for structuring capabilities in specification frameworks,
Author: Wolfgang May 
Address: Am Flughafen 17, 79110 Freiburg, Germany  
Affiliation: Institut fur Informatik, Universitat Freiburg  
Note: International Joint Conference on Theory and Practice of Software Development (TAPSOFT'97), April 14-18, 1997, Lille, France Springer LNCS 1214, pp. 535-549.  Following the  while a computation is running. Communication is done via distinguished locations accessible to the participating systems.  
Abstract: This paper presents an approach for specifying complex, structured systems with Evolving Algebras by means of aggregation and composition. Evolving algebras provide a formal method for executable specifications which has been employed for specifying several algorithms and programming languages. With its transition system-like rule-based syntax, the concept is as well very intuitive as well-suited for formal reasoning and verification. 
Abstract-found: 1
Intro-found: 1
Reference: [AH93] <author> L. Aceto and M. Hennessy. </author> <title> Towards Action-Refinement in Process Algebras. </title> <journal> Information and Computation, </journal> <volume> 103, </volume> <year> 1993. </year>
Reference-contexts: In process algebraic frameworks, some structuring capabilities are provided by the term structure. Action refinement for the Pi-calculus [Mil91] is presented in <ref> [AH93] </ref>. General aspects of process refinement are dealt with in [DG91, DG95]. In [BK94], a concept for defining transactions as sequences of elementary actions in a logic-programming style is defined, parallelism is modeled by interleaving.
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive Modules. </title> <booktitle> Proc. 11th Symp. on Logic in Computer Science (LICS), </booktitle> <year> 1996 </year>
Reference-contexts: Action refinement for the Pi-calculus [Mil91] is presented in [AH93]. General aspects of process refinement are dealt with in [DG91, DG95]. In [BK94], a concept for defining transactions as sequences of elementary actions in a logic-programming style is defined, parallelism is modeled by interleaving. In <ref> [AH96] </ref>, an abstract framework for reactive modules is presented which permits parallel composition and abstraction from the internal behaviour of modules.
Reference: [BDR94] <author> E. Borger, I. Durdanovic, and D. Rosenzweig. </author> <title> Occam: Specification and Compiler Correctness, Part I: The Primary Model, </title> <year> 1994. </year>
Reference-contexts: Another approach for composing Evolving Algebras for modeling concurrent computation has been presented in [GR93]. There, the focus is on joining Evolving Algebras with a shared signature to provide a communication mechanism. <ref> [BDR94] </ref> proposes another model for Occam, based on [GR93], also using shared variables for communication. Also, in [GdL95], parallel execution of rules is formally examined, based on partial interpretations, using restriction, and overwriting.
Reference: [BHK90] <author> J. Bergstra, J. Heering, and P. Klint. </author> <title> Module Algebra. </title> <journal> Journal of the ACM, </journal> <volume> 37(2) </volume> <pages> 335-372, </pages> <year> 1990. </year>
Reference-contexts: A similar approach for the state-oriented deductive database language Statelog which also can be used for specification has been presented in [LML96]. From the software engineering point of view, the concept can further be extended with the usual modularization concepts of import, export, visible signature, renaming, and hiding (cf. <ref> [BHK90] </ref>). The presented approach complements the method of refining Evolving Algebras by different abstraction levels [BR94]. There, the behaviour of rules performing complex changes on data structures in abstract terms is specified on a lower level in less abstract rules, and the finer specification is proven to be equivalent.
Reference: [BK94] <author> A. J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133(2) </volume> <pages> 205-265, </pages> <year> 1994. </year>
Reference-contexts: In process algebraic frameworks, some structuring capabilities are provided by the term structure. Action refinement for the Pi-calculus [Mil91] is presented in [AH93]. General aspects of process refinement are dealt with in [DG91, DG95]. In <ref> [BK94] </ref>, a concept for defining transactions as sequences of elementary actions in a logic-programming style is defined, parallelism is modeled by interleaving. In [AH96], an abstract framework for reactive modules is presented which permits parallel composition and abstraction from the internal behaviour of modules. <p> There, the focus is on the observable behaviour of communication variables, the transitions performed by composed modules are given in a declarative style, similar to the transition oracle of <ref> [BK94] </ref>. In this paper, the focus is on dynamic, operational aspects providing as well a formal specification as an operational model. Although it is primarily formulated in Evolving Algebra terms, the ideas of this work can be transferred to other formal specification methods with an underlying state-oriented concept.
Reference: [BP95] <author> B. Beckert and J. Posegga. </author> <title> leanEA: A Poor Man's Evolving Algebra Compiler. </title> <type> Technical Report 25, </type> <institution> Universitat Karlsruhe, Fak. f. Informatik, </institution> <year> 1995. </year>
Reference-contexts: They have been employed for specifying several algorithms and operational semantics of programming languages. With its formal, transition-system like rule-based syntax, the concept is also well-suited for formal reasoning and verification. Evolving Algebra specifications are directly executable <ref> [GH94, BP95] </ref> thus, because of their clear and intuitive concept they are well-suited for prototyping, testing, and simulating systems in the design and development phase. ? Supported by grant no.
Reference: [BR94] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM Definition and Compiler Correctness. In Logic Programming: Formal Methods and Practical Applications, Ch. 1. </title> <publisher> North Holland, </publisher> <year> 1994. </year>
Reference-contexts: From the software engineering point of view, the concept can further be extended with the usual modularization concepts of import, export, visible signature, renaming, and hiding (cf. [BHK90]). The presented approach complements the method of refining Evolving Algebras by different abstraction levels <ref> [BR94] </ref>. There, the behaviour of rules performing complex changes on data structures in abstract terms is specified on a lower level in less abstract rules, and the finer specification is proven to be equivalent. For execution, the coarser rule system is replaced by the finer one.
Reference: [DG91] <author> P. Degano and R. Gorrieri. </author> <title> Atomic refinement in Process Description languages. </title> <booktitle> In 16th Symp. on Mathematical Foundations of Computer Science, </booktitle> <publisher> Springer LNCS 520, </publisher> <pages> pp. 121-130, </pages> <year> 1991. </year>
Reference-contexts: In process algebraic frameworks, some structuring capabilities are provided by the term structure. Action refinement for the Pi-calculus [Mil91] is presented in [AH93]. General aspects of process refinement are dealt with in <ref> [DG91, DG95] </ref>. In [BK94], a concept for defining transactions as sequences of elementary actions in a logic-programming style is defined, parallelism is modeled by interleaving. In [AH96], an abstract framework for reactive modules is presented which permits parallel composition and abstraction from the internal behaviour of modules.
Reference: [DG95] <author> P. Degano and R. Gorrieri. </author> <title> A Causal Operational Semantics of Action Refinement. </title> <journal> Information and Computation, </journal> <volume> 122(1) </volume> <pages> 97-119, </pages> <year> 1995. </year>
Reference-contexts: In process algebraic frameworks, some structuring capabilities are provided by the term structure. Action refinement for the Pi-calculus [Mil91] is presented in [AH93]. General aspects of process refinement are dealt with in <ref> [DG91, DG95] </ref>. In [BK94], a concept for defining transactions as sequences of elementary actions in a logic-programming style is defined, parallelism is modeled by interleaving. In [AH96], an abstract framework for reactive modules is presented which permits parallel composition and abstraction from the internal behaviour of modules.
Reference: [GdL95] <author> R. Groenboom and G. R. de Lavalette. </author> <title> A Formalisation of Evolving Algebras. </title> <booktitle> In Proc. Accolade95, </booktitle> <pages> pages 17-28, </pages> <year> 1995. </year>
Reference-contexts: Another approach for composing Evolving Algebras for modeling concurrent computation has been presented in [GR93]. There, the focus is on joining Evolving Algebras with a shared signature to provide a communication mechanism. [BDR94] proposes another model for Occam, based on [GR93], also using shared variables for communication. Also, in <ref> [GdL95] </ref>, parallel execution of rules is formally examined, based on partial interpretations, using restriction, and overwriting. Specifying Complex and Structured Systems with Evolving Algebras 15 Both approaches are concerned only with flat rule sets, thus no sequential composition, iteration, or hierarchical structuring is considered.
Reference: [GH94] <author> Y. Gurevich and J. Huggins. </author> <title> An Evolving Algebra Interpreter. </title> <note> WWW, 1994. </note>
Reference-contexts: They have been employed for specifying several algorithms and operational semantics of programming languages. With its formal, transition-system like rule-based syntax, the concept is also well-suited for formal reasoning and verification. Evolving Algebra specifications are directly executable <ref> [GH94, BP95] </ref> thus, because of their clear and intuitive concept they are well-suited for prototyping, testing, and simulating systems in the design and development phase. ? Supported by grant no.
Reference: [GR93] <author> P. Glavan and D. Rosenzweig. </author> <title> Communicating evolving algebras. </title> <publisher> Springer LNCS 702, </publisher> <pages> pp. 182-215. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: In contrast, in the hierarchical concept presented here, rules specifying a behaviour on a lower abstraction level are encapsulated as a system which is then called by the rules on the above level. Another approach for composing Evolving Algebras for modeling concurrent computation has been presented in <ref> [GR93] </ref>. There, the focus is on joining Evolving Algebras with a shared signature to provide a communication mechanism. [BDR94] proposes another model for Occam, based on [GR93], also using shared variables for communication. <p> Another approach for composing Evolving Algebras for modeling concurrent computation has been presented in <ref> [GR93] </ref>. There, the focus is on joining Evolving Algebras with a shared signature to provide a communication mechanism. [BDR94] proposes another model for Occam, based on [GR93], also using shared variables for communication. Also, in [GdL95], parallel execution of rules is formally examined, based on partial interpretations, using restriction, and overwriting.
Reference: [Gur88] <author> Y. Gurevich. </author> <booktitle> Logics and the challenge of Computer science, </booktitle> <pages> pp. 1-57. </pages> <booktitle> In: Current Trends in Theoretical Computer Science, Comp. </booktitle> <address> Sc. </address> <publisher> Press, </publisher> <year> 1988. </year>
Reference-contexts: Section 5 formally defines the notion of systems of Evolving Algebras and gives an operational model for structured Evolving Algebras as constructs of simple Evolving Algebras. Section 6 completes the work with an overview of related work and some concluding remarks. 2 Evolving Algebras Evolving Algebras 2 <ref> [Gur88, Gur91, Gur94] </ref> are transition systems whose states are static algebras, ie first-order interpretations over a functional signature . The transition relation is specified by rules describing the modifications of the interpretation of the function symbols from one state to another.
Reference: [Gur91] <author> Y. Gurevich. </author> <title> An attempt to discover semantics (A Tutorial Introduction). </title> <journal> Bulletin of the EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Formal specification methods gain increasing interest in system design and validation. Their application to complex tasks, for instance workflow systems, requires structuring capabilities of the formal framework. Evolving Algebras <ref> [Gur91] </ref> provide a formal description of operational semantics for algorithms in an easy-to-understanding way, tailored to the natural abstraction level of the algorithm. They have been employed for specifying several algorithms and operational semantics of programming languages. <p> Section 5 formally defines the notion of systems of Evolving Algebras and gives an operational model for structured Evolving Algebras as constructs of simple Evolving Algebras. Section 6 completes the work with an overview of related work and some concluding remarks. 2 Evolving Algebras Evolving Algebras 2 <ref> [Gur88, Gur91, Gur94] </ref> are transition systems whose states are static algebras, ie first-order interpretations over a functional signature . The transition relation is specified by rules describing the modifications of the interpretation of the function symbols from one state to another.
Reference: [Gur94] <author> Y. Gurevich. </author> <title> Lipari Guide. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Thus, subsystems provide a natural way of encapsulating data and internal behaviour. Their behaviour is aggregated to atomic transitions on the upper level. The paper is structured as follows: In the next section, the classical concept of Evolving Algebras as presented in <ref> [Gur94] </ref> is reviewed and a motivating example is pointed out. Section 3 relates computations of Evolving Algebras to sequences of first-order interpretations, setting the base for a logical treatment. In Section 4, some combinators for structuring systems of Evolving Algebras are presented. <p> Section 5 formally defines the notion of systems of Evolving Algebras and gives an operational model for structured Evolving Algebras as constructs of simple Evolving Algebras. Section 6 completes the work with an overview of related work and some concluding remarks. 2 Evolving Algebras Evolving Algebras 2 <ref> [Gur88, Gur91, Gur94] </ref> are transition systems whose states are static algebras, ie first-order interpretations over a functional signature . The transition relation is specified by rules describing the modifications of the interpretation of the function symbols from one state to another.
Reference: [LML96] <author> B. Ludascher, W. May, and G. Lausen. </author> <title> Nested Transactions in a Logical Language for Active Rules. </title> <booktitle> In Proc. Intl. Workshop on Logic in Databases (LID), </booktitle> <address> San Miniato, Italy, </address> <publisher> Springer LNCS 1154, </publisher> <pages> pp. 197-222, </pages> <year> 1996. </year>
Reference-contexts: Although it is primarily formulated in Evolving Algebra terms, the ideas of this work can be transferred to other formal specification methods with an underlying state-oriented concept. A similar approach for the state-oriented deductive database language Statelog which also can be used for specification has been presented in <ref> [LML96] </ref>. From the software engineering point of view, the concept can further be extended with the usual modularization concepts of import, export, visible signature, renaming, and hiding (cf. [BHK90]). The presented approach complements the method of refining Evolving Algebras by different abstraction levels [BR94].
Reference: [Mes92] <author> J. Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96 </volume> <pages> 73-155, </pages> <year> 1992. </year>
Reference-contexts: Then the performed updates (or a part of this state) are returned as results. 6 Related Work and Conclusion Fundamentally, in all specification methods there is a need for structuring. Especially methods with an operational flavor, such as Petri Nets, Rewriting Logic <ref> [Mes92] </ref> or in general rule-based systems take great advantage from features for encapsulating internal data structures and behaviour. In process algebraic frameworks, some structuring capabilities are provided by the term structure. Action refinement for the Pi-calculus [Mil91] is presented in [AH93].
Reference: [Mil91] <author> R. Milner. </author> <title> The Polyadic -calculus: A Tutorial. </title> <type> Technical Report 180, </type> <institution> Computer Science Department, University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: Especially methods with an operational flavor, such as Petri Nets, Rewriting Logic [Mes92] or in general rule-based systems take great advantage from features for encapsulating internal data structures and behaviour. In process algebraic frameworks, some structuring capabilities are provided by the term structure. Action refinement for the Pi-calculus <ref> [Mil91] </ref> is presented in [AH93]. General aspects of process refinement are dealt with in [DG91, DG95]. In [BK94], a concept for defining transactions as sequences of elementary actions in a logic-programming style is defined, parallelism is modeled by interleaving.
References-found: 18

