URL: http://www.cs.utexas.edu/users/boyer/cade11.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/boyer/publications.html
Root-URL: 
Title: Automated Correctness Proofs of Machine Code Programs for a Commercial Microprocessor 1  
Author: Robert S. Boyer and Yuan Yu 
Keyword: Key words. Automated reasoning, Nqthm, Boyer-Moore Theorem Prover, formal program verification, object code, Gnu, C, Ada.  
Note: or  
Address: Austin, Texas 78712  
Affiliation: Computer Sciences and Mathematics Departments University of Texas at Austin  
Email: email: boyer@cs.utexas.edu  yuan@cs.utexas.edu  
Phone: telephone: (512) 471-9745  
Abstract: We have formally specified a substantial subset of the MC68020, a widely used microprocessor built by Motorola, within the mathematical logic of the automated reasoning system Nqthm, i.e., the Boyer-Moore Theorem Prover [6]. Using this MC68020 specification, we have mechanically checked the correctness of MC68020 machine code programs for Euclid's GCD, Hoare's Quick Sort, binary search, and other well-known algorithms. The machine code for these examples was generated using the Gnu C and the Verdix Ada compilers. We have developed an extensive library of proven lemmas to facilitate automated reasoning about machine code programs. We describe a two stage methodology we use to do our machine code proofs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Bevier. </author> <title> A Verified Operating System Kernel. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1987. </year>
Reference: [2] <author> William Bevier, Warren Hunt, J Strother Moore, and William Young. </author> <title> Special issue on system verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4), </volume> <year> 1989. </year>
Reference-contexts: Automated reasoning systems have been successfully used to 1 The work described here was supported in part by NSF Grant MIP-9017499. assist humans to check the correctness of some computer programs (see, for example, the survey paper [4] and the more recent, large scale efforts <ref> [2] </ref>). We have recently used the automated reasoning system Nqthm [6] to define formally a mathematical specification for the widely used Motorola MC68020 microprocessor and to verify mechanically the correctness of machine code generated by high-level programming language compilers for that microprocessor. <p> For earlier examples of Nqthm-checked program proofs that are rooted in an interpreter semantics approach, see the exemplary work of Bevier (on Kit), Hunt (on FM8502), Moore (on Piton), and Young (on Micro-Gypsy), all described in <ref> [2] </ref>. For related work, see also [10]. <p> In the twelve years since A Computational Logic [5] was published, Nqthm has been used to specify and check the correctness of numerous theorems from many areas of mathematics and computing. An extensive partial listing may be found in [6, pages 5-9]. See also <ref> [2] </ref>. This section contains an extremely brief overview of Nqthm that may suffice for understanding the rest of this paper. For a thorough and precise description of the Nqthm logic, we refer the reader to the rigorous treatment in [6], especially Chapter 4, in which the logic is precisely defined. <p> The general style of Nqthm formalization used in this MC68020 specification is the product of over a decade of study by the authors of Nqthm and their students. Especially influential was the FM8502 and Piton work <ref> [2] </ref>. The development of Nqthm was primarily supported by NSF, ONR, and DARPA.
Reference: [3] <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving them correct and using them efficiently as new proof procedures. </title> <editor> In R. S. Boyer and J S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 103-184. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference: [4] <author> Robert S. Boyer and J S. Moore. </author> <title> Program verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(1) </volume> <pages> 17-23, </pages> <year> 1985. </year>
Reference-contexts: Automated reasoning systems have been successfully used to 1 The work described here was supported in part by NSF Grant MIP-9017499. assist humans to check the correctness of some computer programs (see, for example, the survey paper <ref> [4] </ref> and the more recent, large scale efforts [2]). We have recently used the automated reasoning system Nqthm [6] to define formally a mathematical specification for the widely used Motorola MC68020 microprocessor and to verify mechanically the correctness of machine code generated by high-level programming language compilers for that microprocessor.
Reference: [5] <author> Robert S. Boyer and J Strother Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In the twelve years since A Computational Logic <ref> [5] </ref> was published, Nqthm has been used to specify and check the correctness of numerous theorems from many areas of mathematics and computing. An extensive partial listing may be found in [6, pages 5-9]. See also [2].
Reference: [6] <author> Robert S. Boyer and J Strother Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <year> 1988. </year> <title> For sources and examples, </title> <address> see ftp://ftp.cli.com/pub/nqthm/nqthm-1992/nqthm-1992.tar.Z or ftp://ftp.cs.utexas.edu/pub/boyer/nqthm-1992.tar.Z. </address>
Reference-contexts: We have recently used the automated reasoning system Nqthm <ref> [6] </ref> to define formally a mathematical specification for the widely used Motorola MC68020 microprocessor and to verify mechanically the correctness of machine code generated by high-level programming language compilers for that microprocessor. <p> In the twelve years since A Computational Logic [5] was published, Nqthm has been used to specify and check the correctness of numerous theorems from many areas of mathematics and computing. An extensive partial listing may be found in <ref> [6, pages 5-9] </ref>. See also [2]. This section contains an extremely brief overview of Nqthm that may suffice for understanding the rest of this paper. <p> See also [2]. This section contains an extremely brief overview of Nqthm that may suffice for understanding the rest of this paper. For a thorough and precise description of the Nqthm logic, we refer the reader to the rigorous treatment in <ref> [6] </ref>, especially Chapter 4, in which the logic is precisely defined. The logic of Nqthm is a quantifier-free first order logic with equality. The syntax is similar to that of Pure Lisp or the lambda calculus, e.g., prefix notation with parentheses. Constants in the logic are functions with no arguments. <p> It is interesting to see whether we can apply the mathematics so developed to another computer architecture, say, RISC; we believe we can. To ensure that any change is indeed an improvement, we have followed the "proveall" discipline described in <ref> [6] </ref>, i.e., the practice of making sure that after we make changes to our specification or lemmas, we can still prove the most important of our previous results. Much can be said about future directions for such research.
Reference: [7] <author> Robert S. Boyer and Yuan Yu. </author> <title> A formal specification of some user mode instructions for the Motorola 68020. </title> <type> Technical Report TR-92- 04, </type> <institution> Computer Sciences Department, University of Texas at Austin, </institution> <year> 1992. </year> <note> See ftp://ftp.cs.utexas.edu/pub/techreports/tr92-04.ps.Z. Alternatively, see examples/yu/mc20-1.ps in ftp://ftp.cs.utexas.edu/pub/boyer/nqthm-1992.tar.Z. </note>
Reference-contexts: In Section 3, we briefly describe our formal specification of the user instruction set of the MC68020. For more details of the specification, we refer the reader to the complete documentation of our specification in <ref> [7] </ref>. In Section 4, we discuss how we prove the correctness of object code generated from C and Ada programs. 2 The Automated Reasoning System Nqthm The automated reasoning system Nqthm, also known as "the Boyer-Moore Theorem Prover," is a Common Lisp program for proving mathematical theorems.
Reference: [8] <author> D.L. Clutterbuck and B.A. Carre. </author> <title> The verification of low-level code. </title> <journal> IEE Software Engineering Journal, </journal> <month> May </month> <year> 1988. </year>
Reference: [9] <author> Avra Cohn. </author> <title> A proof of correctness of the Viper microprocessor: The first level. </title> <type> Technical Report 104, </type> <institution> University of Cambridge, </institution> <month> January </month> <year> 1987. </year>
Reference: [10] <author> J. V. Cook. </author> <title> Verification of the C/30 microcode using the State Delta Verification System (SDVS). </title> <booktitle> In 13th National Computer Security Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 20-31, </pages> <year> 1990. </year>
Reference-contexts: For earlier examples of Nqthm-checked program proofs that are rooted in an interpreter semantics approach, see the exemplary work of Bevier (on Kit), Hunt (on FM8502), Moore (on Piton), and Young (on Micro-Gypsy), all described in [2]. For related work, see also <ref> [10] </ref>.
Reference: [11] <author> Robert W. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> In Mathematical Aspects of Computer Science, Proceedings of Symposia in Applied Mathematics, </booktitle> <publisher> American Mathematical Society, </publisher> <pages> pages 19-32, </pages> <address> Providence, Rhode Island, </address> <year> 1967. </year>
Reference: [12] <author> Herman H. Goldstine and John von Neumann. </author> <title> Planning and coding problems for an electronic computing instrument. </title> <editor> In John von Neumann, </editor> <booktitle> Collected Works, volume V, </booktitle> <pages> pages 34-235. </pages> <publisher> Pergamon Press, Oxford, </publisher> <year> 1961. </year>
Reference-contexts: The idea of providing a rigorous mathematical basis for programming dates back to the very beginning of computing. In the classic papers of von Neumann and Goldstine <ref> [12] </ref>, which introduced the first "von Neumann machine," they described how to prove the correctness of machine code programs. Fifteen machine code programs are there specified, coded, and proved correct.
Reference: [13] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> The Communi- cation of ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference: [14] <author> Warren A. Hunt. FM8501: </author> <title> A Verified Microprocessor. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1985. </year>
Reference: [15] <author> I.M. O'Neill, et al. </author> <title> The formal verification of safety-critical assembly code. In Safety of Computer Control System 1988. </title> <publisher> Pergamon Press, </publisher> <month> November </month> <year> 1988. </year>
Reference: [16] <institution> ISO Committee JTC1/SC22/WG14. ISO/IEC Standard 9899:1990. Interna- tional Standards Organization, Geneva, </institution> <year> 1990. </year>
Reference: [17] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, Second Edition. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliff, New Jersey, </address> <year> 1988. </year>
Reference-contexts: We have managed to verify, with Nqthm, the object code produced by the Gnu C compiler for some of the C functions in Kernighan and Ritchie's book <ref> [17] </ref>, such as binary search, Quick Sort, and also some C library functions, e.g., strlen and strcpy. We have also mechanically verified the object code produced by the Verdix Ada compiler for an integer square root algorithm.
Reference: [18] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison- Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1981. </year>
Reference: [19] <author> W. D. Maurer. </author> <title> An IBM 370 assembly language verifier. </title> <booktitle> In Proceedings of the 16th Annual Technical Symposium on Systems and Software: Operational Reliability and Performance Assurance. ACM, </booktitle> <month> June </month> <year> 1974. </year>
Reference: [20] <author> W. D. Maurer. </author> <title> Some correctness principles for machine language program and microprocessors. </title> <booktitle> In Proceedings of the Seventh Annual Workshop on Micropro- gramming, </booktitle> <address> Palo Alto, CA, </address> <year> 1974. </year>
Reference: [21] <author> John McCarthy. </author> <title> Towards a mathematical science of computation. </title> <booktitle> In Proceed- ings of IFIP Congress, </booktitle> <pages> pages 21-28, </pages> <year> 1962. </year>
Reference: [22] <author> Motorola, Inc. </author> <title> MC68020 32-bit Microprocessor User's Manual. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1989. </year>
Reference-contexts: The formal specification is intended to reflect as closely as possible the "user's manual view" of the MC68020 <ref> [22] </ref>. We, at the present time, have avoided considering the supervisor level of the MC68020. Any exception caused by user programs simply halts our formalized machine. <p> We specify the "semantics" of this abstract machine as a function in the Nqthm logic in the most straightforward way: fetch the current instruction in the current state, decode the instruction, perform the operation, and return a new machine state suitably altered. for the MC68020, as described in <ref> [22] </ref>. This model has 16 32-bit general-purpose registers (8 data registers, D0-D7, and 8 address registers, A0-A7), a 32-bit program counter PC, and an 8-bit condition code register, CCR. The address register A7 is also used as the user stack pointer (USP). <p> Our specification consists of about 80% of all the user available instructions. Most of the instructions we have left unspecified have some undefined effects on the machine state. For example, some of the condition codes of the instruction CMP2 are described as undefined in <ref> [22] </ref>. We have deliberately excluded these instructions in our specification. Fortunately, these instructions constitute only a small portion of the instruction set, and most of them are rarely used. We summarize below those instructions formalized. <p> Fortunately, these instructions constitute only a small portion of the instruction set, and most of them are rarely used. We summarize below those instructions formalized. The instructions of the MC68020 instruction set are classified into ten categories according to their functions <ref> [22] </ref>. 1. Data Movement. We have included all the data movement instructions: EXG, LEA, LINK, MOVE, MOVEA, MOVEM, MOVEP, MOVEQ, PEA. 2. Integer Arithmetic. <p> An addressing mode can specify a constant that is the operand, a register that contains the operand, or a location in memory where the operand is stored. For a complete description of the MC68020 addressing modes, we refer the reader to Motorola's MC68020 user's manual <ref> [22] </ref>. 3.2 The Formal Instruction-Level Specification Before we present some details of the formal specification, we first formally define the user visible state and its internal representation. 3.2.1 The User Visible State The only type of object manipulated at the instruction level is the bit vector, which is represented as a <p> We also believe that it is unrealistic to assert the correctness of machine code programs without carefully characterizing which parts of memory are read and written|few MC68020 chips are connected to a full 4 gigabytes of RAM. Memory protection issues are not specified in <ref> [22] </ref>. mc-status, mc-rfile, mc-pc, mc-ccr and mc-mem are accessors to the machine status word, the register file, the program counter, the condition codes and the memory, respectively. 3.2.2 The Specification The top-level loop of our specification is defined by a pair of functions, the "single- stepper" stepi and the "stepper" stepn: <p> Condition Code Computation. Ideally, we would specify the condition codes in a way most natural to the "user." But in order to assure full compliance with the MC68020 specification <ref> [22] </ref>, we have followed the syntactical definition described in Table 3-11 of [22]. <p> Condition Code Computation. Ideally, we would specify the condition codes in a way most natural to the "user." But in order to assure full compliance with the MC68020 specification <ref> [22] </ref>, we have followed the syntactical definition described in Table 3-11 of [22].
Reference: [23] <author> P. J. Plauger. </author> <title> Private communication. </title>
Reference: [24] <author> P. J. Plauger. </author> <title> The Standard C Library. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1992. </year>
Reference: [25] <author> Wolfgang Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference: [26] <author> Richard L. </author> <title> Sites. Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <address> Bedford, Mass., </address> <year> 1992. </year>
Reference: [27] <author> Chris Torek. </author> <title> Private communication. </title>
Reference: [28] <author> Alan M. </author> <title> Turing. On checking a large routine. In Report of a Conference on High Speed Automatic Calculating Machines, </title> <type> pages 67-69. </type> <institution> Univ. Math. Laboratory, </institution> <address> Cambridge, </address> <year> 1949. </year>
Reference: [29] <institution> The ANSI Committee X3J11. ANSI Standard X3.159-1989. American National Standards Institute, </institution> <address> New York, </address> <year> 1989. </year>
Reference: [30] <author> Yuan Yu. </author> <title> Automated Proofs of Object Code For a Widely Used Micropro- cessor. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1992. </year> <title> For the dissertation text, see ftp://ftp.cs.utexas.edu/pub/techreports/tr93-09.ps.Z. See the files ./examples/yu/* in ftp://ftp.cs.utexas.edu/pub/boyer/nqthm-1992.tar.Z for replayable proof scripts of all the definitions and theorems mentioned in this paper and in the thesis. </title>
References-found: 30

