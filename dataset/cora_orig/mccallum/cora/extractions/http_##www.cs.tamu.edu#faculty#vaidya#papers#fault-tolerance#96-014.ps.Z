URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/96-014.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Email: fvaidya,sperisetg@cs.tamu.edu  
Title: Proximity Detecting Codes (Preliminary Version)  
Author: Nitin H. Vaidya Srinivas Perisetty 
Address: College Station, TX 77843-3112  
Affiliation: Department of Computer Science Texas A&M University  
Abstract: Technical Report 96-014 June 28, 1996 Abstract A t-proximity detecting (t-PD) code can detect when a received word is at distance t from the transmitted codeword. For non-trivial values of t, a t-proximity detecting code must be unordered. However, not all unordered codes are t-proximity detecting. This report characterizes t-proximity detecting (t-PD) codes, and presents some properties of such codes. Designs of t-PD codes and lower bounds on number of checkbits are also presented. Proximity detecting codes may be useful to improve the performance of asynchronous communication channels. fl Research reported is supported in part by National Science Foundation grant MIP-9423735 and Texas Advanced Technology Program grant 009741-052-C. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Akella. </author> <type> Personal communication, </type> <month> October </month> <year> 1995. </year>
Reference-contexts: The problem of designing proximity detecting codes is, at the very least, an interesting theoretical problem. Proximity detecting codes can be useful in asynchronous systems where certain assumptions can be made on relative delays on the wires of a bus (even if absolute delays are unpredictable) <ref> [1] </ref>. A t-proximity detecting code can be used to allow the receiver to send an acknowledgement to the sender when "all but t" non-zero transmitted bits have been received.
Reference: [2] <author> J. M. Berger, </author> <title> "A Note on Error Detection Codes for Asymmetric Channels," </title> <journal> Information and Control, </journal> <volume> vol. 4, </volume> <pages> pp. 68-73, </pages> <year> 1961. </year> <month> 22 </month>
Reference-contexts: Thus, the problem of designing efficient non-systematic t-PD codes is already solved. The t-PD codes designed in this report are all systematic codes. Although an optimal nonsystematic unordered code is also an optimal non-systematic t-PD code, an optimal systematic unordered code (e.g., Berger code <ref> [2] </ref>) is not t-PD for any non-trivial non-zero t. (All unordered codes are 0-PD, however.) Example 1 Berger codes with number of databits k = 2 r 1 are not 1-PD. For instance, consider the (5,3) Berger code shown below. <p> The construction, described below, is later illustrated with an example. 10 1. First, a (k + r 1 ; k) unordered code is constructed by appending r 1 = dlog 2 (k + 1)e checkbits to given k-bit data. The r 1 checkbits, similar to Berger codes <ref> [2] </ref>, denote the number of zeros in the data. 2. <p> The steps of the construction are described below: 1. First, a (k + r 1 ; k) unordered code is constructed by appending r 1 = dlog 2 (k + 1)e checkbits to given k-bit data. The r 1 checkbits, similar to Berger codes <ref> [2] </ref>, denote the number of zeros in the data. 2. Another r 2 = dlog 2 (k + 1)e 1 bits are appended as follows: Let z be the number of zeros in the data. Then, the r 2 checkbits represent bz=2c in binary.
Reference: [3] <author> M. Blaum and J. Bruck, </author> <title> "Unordered error-correcting codes and their applications," </title> <booktitle> in Digest of papers: The 22 nd Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 486-493, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Even an unordered t-error correcting code is not necessarily t-PD. (As discussed later, this observation raises an interesting issue regarding applicability of unordered SEC codes <ref> [3] </ref> for asynchronous communication.) This report is organized as follows. Section 2 presents characterization and some properties of t-PD codes. A lower bound on the number of checkbits for 1-PD codes is obtained in Section 3. Sections 4 and 5 present design of some t-PD code. <p> Note that N (0011; 0101) = N (0101; 0011) = 1. Therefore, the code is not SEC-AUED. The code is 1-PD, however, as all codewords are of weight 2. Example 3 An unordered single error correcting (unordered SEC) code is not necessarily 1-PD : A code is unordered SEC <ref> [3] </ref> iff for every X; Y 2 C the following condition is true: N (X; Y ) 1 and N (Y; X) 2 or vice versa. As satisfying this condition is not sufficient to satisfy Theorem 1, as expected, an unordered SEC code is not necessarily 1-PD. <p> This situation is similar to impossibility of achieving distributed consensus in the presence of single failure when channels are asynchronous [8]. Example 4 A 1-PD code is not necessarily an unordered SEC code : A code is unordered SEC <ref> [3] </ref> iff for every X; Y 2 C, N (X; Y ) 1 and N (Y; X) 2 or vice versa. As satisfying Theorem 1 is not sufficient to satisfy requirements for an unordered SEC code, as expected, a 1-PD code is not necessarily unordered SEC.
Reference: [4] <author> M. Blaum and H. van Tilborg, </author> <title> "On t-error correcting/all unidirectional error detecting codes," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 38, </volume> <pages> pp. 1493-1501, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Proof: A code C is t-EC-AUED iff for every X; Y 2 C the following condition is true: N (X; Y ) t + 1 and N (Y; X) t + 1 <ref> [4, 6, 11, 13] </ref>. If this condition is satisfied, then condition 2 in Theorem 1 is also satisfied. <p> Any SEC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is 1-PD, as proved next. Proof: Consider two data d 1 and d 2 . <p> Note that checkbits c 1 and c 2 are encoded using a SEC-AUED code to obtain codewords c 1 f 1 and c 2 f 2 from the SEC-AUED code. From the characterization of SEC-AUED codes <ref> [4, 6, 11, 13] </ref> it follows that N (c 1 f 1 ; c 2 f 2 ) 2 and N (c 2 f 2 ; c 1 f 1 ) 2. <p> Any t-EC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is t-PD. The proof is similar to the proof of construction 3. <p> The proof is similar to the proof of construction 3. It uses the fact that a code is t-EC-AUED iff for any two codewords X and Y from that code N (X; Y ) t + 1 and N (Y; X) t + 1 <ref> [4, 11] </ref>. 6 Summary This report defines a new class of codes that are capable of t-proximity detection. The report characterizes the codes and studies their properties. It turns out that the optimal n=2-out-of-n unordered (non-systematic) code is also an optimal non-systematic t-PD code.
Reference: [5] <author> B. Bose, </author> <title> "On Unordered Codes," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 40, </volume> <pages> pp. 125-131, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Unordered codes have been proposed for asynchronous channels, where delays on individual wires are independent and arbitrary <ref> [6, 5, 15] </ref>. In such a system, the sender encodes the data using an unordered code, and transmits the codeword. The receiver waits until a codeword is received, and then decodes it to recover the data. <p> The receiver waits until a codeword is received, and then decodes it to recover the data. As different non-zero bits may take different amount of time to reach the receiver, an unordered code is necessary <ref> [6, 5, 15] </ref>. The notion of proximity detection is motivated by the need to improve the performance of an asynchronous channel. Presently, we are considering binary channels (that can take values 0 or 1). We consider the four-phase protocol for asynchronous communication using unordered codes [12].
Reference: [6] <author> B. Bose and T. R. N. Rao, </author> <title> "Theory of unidirectional error correcting/detecting codes," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 31, </volume> <pages> pp. 521-530, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Unordered codes have been proposed for asynchronous channels, where delays on individual wires are independent and arbitrary <ref> [6, 5, 15] </ref>. In such a system, the sender encodes the data using an unordered code, and transmits the codeword. The receiver waits until a codeword is received, and then decodes it to recover the data. <p> The receiver waits until a codeword is received, and then decodes it to recover the data. As different non-zero bits may take different amount of time to reach the receiver, an unordered code is necessary <ref> [6, 5, 15] </ref>. The notion of proximity detection is motivated by the need to improve the performance of an asynchronous channel. Presently, we are considering binary channels (that can take values 0 or 1). We consider the four-phase protocol for asynchronous communication using unordered codes [12]. <p> Proof: A code C is t-EC-AUED iff for every X; Y 2 C the following condition is true: N (X; Y ) t + 1 and N (Y; X) t + 1 <ref> [4, 6, 11, 13] </ref>. If this condition is satisfied, then condition 2 in Theorem 1 is also satisfied. <p> Note that checkbits c 1 and c 2 are encoded using a SEC-AUED code to obtain codewords c 1 f 1 and c 2 f 2 from the SEC-AUED code. From the characterization of SEC-AUED codes <ref> [4, 6, 11, 13] </ref> it follows that N (c 1 f 1 ; c 2 f 2 ) 2 and N (c 2 f 2 ; c 1 f 1 ) 2.
Reference: [7] <author> J. Bruck and M. Blaum, </author> <title> "New techniques for constructing EC/AUED codes," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 41, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: Any SEC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is 1-PD, as proved next. Proof: Consider two data d 1 and d 2 . <p> The codes presented in Appendix A were obtained by a manual search, and (as yet) we do not have a systematic way of generating codes with same amount of redundancy. 14 number of number of construction checkbits for a data bits k checkbits r number SEC-AUED code <ref> [7, 10] </ref> 5 5 2 6 7 5 2 7 9 7 2 7 12 7 2 9 20 9 2 10 31 9 2 12 50 11 2 13 63 11 2 15 127 13 2 17 139 15 2/3 17 256 16 3 19 512 18 3 22 5 <p> Any t-EC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is t-PD. The proof is similar to the proof of construction 3.
Reference: [8] <author> M. J. Fischer, N. A. Lynch, and M. Merritt, </author> <title> "Impossibility of distributed consensus with one faulty process," </title> <journal> J. ACM, </journal> <volume> vol. 32, </volume> <pages> pp. 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: In this case, the receiver cannot correctly determine which possibility to assume, and hence, it may not be possible to correct single errors (assuming channel delays are arbitrary). This situation is similar to impossibility of achieving distributed consensus in the presence of single failure when channels are asynchronous <ref> [8] </ref>. Example 4 A 1-PD code is not necessarily an unordered SEC code : A code is unordered SEC [3] iff for every X; Y 2 C, N (X; Y ) 1 and N (Y; X) 2 or vice versa.
Reference: [9] <author> C. V. Frieman, </author> <title> "Optimal error detection codes for completely asymmetric binary channels," </title> <journal> Information and Control, </journal> <volume> vol. 5, </volume> <pages> pp. 64-71, </pages> <month> March </month> <year> 1962. </year>
Reference-contexts: We will only be interested in "non-trivial" values of t. From Theorem 1, it follows that, for a non-trivial value of t (including t = 0), all t-PD codes are unordered codes. Note that the bn=2c-out-of-n is an optimal unordered code <ref> [9] </ref>, as well 7 as a t-PD code (for all t). As a t-PD code must be unordered, the bn=2c-out-of-n code is also an optimal t-PD code (for all non-trivial t). Thus, the problem of designing efficient non-systematic t-PD codes is already solved.
Reference: [10] <author> R. S. Katti and M. Blaum, </author> <title> "An improvement on constructions of t-EC/AUED codes," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 45, </volume> <pages> pp. 607-608, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Any SEC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is 1-PD, as proved next. Proof: Consider two data d 1 and d 2 . <p> In the table, second column lists the smallest number of checkbits obtained using constructions 2 and 3, and third column lists the construction number (2 or 3) that yields smaller number of checkbits. For comparison purposes, last column of the table lists number of checkbits for a SEC-AUED code <ref> [10] </ref> for given values of k. For k 4, the dual-rail code is optimal, i.e., optimal number of checkbits is k. Therefore, k 4 are not listed in the table. <p> The codes presented in Appendix A were obtained by a manual search, and (as yet) we do not have a systematic way of generating codes with same amount of redundancy. 14 number of number of construction checkbits for a data bits k checkbits r number SEC-AUED code <ref> [7, 10] </ref> 5 5 2 6 7 5 2 7 9 7 2 7 12 7 2 9 20 9 2 10 31 9 2 12 50 11 2 13 63 11 2 15 127 13 2 17 139 15 2/3 17 256 16 3 19 512 18 3 22 5 <p> Any t-EC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is t-PD. The proof is similar to the proof of construction 3.
Reference: [11] <author> D. J. Lin and B. Bose, </author> <title> "Theory and design of t-error correcting and d(d &gt; t)-unidirectional error detecting (t-EC d-UED) codes," </title> <journal> IEEE Trans. Computers, </journal> <pages> pp. 433-439, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Proof: A code C is t-EC-AUED iff for every X; Y 2 C the following condition is true: N (X; Y ) t + 1 and N (Y; X) t + 1 <ref> [4, 6, 11, 13] </ref>. If this condition is satisfied, then condition 2 in Theorem 1 is also satisfied. <p> Any SEC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is 1-PD, as proved next. Proof: Consider two data d 1 and d 2 . <p> Note that checkbits c 1 and c 2 are encoded using a SEC-AUED code to obtain codewords c 1 f 1 and c 2 f 2 from the SEC-AUED code. From the characterization of SEC-AUED codes <ref> [4, 6, 11, 13] </ref> it follows that N (c 1 f 1 ; c 2 f 2 ) 2 and N (c 2 f 2 ; c 1 f 1 ) 2. <p> Any t-EC-AUED code may be used, for instance <ref> [4, 11, 7, 10] </ref>. The resulting (k + r 1 + r 2 ; k) code is t-PD. The proof is similar to the proof of construction 3. <p> The proof is similar to the proof of construction 3. It uses the fact that a code is t-EC-AUED iff for any two codewords X and Y from that code N (X; Y ) t + 1 and N (Y; X) t + 1 <ref> [4, 11] </ref>. 6 Summary This report defines a new class of codes that are capable of t-proximity detection. The report characterizes the codes and studies their properties. It turns out that the optimal n=2-out-of-n unordered (non-systematic) code is also an optimal non-systematic t-PD code.
Reference: [12] <author> C. A. Mead and L. Conway, </author> <title> An Introduction to VLSI Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1980. </year> <note> Chapter 7 by C. Seitz, entitled "System Timing". </note>
Reference-contexts: The notion of proximity detection is motivated by the need to improve the performance of an asynchronous channel. Presently, we are considering binary channels (that can take values 0 or 1). We consider the four-phase protocol for asynchronous communication using unordered codes <ref> [12] </ref>. In this protocol, the channel (or the bus) begins in the all-0 state (i.e., all wires are 0). The sender encodes the data as a codeword from an unordered code, and transmits the codeword. When the receiver receives the codeword, it sends an acknowledgement back to the sender. <p> When the receiver receives the codeword, it sends an acknowledgement back to the sender. Upon receiving the acknowledgement, sender returns the bus to an all-0 state (called spacer) this all-0 state is acknowledged by the receiver before the next codeword is transmitted by the sender <ref> [12] </ref>. While we are not concerned with actual specifics of the communication protocol, we do assume that the bus is all-0 before the sender begins transmitting a codeword. Thus, any word received by the receiver must be covered by the transmitted codeword.
Reference: [13] <author> D. K. Pradhan, </author> <title> "A new class of error-correcting/detecting codes for fault-tolerant computer applications," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 29, </volume> <pages> pp. 471-481, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: Proof: A code C is t-EC-AUED iff for every X; Y 2 C the following condition is true: N (X; Y ) t + 1 and N (Y; X) t + 1 <ref> [4, 6, 11, 13] </ref>. If this condition is satisfied, then condition 2 in Theorem 1 is also satisfied. <p> Note that checkbits c 1 and c 2 are encoded using a SEC-AUED code to obtain codewords c 1 f 1 and c 2 f 2 from the SEC-AUED code. From the characterization of SEC-AUED codes <ref> [4, 6, 11, 13] </ref> it follows that N (c 1 f 1 ; c 2 f 2 ) 2 and N (c 2 f 2 ; c 1 f 1 ) 2.
Reference: [14] <author> T. R. N. Rao and E. Fujiwara, </author> <title> Error-Control Coding for Computer Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: For instance, N (0111; 1001) = 2 and N (1001; 0111) = 1. Let d (X; Y ) denote the Hamming distance between X and Y . Then, d (X; Y ) = N (X; Y ) + N (Y; X) <ref> [14] </ref>. For future reference, note that if weight of X is smaller than weight of Y , then N (X; Y ) &lt; N (Y; X ); if the two weights are equal then N (X; Y ) = N (Y; X ).
Reference: [15] <author> T. Verhoeff, </author> <title> "Delay-insensitive codes An overview," </title> <journal> Distributed Computing, </journal> <volume> vol. 3, </volume> <pages> pp. 1-8, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Unordered codes have been proposed for asynchronous channels, where delays on individual wires are independent and arbitrary <ref> [6, 5, 15] </ref>. In such a system, the sender encodes the data using an unordered code, and transmits the codeword. The receiver waits until a codeword is received, and then decodes it to recover the data. <p> The receiver waits until a codeword is received, and then decodes it to recover the data. As different non-zero bits may take different amount of time to reach the receiver, an unordered code is necessary <ref> [6, 5, 15] </ref>. The notion of proximity detection is motivated by the need to improve the performance of an asynchronous channel. Presently, we are considering binary channels (that can take values 0 or 1). We consider the four-phase protocol for asynchronous communication using unordered codes [12]. <p> The 2-out-of-4 code presented in Example 2 is 1-PD but not unordered SEC, because N (0011; 0101) = N (0101; 0011) = 1. Example 5 Dual-rail code <ref> [15] </ref> is a systematic t-PD code for all t : Dual-rail code with k databits is a (2k; k) constant-weight code; each codeword has weight k. Therefore, by Corollary 1, the dual-rail code is t-PD for all t.
References-found: 15

