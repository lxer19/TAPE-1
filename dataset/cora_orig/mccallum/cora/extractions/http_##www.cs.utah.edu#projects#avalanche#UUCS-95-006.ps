URL: http://www.cs.utah.edu/projects/avalanche/UUCS-95-006.ps
Refering-URL: http://www.cs.utah.edu/projects/avalanche/avalanche-publications.html
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu  
Title: Explicit-enumeration based Verification made Memory-efficient  
Author: Ratan Nalumasu, Ganesh Gopalakrishnan 
Keyword: Formal Methods, Verification, Model Checking  
Date: February 24, 1995  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science, University of Utah,  
Abstract: We investigate techniques for reducing the memory requirements of a model checking tool employing explicit enumeration. Two techniques are studied in depth: (1) exploiting symmetries in the model, and (2) exploiting sequential regions in the model. The first technique resulted in a significant reduction in memory requirements at the expense of an increase in run time. It is capable of finding progress violations at much lower stack depths. In addition, it is more general than two previously published methods to exploit symmetries, namely scalar sets and network invariants. The second technique comes with no time overheads and can effect significant memory usage reductions directly related to the amount of sequentiality in the model. Both techniques have been implemented as part of the SPIN verifier. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Felice Balarin and Alberto L. Sangiovanni-Vincentelli. </author> <title> On the automatic computation of network invariants. </title> <booktitle> In Computer-Aided Verification, </booktitle> <pages> pages 234-246, </pages> <address> Stanford, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In another approach, a network of the form P||... is replaced by an equivalent network of the form P N . The existence of a network invariant has been widely studied <ref> [1, 16] </ref>. In yet another approach [2], given a finite-state model, a quotient model that takes the symmetries in the problem into account is found, and used as the basis for model checking.
Reference: [2] <author> E. Clarke, T. Filkorn, and S. Jha. </author> <title> Exploiting symmetry in temporal logic model checking. </title> <booktitle> In Computer Aided Verifcation, </booktitle> <pages> pages 450-163, </pages> <address> Elounda, Greece, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In another approach, a network of the form P||... is replaced by an equivalent network of the form P N . The existence of a network invariant has been widely studied [1, 16]. In yet another approach <ref> [2] </ref>, given a finite-state model, a quotient model that takes the symmetries in the problem into account is found, and used as the basis for model checking. <p> Hence, whenever an un-normalized state is generated, it is necessary to normalize it and pursue it, rather than discard it rightaway. Equivalences among states are induced by the symmetries in the system being verified. It is standard practice to require the designer to identify the symmetries in a system <ref> [12, 10, 2] </ref>. Most of the symmetries in concurrent systems are self-evident (e.g., Figure 3). This processor topology is typical of many concurrent protocols. The global state of such a system is a tuple of the states of the individual processing nodes plus the state of the medium (or "bus"). <p> However, when only one rewrite rule is present, the process is confluent. In general, finding the normal form for a state is known to be an NP-complete problem <ref> [2] </ref>. 6 Conclusions and Future Work The results of Section 3 demonstrate that exploiting the symmetries can result in a significant improvement in the usage of available memory. It is therefore very important to exploit such symmetries to be able to verify large concurrent systems.
Reference: [3] <author> Edmund Clarke, Allen Emerson, and Arvind Sistla. </author> <title> Automatic verification of finite-state concurent systems using temporal logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction With the growing complexity of hardware and software, the need to formally verify them is being increasingly felt. Among the options available today, two of the prominent ones are based on deduction and model-checking [8]. Although both methods have their proponents, model-checking <ref> [3] </ref> is preferred when a relatively high degree of automation is desired, and when one-of-a-kind reactive behaviors are involved.
Reference: [4] <author> E. Allen Emerson and Kedar S. Namjoshi. </author> <title> Reasoning about rings. </title> <booktitle> In Proc. of the 21st Annual Symposium on the Principles of Prog. Langs. ACM, </booktitle> <year> 1994. </year> <month> 11 </month>
Reference-contexts: The homomorphic reduction approach is more general than the method we propose, but not as direct and simple to apply. Although network invariants methods are elegant and some of the results in this area are quite powerful <ref> [4] </ref>, these methods have, hitherto, been demonstrated only for simple classes of behaviors. For systems of the size and complexity we are interested in tackling, it is not clear how difficult it will be to find suitable network invariants or quotient models.
Reference: [5] <author> Richard M. Fujimoto, J. -J. Tsai, and Ganesh Gopalakrishnan. </author> <title> Design and evaluation of the rollback chip: Special purpose hardware for time warp. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(1) </volume> <pages> 68-82, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: In a formal sense, this is a process of conducting design refinements [14] in a functional framework, and leading through a process/reactive framework. (An example of our past work in this area in deriving a pipelined multiplier is reported in [6].) 4.1 Overview of the RBC Specification RBC <ref> [5] </ref> is a simple memory management unit designed to speed up the process of state saving and rollback in distributed discrete event based simulation using Time Warp. For the purpose of this paper, its functionality can be understood as follows.
Reference: [6] <author> Ganesh Gopalakrishnan and Venkatesh Akella. </author> <title> A transormational approach to asynchronous high-level synthesis. </title> <booktitle> In VLSI'93, </booktitle> <volume> number 2, </volume> <month> September </month> <year> 1993. </year> <institution> Grenoble, France. </institution>
Reference-contexts: Our present exercise of re-describing RBC in a reactive system description language is consistent with the manner in which system design refinement happens in formal design approaches: an initial functional description is gradually transformed into a more reactive version that embodies scheduling- and resource-related details. (See <ref> [6] </ref> for a case study of functional derivation followed by reactive process derivation.) The RBC example is detailed in Section 4. 2 This rewriting process always terminates; depending on efficiency considerations, the designer may not always want to attain unique normal forms. 3 Because of the emphasis on implementation efficiency, the <p> In a formal sense, this is a process of conducting design refinements [14] in a functional framework, and leading through a process/reactive framework. (An example of our past work in this area in deriving a pipelined multiplier is reported in <ref> [6] </ref>.) 4.1 Overview of the RBC Specification RBC [5] is a simple memory management unit designed to speed up the process of state saving and rollback in distributed discrete event based simulation using Time Warp. For the purpose of this paper, its functionality can be understood as follows.
Reference: [7] <author> Ganesh C. Gopalakrishnan and Richard Fujimoto. </author> <title> Design and verification of the rollback chip using HOP: A case study of formal methods applied to hardware design. </title> <journal> ACM Transaction on Computer Systems, </journal> <volume> 11(2) </volume> <pages> 109-145, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Section 3 introduces state normalization with the help of this example. The second example is concerned with verifying the Rollback Chip which was developed by our group several years ago <ref> [7] </ref> and is an IFIP WG 10.5 benchmark contributed by the second author. A functional/equational manual proof of correctness has been completed for the RBC [7]. <p> The second example is concerned with verifying the Rollback Chip which was developed by our group several years ago <ref> [7] </ref> and is an IFIP WG 10.5 benchmark contributed by the second author. A functional/equational manual proof of correctness has been completed for the RBC [7]. <p> In particular, we pick an example called the Rollback Chip for which we have, in our prior work, come up with a functional/equational specification and verified correctness using verification conditions generated from a computational induction scheme <ref> [7] </ref>. Our asynchronous synthesis group is currently actively engaged in trying to reimplement the RBC by detailing its operations to include more scheduling and resource sharing information. <p> The RBC behaves like an abstract data type object with interface operations reset to initialize the RBC, mark and rollback to change the address mapping function, and read to map a given logical address to a physical 8 address. All these operations have a purely functional description given in <ref> [7] </ref>, where a proof of correctness (using equational reasoning) of the refinement of the RBC architecture has been reported. The Promela version of the RBC system was arrived at by modeling each RBC operation through a proctype. <p> However, this state saving is necessary only if there are multiple enabled threads in an execution. In case of the RBC, however, only one thread is enabled at any given time. (This was because the Promela version was a direct translation of the functional description given in <ref> [7] </ref>. Successive refinements of this Promela version will have much more concurrency; however, in these versions also there would be occasional sequential regions.) This fact can be exploited by not saving states in-between the individual steps contained in a sequential region. This resulted in a sixfold reduction in memory requirements.
Reference: [8] <author> Aarti Gupta. </author> <title> Formal methods: A survey. Formal Methods, </title> <year> 1994. </year>
Reference-contexts: 1 Introduction With the growing complexity of hardware and software, the need to formally verify them is being increasingly felt. Among the options available today, two of the prominent ones are based on deduction and model-checking <ref> [8] </ref>. Although both methods have their proponents, model-checking [3] is preferred when a relatively high degree of automation is desired, and when one-of-a-kind reactive behaviors are involved.
Reference: [9] <author> John V. Guttag, Ellis Horowitz, and David R. Musser. </author> <title> Abstract data types and software validation. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 1048-1064, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: Such symmetries are closer in spirit to the notion of representation invariants captured in works such as <ref> [9] </ref>. In this paper, we present our technique called state normalization for exploiting symmetries at this level. The homomorphic reduction approach is more general than the method we propose, but not as direct and simple to apply.
Reference: [10] <author> Z. Har'El and R.P. Kurshan. </author> <title> Software for analysis of coordination. </title> <booktitle> In Proc. Int'l Conference on System Science, </booktitle> <year> 1988. </year>
Reference-contexts: This paper is about combating state explosion in explicit-enumeration-based verification. Space/Time Tradeoffs During Explicit Enumeration Explicit enumeration forms the basis for a number of tools that have been used with great success in validating several real-life protocols <ref> [12, 10, 11] </ref>. One problem with explicit enumeration is that the available amount of memory often decides the size of the problem that can be handled; most explicit-enumeration-based tools give 100% "coverage" till this limit is reached, and give 0% coverage once this limit is exceeded. <p> This information can be used by the verification tool to cut down the state space explored. In [13], it has been shown that scalar-sets are very useful in practice. Another method for exploiting symmetries employed in tools such as COSPAN <ref> [10] </ref> is that of homomorphic reductions. <p> Hence, whenever an un-normalized state is generated, it is necessary to normalize it and pursue it, rather than discard it rightaway. Equivalences among states are induced by the symmetries in the system being verified. It is standard practice to require the designer to identify the symmetries in a system <ref> [12, 10, 2] </ref>. Most of the symmetries in concurrent systems are self-evident (e.g., Figure 3). This processor topology is typical of many concurrent protocols. The global state of such a system is a tuple of the states of the individual processing nodes plus the state of the medium (or "bus").
Reference: [11] <author> Gerard Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: This paper is about combating state explosion in explicit-enumeration-based verification. Space/Time Tradeoffs During Explicit Enumeration Explicit enumeration forms the basis for a number of tools that have been used with great success in validating several real-life protocols <ref> [12, 10, 11] </ref>. One problem with explicit enumeration is that the available amount of memory often decides the size of the problem that can be handled; most explicit-enumeration-based tools give 100% "coverage" till this limit is reached, and give 0% coverage once this limit is exceeded. <p> These ideas are key to our approach. Promela/SPIN, Supertrace, and Two State-space Search A simple and yet powerful method for effecting this "space/time tradeoff" is used in an explicit-enumeration-based tool called SPIN <ref> [11] </ref>. Strictly speaking, SPIN employs two techniques for effecting the space/time tradeoff: (1) supertrace, in which a "randomized" pruning of the state graph is effected; (2) two state-space method, in which only the amount of stack growth generated during a normal recursive depth-first search needs to be saved 1 . <p> Suppose we would like to detect and report the non-progress loop F, B, C, D, E, F (state "P" indicates the progress loop). A naive algorithm to detect non-progress loops during the depth-first search phase proves to be very inadequate <ref> [11] </ref>. SPIN uses modified depth-first search which works as follows on our example: when state B is revisited, it builds the subgraph rooted at the state immediately prior to the revisited state (state F in our example) in its entirety, in "the heap".
Reference: [12] <author> Alan Hu, David Dill, Andreas Drexler, and Han Yang. </author> <title> Higher-level specification and verification with BDDs. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 82-96, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This paper is about combating state explosion in explicit-enumeration-based verification. Space/Time Tradeoffs During Explicit Enumeration Explicit enumeration forms the basis for a number of tools that have been used with great success in validating several real-life protocols <ref> [12, 10, 11] </ref>. One problem with explicit enumeration is that the available amount of memory often decides the size of the problem that can be handled; most explicit-enumeration-based tools give 100% "coverage" till this limit is reached, and give 0% coverage once this limit is exceeded. <p> Designers combat this abrupt loss of coverage in several ways; almost always, they use techniques such as throwing away irrelevant states, reducing the dimensions of the arrays involved, etc. <ref> [12] </ref>. Although this is essential in any verification fl Supported in part by NSF award MIP 9215878 and APRA Contract N-0003995-C0018 1 approach, there are cases where even after problem-size reductions the number of states exceed the available amount of memory. <p> Hence, whenever an un-normalized state is generated, it is necessary to normalize it and pursue it, rather than discard it rightaway. Equivalences among states are induced by the symmetries in the system being verified. It is standard practice to require the designer to identify the symmetries in a system <ref> [12, 10, 2] </ref>. Most of the symmetries in concurrent systems are self-evident (e.g., Figure 3). This processor topology is typical of many concurrent protocols. The global state of such a system is a tuple of the states of the individual processing nodes plus the state of the medium (or "bus").
Reference: [13] <author> C. Norris Ip and David L. Dill. </author> <title> Better verification through symmetry. </title> <booktitle> In Int'l Conference on Computer Hardware Description Language, </booktitle> <year> 1993. </year>
Reference-contexts: The importance of exploiting symmetries is a widely studied problem, and is described in the next section. Comparing Methods for Exploiting Symmetries There are many techniques available for exploiting symmetries. Three prominent categories of methods are (1) scalar sets <ref> [13] </ref>, (2) homomorphic reductions [15], and (3) network invariants [16]. In the scalar-set method, a non-traditional data type (actually a non-traditional family of data types) called the scalar set is employed. A scalar set is a set with a finite and fixed number of elements. <p> This information can be used by the verification tool to cut down the state space explored. In <ref> [13] </ref>, it has been shown that scalar-sets are very useful in practice. Another method for exploiting symmetries employed in tools such as COSPAN [10] is that of homomorphic reductions. <p> It is therefore very important to exploit such symmetries to be able to verify large concurrent systems. This technique is more general than scalar sets <ref> [13] </ref> or network invariants [16]. While not as general as homomorphic reductions [15], it is simpler, and straightforward to apply. Also, Section 4 demonstrates that identifying the sequential regions of a protocol can result in significant savings in memory.
Reference: [14] <author> Steven D. Johnson. </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> The MIT Press, </publisher> <year> 1984. </year> <note> An ACM Distinguished Dissertation-1983. </note>
Reference-contexts: Our asynchronous synthesis group is currently actively engaged in trying to reimplement the RBC by detailing its operations to include more scheduling and resource sharing information. In a formal sense, this is a process of conducting design refinements <ref> [14] </ref> in a functional framework, and leading through a process/reactive framework. (An example of our past work in this area in deriving a pipelined multiplier is reported in [6].) 4.1 Overview of the RBC Specification RBC [5] is a simple memory management unit designed to speed up the process of state
Reference: [15] <author> Robert P. Kurshan. </author> <title> Formal verification of coordinating processes. </title> <institution> Mathematics Research Center, AT&T Bell Labs Murray Hill, NJ, </institution> <year> 1994. </year>
Reference-contexts: The importance of exploiting symmetries is a widely studied problem, and is described in the next section. Comparing Methods for Exploiting Symmetries There are many techniques available for exploiting symmetries. Three prominent categories of methods are (1) scalar sets [13], (2) homomorphic reductions <ref> [15] </ref>, and (3) network invariants [16]. In the scalar-set method, a non-traditional data type (actually a non-traditional family of data types) called the scalar set is employed. A scalar set is a set with a finite and fixed number of elements. <p> It is therefore very important to exploit such symmetries to be able to verify large concurrent systems. This technique is more general than scalar sets [13] or network invariants [16]. While not as general as homomorphic reductions <ref> [15] </ref>, it is simpler, and straightforward to apply. Also, Section 4 demonstrates that identifying the sequential regions of a protocol can result in significant savings in memory. In Section 5 we presented a technique to translate high-level rewrite rules into a low-level normalization routine.
Reference: [16] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year> <month> 12 </month>
Reference-contexts: Both these approaches have their own strengths. Also, both methods suffer from state explosion <ref> [16] </ref>, combating which forms a central research problem. This paper is about combating state explosion in explicit-enumeration-based verification. Space/Time Tradeoffs During Explicit Enumeration Explicit enumeration forms the basis for a number of tools that have been used with great success in validating several real-life protocols [12, 10, 11]. <p> The importance of exploiting symmetries is a widely studied problem, and is described in the next section. Comparing Methods for Exploiting Symmetries There are many techniques available for exploiting symmetries. Three prominent categories of methods are (1) scalar sets [13], (2) homomorphic reductions [15], and (3) network invariants <ref> [16] </ref>. In the scalar-set method, a non-traditional data type (actually a non-traditional family of data types) called the scalar set is employed. A scalar set is a set with a finite and fixed number of elements. <p> In one approach of this type <ref> [16] </ref>, a network P||... of processes is represented by a more general description of the form P || Q where Q represents a network of an arbitrary number of P's. If a process such as Q (called the "network invariant") can be found, the task of verification is greatly simplified. <p> In another approach, a network of the form P||... is replaced by an equivalent network of the form P N . The existence of a network invariant has been widely studied <ref> [1, 16] </ref>. In yet another approach [2], given a finite-state model, a quotient model that takes the symmetries in the problem into account is found, and used as the basis for model checking. <p> It is therefore very important to exploit such symmetries to be able to verify large concurrent systems. This technique is more general than scalar sets [13] or network invariants <ref> [16] </ref>. While not as general as homomorphic reductions [15], it is simpler, and straightforward to apply. Also, Section 4 demonstrates that identifying the sequential regions of a protocol can result in significant savings in memory.
References-found: 16

