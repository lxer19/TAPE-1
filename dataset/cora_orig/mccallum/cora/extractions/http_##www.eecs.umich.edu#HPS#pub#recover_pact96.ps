URL: http://www.eecs.umich.edu/HPS/pub/recover_pact96.ps
Refering-URL: http://www.eecs.umich.edu/HPS/hps_branchpred.html
Root-URL: http://www.cs.umich.edu
Title: The Effects of Mispredicted-Path Execution on Branch Prediction Structures  
Abstract: Copyright 1996 IEEE. Published in the Proceedings of the 1996 Conference on Parallel Architectures and Compilation Techniques, October 21-23, 1996, Boston, USA. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. Contact: Manager, Copyrights and Permissions / IEEE Service Center / 445 Hoes Lane / P.O. Box 1331 / Piscataway, NJ 08855-1331, USA. Telephone: + Intl. 908-562-3966. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. G. Butler and Y. N. Patt, </author> <title> "An Area-Efficient Register Alias Table For Implementing HPS," </title> <booktitle> Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <year> 1990. </year>
Reference-contexts: A perfect second level unified cache was assumed. In the event of a first level cache miss, eight cycles were required to return the data from the second level cache. A checkpointing mechanism was used to repair the machine state in the event of a branch misprediction <ref> [6, 1] </ref>. An issue packet is a group of consecutive instructions within the dynamic instruction stream. A packet is fetched from the instruction cache using at most one prediction from the branch predictor, and issued as a whole into the node tables. <p> However, this mechanism is space-consuming since each checkpoint records the architectural state of the register file. Several optimizations are based on the fact that the contents of these checkpoints differ by only a few locations, and mappings are cheaper to record than register values <ref> [1, 13, 9] </ref>.
Reference: [2] <author> M. G. Butler, </author> <title> "Aggressive Execution Engines for Surpassing Single Basic Block Execution," </title> <type> PhD Thesis, </type> <institution> University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: Hence, mispredicted path execution results in instruction and data cache prefetching and pollution. The overall effect is reported to be beneficial as stated in <ref> [2] </ref> and [12]. In addition, [12] presents an instruction cache prefetching technique based on mispre-dicted path execution that performs better than other common techniques (next-line prefetching ...). Other cache-like structures such as the BTB may behave in ways similar to the instruction and data caches. <p> Wrong-path instructions may compete for access to the functional units, thus delaying the execution of correct-path instructions. When non-pipelined functional units are used, this problem becomes especially severe; a wrong-path instruction blocks access to its functional unit for the entire time it is executing. However, <ref> [2] </ref> reports that the impact on the processor performance is insignificant. The execution model used in our study features an oldest-first scheduling technique [2] and pipelined functional units. <p> However, <ref> [2] </ref> reports that the impact on the processor performance is insignificant. The execution model used in our study features an oldest-first scheduling technique [2] and pipelined functional units. Because of this, correct-path instructions are always given priority over wrong-path instructions during scheduling, and the execution of a wrong-path instruction will never delay the scheduling of a correct-path instruction. <p> Should a misprediction occur, the recovery process consists of restoring the architectural register locations from the history buffer. Once done, execution can resume. The major drawback of such a recovery mechanism is that it requires several cycles to restore the architectural state from the entries in the history buffer. <ref> [2] </ref> reports that this significantly impacts performance. The reorder buffer is a queue which contains the speculatively allocated architectural register locations. The committed register file maintains the location of each non-speculative architectural register. <p> Hence, in addition to the extra space needed for the future file, this scheme requires several cycles to start the recovery process. However the recovery process is immediate since the committed register file is the architectural state required to resume. <ref> [2] </ref> reports that the delay before recovery impairs performance as much as the history buffer scheme. The checkpoint repair mechanism establishes snapshots or checkpoints of the architectural state whenever a branch is predicted. If misprediction occurs, the checkpoint established for that branch will become the architectural state.
Reference: [3] <author> S. Ewedemi, D. Todd, and J. Yen, </author> <title> "Design Issues of the High Performance PowerPC 620 Microprocessor," Somerset Design Center, </title> <month> December </month> <year> 1994. </year>
Reference-contexts: We call this model of execution the High Performance Substrate (HPS) [11]. Many elements of HPS are embodied in today's high end microprocessors, for example, the Intel P6 [4] and the PowerPC 620 <ref> [3] </ref>.
Reference: [4] <author> L. Gwennap, </author> <title> "Intel's P6 Uses Decoupled Superscalar Design," Microprocessor Report, </title> <journal> Vol. 9 Num. </journal> <volume> 2, </volume> <year> 1995. </year>
Reference-contexts: We call this model of execution the High Performance Substrate (HPS) [11]. Many elements of HPS are embodied in today's high end microprocessors, for example, the Intel P6 <ref> [4] </ref> and the PowerPC 620 [3]. <p> This is a consequence of the large increases in the conditional branch mispredic-tion rate (5.42% to 23.08%) and the return mispredic-tion rate (3.03% to 53.04%). It is interesting to note the prefetching effect due to wrong-path execution for cache-like structures mentioned in <ref> [4] </ref> and [13] is also observed for the BTB when running gcc. This indicates that wrong-path branch instructions actually allocate BTB entries that are subsequently accessed by correct-path branches.
Reference: [5] <author> E. Hao, P-Y Chang, and Y. N. Patt, </author> <title> "The effect of Speculatively Updating Branch History on Branch Prediction Accuracy, Revisited," </title> <booktitle> Proceedings of the 27th Annual International Symposium on Microar-chitecture, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: The second option, the updates occur non-speculatively at instruction retirement. Since the branch prediction structures are not updated speculatively, recovery mechanisms are not required for these structures. However, this significantly impairs the predictor's performance since it does not use the most recent branch history information to make predictions <ref> [15, 5] </ref>. To achieve the highest performance, speculative updates of the branch prediction structures and out-of-order branch resolution must be done. This may require complex recovery mechanisms. <p> The PHT entries in the history buffer can be restored whenever there is a cycle in which no branch is retired. Therefore, an extra write port to the PHTs is not required. 4.3 Branch History Registers In a global scheme, the BHR maintains the history of past conditional branches. <ref> [5] </ref> reports that the predictor should use the most up-to-date history to achieve low misprediction rates. Therefore, the BHR is updated immediately after the prediction is made. The update is speculative and thus the effect of mispredicted branches can be observed if no recovery mechanism is provided. <p> Figure 3 (c) shows that updating at retirement causes an average decrease of 9.3% in the IPC as compared to the scheme with speculative update and a recovery mechanism. This confirms the results obtained in <ref> [5] </ref>, where it was found that the predictor should use the most up-to-date BHR in order to make an accurate prediction. Nevertheless, updating the BHR at instruction retirement still outperforms the scheme with speculate update of the BHT but without a recovery mechanism for the BHT.
Reference: [6] <author> W. Hwu and Y. N. Patt, </author> <title> "Checkpoint Repair for Out-of-Order Execution Machines," </title> <journal> IEEE Transactions on Computers, </journal> <month> December </month> <year> 1987. </year>
Reference-contexts: A perfect second level unified cache was assumed. In the event of a first level cache miss, eight cycles were required to return the data from the second level cache. A checkpointing mechanism was used to repair the machine state in the event of a branch misprediction <ref> [6, 1] </ref>. An issue packet is a group of consecutive instructions within the dynamic instruction stream. A packet is fetched from the instruction cache using at most one prediction from the branch predictor, and issued as a whole into the node tables. <p> The state recovery mechanisms presented include the history buffer [14], the reorder buffer [14], the future file [14], and the checkpoint repair mechanism <ref> [6] </ref>. In dynamically-scheduled processors, logic must be provided to keep track of the location of each architectural register. Additionally, logic must also be provided to restore the architectural state of the register file should a mis-prediction occur.
Reference: [7] <author> M. Johnson, </author> <title> "Superscalar Microprocessor Design," </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: For instance, [17] reports on the use of golden registers to deal with wrong-path instructions while using trace-driven simulations. However, the author assumed that branches were resolved in order. Resolving branches in order simplifies the recovery mechanisms but impacts the performance <ref> [7] </ref>. Note that the performance degradation of 3% reported in [7] assumes a moderate amount of speculative execution. As the amount of speculative execution increases, the performance degradation becomes more severe. This paper focuses on the effect of wrong-path instructions on the branch prediction structures. <p> However, the author assumed that branches were resolved in order. Resolving branches in order simplifies the recovery mechanisms but impacts the performance <ref> [7] </ref>. Note that the performance degradation of 3% reported in [7] assumes a moderate amount of speculative execution. As the amount of speculative execution increases, the performance degradation becomes more severe. This paper focuses on the effect of wrong-path instructions on the branch prediction structures. There are two options as to when to update these structures.
Reference: [8] <author> S. Jourdan, P. Sainrat, and D. Litaize, </author> <title> "Exploring Configurations of Functional Units in an Out-of-Order Superscalar Processor," </title> <booktitle> Proceedings of the 22nd Annual Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: To recover from a misprediction, the processor flushes subsequent recorded locations from the reorder buffer. For wide-issue dynamically-scheduled processors, a large number of reorder buffer entries may be required (over 100 <ref> [8] </ref>). Additionally, the number of read ports is twice the issue width. Both these factors may adversely affect the cycle time. An alternative to avoid the costly associative lookups in the reorder buffer is to explicitly identify the architectural state by means of a future file.
Reference: [9] <author> Mips Technologies Incorporated, </author> <title> "R10000 Microprocessor Product Overview," </title> <type> Technical Report, </type> <month> October </month> <year> 1994. </year>
Reference-contexts: However, this mechanism is space-consuming since each checkpoint records the architectural state of the register file. Several optimizations are based on the fact that the contents of these checkpoints differ by only a few locations, and mappings are cheaper to record than register values <ref> [1, 13, 9] </ref>.
Reference: [10] <author> S. McFarling, </author> <title> "Combining Branch Predictors," </title> <type> Technical Report TN-36, </type> <institution> Digital Western Research Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: 4 Branch, Integer 5 Branch, Integer 6 Load/Store, Bit Field, Integer 7 Load/Store, Bit Field, Integer 8 Load/Store, Bit Field, Integer Table 2: Simulated Machine Configuration Level Global Adaptive Branch Predictor (GAg [17]) scheme which exclusive-ORs a global history with the fetch address to select the appropriate PHT entry (g-share <ref> [10] </ref>). We used a 16-bit global BHR. This results in a 64k-entry PHT. The RAS featured 32 entries. Unless otherwise stated, we used a 2048-entry, 4-way set-associative BTB. 3 Simulation Methodology 3.1 Benchmarks Five benchmarks from the SPECint92 suite were used.
Reference: [11] <author> Y. N. Patt, W. Hwu, and M. Shebanow, </author> <month> "HPS, </month>
Reference-contexts: We provide concluding remarks in section 6. 2 Execution Model The model of execution used for this study exploits instruction level parallelism through speculative execution and dynamic scheduling. We call this model of execution the High Performance Substrate (HPS) <ref> [11] </ref>. Many elements of HPS are embodied in today's high end microprocessors, for example, the Intel P6 [4] and the PowerPC 620 [3].
References-found: 11

