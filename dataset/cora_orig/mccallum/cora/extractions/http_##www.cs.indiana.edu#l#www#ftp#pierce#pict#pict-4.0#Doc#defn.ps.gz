URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/pict-4.0/Doc/defn.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/pict-4.0/Doc/
Root-URL: http://www.cs.indiana.edu
Email: pierce@cs.indiana.edu  dnt@dcs.gla.ac.uk  
Title: Pict Language Definition Version 4.0 definition of the Pict language is still being checked for
Author: Benjamin C. Pierce David N. Turner 
Note: This draft  
Date: March 18, 1997  
Address: Lindley Hall 215 Bloomington Indiana 47405-4101 USA  Glasgow G12 8QQ United Kingdom  
Affiliation: Computer Science Department Indiana University  Department of Computing Science University of Glasgow  
Abstract-found: 0
Intro-found: 1
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> A preliminary version appeared in POPL '91 (pp. 104-118) and as DEC Systems Research Center Research Report number 62, </note> <month> August </month> <year> 1990. </year>
Reference-contexts: can be satisfied by using S-Conv and S-Trans to place the arguments in this form, if necessary, before applying S-App. (The same consideration applies at many other points in this chapter, e.g. in S-Equal, S-Equal-Bound, S-ChanIChan, etc.) 8.2.7 Recursive Types For subtyping recursive types, we use the "Amber rule" (cf. <ref> [AC93] </ref>): we assume that the bound variables representing the two types are in the subtype relation and then try to prove that the whole types are in the subtype relation. ; Y&lt;Top:K; X&lt;Y ` S &lt; T (S-Rec) Pict Language Definition 30 8.2.8 Record Types In subtyping record types, we allow
Reference: [Ama94] <author> Roberto M. Amadio. </author> <title> Translating core Facile. </title> <type> Technical Report ECRC-TR-3-94, </type> <institution> European Computer-Industry Research Center, GmbH, Munich, </institution> <year> 1994. </year> <note> Also available as a technical report from CRIN(CNRS)- Inria (Nancy). </note>
Reference: [AP94] <author> Roberto M. Amadio and Sanjiva Prasad. </author> <title> Localities and failures. </title> <type> Technical Report ECRC-M2-R10, </type> <institution> Euro-pean Computer-Industry Research Center, GmbH, Munich, </institution> <year> 1994. </year>
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: n :T n ] = v (val w 1 :S 1 =v 1 ... (val w m :S m =v m (Tr-Where) 48 Chapter 12 Derived Forms for CPS Conversion The final phase of translation is a continuation-passing transform similar to those used in some compilers for functional languages (e.g. <ref> [App92] </ref>). In essence, we transform a complex value expression into a process that performs whatever computation is necessary and sends the final value along a designated continuation channel.
Reference: [Ber93] <author> Bernard Berthomieu. </author> <title> Programming with behaviours in an ML framework. the syntax and semantics of LCS. </title> <type> Technical Report 93133, </type> <institution> LAAS-CNRS, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [BMT92] <author> Dave Berry, Robin Milner, and David N. Turner. </author> <title> A semantics for ML concurrency primitives. </title> <booktitle> In ACM Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [BS94] <author> M. Boreale and D. Sangiorgi. </author> <title> A fully abstract semantics for causality in the -calculus. </title> <type> Technical Report ECS-LFCS-94-297, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1994. </year>
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [Car90] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: (FK-Bound) ` T 2 K (FK-Equal) Chapter 8 Subtyping The subtyping relation determines when a value may be used in a context expecting a value with a "less informative" type. 8.1 Judgement Forms The main subtyping judgement, ` S &lt; T, is familiar from standard presentations of F ! (e.g., <ref> [Car90, PS96] </ref>).
Reference: [EN86] <author> U. Engberg and M. Nielsen. </author> <title> A calculus of communicating systems with label-passing. </title> <type> Report DAIMI PB-208, </type> <institution> Computer Science Department, University of Aarhus, Denmark, </institution> <year> 1986. </year>
Reference-contexts: Introduction Milner, Parrow, and Walker's -calculus <ref> [EN86, MPW92, Mil91] </ref> generalizes the channel-based communication of CCS and its relatives [Mil80, Mil89, etc.] by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies.
Reference: [FG96] <author> Cedric Fournet and Georges Gonthier. </author> <title> The reflexive chemical abstract machine and the join-calculus. </title> <booktitle> In Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: If we transformed definitions to replicated inputs, we would need to refine the type system to be able to check that these inputs were indeed responsive (cf. [KPT96]). The reduction rules for communicating with definitions are reminiscent of a simple fragment of the join-calculus <ref> [FG96] </ref>. 2. We retain conditional processes in the core language instead of desugaring them using a standard "Church boolean" encoding.
Reference: [GMP89] <author> Alessandro Giacalone, Prateek Mishra, and Sanjiva Prasad. </author> <title> FACILE: A Symmetric Integration of Concurrent and Functional Programming. </title> <booktitle> In Theory and Practice of Software Development (TAPSOFT), </booktitle> <pages> pages 184-209. </pages> <publisher> Springer, </publisher> <year> 1989. </year> <note> LNCS 352. </note>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [Hol83] <author> Soren Holmstrom. </author> <title> PFL: A functional language for parallel programming, and its implementation. Programming Methodology Group, </title> <type> Report 7, </type> <institution> University of Goteborg and Chalmers University of Technology, </institution> <month> September </month> <year> 1983. </year>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [Jon93] <author> Cliff B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR'93, </booktitle> <volume> LNCS 715, </volume> <pages> pages 158-172. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [KPT96] <author> Naoki Kobayashi, Benjamin C. Pierce, and David N. Turner. </author> <title> Linearity and the pi-calculus. </title> <booktitle> In Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: If we transformed definitions to replicated inputs, we would need to refine the type system to be able to check that these inputs were indeed responsive (cf. <ref> [KPT96] </ref>). The reduction rules for communicating with definitions are reminiscent of a simple fragment of the join-calculus [FG96]. 2. We retain conditional processes in the core language instead of desugaring them using a standard "Church boolean" encoding.
Reference: [Mat91] <author> David Matthews. </author> <title> A distributed concurrent implementation of Standard ML. </title> <type> Technical Report ECS-LFCS 91-174, </type> <institution> University of Edinburgh, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Introduction Milner, Parrow, and Walker's -calculus [EN86, MPW92, Mil91] generalizes the channel-based communication of CCS and its relatives <ref> [Mil80, Mil89, etc.] </ref> by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Introduction Milner, Parrow, and Walker's -calculus [EN86, MPW92, Mil91] generalizes the channel-based communication of CCS and its relatives <ref> [Mil80, Mil89, etc.] </ref> by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies.
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year> <title> 56 Pict Language Definition 57 </title>
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <booktitle> Appeared in Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year> <title> Reprinted in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer, and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Introduction Milner, Parrow, and Walker's -calculus <ref> [EN86, MPW92, Mil91] </ref> generalizes the channel-based communication of CCS and its relatives [Mil80, Mil89, etc.] by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies. <p> This is essentially the same as the familiar "chemical abstract machine style" semantics for the pi-calculus <ref> [Mil91, etc.] </ref>, with a few technical differences: 1. We retain def declarations in the core language instead of desugaring them into replicated input processes. The main reason for this is to avoid complicating the type system: in the present formulation, definitions give rise directly to channels with responsive types (/T).
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: Introduction Milner, Parrow, and Walker's -calculus <ref> [EN86, MPW92, Mil91] </ref> generalizes the channel-based communication of CCS and its relatives [Mil80, Mil89, etc.] by allowing channels to be passed as data along other channels. This extension introduces an element of mobility, enabling the specification and verification of concurrent systems with dynamically evolving communication topologies.
Reference: [Pie96] <author> Benjamin C. Pierce. </author> <title> Programming in the pi-calculus: A tutorial introduction to Pict. </title> <note> Available electronically, </note> <year> 1996. </year>
Reference-contexts: This report describes the syntax and formal sematics of the Pict language. This document is not intended as a tutorial on Pict programming, and makes no attempt to explain or motivate the Pict language design. Interested readers are directed to the Pict tuturial <ref> [Pie96] </ref>, the Pict compiler documentation [PT97a], the Pict standard libraries manual [PT97c], and a high-level survey of the Pict language design [PT97b]. Pict is an experimental language, and we welcome any comments or suggestions as to how we might improve the language itself or our presentation of its formal semantics.
Reference: [PS96] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1996. </year> <note> To appear. A preliminary version appeared in IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), June 1994, and as University of Edinburgh technical report ECS-LFCS-94-280 and Universitat Erlangen-Nurnberg Interner Bericht IMMD7-01/94, </note> <month> January </month> <year> 1994. </year>
Reference-contexts: This requires that the context be carried through the definition of the reduction relation, extending with the abbreviation binders that are in scope at each point|so that, for example, 24 Pict Language Definition 25 [#X=Int ^X] = [#X=Int ^Int]. (See <ref> [PS96] </ref> for more details.) The rules for with and where types can be thought of as derived forms for these constructs. <p> (FK-Bound) ` T 2 K (FK-Equal) Chapter 8 Subtyping The subtyping relation determines when a value may be used in a context expecting a value with a "less informative" type. 8.1 Judgement Forms The main subtyping judgement, ` S &lt; T, is familiar from standard presentations of F ! (e.g., <ref> [Car90, PS96] </ref>).
Reference: [PT97a] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus, 1997. Compiler, documentation, demonstration programs, and standard libraries; available electronically. </title>
Reference-contexts: This report describes the syntax and formal sematics of the Pict language. This document is not intended as a tutorial on Pict programming, and makes no attempt to explain or motivate the Pict language design. Interested readers are directed to the Pict tuturial [Pie96], the Pict compiler documentation <ref> [PT97a] </ref>, the Pict standard libraries manual [PT97c], and a high-level survey of the Pict language design [PT97b]. Pict is an experimental language, and we welcome any comments or suggestions as to how we might improve the language itself or our presentation of its formal semantics.
Reference: [PT97b] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus. </title> <type> Technical report, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <title> To appear in Milner Festschrift, </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Interested readers are directed to the Pict tuturial [Pie96], the Pict compiler documentation [PT97a], the Pict standard libraries manual [PT97c], and a high-level survey of the Pict language design <ref> [PT97b] </ref>. Pict is an experimental language, and we welcome any comments or suggestions as to how we might improve the language itself or our presentation of its formal semantics.
Reference: [PT97c] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict libraries manual. </title> <note> Available electronically, </note> <year> 1997. </year>
Reference-contexts: This document is not intended as a tutorial on Pict programming, and makes no attempt to explain or motivate the Pict language design. Interested readers are directed to the Pict tuturial [Pie96], the Pict compiler documentation [PT97a], the Pict standard libraries manual <ref> [PT97c] </ref>, and a high-level survey of the Pict language design [PT97b]. Pict is an experimental language, and we welcome any comments or suggestions as to how we might improve the language itself or our presentation of its formal semantics.
Reference: [Rep91] <author> John Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 293-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: By analogy, then, one may wonder what kind of high-level programming language can be constructed from the -calculus. ML, Haskell, . . . -calculus = -calculus A number of programming language designs have combined -calculus-like communication with a functional core language <ref> [Rep91, BMT92, Mat91, GMP89, Hol83, Car86, Ber93, etc.] </ref>, but none have gone so far as to take communication as the sole mechanism of computation.
Reference: [San92] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1992. </year>
Reference: [San93] <author> Davide Sangiorgi. </author> <title> An investigation into functions as processes. </title> <booktitle> In Proc. Ninth International Conference on the Mathematical Foundations of Programming Semantics (MFPS'93), volume 802 of Lecture Notes in Computer Science, </booktitle> <pages> pages 143-159. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference: [San94a] <author> Davide Sangiorgi. </author> <title> The lazy lambda calculus in a concurrency scenario. </title> <journal> Information and Computation, </journal> <volume> 111(1) </volume> <pages> 120-153, </pages> <year> 1994. </year>
Reference: [San94b] <author> Davide Sangiorgi. </author> <title> Locality and non-interleaving semantics in calculi for mobile processes. </title> <type> Technical Report ECS-LFCS-94-282, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1994. </year> <title> An extract appeared in Proc. </title> <booktitle> TACS '94, Lecture Notes in Computer Science 789, </booktitle> <publisher> Springer Verlag. </publisher>
Reference: [Wal94] <author> David Walker. </author> <title> Algebraic proofs of properties of objects. </title> <booktitle> In Proceedings of European Symposium on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [Wal95] <author> David Walker. </author> <title> Objects in the -calculus. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 253-271, </pages> <year> 1995. </year>
References-found: 33

