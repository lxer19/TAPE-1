URL: ftp://ftp.eecs.umich.edu/groups/gasm/softdev.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: boerger@di.unipi.it)  luca@tex.odd.it)  
Title: Integrating ASMs into the Software Development Life Cycle  
Author: Egon Borger Luca Mearelli 
Keyword: Key Words: Programming Techniques, Requirement Specification, Stepwise Refinement, Code Documentation, Code Inspection, Program Verification, Model Checking, Abstract State Machines.  
Note: Category: D.1, D.1.3, D.1.5, D.2.1, D.2.4, D.2.5  
Address: Pisa, Italy  Pisa, Italy  
Affiliation: (Universita di  (Universita di  
Abstract: In this paper we show how to integrate the use of Gurevich's Abstract State Machines (ASMs) into a complete software development life cycle. We present a structured software engineering method which allows the software engineer to control efficiently the modular development and the maintenance of well documented, formally inspectable and smoothly modifiable code out of rigorous ASM models for requirement specifications. We show that the code properties of interest (like correctness, safety, liveness and performance conditions) can be proved at high levels of abstraction by traditional and reusable mathematical arguments which|where needed|can be computer verified. We also show that the proposed method is appropriate for dealing in a rigorous but transparent manner with hardware-software co-design aspects of system development. The approach is illustrated by developing a C ++ program for the production cell control problem posed in [Lewerentz, Lindner 95]. The program has been validated by extensive experimentation with the FZI production cell simulator in Karlsruhe and has been submitted for inspection to the Dagstuhl seminar on "Practical Methods for Code Documentation and Inspection" (May 1997). 
Abstract-found: 1
Intro-found: 1
Reference: [Abramsky 97] <author> Abramsky, S.: </author> <title> "Semantics of Interaction"; Pitts, </title> <editor> A., Dybjer, P. </editor> <booktitle> (eds),"Semantics and Logics of Computation", Proceedings of the Newton Institute, </booktitle> <publisher> Cambridge University Press 1997. </publisher>
Reference-contexts: Morevore, once languages with features beyond the purely functional are considered, the appropriateness of modeling programs by functions is increasingly open to question. Neither concur-rency nor `advanced' imperative features have been captured denotationally in a fully convincing fashion (see <ref> [Abramsky 97] </ref>).
Reference: [Abrial,Borger,Langmaack 96] <editor> Abrial, J.-R., Borger, E., Langmaack, H. (eds.): </editor> " <booktitle> Formal Methods for Industrial Applications (Specifying and Programming the Steam-Boiler Control)"; Springer LNCS State-of-the-Art Survey 1165 (1996), </booktitle> <address> VIII+511. </address>
Reference-contexts: extendability through easy adaptations of ASMs to evolving requirement specifications; this is particularly important due to the experience of various formal method case studies that "even problems of modest real world complexity are just within the current limits of available automatic proof tools and model-checkers" (see [Lewerentz, Lindner 95b]; see <ref> [Abrial,Borger,Langmaack 96] </ref> where the same experience is reported).
Reference: [Bharadwaj,Heitmeyer 97] <author> Bharadwaj, R., Heitmeyer, C.: </author> <title> "Verifying SCR Requirements Specifications Using State Exploration"; Proc. </title> <booktitle> First ASM SIGPLAN Workshop on Automatic Analysis of Software, </booktitle> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: The same idea to use abstraction to contain the state explosion for model checking has been applied recently to the SCR method (see <ref> [Bharadwaj,Heitmeyer 97] </ref>). The hierarchy of refined models, together with the proofs of the correctness of the implementations relating the different levels, constitute a full documentation of the result of the whole structured software development and make the executable code amenable to rigorous inspection.
Reference: [Beierle et al. 96] <author> Beierle, C., Borger, E., Durdanovic, I., Glasser, U., Riccobene, </author> <title> E.:"Refining abstract machine specifications of the steam boiler control to well documented executable code"; Abrial, </title> <editor> J.-R., Borger, E., Langmaack, H. (Eds.), </editor> <title> Formal Methods for Industrial Applications (Specifying and Programming the Steam-Boiler Control), </title> <booktitle> Springer LNCS State-of-the-Art Survey 1165 (1996), </booktitle> <pages> 52-78. </pages>
Reference-contexts: The possibility offered by the ASM approach to support a theoretically sound but nevertheless simple and practical integration of different methods for different concerns|code development, mathematical or machine verification and documentation|is a distinctive feature of the method (see <ref> [Beierle et al. 96] </ref> for its application to the Steam Boiler Control case study). Just one comparison must suffice here as example to illustrate this claim.
Reference: [Borger 94] <author> Borger, </author> <title> E.:"Logic Programming: The Evolving Algebra Approach"; Pehrson, </title> <editor> B., Simon, I. (Eds.), </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: </booktitle> <address> Technology/Foundations, </address> <publisher> Elsevier, </publisher> <address> Amsterdam (1994), </address> <pages> 391-395. </pages>
Reference-contexts: A survey and a methodological motivation for the new ASM approach in comparison to other specification and verification approaches can be found in [Borger 95]; see also <ref> [Borger 94] </ref>, the annotated ASM bibliography [Borger 95a], the most recent work appearing in this and the previous J.UCS special ASM issue and the two ASM home pages http://www.uni-paderborn.de/cs/asm.html and http://www.eecs.umich.edu/gasm/. <p> Parnas, P. Joannou and the first author from May 12-16, 1997. 1.1 The Main Development Steps Specification. As starting point we define a ground model (in the sense of <ref> [Borger 94] </ref>) which is rigorous but transparent and concise and can be convincingly shown to faithfully reflect the production cell as informally specified in [Lindner 95]. <p> One can adopt automatic translations between these semantically equivalent notations. 3 The Ground Model The purpose of the first production cell model GroundCELL, a ground model in the sense of <ref> [Borger 94] </ref>, is to produce an application oriented rigorous formulation of the informal description which allows one to justify that this formalization provides a correct model of the desired system.
Reference: [Borger 95] <author> Borger, </author> <title> E.:"Why Use Evolving Algebras for Hardware and Software Engineering?", </title> <editor> Bartosek, M., Staudek, J., Wiedermann, J.(Eds), </editor> <booktitle> SOFSEM'95 (22nd Seminar on Current Trends in Theory and Practice of Informatics); Springer LNCS 1012 (1995), </booktitle> <pages> 236-271. </pages>
Reference-contexts: A survey and a methodological motivation for the new ASM approach in comparison to other specification and verification approaches can be found in <ref> [Borger 95] </ref>; see also [Borger 94], the annotated ASM bibliography [Borger 95a], the most recent work appearing in this and the previous J.UCS special ASM issue and the two ASM home pages http://www.uni-paderborn.de/cs/asm.html and http://www.eecs.umich.edu/gasm/. <p> This is not the place to discuss the reasons why this argument is misleading when we are looking for an appropriate treatment of the dynamics of complex computation systems (see <ref> [Borger 95] </ref>); here we have to limit ourselves to remarking that the belief in this dichotomy has proved not to be helpful for filling, in any rigorous but nevertheless practical way, the huge gap between abstract system views and their implementations. <p> Acknowledgements. We thank Peter Pappinghaus for his help in elaborating the classification of functions which appeared in <ref> [Borger 95] </ref>.
Reference: [Borger 95a] <author> Borger, E.: </author> <title> "Annotated Bibliography on Evolving Algebras"; Borger, </title> <editor> E. (ed.), </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press (1995) 37-51. </publisher>
Reference-contexts: A survey and a methodological motivation for the new ASM approach in comparison to other specification and verification approaches can be found in [Borger 95]; see also [Borger 94], the annotated ASM bibliography <ref> [Borger 95a] </ref>, the most recent work appearing in this and the previous J.UCS special ASM issue and the two ASM home pages http://www.uni-paderborn.de/cs/asm.html and http://www.eecs.umich.edu/gasm/.
Reference: [Borger 96] <author> Borger, E.: </author> " <title> Evolving algebras and Parnas tables"; Ehrig, </title> <editor> H., von Henke, F., Meseguer, J., Wirsing, M. (eds), </editor> <title> Specification and Semantics, </title> <booktitle> Dagstuhl Seminar Report 1996. </booktitle>
Reference-contexts: It will help if the reader is familiar with the semantics of Abstract State Machines, defined in [Gurevich 95]. We could have used also Parnas' tabular notation [Parnas, Madey 95] for which a simple but rigorous semantics can be given in terms of ASMs (see <ref> [Borger 96] </ref>). However what follows can be understood correctly also by reading our ASM rules as pseudo-code over abstract data types. We therefore point here only to some of the basic ASM features.
Reference: [Borger,Durdanovic 96] <author> Borger, E., Durdanovic, I.: </author> <title> "Correctness of Compiling Occam to Transputer Code"; The Computer Journal 39,1 (1996), </title> <type> 52-92. </type>
Reference-contexts: Such scheduling principles are easily dealt with at a high level of abstraction; see <ref> [Borger,Durdanovic 96] </ref> where this idea has been developed for the (correctness proof of the) sequentialization of Occam programs as part of their implementation by Transputer code.
Reference: [Borger et al. 95] <author> Borger, E. , Gurevich, Y., Rosenzweig, D.: </author> <title> "The Bakery Algorithm: Yet Another Specification and Verification"; Borger, E.(ed), Specification and Validation Methods, </title> <publisher> Oxford University Press (1995), </publisher> <pages> 231-243. </pages>
Reference-contexts: what happens in the simulator (where the actuators are just started and stopped by the controller to trigger or halt the devices) and in accordance with the fact that ASM rules are atomic, i.e. "executed in zero time" (although there are natural ways to describe durative actions with ASMs, see <ref> [Borger et al. 95] </ref> where durative actions of distributed agents are reduced to atomic actions). <p> Also the real-time properties proposed in another extension (see [Lotzbeyer 96b]) can be incorporated into our models using techniques from <ref> [Borger et al. 95, Gurevich, Huggins 96] </ref>).
Reference: [Borger, Mazzanti 97] <author> Borger, E., Mazzanti, </author> <title> S.:"A Practical Method for Rigorously Controllable Hardware Design"; Bowen, </title> <editor> J.P., Hinchey, M.G., Till, D. (eds), ZUM'97: </editor> <title> The Z Formal Specification Notation, </title> <publisher> Springer LNCS 1212 (1997), </publisher> <pages> 151-187. </pages>
Reference-contexts: Updatable functions are controlled or interaction functions, non updatable functions are static, monitored or derived. In applications it is sometimes useful to adopt the preceding classification with respect to update locations (i.e. particular arguments of a function) or with respect to specific function values (see <ref> [Borger, Mazzanti 97] </ref> for an example), but we will not need this for the production cell. For boolean-valued functions b we often write b (x) instead of b (x)=true and not b (x) or :b (x) instead of b (x)=false.
Reference: [Borger, Rosenzweig 94] <author> Borger, E., Rosenzweig, D.: </author> <title> "The WAM Definition and Compiler Correctness"; Beierle, </title> <editor> C., Plumer, L.(Eds.), </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, North-Holland, Series in Computer Science and Artificial Intelligence (1994), </booktitle> <pages> 20-90 </pages>
Reference-contexts: However standard mathematical proofs accompanying the development of stepwise refined ASMs are amenable to further detailing through mechanization in machine based proof systems. An illustrative example for such an endeavour is the complete verification of the ASM based WAM correctness proof in <ref> [Borger, Rosenzweig 94] </ref> which used the interactive theorem prover KIV and is partially reported in this volume (see [Schellhorn, Ahrendt 97]); for another machine verification of this proof which uses ISABELLE see [Pusch 96]. <p> This approach has been used with success for integrating the Prolog error handling mechanism into the ASM definition of the ISO Prolog standard semantics (see <ref> [Borger, Rosenzweig 94] </ref>). Our ASM models come with some useful object oriented features resembling 652 Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle those reported in the object oriented solutions in [Lewerentz, Lindner 95].
Reference: [Borger, Rosenzweig 94] <author> Borger, E., Rosenzweig, D.: </author> <booktitle> "A Mathematical Definition of Full Prolog"; Science of Computer Programming 24 (1995), </booktitle> <pages> 249-286. </pages>
Reference-contexts: However standard mathematical proofs accompanying the development of stepwise refined ASMs are amenable to further detailing through mechanization in machine based proof systems. An illustrative example for such an endeavour is the complete verification of the ASM based WAM correctness proof in <ref> [Borger, Rosenzweig 94] </ref> which used the interactive theorem prover KIV and is partially reported in this volume (see [Schellhorn, Ahrendt 97]); for another machine verification of this proof which uses ISABELLE see [Pusch 96]. <p> This approach has been used with success for integrating the Prolog error handling mechanism into the ASM definition of the ISO Prolog standard semantics (see <ref> [Borger, Rosenzweig 94] </ref>). Our ASM models come with some useful object oriented features resembling 652 Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle those reported in the object oriented solutions in [Lewerentz, Lindner 95].
Reference: [Brauer, Lindner 95] <editor> Brauer, A., Lindner, T.: </editor> <publisher> "Simulation"; Springer LNCS 891 (1995), </publisher> <pages> 273-284 </pages>
Reference-contexts: loading feed belt phase when GripperVerticalPos = OnFeedBelt ). 5 The Refinement to C ++ Code In this section we introduce the refinement of the ASM RefinedCELL to a C ++ program which we have shown by extensive experimentation to control successfully the simulation of the production cell (proposed in <ref> [Brauer, Lindner 95] </ref> as a validation environment for the specifications and the implementations). Based upon the ASM definition of the semantics of C ++ (see [Wallace 95]) one also has the possibility to prove, by a detailed mathematical argument, that Refined-CELL is correctly implemented by the C ++ program. <p> Then each machine|declared to be an object from the corresponding class|gets its updated sensors readings from the standard input, in the order specified by the status vector in the simulator (see <ref> [Brauer, Lindner 95] </ref>), and eventually reacts updating its internal status and outputting the required commands. Finally the errors provided through the last vector element are taken by the controller from the input stream and processed.
Reference: [Damm et al. 95] <author> Damm, W., Hungar, H., Kelb, P., Schlor, R.: </author> <booktitle> "Statecharts"; Springer LNCS 891 (1995), </booktitle> <pages> 131-150. </pages>
Reference-contexts: Our ASM models are considerably simpler than the numerous finite state machine or transition system based models in [Lewerentz, Lindner 95]. To mention just one concrete example we suggest to compare the ASM models (and their graphical visualization) for the elevating rotary table with the corresponding statechart specification (see <ref> [Damm et al. 95, pages 135-138] </ref>); the authors admit that "the conditions of the transitions are very complex" so that they could not be layed down graphically, missing already for the specification of such a simple device one of the declared "key features of the presented approach", namely "the use of
Reference: [Del Castillo et al. 96] <author> Del Castillo, G., Durdanovic, I., Glasser, U.: </author> <title> "An evolving algebra abstract machine"; Kleine Buning, </title> <editor> H. (ed), </editor> <booktitle> Computer Science Logic, </booktitle> <publisher> Springer LNCS 1092 (1996), </publisher> <pages> 191-214. </pages> <note> See "Available Tools" on http://www.uni-paderborn.de/cs/asm.html. 654 Boerger E., </note> <author> Mearelli L.: </author> <title> Integrating ASMs into the Software Development Life Cycle </title>
Reference-contexts: E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle for capturing informal requirements by appropriate|correct, concise, transpar-ent and flexible|formalizations); it supports incremental development by the systematic use of stepwise refinement; it allows one to simulate abstract models to validate these specifications (see [Pappinghaus 97] where the Paderborn machine <ref> [Del Castillo et al. 96] </ref> for executing ASMs is used); it shows how to turn the informal reasoning and the application domain driven explanations|which necessarily accompany every design|into a precise mathematical form which makes them accessible to (mental or machine) falsifiability experiments; it can integrate the use of machine support (type/model
Reference: [Gurevich 95] <author> Gurevich, Y.: </author> <title> "Evolving Algebras 1993: Lipari Guide"; Borger, </title> <editor> E. (ed.), </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press (1995) 9-36. </publisher>
Reference-contexts: 1 Introduction Gurevich's Abstract State Machines (previously called evolving algebras, see <ref> [Gurevich 95] </ref>) have been used successfully to specify real-life programming languages (e.g. Prolog, C ++ , VHDL, Oberon) and architectures (e.g. PVM, Trans-puter, DLX, APE100), to validate standard language implementations (e.g. of Prolog on the WAM, of Occam on the Transputer), to verify numerous distributed and real-time protocols, etc.. <p> It will help if the reader is familiar with the semantics of Abstract State Machines, defined in <ref> [Gurevich 95] </ref>. We could have used also Parnas' tabular notation [Parnas, Madey 95] for which a simple but rigorous semantics can be given in terms of ASMs (see [Borger 96]). However what follows can be understood correctly also by reading our ASM rules as pseudo-code over abstract data types. <p> This intuitive idea of runs of distributed ASMs should suffice for the purposes of this paper. For a precise definition see <ref> [Gurevich 95] </ref>. For a good understanding of how the distributed nature of the production cell is reflected in our models we define here the following classification of functions which is suggested by the concept of ASMs and has proved to be particularly convenient for applications. <p> For boolean-valued functions b we often write b (x) instead of b (x)=true and not b (x) or :b (x) instead of b (x)=false. Sometimes we will take advantage of the Self function introduced in the definition of distributed ASMs in <ref> [Gurevich 95] </ref> to parameterize the agent specific functions. When the agent Self is clear from the context, we will omit mentioning it. An example is the function pair Bottom/TopPosition which appears below with parameters ERT (for the elevating rotary table in the production cell) and Press (for the press). <p> Neither concur-rency nor `advanced' imperative features have been captured denotationally in a fully convincing fashion (see [Abramsky 97]). In comparison, the ASM concept is operational but abstract; it has a simple theoretical foundation, described in <ref> [Gurevich 95] </ref> starting from scratch and understandable by the working computer scientist without any theoretical prerequisites; the method based on this concept reflects and supports current practice and therefore can be applied as is at each level of the software development life cycle.
Reference: [Gurevich, Huggins 96] <author> Gurevich, Y., Huggins, J.: </author> <title> "The Railroad Crossing Problem: An Experiment with Instantaneous Actions and Immediate Reactions"; Kleine Buning, </title> <editor> H. (ed), </editor> <booktitle> Computer Science Logic, </booktitle> <publisher> Springer LNCS 1092 (1996), </publisher> <pages> 266-290 </pages>
Reference-contexts: Therefore we too make this assumption. This simplifies the task although ASMs have no difficulty of principle to deal with real-time conditions (see <ref> [Gurevich, Huggins 96] </ref> where ASM agents perform instantaneous actions in continuous time). In the following subsections we define separately each of the six sequential component ASMs which, put together as distributed ASM, constitute the ground cell GroundCELL. <p> Also the real-time properties proposed in another extension (see [Lotzbeyer 96b]) can be incorporated into our models using techniques from <ref> [Borger et al. 95, Gurevich, Huggins 96] </ref>).
Reference: [Hall 97] <editor> Hall, A.: "Taking Z Seriously"; Bowen, J.P., Hinchey, M.G., Till, D. (eds), ZUM'97: </editor> <title> The Z Formal Specification Notation, </title> <publisher> Springer LNCS 1212 (1997) 89-91. </publisher>
Reference-contexts: at the 1997 Z User Meeting where he said that "the most important characteristic of Z, which singles it out from every other formal method, is that it is completely divorced from computation" which "means that you can use logic (otherwise known as ordinary language) to define your requirements" (see <ref> [Hall 97] </ref>). Paraphrasing this we would say that the most important characteristic of the ASM approach, which really singles it out from every other formal method, is that it allows us to happily marry the use of logic and of abstract computations. <p> Of course we may find ourselves re-introducing Z or Z-like specifications of modules in the design..."(see <ref> [Hall 97] </ref>).
Reference: [Heinkel, Lindner 95] <author> Heinkel, S., Lindner T. </author> <booktitle> :"SDL"; Springer LNCS 891 (1995), </booktitle> <pages> 171-183. </pages>
Reference-contexts: Some solutions have put a particular emphasis on exhibiting how to support modifiability and reuse during the design process. For example in the SDL specification (see <ref> [Heinkel, Lindner 95] </ref>) the belts have been designed as instantiations or modifications of a "general" belt, similar uniformisations have been proposed for the vertical and horizontal moves (of the robot and the crane) and for the rotation (of the robot and the table).
Reference: [Heitmeyer 97] <author> Heitmeyer, C.L.: </author> <title> "Formal Methods: A Panacea or Academic Poppycock?"; Bowen, </title> <editor> J.P. , Hinchey, M.G. , Till, D. (eds), ZUM'97: </editor> <title> The Z Formal Specification Notation, </title> <publisher> Springer LNCS 1212 (1997), </publisher> <pages> 3-9. </pages>
Reference-contexts: The ASM method for structured software engineering therefore respects the guidelines for applying formal methods proposed in <ref> [Heitmeyer 97] </ref>.
Reference: [Lewerentz, Lindner 95] <author> Lewerentz C., Lindner T. (eds.):" </author> <title> Formal Development of Reactive Systems. Case Study "Production Cell""; Springer LNCS 891 (1995). </title>
Reference-contexts: Co. the proposed structured software engineering approach by developing the au-tomation software for a reactive distributed system, namely a C ++ program to control the production cell introduced in <ref> [Lewerentz, Lindner 95] </ref> as case study derived from "an actual industrial installation in a metal-processing plant in Karlsruhe" to obtain a "realistic, comparative survey" for testing "the usefulness of formal methods for critical software systems and to prove their applicability to real-world examples" [Lindner 95]. <p> We refer to such assumptions generically as Cell Assumption. For the geometrical layout of the production cell see the picture in the appendix. All the approaches reported in <ref> [Lewerentz, Lindner 95] </ref> to which we suggest to compare our solution assume that the reaction of the control software is sufficiently fast to fulfill the appropriate timing requirements. Therefore we too make this assumption. <p> One way to avoid the problem is to allow a nondeterministic choice for the order of the robot actions (with the side effect that the maximal throughput of blanks is 8 instead of 7, see the TLT solution in <ref> [Lewerentz, Lindner 95] </ref> and the proof for the strong performance property below). 3.3.2 The Safety Properties At this level of abstraction we can state robot safety requirements by defining abstract functions modeling the physical movements of the robot (rotating its base, extending/retracting its arms and switching on/off its magnets) and prove <p> There are different ways to prove this Liveness property. Most of the solutions presented in <ref> [Lewerentz, Lindner 95] </ref> succeeded to prove only weaker forms of liveness, like for example that at each moment at least one of the machines composing the cell is not stopped. <p> Development Life Cycle The reader can find the complete refinement to C ++ modules in [Mearelli 97]. 6 Evaluation and Conclusions We answer here the questions posed in [Lindner 95] to evaluate the proposed problem solution and compare from the methodological point of view our solution to the solutions in <ref> [Lewerentz, Lindner 95] </ref>. 6.1 Answers to the Evaluation Questions We have proved (for the formal requirement specification model and for the refined model) all the required safety, liveness and performance properties and have established without difficulties the maximal throughput of the system (a property which the informal task description declares to <p> The reader may enjoy to verify this claim. 6.2 Comparison to Other Solutions [Lewerentz, Lindner 95b] contains a detailed comparative survey of the solutions in <ref> [Lewerentz, Lindner 95] </ref> so that we limit ourselves to mention only the salient features which distinguish them from the ASM solution proposed here. Our ASM models are considerably simpler than the numerous finite state machine or transition system based models in [Lewerentz, Lindner 95]. <p> contains a detailed comparative survey of the solutions in <ref> [Lewerentz, Lindner 95] </ref> so that we limit ourselves to mention only the salient features which distinguish them from the ASM solution proposed here. Our ASM models are considerably simpler than the numerous finite state machine or transition system based models in [Lewerentz, Lindner 95]. <p> Our ASM models come with some useful object oriented features resembling 652 Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle those reported in the object oriented solutions in <ref> [Lewerentz, Lindner 95] </ref>. Basic object oriented features are inherent in the data and action abstraction mechanism of ASMs and have facilitated the transition from the refined ASM model to structured C ++ code.
Reference: [Lewerentz, Lindner 95a] <author> Lewerentz, C., Lindner, T.: </author> <booktitle> "Introduction"; Springer LNCS 891 (1995), </booktitle> <pages> 3-8. </pages>
Reference-contexts: We explain here only the overall structure of the translation to C ++ code and refer for the details to [Mearelli 97] which contains, for a complete documentation of this last refinement step, the entire executable controller. 5.1 The Structure of the Control Program The informal task desciption (see <ref> [Lewerentz, Lindner 95a] </ref>) requires that the control : : : program ... reads sensor values from UNIX stdin and writes its control commands to stdout according to standardized ASCII protocol.
Reference: [Lewerentz, Lindner 95b] <author> Lewerentz C., Lindner T. </author> :" <booktitle> Comparative Survey"; Springer LNCS 891 (1995), </booktitle> <pages> 21-54. </pages>
Reference-contexts: It has to be judged against the well known fact that purely mechanical methods like logical deduction (theorem proving) and symbolic model checking face scalability problems for applications which are beyond the complexity of relatively simple cases like the production cell (see the evidence reported in <ref> [Lewerentz, Lindner 95b] </ref>). However standard mathematical proofs accompanying the development of stepwise refined ASMs are amenable to further detailing through mechanization in machine based proof systems. <p> This would make the task of writing a control program much easier, and the programs running on the local microprocessors could easier be verified. (see <ref> [Lewerentz, Lindner 95b] </ref>) In effect the simplicity of our ground model is partly due to this abstraction from motors which allows us to issue to the agents such abstract moving commands, namely in the form of the updates currPhase (agent):=MovingTo.... <p> Since ASMs offer the possibility of a satisfactory solution for the ground model problem, the ASM approach can be used as a candidate "for intuitive and adequate formalisms that allow for building models which closely simulate reality and support discussions with the customer" (see <ref> [Lewerentz, Lindner 95b] </ref>). <p> design flexibility, re-usability and extendability through easy adaptations of ASMs to evolving requirement specifications; this is particularly important due to the experience of various formal method case studies that "even problems of modest real world complexity are just within the current limits of available automatic proof tools and model-checkers" (see <ref> [Lewerentz, Lindner 95b] </ref>; see [Abrial,Borger,Langmaack 96] where the same experience is reported). <p> Also the real-time properties proposed in another extension (see [Lotzbeyer 96b]) can be incorporated into our models using techniques from [Borger et al. 95, Gurevich, Huggins 96]). The reader may enjoy to verify this claim. 6.2 Comparison to Other Solutions <ref> [Lewerentz, Lindner 95b] </ref> contains a detailed comparative survey of the solutions in [Lewerentz, Lindner 95] so that we limit ourselves to mention only the salient features which distinguish them from the ASM solution proposed here.
Reference: [Lindner 95] <author> Lindner. T.: </author> <booktitle> "Task Description"; Springer LNCS 891 (1995), </booktitle> <pages> 9-21. </pages>
Reference-contexts: Co. the proposed structured software engineering approach by developing the au-tomation software for a reactive distributed system, namely a C ++ program to control the production cell introduced in <ref> [Lewerentz, Lindner 95] </ref> as case study derived from "an actual industrial installation in a metal-processing plant in Karlsruhe" to obtain a "realistic, comparative survey" for testing "the usefulness of formal methods for critical software systems and to prove their applicability to real-world examples" [Lindner 95]. <p> to control the production cell introduced in [Lewerentz, Lindner 95] as case study derived from "an actual industrial installation in a metal-processing plant in Karlsruhe" to obtain a "realistic, comparative survey" for testing "the usefulness of formal methods for critical software systems and to prove their applicability to real-world examples" <ref> [Lindner 95] </ref>. The specification together with its refinement to executable code (see [Mearelli 97]) have been submitted for inspection to the participants of the Dagstuhl seminar on "Practical Methods for Code Documentation and Inspection" organized by D. Parnas, P. <p> As starting point we define a ground model (in the sense of [Borger 94]) which is rigorous but transparent and concise and can be convincingly shown to faithfully reflect the production cell as informally specified in <ref> [Lindner 95] </ref>. <p> We start in an object-oriented spirit by defining what are the basic objects composing the system, their basic operations and interactions. Our method is to extract these items from the informal task description (see <ref> [Lindner 95] </ref>). : : : the production cell is composed of two conveyor belts, a positioning table, a two-armed robot, a press, and a travelling crane. Metal plates inserted in the cell via the feed belt are moved to the press. <p> We refer to such assumptions generically as Cell Assumption. For the geometrical layout of the production cell see the picture in the appendix. All the approaches reported in <ref> [Lewerentz, Lindner 95] </ref> to which we suggest to compare our solution assume that the reaction of the control software is sufficiently fast to fulfill the appropriate timing requirements. Therefore we too make this assumption. <p> to land on the elevating rotary table|provided of course that the latter machine is correctly positioned ... the feed belt may only convey a blank through its light barrier, if the table is in loading position ... do not put blanks on the table, if it is already loaded ... <ref> [Lindner 95] </ref> We formalize this description by abstracting from the motors (see the remark in the section on the press ground model) which yields an automaton with three states (phases). <p> We leave it as an exercise to play with the simple variations which suffice to reflect such hardware/software co-design decisions and to compare their result. We illustrate that the feed belt safety property required by <ref> [Lindner 95] </ref> can be easily proved at the level of abstraction of this ground model ASM Feed Belt. Feed Belt Safety Property . The feed belt does not put metal blanks on the table if the latter is already loaded or not stopped in loading position. Proof. <p> The rotation of the table is also required, because the arm's gripper is not rotary and is therefore unable to place the metal plates into the press in a straight position by itself. <ref> [Lindner 95] </ref> In the ground model for the elevating rotary table we abstract from the motors and from the particular movements (rotation and lifting) which are performed in order to bring each blank from the position where it has been loaded by the feed belt to the position where it can <p> The end of each robot arm is fitted with an electromagnet that allows the arm to pick up metal plates. The robot's task consists in: taking metal blanks from the elevating rotary table to the press; transporting forged plates from the press to the deposit belt. <ref> [Lindner 95] </ref> Abstraction from the motors and from the details of the movements yields four basic robot actions: unload the table/press and load the press/deposit belt. <p> In the task description <ref> [Lindner 95] </ref> a solution is suggested that ensures minimal movements of the robot; the sequence of movements is determined on the basis of the relative positions of table, robot, press and deposit belt, and apparently yields a good usage of the press, letting the robot be ready to load the press <p> One way to avoid the problem is to allow a nondeterministic choice for the order of the robot actions (with the side effect that the maximal throughput of blanks is 8 instead of 7, see the TLT solution in <ref> [Lewerentz, Lindner 95] </ref> and the proof for the strong performance property below). 3.3.2 The Safety Properties At this level of abstraction we can state robot safety requirements by defining abstract functions modeling the physical movements of the robot (rotating its base, extending/retracting its arms and switching on/off its magnets) and prove <p> These assumptions will then be used as integrity constraints to guide the refinement steps. The reader who is interested only in the specification and not in the proofs of the system properties may skip this section. The description given in <ref> [Lindner 95] </ref> for the rotation operations performed by the robot arms can be axiomatized by using two functions RobotRotationMot (describing the robot rotation, i.e. the action of the motor driving the robot base) and Angle (for the potentiometer indicating how far the robot has rotated). <p> Arm1ToPress From the initialization condition Angle = Arm1ToTable and these two assumptions we can prove the robot safety requirements that the robot must not be rotated clockwise, if arm 1 points towards the elevating rotary table, and it must not be rotated counterclockwise if arm 1 points to the press <ref> [Lindner 95] </ref>. Robot Safety Property 1 .The robot never rotates over its bounds. Proof. By induction on robot runs. For the base of the induction the claim holds by initialization. <p> are required for the avoidance of collisions between the first arm and the table, and between the second arm and the deposit belt: : : : In order to meet the various safety requirements ... a robot arm must retract whenever a processing step were it is involved is completed. <ref> [Lindner 95] </ref> Stated otherwise, the arms should extend only when required to pick up or to drop a piece. <p> Move the lower plate to the middle position and wait until arm 1 has loaded and left the press, 3. Close the press, i.e. forge the metal plate. This processing sequence is carried out cyclically. <ref> [Lindner 95] </ref> The press goes through the cycle of loading, forging and unloading under the control of the robot which loads it with blanks and retrieves forged pieces. <p> The informal specification provides no means to know when the forging process is completed. We model this through a monitored function ForgingCompleted whose values are determined by the physical environment. (In the toy model presented in <ref> [Lindner 95] </ref> no forging is actually performed so ForgingCompleted is immediately true once the press has entered the ClosedForForging phase.) Remark. <p> Just after the plate has completely passed through it, the light barrier switches off. At this precise moment, the plate is in the correct position to be picked up by the traveling crane ... <ref> [Lindner 95] </ref> The deposit belt is similar to the feed belt but has not to worry about the passage of the piece to the next machine because the traveling crane takes care about that. <p> The gripper transports the metal plate to the feed belt and unloads it there. <ref> [Lindner 95] </ref> Unloading the deposit belt and loading the feed belt can be formalized by two groups of rules which are similar to the corresponding rule groups for the robot and use similar monitored functions ActionCompleted and ActionPosReached. <p> There are different ways to prove this Liveness property. Most of the solutions presented in <ref> [Lewerentz, Lindner 95] </ref> succeeded to prove only weaker forms of liveness, like for example that at each moment at least one of the machines composing the cell is not stopped. <p> loading feed belt phase when GripperVerticalPos = OnFeedBelt ). 5 The Refinement to C ++ Code In this section we introduce the refinement of the ASM RefinedCELL to a C ++ program which we have shown by extensive experimentation to control successfully the simulation of the production cell (proposed in <ref> [Brauer, Lindner 95] </ref> as a validation environment for the specifications and the implementations). Based upon the ASM definition of the semantics of C ++ (see [Wallace 95]) one also has the possibility to prove, by a detailed mathematical argument, that Refined-CELL is correctly implemented by the C ++ program. <p> Then each machine|declared to be an object from the corresponding class|gets its updated sensors readings from the standard input, in the order specified by the status vector in the simulator (see <ref> [Brauer, Lindner 95] </ref>), and eventually reacts updating its internal status and outputting the required commands. Finally the errors provided through the last vector element are taken by the controller from the input stream and processed. <p> is, cFeedBelt& fb) - is&gt;> fb.PieceInFeedBeltLightBarrier; fb.Where (); fb.Rules (); return is; -; 649Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle The reader can find the complete refinement to C ++ modules in [Mearelli 97]. 6 Evaluation and Conclusions We answer here the questions posed in <ref> [Lindner 95] </ref> to evaluate the proposed problem solution and compare from the methodological point of view our solution to the solutions in [Lewerentz, Lindner 95]. 6.1 Answers to the Evaluation Questions We have proved (for the formal requirement specification model and for the refined model) all the required safety, liveness and <p> Development Life Cycle The reader can find the complete refinement to C ++ modules in [Mearelli 97]. 6 Evaluation and Conclusions We answer here the questions posed in [Lindner 95] to evaluate the proposed problem solution and compare from the methodological point of view our solution to the solutions in <ref> [Lewerentz, Lindner 95] </ref>. 6.1 Answers to the Evaluation Questions We have proved (for the formal requirement specification model and for the refined model) all the required safety, liveness and performance properties and have established without difficulties the maximal throughput of the system (a property which the informal task description declares to <p> The reader may enjoy to verify this claim. 6.2 Comparison to Other Solutions [Lewerentz, Lindner 95b] contains a detailed comparative survey of the solutions in <ref> [Lewerentz, Lindner 95] </ref> so that we limit ourselves to mention only the salient features which distinguish them from the ASM solution proposed here. Our ASM models are considerably simpler than the numerous finite state machine or transition system based models in [Lewerentz, Lindner 95]. <p> contains a detailed comparative survey of the solutions in <ref> [Lewerentz, Lindner 95] </ref> so that we limit ourselves to mention only the salient features which distinguish them from the ASM solution proposed here. Our ASM models are considerably simpler than the numerous finite state machine or transition system based models in [Lewerentz, Lindner 95]. <p> Some solutions have put a particular emphasis on exhibiting how to support modifiability and reuse during the design process. For example in the SDL specification (see <ref> [Heinkel, Lindner 95] </ref>) the belts have been designed as instantiations or modifications of a "general" belt, similar uniformisations have been proposed for the vertical and horizontal moves (of the robot and the crane) and for the rotation (of the robot and the table). <p> Our ASM models come with some useful object oriented features resembling 652 Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle those reported in the object oriented solutions in <ref> [Lewerentz, Lindner 95] </ref>. Basic object oriented features are inherent in the data and action abstraction mechanism of ASMs and have facilitated the transition from the refined ASM model to structured C ++ code.
Reference: [Lotzbeyer 96a] <author> Lotzbeyer, A.: </author> <title> "Task Description of a Fault-Tolerant Production Cell"; FZI Karlsruhe, </title> <note> Version 1.6. </note> <year> (1996). </year>
Reference-contexts: connection it is interesting to observe that our ASM cell models can be easily extended to reflect the additional hardware (another press, more sensors for the two belts, for the table and the press, etc.) and the failure situations introduced in a recent fault-tolerant extension of the production cell (see <ref> [Lotzbeyer 96a] </ref>). Also the real-time properties proposed in another extension (see [Lotzbeyer 96b]) can be incorporated into our models using techniques from [Borger et al. 95, Gurevich, Huggins 96]).
Reference: [Lotzbeyer 96b] <author> Lotzbeyer, A.: </author> <title> "Task Description of a Flexible Production Cell with Real Time Properties"; FZI Karlsruhe, </title> <note> Version 2.1. </note> <year> (1996). </year>
Reference-contexts: Also the real-time properties proposed in another extension (see <ref> [Lotzbeyer 96b] </ref>) can be incorporated into our models using techniques from [Borger et al. 95, Gurevich, Huggins 96]).
Reference: [Mearelli 97] <author> Mearelli, </author> <title> L.:"Refining an ASM Specification for the Production Cell to C ++ Code"; J.UCS (Journal for Universal Computer Science), this volume. </title>
Reference-contexts: The specification together with its refinement to executable code (see <ref> [Mearelli 97] </ref>) have been submitted for inspection to the participants of the Dagstuhl seminar on "Practical Methods for Code Documentation and Inspection" organized by D. Parnas, P. Joannou and the first author from May 12-16, 1997. 1.1 The Main Development Steps Specification. <p> We explain here only the overall structure of the translation to C ++ code and refer for the details to <ref> [Mearelli 97] </ref> which contains, for a complete documentation of this last refinement step, the entire executable controller. 5.1 The Structure of the Control Program The informal task desciption (see [Lewerentz, Lindner 95a]) requires that the control : : : program ... reads sensor values from UNIX stdin and writes its control <p> false; Stopped = false; TableReadyForLoading = TableInLoadPosition && (!TableLoaded); -; friend istream& operator&gt;>(istream& is, cFeedBelt& fb) - is&gt;> fb.PieceInFeedBeltLightBarrier; fb.Where (); fb.Rules (); return is; -; 649Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle The reader can find the complete refinement to C ++ modules in <ref> [Mearelli 97] </ref>. 6 Evaluation and Conclusions We answer here the questions posed in [Lindner 95] to evaluate the proposed problem solution and compare from the methodological point of view our solution to the solutions in [Lewerentz, Lindner 95]. 6.1 Answers to the Evaluation Questions We have proved (for the formal requirement
Reference: [Nielson 96] <editor> Nielson, F. (Ed.): </editor> <booktitle> "ML With Concurrency"; Springer Monographs in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: Why not use right away the operational semantics for Concurrent ML (see <ref> [Nielson 96] </ref>)? The problem the FOCUS method has with applications derives from its commitment to the denotational cause: The classical denotational paradigm ... has some definite limitations.
Reference: [Nokel, Winkelmann 95] <author> Nokel, K., Winkelmann, K.: </author> <title> CSL.Controller Synthesis and Verification: A Case Study"; Lewerentz, </title> <editor> C., Lindner, T. (eds.), </editor> <booktitle> Formal Development of Reactive Systems. Case Study "Production Cell"; Springer LNCS 891 (1995), </booktitle> <pages> 55-74 </pages>
Reference-contexts: The above choice for the order of the robot actions is responsible for the Last Piece Problem discovered in <ref> [Nokel, Winkelmann 95] </ref> when trying to model check that when the press holds a piece, the robot will eventually unload it from the press. <p> In a sense this holds also with respect to the successful model checking solution described in <ref> [Nokel, Winkelmann 95] </ref>.
Reference: [Pappinghaus 97] <author> Pappinghaus, P.: </author> <title> "Industrial Use of ASMs for System Documentation"; Jahnichen, </title> <editor> S., Loeckx, J., Smith, D.R., Wirsing, M. (eds.), </editor> <booktitle> Dagstuhl Seminar on Logic for System Engineering, Dagstuhl Seminar Report (1997). </booktitle>
Reference-contexts: ground model problem (providing means 605Boerger E., Mearelli L.: Integrating ASMs into the Software Development Life Cycle for capturing informal requirements by appropriate|correct, concise, transpar-ent and flexible|formalizations); it supports incremental development by the systematic use of stepwise refinement; it allows one to simulate abstract models to validate these specifications (see <ref> [Pappinghaus 97] </ref> where the Paderborn machine [Del Castillo et al. 96] for executing ASMs is used); it shows how to turn the informal reasoning and the application domain driven explanations|which necessarily accompany every design|into a precise mathematical form which makes them accessible to (mental or machine) falsifiability experiments; it can integrate
Reference: [Parnas, Madey 95] <author> Parnas, D.L., Madey, J.: </author> <booktitle> "Functional documents for computer systems"; Science of Computer Programming 25 (1995), </booktitle> <pages> 41-62. </pages>
Reference-contexts: It will help if the reader is familiar with the semantics of Abstract State Machines, defined in [Gurevich 95]. We could have used also Parnas' tabular notation <ref> [Parnas, Madey 95] </ref> for which a simple but rigorous semantics can be given in terms of ASMs (see [Borger 96]). However what follows can be understood correctly also by reading our ASM rules as pseudo-code over abstract data types. <p> Monitored and controlled functions are generalizations of the controlled and monitored variables in the Parnas-Madey Four Variable Model (see <ref> [Parnas, Madey 95] </ref>). Interaction functions are dynamic functions which are directly updatable by rules of M and by the environment.
Reference: [Pusch 96] <author> Pusch, C.:" </author> <title> Verification of Compiler Correctness for the WAM"; von Wright, </title> <editor> J., Grundy, J., Harrison, J. (eds.), </editor> <title> Theorem Proving in Higher Order Logics, </title> <publisher> TPHOLs'96, Turku, Springer LNCS 1125 (1996.), </publisher> <pages> 347-362. </pages>
Reference-contexts: illustrative example for such an endeavour is the complete verification of the ASM based WAM correctness proof in [Borger, Rosenzweig 94] which used the interactive theorem prover KIV and is partially reported in this volume (see [Schellhorn, Ahrendt 97]); for another machine verification of this proof which uses ISABELLE see <ref> [Pusch 96] </ref>. Kirsten Winter has investigated for the first time the possibility to turn ASMs into finite automata in order to machine check the correctness of the ASM specification by applying advanced model checking techniques (see [Winter 97] in this volume).
Reference: [Rischel,Sun 97] <author> Rischel, H., Sun, H.: </author> <title> "Design and Prototyping of Real-Time systems Using CSP and CML"; 9th EUROMICRO Workshop on Real-Time Systems, </title> <address> Toledo June 11-13 (1997). </address>
Reference-contexts: Our ASM models avoid the somehow artificial grouping of rules concerning more than one agent; the synchronization (read: sequentialization) of specific actions of otherwise independent modules is obtained in the ASM models through appropriate interfaces (in the example: TableLoaded). Also the synchronization events used in <ref> [Rischel,Sun 97] </ref> to define interfaces avoid any splitting of rules and allow the authors to decompose their program into small, manageable components, closely resembling the structure of our component machine rules. One can map our interface updates to the interface defining event pairs in [Rischel,Sun 97] (for example begin t a1!end <p> Also the synchronization events used in <ref> [Rischel,Sun 97] </ref> to define interfaces avoid any splitting of rules and allow the authors to decompose their program into small, manageable components, closely resembling the structure of our component machine rules. One can map our interface updates to the interface defining event pairs in [Rischel,Sun 97] (for example begin t a1!end t a1 corresponds to the update TableLoaded := false in the robot rule whereafter the table can terminate its waiting phase for unloading and proceed to moving to the loading position).
Reference: [Schellhorn, Ahrendt 97] <author> Schellhorn, G., Ahrendt, W.: </author> <title> "Reasoning about Abstract State Machines: The WAM Case Study"; J.UCS (Journal for Universal Computer Science) Special ASM Issue (Part I) 3,4 (1997), </title> <type> 377-413. </type>
Reference-contexts: An illustrative example for such an endeavour is the complete verification of the ASM based WAM correctness proof in [Borger, Rosenzweig 94] which used the interactive theorem prover KIV and is partially reported in this volume (see <ref> [Schellhorn, Ahrendt 97] </ref>); for another machine verification of this proof which uses ISABELLE see [Pusch 96].
Reference: [Wallace 95] <author> Wallace, C.: </author> <title> "The semantics of the C++ programming language"; Borger, </title> <editor> E. (ed.), </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press (1995) 131-164. </publisher>
Reference-contexts: Based upon the ASM definition of the semantics of C ++ (see <ref> [Wallace 95] </ref>) one also has the possibility to prove, by a detailed mathematical argument, that Refined-CELL is correctly implemented by the C ++ program. <p> For our solution we can base a correctness proof of the C ++ code with respect to the refined ASM model on the rigorous ASM definition of the semantics of C ++ given in <ref> [Wallace 95] </ref>. Some solutions have put a particular emphasis on exhibiting how to support modifiability and reuse during the design process.

References-found: 36

