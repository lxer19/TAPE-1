URL: http://www.iiia.csic.es/Reports/1996/lso.ps.gz
Refering-URL: http://www.iiia.csic.es/Reports/1996/IIIA-RR-96.html
Root-URL: 
Title: Linear Second-Order Unification  
Author: Jordi Levy 
Web: http://www-lsi.upc.es/~jlevy  
Affiliation: Departament de Llenguatges i Sistemes Informatics Universitat Politecnica de Catalunya  
Abstract: We present a new class of second-order unification problems, which we have called linear. We deal with completely general second-order typed unification problems, but we restrict the set of unifiers under consideration: they instantiate free variables by linear terms, i.e. terms where any -abstractions bind one and only one occurrence of a bound variable. Linear second-order unification properly extends context unification studied by Comon and Schmidt-Schau. We describe a sound and complete procedure for this class of unification problems and we prove termination for three different subcases of them. One of these subcases is obtained requiring Comon's condition, another corresponds to Schmidt-Schau's condition, (both studied previously for the case of context unification, and applied here to a larger class of problems), and the third one is original, namely that free variables occur at most twice.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Comon. </author> <title> Completion of rewrite systems with membership constraints, part I: Deduction rules and part II: Constraint solving. </title> <type> Technical report, </type> <institution> CNRS and LRI, Universite de Paris Sud, </institution> <year> 1993. </year> <note> (To appear in J. of Symbolic Computation). </note>
Reference-contexts: This is an extension of first-order term unification where variables may denote not only (first-order) terms, but also contexts |terms with a hole or distinguished position|. Comon <ref> [1] </ref> studied these problems to solve membership constraints. He proved that context unification is decidable, when any occurrence of the same context variable is always applied to the same term. <p> into account that for any finite signature and given size there are finitely many unification problems, it easy to see that it is enough to control loops to ensure the termination of the procedure described in the previous sections. 7 6 Extension of Comon's Decidability Result To extend Comon's condition <ref> [1] </ref> to linear second-order unification we have to consider non-unary free variables and -bindings. The later makes necessary to introduce -equivalent terms. <p> F (f (G (a; b) ; G (I (a); b)) ; H (a)) F (a; H (b)) The following are examples of stratified terms G (I (a); b) f (H (a) ; g (H (b))) g (I (a)) w.r.t. positions <ref> [1] </ref>, [2] and [1; 1] respectively, of the same forest. The unification problem fG (I (a); b) = g (I (a))g is not stratified because, although both terms are stratified, they are stratified w.r.t. two different positions. <p> F (f (G (a; b) ; G (I (a); b)) ; H (a)) F (a; H (b)) The following are examples of stratified terms G (I (a); b) f (H (a) ; g (H (b))) g (I (a)) w.r.t. positions [1], [2] and <ref> [1; 1] </ref> respectively, of the same forest. The unification problem fG (I (a); b) = g (I (a))g is not stratified because, although both terms are stratified, they are stratified w.r.t. two different positions. <p> Finally, it can be proved that the existence of such decompositions and exponents is decidable, even in the more complex case of linear second-order unification. 8 Conclusions In this paper we have extended decidability results of Comon <ref> [1] </ref> and Schmidt-Schau [17] for context unification to a proper extension of this unification problem, that we have called linear 13 second-order unification, where n-ary free variables and -bindings are allowed.
Reference: [2] <author> J. H. Gallier and W. Snyder. </author> <title> Designing unification procedures using transformations: A survey. </title> <journal> Bulletin of the EATCS, </journal> <volume> 40 </volume> <pages> 273-326, </pages> <year> 1990. </year>
Reference-contexts: As usual, small letters like p denotes correlative lists of indexes [1::p], so a (b p ) denotes a (b 1 ; : : : ; b p ). We also use the notation on transformations introduced by Gallier and Snyder <ref> [2] </ref> for describing unification processes. <p> F (f (G (a; b) ; G (I (a); b)) ; H (a)) F (a; H (b)) The following are examples of stratified terms G (I (a); b) f (H (a) ; g (H (b))) g (I (a)) w.r.t. positions [1], <ref> [2] </ref> and [1; 1] respectively, of the same forest. The unification problem fG (I (a); b) = g (I (a))g is not stratified because, although both terms are stratified, they are stratified w.r.t. two different positions.
Reference: [3] <author> W. D. Goldfarb. </author> <title> The undecidability of the second-order unification problem. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 225-230, </pages> <year> 1981. </year>
Reference-contexts: Most of the negative results were also discovered during this decade. Independently, Lucchesi [11] and Huet [5] showed that third-order unification is not decidable, later Goldfarb <ref> [3] </ref> showed that second-order unification is not decidable either.
Reference: [4] <author> W. E. Gould. </author> <title> A Matching Procedure for !-Order Logic. </title> <type> PhD thesis, </type> <institution> Princeton Univ., </institution> <year> 1966. </year>
Reference-contexts: In this paper we extend this class of problems to what we call linear second-order unification. Historically, Robinson and Guard were the first who studied the higher-order unification problem in the sixties. In fact, a student of Guard (Gould <ref> [4] </ref>), was the first who found a complete second-order matching algorithm. Most of the results of second-order and higher-order unification problems were proved during the seventies.
Reference: [5] <author> G. Huet. </author> <title> The undecidability of unification in third-order logic. </title> <journal> Information and Control, </journal> <volume> 22(3) </volume> <pages> 257-267, </pages> <year> 1973. </year>
Reference-contexts: Pietrzykowski [15] described a complete second-order unification procedure, that was later extended to the higher-order case [7], and Huet [6] defined preunification (lazy unification) and found a non-redundant procedure for it. Most of the negative results were also discovered during this decade. Independently, Lucchesi [11] and Huet <ref> [5] </ref> showed that third-order unification is not decidable, later Goldfarb [3] showed that second-order unification is not decidable either.
Reference: [6] <author> G. Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Most of the results of second-order and higher-order unification problems were proved during the seventies. Pietrzykowski [15] described a complete second-order unification procedure, that was later extended to the higher-order case [7], and Huet <ref> [6] </ref> defined preunification (lazy unification) and found a non-redundant procedure for it. Most of the negative results were also discovered during this decade. Independently, Lucchesi [11] and Huet [5] showed that third-order unification is not decidable, later Goldfarb [3] showed that second-order unification is not decidable either.
Reference: [7] <author> D. C. Jensen and T. Pietrzykowski. </author> <title> Mechanizing !-order type theory through unification. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 123-171, </pages> <year> 1976. </year>
Reference-contexts: In fact, a student of Guard (Gould [4]), was the first who found a complete second-order matching algorithm. Most of the results of second-order and higher-order unification problems were proved during the seventies. Pietrzykowski [15] described a complete second-order unification procedure, that was later extended to the higher-order case <ref> [7] </ref>, and Huet [6] defined preunification (lazy unification) and found a non-redundant procedure for it. Most of the negative results were also discovered during this decade. Independently, Lucchesi [11] and Huet [5] showed that third-order unification is not decidable, later Goldfarb [3] showed that second-order unification is not decidable either. <p> Notice that if R j = ; then F 0 j is a first-order typed variable (resp. for S i and G 0 i ). Compared with the general second-order unification procedure <ref> [7] </ref>, we avoid the use of the prolific elimination and iteration rules, which always compromise the termination of their procedure. It does not mean that our procedure terminates, but it avoids many redundant states. Moreover, in contrast to Jensen and Pietrzykowski's procedure, our procedure only computes minimal unifiers.
Reference: [8] <author> J. Levy and J. Agust. Bi-rewriting, </author> <title> a term rewriting technique for monotonic order relations. </title> <booktitle> In 4th Int. Conf. on Rewriting Techniques and Applications, RTA'93, volume 690 of LNCS, </booktitle> <pages> pages 17-31, </pages> <address> Montreal, Canada, </address> <year> 1993. </year>
Reference-contexts: Finally, our interest on such problem comes from the extended critical pair problem. This problem arises when trying to apply rewriting techniques to automated deduction in monotonic order theories, using bi-rewriting systems <ref> [8, 9] </ref>. However, we deal with an extension of the context unification problem, named linear second-order unification.
Reference: [9] <author> J. Levy and J. </author> <title> Agust. </title> <journal> Bi-rewriting systems. J. of Symbolic Computation, </journal> <note> 1996. (To be published). </note>
Reference-contexts: Finally, our interest on such problem comes from the extended critical pair problem. This problem arises when trying to apply rewriting techniques to automated deduction in monotonic order theories, using bi-rewriting systems <ref> [8, 9] </ref>. However, we deal with an extension of the context unification problem, named linear second-order unification.
Reference: [10] <author> C. Lora-Saenz. </author> <title> A Theoretical Framework for Reasoning about Program Construction based on Extensions of Rewrite Systems. </title> <type> PhD thesis, </type> <institution> Univ. Kaiserslautern, </institution> <year> 1993. </year>
Reference-contexts: Such patterns were used by Nipkow [14] to propose a notion of higher-order rewriting, which lead to quite some further research <ref> [16, 12, 10] </ref>. This paper deals with another class of higher-order unification problems that has caught the attention of some researchers recently, the so called context unification problems.
Reference: [11] <author> C. L. Lucchesi. </author> <title> The undecidability of the unification problem for third-order languages. </title> <type> Technical Report CSRR 2059, </type> <institution> Dept. of Applied Analysis and Computer Science, Univ. of Waterloo, </institution> <year> 1972. </year>
Reference-contexts: Pietrzykowski [15] described a complete second-order unification procedure, that was later extended to the higher-order case [7], and Huet [6] defined preunification (lazy unification) and found a non-redundant procedure for it. Most of the negative results were also discovered during this decade. Independently, Lucchesi <ref> [11] </ref> and Huet [5] showed that third-order unification is not decidable, later Goldfarb [3] showed that second-order unification is not decidable either.
Reference: [12] <author> O. Lysne and J. Piris. </author> <title> A termination ordering for higher-order rewrite systems. </title> <booktitle> In 6th Int. Conf on Rewriting Techniques and Applications, RTA'95, volume 914 of LNCS, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: Such patterns were used by Nipkow [14] to propose a notion of higher-order rewriting, which lead to quite some further research <ref> [16, 12, 10] </ref>. This paper deals with another class of higher-order unification problems that has caught the attention of some researchers recently, the so called context unification problems.
Reference: [13] <author> D. Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> J. of Logic and Computation, </journal> <volume> 1 </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: Most of the negative results were also discovered during this decade. Independently, Lucchesi [11] and Huet [5] showed that third-order unification is not decidable, later Goldfarb [3] showed that second-order unification is not decidable either. In the nineties, Miller <ref> [13] </ref> found the first class of decidable higher-order unification problems, named higher-order pattern fl This work was partially supported by the ESPRIT Basic Research Action CCL and the project DISCOR (TIC 94-0847-C02-01) funded by the CICYT 1 unification.
Reference: [14] <author> T. Nipkow. </author> <title> Functional unification of higher-order patterns. </title> <booktitle> In 8th IEEE Symp. on Logic in Computer Science, LICS'93, </booktitle> <pages> pages 64-74, </pages> <address> Montreal, Canada, </address> <year> 1993. </year>
Reference-contexts: In the nineties, Miller [13] found the first class of decidable higher-order unification problems, named higher-order pattern fl This work was partially supported by the ESPRIT Basic Research Action CCL and the project DISCOR (TIC 94-0847-C02-01) funded by the CICYT 1 unification. Such patterns were used by Nipkow <ref> [14] </ref> to propose a notion of higher-order rewriting, which lead to quite some further research [16, 12, 10]. This paper deals with another class of higher-order unification problems that has caught the attention of some researchers recently, the so called context unification problems.
Reference: [15] <author> T. Pietrzykowski. </author> <title> A complete mechanization of second-order logic. </title> <journal> J. of the ACM, </journal> <volume> 20(2) </volume> <pages> 333-364, </pages> <year> 1973. </year>
Reference-contexts: In fact, a student of Guard (Gould [4]), was the first who found a complete second-order matching algorithm. Most of the results of second-order and higher-order unification problems were proved during the seventies. Pietrzykowski <ref> [15] </ref> described a complete second-order unification procedure, that was later extended to the higher-order case [7], and Huet [6] defined preunification (lazy unification) and found a non-redundant procedure for it. Most of the negative results were also discovered during this decade.
Reference: [16] <author> C. Prehofer. </author> <title> Solving Higher-Order Equations: From Logic to Programming. </title> <type> PhD thesis, </type> <institution> Technische Universitat Munchen, </institution> <year> 1995. </year>
Reference-contexts: Such patterns were used by Nipkow [14] to propose a notion of higher-order rewriting, which lead to quite some further research <ref> [16, 12, 10] </ref>. This paper deals with another class of higher-order unification problems that has caught the attention of some researchers recently, the so called context unification problems.
Reference: [17] <author> M. Schmidt-Schau. </author> <title> Unification of stratified second-order terms. </title> <type> Technical Report 12/94, </type> <institution> Johan Wolfgang-Goethe-Universitat, Frankfurt, Germany, </institution> <year> 1995. </year>
Reference-contexts: Comon [1] studied these problems to solve membership constraints. He proved that context unification is decidable, when any occurrence of the same context variable is always applied to the same term. Schmidt-Schau <ref> [17] </ref> also studies the same problem, however he is interested in reducing the problem of unification modulo distributivity to a subset of such context unification problems. He proves that context unification is decidable when terms are stratified. <p> Something similar applies to the distinct-heads rule. This fact and the reduction of free arity due to projection rule may be used to define a well-founded ordering on unification problems, and conclude that linear second-order unification under Comon's restriction is finitary. 7 Decidability Result for Stratified Terms Schmidt-Schau <ref> [17] </ref> describes another class of decidable context unification problems, called stratified second-order unification. <p> Finally, it can be proved that the existence of such decompositions and exponents is decidable, even in the more complex case of linear second-order unification. 8 Conclusions In this paper we have extended decidability results of Comon [1] and Schmidt-Schau <ref> [17] </ref> for context unification to a proper extension of this unification problem, that we have called linear 13 second-order unification, where n-ary free variables and -bindings are allowed. We have also described a complete unification procedure for this problem on which we have based all our decidability proofs.
Reference: [18] <author> K. U. Schulz. </author> <title> Makanin's algorithm, two improvements and a generalization. </title> <type> Technical Report CIS-Bericht-91-39, </type> <institution> Centrum fur Informations und Sprachverarbeitung, Universitat Munchen, </institution> <year> 1991. </year> <month> 14 </month>
Reference-contexts: This fact is related with the termination of the naive string unification procedure when variables occurs at most twice <ref> [18] </ref>. Theorem 9 Termination. If no free variable occurs more than twice in a linear second-order unification problem, then this unification problem is decidable. <p> Any linear second-order unification problem satisfying the extended Comon's condition is decidable and finitary. To ensure the termination of our unification procedure we have to apply a kind of problem normalization before any transformation. This is equivalent to working with generalized equations like it is done in A-unification <ref> [18] </ref>. We deal with sequences of equalities t 1 ? ? and we concatenate any pair of sequence sharing two -equivalent terms.
References-found: 18

