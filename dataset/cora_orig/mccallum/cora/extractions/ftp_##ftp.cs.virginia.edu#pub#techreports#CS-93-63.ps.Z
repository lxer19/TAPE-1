URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-93-63.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Register Deprivation Measurements  
Author: Manuel E. Benitez Jack W. Davidson 
Abstract: Computer Science Report No. CS-93-63 November 15, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> A. V. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: The back-end, vpo, improves this code to produce high-quality assembly-language code for the target machine. Most of the traditional optimizations, including local variable promotion, code motion, strength reduction, induction variable elimination, common subexpression elimination, evaluation order determination, dead variable elimination, constant folding and various control-ow optimizations <ref> [ASU86] </ref> are performed.
Reference: [BD88] <author> M. E. Benitez and J. W. Davidson, </author> <title> A Portable Global Optimizer and Linker, </title> <booktitle> Proceedings of the SIGPLAN 88 Symposium on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988, </year> <pages> 329-338. </pages>
Reference-contexts: These concerns motivated the development of new graph-coloring register allocation strategies for the retargeta-ble vpcc/vpo optimizing compiler <ref> [BD88] </ref>. The most difficult part of this task was not developing these strategies, but devising a technique to evaluate their efficacy. Thus, the register deprivation measurement techniques presented here were initially developed to satisfy this need.
Reference: [BD91] <author> M. E. Benitez and J. W. Davidson, </author> <title> Code Generation for Streaming: an Access/Execute Mechanism, </title> <booktitle> Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991, </year> <pages> 132-141. </pages>
Reference-contexts: One instance of this can be seen in the performance results for the MIPS 3000 shown in Figure 4. These results show a significant improvement in the execution time of the iir benchmark between 15 and 17 registers, which comes from applying recurrence optimization <ref> [BD91] </ref> to the main loop of the benchmark. This transformation is very effective, but consumes a trio of registers and the mechanism that prevents vpcc/vpo from over-committing register resources prevents the transformation from taking place until there are sufficient registers available to support it. <p> Instruction scheduling and branch delay-slot filling, which is essential on some pipelined architectures, and recurrence optimization <ref> [BD91] </ref>, which can significantly improve some scientific and digital signal processing codes, are also included. 4.2 Profile Tool The object code produced by vpcc/vpo is instrumented to determine the number of instructions and memory references executed using ease [DW91b].
Reference: [CAC+81] <author> G. J. Chaitin, M.A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins and P. W. Markstein, </author> <title> Register Allocation via Coloring, </title> <booktitle> Computer Languages 6, </booktitle> <volume> 1, </volume> <month> January </month> <year> 1981, </year> <pages> 47-57. </pages>
Reference-contexts: 1 Introduction 1.1 Motivation Optimizing compilers generate code by invoking a comprehensive set of optimizations. Since most code improvement transformations increase the average number of registers that are simultaneously needed within a program, good register allocation is essential to producing high-quality code. Currently, graph coloring <ref> [CAC+81] </ref> is the paradigm of choice for performing register allocation. The typical compiler that uses graph coloring allocation performs optimizations using an infinite set of pseudo-registers that are bound to hardware registers just prior to code generation.
Reference: [CH84] <author> F. C. Chow and J. L. Hennessy, </author> <title> Register Allocation by priority-based coloring, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19, 6, </volume> <month> June </month> <year> 1984, </year> <pages> 222-232. </pages>
Reference-contexts: A typical consequence of postponing register assignment decisions is that register resources are over-committed and produce many spills when the code provides many opportunities to perform code improvement transformations - 2 - or the target machine lacks sufficient registers. Even priority-based coloring allocation strategies <ref> [CH84] </ref> are vulnerable under these circumstances because, although they do not explicitly spill, they cannot provide registers to all of the transformations that expected to get them.
Reference: [Dav86] <author> J. W. Davidson, </author> <title> A Retargetable Instruction Reorganizer, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Programming Language Design and Implementation, </booktitle> <address> Palo Alto, CA, </address> <month> June </month> <year> 1986, </year> <pages> 234-241. </pages>
Reference-contexts: Figures 5 and 6 show how the size of the register set affects the reduction in the dynamic instruction and memory reference execution counts produced by vpcc/vpos evaluation order determination phase <ref> [Dav86] </ref>. Recall that the purpose of evaluation order determination is to reduce the number of registers required to assign register to hold temporary values.
Reference: [DW91a] <author> J. W. Davidson and D. B. Whalley, </author> <title> Methods for Saving and Restoring Register Values across Function Calls, </title> <journal> SoftwarePractice and Experience 21, </journal> <volume> 2, </volume> <month> February </month> <year> 1991, </year> <pages> 149-165. </pages>
Reference-contexts: Since the ratio of volatile to non-volatile registers can have a significant impact on code quality <ref> [DW91a] </ref>, our register deprivation testing implementation also maintains the volatile to non-volatile register ratios as close to the original values as possible. Many calling conventions pass actual parameter values in a subset of the volatile register set.
Reference: [DW91b] <author> J. W. Davidson and D. B. Whalley, </author> <title> A Design Environment for Addressing Architecture and Compiler Interactions, </title> <journal> Microprocessors and Microsystems, </journal> <volume> 15, 9, </volume> <month> November </month> <year> 1991, </year> <pages> 459-472. </pages>
Reference-contexts: Register deprivation experiments that vary only a subset of the registers and register augmentation measurements, which can be performed by simulating the effects of having more registers than are actually available on the target machine <ref> [DW91b] </ref>, are also possible. Table 1 shows the instruction execution counts obtained from a sample register deprivation trial consisting of six probes taken on a mythical machine with a three program benchmark suite. <p> delay-slot filling, which is essential on some pipelined architectures, and recurrence optimization [BD91], which can significantly improve some scientific and digital signal processing codes, are also included. 4.2 Profile Tool The object code produced by vpcc/vpo is instrumented to determine the number of instructions and memory references executed using ease <ref> [DW91b] </ref>. When ease is employed, the object code produced by the compiler is instrumented with execution counters. After the instrumented code executes, the values of these counters are written to a file along with instruction information for each basic block.
Reference: [FH92] <author> C. W. Fraser and D. R. Hanson, </author> <title> Simple Register Spilling in a Retargetable Compiler, </title> <journal> SoftwarePractice and Experience 22, </journal> <volume> 1, </volume> <month> January </month> <year> 1992, </year> <pages> 85-99. </pages>
Reference-contexts: This is not a novel use of a register deprivation-like technique, since Fraser and Hanson utilized a similar strategy to test a local register allocator for the lcc compiler <ref> [FH92] </ref>. What is surprising about the register deprivation process presented here, however, is that it uncovered defects in areas of the compiler that were not associated with the register allocator and thought to be very reliable.
Reference: [HP90] <author> J. L. Hennessy and D. A. Patterson, </author> <title> Computer Architecture, A Quantitative Approach, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: This process eliminates the impact that the size of the allocable register set has on the components that are not being measured, regardless of whether it is beneficial or detrimental. The following formula, given in Hennessy and Patterson <ref> [HP90] </ref>, is used to obtain the percent improvement of the initial optimized trial over the base trial: Table 3 shows the results obtained by applying this formula to each corresponding pair of values in the sample trials.
Reference: [Kan87] <author> G. Kane, </author> <title> MIPS RISC Architecture, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: Figure 2 shows how the number of allocable registers affects the number of instructions executed by the object code produced by the vpcc/vpo system for the Motorola 68020 [Mot85] CISC and the MIPS R3000 <ref> [Kan87] </ref> RISC processors. These results show that the number of instructions executed by the code produced by vpcc/vpo decreases as the number of allocable registers increases.
Reference: [KR78] <author> B. W. Kernighan and D. M. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1978. </year>
Reference-contexts: We implemented register deprivation measurement technique using the vpcc/vpo compiler. The vpcc front-end accepts traditional C <ref> [KR78] </ref> and generates stack-based, intermediate-language code, which is used directly by the code generator to generate machine-level code in the form of register transfer lists (RTLs). The back-end, vpo, improves this code to produce high-quality assembly-language code for the target machine.
Reference: [Mot85] <author> Motorola, </author> <title> MC68020 32-Bit Microprocessor Users Manual, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: Figure 2 shows how the number of allocable registers affects the number of instructions executed by the object code produced by the vpcc/vpo system for the Motorola 68020 <ref> [Mot85] </ref> CISC and the MIPS R3000 [Kan87] RISC processors. These results show that the number of instructions executed by the code produced by vpcc/vpo decreases as the number of allocable registers increases.
Reference: [Wal86] <author> D. W. Wall, </author> <title> Global Register Allocation at Link-time, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Programming Language Design and Implementation, </booktitle> <address> Palo Alto, CA, </address> <month> June </month> <year> 1986, </year> <pages> 264-275. </pages>
Reference-contexts: As marketing and design decisions are increasingly made on the basis of benchmark test results, tools that can be used to locate inadequacies in benchmark suites become more valuable. Existing compiler technology is not capable of making effective use of large numbers of registers. Even link-time register allocation techniques <ref> [Wal86] </ref> have limits on the number of registers that they can successfully utilize. Register deprivation measurements can be used to probe these limits. Hardware designers are often forced to make trade-offs without the guidance of empirical data.
References-found: 14

