URL: http://www.daimi.aau.dk/~stefand/Publications/lics97.ps.gz
Refering-URL: http://www.daimi.aau.dk/~stefand/publications.html
Root-URL: http://www.daimi.aau.dk
Email: std@mimuw.edu.pl  mju@mimuw.edu.pl  igw@mimuw.edu.pl  
Title: How Much Memory is Needed to Win Infinite Games?  
Author: ; Stefan Dziembowski Marcin Jurdzinski ; Igor Walukiewicz 
Affiliation: Institute of Informatics 5 Warsaw University  
Abstract: We consider a class of infinite two-player games on finitely coloured graphs. Our main question is: given a winning condition, what is the inherent blow-up (additional memory) of the size of the I/O automata realizing winning strategies in games with this condition. This problem is relevant to synthesis of reactive programs and to the theory of automata on infinite objects. We provide matching upper and lower bounds for the size of memory needed by winning strategies in games with a fixed winning condition. We also show that in the general case the LAR (latest appearance record) data structure of Gurevich and Harrington is optimal. Then we propose a more succinct way of representing winning strategies by means of parallel compositions of transition systems. We study the question: which classes of winning conditions admit only polynomial-size blowup of strategies in this representation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. ABADI, L. LAMPORT AND P. WOLPER, </author> <title> Realizable and unrealizable specifications of reactive systems, </title> <booktitle> in: Proc. 16th Int. Coll. Automata, Languages and Programming, LNCS 372 (1989) 117. </booktitle>
Reference-contexts: Hence, in this framework, strategy construction amounts to program synthesis and deciding if there exists a winning strategy for player 0 is equivalent to the problem of realizability of specifications of reactive systems. These problems were studied for example in <ref> [1, 4, 14, 17] </ref>. In all these applications an important question is how much memory a strategy may need. As an example from automata theory, consider the complementation lemma for automata on infinite trees.
Reference: [2] <author> R. B. BOPPANA AND M. SIPSER, </author> <title> The complexity of finite functions, </title> <editor> in: J. VAN LEEUWEN Ed., </editor> <booktitle> Handbook of Theoretical Computer Science, Volume A, </booktitle> <publisher> Elsevier, </publisher> <year> 1990, </year> <month> 757804. </month>
Reference-contexts: This is known to be the major open question about nonuniform complexity classes (see <ref> [2] </ref> pp. 763-764 for the description of the problem). . . . f 2 f 1 f n 0 We show that arbitrary characterisation of Muller sequences having polynomially representable strategies will allow us to decide whether a function is computable in PSPACE/poly.
Reference: [3] <author> J. BRADFIELD, J. ESPARZA AND A. MADER, </author> <title> An effective tableau system for the linear time -calculus, </title> <booktitle> in: Proc. 23rd Int. Coll. Automata, Languages and Programming, LNCS 1099 (1996) 98109. </booktitle>
Reference-contexts: In particular it can change this size from single to double exponential. In the area of program logics, additional memory reflects in complications in proof constructions as for example in [21] or in tableau constructions <ref> [3, 6] </ref>. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's [11, 15, 23]. Most importantly, however, the question of memory size is crucial in the program synthesis.
Reference: [4] <author> J. R. B UCHI AND L. H. </author> <title> LANDWEBER, Solving sequential conditions by finite state strategies, </title> <journal> Trans. Amer. Math. Soc. </journal> <volume> 138 (1969) 295311. </volume>
Reference-contexts: The winner is established by a Muller winning condition (defined on the finite set of colours). These games can be seen as a special case of general Borel games and were first studied by Buchi and Landwe-ber <ref> [4] </ref>. <p> Hence, in this framework, strategy construction amounts to program synthesis and deciding if there exists a winning strategy for player 0 is equivalent to the problem of realizability of specifications of reactive systems. These problems were studied for example in <ref> [1, 4, 14, 17] </ref>. In all these applications an important question is how much memory a strategy may need. As an example from automata theory, consider the complementation lemma for automata on infinite trees.
Reference: [5] <author> O. BURKART AND B. STEFFEN, </author> <title> Model checking for context-free processes, </title> <booktitle> in: Proc. 4th Int. Conf. on Computer Aided Verification, LNCS 630 (1992) 123137. </booktitle>
Reference-contexts: When considering program synthesis, however, one usually takes into account game graphs of size at most polynomial in the number of colours in the winning condition. (Although finitely definable infinite size games also were considered in this context <ref> [5, 20, 22] </ref> and our results are also applicable there). As we will see the case when the size of the game graph is bounded in the number of colours is different and technically more difficult, hence it is appropriate to consider it separately.
Reference: [6] <author> M. DAM, </author> <title> CTL fl and ECTL fl as a fragments of the modal - calculus, </title> <note> in: CAAP'92, LNCS 581 (1992) 145165. </note>
Reference-contexts: In particular it can change this size from single to double exponential. In the area of program logics, additional memory reflects in complications in proof constructions as for example in [21] or in tableau constructions <ref> [3, 6] </ref>. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's [11, 15, 23]. Most importantly, however, the question of memory size is crucial in the program synthesis.
Reference: [7] <author> E. A. EMERSON, </author> <title> Automata, tableaux, and temporal logics (Extended abstract), in: Logics of Programs, </title> <note> LNCS 193 (1985) 7988. </note>
Reference-contexts: He mentions some savings in memory for winning strategies by considering his notion of useful colours. This observation is sufficient for showing mem-oryless determinacy for games with Rabin winning conditions (see also <ref> [7, 13] </ref>). In general his bound is not optimal. Our upper bound is in some cases exponentially smaller than his. Zielonka's motivation comes from automata theory so he considers potentially infinite graphs. In this setting our upper and lower bounds for memory needed by winning strategies are optimal. <p> Memoryless determinacy for such games was shown in <ref> [7, 13] </ref>. Remark: Observe that every 1-subtree of a tree from the Example on page 4 (Figure 1) has n leaves (labelled with H i1 ; : : : ; H in for some i).
Reference: [8] <author> E. A. EMERSON AND C. S. JUTLA, </author> <title> The complexity of tree automata and logics of programs, </title> <booktitle> in: Proc. of 29th Annual IEEE Symp. on Foundations of Computer Science (1988) 328-337. </booktitle>
Reference-contexts: McNaughton [15] gives an algorithm working in time exponential in the number of colours. In case the of games with winning conditions given in Rabin form, Emerson and Jutla <ref> [8] </ref> show that the problem is NP-complete. From our general upper bound on memory we infer a class of winning conditions for which the problem is in NP " co-NP (see Corollary 12).
Reference: [9] <author> E. A. EMERSON AND C. S. JUTLA, </author> <title> Tree automata, mu-calculus and determinacy, </title> <booktitle> in: Proc. of 32nd Annual IEEE Symp. on Foundations of Computer Science (1991) 368-377. </booktitle>
Reference-contexts: Since this result, infinite games became a central tool in the theory of automata on infinite objects <ref> [9, 13, 23, 19, 20] </ref>. They were also used in understanding logics of programs [9, 18, 21]. <p> Since this result, infinite games became a central tool in the theory of automata on infinite objects [9, 13, 23, 19, 20]. They were also used in understanding logics of programs <ref> [9, 18, 21] </ref>. It was also observed that a game may be considered as a specification of a reactive system by viewing it as a description of all possible interactions between player 0 (Control) and player 1 (Environment).
Reference: [10] <author> E. A. EMERSON, C. S. JUTLA AND A. P. SISTLA, </author> <title> On model-checking for fragments of -calculus, </title> <booktitle> in: Proc. 5th Int. Conf. on Computer Aided Verification, LNCS 697 (1993) 383396. </booktitle>
Reference-contexts: From our general upper bound on memory we infer a class of winning conditions for which the problem is in NP " co-NP (see Corollary 12). This can be seen as a generalisation of the result due to Emerson, Jutla and Sistla <ref> [10] </ref>, where NP " co-NP upper bound was shown for games with Rabin chain (parity) winning condition. The latter problem is polynomially equivalent to the -calculus model checking [10]. Nerode, Remmel and Yakhnis [16] study classes of winning conditions for which there exist polynomial time algorithms of strategy synthesis. <p> This can be seen as a generalisation of the result due to Emerson, Jutla and Sistla <ref> [10] </ref>, where NP " co-NP upper bound was shown for games with Rabin chain (parity) winning condition. The latter problem is polynomially equivalent to the -calculus model checking [10]. Nerode, Remmel and Yakhnis [16] study classes of winning conditions for which there exist polynomial time algorithms of strategy synthesis. <p> For every i = 1; 2; : : : ; k check recursively if i j satisfies F C (s i ). fl Remark: Corollary 12 can be seen as a generalisation of the result of Emerson, Jutla and Sistla <ref> [10] </ref> that the decision problem for games with Rabin chain (parity) conditions is in NP " co-NP. In this special case the size of the Zielonka tree is linear in the number of colours.
Reference: [11] <author> Y. GUREVICH AND L. HARRINGTON, </author> <title> Trees, automata, and games, </title> <booktitle> in: Proc. of 14th Annual ACM Symp. on Theory of Computing (1982) 6065. </booktitle>
Reference-contexts: The winner is established by a Muller winning condition (defined on the finite set of colours). These games can be seen as a special case of general Borel games and were first studied by Buchi and Landwe-ber [4]. Gurevich and Harrington in their seminal paper <ref> [11] </ref> 1 A part of this research was carried out while the authors were visiting Basic Research in Computer Science, Centre of the Danish National Research Foundation. 2 This work was partially supported by Polish KBN grant No. 8 T11C 002 11. 3 Supported by BRICS Summer Student Programme. 4 Supported <p> In the area of program logics, additional memory reflects in complications in proof constructions as for example in [21] or in tableau constructions [3, 6]. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's <ref> [11, 15, 23] </ref>. Most importantly, however, the question of memory size is crucial in the program synthesis. It measures the inherent blow-up of the size of a program satisfying a specification in terms of the size of the specification itself. <p> Thus w.l.o.g. we can assume that player 0 has a strategy to win from every vertex of the arena. To meet this requirement it is enough to restrict the arena to the winning set of player 0. It turns out (see <ref> [11, 15, 23] </ref>) that for the games we consider the winning strategies can be realized by functions that do not have to refer to the whole histories of the play (i.e., the elements of the set V fl ), but only to a finite information about the play so far.
Reference: [12] <author> H. LESCOW, </author> <title> On polynomial-size programs winning finite-state games, </title> <booktitle> in: Proc. 7th Int. Conf. on Computer Aided Verification, LNCS 939 (1995) 239252. </booktitle>
Reference-contexts: It is well known that there exists a sequence of games hG n i n2N , each G n of size O (n) and requiring strategy automata of size 2 n <ref> [20, 12] </ref>. Hence synthesized program may be exponentially larger than the specification. While it is still possible to imagine that we can deal with problems having worst case exponential time complexity, it is hard to imagine how we can cope with exponential space complexity. <p> Zielonka's motivation comes from automata theory so he considers potentially infinite graphs. In this setting our upper and lower bounds for memory needed by winning strategies are optimal. Memory requirements in the context of program synthesis were studied by Lescow <ref> [12] </ref>. He considers only 2 game graphs of size linear in the number of colours and seeks a characterisation of winning conditions admitting polynomial-size strategies. Our upper bound subsumes all his examples of families of such winning conditions. Le-scow provides also some 2 (n) lower bounds.
Reference: [13] <author> N. KLARLUND, </author> <title> Progress measures, immediate determinacy, and a subset construction for tree automata, </title> <booktitle> in: Proc. of 7th Annual IEEE Symp. on Logic in Computer Science (1992) 382-393. </booktitle>
Reference-contexts: Since this result, infinite games became a central tool in the theory of automata on infinite objects <ref> [9, 13, 23, 19, 20] </ref>. They were also used in understanding logics of programs [9, 18, 21]. <p> He mentions some savings in memory for winning strategies by considering his notion of useful colours. This observation is sufficient for showing mem-oryless determinacy for games with Rabin winning conditions (see also <ref> [7, 13] </ref>). In general his bound is not optimal. Our upper bound is in some cases exponentially smaller than his. Zielonka's motivation comes from automata theory so he considers potentially infinite graphs. In this setting our upper and lower bounds for memory needed by winning strategies are optimal. <p> Memoryless determinacy for such games was shown in <ref> [7, 13] </ref>. Remark: Observe that every 1-subtree of a tree from the Example on page 4 (Figure 1) has n leaves (labelled with H i1 ; : : : ; H in for some i).
Reference: [14] <author> O. MALER, A. PNUELI AND J. </author> <title> SIFAKIS On the synthesis of discrete controllers for timed systems, </title> <booktitle> in: Proc. of 12th Annual Symp. on Theoretical Aspects of Computer Science, LNCS 900 (1995) 229242. </booktitle>
Reference-contexts: Hence, in this framework, strategy construction amounts to program synthesis and deciding if there exists a winning strategy for player 0 is equivalent to the problem of realizability of specifications of reactive systems. These problems were studied for example in <ref> [1, 4, 14, 17] </ref>. In all these applications an important question is how much memory a strategy may need. As an example from automata theory, consider the complementation lemma for automata on infinite trees.
Reference: [15] <author> R. MCNAUGHTON, </author> <title> Infinite games played on finite graphs, </title> <journal> Ann. Pure Appl. </journal> <note> Logic 65 (1993) 149184. </note>
Reference-contexts: 1 Introduction 1997 IEEE We consider games played on (not necessarily finite) graphs coloured with a finite number of colours <ref> [15, 23] </ref>. The two players alternatively choose vertices forming an infinite path through the game graph. The winner is established by a Muller winning condition (defined on the finite set of colours). <p> In the area of program logics, additional memory reflects in complications in proof constructions as for example in [21] or in tableau constructions [3, 6]. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's <ref> [11, 15, 23] </ref>. Most importantly, however, the question of memory size is crucial in the program synthesis. It measures the inherent blow-up of the size of a program satisfying a specification in terms of the size of the specification itself. <p> This may come as a slight surprise, because some claims to the contrary have been quoted (see [20], p. 9). Finally let us mention the following algorithmic problem: given a game and a node, establish whether player 0 has a winning strategy from this node. McNaughton <ref> [15] </ref> gives an algorithm working in time exponential in the number of colours. In case the of games with winning conditions given in Rabin form, Emerson and Jutla [8] show that the problem is NP-complete. <p> A winning set for player 0 is the set of vertices of the arena from which there exists a winning strategy for player 0. It is easy to see that these strategies can be merged (see <ref> [15] </ref>), hence there is also one common winning strategy on the winning set. Proviso: We will consider winning strategies for player 0. Thus w.l.o.g. we can assume that player 0 has a strategy to win from every vertex of the arena. <p> Thus w.l.o.g. we can assume that player 0 has a strategy to win from every vertex of the arena. To meet this requirement it is enough to restrict the arena to the winning set of player 0. It turns out (see <ref> [11, 15, 23] </ref>) that for the games we consider the winning strategies can be realized by functions that do not have to refer to the whole histories of the play (i.e., the elements of the set V fl ), but only to a finite information about the play so far. <p> Remark: It is easy to show (see <ref> [15, 23, 20] </ref>) that Attr W i (T ) is the set of vertices in W from which player i can force the play into T using a memoryless strategy.
Reference: [16] <author> A. NERODE, J. B. REMMEL AND A. YAKHNIS, </author> <title> Mc-Naughton games and extracting strategies for concurrent programs, </title> <journal> Ann. Pure Appl. </journal> <note> Logic 78 (1996) 203242. </note>
Reference-contexts: This can be seen as a generalisation of the result due to Emerson, Jutla and Sistla [10], where NP " co-NP upper bound was shown for games with Rabin chain (parity) winning condition. The latter problem is polynomially equivalent to the -calculus model checking [10]. Nerode, Remmel and Yakhnis <ref> [16] </ref> study classes of winning conditions for which there exist polynomial time algorithms of strategy synthesis.
Reference: [17] <author> A. PNUELI AND R. ROSNER, </author> <title> On the synthesis of a reactive module, </title> <booktitle> in: Proc. 16th Annual ACM Symp. on Principles of Programming Languages (1989) 179190. </booktitle>
Reference-contexts: Hence, in this framework, strategy construction amounts to program synthesis and deciding if there exists a winning strategy for player 0 is equivalent to the problem of realizability of specifications of reactive systems. These problems were studied for example in <ref> [1, 4, 14, 17] </ref>. In all these applications an important question is how much memory a strategy may need. As an example from automata theory, consider the complementation lemma for automata on infinite trees.
Reference: [18] <author> C. STIRLING, </author> <title> Modal and temporal logics for processes, </title> <note> to appear in LNCS. </note>
Reference-contexts: Since this result, infinite games became a central tool in the theory of automata on infinite objects [9, 13, 23, 19, 20]. They were also used in understanding logics of programs <ref> [9, 18, 21] </ref>. It was also observed that a game may be considered as a specification of a reactive system by viewing it as a description of all possible interactions between player 0 (Control) and player 1 (Environment).
Reference: [19] <author> W. THOMAS, </author> <title> Automata on Infinite Objects, </title> <editor> in: J. VAN LEEUWEN Ed., </editor> <booktitle> Handbook of Theoretical Computer Science Volume B, </booktitle> <publisher> Elsevier, </publisher> <year> 1990, </year> <month> 133192. </month>
Reference-contexts: Since this result, infinite games became a central tool in the theory of automata on infinite objects <ref> [9, 13, 23, 19, 20] </ref>. They were also used in understanding logics of programs [9, 18, 21]. <p> A game is a pair G = (A; F), where A is an arena, and F P (C) is a winning condition for player 0 (in Muller form <ref> [19] </ref>).
Reference: [20] <author> W. THOMAS, </author> <title> On the synthesis of strategies in infinite games, </title> <booktitle> in: Proc. of 12th Annual Symp. on Theoretical Aspects of Computer Science, LNCS 900 (1995) 113. </booktitle>
Reference-contexts: Since this result, infinite games became a central tool in the theory of automata on infinite objects <ref> [9, 13, 23, 19, 20] </ref>. They were also used in understanding logics of programs [9, 18, 21]. <p> When considering program synthesis, however, one usually takes into account game graphs of size at most polynomial in the number of colours in the winning condition. (Although finitely definable infinite size games also were considered in this context <ref> [5, 20, 22] </ref> and our results are also applicable there). As we will see the case when the size of the game graph is bounded in the number of colours is different and technically more difficult, hence it is appropriate to consider it separately. <p> It is well known that there exists a sequence of games hG n i n2N , each G n of size O (n) and requiring strategy automata of size 2 n <ref> [20, 12] </ref>. Hence synthesized program may be exponentially larger than the specification. While it is still possible to imagine that we can deal with problems having worst case exponential time complexity, it is hard to imagine how we can cope with exponential space complexity. <p> We improve on them, showing an (n!) lower bound. This closes the gap between previously known lower bounds and the factorial upper bound of LAR's. This may come as a slight surprise, because some claims to the contrary have been quoted (see <ref> [20] </ref>, p. 9). Finally let us mention the following algorithmic problem: given a game and a node, establish whether player 0 has a winning strategy from this node. McNaughton [15] gives an algorithm working in time exponential in the number of colours. <p> Remark: It is easy to show (see <ref> [15, 23, 20] </ref>) that Attr W i (T ) is the set of vertices in W from which player i can force the play into T using a memoryless strategy. <p> Player 0 has a winning strategy in this game that consists of keeping LAR memory and choosing a number equal to the number of negative integers appearing before the change pointer in the LAR (for a description of LAR memory see <ref> [20] </ref>). To implement this strategy using a p-automaton, we can take n I/O automata, each for storing one coordinate of the LAR. Then we add a component that takes care of input/output and of updating the other components.
Reference: [21] <author> I. WALUKIEWICZ, </author> <title> Completeness of Kozen's axiomatisation of the propositional mu-calculus, </title> <booktitle> in: Proc. of 10th Annual IEEE Symp. on Logic in Computer Science (1995) 1424. </booktitle>
Reference-contexts: Since this result, infinite games became a central tool in the theory of automata on infinite objects [9, 13, 23, 19, 20]. They were also used in understanding logics of programs <ref> [9, 18, 21] </ref>. It was also observed that a game may be considered as a specification of a reactive system by viewing it as a description of all possible interactions between player 0 (Control) and player 1 (Environment). <p> Hence the size of the required memory influences the size of the automaton for the complement. In particular it can change this size from single to double exponential. In the area of program logics, additional memory reflects in complications in proof constructions as for example in <ref> [21] </ref> or in tableau constructions [3, 6]. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's [11, 15, 23]. Most importantly, however, the question of memory size is crucial in the program synthesis.
Reference: [22] <author> I. WALUKIEWICZ, </author> <title> Pushdown processes: games and model checking, </title> <booktitle> in: Proc. 8th Int. Conf. on Computer Aided Verification, LNCS 1102 (1996) 6274. </booktitle>
Reference-contexts: When considering program synthesis, however, one usually takes into account game graphs of size at most polynomial in the number of colours in the winning condition. (Although finitely definable infinite size games also were considered in this context <ref> [5, 20, 22] </ref> and our results are also applicable there). As we will see the case when the size of the game graph is bounded in the number of colours is different and technically more difficult, hence it is appropriate to consider it separately.
Reference: [23] <author> W. ZIELONKA, </author> <title> Infinite games on finitely coloured graphs with applications to automata on infinite trees, </title> <type> Technical Re port, </type> <institution> UniversitOEe Bordeaux I, </institution> <year> 1994, </year> <note> to appear in TCS. 12 </note>
Reference-contexts: 1 Introduction 1997 IEEE We consider games played on (not necessarily finite) graphs coloured with a finite number of colours <ref> [15, 23] </ref>. The two players alternatively choose vertices forming an infinite path through the game graph. The winner is established by a Muller winning condition (defined on the finite set of colours). <p> Since this result, infinite games became a central tool in the theory of automata on infinite objects <ref> [9, 13, 23, 19, 20] </ref>. They were also used in understanding logics of programs [9, 18, 21]. <p> In the area of program logics, additional memory reflects in complications in proof constructions as for example in [21] or in tableau constructions [3, 6]. In these applications it is important to understand the structure of the additional memory. Until now essentially the only known memory structure were LAR's <ref> [11, 15, 23] </ref>. Most importantly, however, the question of memory size is crucial in the program synthesis. It measures the inherent blow-up of the size of a program satisfying a specification in terms of the size of the specification itself. <p> p-automata realising winning strategies exist for all games with winning conditions that can be represented by a Tur-ing machine working in a space polynomial in the number of colours used in the condition. 1.2 Comparison with the related work Our upper bound theorem was inspired by the paper of Zielonka <ref> [23] </ref>. He mentions some savings in memory for winning strategies by considering his notion of useful colours. This observation is sufficient for showing mem-oryless determinacy for games with Rabin winning conditions (see also [7, 13]). In general his bound is not optimal. <p> Thus w.l.o.g. we can assume that player 0 has a strategy to win from every vertex of the arena. To meet this requirement it is enough to restrict the arena to the winning set of player 0. It turns out (see <ref> [11, 15, 23] </ref>) that for the games we consider the winning strategies can be realized by functions that do not have to refer to the whole histories of the play (i.e., the elements of the set V fl ), but only to a finite information about the play so far. <p> Remark: It is easy to show (see <ref> [15, 23, 20] </ref>) that Attr W i (T ) is the set of vertices in W from which player i can force the play into T using a memoryless strategy. <p> Remark: According to our proviso, player 0 has a strategy from every vertex of the game. With this assumption it can be shown (see <ref> [23] </ref>) that indeed v 2 S W ; hence there exists required in the last clause of the above definition. <p> Hence i G is winning for player 0 and Theorem 6 is proved. fl Remark: Note that, in particular, if P (C) n F is closed under union, i.e., F can be expressed by a Rabin condition (see <ref> [23] </ref>), then the strategy i G is memoryless. Memoryless determinacy for such games was shown in [7, 13].
References-found: 23

