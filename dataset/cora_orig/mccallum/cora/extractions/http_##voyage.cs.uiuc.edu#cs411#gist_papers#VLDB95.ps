URL: http://voyage.cs.uiuc.edu/cs411/gist_papers/VLDB95.ps
Refering-URL: http://voyage.cs.uiuc.edu/cs411/gist.htm
Root-URL: http://www.cs.uiuc.edu
Email: jmh@cs.berkeley.edu  naughton@cs.wisc.edu  avi@cs.berkeley.edu  
Title: Generalized Search Trees for Database Systems (Extended Abstract)  
Author: Joseph M. Hellerstein Jeffrey F. Naughton Avi Pfeffer 
Address: Wisconsin, Madison  Wisconsin, Madison  Berkeley  
Affiliation: University of  University of  University of California,  
Abstract: This paper introduces the Generalized Search Tree (GiST), an index structure supporting an extensible set of queries and data types. The GiST allows new data types to be indexed in a manner supporting queries natural to the types; this is in contrast to previous work on tree extensibility which only supported the traditional set of equality and range predicates. In a single data structure, the GiST provides all the basic search tree logic required by a database system, thereby unifying disparate structures such as B+-trees and R-trees in a single piece of code, and opening the application of search trees to general extensibility. To illustrate the flexibility of the GiST, we provide simple method implementations that allow it to behave like a B+-tree, an R-tree, and an RD-tree, a new index for data with set-valued attributes. We also present a preliminary performance analysis of RD-trees, which leads to discussion on the nature of tree indices and how they behave for various datasets. 
Abstract-found: 1
Intro-found: 1
Reference: [Aok91] <author> P. M. Aoki. </author> <title> Implementation of Extended Indexes in POSTGRES. </title> <journal> SIGIR Forum, </journal> <volume> 25(1) </volume> <pages> 2-9, </pages> <year> 1991. </year>
Reference-contexts: Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES <ref> [Sto86, Aok91] </ref>, and are included in Illustra [Ill94], both of which have distinct extensible B+-tree and R-tree implementations. These extensible indices allow many types of data to be indexed, but only support a fixed set of query predicates.
Reference: [BKSS90] <author> Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, and Bernhard Seeger. </author> <title> The R*-tree: An Efficient and Robust Access Method For Points and Rectangles. </title> <booktitle> In Proc. ACM-SIGMOD Page 11 International Conference on Management of Data, </booktitle> <pages> pages 322-331, </pages> <address> Atlantic City, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees <ref> [BKSS90] </ref> and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. <p> This metric of change in area is the one proposed by Guttman [Gut84]. * PickSplit (P ) A variety of algorithms have been proposed for R-tree splitting. We thus omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and <ref> [BKSS90] </ref>. The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree [SRF87]. <p> omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and <ref> [BKSS90] </ref>. The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree [SRF87]. The R*-tree differs from the basic R-tree in three ways: in its PickSplit algorithm, which has a variety of small changes, in its ChooseSubtree algorithm, which varies only slightly, and in its policy of reinserting a number of keys during node split.
Reference: [BKSS94] <author> Thomas Brinkhoff, Hans-Peter Kriegel, Ralf Schneider, and Bernhard Seeger. </author> <title> Multi-Step Processing of Spatial Joins. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994, </year> <pages> pages 197-208. </pages>
Reference-contexts: We chose RD-trees for two reasons: 1. We were able to implement the methods in Illustra R trees. 2. Set data can be cooked to have almost arbitrary over 3 Better approximations than bounding boxes have been considered for doing spatial joins <ref> [BKSS94] </ref>. However, this work proposes using bounding boxes in an R*-tree, and only using the more accurate approximations in main memory during post-processing steps. Page 9 This surface was generated from data presented in [HNP95].
Reference: [CDF + 94] <author> Michael J. Carey, David J. DeWitt, Michael J. Franklin, Nancy E. Hall, Mark L. McAuliffe, Jeffrey F. Naughton, Daniel T. Schuh, Mar-vin H. Solomon, C. K. Tan, Odysseas G. Tsatalos, Seth J. White, and Michael J. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994, </year> <pages> pages 383-394. </pages>
Reference-contexts: Implementing a new set of methods for the GiST is a significantly easier task than implementing a new tree package from scratch: for example, the POSTGRES [Gro94] and SHORE <ref> [CDF + 94] </ref> implementations of R-trees and B+-trees are on the order of 3000 lines of C or C++ code each, while our method implementations for the GiST are on the order of 500 lines of C code each.
Reference: [CDG + 90] <author> M.J. Carey, D.J. DeWitt, G. Graefe, D.M. Haight, J.E. Richardson, D.H. Schuh, E.J. Shekita, </author> <title> and S.L. Vandenberg. The EXODUS Extensible DBMS Project: An Overview. </title> <editor> In Stan Zdonik and David Maier, editors, </editor> <booktitle> Readings In Object-Oriented Database Systems. </booktitle> <publisher> Morgan-Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects <ref> [CDG + 90] </ref>, hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc.
Reference: [Com79] <author> Douglas Comer. </author> <title> The Ubiquitous B-Tree. </title> <journal> Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-137, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: 1 Introduction An efficient implementation of search trees is crucial for any database system. In traditional relational systems, B+-trees <ref> [Com79] </ref> were sufficient for the sorts of queries posed on the usual set of alphanumeric data types. Today, database systems are increasingly being deployed to support new applications such as geographic information systems, multimedia systems, CAD tools, document libraries, sequence databases, fingerprint identification systems, biochemical databases, etc. <p> Section 7 concludes with a discussion of the significance of the work, and directions for further research. 1.2 Related Work A good survey of search trees is provided by Knuth [Knu73], though B-trees and their variants are covered in more detail by Comer <ref> [Com79] </ref>. There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. <p> This is the technique used in SHORE's R-trees, for example, which upon insertion take a polygon and compress it to its bounding box, which is itself a valid polygon. It is also used in prefix B+-trees <ref> [Com79] </ref>, which truncate split keys to an initial substring. More involved implementations might use complex methods for both Compress and Decompress. 3.4 Tree Methods The key methods in the previous section must be provided by the designer of the key class.
Reference: [FB74] <author> R. A. Finkel and J. L. Bentley. Quad-Trees: </author> <title> A Data Structure For Retrieval On Composite Keys. </title> <journal> ACTA Informatica, </journal> <volume> 4(1) </volume> <pages> 1-9, </pages> <year> 1974. </year>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees <ref> [FB74] </ref>, k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data.
Reference: [FK94] <author> Christos Faloutsos and Ibrahim Kamel. </author> <title> Beyond Uniformity and Independence: Analysis of R-trees Using the Concept of Fractal Dimension. </title> <booktitle> In Proc. 13th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 4-13, </pages> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Despite these limitations, extensible R-trees are close enough to GiSTs to allow for the initial method implementations and performance experiments we describe in Section 5. Analyses of R-tree performance have appeared in <ref> [FK94] </ref> and [PSTW93]. This work is dependent on the spatial nature of typical R-tree data, and thus is not generally applicable to the GiST. <p> Currently such estimates are reasonably accurate for B+-trees, and less so for R-trees. Recently, some work on R-tree cost estimation has been done <ref> [FK94] </ref>, but more work is required to bring this to bear on GiSTs in general. As an additional problem, the user-defined GiST methods may be time-consuming operations, and their CPU cost should be registered with the optimizer [HS93].
Reference: [Gro94] <institution> The POSTGRES Group. </institution> <note> POSTGRES Reference Manual, Version 4.2. Technical Report M92/85, </note> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Implementing a new set of methods for the GiST is a significantly easier task than implementing a new tree package from scratch: for example, the POSTGRES <ref> [Gro94] </ref> and SHORE [CDF + 94] implementations of R-trees and B+-trees are on the order of 3000 lines of C or C++ code each, while our method implementations for the GiST are on the order of 500 lines of C code each. <p> For example, POSTGRES B+-trees support the usual ordering predicates (&lt;; ; =; ; &gt;), while POSTGRES R-trees support only the predicates Left, Right, OverLeft, Overlap, OverRight, Right, Contains, Contained and Equal <ref> [Gro94] </ref>. Extensible R-trees actually provide a sizable subset of the GiST's functionality. To our knowledge this paper represents the first demonstration that R-trees can index data that has not been mapped into a spatial domain.
Reference: [Gut84] <author> Antonin Guttman. R-Trees: </author> <title> A Dynamic Index Structure For Spatial Searching. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Manage ment of Data, </booktitle> <pages> pages 47-57, </pages> <address> Boston, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: This requirement has motivated two major research approaches in extending search tree technology: 1. Specialized Search Trees: A large variety of search trees has been developed to solve specific problems. Among the best known of these trees are spatial search trees such as R-trees <ref> [Gut84] </ref>. While some of this work has had significant impact in particular domains, the approach of fl Hellerstein and Naughton were supported by NSF grant IRI-9157357. <p> There are a variety of multidimensional search trees, such as R-trees <ref> [Gut84] </ref> and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. <p> For example, Penalty for keys from R 2 can be defined as area (Union (fE 1 ; E 2 g)) area (E 1 :p 1 ) <ref> [Gut84] </ref>. * PickSplit (P ): given a set P of M + 1 entries (p; ptr), splits P into two sets of entries P 1 ; P 2 , each of size at least kM . The choice of the minimum fill factor for a tree is controlled here. <p> This metric of change in area is the one proposed by Guttman <ref> [Gut84] </ref>. * PickSplit (P ) A variety of algorithms have been proposed for R-tree splitting. We thus omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and [BKSS90]. <p> This metric of change in area is the one proposed by Guttman <ref> [Gut84] </ref>. * PickSplit (P ) A variety of algorithms have been proposed for R-tree splitting. We thus omit this method implementation from our discussion here, and refer the interested reader to [Gut84] and [BKSS90]. The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree [SRF87]. <p> Alternatively, return the change in a weighted cardinality, where each element of Zhas a weight, and jSj is the sum of the weights of the elements in S. * PickSplit (P ) Guttman's quadratic algorithm for R-tree split works naturally here. The reader is referred to <ref> [Gut84] </ref> for details. This GiST supports the usual R-tree query predicates, has containment keys, and uses a traditional R-tree algorithm for PickSplit. As a result, we were able to implement these methods in Illustra's extensible R-trees, and get behavior identical to what the GiST behavior would be.
Reference: [HNP95] <author> Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. </author> <title> Generalized Search Trees for Database Systems. </title> <type> Technical Report #1274, </type> <institution> Uni versity of Wisconsin at Madison, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: When there is a linear order on the keys they use B+-tree-style borrow or coalesce techniques. Otherwise they use R-tree-style reinsertion techniques. The deletion algorithms are omitted here due to lack of space; they are given in full in <ref> [HNP95] </ref>. 4 The GiST for Three Applications In this section we briefly describe implementations of key classes used to make the GiST behave like a B+-tree, an R-tree, and an RD-tree, a new R-tree-like index over set-valued data. 4.1 GiSTs Over Z (B+-trees) In this example we index integer data. <p> However, this work proposes using bounding boxes in an R*-tree, and only using the more accurate approximations in main memory during post-processing steps. Page 9 This surface was generated from data presented in <ref> [HNP95] </ref>. Compression loss was calculated as (numranges 20)=numranges, while data overlap was calculated as overlap=10. lap, as opposed to polygon data which is contiguous within its boundaries, and hence harder to manipulate. <p> For each of the 30 datasets, five queries were performed. Each query searched for objects overlapping a different tooth of the first comb. The query performance was measured in number of I/Os, and the five numbers averaged per dataset. A chart of the performance appears in <ref> [HNP95] </ref>. More illustra tive is the 3-d plot shown in Figure 3, where the x and y axes are the same as in Figure 2, and the z axis represents the average number of I/Os. <p> A full-fledged database system is more than just a secondary storage manager, however. In this section we point out some important database system issues which need to be considered when implementing the GiST. Due to space constraints, these are only sketched here; further discussion can be found in <ref> [HNP95] </ref>. * In-Memory Efficiency: The discussion above shows how the GiST can be efficient in terms of disk access. To streamline the efficiency of its in-memory computation, we open the implementation of the Node object to extensibility.
Reference: [HP94] <author> Joseph M. Hellerstein and Avi Pfeffer. </author> <title> The RD-Tree: An Index Structure for Sets. </title> <type> Technical Report #1252, </type> <institution> University of Wisconsin at Madi-son, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Union (fE 1 = (S 1 ; ptr 1 ); : : : ; E n = (S n ; ptr n )g) Return S 1 [ : : : [ S n . * Compress (E = (S; ptr)) A variety of compression techniques for sets are given in <ref> [HP94] </ref>. We briefly describe one of them here. <p> It can be shown that this algorithm produces a rangeset of n items with minimal addition of elements not in S <ref> [HP94] </ref>. * Decompress (E = (rangeset; ptr)) Rangesets are easily converted back to sets by enumerating the elements in the ranges. * Penalty (E 1 = (S 1 ; ptr 1 ); E 2 = (S 2 ; ptr 2 ) Return jE 1 :S 1 [ E 2 :S 2
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate Migration: Optimizing Queries With Expensive Predicates. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994, </year> <pages> pages 267-276. </pages>
Reference-contexts: Recently, some work on R-tree cost estimation has been done [FK94], but more work is required to bring this to bear on GiSTs in general. As an additional problem, the user-defined GiST methods may be time-consuming operations, and their CPU cost should be registered with the optimizer <ref> [HS93] </ref>.
Reference: [Ill94] <institution> Illustra Information Technologies, Inc. </institution> <note> Illustra User's Guide, Illustra Server Release 2.1, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES [Sto86, Aok91], and are included in Illustra <ref> [Ill94] </ref>, both of which have distinct extensible B+-tree and R-tree implementations. These extensible indices allow many types of data to be indexed, but only support a fixed set of query predicates.
Reference: [Jag90] <author> H. V. Jagadish. </author> <title> Linear Clustering of Objects With Multiple Attributes. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Atlantic City, </address> <month> May </month> <year> 1990, </year> <pages> pages 332-342. </pages>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve <ref> [Jag90] </ref>; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES [Sto86, Aok91], and are included in Illustra [Ill94], both of which have distinct extensible B+-tree and R-tree implementations.
Reference: [KB95] <author> Marcel Kornacker and Douglas Banks. </author> <title> High-Concurrency Locking in R-Trees. </title> <booktitle> In Proc. 21st International Conference on Very Large Data Bases, </booktitle> <address> Zurich, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: We are considering extending the results of Kor-nacker and Banks for R-trees <ref> [KB95] </ref> to our implemen tation of GiSTs. * Variable-Length Keys: It is often useful to allow keys to vary in length, particularly given the Compress method available in GiSTs.
Reference: [KG94] <author> Won Kim and Jorge Garza. </author> <title> Requirements For a Performance Benchmark For Object-Oriented Systems. </title> <editor> In Won Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability and Beyond. </title> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In this section, we demonstrate that the GiST can provide support for a new search tree that indexes set-valued data. The problem of handling set-valued data is attracting increasing attention in the Object-Oriented database community <ref> [KG94] </ref>, and is fairly natural even for traditional relational database applications. For example, one might have a university database with a table of students, and for each student an attribute courses passed of type setof (integer).
Reference: [KKD89] <author> Won Kim, Kyung-Chang Kim, and Alfred Dale. </author> <title> Indexing Techniques for Object-Oriented Databases. </title> <editor> In Won Kim and Fred Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 371-394. </pages> <publisher> ACM Press and Addison-Wesley Publishing Co., </publisher> <year> 1989. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 [WE80], k-D-B-trees [Rob81], Ch-trees <ref> [KKD89] </ref>, Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc.
Reference: [Knu73] <author> Donald Ervin Knuth. </author> <title> Sorting and Searching, </title> <booktitle> volume 3 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1973. </year>
Reference-contexts: Section 6 examines some details that need to be considered when implementing GiSTs in a full-fledged DBMS. Section 7 concludes with a discussion of the significance of the work, and directions for further research. 1.2 Related Work A good survey of search trees is provided by Knuth <ref> [Knu73] </ref>, though B-trees and their variants are covered in more detail by Comer [Com79]. There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90].
Reference: [LJF94] <author> King-Ip Lin, H. V. Jagadish, and Christos Falout-sos. </author> <title> The TV-Tree: An Index Structure for High Dimensional Data. </title> <journal> VLDB Journal, </journal> <volume> 3 </volume> <pages> 517-542, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees <ref> [LJF94] </ref>, etc.
Reference: [LS90] <author> David B. Lomet and Betty Salzberg. </author> <title> The hB-Tree: A Multiattribute Indexing Method. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(4), </volume> <month> De-cember </month> <year> 1990. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees <ref> [LS90] </ref>, V-trees [MCD94], TV-trees [LJF94], etc. <p> There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees <ref> [LS90] </ref>. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data.
Reference: [LY81] <author> P. L. Lehman and S. B. Yao. </author> <title> Efficient Locking For Concurrent Operations on B-trees. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <year> 1981. </year>
Reference-contexts: N2: [next on neighboring node] If E is the righ-most entry on its node, let P be the next node to the right of R on the same level of the tree (this can be found via tree traversal, or via sideways pointers in the tree, when available <ref> [LY81] </ref>.) If P is non-existent, return NULL. Otherwise, let N be the leftmost entry on P . If Consistent (N; q), then return N , else return NULL. 3.4.3 Insert The insertion routines guarantee that the GiST remains balanced.
Reference: [MCD94] <author> Maurcio R. Mediano, Marco A. Casanova, and Marcelo Dreux. </author> <title> V-Trees A Storage Method For Long Vector Data. </title> <booktitle> In Proc. 20th International Conference on Very Large Data Bases, </booktitle> <pages> pages 321-330, </pages> <address> Santiago, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 [WE80], k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees <ref> [MCD94] </ref>, TV-trees [LJF94], etc.
Reference: [PSTW93] <author> Bernd-Uwe Pagel, Hans-Werner Six, Heinrich Toben, and Peter Widmayer. </author> <title> Towards an Analysis of Range Query Performance in Spatial Data Structures. </title> <booktitle> In Proc. 12th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 214-221, </pages> <address> Washington, D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Despite these limitations, extensible R-trees are close enough to GiSTs to allow for the initial method implementations and performance experiments we describe in Section 5. Analyses of R-tree performance have appeared in [FK94] and <ref> [PSTW93] </ref>. This work is dependent on the spatial nature of typical R-tree data, and thus is not generally applicable to the GiST.
Reference: [PTSE95] <author> Dimitris Papadias, Yannis Theodoridis, Timos Sellis, and Max J. Egenhofer. </author> <title> Topological Relations in the World of Minimum Bounding Rectangles: A Study with R-trees. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Manage ment of Data, </booktitle> <address> San Jose, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Again, observe that one could fairly easily support more complex predicates, including n-dimensional analogs of the disjunctive queries and ranked keys mentioned for B+- trees, as well as the topological relations of Papadias, et al. <ref> [PTSE95] </ref> Other examples include arbitrary variations of the usual overlap or ordering queries, e.g. find all polygons that overlap more than 30% of this box, or find all polygons that overlap 12 to 1 o'clock, which for a given point p returns all polygons that are in the region bounded by
Reference: [Rob81] <author> J. T. Robinson. </author> <title> The k-D-B-Tree: A Search Structure for Large Multidimensional Dynamic Indexes. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 10-18, </pages> <address> Ann Arbor, </address> <month> April/May </month> <year> 1981. </year>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 [WE80], k-D-B-trees <ref> [Rob81] </ref>, Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc. <p> There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees [SRF87]. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees <ref> [Rob81] </ref>, and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data.
Reference: [SRF87] <author> Timos Sellis, Nick Roussopoulos, and Christos Faloutsos. </author> <title> The R+-Tree: A Dynamic Index For Multi-Dimensional Objects. </title> <booktitle> In Proc. 13th International Conference on Very Large Data Bases, </booktitle> <pages> pages 507-518, </pages> <address> Brighton, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: There are a variety of multidimensional search trees, such as R-trees [Gut84] and their variants: R*- trees [BKSS90] and R+-trees <ref> [SRF87] </ref>. Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. <p> The above implementations, along with the GiST algorithms described in the previous chapters, give behavior identical to that of Guttman's R-tree. A series of variations on R-trees have been proposed, notably the R*-tree [BKSS90] and the R+-tree <ref> [SRF87] </ref>. The R*-tree differs from the basic R-tree in three ways: in its PickSplit algorithm, which has a variety of small changes, in its ChooseSubtree algorithm, which varies only slightly, and in its policy of reinserting a number of keys during node split.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Inclusion of New Types in Relational Database Systems. </title> <booktitle> In Proceedings of the IEEE Fourth International Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <address> Washington, D.C., </address> <month> February </month> <year> 1986. </year>
Reference-contexts: Search Trees For Extensible Data Types: As an alternative to developing new data structures, existing data structures such as B+-trees and R-trees can be made extensible in the data types they support <ref> [Sto86] </ref>. For example, B+-trees can be used to index any data with a linear ordering, supporting equality or linear range queries over that data. While this provides extensibility in the data that can be indexed, it does not extend the set of queries which can be supported by the tree. <p> Other multidimensional search trees include quad-trees [FB74], k-D-B-trees [Rob81], and hB-trees [LS90]. Multidimensional data can also be transformed into unidimensional data using a space-filling curve [Jag90]; after transformation, a B+-tree can be used to index the resulting unidimensional data. Extensible-key indices were introduced in POSTGRES <ref> [Sto86, Aok91] </ref>, and are included in Illustra [Ill94], both of which have distinct extensible B+-tree and R-tree implementations. These extensible indices allow many types of data to be indexed, but only support a fixed set of query predicates.
Reference: [WE80] <author> C. K. Wong and M. C. Easton. </author> <title> An Efficient Method for Weighted Sampling Without Replacement. </title> <journal> SIAM Journal on Computing, </journal> <volume> 9(1) </volume> <pages> 111-113, </pages> <month> February </month> <year> 1980. </year> <pages> Page 12 </pages>
Reference-contexts: The GiST can be adapted to work like a variety of other known search tree structures, e.g. partial sum trees Page 1 <ref> [WE80] </ref>, k-D-B-trees [Rob81], Ch-trees [KKD89], Exodus large objects [CDG + 90], hB-trees [LS90], V-trees [MCD94], TV-trees [LJF94], etc. <p> Finally, observe that one could fairly easily support more complex predicates, including disjunctions of intervals in query predicates, or ranked intervals in key predicates for supporting efficient sampling <ref> [WE80] </ref>. 4.2 GiSTs Over Polygons in R 2 (R-trees) In this example, our data are 2-dimensional polygons on the Cartesian plane. Before compression, the keys in this tree are 4-tuples of reals, representing the upper-left and lower-right corners of rectilinear bounding rectangles for 2d-polygons.
References-found: 29

