URL: http://www.cs.mu.oz.au/tr_db/mu_92_08.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: e-mail: fjah,raog@cs.mu.oz.au  
Title: Constraint Propagation for Linear Recursive Rules  
Author: James Harland Kotagiri Ramamohanarao 
Address: Parkville, 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Abstract: There are many ways in which the query answering process for deductive databases may be optimised. Many of these methods rely on applying constraints as soon as possible, to avoid the production and later rejection of facts which are not relevant to the query. This propagation of constraints is much simpler for left-linear programs than for many others. In this paper we show how to transform right-linear and mixed-linear programs into a left-linear form, to make constraint propagation more effective. Our technique generalises the magic set transformation for linear programs; the magic set transformation can only propagate constraints of the form X = a, whereas our technique can handle arbitrary goals as constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Harland and K. Ramamohanarao, </author> <title> Constraints for Query Optimization in Deductive Databases, </title> <booktitle> to appear at the Second Far East Workshop on Future Database Systems, </booktitle> <address> Kyoto, </address> <month> April, </month> <year> 1992. </year>
Reference-contexts: If these domains are large and the intersection of them small, then there is will be a significant benefit in propagating such a constraint. A method for doing this, based on fold/unfold transformations was given in <ref> [1] </ref>; essentially the "domain" constraint is propagated into t 1 . Clearly such methods will be useful in a general constraint propagation package. It is important to note that the particular transformations used here make depend upon the definitions being regular, i.e. right-linear, left-linear etc.
Reference: [2] <author> D. Kemp, K. Ramamohanarao, I. Balbin and K. Meenakshi, </author> <title> Propagating Constraints in Recursive Deductive Databases, </title> <booktitle> Proceedings of the North American Conference on Logic Programming 981-998, </booktitle> <address> Cleveland, </address> <month> October, </month> <year> 1989. </year>
Reference: [3] <author> D. Kemp, K. Ramamohanarao and Z. Somogyi, Right-, </author> <title> Left- and Multi-linear Rule Transformations which Maintain Context Information, </title> <booktitle> Proceedings of the Sixteenth International Conference on Very Large Databases 380-391, </booktitle> <address> Brisbane, </address> <month> August, </month> <year> 1990. </year>
Reference-contexts: In this paper we show transformation process for right-, mixed-, and multi-linear programs. Our method applies not just to binding constraints, but to any constraint, unlike the context transformations of <ref> [3, 5] </ref>. Thus we arrive at a general and powerful method of constraint propagation. In particular, the optimization of the magic set transformation for right-linear programs of [6] is a particular instance of our scheme. This technique may be used for multi-linear programs as well. <p> A mixed-linear predicate p is a simple mixed-linear predicate if it contains only right-linear or left-linear rules. Note that we allow a mixed-linear recursion to contain left-multi-linear recursions but not multi-linear ones. Thus our mixed-linear rules correspond to those of [6] rather than those of <ref> [3] </ref>, in which a mixed-linear recursion may contain a multi-linear rule. It should be clear that any mixed-linear predicate which is not multi-linear may be divided into a simple mixed-linear program and multi-linear rules. We shall see the significance of this class of programs in the next section. <p> Note that this requires that the constraint have a single solution. For constraints which have a finite number of solutions, the context transformation of <ref> [3] </ref> may be used. Our transformation does not have this restriction, so that constraints with an infinite number of solutions, such as X &gt; 1, may be used. An important point to note is that the latter version of the program is left-linear (in the predicate m). <p> Hence, the use of left-linear programs to propagate constraints provides us with a powerful and general method of constraint propagation. Another point to note is that our transformation gives a similar result to the context transformation of <ref> [3] </ref>. The relevant context-transformed program is below. mc anc (C; C) :- t (C). ac anc (C; Y ) :- mc anc (C; Z); p (Z; Y ). answers (C; Y ) :- t (C); ac anc (C; Y ).
Reference: [4] <author> J.W. Lloyd, </author> <title> Foundations of Logic Programming, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year> <month> 23 </month>
Reference-contexts: We shall see the significance of this class of programs in the next section. We will also need to make use of the well known T P operator. For completeness, we give the definition below; further details may be found in <ref> [4] </ref>. Definition 2.6 Let P be a program. <p> For further information on this point, see <ref> [4] </ref>. 6 3 Transformations to "Left-Linear" Programs Consider the query ?- t (X); anc (X; Y ) and the anc relation defined below. anc (X; Y ) :- q (X; Y ). Note that for the adornment bf , this is right-linear.
Reference: [5] <author> I. Mumick and H. Pirahesh, </author> <title> Overbound and Right-Linear Queries, </title> <booktitle> Proceedings of the ACM Symposium on Principles of Database Systems 127-141, </booktitle> <month> March, </month> <year> 1991. </year>
Reference-contexts: In this paper we show transformation process for right-, mixed-, and multi-linear programs. Our method applies not just to binding constraints, but to any constraint, unlike the context transformations of <ref> [3, 5] </ref>. Thus we arrive at a general and powerful method of constraint propagation. In particular, the optimization of the magic set transformation for right-linear programs of [6] is a particular instance of our scheme. This technique may be used for multi-linear programs as well. <p> Hence it would seem that this is a particular instance of a more general scheme, i.e. that programs be transformed into left-linear forms whenever possible, and then propagate constraints. It is shown in <ref> [5] </ref> how right-linear and left-linear programs may be considered duals of each other.
Reference: [6] <author> J. Naughton, R. Ramakrishnan, Y. Sagiv and J. Ullman, </author> <title> Efficient Evaluation of Right-, Left-, and Multi-Linear Rules, </title> <booktitle> Proceedings of the SIGMOD International Symposium on Management of Data 235-242, </booktitle> <address> Portland, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: For example, consider the query ?- t (1; Y ) for the program below. t (X; Y ) :- p (X; Y ). The magic set transformation for the adornment bf , together with the refinements of <ref> [6] </ref> produces the program and query below. ?- f t (Y ). m (Z) :- m (X); p (X; Z). <p> Our method applies not just to binding constraints, but to any constraint, unlike the context transformations of [3, 5]. Thus we arrive at a general and powerful method of constraint propagation. In particular, the optimization of the magic set transformation for right-linear programs of <ref> [6] </ref> is a particular instance of our scheme. This technique may be used for multi-linear programs as well. <p> It should be noted that linear programs are an important class, and have been the subject of much study in the past <ref> [6, 7, 10] </ref>. For this reason, efficient query evaluation for such programs is an important issue, and in this paper we have attempted to give a maximally general method of constraint propagation for this class of programs. This paper is organised as follows. <p> Given that the definition of t (X) may be arbitrary, this class of constraints is maximally general among constraints that do not depend on the output variables. Below we give the definitions of left-linear, right-linear, mixed-linear and multi-linear programs <ref> [6] </ref>. <p> A mixed-linear predicate p is a simple mixed-linear predicate if it contains only right-linear or left-linear rules. Note that we allow a mixed-linear recursion to contain left-multi-linear recursions but not multi-linear ones. Thus our mixed-linear rules correspond to those of <ref> [6] </ref> rather than those of [3], in which a mixed-linear recursion may contain a multi-linear rule. It should be clear that any mixed-linear predicate which is not multi-linear may be divided into a simple mixed-linear program and multi-linear rules. <p> Now for purposes of comparison, if we assume that t (X) is a (single-valued) binding constraint such as X = 1, then the magic set transformation of <ref> [6] </ref> is applicable. Under this transformation, for the query anc (1; Y ) we arrive at the following program: 7 anc 1 (Y ) :- m (X); q (X; Y ). m (1). Note that this requires that the constraint have a single solution. <p> Then by eliminating the third rule, which is redundant, and utilizing the fact that t (X) is just X = 1, we arrive at anc t2 (Y ) :- m (X); p (X; Y ). m (1). which is the transformation of <ref> [6] </ref> for this program. Hence, the use of left-linear programs to propagate constraints provides us with a powerful and general method of constraint propagation. Another point to note is that our transformation gives a similar result to the context transformation of [3]. <p> As noted above, this transformation requires that t (X) be a binding constraint (as t (C) is used to generate tuples), whereas our transformation does not. Another case considered in <ref> [6] </ref> is that of multi-linear rules. For example, given the query anc (1; Y ) and the program anc (X; Y ) :- p (X; Y ). the transformation of [6] gives the program anc 1 (Y ) :- m (X); p (X; Y ). m (1). <p> Another case considered in <ref> [6] </ref> is that of multi-linear rules. For example, given the query anc (1; Y ) and the program anc (X; Y ) :- p (X; Y ). the transformation of [6] gives the program anc 1 (Y ) :- m (X); p (X; Y ). m (1). Moreover, it is not hard to see that this program is equivalent to the one below. 21 anc 1 (Y ) :- m (X); p (X; Y ). m (1). <p> Moreover, it is not hard to see that this program is equivalent to the one below. 21 anc 1 (Y ) :- m (X); p (X; Y ). m (1). This is just the transformation of <ref> [6] </ref> for the left-linear case. In our case, the transformation gives anc t (X; Y ) :- t (X); p (X; Y ). which also is just the same as our transformation for the left-linear version of the anc predicate. <p> Then we may exploit the nature of t (X) to obtain anc t1 (Y ) :- p (1; Y ). It should be noted that a similar propagation paradigm may be followed for pseudo left-linear predicates <ref> [6] </ref>, i.e. those of the form p (X ; Y ) :- e (X; Y ) However, when mixing such recursions with right-linear ones, there doesn't seem to be an analogous result to Proposition 3.8, in that there doesn't seem to be a way to rewrite such a program as a
Reference: [7] <author> J. Naughton, R. Ramakrishnan, Y. Sagiv and J. Ullman, </author> <title> Argument Reduction by Factoring, </title> <booktitle> Proceedings of the Fifteenth International Conference on Very Large Data Bases 173-182, </booktitle> <address> Amsterdam, </address> <month> August, </month> <year> 1989. </year>
Reference-contexts: It should be noted that linear programs are an important class, and have been the subject of much study in the past <ref> [6, 7, 10] </ref>. For this reason, efficient query evaluation for such programs is an important issue, and in this paper we have attempted to give a maximally general method of constraint propagation for this class of programs. This paper is organised as follows.
Reference: [8] <author> T. Sato and H. Tamaki, </author> <title> Deterministic Transformation and Deterministic Synthesis, Programming of Future Generation Computers II 307-327, </title> <editor> K. Fuchi and L. Koptt (eds.), </editor> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Thus a general technique, such as the one given in this paper, would be supplemented by certain specialised methods of constraint propagation. A particular case in which the fold/unfold transformations <ref> [9, 8] </ref> may be of use is when the constraints are not explicitly given. For example, consider the goal ?- t 1 (X; Y ); t 2 (Y; Z) 22 where t 1 and t 2 are two different transitive closure programs.
Reference: [9] <author> H. Tamaki and T. Sato, </author> <title> Unfold/Fold Transformation of Logic Programs, </title> <booktitle> Proceedings of the Second International Conference on Logic Programming 127-138, </booktitle> <address> Uppsala, </address> <month> July, </month> <year> 1984. </year>
Reference-contexts: Thus a general technique, such as the one given in this paper, would be supplemented by certain specialised methods of constraint propagation. A particular case in which the fold/unfold transformations <ref> [9, 8] </ref> may be of use is when the constraints are not explicitly given. For example, consider the goal ?- t 1 (X; Y ); t 2 (Y; Z) 22 where t 1 and t 2 are two different transitive closure programs.
Reference: [10] <author> J. Ullman, </author> <title> Implementation of Logical Query Languages for Databases, </title> <journal> ACM Transactions on Database Systems 10:3:289-321, </journal> <year> 1985. </year> <month> 24 </month>
Reference-contexts: It should be noted that linear programs are an important class, and have been the subject of much study in the past <ref> [6, 7, 10] </ref>. For this reason, efficient query evaluation for such programs is an important issue, and in this paper we have attempted to give a maximally general method of constraint propagation for this class of programs. This paper is organised as follows. <p> We will also make use of the usual notion of adornment <ref> [10] </ref> in order to express mode information. For every derived relation in the database, we code the valid modes for the relation into the name of the relation. <p> We shall use the default left-to-right sideways information-passing strategy (sip) through out this paper <ref> [10] </ref>. 3 Given a goal p (X ; Y ) where the adornment of p is b m f n and jXj = m and jY j = n, a constraint is an any atom t (X).
References-found: 10

