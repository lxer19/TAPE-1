URL: ftp://ftp.cs.columbia.edu/reports/reports-1991/cucs-026-91.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1991.html
Root-URL: http://www.cs.columbia.edu
Title: An Architectural Framework for Object Management Systems (Area Paper)  
Author: Steven S. Popovich 
Note: Copyright 1991 Steven S. Popovich  
Date: 3 September 1991  
Address: New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Pubnum: CUCS-026-91  
Abstract: Much research has been done in the last decade in the closely related areas of object-oriented programming languages and databases. Both areas now seem to be working toward a common end, that of an object management system, or OMS. An OMS is constructed similarly to an OODB but provides a general purpose concurrent object oriented programming language as well, sharing the object base with the OODB query facilities. In this paper, we will define several different types of object systems (object servers, persistent OOPL's, OODB's and OMS's) in terms of their interfaces and capabilities. We will examine the distinguishing features and general architecture of systems of each type in the light of a general model of OMS architecture. Popovich is supported in part by NASA grant NGT 50583. The Programming Systems Laboratory is supported by National Science Foundation grants CCR-9000930 and CCR-8858029, by grants from AT&T, BNR, DEC and SRA, by the New York State Center for Advanced Technology in Computers and Information Systems and by the NSF Engineering Research Center for Telecommunications Research. 
Abstract-found: 1
Intro-found: 1
Reference: [Andrews 87] <author> Timothy Andrews and Craig Harris. </author> <title> Combining Language and Database Advances in an Object-Oriented Development Environment. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> Object-Oriented Programming Systems, Languages, and Applications Conference, </booktitle> <pages> pages 430-440. </pages> <publisher> ACM Press, </publisher> <month> October, </month> <year> 1987. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 22(12), </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: There is not as yet, however, such an agreement on many concurrency issues. 14 2.4.1. Ontos Ontos [Ontologic 89] is a commercially available OMS, built as an improvement on its predecessor OODB, Vbase <ref> [Andrews 87] </ref>, by the same company, Ontologic, Inc. It provides access to objects through any of several language interfaces, C++ and Lisp among them, and interoperable locking and optimistic transactions on the objects. Ontos provides a transaction group mechanism based on that in ObServer II, thus allowing cooperative transactions.
Reference: [Atkinson 90] <author> Malcolm Atkinson, Francois Bancilhon, David DeWitt, Klaus Dittrich, David Maier and Stanley Zdonik. </author> <title> The Object-Oriented Database System Manifesto. Deductive and Object-Oriented Databases. </title> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: An OMS commonly appears as a database within which objects are specified by use of an object-oriented language, and whose objects are available to its programming language. The similarity of the requirements expressed by the database community [Stonebraker 90] and the object-oriented research community <ref> [Atkinson 90] </ref> in their respective "manifestos" shows clearly that OMS's are an idea whose time has come, and which is becoming increasingly well-defined. 1 In this paper, we survey several object servers , persistent OOPL's, OODB's and OMS's 1 We do not abbreviate this term, since shortening it to OS's would <p> In an OMS, it is desirable to provide both functions. A rule formalism can encompass both functions in a single mechanism, and so the emerging consensus in the object-oriented and database communities, as stated in [Stonebraker 90] and <ref> [Atkinson 90] </ref>, is that such a mechanism should be part of any OMS. There is not as yet, however, such an agreement on many concurrency issues. 14 2.4.1.
Reference: [Bancilhon 88] <author> Francois Bancilhon. </author> <title> Object-Oriented Database Systems. </title> <booktitle> In 7th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 152-162. </pages> <year> 1988. </year>
Reference-contexts: The standard relational, hierarchical and network models have been found unsuitable for certain emerging application areas, such as engineering environments and applied AI, and they have adopted the object-oriented paradigm as a possible solution to their problem. Bancilhon <ref> [Bancilhon 88] </ref> gives a view of the state of the art in object-oriented database (OODB) research.
Reference: [Barghouti 90] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Modeling Concurrency in Rule-Based Development Environments. </title> <booktitle> IEEE Expert 5(6) </booktitle> <pages> 15-27, </pages> <month> December, </month> <year> 1990. </year>
Reference-contexts: The "objects", for example, might be byte strings, simple data items as in a conventional database, or entire files on disk, or might exist explicitly as an interface to a server. 5 2.1.4. DHOMS DHOMS (Dynamic Hierarchical Object Management System) [Ben-Shaul 91] is the object server for the Marvel <ref> [Barghouti 90] </ref> rule-based software development environment. DHOMS has a layered architecture, as shown in Figure 2-4.
Reference: [Bayer 77] <author> R. Bayer and M. Schkolnick. </author> <title> Concurrency of Operations on B-trees. </title> <journal> Acta Informatica (9), </journal> <year> 1977. </year>
Reference-contexts: Since EXODUS provides large (but not composite) objects, it must deal with the concurrency control problems created by insert, append, and delete operations on large objects, which may change their structure. EXODUS uses a well-known non-two-phase B+-tree locking protocol <ref> [Bayer 77] </ref> to preserve the consistency of its trees when the structure of a large object may be changed. 3.4.5. Iris Since Iris is based on a relational back end, it does not lock objects in the sense that the other systems do.
Reference: [Ben-Shaul 91] <author> Israel Ben-Shaul. </author> <title> An Object Management System for Multi-User Programming Environments. </title> <type> Technical Report CUCS-010-91, </type> <institution> Columbia University, </institution> <month> March, </month> <year> 1991. </year>
Reference-contexts: The "objects", for example, might be byte strings, simple data items as in a conventional database, or entire files on disk, or might exist explicitly as an interface to a server. 5 2.1.4. DHOMS DHOMS (Dynamic Hierarchical Object Management System) <ref> [Ben-Shaul 91] </ref> is the object server for the Marvel [Barghouti 90] rule-based software development environment. DHOMS has a layered architecture, as shown in Figure 2-4.
Reference: [Benzaken 90] <author> V. Benzaken and C. Delobel. </author> <title> Enhancing Performance in a Persistent Object Store: </title> <booktitle> Clustering Strategies in O . 2 In 4th International Workshop on Persistent Object Systems, </booktitle> <pages> pages 375-384. </pages> <address> Martha's Vineyard, MA, </address> <month> September, </month> <year> 1990. </year>
Reference-contexts: This is possible because, as stated above, the object identifier contains the exact location of the object. O allows the programmer (actually, one particular programmer -- the DBA) to specify 2 clustering of object on disk by constructing placement trees <ref> [Benzaken 90] </ref>. These specify, for each class at the root of a placement tree, a set of attributes of specified classes that should be clustered with each instance of the class. Because it is a tree, it can also specify further clustering of the children's attributes, to any finite depth.
Reference: [Black 86] <author> Andrew Black, Norman Hutchinson, Eril Jul and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> Object-Oriented Programming Systems, Languages and Applications Conference, </booktitle> <pages> pages 78-86. </pages> <publisher> ACM, </publisher> <address> Portland OR, </address> <month> September, </month> <year> 1986. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: The language has a type structure, which often uses classes and single or multiple inheritance for code sharing. The type structure may, however, use delegation (for code sharing) and/or conformance (as a specification sharing mechanism). For example, Emerald <ref> [Black 86] </ref> is a persistent OOPL built on the unconventional notion of type conformance. In Emerald, an object is a member of an abstract type rather than an instance of a class.
Reference: [Blasgen 77] <author> M. W. Blasgen and K. P. Eswaran. </author> <title> Storage and access in relation databases. </title> <journal> IBM Systems Journal 16(4) </journal> <pages> 363-377, </pages> <year> 1977. </year> <month> 57 </month>
Reference-contexts: Below the kernel is the Storage Manager, which is actually the relational storage subsystem of the HP-SQL database, extended to support generation of unique object identifiers. The Storage Manager is very similar to System R's RSS <ref> [Blasgen 77] </ref>. Above the kernel are a set of interfaces to the DBMS, namely, the Object SQL ad-hoc query language, a graphical database editor, a C language interface, and an embedding of SQL at the statement level in various host languages. <p> The old version of the object is deleted. 3.5.5. Iris Since the Iris transaction manager is provided by its relational back end, it is similar to that of System R's RSS <ref> [Blasgen 77] </ref>. It provides atomic, serializable transactions using two-phase locking. Transactions may not be nested, and distributed transactions are not supported. 3.5.6. Argus Argus supports nested transactions, which may cross guardian boundaries.
Reference: [Bloch 89] <author> Joshua J. Bloch. </author> <title> The Camelot Library: A C Language Extension for Programming a General Purpose Distributed Transaction System. </title> <booktitle> In 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 172-180. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Newport Beach CA, </address> <month> June, </month> <year> 1989. </year>
Reference-contexts: Spector [Spector 89] has proposed a general architecture for distributed database systems based on the Camelot architecture. Camelot provides a locking-based transaction facility through a library <ref> [Bloch 89] </ref> with primitives for multi-threaded concurrency and remote procedure call access to the transaction server.
Reference: [Carey 86] <author> Michael J. Carey, David J. DeWitt, Daniel Frank, Goetz Graefe, M. Muralikrishna, Joel E. Richardson and Eugene J. Shekita. </author> <title> The Architecture of the EXODUS Extensible DBMS. </title> <booktitle> In 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 52-65. </pages> <address> Pacific Grove, CA, </address> <month> September, </month> <year> 1986. </year>
Reference-contexts: Some OODB's provide a compiled data manipulation language, generally in the form of an OOPL, as well as ad-hoc query access, but other OODB's allow access only through the query facility. 2.2.1. EXODUS EXODUS <ref> [Richardson 87; Carey 86] </ref> is an extensible object-oriented data base. It may be extended by adding new data types to the system. <p> While their design, allowing replacement modules for these to be written in E, is no doubt quite general and should allow implementation of any imaginable access method or concurrency control scheme, Carey et al. acknowledge in their paper <ref> [Carey 86] </ref> that programming some of these modules (particularly concurrency control stubs) is likely to be very difficult and unlikely to be undertaken by users of the EXODUS system. The EXODUS storage manager allows grouping objects together into a file object.
Reference: [Chou 85] <author> H.-T. Chou, David J. DeWitt, Randy H. Katz and Anthony C. King. </author> <title> Design and Implementation of the Wisconsin Storage System. </title> <journal> Software Practice and Experience 15(10), </journal> <month> October, </month> <year> 1985. </year>
Reference-contexts: There are object management components in both the client and server processes, as well as a level of caching in each. The server itself uses WiSS, the Wisconsin Storage System <ref> [Chou 85] </ref>, as a storage manager. Figure 2-8 shows this situation.
Reference: [Christou 88] <author> Vassiliki Christou and J. Eliot B. Moss. </author> <title> Persistent Owl: Heap Management and Integration with Mneme. </title> <type> Technical Report 88-78, </type> <institution> University of Massachusetts, </institution> <month> August, </month> <year> 1988. </year>
Reference-contexts: Persistent OOPL's are sometimes built on top of an underlying object server. Persistent Owl <ref> [Christou 88] </ref>, built at the University of Massachusetts on top of Mneme [Moss 88], is an example of this. Avalon [Detlefs 88; Clamen 90], built at Carnegie-Mellon University on top of the Camelot [Spector 88] server, is similar.
Reference: [Clamen 90] <author> Stewart M. Clamen, Linda D. Leibengood, Scott M. Nettles and Jeannette M. Wing. </author> <title> Reliable Distributed Computing with Avalon/Common Lisp. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 169-179. </pages> <address> New Orleans LA, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: Persistent OOPL's are sometimes built on top of an underlying object server. Persistent Owl [Christou 88], built at the University of Massachusetts on top of Mneme [Moss 88], is an example of this. Avalon <ref> [Detlefs 88; Clamen 90] </ref>, built at Carnegie-Mellon University on top of the Camelot [Spector 88] server, is similar. In this case, however, the object server is separate from the Camelot transaction server. <p> Avalon Avalon is actually two persistent OOPL's implemented using Camelot as a back end. One uses C++ [Detlefs 88] as the base programming language, and the other uses the Common Lisp Object System <ref> [Clamen 90] </ref>. Avalon uses the Camelot primitives to provide object classes supporting atomicity and recoverability. The Avalon programmer can then use these as superclasses to implement persistent, recoverable, and atomic objects, while other objects that do not inherit from the Avalon classes are transient.
Reference: [Dahl 66] <author> Ole-Johan Dahl and Kristen Nygaard. </author> <title> SIMULA an ALGOL-Based Simulation Language. </title> <journal> Communications of the ACM 9(9) </journal> <pages> 671-678, </pages> <month> September, </month> <year> 1966. </year>
Reference-contexts: 1. Introduction: Object Management Systems Object-oriented programming languages (OOPL's) have existed for more than twenty years, since the development of Simula-67 <ref> [Dahl 66] </ref>, and have become popular during the 1980's, with the initial success of Smalltalk-80 [Goldberg 83] encouraging much subsequent research into object-oriented languages. The area has been extensively investigated, with many languages being developed, each taking a somewhat different approach to object orientation.
Reference: [Dasgupta 88] <author> Partha Dasgupta, Richard J. Leblanc Jr. and William F. Appelbe. </author> <title> The Clouds Distributed Operating System: Functional Description, Implementation Details and Related Work. </title> <booktitle> In 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 2-9. </pages> <address> San Jose CA, </address> <month> June, </month> <year> 1988. </year>
Reference-contexts: Since MELD transactions use an optimistic algorithm, locks are not needed by transactions. The transaction manager is built on the object manager facilities for message passing between internal transaction ``objects'', and consists of a set of ``methods'' for these ``objects''. 2.3.4. Clouds Clouds <ref> [Dasgupta 88] </ref> is actually an object-oriented operating system, rather than a language. However, Clouds incorporates a language, as well as transaction management on its objects, so we list it here under the heading of OOPL's. <p> In this last case, it also uses the object manager. Table 3-1 summarizes the main features of each object system's type manager. The transaction server (Camelot [Spector 88]), the byte server (ObServer II [Hornick 87]) and the object-oriented operating system (Clouds <ref> [Dasgupta 88] </ref>) do not have type managers. The type manager in Mneme [Moss 88] would be part of its back end, and Basic Mneme has no type manager in its simple back end.
Reference: [Detlefs 88] <author> David Detlefs, Maurice Herlihy and Jeannette Wing. </author> <title> Inheritance of Synchronization and Recovery Properties in Avalon/C++. </title> <booktitle> Computer 21(12) </booktitle> <pages> 57-69, </pages> <month> December, </month> <year> 1988. </year>
Reference-contexts: Persistent OOPL's are sometimes built on top of an underlying object server. Persistent Owl [Christou 88], built at the University of Massachusetts on top of Mneme [Moss 88], is an example of this. Avalon <ref> [Detlefs 88; Clamen 90] </ref>, built at Carnegie-Mellon University on top of the Camelot [Spector 88] server, is similar. In this case, however, the object server is separate from the Camelot transaction server. <p> The architectural structure of Argus has not been discussed in the available literature, so we assume that each of these is simply a module within the Argus runtime system. 2.3.2. Avalon Avalon is actually two persistent OOPL's implemented using Camelot as a back end. One uses C++ <ref> [Detlefs 88] </ref> as the base programming language, and the other uses the Common Lisp Object System [Clamen 90]. Avalon uses the Camelot primitives to provide object classes supporting atomicity and recoverability. <p> The type manager in Mneme [Moss 88] would be part of its back end, and Basic Mneme has no type manager in its simple back end. The only type management in Argus [Liskov 88] is CLU's runtime type management; object type definitions are not stored persistently. Similarly, Avalon <ref> [Detlefs 88] </ref> provides no type management other than that normally provided by C++ (or Common Lisp). In each of these systems, the structure of persistent object classes is assumed not to change, and is compiled into each of the programs that use the classes.
Reference: [Duchamp 90] <author> Dan Duchamp, Joshua J. Bloch, Jeffrey L. Eppinger, Alfred Z. Spector and Dean Thompson. </author> <title> Design Rationale of the Camelot Transaction Processing Facility. </title> <type> Technical Report CUCS-008-90, </type> <institution> Columbia University, </institution> <year> 1990. </year> <note> Submitted for publication. </note>
Reference-contexts: That is the responsibility of a separate data server. Both the data servers and the transaction manager communicate with a separate disk manager, which is responsible for maintaining stable storage both for objects and for log entries. This situation is illustrated in simple transaction with one participating data server <ref> [Duchamp 90] </ref>. 42 The diagram shows the top-level components involved in the transaction (boxes), as well as the messages (arrows) passed between them.
Reference: [Eppinger 90] <author> Jeffrey L. Eppinger, Lily B. Mummert and Alfred Z. Spector. </author> <title> Guide to the Camelot Distributed Transaction Facility including the Avalon Language. </title> <month> July, </month> <year> 1990. </year>
Reference-contexts: Recovery support is provided automatically by Avalon. Note, however, that it is necessary to call read_lock and write_lock before accessing the data in the object; otherwise, Avalon's concurrency control strategy will break down. 2 The example class in Figure 3-5 is taken from the Avalon manual <ref> [Eppinger 90] </ref> . It serves to illustrate that writing atomic classes in Avalon can be very simple. The same class, however, takes a full page of code to specify if written using the SUBATOMIC class. The class atomic_int has only two public functions.
Reference: [Eswaran 76] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Database System. </title> <journal> Communications of the ACM 19(11) 624-632, November, 1976. 58 </journal>
Reference-contexts: In this case, however, the object server is separate from the Camelot transaction server. Both object servers and persistent OOPL's commonly make use of serializable atomic transactions, originally developed to ensure database consistency, for concurrency control and reliability support (crash recovery) <ref> [Eswaran 76] </ref>. Meanwhile, the database community has recognized a need for a new database model.
Reference: [Fernandez 89a] <author> Mary F. Fernandez, Stanley B. Zdonik and Alan N. Ewald. </author> <title> ObServer: A Storage System for Object-Oriented Applications. </title> <month> September, </month> <year> 1989. </year>
Reference-contexts: An Object Server without a DDL is known as a byte server, since the objects it stores are simply streams of bytes, with no semantics attached to the bytes. An Object Server generally supports some level of concurrency, although single-user Object Servers do exist. 2.1.1. ObServer II ObServer II <ref> [Hornick 87; Fernandez 89a] </ref> is perhaps the best known of the object servers. Its objects are simple, undifferentiated collections of bytes, so ObServer is also the best known byte server. In ObServer, all objects live on a central server, which manages the objects and controls access to them.
Reference: [Fernandez 89b] <author> Mary F. Fernandez and Stanley B. Zdonik. </author> <title> Transaction Groups: A Model for Controlling Cooperative Work. </title> <booktitle> In 3rd International Workshop on Persistent Object Systems: Their Design, Implementation and Use, </booktitle> <pages> pages 128-138. </pages> <address> Queensland, Australia, </address> <month> January, </month> <year> 1989. </year>
Reference-contexts: Thus, although most of ObServer II's transactions are the usual atomic and serializable locking type, it is possible to represent optimistic concurrency control (using communication-based locking) and extended transaction models in ObServer II. ObServer's distinguishing design feature is the transaction group <ref> [Fernandez 89b; Hornick 87] </ref> mechanism for cooperating transactions. A transaction group is a set of transactions (and possibly transaction groups) that share access to a set of objects. Objects may be locked on behalf of a group rather than an individual transaction.
Reference: [Fishman 89] <author> D. H. Fishman, J. Annevelink, E. Chow, T. Connors, J. W. Davis, W. Hasan, C. G. Hoch, W. Kent, S. Leichner, P. Lyngbaek, B. Mahbod, M. A. Neimat, T. Risch, M. C. Shan and W. K. Wilkinson. </author> <title> Overview of the Iris DBMS. Object-Oriented Concepts, Databases, and Applications. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989, </year> <pages> pages 219-250, </pages> <note> Chapter 10. </note>
Reference-contexts: The type manager and storage object manager, along with the front-end parser and query compiler, form the kernel of the EXODUS system and cannot be changed or replaced by the user, although they are parameterized by the database schema. 2.2.2. Iris Iris <ref> [Fishman 89] </ref> is an object-oriented data base being developed at Hewlett-Packard (HP) Laboratories using a relational database as its back end. The Iris architecture [Wilkinson 90], as shown in Figure 2-6, consists of three layers.
Reference: [Goldberg 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80 The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1983. </year>
Reference-contexts: 1. Introduction: Object Management Systems Object-oriented programming languages (OOPL's) have existed for more than twenty years, since the development of Simula-67 [Dahl 66], and have become popular during the 1980's, with the initial success of Smalltalk-80 <ref> [Goldberg 83] </ref> encouraging much subsequent research into object-oriented languages. The area has been extensively investigated, with many languages being developed, each taking a somewhat different approach to object orientation. Wegner [Wegner 87] has developed a taxonomy of these various approaches.
Reference: [Gray 75] <author> J. Gray, R. Lorie and G. Putzolu. </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Database. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 428-451. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1975. </year>
Reference-contexts: The user may also write handler functions. 3.4.10. Orion Orion uses standard shared read/exclusive write locks on simple objects; on complex objects, it uses a granularity locking protocol with intention lock modes. This is also, for the most part, a standard protocol <ref> [Gray 75] </ref>. Three lock modes are added: ISO, IXO, and SIXO. They are described succinctly by two examples from Kim et al. [Kim 89]: 1. To access the Vehicle composite object Vi: a. Lock the Vehicle class object in IS (intention shared) mode. b.
Reference: [Gray 78] <author> J. Gray. </author> <booktitle> Notes on Database Operating Systems. Lecture Notes in Computer Science. Volume 60: Operating Systems: an Advanced Course. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1978. </year>
Reference-contexts: Avalon In Avalon/C++, storage management is provided by the RESILIENT class. Its interface consists of two operations: pin and unpin. These implement a write-ahead locking protocol <ref> [Gray 78] </ref>. Before accessing an object, it is pinned in memory. The modifications are then made, and the unpin operation called.
Reference: [Hornick 87] <author> Mark F. Hornick and Stanley B. </author> <note> Zdonik. </note>
Reference-contexts: An Object Server without a DDL is known as a byte server, since the objects it stores are simply streams of bytes, with no semantics attached to the bytes. An Object Server generally supports some level of concurrency, although single-user Object Servers do exist. 2.1.1. ObServer II ObServer II <ref> [Hornick 87; Fernandez 89a] </ref> is perhaps the best known of the object servers. Its objects are simple, undifferentiated collections of bytes, so ObServer is also the best known byte server. In ObServer, all objects live on a central server, which manages the objects and controls access to them. <p> In this last case, it also uses the object manager. Table 3-1 summarizes the main features of each object system's type manager. The transaction server (Camelot [Spector 88]), the byte server (ObServer II <ref> [Hornick 87] </ref>) and the object-oriented operating system (Clouds [Dasgupta 88]) do not have type managers. The type manager in Mneme [Moss 88] would be part of its back end, and Basic Mneme has no type manager in its simple back end. <p> Thus, although most of ObServer II's transactions are the usual atomic and serializable locking type, it is possible to represent optimistic concurrency control (using communication-based locking) and extended transaction models in ObServer II. ObServer's distinguishing design feature is the transaction group <ref> [Fernandez 89b; Hornick 87] </ref> mechanism for cooperating transactions. A transaction group is a set of transactions (and possibly transaction groups) that share access to a set of objects. Objects may be locked on behalf of a group rather than an individual transaction.
References-found: 27

