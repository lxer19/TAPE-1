URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-260.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: COMPILE TIME ANALYSIS OF C AND C SYSTEMS  Written under the direction of  
Author: BY HEMANT D. PANDE Dr. Barbara G. Ryder 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: May, 1996  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 1
Reference: [AG96] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Software Engineering, </booktitle> <year> 1996. </year>
Reference: [AH90] <author> H. Agrawal and J.R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <month> June </month> <year> 1990. </year> <journal> Also available as SIGPLAN Notices, </journal> <volume> vol 25, no 6, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [AH95] <author> A. Agesen and U. Holzle. </author> <title> Type feedback vs. concrete type inference: a comparison of optimization techniques for object-oriented languages. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '95), </booktitle> <pages> pages 91-107, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: A comparison of the two techniques appears in <ref> [AH95] </ref> using SELF as the target language. Although type feedback can be (and has been) applied to languages like C ++ which use pointers extensively, existing type inference techniques for SELF do not extend naturally to handle the additional complications of pointer induced aliasing. <p> Although type feedback techniques are more suitable for interactive systems and are scalable to handle large and extensible systems, the results of type feedback depend heavily on run time information or representative profiles <ref> [AH95] </ref>. Although they are effective on most executions, their predictions cannot be extrapolated to all executions of the program and hence must provide run time support to handle the situations which may deviate from those inferred from previous executions.
Reference: [AL95] <author> R. Z. Altucher and W. Landi. </author> <title> An extended form of must alias analysis for dynamic allocation. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 74-84, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Ours is the first polynomial-time approximation algorithm for def-use associations for C programs. The algorithm has contributed to further research in the area of 117 software re-engineering: (i) it has been extended to improve the quality of def-uses for dynamically allocated locations <ref> [AL95] </ref>, (ii) it has been adapted to perform data flow testing on classes [HR94] and (iii) it has been used to study the effectiveness of data flow based test coverage [HFGO94].
Reference: [APS93] <author> O. Agesen, J. Palsberg, and M. Schwartzbach. </author> <title> Type inference of SELF: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In European Conference on Object-Oriented Programming (ECOOP '93), </booktitle> <pages> pages 247-267, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Agesen et al. present a polynomial time constraint based type inferencing algorithm for SELF to compute approximate types of all expressions in the program, including the types of receivers at dynamic dispatch sites <ref> [APS93] </ref>. Kumar et al. improve on this technique by utilizing the Static Single Assignment form of object-oriented programs [KAI95]. Since each use of an object is reached by at most one definition, their framework can track the program points where a particular receiver may have a Nil value.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [Ban79] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference: [BC92] <author> M. Burke and Jong-Deok Choi. </author> <title> Precise and efficient integration of inter-procedural alias information into data flow analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 14-21, </pages> <month> March </month> <year> 1992. </year>
Reference: [BCCH94] <author> Michael Burke, Paul Carini, J-D. Choi, and M. Hind. </author> <title> Flow-insensitive in-terprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings of the 7th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1994. </year> <month> 174 </month>
Reference-contexts: The latter can use the constraint based approach to arrive at an initial approximation of types for untyped variables and proceed with flow analysis. Function Pointer Analysis Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCCH94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous.
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental in-terprocedural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference: [Cal88] <author> D. Callahan. </author> <title> The prgram summary graph and flow-sensitive interproce-dural data flow analysis. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <month> June </month> <year> 1988. </year>
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Since C ++ is closely related to C (but distinguishes itself from the latter with the significant addition of object-oriented paradigm and polymorphism), our work closely relates to Landi's pointer induced aliasing work for C [Lan92a]. Other techniques for flow-sensitive pointer aliasing include <ref> [CBC93, Deu94, EGH94, WL95] </ref>. They are disparate in representation, complexity and precision. Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques. <p> Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques. Recently, Carini et al. [CHS95] have developed a type determination algorithm for C ++ using the aliasing technique presented in <ref> [CBC93] </ref>.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: Previous researches have proposed general theoretical frameworks to solve interprocedural data flow problems precisely <ref> [CC77, SP81] </ref>. However, they have not led to corresponding practical implementations. Others have proposed data flow frameworks for interprocedural problems with precise, polynomial-time solution procedures [KRS94, Lan92a, RHS95].
Reference: [CG94] <author> B. Calder and D. Grunwald. </author> <title> Reducing indirect function call overhead in C ++ programs. </title> <booktitle> In Conference Record of the Twenty-first Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397-408, </pages> <month> Jan-uary </month> <year> 1994. </year>
Reference-contexts: In Figure 6.1 we classify the reachable virtual call sites in terms of the number of virtual functions found invocable. Our results support the observation by Calder and Grunwald that although object-oriented libraries support polymorphism through virtual functions, the target of most indirect function calls can be accurately predicted <ref> [CG94] </ref>. While their observation is based on execution profiles of programs, our results eliminate the dependence on profile data by using compile time analysis which accounts for all possible executions of the program. <p> Holzle and Ungar [HU94] employ type feedback for optimizing dynamically dispatched 112 calls in SELF. Calder and Grunwald <ref> [CG94] </ref> use their profile based measurements on C ++ programs to demonstrate that virtual function resolution is applicable and beneficial to C ++ .
Reference: [CGZ95] <author> B. Calder, D. Grunwald, and B. Zorn. </author> <title> Quantifying behavioural differences between C and C ++ programs. </title> <journal> Journal of Programming Languages, </journal> <volume> 2 </volume> <pages> 313-351, </pages> <year> 1995. </year>
Reference: [CHS95] <author> P. R. Carini, M. Hind, and H. Srinivasan. </author> <title> Flow-sensitive type analysis for C ++ . Research Report RC 20267, </title> <institution> IBM T. J. Watson Research Center, </institution> <year> 1995. </year>
Reference-contexts: Other techniques for flow-sensitive pointer aliasing include [CBC93, Deu94, EGH94, WL95]. They are disparate in representation, complexity and precision. Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques. Recently, Carini et al. <ref> [CHS95] </ref> have developed a type determination algorithm for C ++ using the aliasing technique presented in [CBC93].
Reference: [CK88] <author> K. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <month> June </month> <year> 1988. </year>
Reference: [CK89] <author> K. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The maximum number of parameters for a function is bounded by a constant over the entire program <ref> [CK89] </ref>. Given this assumption the parameter binding functions are constant time (Section 5.4.2). 2. The value of k, the maximum number of dereferences maintained explicitly by our algorithm, is a small constant. The maximum k used by our algorithm is 5. 3. <p> Flow Analysis of Object-Oriented Languages The algorithm by Larcheveque factors out from type determination the side effects of function invocations and aliasing due to parameter bindings as well as pointers [Lar92]. The suggested algorithms for these problems <ref> [CK89, Wei80] </ref> are grossly approximate and unsuitable in a C ++ context. Parameswaran has developed an algorithm which performs alias analysis without the knowledge of the receiver type at an invocation site and thus assuming that all corresponding virtual functions are invocable [Par92].
Reference: [CU89] <author> C. Chambers and D. Ungar. </author> <title> Customization: optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Prior work on improving run-time efficiency of SELF uses customization, iterative type analysis and inline caches to replace dynamic binding with procedure calls or inlined code <ref> [CU89, CU90, HCU91] </ref>. Although type feedback techniques are more suitable for interactive systems and are scalable to handle large and extensible systems, the results of type feedback depend heavily on run time information or representative profiles [AH95].
Reference: [CU90] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting: optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Prior work on improving run-time efficiency of SELF uses customization, iterative type analysis and inline caches to replace dynamic binding with procedure calls or inlined code <ref> [CU89, CU90, HCU91] </ref>. Although type feedback techniques are more suitable for interactive systems and are scalable to handle large and extensible systems, the results of type feedback depend heavily on run time information or representative profiles [AH95].
Reference: [DCG95] <author> J. Dean, C. Chambers, and D. Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <month> June </month> <year> 1995. </year> <month> 175 </month>
Reference-contexts: Type feedback uses information from previous or current executions of the program to determine the possible receiver classes, while type inference approaches the same goal by analyzing the program's source code at compile time. Type Feedback Recent work by Dean et al. <ref> [DCG95] </ref> uses a combination of type feedback and static class hierarchy information for specialization (compiling multiple versions of a method) based on subsets of possible argument classes of the method. Holzle and Ungar [HU94] employ type feedback for optimizing dynamically dispatched 112 calls in SELF.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: beyond k-limiting. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Since C ++ is closely related to C (but distinguishes itself from the latter with the significant addition of object-oriented paradigm and polymorphism), our work closely relates to Landi's pointer induced aliasing work for C [Lan92a]. Other techniques for flow-sensitive pointer aliasing include <ref> [CBC93, Deu94, EGH94, WL95] </ref>. They are disparate in representation, complexity and precision. Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques.
Reference: [DMM95] <author> A. Diwan, J. E. B. Moss, and K. S. McKinley. </author> <title> Analyzing statically-typed object-oriented programs for modern processors. </title> <type> Technical report, </type> <institution> department of computer science, University of Massachusetts, Amherst, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: In contrast, in a C ++ program, an equivalent method invocation would have already been compiled as a direct function call. Diwan et al. have effectively applied hierarchy information and a limited form of static analysis to optimize Modula-3 programs <ref> [DMM95] </ref>. Nevertheless, such simple techniques proved less effective on our C ++ benchmarks, as demonstrated empirically in Section 6.4. Kuhn 113 and Binkley use a simple transformation which replaces virtual invocations in C ++ with direct calls within a decision statement [KB95].
Reference: [EGH94] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-257, </pages> <month> June </month> <year> 1994. </year> <note> Published as SIGPLAN Notices, 29 (6). </note>
Reference-contexts: The latter can use the constraint based approach to arrive at an initial approximation of types for untyped variables and proceed with flow analysis. Function Pointer Analysis Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCCH94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous. <p> Since C ++ is closely related to C (but distinguishes itself from the latter with the significant addition of object-oriented paradigm and polymorphism), our work closely relates to Landi's pointer induced aliasing work for C [Lan92a]. Other techniques for flow-sensitive pointer aliasing include <ref> [CBC93, Deu94, EGH94, WL95] </ref>. They are disparate in representation, complexity and precision. Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques.
Reference: [Fer95] <author> M. Fernandez. </author> <title> Simple and effective link-time optimization of modula-3 programs. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 103-115, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: We discuss the approaches which factor out aliasing and type determination for object-oriented languages. Class Hierarchy Analysis Class hierarchy information is used at link time by Fer-nandez to replace method invocations with direct calls in Modula-3 programs <ref> [Fer95] </ref>. Since Modula-3 has opaque class hierarchy (where the separate compilation module compiling a derived class may have little information about implementation of the base class), the late binding mechanism is required even for invoking methods inherited from a parent class.
Reference: [FW85] <author> P. G. Frankl and E. J. Weyuker. </author> <title> A data flow testing tool. </title> <booktitle> In Proceedings of IEEE Softfair II, </booktitle> <month> December </month> <year> 1985. </year>
Reference: [FW88] <author> P. Frankl and E. Weyuker. </author> <title> An applicable family of data flow testing criteria. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1483-1498, </pages> <month> Octo-ber </month> <year> 1988. </year>
Reference-contexts: to scale up the analysis to handle bigger programs involve lifting these restrictions, and are described in Chapter 8. 110 Chapter 7 Applications and Related Work 7.1 Def-Use Associations for C Def-use associations are necessary for a range of software development environment tools, and are crucial to data-flow-based testing systems <ref> [FW88, HS89, HS90, OW91, Ost90, RW85] </ref>. Previous efforts to calculate interprocedural def-use associations [HS90, HS91], focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage.
Reference: [GH96] <author> R. Ghiya and L. J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In Conference Record of the Twenty-third Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: We plan to enhance our algorithms to safely handle the constructs which can create circular data structures. It involves additional case analysis during the in-traprocedural propagation phase of the algorithms. Recent work on shape analysis for pointer data structures <ref> [GH96, SRW96] </ref> is relevant in this respect. 6. Our analysis works on the intermediate representation for the whole source program and keeps the entire analysis database in main memory, an approach clearly not suitable for analyzing large programs. We need to re-engineer the algorithms towards modular analysis.
Reference: [Gor93] <author> T. Goradia. </author> <title> Dynamic impact analysis: A cost effective technique to enforce error propagation. </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 171-181, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [Har89] <author> W. L. Harrison. </author> <title> The interprocedural analysis and automatic paralleliza-tion of scheme programs. LISP and Symbolic Computation, </title> <address> 2(3-4):179-396, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Flow Analysis of Higher Order Languages Techniques for flow analysis of higher order languages like Scheme <ref> [Har89, JM79, Shi90] </ref> may be adapted for analyzing function pointers (and hence C ++ ); however, they do not have acceptable complexity for reasonable precision on real programs. The emphasis seems to be on theoretical issues such as being able to solve the problem.
Reference: [HCU91] <author> U. Holzle, C. Chambers, and D. Ungar. </author> <title> Optimizing dynamically-typed object-oriented languages with polymorphic inline caches. </title> <booktitle> In Proceedings of the European Conference on Object Oriented Programming, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: Prior work on improving run-time efficiency of SELF uses customization, iterative type analysis and inline caches to replace dynamic binding with procedure calls or inlined code <ref> [CU89, CU90, HCU91] </ref>. Although type feedback techniques are more suitable for interactive systems and are scalable to handle large and extensible systems, the results of type feedback depend heavily on run time information or representative profiles [AH95].
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: In this domain also, the precision of the def-use information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences. 111 The classical problem of intraprocedural reaching definitions <ref> [Hec77] </ref> was extended to handle interprocedural propagation by Harrold and Soffa [HS90]. In the absence of aliasing, our algorithm is equivalent to theirs in that both obtain the precise solution. <p> Rule 2.1: f [h0; : : : ; h~x] Rule 2.2: f 1 ~x Rule 2.3: f 1 ffi f 2 We now show that F satisfies the following four conditions <ref> [Hec77] </ref>, making it a monotone function space associated with L. 1. Each f 2 F is monotonic.
Reference: [HFGO94] <author> M. Hutchins, H. Foster, T. Goradia, and T. </author> <title> Ostrand. Experiments on the effectiveness of dataflow- and controlflow-based test adequacy criteria. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <year> 1994. </year>
Reference-contexts: area of 117 software re-engineering: (i) it has been extended to improve the quality of def-uses for dynamically allocated locations [AL95], (ii) it has been adapted to perform data flow testing on classes [HR94] and (iii) it has been used to study the effectiveness of data flow based test coverage <ref> [HFGO94] </ref>. Our algorithm for type determination and aliasing is the first attempt to solve this combined problem for an object-oriented language. Empirical studies of C ++ program characteristics have shown that most indirect (virtual) method invocations may be uniquely resolved to direct function calls at run time.
Reference: [HK93] <author> M. Hall and K. Kennedy. </author> <title> Efficient call graph analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 227-242, </pages> <year> 1993. </year> <month> 176 </month>
Reference: [HPR89] <author> S. Horwitz, J. Prins, and T Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1989. </year>
Reference-contexts: The aim of slicing is to concentrate the programmer's attention on those parts of the program significant to the computation under current investigation; the more imprecise the def-use information, the less effectively the slicing method can prune away unrelated computations. Techniques for merging independently altered versions of programs <ref> [HPR89, YHR90] </ref> are of great interest to the programming-in-the-large community.
Reference: [HR94] <author> M. J. Harrold and G. Rothermel. </author> <title> Performing data flow testing on classes. </title> <booktitle> In Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 154-163, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The algorithm has contributed to further research in the area of 117 software re-engineering: (i) it has been extended to improve the quality of def-uses for dynamically allocated locations [AL95], (ii) it has been adapted to perform data flow testing on classes <ref> [HR94] </ref> and (iii) it has been used to study the effectiveness of data flow based test coverage [HFGO94]. Our algorithm for type determination and aliasing is the first attempt to solve this combined problem for an object-oriented language.
Reference: [HRB90] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [HS89] <author> M. J. Harrold and M. L. Soffa. </author> <title> Interprocedural data flow testing. </title> <booktitle> In Proceedings of the Third Testing, Analysis, and Verification Symposium, </booktitle> <pages> pages 158-167, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: to scale up the analysis to handle bigger programs involve lifting these restrictions, and are described in Chapter 8. 110 Chapter 7 Applications and Related Work 7.1 Def-Use Associations for C Def-use associations are necessary for a range of software development environment tools, and are crucial to data-flow-based testing systems <ref> [FW88, HS89, HS90, OW91, Ost90, RW85] </ref>. Previous efforts to calculate interprocedural def-use associations [HS90, HS91], focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage.
Reference: [HS90] <author> M. J. Harrold and M. L. Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In Proceedings of the 1990 International Conference on Computer Languages, </booktitle> <pages> pages 297-306, </pages> <year> 1990. </year>
Reference-contexts: to scale up the analysis to handle bigger programs involve lifting these restrictions, and are described in Chapter 8. 110 Chapter 7 Applications and Related Work 7.1 Def-Use Associations for C Def-use associations are necessary for a range of software development environment tools, and are crucial to data-flow-based testing systems <ref> [FW88, HS89, HS90, OW91, Ost90, RW85] </ref>. Previous efforts to calculate interprocedural def-use associations [HS90, HS91], focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage. <p> Previous efforts to calculate interprocedural def-use associations <ref> [HS90, HS91] </ref>, focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage. <p> this domain also, the precision of the def-use information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences. 111 The classical problem of intraprocedural reaching definitions [Hec77] was extended to handle interprocedural propagation by Harrold and Soffa <ref> [HS90] </ref>. In the absence of aliasing, our algorithm is equivalent to theirs in that both obtain the precise solution.
Reference: [HS91] <author> M. J. Harrold and M. L. Soffa. </author> <title> Selecting and using data for integration testing. </title> <journal> IEEE Software, </journal> <volume> 8(2) </volume> <pages> 58-65, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Previous efforts to calculate interprocedural def-use associations <ref> [HS90, HS91] </ref>, focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage.
Reference: [HS94] <author> M. J. Harrold and M. L. Soffa. </author> <title> Efficient computation of interprocedural definition-use chains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(2) </volume> <pages> 175-204, </pages> <month> March </month> <year> 1994. </year>
Reference: [HU94] <author> U. Holzle and D. Ungar. </author> <title> Optimizing dynamically-dispatched calls with tun-time type feedback. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Type Feedback Recent work by Dean et al. [DCG95] uses a combination of type feedback and static class hierarchy information for specialization (compiling multiple versions of a method) based on subsets of possible argument classes of the method. Holzle and Ungar <ref> [HU94] </ref> employ type feedback for optimizing dynamically dispatched 112 calls in SELF. Calder and Grunwald [CG94] use their profile based measurements on C ++ programs to demonstrate that virtual function resolution is applicable and beneficial to C ++ .
Reference: [JM79] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Flow Analysis of Higher Order Languages Techniques for flow analysis of higher order languages like Scheme <ref> [Har89, JM79, Shi90] </ref> may be adapted for analyzing function pointers (and hence C ++ ); however, they do not have acceptable complexity for reasonable precision on real programs. The emphasis seems to be on theoretical issues such as being able to solve the problem.
Reference: [JW95] <author> S. Jagannathan and A. Wright. </author> <title> Efficient flow analysis for avoiding run-time checks. </title> <booktitle> In Proceedings of the Second International Static Analysis Symposium (SAS '95), </booktitle> <year> 1995. </year> <note> Also appears as Springer-Verlag LNCS-983. </note>
Reference-contexts: It is not clear whether the theory can lead to a practical implementation. Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques <ref> [JW95] </ref>. Flow Analysis of Object-Oriented Languages The algorithm by Larcheveque factors out from type determination the side effects of function invocations and aliasing due to parameter bindings as well as pointers [Lar92]. The suggested algorithms for these problems [CK89, Wei80] are grossly approximate and unsuitable in a C ++ context.
Reference: [KAI95] <author> S. Kumar, D. P. Agrawal, and S. P. Iyer. </author> <title> An improved type-inference algorithm to expose parallelism in object-oriented programs. </title> <booktitle> In Proceedings of the Third Workshop on Languages, Compilers, and Run-Time Systems for Scalable Computers. </booktitle> <publisher> Kluwer Academic Publications, </publisher> <address> Troy, New York, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Kumar et al. improve on this technique by utilizing the Static Single Assignment form of object-oriented programs <ref> [KAI95] </ref>. Since each use of an object is reached by at most one definition, their framework can track the program points where a particular receiver may have a Nil value. Plevyak and Chien describe an incremental constraint based type inference technique for Concurrent Aggregates, a concurrent object-oriented language [PC94].
Reference: [KB95] <author> B. Kuhn and D. Binkley. </author> <title> An enabling optimization for C ++ virtual functions. </title> <booktitle> In Proceedings of Mid-Atlantic States Graduate Workshop on Programming Languages and Systems, </booktitle> <address> East Stroudsburg, PA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Nevertheless, such simple techniques proved less effective on our C ++ benchmarks, as demonstrated empirically in Section 6.4. Kuhn 113 and Binkley use a simple transformation which replaces virtual invocations in C ++ with direct calls within a decision statement <ref> [KB95] </ref>. The class hierarchy information is used to obtain the list of virtual functions possibly invocable at each virtual call site. Having obtained an equivalent program without the construct of virtual calls, they propose applying existing optimization techniques to improve program performance.
Reference: [KL90] <author> B. Korel and J. Laski. </author> <title> Dynamic slicing of computer programs. </title> <journal> Journal of Systems Software, </journal> <volume> 13 </volume> <pages> 187-195, </pages> <year> 1990. </year> <month> 177 </month>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [KRS94] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> A tool kit for constructing optimal interprocedural data flow analyses. </title> <type> Technical Report MIP-9413, </type> <institution> Universitat Passau, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Previous researches have proposed general theoretical frameworks to solve interprocedural data flow problems precisely [CC77, SP81]. However, they have not led to corresponding practical implementations. Others have proposed data flow frameworks for interprocedural problems with precise, polynomial-time solution procedures <ref> [KRS94, Lan92a, RHS95] </ref>. We present an algorithm for approximation formulation of interprocedural type determination using a monotone data flow framework based on a finite multisource lattice [MMR95].
Reference: [KU77] <author> J. B. Kam and J. D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, </pages> <year> 1977. </year>
Reference-contexts: The edge functions 137 representing interprocedural propagation from a call node to entry node (s) and the edge functions representing intraprocedural propagation effectively ignore these components. The use of this multi-component lattice enables us to fit our formulation in the classical definition of a monotone data flow framework <ref> [KU77] </ref>. By employing the well-established results of data flow analysis based on this model, we prove certain properties of the formulation, such as safety and non-distributivity. S ~x represents the ? (bottom) and ; ~x represents the &gt; (top) elements of this semi-lattice.
Reference: [Lak93] <author> A. Lakhotia. </author> <title> Constructing call multigraphs using dependence graphs. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-284, </pages> <month> January </month> <year> 1993. </year>
Reference: [Lan92a] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> January </month> <year> 1992. </year> <note> Available as Laboratory for Computer Science Research Technical Report LCSR-TR-174. </note>
Reference-contexts: Using the assumptions in Section 6.1, a constant amount of work is required to make a predicate true, except when the same predicate 36 Since the design of our algorithm is similar to Landi's pointer aliasing analysis for C, the reasoning is similar to that in <ref> [Lan92a] </ref>. 95 is created in multiple ways. If n is neither a return node nor a pointer assignment, the number of ways a predicate can become true is O (number of ICFG predecessors of n). <p> We are using the MasterCraft C ++ system of Tata Consultancy Services as the front end C ++ parser for the implementation. Our aliasing and type determination algorithm reuses some code from Landi's aliasing algorithm <ref> [Lan92a] </ref> with suitable modifications. We present empirical results of analyzing 19 C ++ programs obtained from various (publicly available) sources such as textbooks, demonstration programs accompanying a C ++ compiler and undergraduate projects. crucial information to retrieve the corresponding non-visible fixed-location from nv. <p> Since C ++ is closely related to C (but distinguishes itself from the latter with the significant addition of object-oriented paradigm and polymorphism), our work closely relates to Landi's pointer induced aliasing work for C <ref> [Lan92a] </ref>. Other techniques for flow-sensitive pointer aliasing include [CBC93, Deu94, EGH94, WL95]. They are disparate in representation, complexity and precision. Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques. <p> Previous researches have proposed general theoretical frameworks to solve interprocedural data flow problems precisely [CC77, SP81]. However, they have not led to corresponding practical implementations. Others have proposed data flow frameworks for interprocedural problems with precise, polynomial-time solution procedures <ref> [KRS94, Lan92a, RHS95] </ref>. We present an algorithm for approximation formulation of interprocedural type determination using a monotone data flow framework based on a finite multisource lattice [MMR95].
Reference: [Lan92b] <author> W. Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4) </volume> <pages> 323-337, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Precise compile time analyses are intractable in the presence of multiple level pointers, and undecidable when recursive data structures are allowed <ref> [Lan92b] </ref>. We have proved that the def-use associations and type determination problems are NP -hard even when only single level pointers are allowed, providing an insight into the inherent complexity of these problems.
Reference: [Lar89] <author> J. R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> May </month> <year> 1989. </year>
Reference: [Lar92] <author> J. M. Larcheveque. </author> <title> Interprocedural type propagation for object-oriented languages. </title> <booktitle> In Proceedings of the Fourth European Symposium on Programming (ESOP '92), </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: Flow Analysis of Object-Oriented Languages The algorithm by Larcheveque factors out from type determination the side effects of function invocations and aliasing due to parameter bindings as well as pointers <ref> [Lar92] </ref>. The suggested algorithms for these problems [CK89, Wei80] are grossly approximate and unsuitable in a C ++ context. Parameswaran has developed an algorithm which performs alias analysis without the knowledge of the receiver type at an invocation site and thus assuming that all corresponding virtual functions are invocable [Par92].
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> SIGPLAN NOTICES, </journal> <volume> Vol. 23, No. </volume> <pages> 7. </pages>
Reference: [Lom77] <author> D. Lomet. </author> <title> Data flow analysis in the presence of procedure calls. </title> <journal> Journal of Research and Development, </journal> <volume> 21(6) </volume> <pages> 559-571, </pages> <month> November </month> <year> 1977. </year>
Reference-contexts: While our approach extends naturally to account for aliasing induced by pointers as well as parameter bindings, they suggest factoring the aliases into data flow problem solution separately, as in previous work by Lomet <ref> [Lom77] </ref>. Lomet's approach suggested that an approximation of program semantics could be obtained by analyzing the procedure under different aliasing conditions and then combining them at some loss of precision. This is conceptually similar to our approach, except we are dealing with pointer induced aliasing.
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Pointer Induced Aliasing and Type Determination We have shown that in C ++ , the problems of aliasing and type determination are practically inseparable in the presence of general purpose pointers. We use the conditional approach proposed by Landi and Ryder <ref> [LR91] </ref> to solve a combined problem. Since C ++ is closely related to C (but distinguishes itself from the latter with the significant addition of object-oriented paradigm and polymorphism), our work closely relates to Landi's pointer induced aliasing work for C [Lan92a]. <p> The technique of conditional analysis was introduced by Landi to solve the problem of aliasing in the presence of pointers <ref> [LR91] </ref>; we have extended it to solve other problems which, like aliasing, are crucial to compile time analysis. We have included a comprehensive treatment of two representative problems: def-use associations for C and type determination for C ++ .
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interproce-dural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference: [LRZ93] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference: [LRZA96] <author> W. Landi, B. G. Ryder, S. Zhang, and R. Altucher. </author> <title> Interprocedural modification side effect analysis for C systems. </title> <institution> Laboratory for computer science research technical report, Rutgers University, </institution> <year> 1996. </year> <note> In preparation. 178 </note>
Reference-contexts: Also, our algorithms use an unoptimized version of aliasing. An independent effort in optimizing this version while solving the modification side effects (MOD) problem for C has been quite successful <ref> [LRZA96] </ref>. We plan to incorporate similar optimizations to improve our analysis performance as well. 3.
Reference: [LT90] <author> S. S. Liu and A. B. Taha. </author> <title> Interprocedural definition-use dependency analysis for recursive procedures. </title> <institution> Software Engineering Research Center SERC-TR-42-F, University of Florida, Gainesville, </institution> <year> 1990. </year>
Reference-contexts: This is conceptually similar to our approach, except we are dealing with pointer induced aliasing. By solving a conditional version of the data flow problem, we avoid some of the loss of precision that Lomet incurred. The algorithm by Liu and Taha <ref> [LT90] </ref> has similar shortcomings in the presence of aliasing.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference: [MMR95] <author> Stephen P. Masticola, Thomas J. Marlowe, and Barbara G. Ryder. </author> <title> Lattice frameworks for multi-source and bidirectional data flow analysis problems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(5) </volume> <pages> 777-803, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: However, they have not led to corresponding practical implementations. Others have proposed data flow frameworks for interprocedural problems with precise, polynomial-time solution procedures [KRS94, Lan92a, RHS95]. We present an algorithm for approximation formulation of interprocedural type determination using a monotone data flow framework based on a finite multisource lattice <ref> [MMR95] </ref>. We show that the algorithm calculates an approximate and safe solution for the precise type determination problem, and the solution is identical to that computed by the algorithm presented in Section 5.3. Further, we outline a similar framework for the combined problem of type determination and aliasing.
Reference: [MR90] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks: a unified model. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference: [Mye81] <author> E. M. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference: [OO84] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [Ost90] <author> Thomas J. </author> <title> Ostrand. Data-flow testing with pointers and function calls. </title> <booktitle> In Proceedings of the Pacific Northwest Software Quality Conference, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: to scale up the analysis to handle bigger programs involve lifting these restrictions, and are described in Chapter 8. 110 Chapter 7 Applications and Related Work 7.1 Def-Use Associations for C Def-use associations are necessary for a range of software development environment tools, and are crucial to data-flow-based testing systems <ref> [FW88, HS89, HS90, OW91, Ost90, RW85] </ref>. Previous efforts to calculate interprocedural def-use associations [HS90, HS91], focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage.
Reference: [OW91] <author> T. J. Ostrand and E. Weyuker. </author> <title> Data flow based test adequecy analysis for languages with pointers. </title> <booktitle> In Proceedings of the 1991 Symposium on Software Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: to scale up the analysis to handle bigger programs involve lifting these restrictions, and are described in Chapter 8. 110 Chapter 7 Applications and Related Work 7.1 Def-Use Associations for C Def-use associations are necessary for a range of software development environment tools, and are crucial to data-flow-based testing systems <ref> [FW88, HS89, HS90, OW91, Ost90, RW85] </ref>. Previous efforts to calculate interprocedural def-use associations [HS90, HS91], focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage.
Reference: [Par92] <author> R. Parameswaran. </author> <title> Interprocedural alias and type analysis for pointers. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Wiscon-sin - Madison, </institution> <year> 1992. </year>
Reference-contexts: The suggested algorithms for these problems [CK89, Wei80] are grossly approximate and unsuitable in a C ++ context. Parameswaran has developed an algorithm which performs alias analysis without the knowledge of the receiver type at an invocation site and thus assuming that all corresponding virtual functions are invocable <ref> [Par92] </ref>. He then uses the precalculated alias information for type determination. We show that aliasing and type determination are inseparable in the general case, therefore a factored approach is not desirable.
Reference: [PC94] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object oriented languages. </title> <booktitle> In Proceeding of Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '94), </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Since each use of an object is reached by at most one definition, their framework can track the program points where a particular receiver may have a Nil value. Plevyak and Chien describe an incremental constraint based type inference technique for Concurrent Aggregates, a concurrent object-oriented language <ref> [PC94] </ref>. While constraint based inferencing is most suitable for purely dynamic, untyped languages like SELF and ours for typed languages like C ++ , the two approaches may supplement each other for languages which combine these separate domains.
Reference: [PLR94] <author> H. D. Pande, W. Landi, and B. G. Ryder. </author> <title> Interprocedural def-use associations for C systems with single level pointers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 385-403, </pages> <month> May </month> <year> 1994. </year>
Reference: [PR94a] <author> H. Pande and B. G. Ryder. </author> <booktitle> Static type determination for C ++ . In Proceedings of the Sixth USENIX C ++ Technical Conference, </booktitle> <pages> pages 85-97, </pages> <month> April </month> <year> 1994. </year>
Reference: [PR94b] <author> H. D. Pande and B. G. Ryder. </author> <title> Static type determination and aliasing for C ++ . Laboratory for Computer Science Research Technical Report LCSR-TR-236, </title> <institution> Rutgers University, </institution> <month> December </month> <year> 1994. </year> <month> 179 </month>
Reference: [PRL91] <author> H. Pande, B. G. Ryder, and W. Landi. </author> <title> Interprocedural def-use associations for C programs. </title> <booktitle> In Proceedings of the ACM SIGSOFT Conference on Testing, Analysis and Verification, </booktitle> <pages> pages 139-153, </pages> <month> October </month> <year> 1991. </year>
Reference: [PS91] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '91), </booktitle> <pages> pages 146-161, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Although the algorithm failed to type-check common programs, it served as a starting point for other efforts to infer types in object-oriented languages. The algorithm by Palsberg and Schwartzbach infers types of expressions in an object oriented language with inheritance, assignments and late bindings <ref> [PS91] </ref>. They set up type constraints and compute the least solution in worst case exponential time. The algorithm does not perform control flow analysis nor does it track the values of objects.
Reference: [PWC91] <author> Michael Platoff, Michael Wagner, and Joseph Camaratta. </author> <title> An integrated program representation and toolkit for the maintenance of C programs. </title> <booktitle> In Proceedings of the Conference on Software Maintenance. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1991. </year>
Reference: [Ram94] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1994. </year>
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Previous researches have proposed general theoretical frameworks to solve interprocedural data flow problems precisely [CC77, SP81]. However, they have not led to corresponding practical implementations. Others have proposed data flow frameworks for interprocedural problems with precise, polynomial-time solution procedures <ref> [KRS94, Lan92a, RHS95] </ref>. We present an algorithm for approximation formulation of interprocedural type determination using a monotone data flow framework based on a finite multisource lattice [MMR95].
Reference: [RLP90] <author> B. G. Ryder, W. Landi, and H. Pande. </author> <title> Profiling an incremental data flow analysis algorithm. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(2) </volume> <pages> 129-140, </pages> <month> February </month> <year> 1990. </year>
Reference: [RM88] <author> C. Ruggieri and T. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> January </month> <year> 1988. </year>
Reference: [RW85] <author> S. Rapps and E. Weyuker. </author> <title> Selecting software test data using data flow information. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):367-375, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: to scale up the analysis to handle bigger programs involve lifting these restrictions, and are described in Chapter 8. 110 Chapter 7 Applications and Related Work 7.1 Def-Use Associations for C Def-use associations are necessary for a range of software development environment tools, and are crucial to data-flow-based testing systems <ref> [FW88, HS89, HS90, OW91, Ost90, RW85] </ref>. Previous efforts to calculate interprocedural def-use associations [HS90, HS91], focused on Pascal like programs; their implementation did not account for pointer aliasing. The accuracy of the def-use information determines the efficiency of the test case coverage.
Reference: [Ryd79] <author> B. G. Ryder. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(3):216-225, </volume> <month> May </month> <year> 1979. </year>
Reference: [Shi90] <author> O. Shivers. </author> <title> Data-flow analysis and type recovery in scheme. </title> <booktitle> In Topics in Advanced Language Implementation. </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Flow Analysis of Higher Order Languages Techniques for flow analysis of higher order languages like Scheme <ref> [Har89, JM79, Shi90] </ref> may be adapted for analyzing function pointers (and hence C ++ ); however, they do not have acceptable complexity for reasonable precision on real programs. The emphasis seems to be on theoretical issues such as being able to solve the problem.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: Previous researches have proposed general theoretical frameworks to solve interprocedural data flow problems precisely <ref> [CC77, SP81] </ref>. However, they have not led to corresponding practical implementations. Others have proposed data flow frameworks for interprocedural problems with precise, polynomial-time solution procedures [KRS94, Lan92a, RHS95].
Reference: [SRW96] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of the Twenty-third Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: We plan to enhance our algorithms to safely handle the constructs which can create circular data structures. It involves additional case analysis during the in-traprocedural propagation phase of the algorithms. Recent work on shape analysis for pointer data structures <ref> [GH96, SRW96] </ref> is relevant in this respect. 6. Our analysis works on the intermediate representation for the whole source program and keeps the entire analysis database in main memory, an approach clearly not suitable for analyzing large programs. We need to re-engineer the algorithms towards modular analysis.
Reference: [SS92] <author> M. Suedholt and C. Steigner. </author> <title> On interprocedural data flow analysis for object oriented languages. </title> <booktitle> In Proceedings of the International Conference on Compiler Construction, </booktitle> <address> Germany, </address> <year> 1992. </year> <month> 180 </month>
Reference-contexts: We show that aliasing and type determination are inseparable in the general case, therefore a factored approach is not desirable. Suedholt and Steigner use a concept of representant virtual function to keep information about all the virtual functions with the same name <ref> [SS92] </ref>. This approach leads to the loss of context which distinguishes one virtual function from others. Vitek et al. present an 115 algorithm which discovers the potential classes of objects for a simple object oriented language as well as a safe approximation to their lifetimes [VHU92].
Reference: [Suz81] <author> N. Suzuki. </author> <title> Inferring types in smalltalk. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 187-199, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Since hierarchy analysis alone is not shown to be effective in obtaining virtual function resolution, it is not clear to what extent the approach would be useful in practice. Constraint based Analysis Suzuki attempted eliminating dynamically dispatched calls in Smalltalk programs by using unification based type inference <ref> [Suz81] </ref>. He performed iterative analysis to determine the receiver type as a set of classes. Although the algorithm failed to type-check common programs, it served as a starting point for other efforts to infer types in object-oriented languages.
Reference: [Ven91] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [VHU92] <author> J. Vitek, R. N. Harspool, and J. S. Uhl. </author> <title> Compile-time analysis of object oriented programs. </title> <booktitle> In Proceedings of the International Conference on Compiler Construction, </booktitle> <address> Germany, </address> <year> 1992. </year>
Reference-contexts: This approach leads to the loss of context which distinguishes one virtual function from others. Vitek et al. present an 115 algorithm which discovers the potential classes of objects for a simple object oriented language as well as a safe approximation to their lifetimes <ref> [VHU92] </ref>. Pointer Induced Aliasing and Type Determination We have shown that in C ++ , the problems of aliasing and type determination are practically inseparable in the presence of general purpose pointers. We use the conditional approach proposed by Landi and Ryder [LR91] to solve a combined problem.
Reference: [Wei80] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: The latter can use the constraint based approach to arrive at an initial approximation of types for untyped variables and proceed with flow analysis. Function Pointer Analysis Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCCH94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous. <p> Flow Analysis of Object-Oriented Languages The algorithm by Larcheveque factors out from type determination the side effects of function invocations and aliasing due to parameter bindings as well as pointers [Lar92]. The suggested algorithms for these problems <ref> [CK89, Wei80] </ref> are grossly approximate and unsuitable in a C ++ context. Parameswaran has developed an algorithm which performs alias analysis without the knowledge of the receiver type at an invocation site and thus assuming that all corresponding virtual functions are invocable [Par92].
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: If we obtain a safe approximation to the def-use associations, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [AH90, Gor93, HRB90, KL90, OO84, Ven91, Wei84] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [WL95] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year> <note> Also available as SIGPLAN Notices, 30(6). </note>
Reference-contexts: The latter can use the constraint based approach to arrive at an initial approximation of types for untyped variables and proceed with flow analysis. Function Pointer Analysis Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCCH94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous. <p> Since C ++ is closely related to C (but distinguishes itself from the latter with the significant addition of object-oriented paradigm and polymorphism), our work closely relates to Landi's pointer induced aliasing work for C [Lan92a]. Other techniques for flow-sensitive pointer aliasing include <ref> [CBC93, Deu94, EGH94, WL95] </ref>. They are disparate in representation, complexity and precision. Nevertheless, we believe it is possible to define the interaction between aliasing and type determination and solve the combined problem using these techniques.
Reference: [YHR90] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> A program integration algorithm that accomodates semantics preserving transformations. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 133-143, </pages> <month> December </month> <year> 1990. </year> <note> Also available as SIGSOFT Notes, vol 15, no 6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: The aim of slicing is to concentrate the programmer's attention on those parts of the program significant to the computation under current investigation; the more imprecise the def-use information, the less effectively the slicing method can prune away unrelated computations. Techniques for merging independently altered versions of programs <ref> [HPR89, YHR90] </ref> are of great interest to the programming-in-the-large community.
Reference: [YHR92] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> A program integration algorithm that accomodates semantics preserving transformations. </title> <journal> ACM Transactions on Software Engineering Methodology, </journal> <volume> 1(3) </volume> <pages> 310-354, </pages> <month> July </month> <year> 1992. </year>
Reference: [ZR94] <author> S. Zhang and B.G. Ryder. </author> <title> Complexity of single level function pointer aliasing analysis. </title> <institution> Laboratory for Computer Science Research Technical Report LCSR-TR-233, Rutgers University, </institution> <month> October </month> <year> 1994. </year> <month> 181 </month>
References-found: 96

