URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/ictl94.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  kifer@cs.sunysb.edu  
Title: Applications of Transaction Logic to Knowledge Representation  
Author: Anthony J. Bonner Michael Kifer 
Note: Work supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada and by a Connaught Grant from the University of Toronto. Supported in part by NSF grant CCR-9102159. Part of this work is done during sabbatical year at the  is gratefully acknowledged.  
Address: Toronto, Ontario M5S 1A4, Canada  NY 11790, U.S.A.  
Affiliation: University of Toronto Department of Computer Science  SUNY at Stony Brook Department of Computer Science Stony Brook,  University of Toronto. Support of Computer Systems Research Institute of University of Toronto  
Abstract: We present applications of the recently proposed Transaction Logic|an extension of classical logic that accounts in a clean and declarative fashion for the phenomenon of state changes in knowledge bases, including logic programs and databases. Transaction Logic has a natural model theory and a sound-and- complete proof theory, but unlike many other logics, it allows users to program transactions. Its semantics also leads naturally to features whose amalgamation in a single logic has proved elusive in the past. These features include both hypothetical and committed updates, static and dynamic constraints, nondeterministic actions, nested transactions, bulk updates, view updates, active databases, subjunctive queries, and more. Finally, Transaction Logic holds promise as a logical model of hitherto non-logical phenomena, including procedural knowledge in AI, and the behavioral aspect of object-oriented databases, especially methods with side effects. This paper outlines the model theory of Transaction Logic, and then focuses on some of its applications to AI, including action definition and execution, planning, and dynamic constraints. This paper appears in Proceedings of the International Conference on Temporal Logic (ICTL), pages 67-81. Springer Verlag, Lecture Notes in Artificial Intelli - gence, volume 827. Conference held in Bonn, Germany, July 11-14 1994. This paper is available at the following URL: ftp://db.toronto.edu/pub/bonner/papers/transaction.logic/ictl94.ps.gz 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and declarative database update lan-guages. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 240-250, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [17, 18, 9, 1] </ref>. The main problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails an overhaul of the entire proof theory.
Reference: [2] <author> J.F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Such constraints are particularly well suited to areas such as planning and design, where it is common to place constraints on the way things are done. This section illustrates a variety of dynamic constraints expressible in T R. These include temporal constraints in the style of James Allen <ref> [2] </ref>, such as, "immediately after," "some time after," "before," etc. There are several important problems related to constraints. One such problem is constraint satisfaction. That is, given a transaction and a constraint, we want to execute the transaction in such a way that it satisfies the constraint.
Reference: [3] <editor> F. Bancilhon. A logic-programming/Object-oriented cocktail. </editor> <booktitle> SIGMOD Record, </booktitle> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: However, despite a plethora of logics, researchers continue to complain that there is no clear declarative semantics for updates, whether in databases or in logic programming <ref> [4, 3, 20] </ref>. In fact|in stark contrast to classical logic|no logic of change has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing logics of change.
Reference: [4] <author> C. Beeri. </author> <title> New data models and languages|The challenge. </title> <booktitle> In ACM SIGACTSIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 1-15, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: However, despite a plethora of logics, researchers continue to complain that there is no clear declarative semantics for updates, whether in databases or in logic programming <ref> [4, 3, 20] </ref>. In fact|in stark contrast to classical logic|no logic of change has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing logics of change.
Reference: [5] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-270, </type> <institution> University of Toronto, </institution> <month> April </month> <year> 1992. </year> <note> Revised: February 1994. ftp://csri-technicalreports/270/report.ps. </note>
Reference-contexts: This is possible because, like classical logic, T R has a "Horn" version that has both a procedural and a declarative semantics, as well as an efficient SLD-style proof procedure. Since the formal aspects of T R can be found in <ref> [6, 5] </ref>, this paper focuses on applications of T R to AI. Numerous other applications can be found in [5, 8] T R was designed with several applications in mind, especially in databases, logic programming, and AI. <p> Since the formal aspects of T R can be found in [6, 5], this paper focuses on applications of T R to AI. Numerous other applications can be found in <ref> [5, 8] </ref> T R was designed with several applications in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. Individual applications can be carved out of different fragments of the logic. <p> It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. Individual applications can be carved out of different fragments of the logic. These applications, both practical and theoretical, are discussed in great detail in <ref> [5] </ref>. For instance, in logic programming, T R leads to a clean, logical treatment of the assert and retract operators in Prolog, which effectively extends the theory of logic programming to include updates as well as queries. <p> In fact|in stark contrast to classical logic|no logic of change has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing logics of change. These reasons are discussed at length in <ref> [5] </ref>, and we discuss some of them briefly here. First, most logics of time or action are hypothetical. For instance, some systems can infer that if action A precedes B, and B precedes C, then A must precede C. <p> In this way, one can account for the behavior of object-oriented databases|something that most formalisms do not do. By integrating T R with F-logic [15], the structural aspect of object-oriented systems can be accounted for as well. In <ref> [5] </ref>, we provide a detailed comparison of T R with many other works. The system that comes closest in spirit to T R is Prolog. <p> It has a natural model theory and a sound-and-complete proof theory. This section gives an overview of the syntax and the model theory. A complete development of T R, including proof theory, can be found in <ref> [5] </ref>. Like classical logic, T R has a "Horn" version that is of particular interest for logic programming and deductive databases. In Horn T R, a transaction is defined by Horn- style rules, where the premise specifies a sequence of queries and updates. <p> T R is, thus, a logical language for programming database transactions, just as classical logic is a logical language for programming queries. Furthermore, T R has an inference system and two natural proof procedures: an efficient SLD-style procedure, and a dual, bottom-up procedure <ref> [6, 5] </ref>. These proof procedures both answer queries, execute transactions, and update the database. Because of its importance, much of this paper focuses on applications of Horn T R. <p> This is a serious drawback since there appears to be no small, single set of elementary transitions that is best for all purposes <ref> [5] </ref>. Indeed, in [5, 8], we introduce two new kinds of elementary update. Thus, rather than committing T R to a fixed set of elementary transitions, we have chosen to treat the elementary transitions as a parameter of T R. To achieve this, elementary transitions are defined by logical axioms. <p> This is a serious drawback since there appears to be no small, single set of elementary transitions that is best for all purposes [5]. Indeed, in <ref> [5, 8] </ref>, we introduce two new kinds of elementary update. Thus, rather than committing T R to a fixed set of elementary transitions, we have chosen to treat the elementary transitions as a parameter of T R. To achieve this, elementary transitions are defined by logical axioms. <p> In practice, these formulas would not be materialized all at once, but would be generated on demand by an algorithm. The reader is referred to <ref> [5] </ref> for a more detailed discussion of transition bases. As seen from the syntax, there is no strict distinction in T R between predicates that query the database and predicates that update it. <p> Planning of robot actions is discussed in Section 3.1, and in more detail in <ref> [5] </ref>. The example shows how updates are combined with queries to define complex transactions. In the example, the body of each rule is a sequence of atomic formulas, some of which are queries and some of which are updates. We say that such rules are serial-Horn, or simply Horn. <p> Example 2.1 easily extends to recursively defined actions. For instance, stack (N; X) can be defined as an action that recursively stacks N blocks on top of block X <ref> [5] </ref>. Finally, observe that the rules in Example 2.1 can easily be rewritten in Prolog form, by replacing "" with "," and by replacing the elementary state transitions with assert and retract. <p> Thus, if blkA was previously on top of blkB, then on (blkA; blkB) would remain deleted and isclear (blkB) would stay in the database. 2.3 Model Theory This section gives an overview of the model theory of T R. The reader is referred to <ref> [5, 7, 6] </ref> for a full treatment, including the proof theory. Just as the syntax of T R is based on two basic ideas|serial conjunction and elementary transitions|semantics is also based on a few fundamental principles, described below. <p> In this way, one model-theoretic device, paths, accounts for databases, updates, queries and more general transactions. This focus on paths is related to the version of Process Logic in [13], but the two logics are fundamentally different <ref> [5] </ref>. Because of the emphasis on paths, we refer to semantic structures in T R as path structures. Truth on Paths: In T R, truth is defined on paths, where a path is a finite sequence of states. <p> All logical connectives are interpreted on paths, i :e:; in terms of action. For instance, _ is true on a path iff is true or is true. This gives rise to non-deterministic actions, since intuitively, _ means, "Do or do ." This idea is illustrated in <ref> [5, 8] </ref>. Likewise, ^ is true on a path iff and are both true. This provides a way of constraining non-deterministic actions. For instance, ^: intuitively means, "Do but without doing in the process." Section 3.2 illustrates this idea. <p> The rest of this section presents the Herbrand semantics of T R. A detailed discussion and development of this semantics is given in [7]. A general, non-Herbrand semantics and a sound-and-complete proof theory are given in <ref> [5, 6] </ref>. For convenience, we define a split of a path = hs 1 ; :::; s n i to be any pair of subpaths, 1 = hs 1 ; :::; s i i and 2 = hs i ; :::; s n i. <p> This section describes some of these applications. Additional applications and further details of the applications presented herein can be found in <ref> [5] </ref> and [8]. In addition, T R can be easily extended with a modal necessity operator, 2, which captures a whole new range of applications. These applications include hypothetical reasoning, subjunctive queries, counterfactuals, imperative programming constructs, active databases, software verification, and more [5, 8]. <p> In addition, T R can be easily extended with a modal necessity operator, 2, which captures a whole new range of applications. These applications include hypothetical reasoning, subjunctive queries, counterfactuals, imperative programming constructs, active databases, software verification, and more <ref> [5, 8] </ref>. T R thus provides a wide range of features whose amalgamation in a single declarative formalism has proved elusive in the past. <p> T R captures this attractive property within a formal logic. The frame problem in the context of T R is extensively discussed in <ref> [5] </ref>. In [5], we consider three planning regimes. In the first regime, which we call naive planning, the inference system searches blindly for any sequence of actions that achieves the goal. Naive planning corresponds roughly to planning using a forward production system as described in [19]. <p> T R captures this attractive property within a formal logic. The frame problem in the context of T R is extensively discussed in <ref> [5] </ref>. In [5], we consider three planning regimes. In the first regime, which we call naive planning, the inference system searches blindly for any sequence of actions that achieves the goal. Naive planning corresponds roughly to planning using a forward production system as described in [19]. <p> This incompleteness is responsible for certain failures of STRIPS, e.g., its inability to exchange the contents of two registers [19]. This problem was fixed in RSTRIPS, a successor of STRIPS, by using a better search strategy. The point, however, is that, since T R has a complete proof theory <ref> [5] </ref>, it provides a means of programming powerful planning systems that are free from the problems created by the use of rigid, ad hoc search algorithms. Other problems with STRIPS-like planning (which extend to many other planning systems) are pointed out and solved in [5]. <p> R has a complete proof theory <ref> [5] </ref>, it provides a means of programming powerful planning systems that are free from the problems created by the use of rigid, ad hoc search algorithms. Other problems with STRIPS-like planning (which extend to many other planning systems) are pointed out and solved in [5]. All examples in this paper are based on the insertion and deletion of tuples from a database. They thus bear a conceptual resemblance to STRIPS-actions. Several differences are worth noting: * Unlike STRIPS-actions, T R-rules are formulas in a rigorous logical formalism. <p> fact, even more general actions are possible in T R, since in addition to sequential ordering, formulas may be combined via classical conjunction, disjunction and negation. 10 * Finally, lest this is forgotten, T R is a general-purpose logic for which STRIPS, planning, and other issues considered here and in <ref> [5] </ref> are only some of the many applications. Naive Planning. Naive planning is based on primitive planning actions (or operators). These primitive actions differ from elementary updates in that they correspond to real-world activities, such as robot actions. <p> Together with recursion, non-determinism allows us to define a plan to be any sequence of primitive actions. The approach to planning which we have just illustrated is conceptually simple, but is too unfocussed in its blind search for plans. The inference systems of T R <ref> [5, 6] </ref>, for instance, will simply string actions together at random until a sequence is found that achieves the goal. This behavior is often called forward (or bottom-up) planning. If the plan does not achieve the goal, then the inference system simply backtracks and generates another plan. <p> This process continues until a plan that achieves the goal is finally found. It is due to this unfocussed behavior that we call the above planning strategy "naive." In contrast, script-based planning strategies described in <ref> [5] </ref> are highly focussed, as they augment action definitions with "scripts" or "skeletal plans" that are known to be useful in achieving certain kinds of goals. In T R, one can easily represent the planning strategies of STRIPS and NOAH via skeletal plans consisting of a small number of rules. <p> In T R, one can easily represent the planning strategies of STRIPS and NOAH via skeletal plans consisting of a small number of rules. The actual plan is then obtained via the general proof procedure of T R, which executes these script. (See <ref> [5] </ref> for details.) 3.2 Constraints on Execution of Complex Actions Because transactions are defined on paths, it is possible to express a large variety of constraints on the way they execute. <p> through rooms C 1 and C 2 , in any order: 13 goto (roomA) ^ 2 4 [go thru (roomB 1 ) ^ go thru (roomB 2 )] [go thru (roomC 1 ) ^ go thru (roomC 2 )] 3 5 Many more examples of constraints can be found in <ref> [5] </ref>. Acknowledgments: We wish to thank Mariano Consens, Alberto Mendelzon, and Ray Reiter for many insightful discussions. Comments by Greg Meredith, Gosta Grahne, Peter Revesz, Fangzhen Lin, Javier Pinto, Dimitris Lagouvardos, Jan Van den Bussche, and Roel Wieringa are also gratefully acknowledged.
Reference: [6] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming (ICLP), </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This is possible because, like classical logic, T R has a "Horn" version that has both a procedural and a declarative semantics, as well as an efficient SLD-style proof procedure. Since the formal aspects of T R can be found in <ref> [6, 5] </ref>, this paper focuses on applications of T R to AI. Numerous other applications can be found in [5, 8] T R was designed with several applications in mind, especially in databases, logic programming, and AI. <p> T R is, thus, a logical language for programming database transactions, just as classical logic is a logical language for programming queries. Furthermore, T R has an inference system and two natural proof procedures: an efficient SLD-style procedure, and a dual, bottom-up procedure <ref> [6, 5] </ref>. These proof procedures both answer queries, execute transactions, and update the database. Because of its importance, much of this paper focuses on applications of Horn T R. <p> Thus, if blkA was previously on top of blkB, then on (blkA; blkB) would remain deleted and isclear (blkB) would stay in the database. 2.3 Model Theory This section gives an overview of the model theory of T R. The reader is referred to <ref> [5, 7, 6] </ref> for a full treatment, including the proof theory. Just as the syntax of T R is based on two basic ideas|serial conjunction and elementary transitions|semantics is also based on a few fundamental principles, described below. <p> The rest of this section presents the Herbrand semantics of T R. A detailed discussion and development of this semantics is given in [7]. A general, non-Herbrand semantics and a sound-and-complete proof theory are given in <ref> [5, 6] </ref>. For convenience, we define a split of a path = hs 1 ; :::; s n i to be any pair of subpaths, 1 = hs 1 ; :::; s i i and 2 = hs i ; :::; s n i. <p> Together with recursion, non-determinism allows us to define a plan to be any sequence of primitive actions. The approach to planning which we have just illustrated is conceptually simple, but is too unfocussed in its blind search for plans. The inference systems of T R <ref> [5, 6] </ref>, for instance, will simply string actions together at random until a sequence is found that achieves the goal. This behavior is often called forward (or bottom-up) planning. If the plan does not achieve the goal, then the inference system simply backtracks and generates another plan.
Reference: [7] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Thus, if blkA was previously on top of blkB, then on (blkA; blkB) would remain deleted and isclear (blkB) would stay in the database. 2.3 Model Theory This section gives an overview of the model theory of T R. The reader is referred to <ref> [5, 7, 6] </ref> for a full treatment, including the proof theory. Just as the syntax of T R is based on two basic ideas|serial conjunction and elementary transitions|semantics is also based on a few fundamental principles, described below. <p> More generally, an elementary update may be non-deterministic, so it is not just a mapping, but a binary relation on databases. The rest of this section presents the Herbrand semantics of T R. A detailed discussion and development of this semantics is given in <ref> [7] </ref>. A general, non-Herbrand semantics and a sound-and-complete proof theory are given in [5, 6].
Reference: [8] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages (DBPL), Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: Since the formal aspects of T R can be found in [6, 5], this paper focuses on applications of T R to AI. Numerous other applications can be found in <ref> [5, 8] </ref> T R was designed with several applications in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. Individual applications can be carved out of different fragments of the logic. <p> This is a serious drawback since there appears to be no small, single set of elementary transitions that is best for all purposes [5]. Indeed, in <ref> [5, 8] </ref>, we introduce two new kinds of elementary update. Thus, rather than committing T R to a fixed set of elementary transitions, we have chosen to treat the elementary transitions as a parameter of T R. To achieve this, elementary transitions are defined by logical axioms. <p> All logical connectives are interpreted on paths, i :e:; in terms of action. For instance, _ is true on a path iff is true or is true. This gives rise to non-deterministic actions, since intuitively, _ means, "Do or do ." This idea is illustrated in <ref> [5, 8] </ref>. Likewise, ^ is true on a path iff and are both true. This provides a way of constraining non-deterministic actions. For instance, ^: intuitively means, "Do but without doing in the process." Section 3.2 illustrates this idea. <p> This section describes some of these applications. Additional applications and further details of the applications presented herein can be found in [5] and <ref> [8] </ref>. In addition, T R can be easily extended with a modal necessity operator, 2, which captures a whole new range of applications. These applications include hypothetical reasoning, subjunctive queries, counterfactuals, imperative programming constructs, active databases, software verification, and more [5, 8]. <p> In addition, T R can be easily extended with a modal necessity operator, 2, which captures a whole new range of applications. These applications include hypothetical reasoning, subjunctive queries, counterfactuals, imperative programming constructs, active databases, software verification, and more <ref> [5, 8] </ref>. T R thus provides a wide range of features whose amalgamation in a single declarative formalism has proved elusive in the past.
Reference: [9] <author> W. Chen. </author> <title> Declarative specification and evaluation of database updates. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases (DOOD), volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [17, 18, 9, 1] </ref>. The main problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails an overhaul of the entire proof theory.
Reference: [10] <editor> P.R. Cohen and E.A. Feigenbaum, editors. </editor> <booktitle> The Handbook of Artificial Intelligence, volume III. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1986. </year> <month> 14 </month>
Reference-contexts: For example, a script for making coffee might be as follows: grind coffee, boil water, put coffee in filter, pour water into filter <ref> [10, Article XV.D1] </ref>. In T R, this script could be represented by a rule like the following: makeCoffee grindCoffee boilWater fillFilter pourWater (1) As this example illustrates, scripts and skeletal plans often have the form of a procedure (or recipe).
Reference: [11] <author> R.E. Fikes and N.J. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> <volume> 2 </volume> <pages> 189-208, </pages> <year> 1971. </year>
Reference-contexts: Thus, while F-logic covers the structural aspect of object-oriented databases, its combination with T R would account for the behavioral aspect as well. In AI, T R suggests a logical account of planning. STRIPS-like actions <ref> [11] </ref>, for instance, and many aspects of hierarchical and non-linear planning are easily expressed in T R. In spite of the previous efforts to give these phenomena declarative semantics, until now there has been no unifying logical framework to account for all of them. <p> For this reason, they are often specified in a procedural language. As the rule above illustrates, however, they can also be specified in a logic, T R, that integrates procedural and declarative knowledge in a single framework. The third planning regime is exemplified by the well-known STRIPS system <ref> [11, 16] </ref>, which plans movements for a robot arm. STRIPS is naturally represented in T R by a script consisting of just four deductive rules and rule-schemas. It can be shown that STRIPS's planning strategy is sound, albeit incomplete, in T R's semantics.
Reference: [12] <author> P.E. Friedland. </author> <title> Knowledge-Based Experiment Design in Molecular Genetics. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Stanford University, </institution> <year> 1979. </year> <type> Report Number 79-771. </type>
Reference-contexts: This kind of planning, which is exemplified by systems such as NOAH [21] 9 and MOLGEN <ref> [12, 22] </ref>, is natural for T R, since each script corresponds to a high-- level, non-deterministic action. For example, a script for making coffee might be as follows: grind coffee, boil water, put coffee in filter, pour water into filter [10, Article XV.D1].
Reference: [13] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidability, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: Note that a path of length 1 corresponds to a single database state. In this way, one model-theoretic device, paths, accounts for databases, updates, queries and more general transactions. This focus on paths is related to the version of Process Logic in <ref> [13] </ref>, but the two logics are fundamentally different [5]. Because of the emphasis on paths, we refer to semantic structures in T R as path structures. Truth on Paths: In T R, truth is defined on paths, where a path is a finite sequence of states.
Reference: [14] <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowl-edge base and revising it. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 387-394, </pages> <address> Boston, Mass., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: This uniformity of representation is important 1 For relational databases, the operators + and can be thought of as union and set-difference. However, if D is a general first-order formula, then defining insertion and deletion is more involved <ref> [14] </ref>. for modeling methods in object-oriented databases, where one generally does not dis-tinguish between information-retrieving and state-changing methods. Nevertheless, if desired, T R can make such a distinction by using different sorts of predicates, one for updates and one for queries. <p> For example, what does it mean to insert an atom b into a database that entails :b, especially if :b itself is not explicitly present in the database? There is no simple answer to this question, and many solutions have been proposed (see <ref> [14] </ref> for a comprehensive discussion). For these reasons, we take a general approach to elementary updates. For us, an elementary update is a mapping that takes one database, D 1 , to some other database, D 2 , where a database is any (equivalence class of) first- order formulas.
Reference: [15] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <month> May </month> <year> 1995. </year>
Reference-contexts: In object-oriented databases, T R can be combined with object-oriented logics, such as F-logic <ref> [15] </ref>, to provide a logical account of methods, i.e., procedures hidden inside objects that manipulate these objects' internal states. Thus, while F-logic covers the structural aspect of object-oriented databases, its combination with T R would account for the behavioral aspect as well. <p> T R achieves this by allowing every logical formula to have not only a truth value, but also a "side effect" on the database. In this way, one can account for the behavior of object-oriented databases|something that most formalisms do not do. By integrating T R with F-logic <ref> [15] </ref>, the structural aspect of object-oriented systems can be accounted for as well. In [5], we provide a detailed comparison of T R with many other works. The system that comes closest in spirit to T R is Prolog.
Reference: [16] <author> V. Lifschitz. </author> <title> On the semantics of STRIPS. </title> <booktitle> In Reasoning about Actions and Plans: Proceedings of the 1986 Workshop, </booktitle> <address> Timberline, OR, </address> <year> 1987. </year> <note> Reprinted in Readings in Planning, </note> <editor> J. Allen, J. Hendler, A. Tate (eds.), </editor> <publisher> Morgan-Kaufmann, </publisher> <year> 1990, </year> <pages> 523-530. </pages>
Reference-contexts: For this reason, they are often specified in a procedural language. As the rule above illustrates, however, they can also be specified in a logic, T R, that integrates procedural and declarative knowledge in a single framework. The third planning regime is exemplified by the well-known STRIPS system <ref> [11, 16] </ref>, which plans movements for a robot arm. STRIPS is naturally represented in T R by a script consisting of just four deductive rules and rule-schemas. It can be shown that STRIPS's planning strategy is sound, albeit incomplete, in T R's semantics.
Reference: [17] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [17, 18, 9, 1] </ref>. The main problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails an overhaul of the entire proof theory.
Reference: [18] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [17, 18, 9, 1] </ref>. The main problem with this approach is that adding new kinds of elementary transitions requires redefining the very notion of a model and, hence, entails an overhaul of the entire proof theory.
Reference: [19] <author> N.J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Tioga Publ. Co., </publisher> <address> Paolo Alto, CA, </address> <year> 1980. </year>
Reference-contexts: Thus the formula p.ins (a) p.ins (b) p.ins (c) represents an updating transaction that inserts p (a) into the database, then p (b), and then p (c). 2.2 Example Before presenting the semantics, we illustrate T R through an example of a robot arm moving blocks around a table top <ref> [19] </ref>. Planning of robot actions is discussed in Section 3.1, and in more detail in [5]. The example shows how updates are combined with queries to define complex transactions. <p> In [5], we consider three planning regimes. In the first regime, which we call naive planning, the inference system searches blindly for any sequence of actions that achieves the goal. Naive planning corresponds roughly to planning using a forward production system as described in <ref> [19] </ref>. The naive planner is simple to formulate, but is very inefficient, and so its utility is limited to a mere demonstration that planning is possible in T R. However, due to space limitation, this paper gives a detailed description of naive planning only. <p> It can be shown that STRIPS's planning strategy is sound, albeit incomplete, in T R's semantics. This incompleteness is responsible for certain failures of STRIPS, e.g., its inability to exchange the contents of two registers <ref> [19] </ref>. This problem was fixed in RSTRIPS, a successor of STRIPS, by using a better search strategy.
Reference: [20] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference-contexts: However, despite a plethora of logics, researchers continue to complain that there is no clear declarative semantics for updates, whether in databases or in logic programming <ref> [4, 3, 20] </ref>. In fact|in stark contrast to classical logic|no logic of change has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing logics of change.
Reference: [21] <author> E.D. Sacerdoti. </author> <title> The non-linear nature of plans. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 206-214, </pages> <year> 1975. </year> <note> Also appears in Readings in Planning, pp. </note> <editor> 162-170. </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: In the second regime, planning is described in terms of a hierarchy of "scripts" or "skeletal plans." Scripts suggest ways of achieving goals, and often they summarize known methods in a particular problem domain. This kind of planning, which is exemplified by systems such as NOAH <ref> [21] </ref> 9 and MOLGEN [12, 22], is natural for T R, since each script corresponds to a high-- level, non-deterministic action. For example, a script for making coffee might be as follows: grind coffee, boil water, put coffee in filter, pour water into filter [10, Article XV.D1].
Reference: [22] <author> M.J. Stefik. </author> <title> Planning with Constraints. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Stanford University, </institution> <year> 1980. </year> <type> Report Number 80-784. 15 </type>
Reference-contexts: This kind of planning, which is exemplified by systems such as NOAH [21] 9 and MOLGEN <ref> [12, 22] </ref>, is natural for T R, since each script corresponds to a high-- level, non-deterministic action. For example, a script for making coffee might be as follows: grind coffee, boil water, put coffee in filter, pour water into filter [10, Article XV.D1].
References-found: 22

