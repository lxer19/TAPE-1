URL: http://www-acaps.cs.mcgill.ca:80/info/McCAT/public/points-to.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/alias-papers.html
Root-URL: 
Email: femami,ghiya,hendreng@cs.mcgill.ca  
Title: Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers  
Author: Maryam Emami Rakesh Ghiya Laurie J. Hendren 
Address: Montreal, Quebec Canada H3A 2A7  
Affiliation: School of Computer Science McGill University,  
Abstract: This paper reports on the design, implementation, and empirical results of a new method for dealing with the aliasing problem in C. The method is based on approximating the points-to relationships between accessible stack locations, and can be used to generate alias pairs, or used directly for other analyses and transformations. Our method provides context-sensitive interproce-dural information based on analysis over invocation graphs that capture all calling contexts including recursive and mutually-recursive calling contexts. Furthermore, the method allows the smooth integration for handling general function pointers in C. We illustrate the effectiveness of the method with empirical results from an implementation in the Mc-CAT optimizing/parallelizing C compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. P. Banning. </author> <title> An efficient way to find the side ef fects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: 1 Introduction and Motivation Alias and dependence analysis are fundamental components of optimizing and parallelizing compilers. Although traditionally studied in the context of Fortran or block-structured languages <ref> [1, 2, 8, 9] </ref>, there has been increasing interest in providing accurate alias and side-effect analysis for C programs [7, 31].
Reference: [2] <author> J. M. Barth. </author> <title> An interprocedural data flow analysis algorithm. </title> <booktitle> In Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 119-131, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: 1 Introduction and Motivation Alias and dependence analysis are fundamental components of optimizing and parallelizing compilers. Although traditionally studied in the context of Fortran or block-structured languages <ref> [1, 2, 8, 9] </ref>, there has been increasing interest in providing accurate alias and side-effect analysis for C programs [7, 31].
Reference: [3] <author> D. Callahan, A. Carle, M. W. Hall, and K. Kennedy. </author> <title> Constructing the procedure call multigraph. </title> <journal> IEEE Transactions on Software Engineering 16,4, </journal> <pages> pages 483-487, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: To date, our experiments show that this is not a problem, and that it is reasonable to decouple the stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a program in the presence of procedure variables has been previously studied <ref> [3, 17, 29, 37, 42, 44] </ref>. However, the above techniques cannot handle function pointers, because in C they are considered no different from data pointers. One can have function pointers of multiple level, as fields of structures, and as arrays.
Reference: [4] <author> C. Chambers and D. Ungar. </author> <title> Customization: Opti mizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the SIGPLAN '89 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow. Type analysis techniques have been developed for C++ [36] and SELF <ref> [4, 5] </ref>. 8 Conclusions and Further Work In this paper we have presented a new method for computing the points-to information for stack-allocated data structures. This method uses the concept of abstract stack locations to capture all possible and definite relationships between accessible stack locations.
Reference: [5] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting: Optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of the SIGPLAN '90 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow. Type analysis techniques have been developed for C++ [36] and SELF <ref> [4, 5] </ref>. 8 Conclusions and Further Work In this paper we have presented a new method for computing the points-to information for stack-allocated data structures. This method uses the concept of abstract stack locations to capture all possible and definite relationships between accessible stack locations.
Reference: [6] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIG-PLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 25, No 6. </volume>
Reference-contexts: All heap-directed pointers point to this location. We have designed a separate family of abstractions to capture meaningful relationships between these heap-directed pointers [16], based on the path-matrix model proposed in [23]. Both the original path matrix analysis [23] and the heap-based method proposed by Chase et al. <ref> [6] </ref> also assume that pointer fields in heap nodes only point to heap nodes, and do not point to variables (which are locations on stack). It is important to note that our points-to method provides a safe approximation even in the presence of pointers from the heap to the stack.
Reference: [7] <author> J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: 1 Introduction and Motivation Alias and dependence analysis are fundamental components of optimizing and parallelizing compilers. Although traditionally studied in the context of Fortran or block-structured languages [1, 2, 8, 9], there has been increasing interest in providing accurate alias and side-effect analysis for C programs <ref> [7, 31] </ref>. <p> One traditional solution to this problem has been to include some context information in the abstraction being calculated [27]. Typical examples of this approach include: memory components [34], procedure strings [18, 19], assumed alias sets [30] and source alias sets with the last call-site <ref> [7] </ref>. Rather than embedding the context in the abstraction being estimated, we have chosen to follow a different strategy where we explicitly represent all invocation paths in an invocation graph. <p> All of this information has been stored by the points-to analysis and need not be recalculated. 7 Related Work 7.1 Alias Analysis The most closely related work is that of Landi and Ryder [30], and Choi et al. <ref> [7] </ref>. In the following paragraphs, we compare our approach with this and other related work, under different points of importance: Alias Representation: Our points-to abstraction provides alias information in a more compact and informative manner than the exhaustive alias pairs used by Landi and Ryder. <p> However, for the example in Figure 9, the transitive closure of points-to pairs at S3 would generate spurious alias pair (**a,c), which won't be reported by Landi and Ryder. The transitive reduction scheme proposed in <ref> [7] </ref> is similar to our points-to abstraction in this context. main () f int flflx, fly, z, w; S1: x = &y; =fl (x,y,D) fl= fl (y,z,D) fl= fl (y,w,D) fl= S1: (flx,y) (flflx,fly) S2: (flx,y) (flflx,fly) (fly,z) (flflx,z) S3: (flx,y) (flflx,fly) (fly,w) (flflx,z) (flflx,w) (a) Original Program (b) Alias Information
Reference: [8] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <booktitle> In Proceedings of the SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: 1 Introduction and Motivation Alias and dependence analysis are fundamental components of optimizing and parallelizing compilers. Although traditionally studied in the context of Fortran or block-structured languages <ref> [1, 2, 8, 9] </ref>, there has been increasing interest in providing accurate alias and side-effect analysis for C programs [7, 31].
Reference: [9] <author> K. D. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction and Motivation Alias and dependence analysis are fundamental components of optimizing and parallelizing compilers. Although traditionally studied in the context of Fortran or block-structured languages <ref> [1, 2, 8, 9] </ref>, there has been increasing interest in providing accurate alias and side-effect analysis for C programs [7, 31].
Reference: [10] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: An analogous problem of control flow analysis [40], has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed <ref> [10, 18, 35, 39, 40, 41] </ref>. In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow.
Reference: [11] <author> A. Deutsch. </author> <title> A storeless model of aliasing and its ab stractions using finite representations of right-regular equivalence relations. </title> <booktitle> In Proceedings of the IEEE 1992 International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In fact, one does not know statically how many locations will be allocated. Thus, a completely different approach is likely to be required. For example, Deutsch argues that a storeless model is more appropriate for the heap-based problems <ref> [11] </ref>. We discuss this issue further in Section 7. 2 Setting the McCAT compiler Our points-to analysis is implemented in the Mc-CAT (McGill Compiler Architecture Testbed) optimizing/parallelizing C compiler. In order to provide the correct intermediate language, we designed a structured intermediate representation called SIMPLE [22, 43].
Reference: [12] <author> C. M. Donawa. </author> <title> The design and implementation of a structured backend for the McCAT C compiler. </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> expected July </month> <year> 1994. </year>
Reference-contexts: This transformation can then lead to better results in later phases of the compiler such as reducing the number of loads and stores <ref> [12] </ref>. We present the points-to abstraction and the basic flow analysis rules in Section 3 and we compare our approach to similar approaches in Section 7. A context-sensitive interprocedural analysis: 1 In more conventional alias analysis, the notion that x points-to y would be captured by an alias pair (*x,y). <p> One example of an optimizing transformation is the use of definite points-to information to reduce the number of loads required in the low-level program representation <ref> [12] </ref>. In the context of fine-grain paralleliz-ing transformations, we are currently studying the use of points-to information for providing more accurate dependence information for instruction scheduling.
Reference: [13] <author> M. Emami. </author> <title> A practical interprocedural alias analysis for an optimizing/parallelizing C compiler. </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The design of these rules is further simplified by the fact that each of the basic statements can have only one level of pointer indirection for a variable reference. Further details are given in <ref> [13, 22] </ref>. 3 Abstract Stack Locations and Basic Analysis Rules Traditionally, alias analysis methods have approximated aliases by sets of alias pairs. With this approximation, two variable references are said to be aliased if they refer to the same location. <p> We give simple versions of the if and while rules in Figure 1. The complete set of compositional rules that handle break, continue and return in a straightforward manner can be found elsewhere <ref> [13] </ref>. 4 Interprocedural Analysis To accurately estimate the effects of procedure calls on points-to information, we perform context-sensitive interprocedural points-to analysis. That is, when measuring the effect of a procedure call we estimate it within a specific calling context and not just summarize the information for all calling contexts. <p> The unmap algorithm essentially consists of mapping the points-to information of symbolic names to that of invisible variables represented by them, besides that of globals. Complete details of our map and unmap algorithms are described in <ref> [13] </ref>. 4.2 Recursive Procedure Calls The cases of approximate and recursive procedure calls shown in Figure 4 work together to implement a safe and accurate fixed-point computation for recursion.
Reference: [14] <author> A. M. Erosa and L. J. Hendren. </author> <title> Taming control flow: A structured approach to eliminating goto statements. </title> <booktitle> In Proceedings of the IEEE 1994 International Conference on Computer Languages, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Thus, our Mc-CAT compiler provides a structuring phase that converts programs with unstructured control flow to equivalent programs with structured control flow <ref> [14] </ref>. is properly abstracted with an abstract stack location with an appropriate name. More specifically, the abstraction must obey the following two properties.
Reference: [15] <author> R. Ghiya. </author> <title> Interprocedural analysis in the presence of function pointers. </title> <type> ACAPS Technical Memo 62. </type> <institution> School of Computer Science, McGill University, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Finally, the output points-to information for the indirect call is obtained by merging the output points-to sets obtained by analyzing each of the invocable functions. A more formal description of the algorithm is provided in Figure 5. The detailed description is given in <ref> [15] </ref>. fun process call indirect (Input,actualList,ign) = =fl Get the function pointer used to make the indirect call fl= fptr = getFnPtr (ign) =fl Get the set of functions pointedto by fptr from current pointsto information fl= pointedToFns = pointsToSetOf (Input,fptr) =fl Initialize output of the indirect call fl= callOutput =
Reference: [16] <author> R. Ghiya. </author> <title> Practical techniques for heap analysis. </title> <type> ACAPS Technical Note 46, </type> <institution> School of Computer Science, McGill University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: This underlines the need for a powerful companion heap analysis to identify disjoint accesses to heap locations <ref> [16] </ref>. * There are very few cases with three or more pos sible points-to relationships for an indirect reference. One of these cases (with more than 4 points-to relationships), occurs when an array of pointers is initialized (in `toplev'). <p> The complete invocation graph and mapping information provides a convenient basis for implementing other interprocedural analyses such as generalized constant propagation [20], and practical heap analysis <ref> [16] </ref>. The important point here is that after points-to analysis is completed one does not need to worry about function pointers or the correspondence between invisible variables and the calling context. <p> Thus, we use a single location called heap in our abstract stack for the points-to analysis. All heap-directed pointers point to this location. We have designed a separate family of abstractions to capture meaningful relationships between these heap-directed pointers <ref> [16] </ref>, based on the path-matrix model proposed in [23]. Both the original path matrix analysis [23] and the heap-based method proposed by Chase et al. [6] also assume that pointer fields in heap nodes only point to heap nodes, and do not point to variables (which are locations on stack).
Reference: [17] <author> M. W. Hall and K. Kennedy. </author> <title> Efficient call graph anal ysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3), </volume> <pages> pages 227-242, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: To date, our experiments show that this is not a problem, and that it is reasonable to decouple the stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a program in the presence of procedure variables has been previously studied <ref> [3, 17, 29, 37, 42, 44] </ref>. However, the above techniques cannot handle function pointers, because in C they are considered no different from data pointers. One can have function pointers of multiple level, as fields of structures, and as arrays.
Reference: [18] <author> W. L. Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of Scheme programs. Lisp and Symbolic Computation: </title> <journal> an International Journal, 1989. </journal> 2(3/4):179-396. 
Reference-contexts: One traditional solution to this problem has been to include some context information in the abstraction being calculated [27]. Typical examples of this approach include: memory components [34], procedure strings <ref> [18, 19] </ref>, assumed alias sets [30] and source alias sets with the last call-site [7]. Rather than embedding the context in the abstraction being estimated, we have chosen to follow a different strategy where we explicitly represent all invocation paths in an invocation graph. <p> An analogous problem of control flow analysis [40], has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed <ref> [10, 18, 35, 39, 40, 41] </ref>. In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow.
Reference: [19] <author> W. L. Harrison III and Z. Ammarguellat. </author> <title> A program's eye view of Miprac. </title> <booktitle> In Conference Record of Fifth International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1992. </year> <booktitle> Volume 757 of Lecture Notes in Computer Science, </booktitle> <pages> pages 512-537. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: One traditional solution to this problem has been to include some context information in the abstraction being calculated [27]. Typical examples of this approach include: memory components [34], procedure strings <ref> [18, 19] </ref>, assumed alias sets [30] and source alias sets with the last call-site [7]. Rather than embedding the context in the abstraction being estimated, we have chosen to follow a different strategy where we explicitly represent all invocation paths in an invocation graph.
Reference: [20] <author> L. J. Hendren, M. Emami, R. Ghiya, and C. Ver brugge. </author> <title> A practical context-sensitive interprocedural analysis framework for C compilers. </title> <type> ACAPS Technical Memo 72, </type> <institution> School of Computer Science, McGill University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Simultaneously, the association of invisible variables b and c with symbolic names 1 x and 2 x is recorded in the invocation graph node currently under investigation, as map information. This context-sensitive information is used while unmapping and also by other interprocedural analyses <ref> [20] </ref>. Note that only the map information is context-sensitive; the symbolic names themselves are used in a context-free manner inside the procedures, by all analyses. <p> In the context of fine-grain paralleliz-ing transformations, we are currently studying the use of points-to information for providing more accurate dependence information for instruction scheduling. The complete invocation graph and mapping information provides a convenient basis for implementing other interprocedural analyses such as generalized constant propagation <ref> [20] </ref>, and practical heap analysis [16]. The important point here is that after points-to analysis is completed one does not need to worry about function pointers or the correspondence between invisible variables and the calling context. <p> These results also show that it is safe and accurate to separate the stack-based points-to analysis from the structure-based approximations for heap-allocated objects. Furthermore, the method has been used as a foundation for a general purpose interprocedural analysis method <ref> [20] </ref>. The next steps in our work will be to add further optimizations to the method itself, and to measure the effect of accurate points-to analysis on other optimizations and transformations. We are also working on the companion analyses to approximate the heap.
Reference: [21] <author> L. J. Hendren, G. R. Gao, and V. C. Sreedhar. AL PHA: </author> <title> A family of structured intermediate representations for a parallelizing C compiler. </title> <type> ACAPS Technical Memo 49, </type> <institution> School of Computer Science, McGill University, </institution> <month> Nov </month> <year> 1992. </year>
Reference-contexts: The point-specific points-to information is very useful to compute read/write sets such as those used in constructing the ALPHA intermediate representation <ref> [21] </ref>. In these approaches one can directly compute the read and write sets based on the names of variables and the symbolic names used for invisibles. The points-to results are also critical to the support analyses required for dependence testing for array references [28].
Reference: [22] <author> L. J. Hendren, C. Donawa, M. Emami, G. R. Gao, Justiani, and B. Sridharan. </author> <title> Designing the McCAT compiler based on a family of structured intermediate representations. </title> <booktitle> In Conference Record of Fifth International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1992. </year> <booktitle> Volume 757 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406-420. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We discuss this issue further in Section 7. 2 Setting the McCAT compiler Our points-to analysis is implemented in the Mc-CAT (McGill Compiler Architecture Testbed) optimizing/parallelizing C compiler. In order to provide the correct intermediate language, we designed a structured intermediate representation called SIMPLE <ref> [22, 43] </ref>. On one hand, we need to analyze real C programs (not just programs written in a toy subset of C), and therefore our SIMPLE representation faithfully represents these programs. <p> The design of these rules is further simplified by the fact that each of the basic statements can have only one level of pointer indirection for a variable reference. Further details are given in <ref> [13, 22] </ref>. 3 Abstract Stack Locations and Basic Analysis Rules Traditionally, alias analysis methods have approximated aliases by sets of alias pairs. With this approximation, two variable references are said to be aliased if they refer to the same location.
Reference: [23] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1):35- 47, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: Thus, we use a single location called heap in our abstract stack for the points-to analysis. All heap-directed pointers point to this location. We have designed a separate family of abstractions to capture meaningful relationships between these heap-directed pointers [16], based on the path-matrix model proposed in <ref> [23] </ref>. Both the original path matrix analysis [23] and the heap-based method proposed by Chase et al. [6] also assume that pointer fields in heap nodes only point to heap nodes, and do not point to variables (which are locations on stack). <p> All heap-directed pointers point to this location. We have designed a separate family of abstractions to capture meaningful relationships between these heap-directed pointers [16], based on the path-matrix model proposed in <ref> [23] </ref>. Both the original path matrix analysis [23] and the heap-based method proposed by Chase et al. [6] also assume that pointer fields in heap nodes only point to heap nodes, and do not point to variables (which are locations on stack).
Reference: [24] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence anal ysis for pointer variables. </title> <booktitle> In Proceedings of the SIG-PLAN '89 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: They k-limit the access paths to have a finite set of object names, in the presence of recursive structures. Choi et al. name the heap objects by using the place in the program where they are created, as in <ref> [24] </ref>. They use procedure-strings and k-limiting of recursive structures [26] to improve their naming scheme. These names are then used in alias calculation. We differ from these approaches in that we claim that the stack and heap problems can and should be separated.
Reference: [25] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The problem of ensuring that the analysis of a procedure call is specific to a particular calling context has been termed the calling context problem by Horwitz et al. <ref> [25] </ref>, while Landi and Ryder [30] consider this to be the problem of restricting the propagation of information along realizable interprocedural execution paths. One traditional solution to this problem has been to include some context information in the abstraction being calculated [27].
Reference: [26] <author> N. D. Jones and S. Muchnick. </author> <title> Flow analysis and op timization of LISP-like structures. In Program Flow Analysis, Theory, </title> <booktitle> and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year> <note> Chapter 4. </note>
Reference-contexts: They k-limit the access paths to have a finite set of object names, in the presence of recursive structures. Choi et al. name the heap objects by using the place in the program where they are created, as in [24]. They use procedure-strings and k-limiting of recursive structures <ref> [26] </ref> to improve their naming scheme. These names are then used in alias calculation. We differ from these approaches in that we claim that the stack and heap problems can and should be separated.
Reference: [27] <author> N. D. Jones and S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: One traditional solution to this problem has been to include some context information in the abstraction being calculated <ref> [27] </ref>. Typical examples of this approach include: memory components [34], procedure strings [18, 19], assumed alias sets [30] and source alias sets with the last call-site [7].
Reference: [28] <author> Justiani and L. J. Hendren. </author> <title> Supporting array depen dence testing for an optimizing/parallelizing C com piler. </title> <booktitle> In Proceedings of 1994 International Conference on Compiler Construction., </booktitle> <month> April </month> <year> 1994. </year> <booktitle> Volume 749 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This information is useful for array dependence testing <ref> [28] </ref>. 3.3 Basic Analysis Rules The basic analysis rules are presented in Figure 1. Note that for pointer assignment statements we have a general rule that uses the L-locations for the lhs and R-locations for the rhs to compute the returned flow information. <p> This information is very useful for array dependence analysis, as it reduces the number of array pairs to be collected for subscript analysis <ref> [28] </ref>. * Overall, 27:92% of points-to relationships used, have heap locations as the pointer target. <p> In these approaches one can directly compute the read and write sets based on the names of variables and the symbolic names used for invisibles. The points-to results are also critical to the support analyses required for dependence testing for array references <ref> [28] </ref>. In this context, points-to results are used to: increase the number of admissible loop-nests, decrease the number of array pairs that require testing, and allow the analysis of array subscripts that involve pointer variables.
Reference: [29] <author> A. Lakhotia. </author> <title> Constructing call multigraphs using de pendence graphs. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-284, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: To date, our experiments show that this is not a problem, and that it is reasonable to decouple the stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a program in the presence of procedure variables has been previously studied <ref> [3, 17, 29, 37, 42, 44] </ref>. However, the above techniques cannot handle function pointers, because in C they are considered no different from data pointers. One can have function pointers of multiple level, as fields of structures, and as arrays.
Reference: [30] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algo rithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the 1992 SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The problem of ensuring that the analysis of a procedure call is specific to a particular calling context has been termed the calling context problem by Horwitz et al. [25], while Landi and Ryder <ref> [30] </ref> consider this to be the problem of restricting the propagation of information along realizable interprocedural execution paths. One traditional solution to this problem has been to include some context information in the abstraction being calculated [27]. <p> One traditional solution to this problem has been to include some context information in the abstraction being calculated [27]. Typical examples of this approach include: memory components [34], procedure strings [18, 19], assumed alias sets <ref> [30] </ref> and source alias sets with the last call-site [7]. Rather than embedding the context in the abstraction being estimated, we have chosen to follow a different strategy where we explicitly represent all invocation paths in an invocation graph. <p> Our experience shows that mapping invisibles involved 4 A similar notion of non-visible variables is given in <ref> [30] </ref>. 5 Note that the information provided is still safe, but less precise. fun process call (Input,actualList,formalList,ign,funcBody) = (funcInput,mapInfo) = map process (Input,formalList,actualList) case ign of &lt; Ordinary &gt; =&gt; if (funcInput == ign.storedInput) =fl already computed fl= return (unmap process (Input,ign.storedOutput,mapInfo)); else =fl compute output, store input and output fl= <p> 0 sim 15 0 19 0 0 26 0 8 travel 2 0 123 0 14 57 0 54 csuite 12 0 52 0 8 56 0 0 msc 0 0 6 0 0 6 0 0 Table 4: Categorization of Points-to Information Used by Indirect References Landi and Ryder <ref> [30] </ref> also present empirical data on the total number of program-point-specific alias pairs collected. <p> All of this information has been stored by the points-to analysis and need not be recalculated. 7 Related Work 7.1 Alias Analysis The most closely related work is that of Landi and Ryder <ref> [30] </ref>, and Choi et al. [7]. In the following paragraphs, we compare our approach with this and other related work, under different points of importance: Alias Representation: Our points-to abstraction provides alias information in a more compact and informative manner than the exhaustive alias pairs used by Landi and Ryder.
Reference: [31] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Symposium on Programmi ng Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction and Motivation Alias and dependence analysis are fundamental components of optimizing and parallelizing compilers. Although traditionally studied in the context of Fortran or block-structured languages [1, 2, 8, 9], there has been increasing interest in providing accurate alias and side-effect analysis for C programs <ref> [7, 31] </ref>. <p> The overall average is equal to 1:13, while the maximum average for a program is only 1:77. This indicates that the information collected by our points-to analysis is highly precise. The overall average is quite close to that reported by Landi et al. <ref> [31] </ref>, which is 1.2. * Overall, 28:80% of indirect references in the programs have the dereferenced pointer definitely pointing to a single stack location. Using the definite information, 19:39% of indirect references, can be replaced by direct references (when the dereferenced pointer does not point to an invisible variable).
Reference: [32] <author> W. A. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: The empirical results presented in section 6 show the existence of a substantial number of definite points-to relationships, which forms very valuable information. Landi and Ryder give an algorithm only for calculation of may-aliases. An algorithm for calculating must-aliases is presented in <ref> [32] </ref>. However, it handles only single level pointers and considers the problem in isolation from may-alias computation. Choi et al. give an example of how must-alias information can improve the precision of alias analysis.
Reference: [33] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9), </volume> <pages> pages 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: However, they cannot distinguish information propagated by two different invocations of a procedure from the same call-site. Further, they cannot properly handle information propagated along call-chains of size greater than one. They also propose using a source alias set abstraction, but its role is not clear from their paper <ref> [33] </ref>. We do not introduce these approximations, as we explicitly propagate information along invocation paths in the program, using the invocation graph representation. Several other advantages of using invocation graphs are mentioned in section 4.
Reference: [34] <author> E. W. Myers. </author> <title> A precise inter-procedural data flow al gorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: One traditional solution to this problem has been to include some context information in the abstraction being calculated [27]. Typical examples of this approach include: memory components <ref> [34] </ref>, procedure strings [18, 19], assumed alias sets [30] and source alias sets with the last call-site [7]. Rather than embedding the context in the abstraction being estimated, we have chosen to follow a different strategy where we explicitly represent all invocation paths in an invocation graph.
Reference: [35] <author> A. Neirynck, P. Panangaden, and A. J. Demers. </author> <title> Ef fect analysis in higher-order languages. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(1) </volume> <pages> 1-37, </pages> <year> 1989. </year>
Reference-contexts: An analogous problem of control flow analysis [40], has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed <ref> [10, 18, 35, 39, 40, 41] </ref>. In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow.
Reference: [36] <author> H. D. Pande and B. G. Ryder. </author> <title> Static type determina tion for C++. </title> <booktitle> In Proceedings of the Sixth Usenix C++ Technical Conference, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow. Type analysis techniques have been developed for C++ <ref> [36] </ref> and SELF [4, 5]. 8 Conclusions and Further Work In this paper we have presented a new method for computing the points-to information for stack-allocated data structures. This method uses the concept of abstract stack locations to capture all possible and definite relationships between accessible stack locations.
Reference: [37] <author> B. G. Ryder. </author> <title> Constructing the call graph of a pro gram. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(3):216-226, </volume> <month> May </month> <year> 1979. </year>
Reference-contexts: To date, our experiments show that this is not a problem, and that it is reasonable to decouple the stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a program in the presence of procedure variables has been previously studied <ref> [3, 17, 29, 37, 42, 44] </ref>. However, the above techniques cannot handle function pointers, because in C they are considered no different from data pointers. One can have function pointers of multiple level, as fields of structures, and as arrays.
Reference: [38] <author> S. Sagiv, N. Francez, M. Rodeh, and R. Wilhem. </author> <title> A logic-based approach to data flow analysis. </title> <booktitle> In Proceedings of Second International Workshop on Programming Language Implementation and Logic Programming, Volume 456 of Lecture Notes in Computer Science, </booktitle> <pages> pages 277-292. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1990. </year>
Reference-contexts: Choi et al. give an example of how must-alias information can improve the precision of alias analysis. But they do not describe how to calculate must-aliases and how to integrate this calculation with the may-alias calculation. Sagiv et al. <ref> [38] </ref> propose simultaneous collection of both universal and existential properties of programs, in their logic-based formulation of data flow analysis problems. In particular, they show how universal assertions can be used to improve the accuracy of existential assertions, using the pointer equality problem as an example.
Reference: [39] <author> P. Sestoft. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 39-53, </pages> <address> London, </address> <month> September </month> <year> 1989. </year> <note> ACM Press. </note>
Reference-contexts: An analogous problem of control flow analysis [40], has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed <ref> [10, 18, 35, 39, 40, 41] </ref>. In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow.
Reference: [40] <author> O. Shivers. </author> <title> Control flow analysis in Scheme. </title> <booktitle> In Pro ceedings of the SIGPLAN '88 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: They can also be type-cast into data pointers and vice versa. Hence the full power of a points-to analysis is needed to correctly and precisely accommodate them in an in-terprocedural analysis. An analogous problem of control flow analysis <ref> [40] </ref>, has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed [10, 18, 35, 39, 40, 41]. <p> An analogous problem of control flow analysis [40], has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed <ref> [10, 18, 35, 39, 40, 41] </ref>. In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow.
Reference: [41] <author> O. Shivers. </author> <title> Control Flow Analysis of Higher Order Languages. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: An analogous problem of control flow analysis [40], has been studied in the domain of higher order languages. Here, the possibility of creating functions dynamically (for example, using lambda in Scheme) poses additional complexity. Different approaches to solve this problem have been proposed <ref> [10, 18, 35, 39, 40, 41] </ref>. In object-oriented languages, call graph analysis becomes non-trivial due to inheritance and function overloading. The method invoked from a call-site depends on the type of the receiver, and static type determination is used to estimate control flow.
Reference: [42] <author> T. C. Spillman. </author> <title> Exposing side-effects in a PL/I op timizing compiler. </title> <booktitle> In Proceedings of the 1971 IFIPS Congress. </booktitle> <publisher> North Holland Publishing Co., </publisher> <address> Amsterdam, </address> <year> 1971, </year> <pages> pages 56-60. </pages>
Reference-contexts: To date, our experiments show that this is not a problem, and that it is reasonable to decouple the stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a program in the presence of procedure variables has been previously studied <ref> [3, 17, 29, 37, 42, 44] </ref>. However, the above techniques cannot handle function pointers, because in C they are considered no different from data pointers. One can have function pointers of multiple level, as fields of structures, and as arrays.
Reference: [43] <author> B. Sridharan. </author> <title> An analysis framework for the McCAT compiler. </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: We discuss this issue further in Section 7. 2 Setting the McCAT compiler Our points-to analysis is implemented in the Mc-CAT (McGill Compiler Architecture Testbed) optimizing/parallelizing C compiler. In order to provide the correct intermediate language, we designed a structured intermediate representation called SIMPLE <ref> [22, 43] </ref>. On one hand, we need to analyze real C programs (not just programs written in a toy subset of C), and therefore our SIMPLE representation faithfully represents these programs.
Reference: [44] <author> W. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages. </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: To date, our experiments show that this is not a problem, and that it is reasonable to decouple the stack and heap analyses. 7.2 Function Pointers The problem of constructing the call graph of a program in the presence of procedure variables has been previously studied <ref> [3, 17, 29, 37, 42, 44] </ref>. However, the above techniques cannot handle function pointers, because in C they are considered no different from data pointers. One can have function pointers of multiple level, as fields of structures, and as arrays.
References-found: 44

