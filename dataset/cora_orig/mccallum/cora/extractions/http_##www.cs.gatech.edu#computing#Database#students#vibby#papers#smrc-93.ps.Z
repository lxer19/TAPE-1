URL: http://www.cs.gatech.edu/computing/Database/students/vibby/papers/smrc-93.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/vibby/vibby.html
Root-URL: 
Title: Using the Co-existence Approach to Achieve Combined Functionality of Object-Oriented and Relational Systems  
Author: R. Ananthanarayanan, V. Gottemukkala, W. Kaefer, T. J. Lehman, H. Pirahesh, 
Affiliation: Georgia Institute of Technology  IBM Almaden Research Center  
Abstract: Once considered a novelty, object oriented systems have now entered the mainstream. Their impressive performance and rich type systems have created a demand for object oriented features in other areas, such as relational database systems. We believe the current efforts to combine object oriented and relational features into a single hybrid system will fall short of the mark, whereas our approach, the co-existence approach, has the distinction of requiring far less work, but at the same time promising both the desired functionality and performance. We describe the attributes of our co-existing systems, an object oriented system (C++) and a relational system (Starburst), and show how this combination supports the desired features of both object-oriented and relational systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Ananthanarayanan, V. Gottemukkala, W. Kaefer, T.J. Lehman, and H. Pirahesh. SMRC: </author> <title> Incorporating Object-Orientation into Star-burst. </title> <type> Research Report, </type> <institution> IBM Almaden Research Center, </institution> <year> 1993. </year> <note> under preparation. </note>
Reference-contexts: Many of our colleagues in the Starburst project deserve a special thanks for providing a very stimulating environment. Thanks are also due to Pat Selinger, Jim Stamos, and Bill Cody for their comments on an earlier version of this paper. <ref> [1] </ref> contains a longer version of this paper.
Reference: [2] <author> M. Astrahan, M. Blasgen, D. Chamberlin, K. Eswaran, J. Gray, P. Griffiths, W. King, R. Lorie, P. McJones, J. Mehl, G. Putzolu, I. Traiger, B. Wade, and V. Watson. </author> <title> System R: Relational Approach to Database Management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2) </volume> <pages> 97-137, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: The technique of linking objects has been exploited in RDBMS. For example, links were first introduced in System R <ref> [2] </ref>, in IBM DB2 [8], and in Star-bursts IMS attachment [3]. However, in RDBMSs, the link representation itself does not change, regardless of whether the data is on disk or buffered in main memory.
Reference: [3] <author> Mike Carey, Eugene Shekita, George Lapis, Bruce Lindsay, and John McPherson. </author> <title> An Incremental Join Attachment for Starburst. </title> <booktitle> In Proc. 16th International Conference on Very Large Data Bases, </booktitle> <address> Brisbane, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: The technique of linking objects has been exploited in RDBMS. For example, links were first introduced in System R [2], in IBM DB2 [8], and in Star-bursts IMS attachment <ref> [3] </ref>. However, in RDBMSs, the link representation itself does not change, regardless of whether the data is on disk or buffered in main memory. An important advance of OOSs is the introduction of pointer swizzling [21, 12], which converts disk pointers to virtual-memory pointers upon loading of the data.
Reference: [4] <author> L. DeMichiel, D. Chamberlin, B. Lindsay, R. Agrawal, and M. Arya. Polyglot: </author> <title> Extensions to Relational Databases for Sharable Types and Functions in a Multi-language Environment. </title> <booktitle> In Proc. </booktitle> <address> DE 93 [18]. </address>
Reference-contexts: Much work is being done to produce such a hybrid system, taking the form of one of two approaches: adding relational features to an object oriented system [22], or adding object oriented features to a relational system <ref> [4] </ref>. The first approach is a potentially formidable task, as a complete RDBMS is much larger than an OOS. <p> Furthermore, persistent objects are only accessible through accessor functions provided by O 2 which results in a performance disadvantage compared to ObjectStore, or our approach, where objects are directly accessible by the application. Polyglot <ref> [4] </ref> takes yet another approach. In Polyglot, the objective is to add all the OO features to an existing RDBMS, which defines a new type system of its own.
Reference: [5] <editor> O. Deux and et al. </editor> <title> The O 2 System. </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: However, we can avoid the difference in RDBMS and application-language data formats (termed as "impedance mismatch" in the literature) by optionally storing objects in their native format and enhancing the RDBMS to access the native object-oriented data through user-defined member functions. O 2 <ref> [5] </ref> provides persistent storage for objects based on the notion of persistent roots which are shared between O 2 and the application. Persistent objects are stored in O 2 using a language-independent format, e.g. complex objects are decomposed and stored in multiple records. <p> Obviously, if whole objects are shipped, the security coverage is identical to the earlier mentioned object shipping techniques of OOS, such as Ver-sant [15]. 2 Structured mapping: An object type is mapped to a multiple-attribute relational table (similar to O 2 <ref> [5] </ref>), i.e. for each attribute definition within the object type there exists a corresponding attribute within the relation. Thus, the full functionality of the RDBMS is available on the data.
Reference: [6] <author> L.M. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita. </author> <title> Starburst Mid-Flight: As the Dust Clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 143-160, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Starburst is an extensible relational database prototype developed at the IBM Almaden Research Center <ref> [6] </ref>. We choose Starburst because it supports experimentation at all levels of the system. In this section we describe how we realized features 1 through 3 with respect to C++ and Starburst. 4.1 Adding User-defined Functions Consider a user-defined function such as length or width.
Reference: [7] <author> J.M. Hellerstein and M. Stonebraker. </author> <title> Predicate Migration: Optimizing Queries with Expensive Predicates. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: hand, the RDBMS 1 An obvious extension of basic mapping is using several attributes of a tuple each storing one object. can access the objects as tuples, but it has to apply the OOS accessor and mutator 2 functions to capture the behavior of the data-members of the objects (see <ref> [7] </ref> for related optimization issues). Thus, all the set-oriented functionality of the RDBMS (e.g. concurrency control, recovery, authorization, etc.) is applicable to the data. Only for the attribute-oriented functionality (e.g. associative queries, access path 3 support) does the RDBMS have to apply the OOS member functions to access the data.
Reference: [8] <institution> IBM. IBM Database 2 Administration Guide, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: The technique of linking objects has been exploited in RDBMS. For example, links were first introduced in System R [2], in IBM DB2 <ref> [8] </ref>, and in Star-bursts IMS attachment [3]. However, in RDBMSs, the link representation itself does not change, regardless of whether the data is on disk or buffered in main memory. <p> Otherwise, we compute the offset between the current load address and the previous load address and adjust all pointers within the BLOB. 7 We can implement this algorithm with a similar mechanism as DB2's field procedure <ref> [8] </ref>. DB2 invokes a field procedure when data is moved from disk to memory or vice versa. One usage of field procedures is data compression/decompression. Analogously, in the SMRC environment field procedures should be invoked whenever data goes across a process boundary.
Reference: [9] <author> Informix. </author> <title> Guide to SQL Reference, </title> <month> December </month> <year> 1991. </year>
Reference-contexts: This method also provides full security and integrity, as authorization is checked by trusted server software. In an RDBMS, all the manipulation and navigation specified by the DBMS requests must be done within the DBMS address space. Some systems <ref> [9] </ref> use a mechanism of application code, sometimes called stored procedures, run inside the RDBMS address space to avoid crossing the application to server boundary. If, however, an RDBMS application does not exploit such a mechanism, it will suffer performance degradation due to RDBMS address space crossings.
Reference: [10] <author> ISO ANSI. </author> <note> ISO-ANSI Working Draft: Database Language SQL2 and SQL3; X3H2; ISO/IEC JTC1/SC21/WG3, </note> <year> 1992. </year>
Reference-contexts: In our example we have to register the type sidelen, defined in the C++ program, as a type within the RDBMS. Basically, sidelen is just another name for the data type float, i.e. sidelen is a so-called distinct type <ref> [10] </ref>. <p> Thus, inheritance is realized through a scheme in which functions appear to be flat to the RDBMS (i.e. without any associated inheritance hierarchy). As mentioned before, this scheme allows adaptation of the RDBMS to different type inheritance models, such as those of C++ and SQL <ref> [10] </ref>. 4.2.2 Dynamically Dispatched Functions The address of a static function can be resolved at compile time, based on the types of the parameters of the actual function call. In the case of dynamically dispatched functions, the actual function address for a corresponding call is not known until run-time.
Reference: [11] <author> A. Kemper and D. Kossmann. </author> <title> Adaptable Pointer Swizzling Strategies in Object Bases. </title> <booktitle> In Proc. </booktitle> <address> DE 93 [18]. </address>
Reference-contexts: The process of adjustment is called pointer swizzling. 5.3 Swizzling, References, and Object Ids Swizzling: Pointer swizzling <ref> [16, 11, 20] </ref>, i.e. the transformation of disk-based pointers into virtual-memory pointers (and vice versa), offers two advantages. First, it offers performance gains since the pointers need not be interpreted for each traversal.
Reference: [12] <author> Chares Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The Objectstore Database System. </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: In this section we compare and contrast our approach and system architecture with those of systems with similar objectives. The ObjectStore approach <ref> [12] </ref> takes an OO language (C++) and provides a tightly integrated language interface to traditional DBMS features such as persistence, associative queries, sets, and transaction management. ObjectStore provides type-independent persistence and set-oriented behavior through collections and queries. <p> Thus, SMRC is designed as a part of the application's address space (we discuss the navigation issue later). However, including the data into the application's address space may compromise its security and integrity. For example, some OOSs (e.g., ObjectStore <ref> [12] </ref>) ship physical pages to the client rather than a logical unit, such as an object. So, when an application requests an object, the page containing that object is returned to the application along with other objects in that page. <p> Shipping the BLOB data between client and server corresponds to shipping of page sets. However, authorization and integrity is still checked for the BLOB data by the RDBMS which has many advantages compared to page shipping done by OOS, such as ObjectStore <ref> [12] </ref>. <p> However, in RDBMSs, the link representation itself does not change, regardless of whether the data is on disk or buffered in main memory. An important advance of OOSs is the introduction of pointer swizzling <ref> [21, 12] </ref>, which converts disk pointers to virtual-memory pointers upon loading of the data. Swizzling pointers during loading/unloading of objects requires some kind of persistent pointers. <p> In this section, we discuss the design of SMRC. First, we show how SMRC satisfies the relational interface to its data. Second, we discuss support for set 5 New operators also attach type-tags to objects. oriented OOS access. Most OOS use the notion of col-lections (e.g. <ref> [12] </ref>) to refer to a set of objects. Thus, at a first glance collections are similar to relations. However, collections offer some additional variations. For example, collections may maintain an order (lists) and often contain only pointers to objects, not the objects themselves. Thus, SMRC offers special support for collections.
Reference: [13] <author> T. Lehman, E. Shekita, </author> <title> and L.F. Cabrera. An Evaluation of the Star burst Memory-Resident Storage Component. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> December </month> <year> 1992. </year>
Reference-contexts: As a result, the data stored in SDC is accessible via the usual relational operators of Starburst during query execution. In fact, the design of SDC is very similar to that of Starburst's MMM storage component, described in <ref> [13] </ref>, which supports memory-resident relations. But, in addition to the MMM functionality, SDC provides OOS with a procedure call interface thus avoiding the long access path to an attribute passed through all the involved RDBMS layers.
Reference: [14] <author> Bruce Lindsay, John McPherson, and Hamid Pirahesh. </author> <title> Data Manage ment Extension Architecture. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 220-226, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Thus, SMRC offers special support for collections. At the end of this section, we discuss some issues of pointer swizzling, object identifiers and references. 5.1 Shared Data Cache (SDC) Starburst's Data Management Extension Architecture (DMEA) <ref> [14] </ref> formalizes the interface for creating new storage methods and attachments. Storage methods provide the means for storing the tuples of a relation, whereas attachments provide the means for managing data structures about relations (e.g., indexes).
Reference: [15] <author> Mary Loomis. </author> <title> Client-Server Architecture. Object-Oriented Program ming, </title> <month> February </month> <year> 1992. </year>
Reference-contexts: This compromises security of the data, because the application can read objects for which it is not authorized, or it can even modify these other objects (may be accidentally through the use of an incorrect pointer value). Other OOSs, such as Versant <ref> [15] </ref>, ship whole objects instead of physical pages. This method solves the problem of object level side-effects mentioned above. However, it exposes all attributes of an object. For example, there is no way to hide the salary of an employee and expose only the name and address. <p> Attribute value security (e.g. hiding of salary) can be done by using the salary ac-cessor function in the select list, instead of shipping the whole object. Obviously, if whole objects are shipped, the security coverage is identical to the earlier mentioned object shipping techniques of OOS, such as Ver-sant <ref> [15] </ref>. 2 Structured mapping: An object type is mapped to a multiple-attribute relational table (similar to O 2 [5]), i.e. for each attribute definition within the object type there exists a corresponding attribute within the relation. Thus, the full functionality of the RDBMS is available on the data.
Reference: [16] <author> J.E.B. Moss. </author> <title> Working with Persistent Objects: To Swizzle or Not to Swizzle. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3), </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: The process of adjustment is called pointer swizzling. 5.3 Swizzling, References, and Object Ids Swizzling: Pointer swizzling <ref> [16, 11, 20] </ref>, i.e. the transformation of disk-based pointers into virtual-memory pointers (and vice versa), offers two advantages. First, it offers performance gains since the pointers need not be interpreted for each traversal.
Reference: [17] <author> Hamid Pirahesh and C. Mohan. </author> <title> Evolution of Relational DBMSs To ward Object Support: A Practical Viewpoint. </title> <booktitle> In Proc. Datenbanksys-teme in Buro, </booktitle> <publisher> Technik und Wissenschaft, </publisher> <address> Kaiserslautern, </address> <month> March </month> <year> 1991. </year> <note> Springer-Verlag. Also available as IBM Research Report RJ 8324, </note> <institution> IBM Almaden Research Center, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Furthermore, our method makes the system more easily extensible since it allows the system to be adapted to many application languages. Our approach is an evolutionary approach similar to the one recommended in <ref> [17] </ref>. Our objective is to reuse as much existing technology as possible. To this end, we employ an RDBMS to provide support in areas of strength such as persistence, transaction management, and associative queries. We achieve this without forcing the OOS's type system into the RDBMS.
Reference: [18] <editor> Proc. </editor> <booktitle> 9th IEEE International Conferenceon Data Engineering, </booktitle> <address> Vienna, </address> <month> April </month> <year> 1993. </year>
Reference: [19] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley Publishing Co., </publisher> <year> 1987. </year>
Reference-contexts: CAD/CAM applications usually employ complex algorithms encoded in large vendor-provided libraries written in object-oriented languages like C++ <ref> [19] </ref>. Thus, our system is designed to manage the working set of data in such a way that C++ library routines are applicable.
Reference: [20] <author> S.J. White and D.J. DeWitt. </author> <title> A Performance Study of Alternative Ob ject Faulting and Pointer Swizzli ng Strategies. </title> <booktitle> In Proc. 18th International Conference on Very Large Data Bases, </booktitle> <address> Vancouver, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: The process of adjustment is called pointer swizzling. 5.3 Swizzling, References, and Object Ids Swizzling: Pointer swizzling <ref> [16, 11, 20] </ref>, i.e. the transformation of disk-based pointers into virtual-memory pointers (and vice versa), offers two advantages. First, it offers performance gains since the pointers need not be interpreted for each traversal.
Reference: [21] <author> Paul Wilson. </author> <title> Pointer Swizzling at Page Fault Time: Efficiently Sup porting Huge Address Spaces on Standard Hardware. </title> <institution> Electrical Engineering and Computer Science Technical Report UIC-EECS-90-6, University of Illinois at chicago, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: However, in RDBMSs, the link representation itself does not change, regardless of whether the data is on disk or buffered in main memory. An important advance of OOSs is the introduction of pointer swizzling <ref> [21, 12] </ref>, which converts disk pointers to virtual-memory pointers upon loading of the data. Swizzling pointers during loading/unloading of objects requires some kind of persistent pointers. <p> First, it offers performance gains since the pointers need not be interpreted for each traversal. Second, which might be more important, some swizzle techniques (e.g. <ref> [21] </ref>) allow applications to work with persistent pointers exactly the same way as with common C++ pointers. Thus, it is possible to be object code compatible to C++ libraries; libraries which were not created to be used in a database environment.
Reference: [22] <author> Stanley Zdonik and David Maier. </author> <title> Fundamentals of Object-Oriented Databases. </title> <editor> In Stan Zdonik and David Maier, editors, </editor> <booktitle> Readings In Object-Oriented Database Systems. </booktitle> <publisher> Morgan-Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Much work is being done to produce such a hybrid system, taking the form of one of two approaches: adding relational features to an object oriented system <ref> [22] </ref>, or adding object oriented features to a relational system [4]. The first approach is a potentially formidable task, as a complete RDBMS is much larger than an OOS.
References-found: 22

