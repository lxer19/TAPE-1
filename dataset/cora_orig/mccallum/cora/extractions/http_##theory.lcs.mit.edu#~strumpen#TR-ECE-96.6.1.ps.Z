URL: http://theory.lcs.mit.edu/~strumpen/TR-ECE-96.6.1.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~porch/
Root-URL: 
Email: email: fstrumpen,ramkumarg@eng.uiowa.edu  
Title: Portable Checkpointing and Recovery in Heterogeneous Environments  
Author: Volker Strumpen and Balkrishna Ramkumar 
Address: Iowa, Iowa City, Iowa 52242  
Affiliation: Department of Electrical and Computer Engineering, University of  
Abstract: Current approaches for checkpointing and recovery assume system homogeneity, where checkpointing and recovery are both performed on the same processor architecture and operating system configuration. Sometimes it is desirable or necessary to recover the failed computation on a different processor architecture, with possibly different byte-ordering and data-alignment specifications. This implies that checkpointing and recovery must be portable. We provide portability by means of a universal checkpoint format that allows object codes to resume execution from a checkpointed state, allowing for fast execution of already compiled code, rather than interpreting or compiling on the fly. This paper describes the system support needed to implement portable checkpoints, and the shadow checkpoint algorithm to checkpoint and recover a sequential process. Experimental results on three different architecture-operating system combinations demonstrate the checkpointing overhead and the cost of recovery. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4), </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: basic idea for saving the existential variables of the stack is to visit all stack frames, and save the existential 4 extern int checkpoint (); main (int argc, char *argv []) - chkpt_main (argc, argv); - chkpt_main (int argc, char *argv []) - int n, result; n = atoi (argv <ref> [1] </ref>); result = fib (n); - - return (fib (n-1) + fib (n-2)); else - checkpoint (); return 1; - the Shadow Checkpoint Algorithm; cf. Figures 4 and 5. variables specified at compile time. For a portable implementation, only function call and return instructions can be used safely. <p> - unsigned long _SL_funid, _SL_addr; int n, result; switch (_SL_chkptmode) - case (_SL_EXEC): break; case (_SL_RESTORE): _SL_addr = s_stack.top; _SL_RESTORE_chkpt_main_0; _SL_CONVERT_chkpt_main_0 (_SL_addr); switch (_SL_funid) - case (0): goto L_SL_fun0; - case (_SL_RECOVER): _SL_addr = s_stack.top; _SL_CONVERT_chkpt_main_0 (_SL_addr); _SL_RESTORE_chkpt_main_0; switch (_SL_funid) - case (0): goto L_SL_fun0; - n = atoi (argv <ref> [1] </ref>); _SL_funid = 0; L_SL_fun0: result = fib (n); switch (_SL_chkptmode) - case (_SL_EXEC): break; case (_SL_SAVE): _SL_SAVE_chkpt_main_0; return 0; - printf (""n fib (%d) = %d"n", n, result); - - unsigned long _SL_funid, _SL_addr; int _SL_fun0, _SL_fun1; switch (_SL_chkptmode) - case (_SL_EXEC): break; case (_SL_RESTORE): _SL_addr = s_stack.top; _SL_RESTORE_fib_0; _SL_CONVERT_fib_0 <p> Note that a shadow stack pop operation affects an entire object. Array a is restored as a whole, not element-wise. In order to recover forward pointers here p to a <ref> [1] </ref> the address of each object's element on the activation stack is stored in its location on the shadow stack after the value of the element has been restored on the activation stack; cf. broken lines in Figure 8. This mapping is needed, when function1 is restored. <p> This mapping is needed, when function1 is restored. The frame of function1 contains the offset to a <ref> [1] </ref> in address X ps . Recovering pointer p involves the transformation of the offset into the pointer. This requires the lookup operation: p= fi fl . <p> Only blocks on the used list are currently checkpointed. This, however, may include unreachable memory that has been allocated but not freed. It may be cost effective to perform garbage collection <ref> [1] </ref> before checkpointing the heap to further reduce the amount of information that needs to be check-pointed. 6 Experimental Results Two types of experiments were performed to evaluate the performance of portable checkpoints: (1) Microbench-marks to shed light on the cause of overheads, and (2) three small application programs to demonstrate
Reference: [2] <author> Robert D. Blumofe. </author> <title> Executing Multithreaded Programs Efficiently. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Mas-sachusetts Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs.
Reference: [3] <author> Nicholas S. Bowen and Dhiraj K. Pradhan. </author> <title> Virtual checkpoints: Architecture and performance. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5):516525, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: This technique requires the construction of a complex language environment. Moreover, neither interpreter-based systems nor compilation on the fly are explicitly designed to support fault tolerance. Providing hardware support for fault tolerance such as Sheaved Memory [21] or the Virtual Checkpoint Architecture <ref> [3] </ref> are not designed for portability either. The remainder of this paper is organized as follows. In Section 2, we describe related work in the area of check-pointing and recovery.
Reference: [4] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3:6375, </volume> <year> 1985. </year>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. <p> In checkpoint, for each shadow address on the pointer stack, overwrite the contents of the shadow address by its corresponding portable offset. As an example, consider the code fragment in Figure 6 and the illustration in Figure 7. extern int checkpoint (); chkpt_main () - long a <ref> [4] </ref>; function1 (a); - function1 (long *p) - *p = 1; checkpoint (); - point Algorithm with call by reference; cf. Figure 7. 8 When checkpoint is called, the save phase begins. First, the existential variables of function1 are pushed onto the shadow stack, in particular pointer p.
Reference: [5] <author> Geert Deconinck, </author> <title> editor. Integrating Fault Tolerance in off-the-shelf Massively Parallel Systems, </title> <booktitle> Workshop run by FTMPS consortium (ESPRIT 6731) within HPCN Europe 1996, </booktitle> <year> 1996. </year>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs.
Reference: [6] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The performance of consistent checkpointing. </title> <booktitle> In 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 3947, </pages> <address> Houston, Texas, </address> <month> October </month> <year> 1992. </year> <note> IEEE. </note>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. <p> At runtime, heuristics are used to determine which of these checkpoints will be activated. Plank and others [13] propose latency hiding optimizations to reduce the cost of transformation of a checkpoint to stable storage. Elnozahy <ref> [6] </ref> and Plank [17] have proposed efficient implementation techniques that limit the overhead of checkpointing to within 2-5% of the the overall runtime of a program, when checkpoints are taken every two minutes. <p> All experiments are performed with sequential check-pointing, where the program is halted to copy its state onto the shadow stack, then writes the checkpoint to disk, and, after completion, continues the program execution. Optimizations, such as proposed in <ref> [6, 17] </ref>, can be applied. 6.2.1 Heat Equation We use a Jacobi-type iteration to solve the heat diffusion problem on a 256 fi 256 grid, executing 1; 000 iterations.
Reference: [7] <author> Michael Franz. </author> <title> Code Generation On the Fly: A Key for Portable Software. </title> <type> PhD thesis, </type> <institution> Institute for Computer Systems, ETH Zurich, </institution> <year> 1994. </year>
Reference-contexts: Unfortunately such schemes severely compromise performance since they run at least an order of magniture slower than comparable C programs. Another possibility is compilation on the fly <ref> [7] </ref> which provides portability by compiling the source code on the desired target machine immediately prior to execution. This technique requires the construction of a complex language environment. Moreover, neither interpreter-based systems nor compilation on the fly are explicitly designed to support fault tolerance.
Reference: [8] <author> James Gosling and Henry McGilton. </author> <title> The Java Language Environment, A White Paper. </title> <address> Mountain View, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: In this paper, we present a new efficient checkpointing and recovery mechanism that provides both portable program execution as well as fault tolerance in heterogeneous environments. Other approaches to portable fault tolerant computing have been investigated. Languages like Java <ref> [8] </ref> provide an interpreter-based approach to portability where the program byte code is first migrated to the client platform for local interpretation. Unfortunately such schemes severely compromise performance since they run at least an order of magniture slower than comparable C programs.
Reference: [9] <author> David B. Johnson. </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs. </title> <booktitle> In 12th Symposium on Reliable Distributed Systems, </booktitle> <address> Princeton, New Jersey, </address> <month> October </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs.
Reference: [10] <author> M. F. Kaashoek, R. Michiels, H. E. Bal, and A. S. Tanenbaum. </author> <title> Transparent Fault-Tolerance in Parallel Orca Programs. </title> <booktitle> In Symposium on Experiences with Distributed and Multiprocesor Systems, </booktitle> <pages> pages 297 311, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: In addition, projects described in <ref> [10, 12, 15, 18] </ref> concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. We restrict our discussion below to these optimizations. Previous work has focussed on the runtime and space efficiency objectives.
Reference: [11] <author> R. Koo and Sam Toueg. </author> <title> Checkpointing and Rollback-Recovery for Distributed Systems. </title> <journal> IEEE Transactions on Software Enigeering, </journal> <volume> SE-13 no. 1:2331, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs.
Reference: [12] <author> Chung-Chi Jim Li, Elliot M. Stewart, and W. Kent Fuchs. </author> <title> Compiler-assisted Full Checkpointing. </title> <journal> Software Practice and Experience, </journal> <volume> 24(10):871886, </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: In addition, projects described in <ref> [10, 12, 15, 18] </ref> concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. We restrict our discussion below to these optimizations. Previous work has focussed on the runtime and space efficiency objectives. <p> Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. We restrict our discussion below to these optimizations. Previous work has focussed on the runtime and space efficiency objectives. Li and Fuchs <ref> [12] </ref> were among the first to demonstrate the use of compilers to identify potential checkpoints in programs. At runtime, heuristics are used to determine which of these checkpoints will be activated.
Reference: [13] <author> Kai Li, J. F. Naughton, and J. S. Plank. </author> <title> Low-latency, concurrent checkpointing for parallel programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(8):874879, </volume> <month> August </month> <year> 1994. </year>
Reference-contexts: Previous work has focussed on the runtime and space efficiency objectives. Li and Fuchs [12] were among the first to demonstrate the use of compilers to identify potential checkpoints in programs. At runtime, heuristics are used to determine which of these checkpoints will be activated. Plank and others <ref> [13] </ref> propose latency hiding optimizations to reduce the cost of transformation of a checkpoint to stable storage.
Reference: [14] <author> B. Lyon. </author> <title> Sun External Data Representation Specification. Sun Microsystems, </title> <publisher> Inc., </publisher> <address> Mountain View, </address> <year> 1984. </year>
Reference-contexts: Since UCF-incompatible systems have to convert data types, UCF-incompatible systems pay a runtime penalty. The concept of UCF for portable checkpoints is similar to, but more flexible than, the external data representation (XDR) for remote pro cedure calls <ref> [14] </ref>. typedef struct - char c; double d; - cd_t; typedef struct - char c; int pad; double d; - cd_t; Alignment incompatabilities pose special problems on portability. Consider the example in Figure 2. The size of structure cd_t on the left, depends on the data representations and alignment.
Reference: [15] <author> N. Neves, M. Castro, and P. Guedes. </author> <title> A Checkpoint Protocol for an Entry-Consistent Shared Memory System. </title> <booktitle> In Proceedings of Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 121129, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: In addition, projects described in <ref> [10, 12, 15, 18] </ref> concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. We restrict our discussion below to these optimizations. Previous work has focussed on the runtime and space efficiency objectives.
Reference: [16] <author> James S. Plank. </author> <title> Efficient Checkpointing on MIMD Architectures. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs.
Reference: [17] <author> James S. Plank, Micah Beck, and Gerry Kingsley. Libckpt: </author> <title> Transparent checkpointing under Unix. </title> <booktitle> In USENIX Winter 1995 Technical Conference, </booktitle> <pages> pages 213233, </pages> <address> New Orleans, Louisiana, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: At runtime, heuristics are used to determine which of these checkpoints will be activated. Plank and others [13] propose latency hiding optimizations to reduce the cost of transformation of a checkpoint to stable storage. Elnozahy [6] and Plank <ref> [17] </ref> have proposed efficient implementation techniques that limit the overhead of checkpointing to within 2-5% of the the overall runtime of a program, when checkpoints are taken every two minutes. These techniques rely on efficient page-based bulk copying and hardware support to identify memory pages since the last checkpoint. <p> This scheme allows for identifying existential variables at compile time, accessing each variable individually rather than block-copying the stack, and avoids non-portable implementations based on setjmp/longjmp pairs, as for example libckpt <ref> [17] </ref>. In order to preserve the program's state while check-pointing, none of the program's statements may be executed. Therefore, function calls and returns for check-pointing require a modification of the original program. Source-to-source compilation transforms the code fragment given in Figure 3 into the code shown in Figure 4. <p> All experiments are performed with sequential check-pointing, where the program is halted to copy its state onto the shadow stack, then writes the checkpoint to disk, and, after completion, continues the program execution. Optimizations, such as proposed in <ref> [6, 17] </ref>, can be applied. 6.2.1 Heat Equation We use a Jacobi-type iteration to solve the heat diffusion problem on a 256 fi 256 grid, executing 1; 000 iterations. <p> The difference between the runtimes of the recovered experiments with UCF incompatible architectures and UCF compatible architectures gives the overhead of two conversions, one during checkpointing and the other during recovery. 6.2.2 Matrix Multiplication We instrumented the dense matrix-matrix multiplication implemented by Plank <ref> [17] </ref>. Table 6 summarizes the run-times and overheads for the checkpointed dense matrix-matrix multiplications of two dense 615 fi 615 matrices without failures. The performance of the i486 is dominated by its local disk performance.
Reference: [18] <author> Daniel J. Scales and Monica S. Lam. </author> <title> Transparent Fault Tolerance for Parallel Applications on Networks of Workstations. </title> <booktitle> In Usenix Winter Conference, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: In addition, projects described in <ref> [10, 12, 15, 18] </ref> concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. We restrict our discussion below to these optimizations. Previous work has focussed on the runtime and space efficiency objectives.
Reference: [19] <author> E. Seligman and A. Beguelin. </author> <title> High-Level Fault Tolerance in Distributed Programs. </title> <type> Technical Report CMU-CS-94-223, </type> <institution> Carnegie-Mellon University, </institution> <month> De-cember </month> <year> 1994. </year>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs. <p> These techniques rely on efficient page-based bulk copying and hardware support to identify memory pages since the last checkpoint. However, these optimizations are restricted to binary compatible hardware and operating systems. Thus, their applicability in a heterogeneous system is severely limited. Seligman and Beguelin <ref> [19] </ref> have developed check-pointing and restart algorithms in the context of the Dome C++ environment.
Reference: [20] <author> S. W. Smith, D. B. Johnson, and J. D. Tygar. </author> <title> Completely asynchronous optimistic recovery with minimal rollbacks. </title> <booktitle> In 25th Annual International Symposium on Fault-Tolerant Computing Digest of Papers, </booktitle> <address> Pasadena, CA, </address> <month> June </month> <year> 1995. </year> <journal> IEEE Computer Society. </journal> <volume> 19 </volume>
Reference-contexts: Our algorithm is described in detail in Section 5. In Section 6 we present experimental evidence that the loss of efficiency traded in for portability is acceptable. 2 Related Work Much of recent related work is in the area of check-pointing distributed programs, for example <ref> [2, 4, 5, 6, 9, 11, 16, 19, 20] </ref>. In addition, projects described in [10, 12, 15, 18] concentrate on shared or distributed 1 shared memory (DSM) systems. Many of the optimiza-tions discussed in the work cited above are applicable to checkpointing sequential programs.
Reference: [21] <author> Mark E. Staknis. </author> <title> Sheaved memory: Architectural support for state saving and restoration in paged systems. </title> <booktitle> In 3rd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96102, </pages> <address> Boston, Mas-sachusetts, </address> <month> April </month> <year> 1989. </year>
Reference-contexts: This technique requires the construction of a complex language environment. Moreover, neither interpreter-based systems nor compilation on the fly are explicitly designed to support fault tolerance. Providing hardware support for fault tolerance such as Sheaved Memory <ref> [21] </ref> or the Virtual Checkpoint Architecture [3] are not designed for portability either. The remainder of this paper is organized as follows. In Section 2, we describe related work in the area of check-pointing and recovery.
Reference: [22] <author> Volker Strumpen. </author> <title> Software-based communication latency hiding for commodity workstation networks. </title> <booktitle> To appear in International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: Once the checkpoint is available on the shadow stack, communication latency hiding can be used to transfer the checkpoint and continue the computation at the same time <ref> [22] </ref>. 2. Universal Checkpoint Format (UCF) specifies the layout of a portable checkpoint, such as header information and data segments, as well as the data representations and alignments used in the checkpoint. UCF data representations and alignments can be specified by the user.
Reference: [23] <author> Alan Wood. </author> <title> An analysis of client/server outage data. </title> <journal> IEEE, </journal> <pages> pages 295304, </pages> <year> 1995. </year> <month> 20 </month>
Reference-contexts: Due to the difficulties associated with programming such systems today, local area networks (LANs) are still used heavily for long running simulations. Even on such systems, failures occur frequently <ref> [23] </ref> due to a variety of reasons including network failures, processor failures, and even administration downtimes. Thus fault tolerance is fast becoming an essential feature for networked programming systems. Large distributed systems are inherently heterogeneous in nature.
References-found: 23

