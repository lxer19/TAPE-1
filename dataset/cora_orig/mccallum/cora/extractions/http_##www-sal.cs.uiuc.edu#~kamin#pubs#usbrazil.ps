URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/usbrazil.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Title: Research on Domain-specific Embedded Languages and Program Generators  
Author: Samuel N. Kamin 
Address: Champaign, IL, USA  
Affiliation: Computer Science Department University of Illinois at Urbana-Champaign  
Web: URL: http://www.elsevier.nl/locate/entcs/volume14.html  
Note: Electronic Notes in Theoretical Computer Science 14 (1998)  20 pages  
Abstract: Embedding is the process of implementing a language by defining functions in an existing "host" language; the host language with these added functions is the new language. As a consequence, the new language comes equipped with all the features of the host language, with no additional work on the part of the language designer. Embedding works particularly well when the host language is a functional language. We describe several examples of embedded languages. The first is a language for specifying simple pictures. The others are program generators, that is, languages used to specify programs in other languages. In all of these examples, the host language is Standard ML; in the program generating languages, the target language is C++. The power obtained from the host language is the main emphasis of our presentation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A. V., R. Sethi and J. D. Ullman, </author> <booktitle> "Compilers: Principles, Techniques, and Tools," </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: We will present all the code for this example, and not for the more elaborate examples to follow. The basic idea of top-down parsing <ref> [1] </ref> is this: We are at all times attempting to find a substring of the input that can be derived from a particular non-terminal. <p> lab)` (* ::= : Name -&gt; RHS -&gt; CFunction *) infix 1 ::= ; fun (v:Name) ::= (rhs:RHS) = 14 Kamin %`int parse^v () - int pos = current; ^(rhs "L1000") return true; L1000: current = pos; return false; -` ; 5 LL (1) parser generator An LL (1) parser <ref> [1] </ref> operates by keeping a (statically generated) table M which maps non-terminals and tokens to productions. <p> contains nothing analogous to the programming facilities whose use we illustrated in the previous section. (Those examples need some minor changes to work with the current set of combinators.) 6 Abstract syntax tree generation Language processors usually begin their work by parsing their input and constructing an abstract syntax tree <ref> [1] </ref>, basically a simplified version of the parse tree. Abstract syntax trees (AST's) are trees whose nodes are labelled with abstract syntax operators.
Reference: [2] <author> Carlson, W. E., P. Hudak and M. P. Jones, </author> <title> An experiment using Haskell to prototype "Geometric Region Servers" for navy command and control, </title> <institution> Research Report YALEU/DCS/RR-1031, Yale Univ. C. S. Dept., </institution> <month> May </month> <year> 1994. </year>
Reference: [3] <author> Donnelly, C. and R. Stallman, </author> <title> "The Bison Manual: Using the YACC-compatible Parser Generator," Free Software Foundation, </title> <year> 1995. </year>
Reference-contexts: As a point of comparison, the Bison LR parser generator <ref> [3] </ref> is about 7000 lines of C. Granted, the LALR (1) construction that Bison uses is more complicated than the LL (1) construction used here, and Bison includes some additional facilities such as ambiguity resolution.
Reference: [4] <author> Elliott, C., </author> <title> Modeling interactive 3D and multimedia animation with an embedded language, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa 19 Kamin Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> pp. 285-296. </pages>
Reference: [5] <editor> Hudak, P., S. Peyton Jones and P. Wadler (eds.). </editor> <title> Report on the Programming Language Haskell (Version 1.2), </title> <journal> ACM SIGPLAN Notices 27(5), </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: Furthermore, they should not only simplify the construction of language processors, but should aid in the design of high-quality languages. To many programming language researchers, the highest quality languages are the functional languages, such as Haskell <ref> [5] </ref> and Standard ML [16]. As it happens, there is a simple way to construct languages for specific application areas so that these languages will, without fail, be well-designed functional languages: embedding [2,4,7,10,12].
Reference: [6] <author> Hudak, P., </author> <title> Building domain-specific embedded languages, </title> <journal> Computing Surveys, 28A(4). </journal>
Reference: [7] <author> Hudak, Paul, Tom Makucevich, Syam Gadde and Bo Whong, </author> <title> Haskore music notation: An algebra of music, </title> <journal> J. Func. Prog. </journal> <volume> 6(3) (1996), </volume> <pages> pp. 465-483. </pages>
Reference: [8] <author> Hutton, G., </author> <title> Higher-order functions for parsing, </title> <journal> J. Func. Prog. </journal> <volume> 2(3) (1992), </volume> <pages> pp. 323-343. </pages>
Reference: [9] <author> Hutton, G. and E. Meijer, </author> <title> A Haskell library of monadic parser combinators, </title> <note> Web page at www.cs.nott.ac.uk/Department/Staff/gmh/pearl.hs, April, </note> <year> 1997. </year>
Reference: [10] <author> Kamin, S., </author> <title> The Challenge of Language Technology Transfer, </title> <journal> ACM Computing Surveys 28A(4) (1996). </journal>
Reference: [11] <author> Kamin, S., FPIC documentation, </author> <note> Web page at www-sal.cs.uiuc.edu/ ~kamin/fpic/. </note>
Reference: [12] <author> Kamin, S. and D. Hyatt, </author> <title> A special-purpose language for picture-drawing, </title> <booktitle> Proc. USENIX Conf. on Domain-Specific Languages, </booktitle> <address> Santa Barbara, </address> <month> Oct. </month> <year> 1997, </year> <pages> pp. 297-310. </pages>
Reference-contexts: These issues, which are the topics of current research, are discussed in the conclusions. The paper assumes knowledge of Standard ML. 3 Kamin 2 FPIC FPIC <ref> [12] </ref> is a language for drawing simple pictures. It is inspired by the Unix utility pic [13], a widely used preprocessor for troff. FPIC attempts to preserve the flavor of pic's syntax, though it differs in detail.
Reference: [13] <author> Kernighan, B. W., </author> <title> PIC: A crude graphics language for typesetting, </title> <institution> Bell Laboratory, </institution> <year> 1981. </year>
Reference-contexts: This paper describes several experiments in language implementation by embedding. The first is a language for describing simple pictures, inspired by a well-known domain-specific language, the pic preprocessor for troff <ref> [13] </ref>. The remainder are all examples of program-generating languages. This is a category of languages in which programs are actually specifications for programs in other languages. Perhaps the best-known examples are the parser generators, such as yacc [14]. <p> These issues, which are the topics of current research, are discussed in the conclusions. The paper assumes knowledge of Standard ML. 3 Kamin 2 FPIC FPIC [12] is a language for drawing simple pictures. It is inspired by the Unix utility pic <ref> [13] </ref>, a widely used preprocessor for troff. FPIC attempts to preserve the flavor of pic's syntax, though it differs in detail. FPIC is embedded in Standard ML and consists of approximately 1200 lines of ML.
Reference: [14] <author> Levine, John R., Tony Mason and Doug Brown, </author> <title> "Lex & Yacc," 2nd Ed. </title> <publisher> O'Reilly & Associates, </publisher> <year> 1992. </year>
Reference-contexts: The remainder are all examples of program-generating languages. This is a category of languages in which programs are actually specifications for programs in other languages. Perhaps the best-known examples are the parser generators, such as yacc <ref> [14] </ref>. From our point of view, these are just languages produced by embedding, that is, by adding program-generating functions to a functional language. <p> A well-known example is the parser generator yacc <ref> [14] </ref>: context-free grammar yacc C program In line with our philosophy of language implementation by embedding, we propose to create program generators by adding program-manipulating combinators to Standard ML.
Reference: [15] <author> Liaw, Andy and Dick Crawford, </author> <note> "gnuplot 3.5 User's Guide," Available by anonymous ftp at picard.tamu.edu in directory pub/gnuplot. </note>
Reference-contexts: For example, the function-plotting operations defined below | plot and xyplot | could easily be supplemented with operations to read function values from a file, to draw a grid, to include a legend, and so on, forming a plotting library comparable to, but far more powerful than, say, gnuplot <ref> [15] </ref>. (* Draw two squares connected by a horizontal arrow *) val sq = square 1.0; val boxes = sq hseq harrow 0.5 1.0 hseq sq; boxes; (* Use ML's foldr operation to draw several copies of boxes *) foldr (op vseq) empty [boxes, boxes, boxes]; (* Draw a regular polygon
Reference: [16] <author> Milner, Robin, Mads Tofte and Robert Harper, </author> <title> "The Definition of Standard ML," </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Furthermore, they should not only simplify the construction of language processors, but should aid in the design of high-quality languages. To many programming language researchers, the highest quality languages are the functional languages, such as Haskell [5] and Standard ML <ref> [16] </ref>. As it happens, there is a simple way to construct languages for specific application areas so that these languages will, without fail, be well-designed functional languages: embedding [2,4,7,10,12].
Reference: [17] <institution> Standard ML of New Jersey User's Guide, Available at cm.bell-labs.com/ cm/cs/what/smlnj/index.html, </institution> <year> 1997. </year>
Reference-contexts: Formalizing this lookahead leads eventually to LL (1) parsing, which we will implement separately. The idea here is to give a simple formalization of recursive descent so that we can illustrate the program generation method. 4 The feature is more general than what we are presenting; see <ref> [17] </ref> for details. 13 Kamin %`... ^x ...` for "..." ^ x ^ "..." That is, within anti-quotation brackets (%` and `), an anti-quoted expression (surrounded by ^( and )) is evaluated (to a string) and spliced in.
Reference: [18] <author> Taha, Walid and Tim Sheard, </author> <title> Multi-stage programming with explicit annotations, </title> <booktitle> Proc. ACM SIGPLAN Symp. on Partial Evaluation and Semantics-Based Program Manipulation (PEPM '97), </booktitle> <address> Amsterdam, </address> <month> June 12-13, </month> <year> 1997, </year> <booktitle> SIGPLAN Notices 32(12) (1997), </booktitle> <pages> pp. 203-217. 20 </pages>
Reference-contexts: The program-generating languages suggest an entirely new set of domain-specific analyses, namely analyses of the program that is to be generated. For instance, one would like to be able to ensure the syntactic and type correctness of generated programs a priori, before generating any actual programs. (The MetaML language <ref> [18] </ref> does just this for program generators from ML to ML, written in a certain style.) As things stand, these analyses are done by the C++ compiler, but building them into the generator would give earlier feedback; furthermore, the generator could perform some optimizations, based on its knowledge of the programs
References-found: 18

