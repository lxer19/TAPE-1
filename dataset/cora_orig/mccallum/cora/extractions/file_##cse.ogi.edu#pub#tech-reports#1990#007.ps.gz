URL: file://cse.ogi.edu/pub/tech-reports/1990/007.ps.gz
Refering-URL: http://www.cse.ogi.edu/Sparse/sparse.papers.html
Root-URL: http://www.cse.ogi.edu
Email: mwolfe@cse.ogi.edu  
Title: Data Dependence and Program Restructuring  
Author: Michael Wolfe 
Keyword: data dependence, direction vector, restructuring, loop interchanging, loop reversal, loop skewing, loop rotation, sectioning, strip mining  
Address: 19600 NW von Neumann Drive Beaverton, OR 97006  
Affiliation: Oregon Graduate Institute of Science and Technology  
Abstract: 503-690-1153 Abstract Data dependence concepts are reviewed, concentrating on and extending previous work on direction vectors. A bit vector representation of direction vectors is discussed. Various program restructuring transformations, such as loop circulation (a form of loop interchanging), reversal, skewing, sectioning (strip mining), combing and rotation, are discussed in terms of their effects on the execution of the program, the required dependence tests for legality, and the effects of each transformation on the dependence graph. Simple bit vector operations for the dependence tests and modifying the direction vector are shown. Finally, a simple method to interchange complex convex loop limits is given, which is useful when several loop restructuring operations are being applied in sequence. 
Abstract-found: 1
Intro-found: 1
Reference: [All83] <author> J. R. Allen, </author> <title> Dependence Analysis for Subscripted Variables and Its Application to Program Transformations, </title> <type> Ph.D. Thesis, </type> <institution> Rice University, Houston, TX, </institution> <month> April, </month> <year> 1983. </year>
Reference: [AlK84] <author> J. R. Allen and K. Kennedy, </author> <title> Automatic Loop Interchange, </title> <booktitle> in Proc. of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <address> New York, </address> <month> June </month> <year> 1984, </year> <pages> 233-246. </pages>
Reference: [AlK87] <author> J. R. Allen and K. Kennedy, </author> <title> Automatic Translation of Fortran Programs to Vector Form, </title> <journal> ACM Transactions on Programming Languages and Systems 9, </journal> <month> 4 (October </month> <year> 1987), </year> <pages> 491-542. </pages>
Reference-contexts: Another popular data dependence annotation saves only the nest level of the outermost loop with a non (=) direction (non-zero distance) <ref> [AlK87] </ref>. The dependence relation for Program 3 has a zero distance in the outer loop, but a non-zero distance in the inner loop, so this dependence relation is carried by the inner j loop. <p> This is written S 1P d (=,P=)P S 2P or S 1P d (0,P0)P S 2P . Since it is carried by neither of the loops, it is called a loop independent dependence <ref> [AlK87] </ref>.
Reference: [Ban88] <author> U. Banerjee, </author> <title> Dependence Analysis for Supercomputing, </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1988. </year>
Reference-contexts: A common method to represent this is to save a vector of the signs of the dependence distances, called a direction vector. Each direction vector element will be one of -+,P0,P- <ref> [Ban88] </ref>; for historical reasons, these are usually written -&lt;,P=,P&gt;- [Wol78,OWoB87,OWol89]. In Program 4, the direction vector associated with the dependence relation is S 1P d (&lt;,P&lt;)P S 1P ; in Program 3, the dependence relation would be written S 1P d (=,P&lt;)P S 1P .
Reference: [Ban90] <author> U. Banerjee, </author> <title> A Theory of Loop Permutations, in Languages and Compilers for Parallel Computing, </title> <editor> D. Gelernter, A. Nicolau and D. Padua (ed.), </editor> <publisher> Pitman, </publisher> <address> London, </address> <year> 1990, </year> <pages> 54-74. </pages>
Reference-contexts: Loop interchanging is well known as a method to enhance parallelism and to improve memory hierarchy performance [AlK84,OWol82]; here we discuss a slightly more powerful formulation than the usual pairwise interchanging, namely loop circulation (interchanging a given loop inwards or outwards over several loops in a single step) <ref> [Ban90] </ref>. Loop skewing is a simple transformation that allows a compiler to implement the wavefront method, even in multiple dimensions [Wol86b]. Loop reversal was first implemented in the compilers for the Texas Instruments' ASC [Wed75]. Loop rotation has been introduced as a method to map algorithms efficiently onto multiprocessors [Wol90]. <p> A more general form of loop interchanging, called a circulation in <ref> [Ban90] </ref>, can interchange loop i kP inwards to inside any loop (up to i nP ) or outwards to outside any enclosing loop (down to i 1P ) in a single step; we will call these in-circulation and out-circulation. <p> Yet, in-circulation is legal in this case <ref> [Ban90] </ref>.
Reference: [BuC86] <author> M. Burke and R. Cytron, </author> <title> Interprocedural Dependence Analysis and Parallelization, </title> <booktitle> in Proc. of the SIGPLAN 86 Symp. on Compiler Construction, </booktitle> <address> Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986, </year> <pages> 162-175. </pages>
Reference-contexts: For example: (&lt;,P&lt;) + (&lt;,P=) + (=,P&lt;) fi (,P) (&lt;,P&lt;) + (&lt;,P=) + (=,P&lt;) + (=,P=) fi (,P,P==) Using bit vectors to represent dependence direction vectors does not preclude the use of efficient techniques to build the direction vector, such as the dependence hierarchy introduced in <ref> [BuC86] </ref>. We will show how to manipulate the bit vector representation of dependence directions for each program transformation. For instance, the test to see whether the iterations of a loop at nest level k can be executed in parallel is that the loop carries no dependence relations.
Reference: [KKP81] <author> D. J. Kuck, R. H. Kuhn, D. A. Padua, B. Leasure and M. Wolfe, </author> <title> Dependence Graphs and Compiler Optimizations, </title> <booktitle> in Conf. Record of the 8th ACM Symp. on the Principles of Programming Languages, </booktitle> <address> Williamsburg, VA, </address> <year> 1981, </year> <pages> 207-218. </pages>
Reference: [Lov77] <author> D. Loveman, </author> <title> Program Improvement by Source-to-Source Transformation, </title> <editor> J. </editor> <booktitle> of the ACM 20, </booktitle> <month> 1 (January </month> <year> 1977), </year> <pages> 121-145. </pages>
Reference: [Wed75] <author> D. Wedel, </author> <title> Fortran for the Texas Instruments ASC System, </title> <journal> SIGPLAN Notices 10, </journal> <month> 3 (March </month> <year> 1975), </year> <pages> 119-132. </pages>
Reference-contexts: Loop skewing is a simple transformation that allows a compiler to implement the wavefront method, even in multiple dimensions [Wol86b]. Loop reversal was first implemented in the compilers for the Texas Instruments' ASC <ref> [Wed75] </ref>. Loop rotation has been introduced as a method to map algorithms efficiently onto multiprocessors [Wol90]. Sectioning is used to divide a loop into fixed size sections for vector processing, or into a fixed number of sections for concurrent execution [All83,OLov77]; combing is a variant of sectioning.
Reference: [Wol78] <author> M. Wolfe, </author> <title> Techniques for Improving the Inherent Parallelism in Programs, </title> <institution> UIUCDCS-R-78-929, Univ. of Illinois, </institution> <month> July </month> <year> 1978. </year>
Reference: [Wol82] <author> M. Wolfe, </author> <title> Optimizing Supercompilers for Supercomputers, </title> <type> Ph.D. Thesis, </type> <institution> Univ. of Illinois UIUCDCS-82-1105, Urbana, IL, </institution> <month> October </month> <year> 1982. </year> <pages> (UMI 83-03027). </pages>
Reference: [Wol86a] <author> M. Wolfe, </author> <title> Advanced Loop Interchanging, </title> <booktitle> in Proc. of the 1986 Intl Conf. on Parallel Processing, </booktitle> <editor> K. Hwang, S. M. Jacobs and E. E. Swartzlander (ed.), </editor> <address> St. Charles, IL, </address> <month> August 19-22, </month> <year> 1986, </year> <pages> 536-543. </pages>
Reference-contexts: Now consider what happens when the skewed loops are interchanged <ref> [Wol86a] </ref>: for j = 2+2 to N-1+N-1 A (i,j-i) = A (i-1,j-i) + A (i,j-i-1) endfor endfor Now the dependence direction vectors are (&lt;,P&lt;) and (&lt;,P=), meaning that the outer j loop carries both dependence relations.
Reference: [Wol86b] <author> M. Wolfe, </author> <title> Loop Skewing: The Wavefront Method Revisited, </title> <booktitle> Intl J. Parallel Programming 15, </booktitle> <month> 4 (August </month> <year> 1986), </year> <pages> 279-294. </pages>
Reference-contexts: Loop skewing is a simple transformation that allows a compiler to implement the wavefront method, even in multiple dimensions <ref> [Wol86b] </ref>. Loop reversal was first implemented in the compilers for the Texas Instruments' ASC [Wed75]. Loop rotation has been introduced as a method to map algorithms efficiently onto multiprocessors [Wol90]. <p> Notice that since we are allowing the order of reductions to change, reduction dependences do not prevent interchanging. The reduction loops in Program 5, for instance, could be interchanged in our scheme. Loop Skewing. Loop skewing was introduced as a alternate derivation of the wavefront method <ref> [Wol86b] </ref>.
Reference: [WoB87] <author> M. Wolfe and U. Banerjee, </author> <title> Data Dependence and Its Application to Parallel Processing, </title> <booktitle> Intl Journal of Parallel Programming 16, </booktitle> <month> 2 (April </month> <year> 1987), </year> <pages> 137-178. </pages>
Reference: [Wol89] <author> M. Wolfe, </author> <title> Optimizing Supercompilers for Supercomputers, </title> <publisher> Pitman Publishing, </publisher> <address> London, </address> <year> 1989. </year>
Reference-contexts: In previous work, we discussed the potential of using a bit vector to represent a direction vector, with one bit for each direction in each loop <ref> [Wol89] </ref>. With the reduction direction, a direction vector would use 4n bits to represent a dependence relation between two statements in n nested loops; if n is limited to a small number (like 7 or 15), then each direction vector can be stored in a single 32- or 64-bit word. <p> As mentioned in <ref> [Wol89] </ref>, taking the union of multiple directions ('ORing' the bit vectors) can save space but with a loss of precision. For instance, ORing the bit vectors for the direction vectors (&lt;,P&gt;) and (=,P=) gives the combined bit vector (,P). <p> However the spurious (=,P=) does, since it will prevent reordering of code within the body of the loop, even within a single iteration. Thus, as in <ref> [Wol89] </ref>, we add one additional bit in the direction vector, called the (==) bit, which will be set when the combined direction vector includes the "all-equals" case.
Reference: [Wol90] <author> M. Wolfe, </author> <title> Loop Rotation, in Languages and Compilers for Parallel Computing, </title> <editor> D. Gelernter, A. Nicolau and D. Padua (ed.), </editor> <publisher> Pitman, </publisher> <address> London, </address> <year> 1990, </year> <pages> 531-553. </pages> <note> This work was supported by NSF Grant CCR-8906909 and DARPA Grant MDA972-88-J-1004. 21 </note>
Reference-contexts: Loop skewing is a simple transformation that allows a compiler to implement the wavefront method, even in multiple dimensions [Wol86b]. Loop reversal was first implemented in the compilers for the Texas Instruments' ASC [Wed75]. Loop rotation has been introduced as a method to map algorithms efficiently onto multiprocessors <ref> [Wol90] </ref>. Sectioning is used to divide a loop into fixed size sections for vector processing, or into a fixed number of sections for concurrent execution [All83,OLov77]; combing is a variant of sectioning. <p> Loop Rotation. Loop rotation is most easily defined when the loops are "normalized", that is have a lower limit of zero and increment of one; unnormalized loops can always be normalized by a simple program transformation if desired [AlK87,OKKP81]. Rotation is much like skewing <ref> [Wol90] </ref>; in the two-nested case below: for i = 0 to N-1 computation (i,j) endfor endfor rotating the j loop with respect to the i loop by a factor of +1 changes the computation: for i = 0 to N-1 computation (i,(j-i)mod M) endfor endfor while rotation by a factor of
References-found: 16

