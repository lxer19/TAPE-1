URL: http://www-acs.ucsd.edu/offerings/doc/unixprog.ps
Refering-URL: http://www-acs.ucsd.edu/offerings/doc/HTML/unixprog,d.html
Root-URL: http://www.cs.ucsd.edu
Title: UNIX Programming Second Edition  
Author: Brian W. Kernighan Dennis M. Ritchie 
Note: There is also an appendix which describes the standard I/O library in detail.  
Abstract: This paper is an introduction to programming on the UNIX system. The emphasis is on how to write programs that interface to the operating system, either directly or through the standard I/O library. The topics discussed include g handling command arguments g rudimentary I/O; the standard input and output g the standard I/O library; file system access g low-level I/O: open, read, write, close, seek g processes: exec, fork, pipes g signals interrupts, etc. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. L. Thompson and D. M. Ritchie, </author> <title> The UNIX Programmer's Manual, </title> <institution> Bell Laboratories, </institution> <year> 1978. </year>
Reference-contexts: This includes programs that use files by name, that use pipes, that invoke other commands as they run, or that attempt to catch interrupts and other signals during execution. The document collects material which is scattered throughout several sections of The UNIX Programmer's Manual <ref> [1] </ref> for Version 7 UNIX. There is no attempt to be complete; only generally useful material is dealt with. It is assumed that you will be programming in C, so you must be able to read the language roughly up to the level of The C Programming Language [2]. <p> The program starts by printing argv <ref> [1] </ref> and loops until it has printed them all. The argument count and the arguments are parameters to main. If you want to keep them around so other routines can get at them, you must copy them to external variables. 2.2. <p> 0 #define BUFSIZE 512 #define PMODE 0644 /* RW for owner, R for group, others */ main (argc, argv) /* cp: copy f1 to f2 */ int argc; char *argv []; - char buf [BUFSIZE]; if (argc != 3) error ("Usage: cp from to", NULL); if ((f1 = open (argv <ref> [1] </ref>, 0)) == -1) error ("cp: can't open %s", argv [1]); if ((f2 = creat (argv [2], PMODE)) == -1) error ("cp: can't create %s", argv [2]); while ((n = read (f1, buf, BUFSIZE)) &gt; 0) if (write (f2, buf, n) != n) error ("cp: write error", NULL); exit (0); - <p> owner, R for group, others */ main (argc, argv) /* cp: copy f1 to f2 */ int argc; char *argv []; - char buf [BUFSIZE]; if (argc != 3) error ("Usage: cp from to", NULL); if ((f1 = open (argv <ref> [1] </ref>, 0)) == -1) error ("cp: can't open %s", argv [1]); if ((f2 = creat (argv [2], PMODE)) == -1) error ("cp: can't create %s", argv [2]); while ((n = read (f1, buf, BUFSIZE)) &gt; 0) if (write (f2, buf, n) != n) error ("cp: write error", NULL); exit (0); - error (s1, s2) /* print error message and die */ <p> writing, two file descriptors are returned; the actual usage is like this: int fd [2]; stat = pipe (fd); if (stat == -1) /* there was an error ... */ fd is an array of two file descriptors, where fd [0] is the read side of the pipe and fd <ref> [1] </ref> is for writing. These may be used in read, write and close calls just like any other file descriptors.
Reference: [2] <author> B. W. Kernighan and D. M. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1978. </year>
Reference-contexts: There is no attempt to be complete; only generally useful material is dealt with. It is assumed that you will be programming in C, so you must be able to read the language roughly up to the level of The C Programming Language <ref> [2] </ref>. Some of the material in sections 2 through 4 is based on topics covered more carefully there. You should also be familiar with UNIX itself at least to the level of UNIX for Beginners [3]. 2. BASICS 2.1. <p> main (argc, argv) /* cp: copy f1 to f2 */ int argc; char *argv []; - char buf [BUFSIZE]; if (argc != 3) error ("Usage: cp from to", NULL); if ((f1 = open (argv [1], 0)) == -1) error ("cp: can't open %s", argv [1]); if ((f2 = creat (argv <ref> [2] </ref>, PMODE)) == -1) error ("cp: can't create %s", argv [2]); while ((n = read (f1, buf, BUFSIZE)) &gt; 0) if (write (f2, buf, n) != n) error ("cp: write error", NULL); exit (0); - error (s1, s2) /* print error message and die */ char *s1, *s2; - printf (s1, <p> int argc; char *argv []; - char buf [BUFSIZE]; if (argc != 3) error ("Usage: cp from to", NULL); if ((f1 = open (argv [1], 0)) == -1) error ("cp: can't open %s", argv [1]); if ((f2 = creat (argv <ref> [2] </ref>, PMODE)) == -1) error ("cp: can't create %s", argv [2]); while ((n = read (f1, buf, BUFSIZE)) &gt; 0) if (write (f2, buf, n) != n) error ("cp: write error", NULL); exit (0); - error (s1, s2) /* print error message and die */ char *s1, *s2; - printf (s1, s2); printf (""n"); exit (1); - As we said earlier, <p> The system call pipe creates a pipe. Since a pipe is used for both reading and writing, two file descriptors are returned; the actual usage is like this: int fd <ref> [2] </ref>; stat = pipe (fd); if (stat == -1) /* there was an error ... */ fd is an array of two file descriptors, where fd [0] is the read side of the pipe and fd [1] is for writing.
Reference: [3] <author> B. W. Kernighan, </author> <title> ``UNIX for Beginners Second Edition.'' </title> <institution> Bell Laboratories, </institution> <year> 1978. </year> <note> PS2:3-18 UNIX Programming Second Edition </note>
Reference-contexts: Some of the material in sections 2 through 4 is based on topics covered more carefully there. You should also be familiar with UNIX itself at least to the level of UNIX for Beginners <ref> [3] </ref>. 2. BASICS 2.1. Program Arguments When a C program is run as a command, the arguments on the command line are made available to the function main as an argument count argc and an array argv of pointers to character strings that contain the arguments.
References-found: 3

