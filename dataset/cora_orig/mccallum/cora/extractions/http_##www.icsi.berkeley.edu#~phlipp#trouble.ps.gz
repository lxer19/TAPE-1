URL: http://www.icsi.berkeley.edu/~phlipp/trouble.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~phlipp/phlipp.publ.html
Root-URL: http://www.icsi.berkeley.edu
Title: Is Java ready for computational science?  
Author: Michael Philippsen 
Address: PO-Box 6980, 76128 Karlsruhe, Germany  
Affiliation: Computer Science Dept., University of Karlsruhe,  
Abstract: Tel: +49/721/608-4067, Fax: +49/721/7343, eMail: phlipp@ira.uka.de This paper has been submitted to Euro-PDS'98, The Second European Parallel and Distributed Systems Conference, July 1998, Vienna, Austria. Abstract This paper provides quantitative and qualitative arguments that help to decide whether Java is ready for computational science. Current shortcomings of Java as well as appropriate countermeasures are discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Although such a design is preferable from the software engineer's point of view, C/C++ people claim that it results in poor performance. Due to Java's relative simplicity, an agressive optimizer can effectively inline index computations and can sucessfully try to eliminate invariant expressions <ref> [1] </ref>. We expect that much of the performance loss encountered in C/C++ implementations that use the additional layer of abstraction, can be compensated in Java by a clever optimizer. In conclusion, Java's array mechanisms coupled with some library support for multi-dimensional arrays will not prevent sufficient performance.
Reference: [2] <author> Z. Budimlic and K. Kennedy. </author> <title> Optimizing Java: </title> <journal> Theory and practice. Concurrency: Practice and Experience, </journal> <month> June </month> <year> 1997. </year>
Reference-contexts: Therefore, traditional optimization techniques, as for example code and object inlining, dispatch optimization, register allocation, etc., can be applied more often and presumably with more effect. As Budimlic and Kennedy stress in <ref> [2] </ref> the only serious difficulty is that Java's elaborate exception framework interferes with some optimization.
Reference: [3] <author> J. Clearbout and B. Biondi. </author> <title> Geophysics in object-oriented numerics (GOON): Informal conference. In Stanford Exploration Project Report No. </title> <type> 93. </type> <month> October </month> <year> 1996. </year> <note> http://sepwww.stanford.edu/sep. </note>
Reference-contexts: The first benchmark is the Sieve of Eratosthenes for finding prime numbers. The Sieve is implemented in all three languages and is timed on a single workstation. The second benchmark targets large-scale geophysical algorithms, that have been studied in [6]. We cooperated with the Stanford Exploration Project <ref> [3] </ref> in implementing parallel versions of these algorithms in all three languages. Runtime were measured on an IBM SP/2 (distributed memory parallel architecture) and on a SGI PowerChallenge (shared memory parallel architecture). 2.1 Sieve Performance The Sieve was run on an IBM RS/6000 workstation.
Reference: [4] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: The method found is of type t : 2 (t; t), where both t 1 and t 2 either are equal to t or can be widened to t without loss of precision. See <ref> [4] </ref> for the details. Since the Java compiler handles primitive type infix operators in the same way as regular methods, the 4 straightforward approach is to simply add new meth-ods of type t : 2 (t; t) to the scope.
Reference: [5] <author> IBM. </author> <title> High performance compiler for Java. </title> <address> http://www.alphaWorks.ibm.com. </address>
Reference-contexts: Array boundary checks have been introduced into Java because of applet security reasons. They are a valued instrument during debugging, but are often blamed for slowing down performance. For RS/6000 workstations, IBM has an alpha version of a Java compiler, called High Performance Compiler for Java (HPJ) <ref> [5] </ref> that compiles Java code to native code. HPJ has an option to switch off array boundary checks, which we used in our measurements. <p> Later releases, including JDK 1.2beta, increased performance on Solaris and Wintel platforms and are likely to show similar improvements on the parallel hardware platforms as well. Compilers producing optimized native code like IBM's High Performance Java Compiler <ref> [5] </ref> are on the horizon; they will outperform C++ compilers in a few years. When comparing Java to C++ from the compiler writer's perspective, it is obvious that Java's control and data flow is much easier to analyze.
Reference: [6] <author> Matthias Jacob. </author> <title> Implementing Large-Scale Geophysical Algorithms with Java: A Feasibility Study. </title> <type> Master's thesis, </type> <institution> Karlsruhe University, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: The first benchmark is the Sieve of Eratosthenes for finding prime numbers. The Sieve is implemented in all three languages and is timed on a single workstation. The second benchmark targets large-scale geophysical algorithms, that have been studied in <ref> [6] </ref>. We cooperated with the Stanford Exploration Project [3] in implementing parallel versions of these algorithms in all three languages. <p> Since it can take tera bytes of input data to cover a reasonable area, the performance of these algorithms is crucial. The geophysics and the details of the benchmarks can be found in <ref> [6] </ref>. We have implemented these algorithms in a Java environment, in HPF, and in Fortran90, and bench-marked the programs on up to 16 nodes of an SGI PowerChallenge shared memory computer and on 16 nodes of an IBM SP/2 distributed memory parallel machine.
Reference: [7] <author> JavaParty. </author> <note> http://wwwipd.ira.uka.de/JavaParty. </note>
Reference-contexts: On the SGI, we used SGI's standard For-tran90 compiler; on the IBM SP/2, version 2.2 of the Portland Group High Performance Fortran compiler was used. The Java implementation on both machines uses the JavaParty <ref> [7] </ref> distributed runtime and communication system, which itself is written in Java. On both platforms, Java's performance is not attained by compiled and optimized native code but instead relies on interpreters with just-in-time compilation features. 1 The above graph shows the results on the SGI Pow-erChallenge.
Reference: [8] <author> William Kahan. </author> <title> The Baleful Effect of Computer Languages and Benchmarks upon Applied Mathematics, Physics and Chemistry. </title> <booktitle> The John von Neumann Lecture at the 45th Annual Meeting of SIAM, </booktitle> <institution> Stanford University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: For the division of two integers it is not well defined in C/C++ whether this operation will round towards zero or towards -infinity, when either or both operands are negative. In Java, integer division rounds towards zero (exception for overflow conditions). Floating Point Promotion Kahan pointed out in <ref> [8] </ref> that there are cases where for a given floating point expression Java's arithmetic computes results that are different from Fortran's, although both languages are based on the IEEE 754 standard.
Reference: [9] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Proc. 24th ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Another problem is that it is undesirable to change the byte-code or to alter Java's approach to separate compilation. Several solutions have been proposed, the Pizza type system is one of those <ref> [9] </ref>, and there are rumors that generic classes are strong candidates for a future extension of Java. Compared to complex numbers, the demand for generic classes is not restricted to computational scientists. In the meantime, Pizza's generic classes can be used. <p> Compared to complex numbers, the demand for generic classes is not restricted to computational scientists. In the meantime, Pizza's generic classes can be used. The Pizza system <ref> [9, 12] </ref> provides a source-to-source transformation of Java with generic classes into regular Java. 3.3 Operator Overloading When complex numbers are introduced into Java, the corresponding infix operator will be introduced as well. This section discusses Java's lack of operator overloading for reference types.
Reference: [10] <author> Stephen M. Omohundro. </author> <title> The Sather programming language. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 18(11) </volume> <pages> 42-48, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Similarly, array indexing or pointer dereferencing are unlikely to ever be candidates for overloading, although admittedly, there might be some rare situations where this type of overloading actually can improve code quality. The following middle course, that is similar to the approach used in the Sather language <ref> [10, 11] </ref>, might be reasonable and sufficiently simple. Without support for generic classes, it is difficult to add overloading of infix operators to Java without breaking Java's general design principles.
Reference: [11] <author> Stephen M. Omohundro and David Stoutamire. </author> <title> The Sather 1.1 specification. </title> <type> Technical Report TR-96-012, </type> <institution> International Computer Science Institute, Berkeley, </institution> <year> 1996. </year>
Reference-contexts: Similarly, array indexing or pointer dereferencing are unlikely to ever be candidates for overloading, although admittedly, there might be some rare situations where this type of overloading actually can improve code quality. The following middle course, that is similar to the approach used in the Sather language <ref> [10, 11] </ref>, might be reasonable and sufficiently simple. Without support for generic classes, it is difficult to add overloading of infix operators to Java without breaking Java's general design principles.
Reference: [12] <author> Pizza. </author> <note> http://www.cis.unisa.edu.au/~pizza. </note>
Reference-contexts: Compared to complex numbers, the demand for generic classes is not restricted to computational scientists. In the meantime, Pizza's generic classes can be used. The Pizza system <ref> [9, 12] </ref> provides a source-to-source transformation of Java with generic classes into regular Java. 3.3 Operator Overloading When complex numbers are introduced into Java, the corresponding infix operator will be introduced as well. This section discusses Java's lack of operator overloading for reference types.
Reference: [13] <author> Todd L. Veldhuizen and M. Ed Jernigan. </author> <title> Will C++ be faster than Fortran? In Proc. </title> <booktitle> of IS-COPE97, Intl. Conf. on Scientific Computing in Object-oriented Parallel Environments, </booktitle> <address> Decem-ber 8-11, </address> <year> 1997. </year>
Reference-contexts: As Budimlic and Kennedy stress in [2] the only serious difficulty is that Java's elaborate exception framework interferes with some optimization. Given that assumption and given the results of a recent study by Veldhuizen and Jernigan <ref> [13] </ref> who benchmarked Kuck and Associates C++ compiler KAI-C++ and demonstrated that KAI-C++ can generate faster-than-Fortran code, it is reasonable to conclude, that Java might as well outperform Fortran. But even if Java and or C/C++ remain slower than Fortran on a runtime scale, economic costs must be considered.
Reference: [14] <author> VisualNumerics. </author> <note> http://www.vni.com. 7 </note>
Reference-contexts: However, for computational science it is unacceptable that Java does not offer complex numbers as primitive type. With current Java, programmers can only fill that gap by defining a class Complex of their own (or by downloading such a class from the Web <ref> [14] </ref>). This approach has several disadvantages. * Object creation cost. Object creation in Java is expensive since each object needs some memory that must be initialized and registered for garbage collection, and an additional lock object must be created. <p> Although that approach is not acceptable in the long run, it is sufficient for flying a kite. The good news is that recently, such libraries have begun to appear, see for example <ref> [14] </ref>. 4 Advantages This section discusses some specific advantages of Java 5 that are often forgotten in the discussion. 4.1 Distribution Since there are MPI and PVM libraries for Java, Java can be used for low level distributed programming much like Fortran or C/C++.
References-found: 14

