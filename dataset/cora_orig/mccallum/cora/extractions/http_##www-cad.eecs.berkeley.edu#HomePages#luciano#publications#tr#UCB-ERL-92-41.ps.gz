URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications/tr/UCB-ERL-92-41.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications.html
Root-URL: http://www.cs.berkeley.edu
Title: SIS: A System for Sequential Circuit Synthesis  a tutorial example illustrating the design process using SIS.  
Author: Ellen M. Sentovich Kanwar Jit Singh Luciano Lavagno Cho Moon Rajeev Murgai Alexander Saldanha Hamid Savoj Paul R. Stephan Robert K. Brayton Alberto Sangiovanni-Vincentelli 
Keyword: (programmable gate arrays).  
Note: The second part contains  
Date: 4 May 1992  
Address: Berkeley, CA 94720  
Affiliation: Electronics Research Laboratory  Department of Electrical Engineering and Computer Science University of California,  
Pubnum: Memorandum No. UCB/ERL M92/41  
Abstract: SIS is an interactive tool for synthesis and optimization of sequential circuits. Given a state transition table, a signal transition graph, or a logic-level description of a sequential circuit, it produces an optimized net-list in the target technology while preserving the sequential input-output behavior. Many different programs and algorithms have been integrated into SIS, allowing the user to choose among a variety of techniques at each stage of the process. It is built on top of MISII [5] and includes all (combinational) optimization techniques therein as well as many enhancements. SIS serves as both a framework within which various algorithms can be tested and compared, and as a tool for automatic synthesis and optimization of sequential circuits. This paper provides an overview of SIS. The first part contains descriptions of the input specification, STG (state transition graph) manipulation, new logic optimization and verification algorithms, ASTG (asynchronous signal transition graph) manipulation, and synthesis for PGA's 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> VAX DECSIM Reference Manual. Digital Equipment Corporation, </institution> <month> December </month> <year> 1985. </year> <note> Not generally available. </note>
Reference-contexts: While MISII operated on only combinational circuits, SIS handles both combinational and sequential circuits. In the Octtools environment, a behavioral description of combinational logic can be given in a subset of the BDS language (the BDS language was developed at DEC <ref> [1] </ref>). The program bdsyn [45] is used to translate this description into a set of logic equations, and then bdnet is used to connect combinational logic and registers and create an Oct description file.
Reference: [2] <author> Karen A. Bartlett, Robert K. Brayton, Gary D. Hachtel, Reily M. Jacoby, Christopher R. Morrison, Richard L. Rudell, Alberto Sangiovanni-Vincentelli, and Albert R. Wang. </author> <title> Multilevel Logic Minimization Using Implicit Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 7(6) </volume> <pages> 723-740, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: In MISII, subsets of the satisfiability and observability don't care sets (SDC and ODC respectively, see <ref> [2] </ref>) are used. The SDC captures conditions which can never happen in the network and hence are don't cares (i.e. if y 1 = x 1 , then y 1 x 1 is a don't care because y 1 and x 1 will never both be 1).
Reference: [3] <author> R.K. Brayton and C. McMullen. </author> <title> The Decomposition and Factorization of Boolean Expressions. </title> <booktitle> In Proceedings of the International Symposium on Circuits and Systems, </booktitle> <pages> pages 49-54, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: This technique is dependent on the sum-of-products representation at each node in the network and therefore a slight change at a node can cause a large change in the final result, for better or for worse. The current algebraic techniques in MISII are based on kernels <ref> [3] </ref>.
Reference: [4] <author> Robert K. Brayton, Gary D. Hachtel, Curtis T. McMullen, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: In addition, new techniques for both combinational and sequential circuits have been introduced. 3.2.1 Combinational Optimization Node Simplification The logic function at a node is simplified in MISII using the simplify command which uses the two-level logic minimizer ESPRESSO <ref> [4] </ref>. The objective of a general two-level logic minimizer is to find a logic representation with a minimal number of implicants and literals while preserving the functionality. There are several approaches to this problem. <p> The input usually contains a cover for the onset and a cover for the don't care set. A cover for the offset is generated from the input using a complement algorithm based on the Unate Recursive Paradigm <ref> [4] </ref>. The number of cubes in the offset can grow exponentially with the number of input variables; hence the offset generation could be quite time consuming. <p> At each intermediate node, the local don't cares are computed in terms of fanins of the node being simplified by an image computation which uses BDD's. This don't care set is augmented with some local SDC's, and minimized with the two-level minimizer ESPRESSO <ref> [4] </ref>. Results for full simplify are reported in [42]. This command should not be applied to networks where the BDD's become too large; there is a built-in mechanism to halt the computation if this occurs.
Reference: [5] <author> Robert K. Brayton, Richard Rudell, Alberto Sangiovanni-Vincentelli, and Albert R. Wang. </author> <title> MIS: A Multiple-Level Logic Optimization System. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> CAD-6(6):1062-1081, </volume> <month> November </month> <year> 1987. </year>
Reference: [6] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification <ref> [6, 10] </ref>, timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date. <p> This can be done either by reducing the size of the resulting function during computation by eliminating variables appropriately [53], or by using a divide and conquer approach [10]. Each function is efficiently implemented and manipulated using BDDs <ref> [6] </ref>. These techniques are useful for generating sequential don't care conditions. The reachable state set is computed with implicit techniques; the complement of this set represents the unreachable states. These are don't care conditions expressed in terms of the registers in the circuit.
Reference: [7] <author> J. A. Brzozowski and C-J. Seger. </author> <title> Advances in Asynchronous Circuit Theory Part I: Gate and Unbounded Inertial Delay Models. </title> <journal> Bulletin of the European Association of Theoretical Computer Science, </journal> <month> October </month> <year> 1990. </year> <month> 29 </month>
Reference-contexts: The designer should use the delay model that best suits the underlying implementation technology (see <ref> [7] </ref>). 5 By default the environment is assumed to respond instantaneously, since this represents a pessimistic worst-case assumption for hazard analysis. 16 TLU Synthesis xl ao cube-packing on an infeasible network xl k decomp apply Roth-Karp decomposition xl split modified kernel extraction xl imp apply different decomposition schemes and pick the
Reference: [8] <author> T. A. Chu. </author> <title> Synthesis of Self-timed VLSI Circuits from Graph-theoretic Specifications. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Other methods of input are by reading from the Oct database, and through a sequential circuit net-list called SLIF (Stanford Logic Interchange Format) [15]. For asynchronous circuits, the input is a signal transition graph <ref> [8] </ref>. 2.1 Logic Implementation (Netlist) The net-list description is given in extended BLIF (Berkeley Logic Interchange Format) which consists of interconnected single-output combinational gates and latches (see Appendix A for a description). The BLIF format, used in MISII, has been augmented to allow the specification of latches and controlling clocks. <p> Again, the user can control the trade-off between area and delay by varying the parameters supplied to the various algorithms. 4.2 Asynchronous Synthesis Example Let us examine a simple example of a signal transition graph from <ref> [8] </ref>, shown in Figure 10.
Reference: [9] <author> T. A. Chu. </author> <title> Synthesis of Hazard-free Control Circuits from Asynchronous Finite State Machine Specifications. </title> <booktitle> In ACM Intl. Workshop on Timing Issues in the Specification and Synthesis of Digital Systems, </booktitle> <pages> pages 1-10, </pages> <year> 1992. </year>
Reference-contexts: Dummy signals are very useful, for example, in transforming an asynchronous finite state machine into a signal transition graph by direct translation <ref> [9] </ref>.
Reference: [10] <author> O. Coudert, C. Berthet, and J.C. Madre. </author> <title> Verification of Sequential Machines Based on Symbolic Execution. In Proc. of the Workshop on Automatic Verification Methods for Finite State Systems, </title> <address> Grenoble, France, </address> <year> 1989. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification <ref> [6, 10] </ref>, timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date. <p> Implicit State Enumeration Techniques Recently, methods for implicitly enumerating the states in a finite-state machine have been reported and can be used to explore the state space in very large examples <ref> [10, 53] </ref>. Such techniques employ a breadth-first traversal of sets of states of a machine. Beginning with an initial state set, all the states reachable in one transition from that set are computed simultaneously, then all the states reachable in two transitions, etc. <p> This can be done either by reducing the size of the resulting function during computation by eliminating variables appropriately [53], or by using a divide and conquer approach <ref> [10] </ref>. Each function is efficiently implemented and manipulated using BDDs [6]. These techniques are useful for generating sequential don't care conditions. The reachable state set is computed with implicit techniques; the complement of this set represents the unreachable states.
Reference: [11] <author> G. DeMicheli. </author> <title> Synchronous Logic Synthesis: Algorithms for Cycle-Time Minimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 63-73, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries <ref> [11, 25, 28, 29] </ref>. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date.
Reference: [12] <author> Andrea Casotto editor. </author> <note> Octtools-5.1 Manuals. In UCB Electronics Research Lab, </note> <month> September </month> <year> 1991. </year>
Reference-contexts: SIS is an interactive tool like MISII, but for sequential circuit synthesis and optimization. It is built on top of MISII and replaces it in the Octtools <ref> [12] </ref>, the Berkeley synthesis tool set based on the Oct database. While MISII operated on only combinational circuits, SIS handles both combinational and sequential circuits.
Reference: [13] <author> A. Gamal et. al. </author> <title> An Architecture for Electrically Configurable Gate Arrays. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 24(2) </volume> <pages> 394-398, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: For a given TLU architecture, m is a fixed number. A typical example is the Xilinx architecture [18], in which m = 5. In MB architectures, the basic block is a configuration of multiplexors <ref> [13] </ref>. In SIS, combinational circuits can be synthesized for both these architectures. Area minimization for both architectures and delay minimization for TLU architectures are supported.
Reference: [14] <author> R.J. Francis, J. Rose, and Z. Vranesic. Chortle-crf: </author> <title> Fast Technology Mapping for Lookup Table-Based FPGAs. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 227-233, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The following is a summary of various decomposition commands for TLU architectures that are in SIS: xl ao cube-packing on an infeasible network xl k decomp apply Roth-Karp decomposition xl split modified kernel extraction xl imp apply different decomposition schemes and pick the best Cube-packing <ref> [14] </ref> used in xl ao treats the cubes (product-terms) of the function as items. The size of each cube is the number of literals in it. Each logic block is a bin with capacity m.
Reference: [15] <author> G. De Micheli. </author> <title> Synchronous logic synthesis. </title> <booktitle> In International Workshop on Logic Synthesis, </booktitle> <institution> page 5.2, North Carolina, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: The two most common entry points are a net-list of gates and a finite-state machine in state-transition-table form. Other methods of input are by reading from the Oct database, and through a sequential circuit net-list called SLIF (Stanford Logic Interchange Format) <ref> [15] </ref>. For asynchronous circuits, the input is a signal transition graph [8]. 2.1 Logic Implementation (Netlist) The net-list description is given in extended BLIF (Berkeley Logic Interchange Format) which consists of interconnected single-output combinational gates and latches (see Appendix A for a description). <p> Signals L and Ro, on the other hand, are purely combinational, hence they are just represented as a combinational logic block. Now we can examine a similar session using the bounded wire-delay model commands. sis&gt; read_astg chu150.g sis&gt; astg_to_f sis&gt; print -Ro_next- = D <ref> [15] </ref> = Ai_ D + Ai_ L_ + D L_' [17] = Ao D Ri' + Ao' D' Ri sis&gt; print_latch input: -[15]- output: Ai_ init val: 1 cur val: 3 type: as control: none input: -[17]- output: L_ init val: 1 cur val: 3 type: as control: none sis&gt; print_io
Reference: [16] <author> Abhijit Ghosh. </author> <title> Techniques for Test Generation and Verification in VLSI Sequential Circuits. </title> <type> UCB PhD Thesis, </type> <institution> Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing <ref> [16] </ref>, retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32].
Reference: [17] <author> G.D. Hachtel, J.-K. Rho, F. Somenzi, and R. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Machines. </title> <booktitle> In The Proceedings of the European Conference on Design Automation, </booktitle> <pages> pages 184-191, </pages> <address> Amsterdam, The Netherlands, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: This approach is illustrated with an example demonstrating the usefulness of these new techniques and the flexibility the designer can exploit during the synthesis process. Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization <ref> [17, 31] </ref>, testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. <p> This usually translates to a smaller logic implementation. Such a technique is called state minimization and has been studied extensively (e.g. <ref> [17, 31] </ref>). For completely specified machines the problem can be solved in polynomial time, while in the more general case of incompletely specified machines the problem is NP hard. In SIS, state minimization has been implemented to allow the user to choose among various state minimization programs. <p> Programs that conform to the specification can be executed from the SIS shell. It has simple requirements, e.g. that the program use the KISS format for input and output. For example, the user may invoke the STAMINA <ref> [17] </ref> program, a heuristic state minimizer for incompletely specified machines distributed with SIS, as follows: sis&gt; state_minimize stamina -s 1 In this case, STAMINA is used with its option `-s 1' to perform state minimization on the current STG. <p> Now we can examine a similar session using the bounded wire-delay model commands. sis&gt; read_astg chu150.g sis&gt; astg_to_f sis&gt; print -Ro_next- = D [15] = Ai_ D + Ai_ L_ + D L_' <ref> [17] </ref> = Ao D Ri' + Ao' D' Ri sis&gt; print_latch input: -[15]- output: Ai_ init val: 1 cur val: 3 type: as control: none input: -[17]- output: L_ init val: 1 cur val: 3 type: as control: none sis&gt; print_io primary inputs: Ri Ao D Ai_ L_ primary outputs: -Ro_next
Reference: [18] <author> Xilinx Inc. </author> <title> Xilinx Programmable Gate Array User's Guide, </title> <year> 1988. </year>
Reference-contexts: A basic block of a TLU architecture (also called configurable logic block or CLB) implements any function having up to m inputs, m 2. For a given TLU architecture, m is a fixed number. A typical example is the Xilinx architecture <ref> [18] </ref>, in which m = 5. In MB architectures, the basic block is a configuration of multiplexors [13]. In SIS, combinational circuits can be synthesized for both these architectures. Area minimization for both architectures and delay minimization for TLU architectures are supported.
Reference: [19] <author> T. Larrabee. </author> <title> Efficient Generation of Test Patterns Using Boolean Difference. </title> <booktitle> In Proceedings of the International Test Conference, </booktitle> <pages> pages 795-801, </pages> <year> 1989. </year>
Reference-contexts: Random test generation is done using parallel fault simulation. After the random patterns have been simulated, the algorithm performs a deterministic search to find tests for the remaining faults. This part is based on the algorithm reported in <ref> [19] </ref>: a set of equations is written to express the difference between the good and faulty circuits for a particular fault and Boolean satisfiability is used to find a satisfying assignment for these equations. The implementation of the algorithm in SIS has been substantially improved for speed.
Reference: [20] <author> L. Lavagno, K. Keutzer, and A. Sangiovanni-Vincentelli. </author> <title> Algorithms for Synthesis of Hazard-free Asynchronous Circuits. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 302-308, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis <ref> [20, 32] </ref>. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date. <p> This straightforward implementation, though, can still exhibit hazards (i.e. temporary deviations from the expected values, due to the non-zero delays of gates and wires in a combinational circuit). SIS provides an implementation of the algorithms described in [32] and <ref> [20] </ref> to produce hazard-free circuits under the unbounded gate-delay model and the bounded wire-delay model respectively. The commands that operate on a signal transition graph and produce an asynchronous circuit implementation of it can be roughly classified as analysis and synthesis commands. <p> Those hazards can be eliminated, after a constrained logic synthesis and technology mapping, by the astg slow command. * astg slow inserts delays, as described in <ref> [20] </ref>, in order to produce a hazard-free circuit in a specific implementation technology. Note that this step can take advantage of the knowledge about minimum delays in the environment 5 .
Reference: [21] <author> C. E. Leiserson, F. M. Rose, and J. B. Saxe. </author> <title> Optimizing Synchronous Circuitry by Retiming. </title> <booktitle> In Advanced Research in VLSI: Proceedings of the Third Caltech Conference, </booktitle> <pages> pages 86-116. </pages> <publisher> Computer Science Press, </publisher> <year> 1983. </year>
Reference-contexts: It operates on synchronous edge-triggered designs. A particular gate is retimed forward by moving registers from each of its fanins to each of its fanouts (see Figure 6). The sequential I/O behavior of the circuit is maintained. An example of retiming for minimum cycle time taken from <ref> [21] </ref> is shown in Figure 7. This example represents a correlator circuit, which takes a stream of bits and compares it with a pattern a 0 ; a 1 ; a 2 ; a 3 .
Reference: [22] <author> C. E. Leiserson and J. B. Saxe. </author> <title> Retiming Synchronous Circuitry. In TM 372, MIT/LCS, 545 Technology Square, </title> <address> Cambridge, Massachusetts 02139, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming <ref> [22] </ref>, technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. <p> Some extensions are required for the technology mapping algorithms to work on sequential circuits. Finally, sequential don't cares based on unreachable states can be computed and used during node minimization. Retiming Retiming <ref> [22] </ref> is an algorithm that moves registers across logic gates either to minimize cycle time, minimize the number of registers, or minimize the number of registers subject to a cycle-time constraint. It operates on synchronous edge-triggered designs.
Reference: [23] <author> C.E. Leiserson and J.B. Saxe. </author> <title> Optimizing Synchronous Systems. </title> <journal> Journal of VLSI and Computer Systems, </journal> <volume> 1(1) </volume> <pages> 41-67, </pages> <month> Spring </month> <year> 1983. </year>
Reference-contexts: The delays of each of the components are given (delay = 3 for a comparator, 7 for an adder). For this circuit, the cycle time is reduced from 24 to 13. The original algorithm <ref> [23] </ref> was based on a mixed-integer linear programming formulation for determining whether a particular cycle time is feasible; if so, the correct register positions are determined. Later, more efficient relaxation 12 based techniques were reported [44]. Both approaches are implemented in the retime command in SIS.
Reference: [24] <author> B. Lin and A.R. </author> <title> Newton. Synthesis of Multiple Level Logic from Symbolic High-Level Description Languages. </title> <booktitle> In Proceedings of the International Conference on VLSI, </booktitle> <pages> pages 187-196, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: This approach is illustrated with an example demonstrating the usefulness of these new techniques and the flexibility the designer can exploit during the synthesis process. Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment <ref> [24, 58] </ref>, state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. <p> A call to a state assignment program, such as sis&gt; state_assign nova -e ih 7 will perform optimal state assignment on the STG and return a corresponding logic implementation. Two state assignment programs, JEDI <ref> [24] </ref> and NOVA [58] are distributed with SIS. JEDI is a general symbolic encoding program (i.e., for encoding both inputs and outputs) that can be used for the more specific state encoding problem; it is targeted for multi-level implementations.
Reference: [25] <author> B. Lin, H. Touati, and A.R. </author> <title> Newton. Don't Care Minimization of Multi-level Sequential Logic Networks. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 414-417, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries <ref> [11, 25, 28, 29] </ref>. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date.
Reference: [26] <author> R. Lisanke. </author> <booktitle> Logic synthesis benchmark circuits for the International Workshop on Logic Synthesis, </booktitle> <month> May, </month> <year> 1989. </year> <month> 30 </month>
Reference-contexts: Designs can be described hierarchically although currently the hierarchy information is not retained in the internal data structure resulting in a flat netlist 1 . 2.2 State Transition Graph (STG) A state transition table for a finite-state machine can be specified with the KISS <ref> [26] </ref> format, used extensively in state assignment and state minimization programs. Each state is symbolic; the transition table indicates the next symbolic state and output bit-vector given a current state and input bit-vector. <p> The example chosen is mark1, which is in the MCNC benchmark set <ref> [26] </ref>. <p> Moreover, the user can control the tradeoff between latch count and cycle time. Finally, a library of gates including latches is read in. sis&gt; rlib lib2.genlib lib2.genlib is based on a standard-cell design style and is from the MCNC benchmark set <ref> [26] </ref>. It has been augmented with latches.
Reference: [27] <author> A. Malik, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> A Modified Approach to Two-level Logic Minimiza--tion. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 106-109, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: To overcome the problem of generating huge offsets, a subset of the offset called the reduced offset is used <ref> [27] </ref>. The reduced offset for a cube is never larger than the entire offset of the function and in practice has been found to be much smaller.
Reference: [28] <author> S. Malik, E.M. Sentovich, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Retiming and resynthesis: Optimization of sequential networks with combinational techniques. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 74-84, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries <ref> [11, 25, 28, 29] </ref>. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date. <p> Standard combinational techniques optimize a logic network, but given a sequential circuit, the optimization is limited to each combinational block: interactions between signals across register boundaries are not exploited. These two techniques are combined in the retiming and resynthesis algorithm <ref> [28] </ref>. The first step is to identify the largest subcircuits that can be peripherally retimed, i.e. that can be retimed in such a way as to move all the registers to the boundaries of the subcircuit.
Reference: [29] <author> S. Malik, K.J. Singh, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Performance Optimization of Pipelined Circuits. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 410-413, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries <ref> [11, 25, 28, 29] </ref>. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date. <p> It is only by combining peripheral retiming, which allows negative registers, and resynthesis that the improvement is obtained. This algorithm has been successful in performance optimization of pipelined circuits <ref> [29] </ref>. Experiments with area minimization are ongoing, but it is expected that good results will be obtained only when the latest combinational optimization techniques, which use a larger set of observability don't cares, are employed.
Reference: [30] <author> H.-J. Mathony. </author> <title> Universal Logic Design Algorithm and its Application to the Synthesis of Two-level Switching Circuits. </title> <booktitle> IEE Proceedings, </booktitle> <volume> 136 Pt. E(3), </volume> <month> May </month> <year> 1989. </year>
Reference-contexts: This is a binate covering formulation [39]. Mathony's algorithm <ref> [30] </ref> is used to solve this formulation. For large networks, this algorithm is computationally intensive and several heuristics for fast approximate solutions are used (option -h). xl partition tries to reduce the number of nodes by collapsing nodes into their immediate fanouts. It also takes into account extra nets created.
Reference: [31] <author> M.C. Paull and S.H. Unger. </author> <title> Minimizing the Number of States in Incompletely Specified Sequential Switching Functions. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> EC-8:356-367, </volume> <month> September </month> <year> 1959. </year>
Reference-contexts: This approach is illustrated with an example demonstrating the usefulness of these new techniques and the flexibility the designer can exploit during the synthesis process. Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization <ref> [17, 31] </ref>, testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. <p> This usually translates to a smaller logic implementation. Such a technique is called state minimization and has been studied extensively (e.g. <ref> [17, 31] </ref>). For completely specified machines the problem can be solved in polynomial time, while in the more general case of incompletely specified machines the problem is NP hard. In SIS, state minimization has been implemented to allow the user to choose among various state minimization programs.
Reference: [32] <author> C. W. Moon, P. R. Stephan, and R. K. Brayton. </author> <title> Synthesis of Hazard-free Asynchronous Circuits from Graphical Specifications. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 322-325, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis <ref> [20, 32] </ref>. However, no comprehensive evaluation of the algorithms and no complete synthesis system in which all of these algorithms are employed has been 1 reported to date. <p> This straightforward implementation, though, can still exhibit hazards (i.e. temporary deviations from the expected values, due to the non-zero delays of gates and wires in a combinational circuit). SIS provides an implementation of the algorithms described in <ref> [32] </ref> and [20] to produce hazard-free circuits under the unbounded gate-delay model and the bounded wire-delay model respectively. The commands that operate on a signal transition graph and produce an asynchronous circuit implementation of it can be roughly classified as analysis and synthesis commands. <p> Synthesis commands * astg syn synthesizes a hazard-free circuit using the unbounded gate-delay model. It eliminates hazards from the initial circuit, produced from the implied values as described above, by adding redundant gates and/or adding input connections to some gates, as described in <ref> [32] </ref>. This command (as well as astg to f) can compute the initial marking if it is not explicitly given. * astg to f synthesizes a circuit (like astg syn), but in addition it analyzes and stores its potential hazards using the bounded wire-delay model 4 .
Reference: [33] <author> C.W. Moon, B. Lin, H. Savoj, and R.K. Brayton. </author> <title> Technology Mapping for Sequential Logic Synthesis. </title> <booktitle> In Proc. Int'l. Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment [24, 58], state minimization [17, 31], testing [16], retiming [22], technology mapping <ref> [33] </ref>, verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. <p> Retiming and resynthesis will be implemented in SIS after further investigation and experimentation. Technology Mapping The strategy of representing feedback lines by latches preserves the acyclic nature of the circuit representation and allows the combinational technology mapping algorithms to be easily extended to sequential mapping <ref> [33] </ref>. The same tree-covering algorithm [39] is used but the pattern matching procedure is extended to accommodate sequential elements. The pattern matching relies no longer on just the network topology but also on the type of library element and on the location of latch input and output pins.
Reference: [34] <author> R. Murgai, Y. Nishizaki, N. Shenoy, R. K. Brayton, and A. Sangiovanni Vincentelli. </author> <title> Logic Synthesis for Programmable Gate Arrays. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 620-625, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We are working on extending the capabilities to handle sequential circuits. 17 The algorithms and the corresponding commands that implement them in SIS are described next. For complete details of the algorithms, the reader may refer to <ref> [34, 35, 36] </ref>. 3.4.1 Synthesis for TLU architectures If a function has at most m inputs, we know it can be realized with one block. We call such a function m-feasible. Otherwise, it is m-infeasible. A network is m-feasible if the function at each node of the network is m-feasible. <p> The command is called act map. The architecture act (that is, act1 with the OR gate removed) is also supported. No library needs to be read. The outline of the algorithm <ref> [34] </ref> is as follows: first, for each node of the network a BDD (ordered or unordered) is constructed. The basic block of the architecture is represented with pattern graphs.
Reference: [35] <author> R. Murgai, N. Shenoy, R. K. Brayton, and A. Sangiovanni Vincentelli. </author> <title> Improved Logic Synthesis Algorithms for Table Look Up Architectures. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 564-567, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: We are working on extending the capabilities to handle sequential circuits. 17 The algorithms and the corresponding commands that implement them in SIS are described next. For complete details of the algorithms, the reader may refer to <ref> [34, 35, 36] </ref>. 3.4.1 Synthesis for TLU architectures If a function has at most m inputs, we know it can be realized with one block. We call such a function m-feasible. Otherwise, it is m-infeasible. A network is m-feasible if the function at each node of the network is m-feasible.
Reference: [36] <author> R. Murgai, N. Shenoy, R. K. Brayton, and A. Sangiovanni Vincentelli. </author> <title> Performance Directed Synthesis for Table Look Up Programmable Gate Arrays. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 572-575, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: We are working on extending the capabilities to handle sequential circuits. 17 The algorithms and the corresponding commands that implement them in SIS are described next. For complete details of the algorithms, the reader may refer to <ref> [34, 35, 36] </ref>. 3.4.1 Synthesis for TLU architectures If a function has at most m inputs, we know it can be realized with one block. We call such a function m-feasible. Otherwise, it is m-infeasible. A network is m-feasible if the function at each node of the network is m-feasible. <p> Then any block count minimization command (e.g. xl cover, xl partition) can be applied to reduce the number of blocks without increasing the number of levels. The details of the complete algorithm may be found in <ref> [36] </ref>. 3.4.2 Synthesis for MB architectures We have implemented synthesis algorithms for Actel's act1 architecture (Figure 9). The command is called act map. The architecture act (that is, act1 with the OR gate removed) is also supported. No library needs to be read.
Reference: [37] <author> C. Pixley and G. Beihl. </author> <title> Calculating Resetability and Reset Sequences. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: It uses implicit state enumeration techniques (see Section 3.2.2) to find a cycle of states containing the reset state. Simulation along the cycle is used to determine the new initial state for the retimed circuit. Recently the notion of a resetable circuit was proposed <ref> [37] </ref>. Resetable circuits have an easily computed initializing sequence which brings the machine to a known state independent of the state on power-up. Although retiming preserves the resetable property, Boolean operations may not.
Reference: [38] <author> J.P. Roth and R.M. Karp. </author> <title> Minimization over Boolean Graphs. </title> <journal> In IBM Journal of Research and Development, </journal> <month> April </month> <year> 1982. </year>
Reference-contexts: The size of each cube is the number of literals in it. Each logic block is a bin with capacity m. The decomposition problem can then be seen as that of packing the cubes into a minimum number of bins. xl k decomp uses classical Roth-Karp decomposition <ref> [38] </ref> to decompose an infeasible node into m-feasible nodes. A set X (called the bound set) of cardinality m is chosen from the inputs of the infeasible function f . The rest of the inputs form the free set Y .
Reference: [39] <author> R. Rudell. </author> <title> Logic Synthesis for VLSI Design. </title> <note> Memorandum No. </note> <institution> UCB/ERL M89/49, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> April </month> <year> 1989. </year>
Reference-contexts: The redundancy removal command red removal is based on these techniques and iteratively removes all redundant faults. Technology Mapping MISII uses a tree-covering algorithm to map arbitrary complex logic gates into gates specified in a technology library <ref> [39] </ref>. (The technology library is given in genlib format, which is described in Appendix B.) This is done by decomposing the logic to be mapped into a network of 2-input NAND gates and inverters. <p> Technology Mapping The strategy of representing feedback lines by latches preserves the acyclic nature of the circuit representation and allows the combinational technology mapping algorithms to be easily extended to sequential mapping [33]. The same tree-covering algorithm <ref> [39] </ref> is used but the pattern matching procedure is extended to accommodate sequential elements. The pattern matching relies no longer on just the network topology but also on the type of library element and on the location of latch input and output pins. <p> This is a binate covering formulation <ref> [39] </ref>. Mathony's algorithm [30] is used to solve this formulation. For large networks, this algorithm is computationally intensive and several heuristics for fast approximate solutions are used (option -h). xl partition tries to reduce the number of nodes by collapsing nodes into their immediate fanouts.
Reference: [40] <author> Alexander Saldanha, Albert Wang, Robert K. Brayton, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Multi-Level Logic Simplification using Don't Cares and Filters. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 277-282, </pages> <year> 1989. </year>
Reference-contexts: The use of the reduced offset speeds up the node simplification; however, if the size of don't care set is too large, the computation of reduced offsets is not possible either. As a result, filters <ref> [40] </ref> must be introduced to keep the don't care size reasonably small. <p> In latter versions of MISII and in SIS, the generation of the don't care sets has been improved significantly. A subset of the SDC is used that is known as the support subset <ref> [40] </ref> and consists of the satisfiability don't cares of all the nodes whose support is included in the support of the node being simplified.
Reference: [41] <author> H. Savoj and R.K. Brayton. </author> <title> The Use of Observability and External Don't Cares for the Simplification of Multi-Level Networks. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 297-301, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: To reduce the size of the input to the two-level minimizer, several techniques are employed. External and observability don't cares are computed for each node using the techniques in <ref> [41] </ref>. The external don't cares are only allowed in two-level form expressed directly in terms of primary inputs. A subset of the ODC called the CODC (compatible ODC) is computed for the simplification of each node.
Reference: [42] <author> H. Savoj, R.K. Brayton, and H. Touati. </author> <title> Extracting Local Don't Cares for Network Optimization. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: This don't care set is augmented with some local SDC's, and minimized with the two-level minimizer ESPRESSO [4]. Results for full simplify are reported in <ref> [42] </ref>. This command should not be applied to networks where the BDD's become too large; there is a built-in mechanism to halt the computation if this occurs. Kernel and Cube Extraction An important step in network optimization is extracting new nodes representing logic functions that are factors of other nodes. <p> That is, given the don't cares for the inputs of a node, an appropriate don't care function is computed for the output of the node. Techniques for propagating don't cares backward have already been developed in the work on ODC's <ref> [42] </ref>. Together, the forward and backward propagation algorithms can be used to propagate don't care conditions completely throughout a network, regardless of where these don't cares originate. Retiming and Resynthesis Retiming finds optimal register positions without altering the combinational logic functions at each node.
Reference: [43] <author> H. Savoj, H.-Y. Wang, and R.K. Brayton. </author> <title> Improved Scripts in MIS-II for Logic Minimizaton of Combinational Circuits. </title> <booktitle> In The International Workshop on Logic Synthesis, </booktitle> <month> May </month> <year> 1991. </year> <month> 31 </month>
Reference-contexts: This technique has been implemented in SIS and is called fast extract or fx. Generally, it should replace the MISII commands gkx and gcx since its quality is comparable but its speed in many cases is substantially higher <ref> [43] </ref>. One shortcoming of this approach is that the size of each divisor is limited to no more than two cubes. However, large nodes are effectively extracted by the combined process of fast extract and elimination.
Reference: [44] <author> James B. Saxe. </author> <title> Decomposable Searching Problems and Circuit Optimization by Retiming: Two Studies in General Transformations of Computational Structures. </title> <institution> CMU-CS-85-162, Carnegie-Mellon University, Department of Computer Science, </institution> <month> August </month> <year> 1985. </year>
Reference-contexts: The original algorithm [23] was based on a mixed-integer linear programming formulation for determining whether a particular cycle time is feasible; if so, the correct register positions are determined. Later, more efficient relaxation 12 based techniques were reported <ref> [44] </ref>. Both approaches are implemented in the retime command in SIS. To determine the optimal cycle time, the feasible cycle time algorithm is combined with a binary search procedure through a range of cycle times.
Reference: [45] <author> R. Segal. BDSYN: </author> <title> Logic Description Translator; BDSIM: Switch-Level Simulator. </title> <type> Master's Thesis, </type> <note> Memorandum No. </note> <institution> UCB/ERL M87/33, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: While MISII operated on only combinational circuits, SIS handles both combinational and sequential circuits. In the Octtools environment, a behavioral description of combinational logic can be given in a subset of the BDS language (the BDS language was developed at DEC [1]). The program bdsyn <ref> [45] </ref> is used to translate this description into a set of logic equations, and then bdnet is used to connect combinational logic and registers and create an Oct description file.
Reference: [46] <author> E.M. Sentovich and R.K. Brayton. </author> <title> Preserving Don't Care Conditions During Retiming. </title> <booktitle> In Proceedings of the International Conference on VLSI, </booktitle> <pages> pages 461-470, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: During retiming, the registers are moved and these boundaries change. This invalidates the computed don't care information, even though the combinational logic function at each node is unchanged. An algorithm for preserving the maximal don't care sets during retiming has been reported <ref> [46] </ref> and is currently being implemented in SIS (it is not available in the current release of SIS). Although often the don't care information can be re-computed based on the new structure of the logic blocks, in some cases this results in a smaller don't care set.
Reference: [47] <author> K.J. Singh and A. Sangiovanni-Vincentelli. </author> <title> A Heuristic Algorithm for the Fanout Problem. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 357-360, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In addition to the technology mapping for delay another command that inserts buffers in the circuit to reduce delay, is provided. The command buffer opt <ref> [47] </ref> takes as input a circuit mapped for minimum area (map -m 0) and inserts buffers to improve circuit performance. This command is subsumed by the map -m 1 -A command which in addition to adding buffers also makes selections of the gates to implement the logic functions.
Reference: [48] <author> K.J. Singh, A.R. Wang, R.K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Timing Optimization of Combinational Logic. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 282-285, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Restructuring for Performance The delay of the circuit is determined by the multi-level structure of the logic as well as the choice of gates used to implement the functions. There are two algorithms that address the restructuring of the logic to improve the delay. These are speed up <ref> [48] </ref> and reduce depth [52]. The speed up command operates on a decomposition of the network in terms of simple gates (2-input NAND gates and inverters). This description is the same as that used by technology mapping. <p> The speed up command tries to reduce the depth of the decomposed circuit with the intuition that a small depth representation will result in a smaller delay. The restructuring is performed by collapsing sections along the long paths and resynthesizing them for better timing characteristics <ref> [48] </ref>. Following the restructuring the circuit is mapped for minimum delay. The recommended use of the speed up command is to run the following on an area-optimized circuit: gd *; eliminate -1; speed up; map -m 1 -A.
Reference: [49] <author> A. Srinivasan, T. Kam, S. Malik, and R.K. Brayton. </author> <title> Algorithms for Discrete Function Manipulation. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 92-95, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Then, a latch with asynchronous set/reset signals can be represented as a latch with only synchronous set/reset signals, and the mapper distinguishes between the two by the types of input pins. A project is underway to store an un-encoded state machine in an MDD representation (multiple-valued decision diagram) <ref> [49] </ref> rather than the cumbersome STG representation; state assignment algorithms that work from multi-level logic descriptions represented as MDDs are being explored. Also under investigation are techniques for sequential test pattern generation.
Reference: [50] <author> H. Touati and R.K. Brayton. </author> <title> Computing the Initial States of Retimed Circuits. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <month> July </month> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: Although the retimed circuit may not have an equivalent reset state, a method for computing the new initial state when possible is reported in <ref> [50] </ref>. It uses implicit state enumeration techniques (see Section 3.2.2) to find a cycle of states containing the reset state. Simulation along the cycle is used to determine the new initial state for the retimed circuit. Recently the notion of a resetable circuit was proposed [37].
Reference: [51] <author> H. Touati, C. Moon, R.K. Brayton, and A.Wang. </author> <title> Performance-Oriented Technology Mapping. </title> <booktitle> In Proceedings of the sixth MIT VLSI Conference, </booktitle> <pages> pages 79-97, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Recent refinements have significantly improved it for performance optimization, as reported in [54]; tree covering has been extended to take load values into account accurately. In addition, efficient heuristic fanout optimization algorithms, reported in <ref> [51] </ref>, have been extended and implemented. They are also used during tree covering to estimate delay at multiple fanout points; this enables the algorithm to make better decisions in successive mapping passes over the circuit.
Reference: [52] <author> H. Touati, H. Savoj, and R.K. Brayton. </author> <title> Delay Optimization of Combinational Logic Circuits by Clustering and Partial Collapsing. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: There are two algorithms that address the restructuring of the logic to improve the delay. These are speed up [48] and reduce depth <ref> [52] </ref>. The speed up command operates on a decomposition of the network in terms of simple gates (2-input NAND gates and inverters). This description is the same as that used by technology mapping. <p> The recommended use of the speed up command is to run the following on an area-optimized circuit: gd *; eliminate -1; speed up; map -m 1 -A. The reduce depth command takes a different approach to technology-independent network restructuring for performance optimization <ref> [52] </ref>. The idea is to uniformly reduce the depth of the circuit. It does this by first clustering nodes according to some criteria and then collapsing each cluster into a single node.
Reference: [53] <author> H. Touati, H. Savoj, B. Lin, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Implicit State Enumeration Techniques Recently, methods for implicitly enumerating the states in a finite-state machine have been reported and can be used to explore the state space in very large examples <ref> [10, 53] </ref>. Such techniques employ a breadth-first traversal of sets of states of a machine. Beginning with an initial state set, all the states reachable in one transition from that set are computed simultaneously, then all the states reachable in two transitions, etc. <p> Efficient implementation of this technique requires careful computation of the product of the transition relation (present-state/next-state relation) and the current set of states. This can be done either by reducing the size of the resulting function during computation by eliminating variables appropriately <ref> [53] </ref>, or by using a divide and conquer approach [10]. Each function is efficiently implemented and manipulated using BDDs [6]. These techniques are useful for generating sequential don't care conditions. The reachable state set is computed with implicit techniques; the complement of this set represents the unreachable states. <p> The two machines may have different state encodings. At each iteration, the states reached are checked for equivalent output functions. The verify fsm command in SIS has verified machines with more than 10 68 states <ref> [53] </ref>. 3.3 Signal Transition Graph Manipulations The design input to SIS need not be a synchronous specification. An asynchronous specification can be given as a signal transition graph. In this section, algorithms are outlined for the synthesis of hazard-free circuits under different delay models from signal transition graphs.
Reference: [54] <author> Herv e J. Touati. </author> <title> Performance-Oriented Technology Mapping. </title> <note> Memorandum No. </note> <institution> UCB/ERL M90/109, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Recent refinements have significantly improved it for performance optimization, as reported in <ref> [54] </ref>; tree covering has been extended to take load values into account accurately. In addition, efficient heuristic fanout optimization algorithms, reported in [51], have been extended and implemented.
Reference: [55] <author> S. H. Unger. </author> <title> Asynchronous Sequential Switching Circuits. </title> <publisher> Wiley Interscience, </publisher> <year> 1969. </year>
Reference-contexts: could not be represented, in general, by a free-choice signal transition graph without dummy transitions. 5 i.e. it must be a Moore-type machine, and each edge entering the state must have exactly the same input signal labels (this is often the case, for example, with classical primitive flow tables, see <ref> [55] </ref>). Suppose that a finite state machine, whose fragment appears in Figure 4 (a), has a state s 1 with code 00, where all input and output signals signals have the value 0.
Reference: [56] <author> P. Vanbekbergen, G. Goossens, and H. De Man. </author> <title> A Local Optimization Technique for Asynchronous Control Circuits. </title> <booktitle> In Proc. Int'l. Workshop on Logic Synthesis, </booktitle> <address> North Carolina, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Note that contraction is guaranteed to yield a contracted signal transition graph with complete state coding only if the original signal transition graph was a marked graph. * astg lockgraph, given a correct signal transition graph without complete state coding, uses the algorithm described in <ref> [56] </ref> to produce a signal transition graph with less concurrency but complete state coding (so that it can be synthesized).
Reference: [57] <author> J. Vasudevamurthy and J. Rajski. </author> <title> A Method for Concurrent Decomposition and Factorization of Boolean Expressions. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 510-513, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Extraction of multi-cube divisors and common cubes from a network in MISII is done with the gkx and gcx commands. A more recent algebraic technique extracts only two-cube divisors and two-literal single-cube divisors both in normal and complement form <ref> [57] </ref>. This approach has several advantages in terms of computation time while the quality of the final result is as good as kernel-based approaches according to [57] as well as our experimental results. <p> A more recent algebraic technique extracts only two-cube divisors and two-literal single-cube divisors both in normal and complement form <ref> [57] </ref>. This approach has several advantages in terms of computation time while the quality of the final result is as good as kernel-based approaches according to [57] as well as our experimental results. It is shown that the total number of double-cube divisors and two-literal single-cube divisors is polynomial in the number of cubes appearing in the expression. Also, this set is created once, and can be efficiently updated when a divisor is extracted.
Reference: [58] <author> T. Villa and A. Sangiovanni-Vincentelli. </author> <title> NOVA: State Assignment of Finite State Machines for Optimal Two-Level Logic Implementations. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 9(9) </volume> <pages> 905-924, </pages> <month> September </month> <year> 1990. </year> <month> 32 </month>
Reference-contexts: This approach is illustrated with an example demonstrating the usefulness of these new techniques and the flexibility the designer can exploit during the synthesis process. Many algorithms have been published for various stages of sequential synthesis. For synchronous circuits, these include methods for state assignment <ref> [24, 58] </ref>, state minimization [17, 31], testing [16], retiming [22], technology mapping [33], verification [6, 10], timing analysis, and optimization across register boundaries [11, 25, 28, 29]. For asynchronous circuits, these include methods for hazard-free synthesis [20, 32]. <p> A call to a state assignment program, such as sis&gt; state_assign nova -e ih 7 will perform optimal state assignment on the STG and return a corresponding logic implementation. Two state assignment programs, JEDI [24] and NOVA <ref> [58] </ref> are distributed with SIS. JEDI is a general symbolic encoding program (i.e., for encoding both inputs and outputs) that can be used for the more specific state encoding problem; it is targeted for multi-level implementations.
References-found: 58

