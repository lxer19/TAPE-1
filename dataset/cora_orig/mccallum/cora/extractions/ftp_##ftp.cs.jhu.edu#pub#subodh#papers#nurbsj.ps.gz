URL: ftp://ftp.cs.jhu.edu/pub/subodh/papers/nurbsj.ps.gz
Refering-URL: http://www.cs.jhu.edu/~subodh/research/pub.html
Root-URL: http://www.cs.jhu.edu
Title: Interactive Display of Large NURBS Models  
Author: Subodh Kumar, Dinesh Manocha, Anselmo Lastra 
Keyword: NURBS, Tessellation, Triangulation, Visibility, Interactive Display, CAD, Parallel algorithm.  
Address: Chapel Hill NC 27599  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: We present serial and parallel algorithms for interactive rendering of large-scale NURBS models. The algorithm converts the NURBS surfaces to Bezier surfaces, tessellates each Bezier surface into triangles and renders them using the triangle rendering capabilities common to current graphics systems. This paper explains how to derive tight bounds for good quality tessellation of Bezier surfaces. We use visibility techniques and present methods to make efficient use of coherence between successive frames. In addition, we also discuss issues in parallelization of these techniques. The algorithm includes visibility culling and avoids polygonization anomalies like cracks. We also quote results to show that it works well in practice and, on high-end graphics systems, is able to display models described using thousands of Bezier surfaces at interactive frame rates. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Akeley, </author> <title> "Reality Engine Graphics", </title> <booktitle> in Proceedings of ACM Siggraph, </booktitle> <year> 1993, </year> <pages> pp. 109-116. </pages>
Reference-contexts: Closely spaced knots, with tolerance less than 2 fi 10 5 , are coerced to the same value before knot insertion 2 . NURBS surfaces are thus decomposed into a series of Bezier surfaces. A Bezier patch F of degree m fi n defined by parameters u; v 2 <ref> [0; 1] </ref>, is specified by a mesh 2 The tolerance value can be overridden by the user. 5 of control points C ij ; 0 i m; 0 j n: F (u; v) = i=0 j=0 i (u)B n where the Bernstein polynimial B is given by B n 0 @ <p> In general, a point p on a patch with normal n is backfacing if ~ep ~n &gt; 0; where e is the eye point. In other words, a patch, F, is backfacing if, 8u; v 2 <ref> [0; 1] </ref>; n (u; v) makes an acute angle with the vector joining the eye to F (u; v). <p> As a result k C (t + ffi) C (t) k= ffi k X (t 1 ); Y (t 2 ); Z (t 3 ) k 0 0 0 where X 0 0 0 (t) represent the maximum magnitude of X 0 0 0 (t), respectively, in the domain <ref> [0; 1] </ref> and kV k is the L 2 norm of the vector V . <p> F (u; v), the tessellation parameters are computed in object space as: fl fl X (u;v) ; W (u;v) u Z (u;v) fl fl T OL where X (u;v) corresponds to the maximum magnitude of the partial derivative of X (u;v) W (u;v) with respect to u in the domain <ref> [0; 1] </ref> fi [0; 1]. n v is computed analogously. 15 The maximum values of the partial derivates are computed in the following way. <p> the tessellation parameters are computed in object space as: fl fl X (u;v) ; W (u;v) u Z (u;v) fl fl T OL where X (u;v) corresponds to the maximum magnitude of the partial derivative of X (u;v) W (u;v) with respect to u in the domain <ref> [0; 1] </ref> fi [0; 1]. n v is computed analogously. 15 The maximum values of the partial derivates are computed in the following way. <p> Based on the solutions of these equations, we compute the maximum values of f x (u; v) in 16 Fig. 3. Undersampling the domain <ref> [0; 1] </ref> fi [0; 1]. Let the maximum value be at [u x ; v x ]. Similar computations are performed on f y (u; v) and f z (u; v). <p> Based on the solutions of these equations, we compute the maximum values of f x (u; v) in 16 Fig. 3. Undersampling the domain <ref> [0; 1] </ref> fi [0; 1]. Let the maximum value be at [u x ; v x ]. Similar computations are performed on f y (u; v) and f z (u; v). <p> It is applied in a similar manner along the v-axis. Let us first consider the case when n u &gt; n u . We need to choose n u n u additional points in the domain <ref> [0; 1] </ref>, such that the resulting polygonization is smooth. One simple solution is to use tessellations that are powers of two. Thus we need to introduce n u new tessellants 22 Fig. 7. Example of Incremental Tessellation subdividing the old tessellation, thereby halving the step size. <p> Currently, we are able to render models consisting of seven to eight hundred Bezier patches at 12 16 frames a second. 26 A. Parallel Implementation Pixel-Planes 5 [2] uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators <ref> [1] </ref>. Figure 4 presents a block diagram of the Pixel-Planes 5 system. Front-end geometry processing, such as transformation, clipping, and setup for rasterization, is performed on the Graphics Processors (GPs) which contain Intel i860 RISC microprocessors running at 40 MHz, 8 MB of main memory, and communications hardware.
Reference: [2] <author> H. Fuchs and J. Poulton et al., </author> <title> "Pixel-Planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 79-88, </pages> <year> 1989, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: 1 By interactive display we mean a rendering rate of more than 10-15 frames a second. 2 and on Pixel-Planes 5, <ref> [2] </ref> about thirty thousand surfaces at interactive frame rates. On multiple-processor machines the algorithm statically partitions the model, distributing it to the processors to balance the load. A preliminary version of this paper has appeared as [24]. <p> Currently, we are able to render models consisting of seven to eight hundred Bezier patches at 12 16 frames a second. 26 A. Parallel Implementation Pixel-Planes 5 <ref> [2] </ref> uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators [1]. Figure 4 presents a block diagram of the Pixel-Planes 5 system. <p> Triangle rasterization, and shading is performed on renderer boards which contain arrays of 128 by 128 1-bit processors with local memory <ref> [2] </ref> and an instruction sequencer. The processing units are connected by a 160 million word per second ring communications network. Since we have access to the GPs of Pixel-Planes 5, a parallel implementation of the tessellation algorithm seemed natural.
Reference: [3] <author> E. Catmull, </author> <title> A subdivision algorithm for computer display of curved surfaces, </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference: [4] <author> J. H. Clark, </author> <title> "A fast algorithm for rendering parametric surfaces", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 13, no. 2, </volume> <pages> pp. 289-299, </pages> <year> 1979, </year> <note> (SIGGRAPH Proceedings). </note>
Reference: [5] <author> J.M. Lane and R.F. Riesenfeld, </author> <title> "Bounds on polynomials", </title> <journal> BIT, </journal> <volume> vol. 21, no. 1, </volume> <pages> pp. 112-117, </pages> <year> 1981. </year>
Reference-contexts: Normal Deviation criterion: The deviation of triangle normals from the surface normals should be bounded. To compute the bound on the step size in the parametric domain so as to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of cush bounds. <ref> [5] </ref>, [21], [22], [23]. The criteria listed above are related to each other and not all of them have to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [5] </ref>, [22], [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], [21]. <p> Note that all these computations are part of the preprocessing stage. Similarly, the maximum of f x (0; v) corresponds to computing the roots of f x v (0; v) = 0, which can be computed using root-finders or subdivision properties of Bezier curves <ref> [5] </ref>. Based on the solutions of these equations, we compute the maximum values of f x (u; v) in 16 Fig. 3. Undersampling the domain [0; 1] fi [0; 1]. Let the maximum value be at [u x ; v x ].
Reference: [6] <author> A.R. </author> <title> Forest, "On the rendering of surfaces", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 13, no. 2, </volume> <pages> pp. 253-259, </pages> <year> 1979, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature <ref> [6] </ref>, [14], [16], [17], [18], [19], [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1.
Reference: [7] <author> J. Kajiya, </author> <title> "Ray tracing parametric patches", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 16, no. 3, </volume> <pages> pp. 245-254, </pages> <year> 1982, </year> <note> (SIGGRAPH Proceedings). </note>
Reference: [8] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto, </author> <title> "Ray tracing trimmed rational surface patches", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 24, no. 4, </volume> <pages> pp. 337-345, </pages> <year> 1990, </year> <note> (SIGGRAPH Proceedings). </note>
Reference: [9] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn, "Scan line methods for displaying parametrically defined surfaces", </title> <journal> Communications of ACM, </journal> <volume> vol. 23, no. 1, </volume> <pages> pp. 23-34, </pages> <year> 1980. </year>
Reference: [10] <author> C.L. Bajaj, </author> <title> "Rational hypersurface display", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 24, no. 2, </volume> <pages> pp. 117-127, </pages> <year> 1990, </year> <title> (Symposium on Interactive 3D Graphics). </title>
Reference: [11] <author> S.S. Abi-Ezzi and L.A. Shirman, </author> <title> "The scaling behavior of viewing transformations", </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> vol. 13, no. 3, </volume> <pages> pp. 48-54, </pages> <year> 1993. </year>
Reference-contexts: Bound Computation We compute improved bounds for the rational surfaces in object space as part of a preprocessing phase. They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [11] </ref>, [23]. An algorithm for computation of bounds based on the size criterion is presented in [22]. However, the bounds in [22] need to be modified to use the mean value theorem for vector valued functions. <p> Given these bounds in object space, we compute the step size in screen space as a function of the viewing transformations. These bounds are invariant to rigid body transformations like rotations and translations. They vary with the perspective transformation matrix as shown in <ref> [11] </ref>. The computation of the bounds for the other difference criteria can be computed similarly. In one case we seek to bound the length of the vector connecting two points on the surface, and in the others we seek to bound the angle between tangents or normals.
Reference: [12] <author> R. Bedichek, C. Ebeling, G. Winkenbach, and T. DeRose, </author> <title> "Rapid low-cost display of spline surfaces", </title> <booktitle> in Proceedings of advanced reseach in VLSI, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [13] <author> T. DeRose and M. Bailey et al., "Apex: </author> <title> two architectures for generating parametric curves and surfaces", </title> <journal> The Visual Computer, </journal> <volume> vol. 5, no. 5, </volume> <pages> pp. 264-276, </pages> <year> 1989. </year>
Reference: [14] <institution> W.L. Luken, "Tessellation of trimmed NURB surfaces", Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year> <month> 31 </month>
Reference-contexts: At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], <ref> [14] </ref>, [16], [17], [18], [19], [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1.
Reference: [15] <author> W.L. Luken and Fuhua Cheng, </author> <title> "Rendering trimmed NURB surfaces", </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference: [16] <author> F. Cheng, </author> <title> "Computation techniques on NURBS surfaces", </title> <booktitle> in SIAM Conference on Geometric Design, </booktitle> <address> Tempe, AZ, </address> <year> 1993. </year>
Reference-contexts: At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], <ref> [16] </ref>, [17], [18], [19], [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1.
Reference: [17] <author> M. Shantz and S. Chang, </author> <title> "Rendering trimmed NURBS with adaptive forward differencing", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 189-198, </pages> <year> 1988, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], <ref> [17] </ref>, [18], [19], [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [18] <author> M. Shantz and S. Lien, </author> <title> "Shading bicubic patches", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 21, no. 4, </volume> <pages> pp. 189-196, </pages> <year> 1987, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], <ref> [18] </ref>, [19], [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [19] <author> D.R. Forsey and V. Klassen, </author> <title> "An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces", </title> <booktitle> in Proceedings of Graphics Interface, </booktitle> <year> 1990, </year> <pages> pp. 1-8. </pages>
Reference-contexts: At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], [18], <ref> [19] </ref>, [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [20] <author> A. Rockwood, K. Heaton, and T. Davis, </author> <title> "Real-time rendering of trimmed surfaces", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 107-117, </pages> <year> 1989, </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: The step size is computed as a function of these bounds and viewing parameters [5], [22], [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds <ref> [20] </ref>, [21]. We require only two mathematical formulations: one for the computation of the two `deviation' bounds, and the other for the other `difference' bounds. Let us first demonstrate it with the size criterion bound computations. <p> Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, different tessellations on two adjacent patches are possible. This could result in cracks in the rendered 19 image. To address this issue [23], <ref> [20] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary. <p> The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in <ref> [20] </ref>, [32] and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [21] <author> A. Rockwood, </author> <title> "A generalized scanning technique for display of parametrically defined surface", </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> vol. 7, no. 8, </volume> <pages> pp. 15-26, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: To compute the bound on the step size in the parametric domain so as to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of cush bounds. [5], <ref> [21] </ref>, [22], [23]. The criteria listed above are related to each other and not all of them have to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> The step size is computed as a function of these bounds and viewing parameters [5], [22], [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], <ref> [21] </ref>. We require only two mathematical formulations: one for the computation of the two `deviation' bounds, and the other for the other `difference' bounds. Let us first demonstrate it with the size criterion bound computations. <p> Let T OL be the user-specified tolerance in screen space. The step sizes along the u and v directions are given as <ref> [21] </ref>: n u = m max T OL fl min (W ij ) k W ij R ij W i;j+1 R i;j+1 k for (1 i m, 1 j n). In practice these bounds are good for polynomial surfaces only, when W ij = 1. <p> Most surfaces do not have highly varying curvature and are uniformly parametrized. E. Comparison of Methods We empirically compared our bound with those of Rockwood et. al. <ref> [21] </ref> and Abi-Ezzi & Shirman [22]. For each model, these comparisons were performed over a large number of user-driven model inspection runs with different user-specified tolerance values. We collated the averages of the number of triangles generated for each model. <p> The degrees of the patches in these models were between two and three in u as well as v. Some models, e.g. Dragon, 18 Fig. 4. T-Joint contained no rational patches making <ref> [21] </ref>'s bounds tighter. For a given tolerance, our bounds result in about 31% fewer triangles than [21] and about 20% fewer than [22]. Color plate A displays the wireframes and shaded images of the pencil and goblet models computed using the three methods. Model Number of Our Algorithm [21]'s Algorithm [22]'s Algorithm Patches Num. Tris. Ratio Num. Tris. Ratio Num. Tris.
Reference: [22] <author> S.S. Abi-Ezzi and L.A. Shirman, </author> <title> "Tessellation of curved surfaces under highly varying transformations", </title> <booktitle> Proceedings of Eurographics, </booktitle> <pages> pp. 385-397, </pages> <year> 1991. </year>
Reference-contexts: To compute the bound on the step size in the parametric domain so as to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of cush bounds. [5], [21], <ref> [22] </ref>, [23]. The criteria listed above are related to each other and not all of them have to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters [5], <ref> [22] </ref>, [23]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], [21]. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [11], [23]. An algorithm for computation of bounds based on the size criterion is presented in <ref> [22] </ref>. However, the bounds in [22] need to be modified to use the mean value theorem for vector valued functions. In addition, due to our exact extrema computation, for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [11], [23]. An algorithm for computation of bounds based on the size criterion is presented in <ref> [22] </ref>. However, the bounds in [22] need to be modified to use the mean value theorem for vector valued functions. In addition, due to our exact extrema computation, for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve. It is applied in a similar manner to the surfaces. <p> Most surfaces do not have highly varying curvature and are uniformly parametrized. E. Comparison of Methods We empirically compared our bound with those of Rockwood et. al. [21] and Abi-Ezzi & Shirman <ref> [22] </ref>. For each model, these comparisons were performed over a large number of user-driven model inspection runs with different user-specified tolerance values. We collated the averages of the number of triangles generated for each model. <p> Some models, e.g. Dragon, 18 Fig. 4. T-Joint contained no rational patches making [21]'s bounds tighter. For a given tolerance, our bounds result in about 31% fewer triangles than [21] and about 20% fewer than <ref> [22] </ref>. Color plate A displays the wireframes and shaded images of the pencil and goblet models computed using the three methods. Model Number of Our Algorithm [21]'s Algorithm [22]'s Algorithm Patches Num. Tris. Ratio Num. Tris. Ratio Num. Tris.
Reference: [23] <author> D. Filip, R. Magedson, and R. Markot, </author> <title> "Surface algorithms using bounds on derivatives", </title> <booktitle> Computer Aided Geometric Design, </booktitle> <volume> vol. 3, no. 4, </volume> <pages> pp. 295-311, </pages> <year> 1986. </year>
Reference-contexts: Adaptive tessellation algorithms normally use a recursive approach to subdivision based on `flatness criteria' and surface areas. At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice <ref> [23] </ref>. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], [18], [19], [25]. We stored the sequence of viewpoints used in a user-run 3 of the system. <p> To compute the bound on the step size in the parametric domain so as to satisfy these criteria, we need to compute bounds on polynomials. There is considerable literature on computation of cush bounds. [5], [21], [22], <ref> [23] </ref>. The criteria listed above are related to each other and not all of them have to be used. Further, these criteria are functions of the first, second and higher order derivatives of the surface vector. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters [5], [22], <ref> [23] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size as a function of these bounds [20], [21]. <p> Bound Computation We compute improved bounds for the rational surfaces in object space as part of a preprocessing phase. They are used to compute the step sizes as a function of the viewing parameters as shown in [11], <ref> [23] </ref>. An algorithm for computation of bounds based on the size criterion is presented in [22]. However, the bounds in [22] need to be modified to use the mean value theorem for vector valued functions. <p> The optimal solution to that problem would be based on the deviation criterion. The bound on deviation is computed using results from <ref> [23] </ref>: For a linearly parametrized triangle T = l (u; v) between three points on a surface at l (0; 0); l (l 1 ; 0) and l (0; l 2 ): (u;v)2T 1 (l 2 2 M 3 ); where M 1 = max kF uu (u; v)k; M 2 <p> Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, different tessellations on two adjacent patches are possible. This could result in cracks in the rendered 19 image. To address this issue <ref> [23] </ref>, [20] suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary.
Reference: [24] <author> S. Kumar, D. Manocha, and A. Lastra, </author> <title> "Interactive display of large scale NURBS models", in Symposium on Interactive 3D Graphics, </title> <address> Monterey, CA, </address> <year> 1995, </year> <pages> pp. 51-58. </pages>
Reference-contexts: On multiple-processor machines the algorithm statically partitions the model, distributing it to the processors to balance the load. A preliminary version of this paper has appeared as <ref> [24] </ref>. In the rest of this paper, a basic familiarity with NURBS and Bezier surfaces is assumed. In Section II we analyze the problem of computing polygonal approximations to surface models and give an overview of our approach. In Section III, we consider visibility processing and explain back-patch culling.
Reference: [25] <author> G. Farin, </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide, </title> <publisher> Academic Press Inc., </publisher> <year> 1993. </year>
Reference-contexts: Finally, screen space refers to the 2D coordinate system defined by projecting the image space onto the plane of the screen. Given a NURBS model, we use knot insertion to decompose each NURBS surface into a series of rational Bezier patches <ref> [25] </ref>. Closely spaced knots, with tolerance less than 2 fi 10 5 , are coerced to the same value before knot insertion 2 . NURBS surfaces are thus decomposed into a series of Bezier surfaces. <p> This check, combined with z-buffering, can calculate complete visibility quite rapidly. A Bezier surface, F (u; v) = (X (u; v); Y (u; v); Z (u; v); W (u; v)); is contained in the convex polytope of the control points <ref> [25] </ref>. Let us denote this convex polytope as P F . We also compute an axis-aligned bounding box, B F , defined by eight vertices as the smallest volume bounding box enclosing P F . A. <p> At any stage, if the tessellation is not satisfactory, it is further subdivided. For large models, empirical results suggest that uniform subdivision methods are much faster in practice [23]. A. Adaptive Tessellation Different algorithms for adaptive subdivision are presented in the literature [6], [14], [16], [17], [18], [19], <ref> [25] </ref>. We stored the sequence of viewpoints used in a user-run 3 of the system. For each of these sequences of viewpoints, we computed, off-line, an adaptive tessellation of each patch using the following algorithm: 1. Transform the control points of the patch to screen space. 2.
Reference: [26] <author> B. O' Neill, </author> <title> Elementary Differential Geometry, </title> <publisher> Academic Press, </publisher> <year> 1966. </year>
Reference-contexts: Thus for each u and v, the normal direction is given by N (u; v) = F u fi F v Bezier patches belong to the class of surfaces called orientable surfaces: their normals can be oriented `inside' or `outside' the surface <ref> [26] </ref>. For a given model we can orient all patches by flipping the order of control points such that N (u; v) points outside for each u; v for each patch. <p> G of a surface, F, is a map G : F ! S 2 , the 2-Sphere, which takes point F (u; v) into the translation of the vector U (u; v) to the origin, where U (u; v) is the unit vector in the direction of N (u; v) <ref> [26] </ref>. Thus the function G (u; v) can be used to compute the unit normal of the surface at the point (u; v). This can be relatively expensive to compute. We just use a pseudo-Gauss map, which gives the normal direction for each (u; v).
Reference: [27] <author> D. Manocha and J. Demmel, </author> <title> "Algorithms for intersecting parametric and algebraic curves", </title> <booktitle> in Proceedings of Graphics Interface, </booktitle> <year> 1992, </year> <pages> pp. 232-241. </pages>
Reference-contexts: The resulting algorithms are fast, accurate, need no initial guess to the solutions and do not suffer from convergence problems <ref> [27] </ref>. III. Visibility Computations Given a large model consisting of Bezier patches, not all patches are typically visible from a viewpoint. A good part of the model may be clipped by the viewing volume. The rest of the model is tessellated and the triangles are sent down the rendering pipeline. <p> We compute all roots and pick the maximum of those. Thus the problem of computing the maximum derivative vector is equivalent to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [27] </ref>, [31].
Reference: [28] <author> M.F. Deering and S.R. Nelson, "Leo: </author> <title> A system for cost effective 3d shaded graphics", </title> <booktitle> in Proceedings of ACM Siggraph, </booktitle> <year> 1993, </year> <pages> pp. 101-108. </pages>
Reference: [29] <author> S. Krishnan and D. Manocha, </author> <title> "Global visibility and hidden surface algorithms for free form surfaces", </title> <type> Tech. Rep. </type> <institution> TR94-063, Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: In general, the exact computation of the visible portions of a NURBS model is a non-trivial problem requiring silhouette computation <ref> [29] </ref>. In this section, we show that it is relatively simple to perform a visibility check to find most of the patches that are completely invisible. This check, combined with z-buffering, can calculate complete visibility quite rapidly.
Reference: [30] <author> S. Kumar and D. Manocha, </author> <title> "Hierarchical visibility culling for spline models", </title> <booktitle> in Proceedings of Graphics Interface, </booktitle> <year> 1996. </year>
Reference-contexts: Each point on N (u; v) corresponds to a direction on F (u; v) and P N and B N define a multi-faced pyramid in which all these directions lie <ref> [30] </ref>. Testing for visibility reduces to checking whether each of these control points, or just the bounding box B N , is in the half-space H. Instead of using a sphere to bound the points on the surface, a rectangular box or the convex hull can be used.
Reference: [31] <author> T.W. </author> <title> Sederberg, "Algorithms for algebraic curve intersection", </title> <booktitle> Computer-Aided Design, </booktitle> <volume> vol. 21, no. 9, </volume> <pages> pp. 547-555, </pages> <year> 1989. </year>
Reference-contexts: We compute all roots and pick the maximum of those. Thus the problem of computing the maximum derivative vector is equivalent to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection [27], <ref> [31] </ref>.
Reference: [32] <author> R. Nash, </author> <year> 1993, </year> <title> Silicon Graphics, </title> <type> Personal Communication. </type>
Reference-contexts: The images were rendered with Gouraud shading. The standard SGI-GL implementation is based on the algorithm presented in [20], <ref> [32] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations (for example, the design constraints may be different), we performed the following experiments using identical sets of viewing parameters.
Reference: [33] <author> D. </author> <title> Banks, "Interactive manipulation and display of two-dimensional surfaces in four-dimensional space", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 26, </volume> <pages> pp. 197-207, </pages> <year> 1992, </year> <title> (Special Issue on Symposium on Interactive 3D Graphics). </title>
Reference-contexts: These routines may generate arbitrary geometry in immediate mode for the rendering engine to display. This feature has been used successfully for problems which require close coupling between computation and the generation of geometry <ref> [33] </ref>. The tessellation algorithm is implemented as a set of user functions running on the GPs. The algorithm does not require any inter-processor communication during execution. This property not only improves the parallel speedup, but also will make it easier to port the code to another multi-processor machine.
Reference: [34] <author> D. Ellsworth, H. Good, and B. Tebbs, </author> <title> "Distributing display lists on a multicomputer", </title> <journal> ACM Computer Graphics, </journal> <volume> vol. 24, no. 2, </volume> <year> 1990, </year> <title> (In Symposium on Interactive 3D Graphics). </title>
Reference-contexts: At the same time, processors with patches occupying a small area on screen may be idle. We experimented with a number of schemes. A random distribution scheme <ref> [34] </ref> does not perform well for our application. The reason is that the cost of rendering a patch can vary significantly. We made an explicit adjacency-based distribution and achieved better performance (see Table V).
Reference: [35] <author> S. Kumar and D. Manocha, </author> <title> "Efficient rendering of trimmed NURBS surfaces", </title> <booktitle> Computer-Aided Design, </booktitle> <volume> vol. 27, no. 7, </volume> <pages> pp. 509-521, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: The preprocessing is costly for applications involving interactive design. It would be nice to extend some of techniques presented in this paper to cases when models can be modified on-line. The techniques described in this paper have been extended to trimmed Bezier surfaces <ref> [35] </ref>. In particular, coherence allows us to efficiently triangulate simple polygons without any artifacts. We are now working on extending the visibility algorithm to make it more effective.

References-found: 35

