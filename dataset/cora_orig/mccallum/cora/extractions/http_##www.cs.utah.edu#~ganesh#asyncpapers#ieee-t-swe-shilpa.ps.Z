URL: http://www.cs.utah.edu/~ganesh/asyncpapers/ieee-t-swe-shilpa.ps.Z
Refering-URL: http://www.cs.utah.edu/~ganesh/asyncpapers.html
Root-URL: 
Email: (akella@cs.utah.edu)  (ganesh@bliss.utah.edu)  
Title: Specification and Validation of Control Intensive ICs in hopCP  
Author: VENKATESH AKELLA GANESH GOPALAKRISHNAN 
Keyword: asynchrony, behavioral simulation, formal methods, hardware description languages, formal specification and validation  
Address: Salt Lake City, Utah 84112  
Affiliation: Dept. of Computer Science University of Utah  
Abstract: Control intensive ICs pose a significant challenge to the users of formal methods in designing hardware. These ICs have to support a wide variety of requirements including synchronous and asynchronous operations, polling and interrupt-driven modes of operation, multiple concurrent threads of execution, non-trivial computational requirements, and programmability. In this paper, we illustrate the use of formal methods in the design of a control intensive IC called the "Intel 8251" Universal Synchronous/Asynchronous Receiver/Transmitter (USART), using our hardware description language `hopCP'. A feature of hopCP is that it supports communication via asynchronous ports in addition to synchronous message passing. Asynchronous ports are distributed shared variables writable by exactly one process. We show the usefulness of this combination of communication constructs. We outline algorithms to determine safe usages of asynchronous ports, and also to discover other static properties of the specification. We discuss a compiled-code concurrent functional simulator called CFSIM, as well as the use of concurrent testers for driving CFSIM. The use of a semantically well specified and simple language, and the associated analysis/simulation tools helps conquer the complexity of specifying and validating control intensive ICs. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Akella, V., and Gopalakrishnan, G. hopCP: </author> <title> A Concurrent Hardware Description Language. </title> <type> Tech. Rep. </type> <institution> UUCS-91-021, Department of Computer Science, University of Utah, </institution> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: In this paper, we develop the specification of the 8251 in our HDL hopCP|a semantically well specified and simple language <ref> [1] </ref>. The design of control intensive hardware systems has a lot in common with the specification and verification of concurrent software systems. Several verification techniques for concurrent software have been widely studied [7]. <p> We do this by presenting the hopCP language, outlining its operational semantics (detailed in <ref> [1] </ref>), and present tools and techniques that help validate hopCP descriptions. <p> IN HOPCP 19 RCVR_ASYNC [mo, size, data] &lt;= ((not (size=0)) -&gt; RxD?y -&gt; RCVR_ASYNC [mo, (Decrement size), (AccumulateSerialData data y)]) |((size =0) -&gt; RxD?pin -&gt; RCVR_PROCESS_DATA [mo, data, (CheckParityError data mo pin)]); RCVR_PROCESS_DATA [mo, data, perror] &lt;= ((IsFalse extReset) -&gt; RCVR_START []) |(intReset? -&gt; RCVR_INITIATE []) |(RxD?sb -&gt;((sb=0) -&gt; SEND_DATA_TO_MAIN <ref> [mo, data, perror, 1] </ref>) |((sb=1) -&gt; SEND_DATA_TO_MAIN [mo, data, perror, 0])); SEND_DATA_TO_MAIN [mode, data, pe, fe] &lt;= ((IsFalse extReset) -&gt; RCVR_START []) |(intReset? -&gt; RCVR_INITIATE []) |((IsTrue ReceiverBufferEmpty) -&gt; rcvrstatus!(MakeAsyncStatus pe fe 0 1) -&gt; rcvrmain!data -&gt; RCVR_EXECUTE [mode,0,0]) | ((not (IsTrue ReceiverBufferEmpty)) -&gt; rcvrstatus!(MakeAsyncStatus pe fe 1 1) -&gt; rcvrmain!data <p> Note that, in the above example a 1 and a 2 are primitive actions. The notion of synchronization and value communication can be extended in a similar way to compound actions. The details of semantics of parComp are presented in <ref> [1] </ref>. parComp has been implemented in Standard ML of New Jersey [5] in the prototype hopCP design environment on a SUN sparcstation.
Reference: 2. <author> Akella, V., and Gopalakrishnan, G. </author> <title> Static Analysis Techniques for the Synthesis of Efficient Asynchronous Circuits. </title> <type> Tech. Rep. </type> <institution> UUCS-91-018, Department of Computer Science, University of Utah, </institution> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: SPECIFICATION AND VALIDATION OF CONTROL INTENSIVE ICS IN HOPCP 21 * A compiled-code behavioral simulator to establish functional correctness of the hopCP speci fications. In section 5.1, we introduce the algorithm parComp. In section 5.2, we will briefly introduce the seriality-checking algorithm. These algorithms have been detailed in <ref> [2] </ref>. Section 5.3 presents the compiled code functional simulator that can be used to debug hopCP descriptions. Section 5.4 presents how hopCP specifications are debugged using tester processes. 5.1 Behavioral Inference via Parallel Composition In this section we will briefly introduce parComp and discuss its performance on the USART example. <p> All the phases of the seriality-checking procedure have been formalized and implemented in the hopCP design environment. The details are presented in <ref> [2] </ref>. This procedure was particularly useful on the USART specification because of its complexity. Several errors in the unsafe usage of the asynchronous ports were revealed.
Reference: 3. <author> Akella, V., and Gopalakrishnan, G. CFSIM: </author> <title> A Compiled-Code Concurrent Functional Simulator for VLSI Systems. </title> <type> Tech. Rep. </type> <institution> UUCS-TR-92-002, Department of Computer Science, University of Utah, </institution> <month> Jan. </month> <year> 1992. </year> <note> To appear in International Journal in Computer Simulation. </note>
Reference-contexts: CFSIM is compiled-code concurrent functional simulator for hopCP specifications obtained by translating H F Gs into CML (Concurrent ML) source code. The details of CFSIM are described in <ref> [3] </ref>. CML is an extension to Standard ML of New Jersey to support first-class synchronous operations [35]. CML being higher-order facilitates building concurrent-programming abstractions and is implemented efficiently capitalizing on the continuation-passing style technology of the SML of New Jersey compiler [6]. <p> The `[]' operator is implemented by choose combinator in CML and the `;' operator is implemented by directly in SML. The crux of the simulator is in implementing compound actions and multiway rendezvous whose implementation is discussed in <ref> [3] </ref>.
Reference: 4. <author> Akella, V., and Gopalakrishnan, G. SHILPA: </author> <title> A High-Level Synthesis System for Self-Timed Circuits. </title> <booktitle> In International Conference on Computer-aided Design, </booktitle> <address> ICCAD 92 (Nov. </address> <year> 1992), </year> <pages> pp. 587-591. </pages>
Reference-contexts: Although a language such as hopCP cannot be used to describe all the operational aspects of a control intensive IC, it is well suited for writing high-level descriptions that make the global properties of interest quite explicit. Given the increasing prevalence of high-level synthesis tools <ref> [31, 4, 17] </ref>, descriptions such as written in hopCP can be compiled to derive large portions of the silicon implementation of control intensive ICs. We now proceed to describe the 8251 in great detail. The 8251 can be programmed by the CPU to operate under many serial data transmission schemes.
Reference: 5. <author> Appel, A., and MacQueen, D. </author> <title> A Standard ML compiler. </title> <booktitle> In Functional Programming Languages and Computer Architecture (Sept. </booktitle> <year> 1987). </year>
Reference-contexts: The notion of synchronization and value communication can be extended in a similar way to compound actions. The details of semantics of parComp are presented in [1]. parComp has been implemented in Standard ML of New Jersey <ref> [5] </ref> in the prototype hopCP design environment on a SUN sparcstation. It exhibits acceptable runtimes of the order of seconds on the 8251 USART example. 5.2 Seriality Checking and its Uses Determining whether two specific actions of an HFG are serial or are potentially concurrent has numerous applications.
Reference: 6. <author> Appel, A. W. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge Univ. Press, </publisher> <year> 1992. </year> <note> ISBN 0-521-41695-7. </note>
Reference-contexts: CFSIM is compiled-code concurrent functional simulator obtained by translating hopCP specifications into CML (Concurrent ML) source code. CML facilitates building concurrent-programming abstractions and is implemented efficiently capitalizing on the continuation-passing style technology of the SML of New Jersey compiler <ref> [6, 35] </ref>. <p> The details of CFSIM are described in [3]. CML is an extension to Standard ML of New Jersey to support first-class synchronous operations [35]. CML being higher-order facilitates building concurrent-programming abstractions and is implemented efficiently capitalizing on the continuation-passing style technology of the SML of New Jersey compiler <ref> [6] </ref>. SPECIFICATION AND VALIDATION OF CONTROL INTENSIVE ICS IN HOPCP 23 The first step in the generation of the simulator in CML is to decompose the hopCP specifications into sequential HF Gs .
Reference: 7. <author> Apt, K. R., and Olderog, E.-R. </author> <title> Verification of Sequential and Concurrent Programs. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> ISBN 0-387-97532-2. </note>
Reference-contexts: The design of control intensive hardware systems has a lot in common with the specification and verification of concurrent software systems. Several verification techniques for concurrent software have been widely studied <ref> [7] </ref>. Research prototypes embodying some of these techniques (such as the Concurrency Workbench [12] and COSPAN [21]) are also available.
Reference: 8. <author> Barbacci, M. R. </author> <title> Instruction Set Processor Specifications (ISPS): The Notation and Its Applications. </title> <journal> IEEE Transactions on Computers C-30, </journal> <month> 1 (Jan. </month> <year> 1981), </year> <pages> 24-40. </pages>
Reference-contexts: These informal descriptions are prone to misinterpretations, and are not machine readable. They cannot be used as a basis for design validation. Lately, such ICs are being specified in HDLs. For example, the 8251 USART has been specified in many HDLs such as ISPS <ref> [8] </ref>, VHDL [44], and Verilog [40, 43]. However, when studied from a formal point of view, these HDLs have many shortcomings. None of the currently popular HDLs (such as referred to above) have a well specified and simple formal semantics.
Reference: 9. <author> Boyer, and Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Hence, tools such as CFSIM can complement other finite state validation tools. Other formal verification systems such as HOL [19] and Nqthm <ref> [9] </ref> are considerably more powerful and can, in principle, deal with systems with potentially unbounded amounts of state.
Reference: 10. <author> Brunvand, E. </author> <title> Translating Concurrent Communicating Programs into Asynchronous Circuits. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: In this section we will compare the hopCP specification of the 8251 with its HardwareC and ISPS specifications. We will also touch 20 VENKATESH AKELLA, GANESH GOPALAKRISHNAN upon the drawbacks of describing the 8251 in a language like Occam <ref> [10] </ref> which has been advocated for the specification of asynchronous circuits. 4.5.1 ISPS ISPS is a procedural language augmented with constructs to describe synchronous hardware. <p> However, HardwareC has the ability to specify resource and timing constraints which are not provided in hopCP, at present. 4.5.3 CSP based Languages CSP based languages like Occam used in <ref> [10] </ref> and Trace Theory used in [15] have the disadvantage of supporting only synchronous message passing. It is awkward to model asynchronous phenomena like interrupts and status and reset operations in such languages which makes them restrictive for hardware specification.
Reference: 11. <author> Charlesworth, A. </author> <title> The Multiway Rendezvous. </title> <journal> ACM Transactions on Programming Languages and Systems 9, </journal> <month> 3 (July </month> <year> 1987), </year> <pages> 350-366. </pages> <note> 30 VENKATESH AKELLA, GANESH GOPALAKRISHNAN </note>
Reference-contexts: It is possible to employ synchronous ports which deal only with control and do not have data. Multiway rendezvous is a powerful notion which facilitates the specification of a wide variety of concurrent algorithms very naturally <ref> [11] </ref>. It subsumes broadcast style of communication (point to multipoint communication) which is very natural in hardware, but not supported by many popular HDLs currently being used for synthesis. <p> agent willing to perform a data query corresponding to a data assertion. (The converse of the situation|more than one agent asserting a value on the same channel|is not supported in hopCP.) Multiway rendezvous is a powerful notion which facilitates the specification of a wide variety of concurrent algorithms very naturally <ref> [11] </ref>. It subsumes broadcast style of communication (point to multipoint communication) which is very natural in hardware. Multiway rendezvous is not supported by most HDLs currently being used for high level synthesis. Without multiway rendezvous, many situations become awkward to model.
Reference: 12. <author> Cleveland, R., Parrow, J., and Steffen, B. </author> <title> The concurrency workbench: A semantics based tood for the verification of concurrent systems. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-89-83, Laboratory for Foundations of Computer Science, Univ of Edinburgh, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The design of control intensive hardware systems has a lot in common with the specification and verification of concurrent software systems. Several verification techniques for concurrent software have been widely studied [7]. Research prototypes embodying some of these techniques (such as the Concurrency Workbench <ref> [12] </ref> and COSPAN [21]) are also available. In addition, formalisms such as trace theory [13] and Temporal Logic [30] have been applied for the verification of speed independent asynchronous circuits [14] as well as for verifying concurrent protocols such as cache coherence protocols.
Reference: 13. <author> Dill, D. L. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <publisher> MIT Press, </publisher> <year> 1989. </year> <note> An ACM Distinguished Dissertation. </note>
Reference-contexts: Several verification techniques for concurrent software have been widely studied [7]. Research prototypes embodying some of these techniques (such as the Concurrency Workbench [12] and COSPAN [21]) are also available. In addition, formalisms such as trace theory <ref> [13] </ref> and Temporal Logic [30] have been applied for the verification of speed independent asynchronous circuits [14] as well as for verifying concurrent protocols such as cache coherence protocols. These tools have also been used by us in our past work [18, 33].
Reference: 14. <author> Dill, D. L., Nowick, S. M., and Sproull, R. F. </author> <title> Specification and automatic verification of self-timed queues. Formal Methods in System Design 1, </title> <month> 1 (July </month> <year> 1992), </year> <pages> 29-62. </pages>
Reference-contexts: Research prototypes embodying some of these techniques (such as the Concurrency Workbench [12] and COSPAN [21]) are also available. In addition, formalisms such as trace theory [13] and Temporal Logic [30] have been applied for the verification of speed independent asynchronous circuits <ref> [14] </ref> as well as for verifying concurrent protocols such as cache coherence protocols. These tools have also been used by us in our past work [18, 33].
Reference: 15. <author> Ebergen, J. C. </author> <title> Translating Programs into Delay Insensitive Circuits. </title> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1989. </year> <note> CWI Tract 56. </note>
Reference-contexts: Also, by presenting the description of the 8251 in a semantically well specified notation, we believe that some of the difficulties of formally verifying such systems will be brought to the surface. Currently there is a growing trend towards applying formal methods in the design of real-world hardware systems <ref> [39, 16, 15] </ref>. Most of the current efforts do not address ICs that, in addition to exhibiting control intensive behavior also support non-trivial computations. <p> These HDLs are designed based on a single paradigm; for example, many of these HDLs adopt a purely functional view of computations [24, 38], many adopt a formal process model [22, 36] while others are based on special theories like the Trace theory <ref> [15] </ref>. An HDL based on a single paradigm (e.g. functional view of computations) is well suited for a limited class of circuits (e.g. computation oriented), but fares poorly when it comes to dealing with both computations and control/communication activities. <p> However, HardwareC has the ability to specify resource and timing constraints which are not provided in hopCP, at present. 4.5.3 CSP based Languages CSP based languages like Occam used in [10] and Trace Theory used in <ref> [15] </ref> have the disadvantage of supporting only synchronous message passing. It is awkward to model asynchronous phenomena like interrupts and status and reset operations in such languages which makes them restrictive for hardware specification.
Reference: 16. <author> Gopalakrishnan, G., and Fujimoto, R. </author> <title> Design and verification of the rollback chip using hop: A case study of formal methods applied to hardware design. </title> <type> Tech. Rep. </type> <institution> UU-CS-TR-91-015, University of Utah, Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: Also, by presenting the description of the 8251 in a semantically well specified notation, we believe that some of the difficulties of formally verifying such systems will be brought to the surface. Currently there is a growing trend towards applying formal methods in the design of real-world hardware systems <ref> [39, 16, 15] </ref>. Most of the current efforts do not address ICs that, in addition to exhibiting control intensive behavior also support non-trivial computations.
Reference: 17. <author> Gopalakrishnan, G., and Josephson, L. </author> <title> Towards amalgamating the synchronous and asynchronous styles. In TAU 93: Timing Aspects of VLSI, </title> <address> Malente, Germany (Sept. 1993), </address> <publisher> ACM. </publisher>
Reference-contexts: Although a language such as hopCP cannot be used to describe all the operational aspects of a control intensive IC, it is well suited for writing high-level descriptions that make the global properties of interest quite explicit. Given the increasing prevalence of high-level synthesis tools <ref> [31, 4, 17] </ref>, descriptions such as written in hopCP can be compiled to derive large portions of the silicon implementation of control intensive ICs. We now proceed to describe the 8251 in great detail. The 8251 can be programmed by the CPU to operate under many serial data transmission schemes.
Reference: 18. <author> Gopalakrishnan, G., Michell, N., Brunvand, E., and Nowick, S. M. </author> <title> A correctness criterion for asynchronous circuit verification and optimization. </title> <journal> IEEE Transactions on Computer-Aided Design (1992). </journal> <note> Accepted for Publication. </note>
Reference-contexts: In addition, formalisms such as trace theory [13] and Temporal Logic [30] have been applied for the verification of speed independent asynchronous circuits [14] as well as for verifying concurrent protocols such as cache coherence protocols. These tools have also been used by us in our past work <ref> [18, 33] </ref>. However, few of these tools or techniques have been applied for the verification of real-world control intensive hardware systems where one has to address data dependent control flows, exception handling, and similar issues.
Reference: 19. <author> Gordon, M. J. </author> <title> Mechanizing programming logics in higher order logic. </title> <booktitle> In 1988 Banff Hardware Verification Workshop, </booktitle> <address> Banff, </address> <month> June </month> <year> 1988 (1988), </year> <note> G.Birtwistle and P.A.Subrahmanyam, Eds. Invited Paper, to appear as a chapter in a forthcoming Springer-Verlag book. </note>
Reference-contexts: Hence, tools such as CFSIM can complement other finite state validation tools. Other formal verification systems such as HOL <ref> [19] </ref> and Nqthm [9] are considerably more powerful and can, in principle, deal with systems with potentially unbounded amounts of state.
Reference: 20. <author> Hall, A. </author> <title> Seven myths of formal methods. </title> <journal> IEEE Software, </journal> <month> 9 (Sept. </month> <year> 1990). </year>
Reference-contexts: We do this by presenting the hopCP language, outlining its operational semantics (detailed in [1]), and present tools and techniques that help validate hopCP descriptions. As Hall points out <ref> [20] </ref>, even without conducting formal verification at all levels of design representation, the application of formal methods can enhance the degree of confidence in a design, help discover design flaws, and promote overall understanding of the design.
Reference: 21. <author> Har'El, Z., and Kurshan, R. P. </author> <title> Software for analytical development of communication protocols. </title> <journal> AT&T Technical Journal (Jan. </journal> <note> 1990). To appear. </note>
Reference-contexts: The design of control intensive hardware systems has a lot in common with the specification and verification of concurrent software systems. Several verification techniques for concurrent software have been widely studied [7]. Research prototypes embodying some of these techniques (such as the Concurrency Workbench [12] and COSPAN <ref> [21] </ref>) are also available. In addition, formalisms such as trace theory [13] and Temporal Logic [30] have been applied for the verification of speed independent asynchronous circuits [14] as well as for verifying concurrent protocols such as cache coherence protocols. <p> It is interesting to compare the style of validation we have presented against that offered in verification tools such as SMV [30] and COSPAN <ref> [21] </ref>. SMV is a system that allows concurrent finite-state systems to be described in a language reminiscent of data-flow languages as well as guarded-command languages. The transition relation underlying finite state systems modeled in SMV are represented using binary decision diagrams (BDDs) which are often efficient representations for relations.
Reference: 22. <author> Hoare, C. A. R. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: These HDLs are designed based on a single paradigm; for example, many of these HDLs adopt a purely functional view of computations [24, 38], many adopt a formal process model <ref> [22, 36] </ref> while others are based on special theories like the Trace theory [15]. <p> It is awkward to model asynchronous phenomena like interrupts and status and reset operations in such languages which makes them restrictive for hardware specification. There are operators suggested in <ref> [22] </ref> to correct this defficiency but they are yet to appear in a realistic HDL. 5 Tools for Analysis of hopCP Specifications High-Level specifications of complex protocols are of little use if they are not adequately supported by tools to analyze them and reason about them.
Reference: 23. <author> Intel. </author> <title> 8251A Programmable Communication Interface. </title> <booktitle> In Intel Microprocessor and Peripheral Handbook (1986), </booktitle> <pages> pp. </pages> <month> 6.122-6.138. </month>
Reference-contexts: We can illustrate many of the above mentioned problems, as well as possible solutions, through one example: the Intel 8251 Universal Synchronous/Asynchronous Receiver/Transmitter (USART) <ref> [23] </ref>. Integrated circuits (ICs) such as the 8251 USART exhibit diverse behaviors. They typically possess independent threads of execution, have coexistent synchronous (clocked) and asynchronous (unclocked) subcomponents, support multiple modes of operation, such as the interrupt-driven and the polled modes. <p> We begin by pointing out some of the essential difficulties of specifying a system such as the 8251. We then provide the details, almost verbatim from the manual pages <ref> [23] </ref>. Intel 8251 is a USART designed for data communication with Intel's microprocessor families. It possess independent threads of execution, has coexistent synchronous (clocked) and asynchronous (unclocked) subcomponents, and supports multiple modes of operation, such as the interrupt-driven and the polled modes. <p> They capture the decoding of the mode words and assembling the status words based on their format in <ref> [23] </ref>. Note that the functions are expressed in a first-order functional language with built-in routines for bit-level manipulations. subvector (x,y,z) returns the value of the integer formed by the bits from y to z from the bitvector denoted by x while orb does a simple bitwise OR operation.
Reference: 24. <author> Johnson, S. D. </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> The MIT Press, </publisher> <year> 1984. </year> <note> An ACM Distinguished Dissertation-1983. </note>
Reference-contexts: These HDLs are designed based on a single paradigm; for example, many of these HDLs adopt a purely functional view of computations <ref> [24, 38] </ref>, many adopt a formal process model [22, 36] while others are based on special theories like the Trace theory [15].
Reference: 25. <author> Ku, D., and Micheli, G. D. </author> <title> HardwareC A Language for Hardware Design, Version 2.0. </title> <type> Tech. Rep. </type> <institution> CSL-TR-90-419, Computer Science Laboratory, Stanford University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: character is received from the MAIN module, padded with start and stop bits and shifted out serially (least significant bit first) on the TxD output at a rate determined by the baud rate setting in the mode word. 4.5 Comparison With Existing Work Intel 8251 has been specified in HardwareC <ref> [25] </ref> and a variant of ISPS [42]. The specifications are available with the distribution of high-level synthesis benchmarks. In this section we will compare the hopCP specification of the 8251 with its HardwareC and ISPS specifications. <p> ISPS specifications are that the ISPS specification (i) lacks abstraction in the sense that it describes on particular implementation of the 8251, based on synchronization flip-flops (ii) does not have constructs to expressing parallel behavior explicitly. (iii) the computation is described in a imperative language. 4.5.2 HardwareC The language hardwareC <ref> [25] </ref> comes closest to hopCP in terms of the communication constructs it uses. This is encouraging because starting from similar motivations about the real-world scenarios that we wish to model, we have independently ended up selecting the same set of communication constructs in our respective HDLs.
Reference: 26. <author> Lamport, L. </author> <title> A Simple Approach to Specifying Concurrent Systems. </title> <journal> Communications of the ACM 32, </journal> <month> 1 (Jan. </month> <year> 1989), </year> <pages> 32-45. </pages>
Reference-contexts: There are usually two ways of validating a specification: (i) prove liveness and safety properties of the specification <ref> [26] </ref>; and (ii) high-level simulation. We follow the second approach. We provide a simulation environment called CFSIM to validate hopCP specifications.
Reference: 27. <author> Logrippo, L., Obaid, A., J.P.Briand, and Fehri, M. </author> <title> An Interpreter for LOTOS, a Specification Language for Distributed Systems. </title> <journal> Software|Practice and Experience 18, </journal> <month> 4 (Apr. </month> <year> 1988), </year> <pages> 365-385. </pages>
Reference-contexts: The multiway rendezvous advocated in hopCP is simpler than that in the protocol specification language LOT OS <ref> [27] </ref>, in the sense that the multiway rendezvous and its participants can be statically determined by a simple analysis. This is because we do not have dynamic process creation in hopCP. 3 An Informal Description of 8251 In this section we present the functional description of Intel 8251 USART.
Reference: 28. <author> Page, Ian and Luk, Wayne. </author> <title> Compiling Occam into Field-Programmable Gate Arrays. </title> <booktitle> International Workshop on Field Programmable Logic and Applications, </booktitle> <month> September, </month> <year> 1991, </year> <institution> Oxford University, UK. </institution>
Reference-contexts: eXene (a muti-threaded interface to X protocol), distributed ML and distributed Nuprl (a theorem proving environment) implementations. 1.2.3 High Level Validation using Testers The behavioral specification of complex control intensive ICs can be hard to follow, even if such ICs are described in a modern concurrent HDL, such as Occam <ref> [34, 32, 28] </ref> or hopCP. Although a simulator can help "animate" the specification for selected scenarios, output waveform traces produced by typical simulation runs offer very little help in understanding or debugging complex control intensive ICs. In the hopCP system, high level validation is supported in two ways.
Reference: 29. <author> Martin, A. J., Burns, S., T.K.Lee, D.Borkovic, and P.J.Hazewindus. </author> <title> The design of an asynchronous microprocessor. </title> <booktitle> In Proc. Decennial Caltech Conference on VLSI (1989), </booktitle> <editor> C.L.Seitz, Ed., </editor> <publisher> MIT Press. </publisher>
Reference-contexts: In hopCP, we provide a construct known as asynchronous ports to model such situations. Asynchronous ports are distributed single-writer multiple-reader shared variables. Other HDL users also have felt the need for asynchronous ports. For example, the "first asynchronous microprocessor" <ref> [29] </ref> is generally considered to be specified in a CSP-like language; yet, asynchronous port assignments are extensively used in the specification. In short, without using asynchronous ports, many hardware systems become very difficult to describe. 1.2 Specification/design Validation Tools 1.2.1 Seriality Checking Asynchronous ports must be used with caution. <p> Although it is in principle possible to allow asynchronous ports to be concurrently read and written through the use of special synchronizers such as Q-flops [37], we do not currently support this capability in hopCP. Though asynchronous ports are used in <ref> [29] </ref>, no support for the safe usage of asynchronous ports is offered in their system, thus making it users' responsibility to use asynchronous ports safely. 1.2.2 Compiled Code Simulation A high-level specification is not very useful unless it is supported by a methodology to validate it.
Reference: 30. <author> McMillan, K. L. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: Several verification techniques for concurrent software have been widely studied [7]. Research prototypes embodying some of these techniques (such as the Concurrency Workbench [12] and COSPAN [21]) are also available. In addition, formalisms such as trace theory [13] and Temporal Logic <ref> [30] </ref> have been applied for the verification of speed independent asynchronous circuits [14] as well as for verifying concurrent protocols such as cache coherence protocols. These tools have also been used by us in our past work [18, 33]. <p> It is interesting to compare the style of validation we have presented against that offered in verification tools such as SMV <ref> [30] </ref> and COSPAN [21]. SMV is a system that allows concurrent finite-state systems to be described in a language reminiscent of data-flow languages as well as guarded-command languages.
Reference: 31. <author> McFarland, M. C., Parker, A. C., and Camposano, R. </author> <title> The high-level synthesis of digital systems. </title> <booktitle> Proceedings of the IEEE 78, </booktitle> <month> 2 (Feb. </month> <year> 1990), </year> <pages> 301-318. </pages>
Reference-contexts: Although a language such as hopCP cannot be used to describe all the operational aspects of a control intensive IC, it is well suited for writing high-level descriptions that make the global properties of interest quite explicit. Given the increasing prevalence of high-level synthesis tools <ref> [31, 4, 17] </ref>, descriptions such as written in hopCP can be compiled to derive large portions of the silicon implementation of control intensive ICs. We now proceed to describe the 8251 in great detail. The 8251 can be programmed by the CPU to operate under many serial data transmission schemes.
Reference: 32. <editor> May David Compiling Occam into Silicon. </editor> <booktitle> Developments in Concurrency and Communication Addison-Wesley, 1990. SPECIFICATION AND VALIDATION OF CONTROL INTENSIVE ICS IN HOPCP 31 </booktitle>
Reference-contexts: eXene (a muti-threaded interface to X protocol), distributed ML and distributed Nuprl (a theorem proving environment) implementations. 1.2.3 High Level Validation using Testers The behavioral specification of complex control intensive ICs can be hard to follow, even if such ICs are described in a modern concurrent HDL, such as Occam <ref> [34, 32, 28] </ref> or hopCP. Although a simulator can help "animate" the specification for selected scenarios, output waveform traces produced by typical simulation runs offer very little help in understanding or debugging complex control intensive ICs. In the hopCP system, high level validation is supported in two ways.
Reference: 33. <author> Nalumasu, R., and Gopalakrishnan, G. </author> <title> Verifying an asynchronous wavefront crossbar arbiter using smv, 1993. Class Project Notes, </title> <type> CS 611, </type> <note> Available upon request from ratan@cs.utah.edu. </note>
Reference-contexts: In addition, formalisms such as trace theory [13] and Temporal Logic [30] have been applied for the verification of speed independent asynchronous circuits [14] as well as for verifying concurrent protocols such as cache coherence protocols. These tools have also been used by us in our past work <ref> [18, 33] </ref>. However, few of these tools or techniques have been applied for the verification of real-world control intensive hardware systems where one has to address data dependent control flows, exception handling, and similar issues.
Reference: 34. <institution> Occam programming manual, </institution> <year> 1983. </year>
Reference-contexts: eXene (a muti-threaded interface to X protocol), distributed ML and distributed Nuprl (a theorem proving environment) implementations. 1.2.3 High Level Validation using Testers The behavioral specification of complex control intensive ICs can be hard to follow, even if such ICs are described in a modern concurrent HDL, such as Occam <ref> [34, 32, 28] </ref> or hopCP. Although a simulator can help "animate" the specification for selected scenarios, output waveform traces produced by typical simulation runs offer very little help in understanding or debugging complex control intensive ICs. In the hopCP system, high level validation is supported in two ways.
Reference: 35. <author> Reppy, J. H. </author> <title> CML: A Higher-order Concurrent Language. </title> <booktitle> In ACM SIGPLAN'91 Conference on Programming Language Design and Implementation (June 1991). </booktitle>
Reference-contexts: CFSIM is compiled-code concurrent functional simulator obtained by translating hopCP specifications into CML (Concurrent ML) source code. CML facilitates building concurrent-programming abstractions and is implemented efficiently capitalizing on the continuation-passing style technology of the SML of New Jersey compiler <ref> [6, 35] </ref>. <p> CFSIM is compiled-code concurrent functional simulator for hopCP specifications obtained by translating H F Gs into CML (Concurrent ML) source code. The details of CFSIM are described in [3]. CML is an extension to Standard ML of New Jersey to support first-class synchronous operations <ref> [35] </ref>. CML being higher-order facilitates building concurrent-programming abstractions and is implemented efficiently capitalizing on the continuation-passing style technology of the SML of New Jersey compiler [6].
Reference: 36. <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year>
Reference-contexts: These HDLs are designed based on a single paradigm; for example, many of these HDLs adopt a purely functional view of computations [24, 38], many adopt a formal process model <ref> [22, 36] </ref> while others are based on special theories like the Trace theory [15].
Reference: 37. <author> Rosenberger, F. U., Molnar, C. E., Chaney, T. J., and Ting-Pein Fang. Q-modules: </author> <title> Internally clocked delay-insensitive modules. </title> <journal> IEEE Transactions on Computers 37, </journal> <month> 9 (Sept. </month> <year> 1988), </year> <pages> 1005-1018. </pages>
Reference-contexts: In hopCP we provide support for safe usage of asynchronous ports through seriality checking, as will be described later. Although it is in principle possible to allow asynchronous ports to be concurrently read and written through the use of special synchronizers such as Q-flops <ref> [37] </ref>, we do not currently support this capability in hopCP.
Reference: 38. <author> Sheeran, M. </author> <title> Design of regular hardware structures using higher order functions. </title> <booktitle> In Proceedings of the Functional Programming and Computer Architecture Conference (Sept. 1985), </booktitle> <publisher> Springer-Verlag, LNCS 201. </publisher> <address> Nancy, France. </address>
Reference-contexts: These HDLs are designed based on a single paradigm; for example, many of these HDLs adopt a purely functional view of computations <ref> [24, 38] </ref>, many adopt a formal process model [22, 36] while others are based on special theories like the Trace theory [15].
Reference: 39. <author> Srivas, M., and Bickford, M. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <month> 9 (Sept. </month> <year> 1990). </year>
Reference-contexts: Also, by presenting the description of the 8251 in a semantically well specified notation, we believe that some of the difficulties of formally verifying such systems will be brought to the surface. Currently there is a growing trend towards applying formal methods in the design of real-world hardware systems <ref> [39, 16, 15] </ref>. Most of the current efforts do not address ICs that, in addition to exhibiting control intensive behavior also support non-trivial computations.
Reference: 40. <author> Sternheim, E., Singh, R., and Trivedi, Y. </author> <title> Digital Design with Verilog HDL. </title> <publisher> Automata Publishing Company, </publisher> <address> Cupertino, CA, 95014, </address> <year> 1990. </year> <note> ISBN 0-9627488-0-3. </note>
Reference-contexts: These informal descriptions are prone to misinterpretations, and are not machine readable. They cannot be used as a basis for design validation. Lately, such ICs are being specified in HDLs. For example, the 8251 USART has been specified in many HDLs such as ISPS [8], VHDL [44], and Verilog <ref> [40, 43] </ref>. However, when studied from a formal point of view, these HDLs have many shortcomings. None of the currently popular HDLs (such as referred to above) have a well specified and simple formal semantics.
Reference: 41. <author> Sutherland, I. Micropipelines. </author> <note> Communications of the ACM (June 1989). The 1988 ACM Turing Award Lecture. </note>
Reference-contexts: In addition, in a hopCP specification we do not make any assumptions about the representation of the electrical signals i.e. we allow both transition based or level-based implementations|two popular styles of implementing asynchronous circuits <ref> [41] </ref>. (ii) HardwareC is based on an imperative language to specify computation where parallelism has to be extracted from sequential descriptions (during synthesis) while hopCP is based on a functional language the parallelism is implicit in the program (i.e. it is much easier to extract).
Reference: 42. <author> Thomas, D. E., Lagnese, E. D., Walker, R. A., Nestor, J. A., Rajan, J. V., and Blackburn, R. L. </author> <title> Algorithmic and Register-Transfer Level Synthesis: The System Architect's Workbench. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1990. </year>
Reference-contexts: module, padded with start and stop bits and shifted out serially (least significant bit first) on the TxD output at a rate determined by the baud rate setting in the mode word. 4.5 Comparison With Existing Work Intel 8251 has been specified in HardwareC [25] and a variant of ISPS <ref> [42] </ref>. The specifications are available with the distribution of high-level synthesis benchmarks. In this section we will compare the hopCP specification of the 8251 with its HardwareC and ISPS specifications.
Reference: 43. <author> Thomas, D. E., and Moorby, P. </author> <title> The Verilog Hardware Description Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year> <note> ISBN 0-7923-9126-8. </note>
Reference-contexts: These informal descriptions are prone to misinterpretations, and are not machine readable. They cannot be used as a basis for design validation. Lately, such ICs are being specified in HDLs. For example, the 8251 USART has been specified in many HDLs such as ISPS [8], VHDL [44], and Verilog <ref> [40, 43] </ref>. However, when studied from a formal point of view, these HDLs have many shortcomings. None of the currently popular HDLs (such as referred to above) have a well specified and simple formal semantics.

References-found: 43

