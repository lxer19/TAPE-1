URL: http://www.cs.gatech.edu/computing/Database/students/bmoopen/paper.ps
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/bmoopen/homepage.html
Root-URL: 
Email: spencer@cc.gatech.edu  
Title: DOMAIN ANALYSIS AND REVERSE ENGINEERING  
Author: Jean-Marc Debaud Bijith M. Moopen Spencer Rugaber 
Keyword: Domain analysis, reverse engineering, report writing  
Address: Atlanta, Georgia 30332-0280 (v) (404) 894-8450 (f) (404) 853-9378  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: EXPERIENCE REPORT ABSTRACT Current reverse engineering technology is typically based on program analysis methods such as parsing and data ow analysis. As such, it is limited in what it can accomplish. Knowledge of the application domain containing a program can help overcome this limit and aid the comprehension process. This paper discusses the relationship of application domain analysis and reverse engineering. Tw o case studies are presented. The first describes how domain knowledge, expressed as an object-oriented framework, can aid the reverse engineering process for a well-understood domain. The second studies how rev erse engineering can be used to build a domain model. Issues raised by the conuence of domain analysis and reverse engineering are discussed, and implications on future work in the area are suggested. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Automated Data Systems Manual, </author> <title> Installation Materiel Condition Status Reporting System (IMCSRS), Functional User's Manual, </title> <address> Commander FORSCOM, AFLG-RO, Ft. McPherson, Georgia, </address> <month> April 1, </month> <year> 1984. </year>
Reference: 2. <author> Guillermo Arango, </author> <title> ``Domain Analysis Methods,'' in Software R eusability, </title> <editor> ed. W. Schaeffer, R. Prieto-Diaz, and M. </editor> <booktitle> Matsumoto, </booktitle> <pages> pp. 17-49, </pages> <publisher> Ellis Horwood, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: We conclude with some observations on the case study approach and results. 2.1. Object-Oriented Frameworks The construction of a domain model entails performing a domain analysis. We hav e used Arango's Common Process of domain analysis <ref> [2] </ref> to construct the Report Writing domain model. Generically, a domain analysis has four major steps: selecting a domain, bounding the domain, eliciting and articulating the domain concepts and operations, and expressing the domain in a representation.
Reference: 3. <author> Guillermo Arango and Ruben Prieto-Diaz, </author> <title> ``Domain Analysis Concepts and Research Directions,'' in Domain Analysis and Software Systems Modeling, </title> <editor> ed. Ruben Prieto-Diaz and Guillermo Arango, </editor> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: What is Domain Analysis? A domain is a problem area. Typically, many application programs exist to solve the problems in a single domain. Arango and Prieto-Diaz <ref> [3] </ref> give the following prerequisites for the presence of a domain: the existence of comprehensive relationships among objects in the domain, a community interested in solutions to the problems in the domain, a recognition that software solutions are appropriate to the problems in the domain, and a store of knowledge or
Reference: 4. <author> Ted J. Biggerstaff, </author> <title> ``Design Recovery for Maintenance and Reuse,'' </title> <journal> IEEE Computer, </journal> <volume> vol. 22, no. 7, </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Given that the source code by itself is not sufficient to understand the program, the question arises whether there is an alternate approach better suited to the needs of reverse engineering. This paper argues that 1 This thought experiment was developed by Biggerstaff <ref> [4] </ref>. - 2 - application domain modeling provides such an approach. 1.2. What is Domain Analysis? A domain is a problem area. Typically, many application programs exist to solve the problems in a single domain.
Reference: 5. <author> Richard Clayton and Spencer Rugaber, </author> <title> ``The Representation Problem in Reverse Engineering,'' </title> <booktitle> Proceedings of the First Working Conference on Reverse Engineering, </booktitle> <address> Baltimore, Maryland, </address> <month> May 21-23, </month> <year> 1993. </year>
Reference-contexts: They can be broken into the categories of representation, methods, and tools. Representation The fundamental question concerning representation is what is the best form for a domain description to take in order to support reverse engineering, or whether, in fact, a single, "best" representation can be devised <ref> [5] </ref>. In our case studies, we used object oriented frameworks and Entity Relationship diagrams, but a plethora of alternatives exist. Although domain theorists do not yet agree on how to represent domain information, a consistent representation is a prerequisite to broadly applicable tools.
Reference: 6. <author> J.-M. DeBaud, </author> <title> ``From Domain Analysis to Object-Oriented Frameworks, A Reuse Oriented Software Engineering Methodology,'' </title> <type> Thesis Proposal, </type> <institution> Georgia Institute of Technology, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: It is a novel use of the technology. An object-oriented framework is a carefully crafted set of abstract classes that collaborate to carry out responsibilities in order to embody a reusable design for an entire class of applications or subsystems <ref> [6] </ref>. An abstract class is an incompletely specified class that is designed to be a template for a subclass. Each abstract class is a reusable design of a component [8]. We found the object model hierarchy v ery useful in representing the generalization/specialization relationships of the domain concepts. <p> Later, we found the DSL to be very useful in recording the changes to the domain model as it evolved. We have structured the DSL as a non-procedural, declarative specification languages. A number of rules and heuristics to map the language to class hierarchy shells have been found <ref> [6] </ref>. They proved very helpful in designing and manipulating the Report Writing framework. In Figure 1a, we present the overall class organization of the Report Writing framework. In this model, reports are either text-baseda set of text strings or calculated fieldsor record-baseda set of rows fetched by queries.
Reference: 7. <author> Premkumar T. Devanbu, </author> <title> ``GENOA A C ustomizable, Language- and Front-End Independent Code Analyzer,'' </title> <booktitle> Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <pages> pp. 307-319, </pages> <address> Mel-bourne, Australia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Mature domains enable application generation technol ogy, such as report writers. How about the inverse? Can we build application analyzer generators? In fact, at least one such tool exists, GENOA, a language-independent analyzer generator <ref> [7] </ref>. Finally, what should be done with all the existing reverse engineering tools that do not take advantage of domain knowledge? Can they be adapted or integrated? Need they be? 4.2.
Reference: 8. <author> R. E. Johnson and B. Foote, </author> <title> ``Designing Reusable Classes,'' </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1, no. 2, </volume> <pages> pp. 22-35, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: An abstract class is an incompletely specified class that is designed to be a template for a subclass. Each abstract class is a reusable design of a component <ref> [8] </ref>. We found the object model hierarchy v ery useful in representing the generalization/specialization relationships of the domain concepts. The Report Writing framework provides a clear and normative structure to guide the reverse engineering effort through feature expectations.
Reference: 9. <author> James M. Neighbors, </author> <title> ``Software Construction from Components,'' </title> <type> PhD thesis, </type> <institution> TR-160, ICS Department, University of California at Irvine, </institution> <year> 1980. </year>
Reference-contexts: Domain Analysis According to Neighbors <ref> [9] </ref>, domain analysis "is an attempt to identify the objects, operators, and relationships between what domain experts perceive to be important about the domain." As such, it bears a close resemblance to traditional systems analysis, but at the level of a collection of problems rather than a single one.
Reference: 10. <author> Stephen B. Ornburn and Spencer Rugaber, </author> <title> ``Reverse Engineering: Resolving Conicts between Expected and Actual Software Designs,'' </title> <booktitle> Proceedings of the Conference on Software Maintenance, </booktitle> <pages> pp. 32-40, </pages> <address> Orlando, Florida, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Army. The program consists of 636 lines of code of which 243 are PROCEDURE DIVISION statements. This, in COBOL, is the actual executable code. The rest of the statements in the program are data declarations and definitions found in the WORKING STORAGE and FILE sections. 3.1. Process Synchronized Refinement <ref> [10] </ref> was used to reverse engineer the program. This technique analyzes the program text from the bottom up, looking for stereotypical cues that signal the implementation of design decisions.
Reference: 11. <author> Linda Mary Wills, </author> <title> ``Automated Program Recognition by Graph Parsing,'' </title> <type> 1358 (PhD Thesis), </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Understanding a pro gram may involve unraveling an idiom to discover what the code is actually accomplishing. Wills has made some progress in recognizing these patterns <ref> [11] </ref>. In conclusion, we were able to construct a formal domain model from the code. However, clearly one instance of a program from the domain is not sufficient validation. Moreover, the value of doing so is severely modulated by the presence of multiple domains. 4. DISCUSSION 4.1.
References-found: 11

