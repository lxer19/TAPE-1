URL: http://www.cs.tamu.edu/research/phoenix/techreports/TR_96-006.ps.Z
Refering-URL: http://www.cs.tamu.edu/research/phoenix/papers_bib.html
Root-URL: 
Email: fganeshb, poochg@cs.tamu.edu  
Title: An Architecture for Object Replication in Distributed Systems  
Author: Ganesha Beedubail and Udo Pooch 
Address: College Station, TX 77843.  
Affiliation: Department of Computer Science, Texas A&M University,  
Abstract: Technical Report (TR 96-006) March 1996. Abstract In this paper we present an architecture for developing replicated objects in object oriented distributed systems. The architecture is however general and the concepts can be adapted to non-object oriented distributed systems. The architecture specifies the main requirements for developing replicated objects in distributed systems, namely: the replicated object representation, the replicated object development and management mechanism, and the replica consistency protocol. For achieving these requirements the architecture specifies a hierarchy of objects and the inheritance and functional relationship among these objects. All the management functions of replicated objects are encapsulated in a manager object. An application object inherits these functionalities from the manager object. This object replication architecture will greatly reduce the complexity of the development of replicated objects in distributed systems. We also developed an efficient replica consistency algorithm that takes advantage of the features of our architecture. A preliminary prototype implementation of our architecture has been carried out in Spring OS environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Alsberg and J. Day, </author> <title> "A principle for resilient sharing of distributed resrources," </title> <booktitle> In Proc. Of Second Intl' Conf. on Software Engg., </booktitle> <address> San Francisco, CA., </address> <pages> pp. 562-570, </pages> <year> 1976. </year>
Reference-contexts: The solution we provide here is a software architecture that greatly reduces the complexity of the development of replicated objects in distributed systems. Much of the research <ref> [1, 2, 3, 4, 5] </ref> in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems [6, 7, 8] elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects). <p> If the primary fails, then one of the backups becomes the primary. This approach is known as the primary-backup or the primary copy approach <ref> [1] </ref>. All the research on object replication are variations or combinations of the above two basic strategies. Alsberg and Day [1] proposed one of the earliest primary-backup protocols. <p> If the primary fails, then one of the backups becomes the primary. This approach is known as the primary-backup or the primary copy approach <ref> [1] </ref>. All the research on object replication are variations or combinations of the above two basic strategies. Alsberg and Day [1] proposed one of the earliest primary-backup protocols. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept to n hosts. In [5], Budhiraja et. al. present some theoretical aspects of the primary backup approach.
Reference: [2] <author> K. P. Birman et al., </author> <title> "Implementing fault-tolerant distributed objects," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 6, no. 11, </volume> <pages> pp. 502-508, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: The solution we provide here is a software architecture that greatly reduces the complexity of the development of replicated objects in distributed systems. Much of the research <ref> [1, 2, 3, 4, 5] </ref> in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems [6, 7, 8] elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects).
Reference: [3] <author> P. Jalote, </author> <title> "Resilient objects in broadcast networks," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 15, no. 1, </volume> <pages> pp. 68-72, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The solution we provide here is a software architecture that greatly reduces the complexity of the development of replicated objects in distributed systems. Much of the research <ref> [1, 2, 3, 4, 5] </ref> in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems [6, 7, 8] elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects).
Reference: [4] <author> F. Schneider, </author> <title> "Implementing fault tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The solution we provide here is a software architecture that greatly reduces the complexity of the development of replicated objects in distributed systems. Much of the research <ref> [1, 2, 3, 4, 5] </ref> in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems [6, 7, 8] elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects). <p> This approach is known as active replication or the state machine approach <ref> [4] </ref>. 2) Designate one server as the primary and all others as backups. Clients make requests by sending messages only to the primary. The primary forwards the requests to the backups (so that, backups can synchronize their state with the primary) and then responds to the client 2 .
Reference: [5] <author> N. Budhiraja et al., </author> <title> "The primary-backup approach," In Distributed Systems, 2ed Edition, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 199-216, </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: The solution we provide here is a software architecture that greatly reduces the complexity of the development of replicated objects in distributed systems. Much of the research <ref> [1, 2, 3, 4, 5] </ref> in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems [6, 7, 8] elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects). <p> Alsberg and Day [1] proposed one of the earliest primary-backup protocols. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept to n hosts. In <ref> [5] </ref>, Budhiraja et. al. present some theoretical aspects of the primary backup approach. Their system assumes closely synchronized clocks in the system.
Reference: [6] <author> E. C. Cooper, </author> <title> "Replicated distributed programs," </title> <booktitle> In ACM Symp. on Oper. Syst. Princ., </booktitle> <pages> pp. 63-78, </pages> <year> 1985. </year>
Reference-contexts: Much of the research [1, 2, 3, 4, 5] in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems <ref> [6, 7, 8] </ref> elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects). In this paper we will present a comprehensive architecture for developing replicated objects in distributed systems. <p> In [10], Beedubail et. al. extended the primary backup protocol for nested object invocation (i.e., to service a client request object can invoke the services of other objects). That scheme assumes the existence of a reliable multicast and fault tolerant naming service. The replicated distributed programs described by Cooper <ref> [6] </ref> is an example of active replication. Here, all the replicas (called the members of a troupe) execute the client calls independently. A higher level protocol should make sure that all the replicas get their client calls in the same order.
Reference: [7] <author> M. Olsen, E. Oskiewicz, and J. Warne, </author> <title> "A model for interface groups," </title> <booktitle> In 10th Symposium, Reliable Distributed Systems, </booktitle> <pages> pp. 98-107, </pages> <year> 1991. </year>
Reference-contexts: Much of the research [1, 2, 3, 4, 5] in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems <ref> [6, 7, 8] </ref> elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects). In this paper we will present a comprehensive architecture for developing replicated objects in distributed systems. <p> A higher level protocol should make sure that all the replicas get their client calls in the same order. In [11] Birman et. al. describes how totally ordered, reliable broadcasts can be used to maintain replicated data (active replication). In <ref> [7] </ref> Olsen et.al. describe the interface group abstraction developed and implemented on ANSA architecture. Interface groups hide the group membership from the application and thus can be used for supporting reliability by replication. Object replication in Arjuna [8] uses active replication 3 .
Reference: [8] <author> M. C. Little, </author> <title> Object Replication in a Distributed System, </title> <type> PhD thesis, </type> <institution> Computer Science Dept., University of Newcastle upon Tyne, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Much of the research [1, 2, 3, 4, 5] in object replication techniques is concentrated on one aspect of replication, i.e., the replica consistency. A few systems <ref> [6, 7, 8] </ref> elaborate on other aspects of replication such as naming support and replicated object management (creating, adding, deleting replicated objects). In this paper we will present a comprehensive architecture for developing replicated objects in distributed systems. <p> In [7] Olsen et.al. describe the interface group abstraction developed and implemented on ANSA architecture. Interface groups hide the group membership from the application and thus can be used for supporting reliability by replication. Object replication in Arjuna <ref> [8] </ref> uses active replication 3 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by the Arjuna system. A higher level group locking protocol (issued by the application program) avoids the need for a reliable ordered broadcast.
Reference: [9] <author> B. Liskov et al., </author> <title> "Replication in the harp file system," </title> <type> Technical Report MIT/LCS/TM-456, </type> <institution> Massachusetts Institute Of Technology, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The Harp File System also uses a primary-backup protocol <ref> [9] </ref>. It is assumed that the system clocks are closely synchronized and all the machines are equipped with an uninterruptable power supply (UPS). The protocol keeps a log of updates on volatile memory (the UPS is necessary to write back this log to disk in case of power failure).
Reference: [10] <author> G. Beedubail et al., </author> <title> "Fault tolerant objects in distributed systems using hot replication," </title> <booktitle> In Proc. of 15th Int'l Phoenix Conf. on Computers and Communications (IPCCC'96), </booktitle> <address> Phoenix, AZ, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Operations on the log are applied to the system in the background. Thus the disk access is removed from the critical path and good response time is achieved. In <ref> [10] </ref>, Beedubail et. al. extended the primary backup protocol for nested object invocation (i.e., to service a client request object can invoke the services of other objects). That scheme assumes the existence of a reliable multicast and fault tolerant naming service.
Reference: [11] <author> T. Joseph and K. Birman, </author> <title> "Exploiting replication in distributed systems," In Distributed Systems, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 319-367, </pages> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The replicated distributed programs described by Cooper [6] is an example of active replication. Here, all the replicas (called the members of a troupe) execute the client calls independently. A higher level protocol should make sure that all the replicas get their client calls in the same order. In <ref> [11] </ref> Birman et. al. describes how totally ordered, reliable broadcasts can be used to maintain replicated data (active replication). In [7] Olsen et.al. describe the interface group abstraction developed and implemented on ANSA architecture.
Reference: [12] <author> P. Dasgupta, R. Leblanc, M. Ahamad, and U. Ramachandran, </author> <title> "The clouds distributed operating system," </title> <journal> IEEE Computer, </journal> <volume> vol. 24, no. 11, </volume> <pages> pp. 34-44, </pages> <month> November </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: The replication algorithm uses the support of naming and binding service and the atomic action service provided by the Arjuna system. A higher level group locking protocol (issued by the application program) avoids the need for a reliable ordered broadcast. The clouds system <ref> [12] </ref> uses the concept of parallel execution threads (PETs) to support replicated computation (and thus fault tolerance). In [13] Kaashoek et.al., describe the fault tolerant directory service implemented in the Amoeba distributed operating system. They use the closed group communication service supported in Amoeba to implement the directory service.
Reference: [13] <author> M. F. Kaasshoek, A. S. Tanenbaum, and K. Verstoep, </author> <title> "Using group communication to imple-ment a fault-tolerant directory service," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 130-139, </pages> <year> 1993. </year>
Reference-contexts: A higher level group locking protocol (issued by the application program) avoids the need for a reliable ordered broadcast. The clouds system [12] uses the concept of parallel execution threads (PETs) to support replicated computation (and thus fault tolerance). In <ref> [13] </ref> Kaashoek et.al., describe the fault tolerant directory service implemented in the Amoeba distributed operating system. They use the closed group communication service supported in Amoeba to implement the directory service. In [14], Spiewak describes a framework for replicating objects in Spring OS using primary backup algorithm.
Reference: [14] <author> J. S. Spiewak, </author> <title> "Replication in spring: A new subcontract," </title> <type> Technical Report CS-95-16, </type> <institution> Brown University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: In [13] Kaashoek et.al., describe the fault tolerant directory service implemented in the Amoeba distributed operating system. They use the closed group communication service supported in Amoeba to implement the directory service. In <ref> [14] </ref>, Spiewak describes a framework for replicating objects in Spring OS using primary backup algorithm. Here the replicas are periodically updated. Thus the replicas will not always be in a mutually consistent state.
Reference: [15] <author> C. Pu, J. Noe, and A. Proudfoot, </author> <title> "Regeneration of replicated objects: A technique and its eden implementation," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 14, no. 7, </volume> <pages> pp. 936-945, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: In [14], Spiewak describes a framework for replicating objects in Spring OS using primary backup algorithm. Here the replicas are periodically updated. Thus the replicas will not always be in a mutually consistent state. The reader can refer to <ref> [15, 16, 17, 18] </ref> for additional reading on replication. 2.1 Motivations for this Work The foregoing discussion mainly dealt with various algorithms for object replication. These algorithms basically keep the copies of replicated objects in a mutually consistent state.
Reference: [16] <author> R. Ladin, B. Liskov, L. Shrira, and S. Ghemawat, </author> <title> "Lazy replication: Exploiting the semantics of distributed services," </title> <type> Technical Report MIT/LCS/TR-484, </type> <institution> Massachusetts Institute Of Technology, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: In [14], Spiewak describes a framework for replicating objects in Spring OS using primary backup algorithm. Here the replicas are periodically updated. Thus the replicas will not always be in a mutually consistent state. The reader can refer to <ref> [15, 16, 17, 18] </ref> for additional reading on replication. 2.1 Motivations for this Work The foregoing discussion mainly dealt with various algorithms for object replication. These algorithms basically keep the copies of replicated objects in a mutually consistent state.
Reference: [17] <author> T. Mann, A. Hisgen, and G. Swart, </author> <title> "An algorithm for data replication," </title> <type> Technical Report 46, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In [14], Spiewak describes a framework for replicating objects in Spring OS using primary backup algorithm. Here the replicas are periodically updated. Thus the replicas will not always be in a mutually consistent state. The reader can refer to <ref> [15, 16, 17, 18] </ref> for additional reading on replication. 2.1 Motivations for this Work The foregoing discussion mainly dealt with various algorithms for object replication. These algorithms basically keep the copies of replicated objects in a mutually consistent state.
Reference: [18] <author> E. N. Elnozahy and W. Zwaenepoel, </author> <title> "Replicated distributed processes in manetho," </title> <booktitle> In Digest of papers: The 22 nd Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 18-27, </pages> <year> 1992. </year>
Reference-contexts: In [14], Spiewak describes a framework for replicating objects in Spring OS using primary backup algorithm. Here the replicas are periodically updated. Thus the replicas will not always be in a mutually consistent state. The reader can refer to <ref> [15, 16, 17, 18] </ref> for additional reading on replication. 2.1 Motivations for this Work The foregoing discussion mainly dealt with various algorithms for object replication. These algorithms basically keep the copies of replicated objects in a mutually consistent state.
Reference: [19] <author> J. Mitchel et al., </author> <title> "An overview of the spring system," </title> <booktitle> In Proceedings of of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: This system is a collection of objects that provides services to the user. The objects interact with each other and with the outside world through well defined interfaces. The object interfaces are defined in such a system using some standard interface definition language (IDL). Systems such as SPRING <ref> [19] </ref> and CORBA framework [20] provide such features. The objects in the system are active (i.e. the object is always executing for providing services). We will not consider persistent objects here (note that object persistence is an orthogonal issue with respect to object replication). <p> We also required that the NS be fault tolerant and provide support for object replication. We developed such a NS. Here we will briefly highlight the features of our NS. The details of this work can be found in [21]. We used Spring OS for our implementation <ref> [19] </ref>. Spring provides a native name service [22]. To make it fault tolerant, we replicated the Spring NS. The main idea of the replication algorithm is similar to the one given in Section 4. However, the details are somewhat different. <p> In this way the load distribution will be more efficient. 7 Implementation We implemented a preliminary version of the prototype of our object replication framework. Our implementation environment is the Spring OS. Spring is a micro kernel based object oriented distributed operating system <ref> [19] </ref>. All services in Spring (user services as well as system services) are implemented as objects. All objects in Spring have well defined interfaces, and these interfaces are defined using the Interface Definition Language (IDL).
Reference: [20] <author> T. J. Mowbray and R. Zahavi, </author> <title> The Essential Corba: System Integration Using Distributed Objects, </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference-contexts: The objects interact with each other and with the outside world through well defined interfaces. The object interfaces are defined in such a system using some standard interface definition language (IDL). Systems such as SPRING [19] and CORBA framework <ref> [20] </ref> provide such features. The objects in the system are active (i.e. the object is always executing for providing services). We will not consider persistent objects here (note that object persistence is an orthogonal issue with respect to object replication).
Reference: [21] <author> G. Beedubail, P. Kessler, and U. Pooch, </author> <title> "Replicated naming service in spring," </title> <type> Technical Report TR95-048, </type> <institution> Computer Science Department,Texas A&M University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: We also required that the NS be fault tolerant and provide support for object replication. We developed such a NS. Here we will briefly highlight the features of our NS. The details of this work can be found in <ref> [21] </ref>. We used Spring OS for our implementation [19]. Spring provides a native name service [22]. To make it fault tolerant, we replicated the Spring NS. The main idea of the replication algorithm is similar to the one given in Section 4. However, the details are somewhat different.
Reference: [22] <author> S. Radia, M. Nelson, and M. Powell, </author> <title> "The spring name service," </title> <type> Technical Report SMLI-9316, </type> <institution> Sun Microsystems Laboratories, </institution> <year> 1993. </year>
Reference-contexts: We developed such a NS. Here we will briefly highlight the features of our NS. The details of this work can be found in [21]. We used Spring OS for our implementation [19]. Spring provides a native name service <ref> [22] </ref>. To make it fault tolerant, we replicated the Spring NS. The main idea of the replication algorithm is similar to the one given in Section 4. However, the details are somewhat different. First, we fix the name server machines (NSmachines) in the system apriori.
Reference: [23] <author> G. Beedubail, P. Kessler, and U. Pooch, </author> <title> "Object replication in spring using subcontracts," </title> <type> Technical Report TR95-041, </type> <institution> Computer Science Department,Texas A&M University, </institution> <month> Septem-ber </month> <year> 1995. </year> <month> 17 </month>
Reference-contexts: IDL interface only defines the operations (with necessary arguments) on the object. The object developer has to implement the actual function of the object. IDL supports multiple inheritance of the interfaces. Initially we used Spring's subcontract facility to implement the preliminary version of this architecture <ref> [23] </ref>. As we gained experience in the requirement for developing replicated objects, we modified the architecture to the current form. For the prototype implementation of the current architecture, we hand coded the object interfaces for all the objects shown in the Figure 3.
References-found: 23

