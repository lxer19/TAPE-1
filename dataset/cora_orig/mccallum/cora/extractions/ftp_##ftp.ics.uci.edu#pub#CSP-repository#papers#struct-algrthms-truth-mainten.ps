URL: ftp://ftp.ics.uci.edu/pub/CSP-repository/papers/struct-algrthms-truth-mainten.ps
Refering-URL: http://www.ics.uci.edu/~mlearn/MLPapers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: dechter@ics.uci.edu  avi@cs.ucla.edu  
Title: Structure-Driven Algorithms for Truth Maintenance  
Author: Rina Dechter Avi Dechter 
Date: December 28, 1994  
Address: Irvine CA 92717  Northridge, CA 91330  
Affiliation: Information and Computer Science Department University of California,  Department of Managment Science School of Business Administration and Economics California State University,  
Abstract: This paper studies truth-maintenance and belief revision tasks on singly-connected structures for the purpose of understanding how structural features could be exploited in such tasks. We present distributed algorithms and show that, in the JTMS framework, both belief revision and consistency maintenance are linear in the size of the knowledge-base on singly connected structures. However, the ATMS task is exponential in the branching degree of the network. The singly-connected model, while restrictive, is useful for three reasons. First, efficient algorithms on singly-connected models can be utilized in more general structures by employing well-known clustering techniques. Second, these algorithms can serve as approximations or as heuristics in algorithms that perform truth-maintenance on general problems. Finally, the analysis provides insights for understanding the sources of the computational difficulties associated with JTMS and ATMS.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C.R. Alchourron, P. Gardenfors, and D. Makinson. </author> <title> On the logic of theory change: partial meet contraction and revision functions. </title> <journal> Journal of Symbolic logic, </journal> <volume> 50 </volume> <pages> 510-530, </pages> <year> 1985. </year> <month> 19 </month>
Reference-contexts: This functionality of JTMS is closely related to the framework of agent's belief revision. The basic idea in this more recent work is to enforce minimal change in an agent's belief necessary to account for a new contradiction in his knowledge <ref> [1] </ref>. Thus far, research in belief revision focused on the task of finding a minimal revision or on finding what holds under all minimal revisions. Here we focus on the identification of a minimum number of changes to represent minimal change.
Reference: [2] <author> R. Ben-Eliyahu and R. Dechter. </author> <title> On computing minimal models. </title> <booktitle> In Proceedings of AAAI-93, </booktitle> <pages> pages 2-8, </pages> <address> Washington, D.C., </address> <year> 1993. </year>
Reference-contexts: The merits of the belief revision algorithms appearing here were recently tested experimentally on various circuit diagnosis examples. The algorithm's performance was shown to be superior relative to Model-based Diagnosis (MBD) algorithms [14]. Another recent paper <ref> [2] </ref> discusses the task of finding all minimal sets of changes needed to restore consistency (as opposed to the task of all sets of minimum cardinality, discussed in the current paper). It is shown that while a propagation scheme is available in this case as well, it has greater complexity.
Reference: [3] <author> A Darwiche. </author> <title> Conditional independence in atmss: Independence-based algorithms for computing labels and diagnosis. In Rockwell, </title> <type> Technical Report, </type> <year> 1994. </year>
Reference-contexts: Examples of such cases are physical or biological systems such as electronic circuits and model-based medical diagnosis systems. Structure-exploiting algorithms for diagnosis that were inspired by algorithms on probabilistic networks appear in [16] and recently in <ref> [3, 18] </ref>. The merits of the belief revision algorithms appearing here were recently tested experimentally on various circuit diagnosis examples. The algorithm's performance was shown to be superior relative to Model-based Diagnosis (MBD) algorithms [14].
Reference: [4] <author> R. Davis. </author> <title> Diagnostic reasoning based on structure and behavior. </title> <journal> Artificial Intelligence, </journal> <volume> 24, </volume> <year> 1984. </year>
Reference-contexts: For the purpose of this example we assume that the set of expected values for each variable were determined by some pre-processing and all the other values are marked collectively by the symbol "e". Consider the circuit of Figure 5 (also discussed in <ref> [7, 4, 17] </ref>), consisting of three multipliers, M 1 ; M 2 ; M 3 , and two adders, A 1 and A 2 . The values of the five input variables, A; B; C; D, and E, and of the two output variables, F and G, are given.
Reference: [5] <author> J. de Kleer. </author> <title> An assumption-based TMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28(2) </volume> <pages> 127-162, </pages> <year> 1986. </year>
Reference-contexts: Two primary approaches to TMS implementation have been proposed: the JTMS (Justification-based TMS) [13, 20, 22] and the ATMS (Assumption-based TMS) <ref> [5] </ref>. Each design implements the main functionality in a different way. A JTMS starts with the given premise set and attempts to identify all provable propositions, hoping that a proof will be derived for the target proposition. <p> By contrast, handling this problem using ATMS <ref> [5] </ref> may exhibit exponential behavior.
Reference: [6] <author> J. de Kleer. </author> <title> A comparison of ATMS and CSP techniques. </title> <booktitle> In Proceedings of IJCAI-89, </booktitle> <pages> pages 290-296, </pages> <address> Detroit, Michigan, </address> <year> 1989. </year>
Reference-contexts: Here we focus on the identification of a minimum number of changes to represent minimal change. When originally introduced, algorithms for Truth Maintenance were not accompanied by complexity analysis, or performance guarantees <ref> [13, 6, 20] </ref>. Nevertheless, experimental work with these tools, and more recent complexity analysis, have shown that both JTMS and ATMS functionalities are very inefficient, with ATMS exhibiting higher complexity than JTMS in both time and space. <p> Since the language of constraints has the same expressive power as propositional logic [20], all the algorithms presented here are applicable to propositional languages. The connection between truth maintenance systems and constraint satisfaction problems was already pointed out by several authors e.g., <ref> [6] </ref> and [23] [21]. The main thrust of these efforts has been to show that search reduction techniques developed in one area may be used to the benefit of the other. Our work here take this idea one step further. <p> The numbers in the brackets are the expected values of the three intermediate points X, Y , and Z, and of the outputs. 10 M1 M3 A2 B=2 D=3 X <ref> [6] </ref> Z [6] [12] [12] M 1 A C X 1 2 3 c w = 1 The relation defining the constraint associated with the multiplier M 1 is given in Figure 6 as an example, as well as the initial weights associated with the tuples of these leaf constraints (ffi <p> The numbers in the brackets are the expected values of the three intermediate points X, Y , and Z, and of the outputs. 10 M1 M3 A2 B=2 D=3 X <ref> [6] </ref> Z [6] [12] [12] M 1 A C X 1 2 3 c w = 1 The relation defining the constraint associated with the multiplier M 1 is given in Figure 6 as an example, as well as the initial weights associated with the tuples of these leaf constraints (ffi = w
Reference: [7] <author> J. de Kleer and B. Williams. </author> <title> Reasoning about multiple faults. </title> <booktitle> In Proceedings of AAAI-86, </booktitle> <pages> pages 132-139, </pages> <address> Philadelphia, Pensilvania, </address> <year> 1986. </year>
Reference-contexts: For the purpose of this example we assume that the set of expected values for each variable were determined by some pre-processing and all the other values are marked collectively by the symbol "e". Consider the circuit of Figure 5 (also discussed in <ref> [7, 4, 17] </ref>), consisting of three multipliers, M 1 ; M 2 ; M 3 , and two adders, A 1 and A 2 . The values of the five input variables, A; B; C; D, and E, and of the two output variables, F and G, are given.
Reference: [8] <author> R Dechter. </author> <title> A distributed algorithm for atms. </title> <booktitle> In Bar-Ilan Symposium on Foundation of Artificial Intelligence (BISFAI-89), </booktitle> <year> 1989. </year>
Reference: [9] <author> R. Dechter. </author> <title> Enhancement schemes for constraint processing: backjumping, learning, and cutset decomposition. </title> <journal> Artificial Intelligence, </journal> <volume> 41 </volume> <pages> 273-312, </pages> <year> 1990. </year>
Reference-contexts: Examples of such theories are discussed in section 5. An alternative approach for extending the algorithm to cyclic theories is via a method known as cycle-cutset <ref> [9] </ref>, which is exponential in the cycle-cutset size of the theory. The size of the minimal cycle-cutset is normally higher than the cluster's sizes of a tree-embedding of the same theory. <p> The clustering scheme is exponential in the size of the largest cluster, making the complexity of preprocessing also dependent on the structure of the network, with near-tree networks requiring less computation. An alternative approach to dealing with cyclic theories is to use the cycle-cutset method <ref> [9] </ref>, which is exponential in the cycle-cutset size of the theory. The size of the minimal cycle-cutset is larger than the cluster's sizes of a tree-embedding of the same theory, however, unlike tree-clustering, the cycle-cutset method does not require exponential space.
Reference: [10] <author> R. Dechter and A. Dechter. </author> <title> Belief maintenance in dynamic constraint networks. </title> <booktitle> In Proceedings of the seventh national Conference of Artificial Intelligence (AAAI-88), </booktitle> <pages> pages 37-42, </pages> <address> St. Paul, MN, </address> <year> 1988. </year>
Reference: [11] <author> R. Dechter and J. Pearl. </author> <title> Network-based heuristics for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 34 </volume> <pages> 1-38, </pages> <year> 1987. </year>
Reference-contexts: The algorithms are based on recent work in Constraint Satisfaction Problems (CSPs), which resulted in many efficient algorithms and tractable cases tied specifically to the struc 2 ture of the problem <ref> [11, 15, 19, 12] </ref>. A constraint network consists of a set of variables, each associated with a finite set of possible values, and a set of constraints, specifying joint assignments to the variables "allowed" by the constraints. <p> In the following we present a distributed algorithm that compiles all n-supports for an acyclic network. The algorithm is a distributed adaptation of a known tree algorithm that computes the number of solutions <ref> [11] </ref>. Following [11], it is easy to show that: Theorem 1 Let T be a join-tree, and let U be one of its relations, the overall n-support for U = u can be expressed as a function of the n-supports of its neighbors, namely: s U (u) = (Q;U)2T q;q U"Q <p> In the following we present a distributed algorithm that compiles all n-supports for an acyclic network. The algorithm is a distributed adaptation of a known tree algorithm that computes the number of solutions <ref> [11] </ref>. Following [11], it is easy to show that: Theorem 1 Let T be a join-tree, and let U be one of its relations, the overall n-support for U = u can be expressed as a function of the n-supports of its neighbors, namely: s U (u) = (Q;U)2T q;q U"Q =u U"Q
Reference: [12] <author> R. Dechter and J. Pearl. </author> <title> Tree clustering for constraint networks. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> pages 353-366, </pages> <year> 1989. </year>
Reference-contexts: The algorithms are based on recent work in Constraint Satisfaction Problems (CSPs), which resulted in many efficient algorithms and tractable cases tied specifically to the struc 2 ture of the problem <ref> [11, 15, 19, 12] </ref>. A constraint network consists of a set of variables, each associated with a finite set of possible values, and a set of constraints, specifying joint assignments to the variables "allowed" by the constraints. <p> The algorithms we discuss in this paper assume, initially, that the theories are acyclic. These algorithms are extensible to arbitrary theories via a procedure known as tree-clustering <ref> [12] </ref>, which compiles any theory into a tree of relations. Consequently, given a general theory, the algorithms presented in the sequel work in two steps: A join-tree is computed by tree-clustering, and then a specialized tree-algorithm for the particular TMS function is applied. <p> The numbers in the brackets are the expected values of the three intermediate points X, Y , and Z, and of the outputs. 10 M1 M3 A2 B=2 D=3 X [6] Z [6] <ref> [12] </ref> [12] M 1 A C X 1 2 3 c w = 1 The relation defining the constraint associated with the multiplier M 1 is given in Figure 6 as an example, as well as the initial weights associated with the tuples of these leaf constraints (ffi = w for <p> The numbers in the brackets are the expected values of the three intermediate points X, Y , and Z, and of the outputs. 10 M1 M3 A2 B=2 D=3 X [6] Z [6] <ref> [12] </ref> [12] M 1 A C X 1 2 3 c w = 1 The relation defining the constraint associated with the multiplier M 1 is given in Figure 6 as an example, as well as the initial weights associated with the tuples of these leaf constraints (ffi = w for leaf <p> This network is acyclic, as is evident by the fact that a join-tree can be obtained by eliminating the redundant arc (marked by a dashed line) between constraint (M 2 ; B; D; Y ) and (A 2 ; Z; Y; G). For more details see <ref> [12] </ref>. Initially, when no observation of output data is available, the network propagates its n-supports assuming all device variables have their default assumption-value "0". In this case only one solution exists and therefore the supports for all consistent values are "1". <p> It appears that, in practice, users should be advised to implement the JTMS strategy whenever possible and to use ATMS only when necessary. When the constraint network is not acyclic, the method of tree-clustering <ref> [12] </ref> should be used as a pre-processing step. This method uses aggregation of constraints into equivalent constraints involving larger clusters of variables in such a way that the resulting network is acyclic.
Reference: [13] <author> J. Doyle. </author> <title> A truth maintenance system. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year>
Reference-contexts: The main functionality of a TMS is to determine whether the truth of a given proposition follows logically from a given set of premises and from the set of constraints, and to keep this information current. Two primary approaches to TMS implementation have been proposed: the JTMS (Justification-based TMS) <ref> [13, 20, 22] </ref> and the ATMS (Assumption-based TMS) [5]. Each design implements the main functionality in a different way. A JTMS starts with the given premise set and attempts to identify all provable propositions, hoping that a proof will be derived for the target proposition. <p> Here we focus on the identification of a minimum number of changes to represent minimal change. When originally introduced, algorithms for Truth Maintenance were not accompanied by complexity analysis, or performance guarantees <ref> [13, 6, 20] </ref>. Nevertheless, experimental work with these tools, and more recent complexity analysis, have shown that both JTMS and ATMS functionalities are very inefficient, with ATMS exhibiting higher complexity than JTMS in both time and space.
Reference: [14] <author> Y. El fattah and R. Dechter. </author> <title> Diagnosis for near tree structures. </title> <note> In UCI technical report, </note> <year> 1994, 1994. </year>
Reference-contexts: The merits of the belief revision algorithms appearing here were recently tested experimentally on various circuit diagnosis examples. The algorithm's performance was shown to be superior relative to Model-based Diagnosis (MBD) algorithms <ref> [14] </ref>. Another recent paper [2] discusses the task of finding all minimal sets of changes needed to restore consistency (as opposed to the task of all sets of minimum cardinality, discussed in the current paper).
Reference: [15] <author> E. C. Freuder. </author> <title> A sufficient condition for backtrack-free search. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 24-32, </pages> <year> 1982. </year>
Reference-contexts: The algorithms are based on recent work in Constraint Satisfaction Problems (CSPs), which resulted in many efficient algorithms and tractable cases tied specifically to the struc 2 ture of the problem <ref> [11, 15, 19, 12] </ref>. A constraint network consists of a set of variables, each associated with a finite set of possible values, and a set of constraints, specifying joint assignments to the variables "allowed" by the constraints.
Reference: [16] <author> H. Geffner and J. Pearl. </author> <title> An improved constraint propagation algorithm for diagnosis. </title> <booktitle> In Proceedings of IJCAI-87, </booktitle> <pages> pages 1105-1111, </pages> <address> Milan, Italy, </address> <year> 1987. </year>
Reference-contexts: By contrast, handling this problem using ATMS [5] may exhibit exponential behavior. A similar algorithm exploiting the framework of probabilistic networks is given <ref> [16] </ref>. 6 ATMS Labeling In this section we focus on the primary ATMS functionality, namely, finding one or all minimal instantiations of assumption variables in a given network of constraints that entail the proposition X = x . This task is often called label determination in the ATMS terminology. <p> Examples of such cases are physical or biological systems such as electronic circuits and model-based medical diagnosis systems. Structure-exploiting algorithms for diagnosis that were inspired by algorithms on probabilistic networks appear in <ref> [16] </ref> and recently in [3, 18]. The merits of the belief revision algorithms appearing here were recently tested experimentally on various circuit diagnosis examples. The algorithm's performance was shown to be superior relative to Model-based Diagnosis (MBD) algorithms [14].
Reference: [17] <author> M. R. Genesereth. </author> <title> The use of design descriptions in automated diagnosis. </title> <journal> Artificial Intelligence, </journal> <volume> 24 </volume> <pages> 411-436, </pages> <year> 1984. </year>
Reference-contexts: For the purpose of this example we assume that the set of expected values for each variable were determined by some pre-processing and all the other values are marked collectively by the symbol "e". Consider the circuit of Figure 5 (also discussed in <ref> [7, 4, 17] </ref>), consisting of three multipliers, M 1 ; M 2 ; M 3 , and two adders, A 1 and A 2 . The values of the five input variables, A; B; C; D, and E, and of the two output variables, F and G, are given.
Reference: [18] <author> J. Kohlas. </author> <title> Symbolic evidence, arguments and valuation networks. </title> <booktitle> In Uncertainty in Artificial Intelligence (UAI-93), </booktitle> <address> Washington D.C, </address> <year> 1993. </year>
Reference-contexts: Examples of such cases are physical or biological systems such as electronic circuits and model-based medical diagnosis systems. Structure-exploiting algorithms for diagnosis that were inspired by algorithms on probabilistic networks appear in [16] and recently in <ref> [3, 18] </ref>. The merits of the belief revision algorithms appearing here were recently tested experimentally on various circuit diagnosis examples. The algorithm's performance was shown to be superior relative to Model-based Diagnosis (MBD) algorithms [14].
Reference: [19] <author> A. K. Mackworth and E. C. Freuder. </author> <title> The complexity of some polynomial network consistency algorithms for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1), </volume> <year> 1985. </year>
Reference-contexts: The algorithms are based on recent work in Constraint Satisfaction Problems (CSPs), which resulted in many efficient algorithms and tractable cases tied specifically to the struc 2 ture of the problem <ref> [11, 15, 19, 12] </ref>. A constraint network consists of a set of variables, each associated with a finite set of possible values, and a set of constraints, specifying joint assignments to the variables "allowed" by the constraints.
Reference: [20] <author> D. A. McAllester. </author> <title> An outlook on truth-maintenance. </title> <type> Technical Report AI Memo 551, </type> <institution> MIT, Boston, Massachusetts, </institution> <year> 1980. </year>
Reference-contexts: The main functionality of a TMS is to determine whether the truth of a given proposition follows logically from a given set of premises and from the set of constraints, and to keep this information current. Two primary approaches to TMS implementation have been proposed: the JTMS (Justification-based TMS) <ref> [13, 20, 22] </ref> and the ATMS (Assumption-based TMS) [5]. Each design implements the main functionality in a different way. A JTMS starts with the given premise set and attempts to identify all provable propositions, hoping that a proof will be derived for the target proposition. <p> Here we focus on the identification of a minimum number of changes to represent minimal change. When originally introduced, algorithms for Truth Maintenance were not accompanied by complexity analysis, or performance guarantees <ref> [13, 6, 20] </ref>. Nevertheless, experimental work with these tools, and more recent complexity analysis, have shown that both JTMS and ATMS functionalities are very inefficient, with ATMS exhibiting higher complexity than JTMS in both time and space. <p> To model change we introduce the notion of assumption variables. The TMS algorithms will be allowed to manipulate those assumptions in response to changes to the network (possibly imposed by observations from the outside world). Since the language of constraints has the same expressive power as propositional logic <ref> [20] </ref>, all the algorithms presented here are applicable to propositional languages. The connection between truth maintenance systems and constraint satisfaction problems was already pointed out by several authors e.g., [6] and [23] [21].
Reference: [21] <author> D. A. McAllester. </author> <title> Truth maintenance. </title> <booktitle> In Proceedings of AAAI-90, </booktitle> <pages> pages 1109-1116, </pages> <year> 1990. </year>
Reference-contexts: Nevertheless, experimental work with these tools, and more recent complexity analysis, have shown that both JTMS and ATMS functionalities are very inefficient, with ATMS exhibiting higher complexity than JTMS in both time and space. A common strategy for reducing computational complexity has been to use efficient algorithms <ref> [21] </ref> which are complete only for restricted languages (e.g., unit resolution for Horn theories), but may be incomplete in general. This paper examine another type of restriction, one based on the structure of the knowledge-base as reflected in the graphical properties of the T M S constraint set. <p> Since the language of constraints has the same expressive power as propositional logic [20], all the algorithms presented here are applicable to propositional languages. The connection between truth maintenance systems and constraint satisfaction problems was already pointed out by several authors e.g., [6] and [23] <ref> [21] </ref>. The main thrust of these efforts has been to show that search reduction techniques developed in one area may be used to the benefit of the other. Our work here take this idea one step further.
Reference: [22] <author> D. Mcdermott. </author> <title> A general framework for reason maintenance. </title> <journal> Artificial Intelligence, </journal> <volume> 50(3) </volume> <pages> 289-329, </pages> <year> 1991. </year>
Reference-contexts: The main functionality of a TMS is to determine whether the truth of a given proposition follows logically from a given set of premises and from the set of constraints, and to keep this information current. Two primary approaches to TMS implementation have been proposed: the JTMS (Justification-based TMS) <ref> [13, 20, 22] </ref> and the ATMS (Assumption-based TMS) [5]. Each design implements the main functionality in a different way. A JTMS starts with the given premise set and attempts to identify all provable propositions, hoping that a proof will be derived for the target proposition.
Reference: [23] <author> G. Provan. </author> <title> Complexity analysis of multiple-context TMSs in scene representation. </title> <booktitle> In Proceedings of AAAI-87, </booktitle> <pages> pages 173-177, </pages> <address> Seattle, Washington, </address> <year> 1987. </year>
Reference-contexts: Since the language of constraints has the same expressive power as propositional logic [20], all the algorithms presented here are applicable to propositional languages. The connection between truth maintenance systems and constraint satisfaction problems was already pointed out by several authors e.g., [6] and <ref> [23] </ref> [21]. The main thrust of these efforts has been to show that search reduction techniques developed in one area may be used to the benefit of the other. Our work here take this idea one step further.
Reference: [24] <author> L. G. Valiant. </author> <title> The complexity of enumeration and reliability problems. </title> <journal> Siam Jouranl of Computation, </journal> <volume> 8(3) </volume> <pages> 105-117, </pages> <year> 1987. </year>
Reference-contexts: This results in a distributed arc-consistency algorithm that minimizes the number of message passing along the links. Computing n-supports is not easier than determining entailment directly (namely, by calculating all the solutions of the network). In fact, it is generally very complex, as it is #P -complete <ref> [24] </ref>. However, for acyclic networks the complexity of computing n-supports is the same as that of computing one solution.

References-found: 24

