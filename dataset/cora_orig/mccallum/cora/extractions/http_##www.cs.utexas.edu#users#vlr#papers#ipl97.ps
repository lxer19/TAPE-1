URL: http://www.cs.utexas.edu/users/vlr/papers/ipl97.ps
Refering-URL: http://www.cs.utexas.edu/users/vlr/pub.html
Root-URL: 
Title: An Optimal EREW PRAM Algorithm For Minimum Spanning Tree Verification  
Author: Valerie King Chung Keung Poon Vijaya Ramachandran and Santanu Sinha 
Date: 62(3):153-159, 1997  July 29, 1997  
Note: A slightly different version appears in IPL  
Abstract: We present a deterministic parallel algorithm on the EREW PRAM model to verify a minimum spanning tree of a graph. The algorithm runs on a graph with n vertices and m edges in O(log n) time and O(m + n) work. The algorithm is a parallelization of King's linear time sequential algorithm for the problem. 
Abstract-found: 1
Intro-found: 1
Reference: [AS87] <author> N. Alon and B. Schieber. </author> <title> Optimal preprocessing for answering online product queries. </title> <type> Technical report, </type> <institution> Tel Aviv University, </institution> <year> 1987. </year>
Reference: [Bor26] <editor> O. Bor ffi u vka. O jistem problemu minimaln im. Praca Moravske Pr irodovedecke Spolecnosti, </editor> <volume> 3 </volume> <pages> 37-58, </pages> <year> 1926. </year> <note> In Czech. </note>
Reference: [CDR86] <author> S. A. Cook, C. Dwork, and R. Reischuk. </author> <title> Upper and lower time bounds for parallel random access machines without simultaneous writes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15(1) </volume> <pages> 87-97, </pages> <month> February </month> <year> 1986. </year>
Reference: [CKT96] <author> R. Cole, P.N. Klein, and R.E. Tarjan. </author> <title> Finding minimum spanning trees in logarithmic time and linear work using random sampling. </title> <booktitle> In Proceedings of the 1996 ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 243-249, </pages> <year> 1996. </year>
Reference: [CL93] <author> K. W. Chong and T. W. Lam. </author> <title> Connected components in O(log n log log n) time on the EREW PRAM. </title> <booktitle> In Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 11-20, </pages> <year> 1993. </year>
Reference: [DRT92] <author> B. Dixon, M. Rauch, and R. Tarjan. </author> <title> Verification and sensitivity analysis of minimum spanning trees in linear time. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(6) </volume> <pages> 1184-1192, </pages> <year> 1992. </year> <month> 8 </month>
Reference-contexts: A simpler algorithm was developed by King ([Kin95]), which is essentially a simplification and implementation of the Komlos algorithm. For parallel algorithms, Alon and Schieber ([AS87]) gave one on the CREW PRAM model whose work bound is superlinear by a factor of ff (m; n). Parallelizing the algorithm in <ref> [DRT92] </ref>, Dixon and Tarjan ([DT94]) obtained an algorithm on the CREW PRAM with optimal bounds (i.e., logarithmic time and linear work). We further improve it by parallelizing King's algorithm ([Kin95]). Our result is an optimal algorithm for this problem on the EREW PRAM, which is the weakest PRAM model.
Reference: [DT94] <author> B. Dixon and R.E. Tarjan. </author> <title> Optimal parallel verification of minimum spanning trees in logarithmic time. </title> <booktitle> In Parallel and Distributed Computing, Theory and Practice, Lecture Notes in Compututer Science 805, </booktitle> <pages> pages 13-22. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: Dixon and Tarjan have also given an optimal CREW algorithm (<ref> [DT94] </ref>). In this paper, we present a parallel algorithm which runs in optimal time and work bounds on the weaker EREW PRAM model. This resolves an open question posed in [DT94]. The high-level structure of the algorithm has been adapted from [DT94] and [Kin95]. We use tree contraction (shunting) ([KR90, KD88]) to convert the given spanning tree to a logarithmic depth Bor ffi u vka tree. As in [DT94] we decompose the given tree into microtrees of size O ( p <p> and Tarjan have also given an optimal CREW algorithm (<ref> [DT94] </ref>). In this paper, we present a parallel algorithm which runs in optimal time and work bounds on the weaker EREW PRAM model. This resolves an open question posed in [DT94]. The high-level structure of the algorithm has been adapted from [DT94] and [Kin95]. We use tree contraction (shunting) ([KR90, KD88]) to convert the given spanning tree to a logarithmic depth Bor ffi u vka tree. As in [DT94] we decompose the given tree into microtrees of size O ( p The microtrees are verified in parallel using King's ([Kin95]) sequential linear <p> This resolves an open question posed in <ref> [DT94] </ref>. The high-level structure of the algorithm has been adapted from [DT94] and [Kin95]. We use tree contraction (shunting) ([KR90, KD88]) to convert the given spanning tree to a logarithmic depth Bor ffi u vka tree. As in [DT94] we decompose the given tree into microtrees of size O ( p The microtrees are verified in parallel using King's ([Kin95]) sequential linear time algorithm. The process is repeated once more. This leaves a macrotree of size O (n= log n). <p> This resolves an open questions in <ref> [DT94] </ref>. The algorithm is also strongly optimal. Additionally, our algorithm has a very simple high-level structure and makes use of elementary parallel constructs. A closely related problem is to find a minimum spanning tree in a graph.
Reference: [GMR94] <author> P.B. Gibbons, Y. Matias, and V. Ramachandran. </author> <title> The QRQW PRAM: Accounting for contention in parallel algorithms. </title> <booktitle> In Proceedings of the Fifth Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 638-648, </pages> <year> 1994. </year>
Reference: [HZ96] <author> S. Halperin and U Zwick. </author> <title> Optimal randomized EREW PRAM algorithms for finding spanning forests and for other basic graph connectivity problems. </title> <booktitle> In Proceedings of the Seventh ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 438-447, </pages> <year> 1996. </year>
Reference: [J92] <author> J. JaJa. </author> <title> An Introduction to Parallel Algorithms. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: This remaining macrotree is verified by forming an exhaustive query structure, which can be done in work linear in the size of the graph. Our algorithm uses simple parallel constructs such as tree contraction and the Euler tour (see, e.g., <ref> [KR90, J92] </ref>) along with King's ([Kin95]) algorithm as a procedure. The problem of verifying a fl Department of Computer Science, University of Victoria, Victoria, Canada. This research was supported in part by NSERC. y Department of Computer Sciences, University of Texas at Austin, TX 78712. <p> Next, for each nontree edge, we find the least common ancestor (lca) of its endpoints in B. This can be done in logarithmic time and linear work on an EREW PRAM using the preprocessing 4 algorithm described in <ref> [J92] </ref>, together with a scheme described in [Ram96]. Then, we split each nontree edge &lt;x; y&gt; into two edges, namely &lt;x; lca (x; y)&gt; and &lt;y; lca (x; y)&gt; with the same weight as &lt;x; y&gt;. <p> The least common ancestors (lca's) may be computed in the same work-time bounds with the method for computing lca's for nontree edges given in [Ram96]. (Briefly, this method is based on the algorithm for finding lca's based on the Euler tour (see, e.g., <ref> [J92] </ref>) that preprocesses in O (log n) time and O (n) work on the EREW PRAM and answers queries in constant time in parallel on the CREW PRAM. [Ram96] observes that the lca's of any collection of nontree edges can be found in O (log n) time and linear work on <p> The final comparison is a constant time linear work operation. 7 By the above analysis it follows that the overall algorithm runs in O (log n) time and O (m + n) work. These bounds are strongly optimal (as defined in <ref> [J92] </ref>) even on a CREW PRAM.
Reference: [Kar95] <author> D. R. Karger. </author> <title> Random Sampling in Graph Optimization Problems. </title> <type> PhD thesis, </type> <institution> Depart ment of Computer Science, Stanford University, </institution> <year> 1995. </year>
Reference: [KD88] <author> S. R. Kosaraju and A. Delcher. </author> <title> Optimal parallel evaluation of tree-structured computa tions raking. </title> <booktitle> In Aegean Workshop on Computing, </booktitle> <pages> pages 101-110, </pages> <year> 1988. </year>
Reference-contexts: This 3 procedure is recursively repeated until we have a binary tree. Note that the number of dummy nodes is linear in the size of the original tree. Next, we use tree contraction as described in <ref> [KR90, KD88] </ref>. Tree contraction shrinks a tree into a single vertex by repeatedly applying the shunt operation (which is called rake in [KD88]; we prefer the term shunt since this operation is derived from the shunt operation on DAGs presented in [MRK88]). <p> Note that the number of dummy nodes is linear in the size of the original tree. Next, we use tree contraction as described in [KR90, KD88]. Tree contraction shrinks a tree into a single vertex by repeatedly applying the shunt operation (which is called rake in <ref> [KD88] </ref>; we prefer the term shunt since this operation is derived from the shunt operation on DAGs presented in [MRK88]).
Reference: [Kin95] <author> V. King. </author> <title> A simpler minimum spanning tree verification algorithm. </title> <booktitle> In Lecture Notes in Compututer Science 955, </booktitle> <pages> pages 440-448. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: In this paper, we present a parallel algorithm which runs in optimal time and work bounds on the weaker EREW PRAM model. This resolves an open question posed in [DT94]. The high-level structure of the algorithm has been adapted from [DT94] and <ref> [Kin95] </ref>. We use tree contraction (shunting) ([KR90, KD88]) to convert the given spanning tree to a logarithmic depth Bor ffi u vka tree. As in [DT94] we decompose the given tree into microtrees of size O ( p The microtrees are verified in parallel using King's ([Kin95]) sequential linear time algorithm. <p> The Bor ffi u vka tree B (as defined in <ref> [Kin95] </ref>) of T is the tree of components that are formed when the Bor ffi u vka algorithm ([Bor26]) for finding a minimum spanning tree is applied to T . <p> We shall prove the following property of a modified Bor ffi u vka tree. This was proved earlier for the Bor u vka tree in <ref> [Kin95] </ref>. Lemma 1 Let T be a spanning tree and let B be a modified Bor ffi u vka tree constructed as described above. <p> We shall call the latter tree a macrotree. We can now verify in parallel that the edges within the microtrees do not violate the minimality condition, using the sequential algorithm in <ref> [Kin95] </ref> for each microtree. Processors can be allocated by computing prefix sums on an auxiliary array containing the number of nontree edges lying wholly within each microtree and making a proportional allocation of microtrees to processors.
Reference: [Kom85] <author> J. Komlos. </author> <title> Linear verification for spanning trees. </title> <journal> Combinatorica, </journal> <volume> 5 </volume> <pages> 57-65, </pages> <year> 1985. </year>
Reference: [KR90] <author> R. M. Karp and V. Ramachandran. </author> <title> Parallel algorithms for shared-memory machines. </title> <booktitle> In Handbook of Theoritical Computer science, volume A:Algorithms and Complexity, </booktitle> <pages> pages 869-941. </pages> <publisher> MIT Press, </publisher> <address> Cambridge Mass., </address> <year> 1990. </year>
Reference-contexts: This remaining macrotree is verified by forming an exhaustive query structure, which can be done in work linear in the size of the graph. Our algorithm uses simple parallel constructs such as tree contraction and the Euler tour (see, e.g., <ref> [KR90, J92] </ref>) along with King's ([Kin95]) algorithm as a procedure. The problem of verifying a fl Department of Computer Science, University of Victoria, Victoria, Canada. This research was supported in part by NSERC. y Department of Computer Sciences, University of Texas at Austin, TX 78712. <p> This 3 procedure is recursively repeated until we have a binary tree. Note that the number of dummy nodes is linear in the size of the original tree. Next, we use tree contraction as described in <ref> [KR90, KD88] </ref>. Tree contraction shrinks a tree into a single vertex by repeatedly applying the shunt operation (which is called rake in [KD88]; we prefer the term shunt since this operation is derived from the shunt operation on DAGs presented in [MRK88]).
Reference: [MRK88] <author> G.L. Miller, V. Ramachandran, and E. Kaltofen. </author> <title> Efficient parallel evaluation of straight line code and arithmetic circuits. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(4) </volume> <pages> 687-695, </pages> <year> 1988. </year>
Reference-contexts: Next, we use tree contraction as described in [KR90, KD88]. Tree contraction shrinks a tree into a single vertex by repeatedly applying the shunt operation (which is called rake in [KD88]; we prefer the term shunt since this operation is derived from the shunt operation on DAGs presented in <ref> [MRK88] </ref>). Given a leaf u whose parent is p (u), the shunt operation applied to u removes u and p (u) from the tree and connects the sibling of u to p (p (u)), the parent of p (u). The tree contraction algorithm is applicable only to binary trees.
Reference: [PR97] <author> C. K. Poon and Vijaya Ramachandran. </author> <title> A randomized linear work EREW PRAM algo rithm to find a minimum spanning tree. </title> <booktitle> In Proceedings of the 8th Annual International Symposium on Algorithms and Computation (ISAAC'97), </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: As a first step to solving this open problem two of the authors of this paper have developed a linear work EREW PRAM algorithm to find a minimum spanning tree that runs in slightly super-logarithmic time <ref> [PR97] </ref>; this gives the first linear work, polylogarithmic time algorithm on the EREW PRAM for this problem.
Reference: [Ram96] <author> V. Ramachandran. </author> <title> Private communication to Uri Zwick, </title> <month> January, </month> <year> 1996. </year> <note> To be included in journal version of [HZ96]. </note>
Reference-contexts: Next, for each nontree edge, we find the least common ancestor (lca) of its endpoints in B. This can be done in logarithmic time and linear work on an EREW PRAM using the preprocessing 4 algorithm described in [J92], together with a scheme described in <ref> [Ram96] </ref>. Then, we split each nontree edge &lt;x; y&gt; into two edges, namely &lt;x; lca (x; y)&gt; and &lt;y; lca (x; y)&gt; with the same weight as &lt;x; y&gt;. These new edges can be stored at x and y respectively to avoid write conflicts. <p> This is a logarithmic time, linear work EREW computation ([TV85]). The least common ancestors (lca's) may be computed in the same work-time bounds with the method for computing lca's for nontree edges given in <ref> [Ram96] </ref>. (Briefly, this method is based on the algorithm for finding lca's based on the Euler tour (see, e.g., [J92]) that preprocesses in O (log n) time and O (n) work on the EREW PRAM and answers queries in constant time in parallel on the CREW PRAM. [Ram96] observes that the <p> edges given in <ref> [Ram96] </ref>. (Briefly, this method is based on the algorithm for finding lca's based on the Euler tour (see, e.g., [J92]) that preprocesses in O (log n) time and O (n) work on the EREW PRAM and answers queries in constant time in parallel on the CREW PRAM. [Ram96] observes that the lca's of any collection of nontree edges can be found in O (log n) time and linear work on an EREW PRAM by this method, provided all endpoints of edges are distinct. To enforce this, [Ram96] transforms the tree by appending a chain to each vertex, with <p> answers queries in constant time in parallel on the CREW PRAM. <ref> [Ram96] </ref> observes that the lca's of any collection of nontree edges can be found in O (log n) time and linear work on an EREW PRAM by this method, provided all endpoints of edges are distinct. To enforce this, [Ram96] transforms the tree by appending a chain to each vertex, with one copy of the vertex for each nontree edge incident on it, computes lca's of nontree edges in this new tree, and determines the lca's of the nontree edges in the original tree from this.
Reference: [Tar79] <author> R. E. Tarjan. </author> <title> Applications of path compressions on balanced trees. </title> <journal> Journal of the ACM, </journal> <volume> 26(4) </volume> <pages> 690-715, </pages> <year> 1979. </year>
Reference: [TV85] <author> R. E. Tarjan and U. Vishkin. </author> <title> An efficient parallel biconnectivity algorithm. </title> <journal> SIAM Journal on Computing, </journal> <volume> 14(4) </volume> <pages> 862-874, </pages> <month> November </month> <year> 1985. </year> <month> 9 </month>
References-found: 20

