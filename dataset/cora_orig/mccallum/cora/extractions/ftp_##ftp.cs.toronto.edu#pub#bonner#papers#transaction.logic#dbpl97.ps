URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/dbpl97.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Title: Transaction Datalog: A Compositional Language for Transaction Programming  
Author: Anthony J. Bonner 
Web: www.cs.toronto.edu/~bonner  
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: University of Toronto, Department of Computer Science,  
Abstract: In the classical model of database transactions, large transactions cannot be built out of smaller ones. Instead, transactions are mod-elled as atomic and isolated units of work. This model has been widely successful in traditional database applications, in which transactions perform only a few simple operations on small amounts of simply-structured data. Unfortunately, this model is inappropriate for more complex applications in which transactions must be combined and coordinated to achieve a larger goal. Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. These applications require new transaction models, new methods of transaction management, and new transaction languages. This paper focuses on the latter issue: languages for specifying non-classical transactions, and combining them into complex processes. In particular, we develop Transaction Datalog, a deductive language that integrates queries, updates, and transaction composition in a simple logical framework. This integration extends the deductive-database paradigm with several new capabilities. For instance, Transaction Datalog supports all the properties of classical transactions, such as persistence, atomicity, isolation, abort and rollback. It also supports properties found in many new transaction models, such as subtransaction hierarchies, concurrency within individual transactions, cooperation between concurrent activities, a separation of atomicity and isolation, and fine-grained control over abort and rollback. These capabilities are all provided within a purely logical framework, including a natural model theory and a sound-and-complete proof theory. This paper outlines the problems of developing a compositional transaction language, illustrates our solution (Transaction Datalog) through a series of examples, and develops its formal semantics in terms of a logical inference system.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical transactions and database queries (e:g:, <ref> [1, 2, 12] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> Formally, these issues are abstracted away, and only the effects of transactions are considered. These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu <ref> [1, 2] </ref>, the procedural language QL of Chandra and Harel [12], 3 Dynamic Prolog [24], LDL [28], and numerous other languages. A detailed discussion of these works can be found in [9, 10]. The coordination approach focuses on non-classical transactions.
Reference: 2. <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical transactions and database queries (e:g:, <ref> [1, 2, 12] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> Formally, these issues are abstracted away, and only the effects of transactions are considered. These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu <ref> [1, 2] </ref>, the procedural language QL of Chandra and Harel [12], 3 Dynamic Prolog [24], LDL [28], and numerous other languages. A detailed discussion of these works can be found in [9, 10]. The coordination approach focuses on non-classical transactions.
Reference: 3. <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing inter-task dependencies. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Developments in this area include ACTA [13], proposals for Third Generation TP Monitors [14], approaches based on temporal logic <ref> [3] </ref> and event algebras [32], and numerous other works. In this paper, we addressed both issues, and integrated them into a single language. Specifically, Transaction Datalog can specify the effects of classical and non-classical transactions, and it can compose simple transaction programs into complex ones.
Reference: 4. <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Database transactions were originally modeled as atomic and isolated units of work, with no internal structure and no external connections <ref> [4] </ref>. This "classical" transaction model has been widely successful for applications like banking, airline reservations, and inventory control, where transactions perform only a few simple operations on small amounts of simply-structured data. <p> Because communication can be two-way, executions of such programs need not be serializable <ref> [4] </ref>, so T D programs need not be isolated transactions. To specify isolation, T D includes a logical modality called the modality of isolation, denoted fi. Intuitively, the formula fi means that program executes in isolation from all other concurrent programs. <p> When the transaction base is implicit, we sometimes refer to the goal as a program. A transaction program is a program whose main procedure executes in isolation, i:e:, has the form fi. In the literature <ref> [4, 19] </ref>, a transaction is a particular execution of a transaction program. This paper uses the same definition, but when there is no confusion, we sometimes use "transaction" as an abbreviation for "transaction program." 3.2 Execution Traces Concurrency in Transaction Datalog has an interleaving semantics. <p> As a special case, a concurrent execution of transactions must have the same effect as a serial execution; i:e:, transactions must be serializable, which is the normal understanding in database concurrency control <ref> [4] </ref>. Our semantics therefore specifies the effects of a T D program, but not its actual execution inside a DBMS. In fact, inside a DBMS, concurrent programs may be executed in parallel, rather than in an interleaved fashion.
Reference: 5. <author> A.J. Bonner. </author> <title> The power of cooperating transactions. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: In the case of database programming languages (like T D), these operations are elementary database transactions. The precise set of elementary operations is somewhat arbitrary, and in this paper, four are provided. These operations are simple, they can be efficiently implemented, and they lead to expressive completeness <ref> [5] </ref>. They are also minimal, since removing any one of them causes a loss of expressive completeness [5]. To represent these four operations, we use four types of expression: q, r.empty, ins.q, del.q. The first two expressions are yes/no queries. <p> The precise set of elementary operations is somewhat arbitrary, and in this paper, four are provided. These operations are simple, they can be efficiently implemented, and they lead to expressive completeness <ref> [5] </ref>. They are also minimal, since removing any one of them causes a loss of expressive completeness [5]. To represent these four operations, we use four types of expression: q, r.empty, ins.q, del.q. The first two expressions are yes/no queries. Intuitively, q means "Is atom q in the database," and r.empty means "Is relation r empty." The other two expressions are updates.
Reference: 6. <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Estes Park, Colorado, </address> <month> August </month> <year> 1997. </year> <note> Springer Verlag. Long version available at http://www.cs.toronto.edu/~bonner/papers.html #transaction-logic. </note>
Reference-contexts: The examples show how logical formulas in T D can be interpreted procedurally and declaratively, and how they lead quickly to the basic properties of nested transactions. More-involved examples are given in the long version of this paper <ref> [6] </ref>. As in any programming language, programs in Transaction Datalog are ul-timately built from a set of elementary operations. In the case of database programming languages (like T D), these operations are elementary database transactions. <p> In contrast, the procedural semantics involves one process waiting for another process to perform an update, as described in Example 4. A more-involved example of cooperation between processes in T D is given in the long version of this paper <ref> [6] </ref>, where concurrent transactions are combined into a workflow. Example 4. (Communication and Synchronization) The rules below define a process and two subprocesses. <p> A more-involved example of logical inference is given in the long version of this paper <ref> [6] </ref>. 4 Related Work This section compares and contrasts Transaction Datalog with other languages in the literature. We have divided the comparison into several broad areas. Due to space limitations, we have limited most of the comparisons to formalisms involving concurrency.
Reference: 7. <author> A.J. Bonner and M. Kifer. </author> <title> Results on reasoning about action in transaction logic. </title> <note> 1998. Submitted for publication. </note>
Reference-contexts: Transaction Datalog is derived from a general logic of state change called Transaction Logic [8, 9, 10, 11]. Transaction Logic allows users to express properties of transaction programs and to reason about them <ref> [7] </ref>. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. In addition, like classical logic, Transaction Logic has a "Horn" fragment with both a procedural and declarative semantics.
Reference: 8. <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [8, 9, 10, 11] </ref>. Transaction Logic allows users to express properties of transaction programs and to reason about them [7]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [8, 9, 11] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, T D has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and a sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [8, 9, 10, 11] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [8, 9, 10, 11] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere [8, 9, 11]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere <ref> [8, 9, 11] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> The simplified semantics is based on a logical inference system that describes the legal execution traces of a T D program. It should also be mentioned that Transaction Logic (and thus Transaction Datalog) has an operational semantics based on a proof procedure with unification <ref> [11, 10, 8] </ref>. This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. <p> As the examples in this paper illustrate, programs in Transaction Datalog can take either point of view, or a combination of both. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [8, 9, 10, 11] </ref>. Thanks go to David Toman and Michael Kifer for their comments and suggestions on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: 9. <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [8, 9, 10, 11] </ref>. Transaction Logic allows users to express properties of transaction programs and to reason about them [7]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [8, 9, 11] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, T D has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and a sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [8, 9, 10, 11] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [8, 9, 10, 11] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere [8, 9, 11]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere <ref> [8, 9, 11] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> In addition, many have no notion of database state or declarative query, many are propositional, and many are simply inappropriate for database applications. An extensive comparison of these formalisms with the sequential version of Transaction Logic can be found in <ref> [9, 10] </ref>. Transaction Languages: Broadly speaking, the theoretical literature has explored two kinds of transaction language, in order to address two different problems. In the first approach, the user specifies the effects of individual transactions; and in the second approach, he coordinates the execution of a set of transactions. <p> Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [1, 2], the procedural language QL of Chandra and Harel [12], 3 Dynamic Prolog [24], LDL [28], and numerous other languages. A detailed discussion of these works can be found in <ref> [9, 10] </ref>. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system. The focus is on relationships between tasks. <p> As the examples in this paper illustrate, programs in Transaction Datalog can take either point of view, or a combination of both. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [8, 9, 10, 11] </ref>. Thanks go to David Toman and Michael Kifer for their comments and suggestions on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: 10. <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.toronto.edu/~bonner/ transaction-logic.html. </note>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [8, 9, 10, 11] </ref>. Transaction Logic allows users to express properties of transaction programs and to reason about them [7]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Like classical Datalog, T D has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and a sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [8, 9, 10, 11] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [8, 9, 10, 11] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere [8, 9, 11]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> The simplified semantics is based on a logical inference system that describes the legal execution traces of a T D program. It should also be mentioned that Transaction Logic (and thus Transaction Datalog) has an operational semantics based on a proof procedure with unification <ref> [11, 10, 8] </ref>. This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. <p> In addition, many have no notion of database state or declarative query, many are propositional, and many are simply inappropriate for database applications. An extensive comparison of these formalisms with the sequential version of Transaction Logic can be found in <ref> [9, 10] </ref>. Transaction Languages: Broadly speaking, the theoretical literature has explored two kinds of transaction language, in order to address two different problems. In the first approach, the user specifies the effects of individual transactions; and in the second approach, he coordinates the execution of a set of transactions. <p> Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [1, 2], the procedural language QL of Chandra and Harel [12], 3 Dynamic Prolog [24], LDL [28], and numerous other languages. A detailed discussion of these works can be found in <ref> [9, 10] </ref>. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system. The focus is on relationships between tasks. <p> As the examples in this paper illustrate, programs in Transaction Datalog can take either point of view, or a combination of both. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [8, 9, 10, 11] </ref>. Thanks go to David Toman and Michael Kifer for their comments and suggestions on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: 11. <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [8, 9, 10, 11] </ref>. Transaction Logic allows users to express properties of transaction programs and to reason about them [7]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [8, 9, 11] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, T D has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and a sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [8, 9, 10, 11] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> In particular, the database can contain structures and access methods designed for efficient communication. For instance, some relations in the database could be a view of a set of message queues or communication channels, as described in <ref> [11] </ref>. To convey the right intuition, we refer to formulas of the form q 1 q 2 q n as sequential processes, or simply as processes. The example also illustrates how concurrency in T D can be interpreted both procedurally and declaratively. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [8, 9, 10, 11] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere [8, 9, 11]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof pro-cedures, which have been published elsewhere <ref> [8, 9, 11] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> The simplified semantics is based on a logical inference system that describes the legal execution traces of a T D program. It should also be mentioned that Transaction Logic (and thus Transaction Datalog) has an operational semantics based on a proof procedure with unification <ref> [11, 10, 8] </ref>. This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. <p> The development is based on a logical inference system that specifies the legal execution traces of a T D program. In <ref> [11] </ref>, an equivalent, model-theoretic semantics is developed, along with a practical proof procedure based on unification. The inference system below manipulates expressions of the form P : D ` , called sequents. Here, P is a transaction base, is a ground goal, and D is an execution trace. <p> First, they extend the logic programming paradigm with a host of transactional notions, including atomicity, isolation, rollback, and subtransaction hierarchies. Second, they integrate concurrency, communication and updates into a purely logical framework, including a natural model theory and a sound-and-complete proof theory <ref> [11] </ref>. This integration presents interesting possibilities for concurrent logic programming (CLP). For instance, concurrent processes can now communicate via the database, since one process can read what another process writes. This form of communication leads to a programming style that is very different from that of existing CLP languages [31]. <p> As the examples in this paper illustrate, programs in Transaction Datalog can take either point of view, or a combination of both. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [8, 9, 10, 11] </ref>. Thanks go to David Toman and Michael Kifer for their comments and suggestions on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: 12. <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical transactions and database queries (e:g:, <ref> [1, 2, 12] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [1, 2], the procedural language QL of Chandra and Harel <ref> [12] </ref>, 3 Dynamic Prolog [24], LDL [28], and numerous other languages. A detailed discussion of these works can be found in [9, 10]. The coordination approach focuses on non-classical transactions.
Reference: 13. <author> P.K. Chrysanthis and K. Ramamritham. </author> <title> Synthesis of extended transaction models using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 450-491, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: Typically, these languages model a classical transaction as a finite automaton with a small number of states such as "start," "commit" and "abort." Temporal constraints between the states of different automata are then specified in a propositional logic. Developments in this area include ACTA <ref> [13] </ref>, proposals for Third Generation TP Monitors [14], approaches based on temporal logic [3] and event algebras [32], and numerous other works. In this paper, we addressed both issues, and integrated them into a single language.
Reference: 14. <author> U. Dayal, H. Garcia-Molina, M. Hsu, B. Kao, and M.-C. Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-397, </pages> <address> Washington, DD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [15, 18, 19, 21]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [14, 15, 18, 19] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated T D). <p> The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance. In addition to new methods of transaction management, new transaction languages are also needed <ref> [14] </ref>. These languages must deal both with conventional programming issues and with transactional issues. For instance, they must allow transaction programs to be combined sequentially, concurrently, and hierarchically. In addition, they must deal with persistent data and with transaction abort, rollback, atomicity, and isolation. <p> We shall refer to these two approaches as specification and coordination, respectively. In software-engineering terms, these two approaches correspond to "programming in the small" and "programming in the large," respectively <ref> [14] </ref>. The specification approach implicitly focuses on classical transactions. The problem is to develop a high-level language for specifying database queries and updates, and to establish its theoretical properties, such as formal semantics, data complexity, and expressive power. Numerous languages with logical, algebraic and procedural semantics have been developed. <p> Developments in this area include ACTA [13], proposals for Third Generation TP Monitors <ref> [14] </ref>, approaches based on temporal logic [3] and event algebras [32], and numerous other works. In this paper, we addressed both issues, and integrated them into a single language.
Reference: 15. <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [15, 18, 19, 21] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [14, 15, 18, 19]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [15, 18, 19, 21]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [14, 15, 18, 19] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated T D). <p> Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http://www.cs.toronto.edu/~bonner/transaction-logic.html 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [15, 18, 19, 27] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language. <p> Such dependencies are typical of many new database applications, in which transactions participate in a complex web of relations. These new applications require the development of new transaction models. This need has been eloquently expressed by Jim Gray <ref> [15, page xvii] </ref>: The transaction concept has emerged as the key structuring technique for distributed data and distributed computations. Originally developed and applied to database applications, the transaction model is now being used in new application areas ranging from process control to cooperative work. <p> Many new transaction models have been proposed in the literature. Nested Transactions were the first [19, 27]. More recent models include Sagas [17], ConTracts [35], Flex Transactions [16], Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions [36], among others <ref> [15] </ref>. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
Reference: 16. <author> A.K. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewcz. </author> <title> A multidatabase transaction model for interbase. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 507-518, </pages> <address> Brisbane, Australia, </address> <month> August 13-16 </month> <year> 1990. </year>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [19, 27]. More recent models include Sagas [17], ConTracts [35], Flex Transactions <ref> [16] </ref>, Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions [36], among others [15]. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
Reference: 17. <author> H. Garcia-Molina and K. Salem. Sagas. </author> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [19, 27]. More recent models include Sagas <ref> [17] </ref>, ConTracts [35], Flex Transactions [16], Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions [36], among others [15]. Much of the research on these models emphasizes transaction management.
Reference: 18. <author> J. Gray. </author> <title> The transaction concept: Virtues and limitations. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 144-154, </pages> <address> Cannes, France, </address> <month> September </month> <year> 1981. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [15, 18, 19, 21] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [14, 15, 18, 19]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [15, 18, 19, 21]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [14, 15, 18, 19] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated T D). <p> Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http://www.cs.toronto.edu/~bonner/transaction-logic.html 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [15, 18, 19, 27] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language.
Reference: 19. <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [15, 18, 19, 21] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [14, 15, 18, 19]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [15, 18, 19, 21]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [14, 15, 18, 19] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated T D). <p> Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http://www.cs.toronto.edu/~bonner/transaction-logic.html 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [15, 18, 19, 27] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language. <p> The first attempt to address this problem lead to the nested transaction model, in which a transaction can be composed of subtransactions <ref> [19, 27] </ref>. As a simple example, suppose we have a transaction program for withdrawing money from a bank account, and another for depositing money. <p> The concept must be made recursive, it must deal with concurrency within a transaction, it must relax the strict isolation among transactions, and it must deal more gracefully with failures. Many new transaction models have been proposed in the literature. Nested Transactions were the first <ref> [19, 27] </ref>. More recent models include Sagas [17], ConTracts [35], Flex Transactions [16], Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions [36], among others [15]. Much of the research on these models emphasizes transaction management. <p> Like classical Datalog, Transaction Datalog can be embellished with negation-as-failure. When this is done, T D can simulate a number of different transaction models. For simplicity, though, this paper focuses on the negation-free version of the language, which is well-suited to specifying nested transactions <ref> [19, 27] </ref>. In this model, a transaction may be decomposed into subtransactions. <p> These subtransactions may execute serially or concurrently, and their effects are undone if the parent transaction aborts, even if the subtransactions have already committed. "Nested transactions provide a powerful mechanism for fine-tuning the scope of rollback in applications with a complex structure" <ref> [19] </ref>. Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [19]. These properties make nested transactions ideal for distributed applications, object-oriented databases, and layered software systems. Numerous examples in this paper deal with nested transactions. <p> if the parent transaction aborts, even if the subtransactions have already committed. "Nested transactions provide a powerful mechanism for fine-tuning the scope of rollback in applications with a complex structure" <ref> [19] </ref>. Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [19]. These properties make nested transactions ideal for distributed applications, object-oriented databases, and layered software systems. Numerous examples in this paper deal with nested transactions. In addition to transactional features, Transaction Datalog provides all the functionality of a declarative query language and a procedural programming language, seamlessly integrated. <p> When the transaction base is implicit, we sometimes refer to the goal as a program. A transaction program is a program whose main procedure executes in isolation, i:e:, has the form fi. In the literature <ref> [4, 19] </ref>, a transaction is a particular execution of a transaction program. This paper uses the same definition, but when there is no confusion, we sometimes use "transaction" as an abbreviation for "transaction program." 3.2 Execution Traces Concurrency in Transaction Datalog has an interleaving semantics.
Reference: 20. <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: Process Algebras: These are a family of algebraic systems for modeling concurrent communicating processes. They include Milner's Calculus of Communicating Systems (CCS) [25], and Hoare's Communicating Sequential Processes (CSP) <ref> [20] </ref>, among others. Transaction Datalog and process algebras use very different formal frameworks. This difference is most easily seen in terms of COSY [23], an early algebraic approach to modeling concurrent processes. COSY is an extension of regular expressions, while Transaction Datalog is an extension of deductive databases.
Reference: 21. <author> M. Hsu, Ed. </author> <title> Special issue on workflow and extended transaction systems. </title> <journal> Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 16(2), </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [15, 18, 19, 21] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [14, 15, 18, 19]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes.
Reference: 22. <author> Samuel Y.K. Hung. </author> <title> Implementation and Performance of Transaction Logic in Prolog. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year> <note> http://www.cs.toronto.edu/~bonner/transaction-logic.html. </note>
Reference-contexts: This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. This procedure is the foundation of our implementation <ref> [22] </ref>. 3.1 Syntax The language of Transaction Datalog includes three infinite enumerable sets of symbols: constant symbols (a; b; c; :::), variables (X; Y; Z; :::), and predicate symbols (p; q; r; :::).
Reference: 23. <author> P.E. Lauer and R.H. Campbell. </author> <title> Formal semantics of a class of high-level primitives for co-ordinating concurrent processes. </title> <journal> Acta Informatica, </journal> <volume> 5 </volume> <pages> 297-332, </pages> <year> 1975. </year>
Reference-contexts: They include Milner's Calculus of Communicating Systems (CCS) [25], and Hoare's Communicating Sequential Processes (CSP) [20], among others. Transaction Datalog and process algebras use very different formal frameworks. This difference is most easily seen in terms of COSY <ref> [23] </ref>, an early algebraic approach to modeling concurrent processes. COSY is an extension of regular expressions, while Transaction Datalog is an extension of deductive databases. Process algebras have since developed into equational theories, but the formal differences with T D remain the same.
Reference: 24. <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [1, 2], the procedural language QL of Chandra and Harel [12], 3 Dynamic Prolog <ref> [24] </ref>, LDL [28], and numerous other languages. A detailed discussion of these works can be found in [9, 10]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: 25. <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Indeed, one of the novelties of T D is that it provides a logical foundation for exactly this kind of interaction. Process Algebras: These are a family of algebraic systems for modeling concurrent communicating processes. They include Milner's Calculus of Communicating Systems (CCS) <ref> [25] </ref>, and Hoare's Communicating Sequential Processes (CSP) [20], among others. Transaction Datalog and process algebras use very different formal frameworks. This difference is most easily seen in terms of COSY [23], an early algebraic approach to modeling concurrent processes.
Reference: 26. <author> R. Milner. </author> <title> Operational and algebraic semantics of concurrent processes. </title> <booktitle> In [34], chapter 19, </booktitle> <pages> pages 1201-1242. </pages> <year> 1990. </year>
Reference-contexts: For instance, process algebras explicitly reject the notion of processes interacting via shared memory (such as a database) <ref> [26] </ref>. Instead, each process has its own local memory, and it interacts with other processes via synchronized communication. In contrast, Transaction Datalog is explicitly intended for database transactions, i:e:, processes that interact with a shared database.
Reference: 27. <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <booktitle> Series in Information Systems. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http://www.cs.toronto.edu/~bonner/transaction-logic.html 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [15, 18, 19, 27] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language. <p> The first attempt to address this problem lead to the nested transaction model, in which a transaction can be composed of subtransactions <ref> [19, 27] </ref>. As a simple example, suppose we have a transaction program for withdrawing money from a bank account, and another for depositing money. <p> The concept must be made recursive, it must deal with concurrency within a transaction, it must relax the strict isolation among transactions, and it must deal more gracefully with failures. Many new transaction models have been proposed in the literature. Nested Transactions were the first <ref> [19, 27] </ref>. More recent models include Sagas [17], ConTracts [35], Flex Transactions [16], Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions [36], among others [15]. Much of the research on these models emphasizes transaction management. <p> Like classical Datalog, Transaction Datalog can be embellished with negation-as-failure. When this is done, T D can simulate a number of different transaction models. For simplicity, though, this paper focuses on the negation-free version of the language, which is well-suited to specifying nested transactions <ref> [19, 27] </ref>. In this model, a transaction may be decomposed into subtransactions.
Reference: 28. <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [1, 2], the procedural language QL of Chandra and Harel [12], 3 Dynamic Prolog [24], LDL <ref> [28] </ref>, and numerous other languages. A detailed discussion of these works can be found in [9, 10]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: 29. <author> M. H. Nodine, S. Ramaswamy, and S. B. Zdonik. </author> <title> A cooperative transaction model for design databases. </title> <booktitle> In [15], chapter 3, </booktitle> <pages> pages 53-85. </pages> <year> 1992. </year>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [19, 27]. More recent models include Sagas [17], ConTracts [35], Flex Transactions [16], Cooperative Transactions <ref> [29] </ref>, Multi-Level Transactions and Open Nested Transactions [36], among others [15]. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
Reference: 30. <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional work-flows. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: A typical control dependency is, "Task T2 cannot start until task T1 has committed;" and a typical data dependency is, "Task T2 can start if task T1 returns a value greater than 25" <ref> [30] </ref>. Specifying database updates and queries is not an issue here. Formally, the effects of tasks are abstracted away, and only the relation 3 Although presented as a query language, QL is even more natural as an update language. ships between tasks are considered.
Reference: 31. <author> E. Shapiro. </author> <title> A family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference-contexts: This integration presents interesting possibilities for concurrent logic programming (CLP). For instance, concurrent processes can now communicate via the database, since one process can read what another process writes. This form of communication leads to a programming style that is very different from that of existing CLP languages <ref> [31] </ref>. In such languages, concurrent processes communicate via shared variables and unification. This kind of communication is orthogonal to communication via the database. Both are possible in T D. Implementations of T D may therefore adopt many of the techniques of shared-variable communication developed for CLP.
Reference: 32. <author> M.P. Singh. </author> <title> Semantical considerations on workflows: An algebra for intertask dependencies. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September 6-8 </month> <year> 1995. </year>
Reference-contexts: Developments in this area include ACTA [13], proposals for Third Generation TP Monitors [14], approaches based on temporal logic [3] and event algebras <ref> [32] </ref>, and numerous other works. In this paper, we addressed both issues, and integrated them into a single language. Specifically, Transaction Datalog can specify the effects of classical and non-classical transactions, and it can compose simple transaction programs into complex ones.
Reference: 33. <author> Transarc-Encina. </author> <title> Encina Transactional Processing System: Transactional-C Programmers Guide and Reference, </title> <institution> TP-00-D347. Transarc Corp., Pittsburg, </institution> <address> PA, </address> <year> 1991. </year>
Reference-contexts: For instance, some transaction programming languages offer save points, which support a limited form of nested transactions and partial rollback. In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions <ref> [33] </ref>. Likewise, a number of research projects have developed programming languages for nested transac-tions and other non-classical transaction models. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete.
Reference: 34. <editor> J. van Leeuwen, editor. </editor> <booktitle> Handbook of Theoretical Computer Science, Volume B, Formal Methods and Semantics. </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference: 35. <author> H. Wachter and A. Reuter. </author> <title> The ConTract model. </title> <booktitle> In [15], chapter 7, </booktitle> <pages> pages 220-263. </pages> <year> 1992. </year>
Reference-contexts: In particular, they cannot be met by having application programmers specify transactions in a conventional programming language on top of a conventional DBMS (e:g:, by using SQL embedded in C, or even concurrent C). As another example, consider the following abstract process, taken from <ref> [35] </ref>: Run Transaction T1. Then execute transactions T2, T3, and T4 in parallel. Immediately after their successful completion, start T5. But, if one of T2, T3, or T4 fails, then abort the other two. In this case, the effects of T1 have to be cancelled as well. <p> Many new transaction models have been proposed in the literature. Nested Transactions were the first [19, 27]. More recent models include Sagas [17], ConTracts <ref> [35] </ref>, Flex Transactions [16], Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions [36], among others [15]. Much of the research on these models emphasizes transaction management.
Reference: 36. <author> G. Weikum and H.-J. Schek. </author> <title> Concepts and applications of multilevel transactions and open nested transactions. </title> <booktitle> In [15], chapter 13, </booktitle> <pages> pages 515-553. </pages> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [19, 27]. More recent models include Sagas [17], ConTracts [35], Flex Transactions [16], Cooperative Transactions [29], Multi-Level Transactions and Open Nested Transactions <ref> [36] </ref>, among others [15]. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
References-found: 36

