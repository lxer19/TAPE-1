URL: ftp://ftp.cs.purdue.edu/pub/hosking/papers/oopsla92.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/hosking/papers.html
Root-URL: http://www.cs.purdue.edu
Title: A Comparative Performance Evaluation of Write Barrier Implementations  
Author: Antony L. Hosking J. Eliot B. Moss Darko Stefanovic 
Address: Amherst, MA 01003  
Affiliation: Object Systems Laboratory Department of Computer Science University of Massachusetts  
Abstract: Generational garbage collectors are able to achieve very small pause times by concentrating on the youngest (most recently allocated) objects when collecting, since objects have been observed to die young in many systems. Generational collectors must keep track of all pointers from older to younger generations, by monitoring all stores into the heap. This write barrier has been implemented in a number of ways, varying essentially in the granularity of the information observed and stored. Here we examine a range of write barrier implementations and evaluate their relative performance within a generation scavenging garbage collector for Smalltalk. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software: Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: However, for compiled languages this overhead will be incurred at every one of an arbitrary number of compiled store sites, which may be prohibitive. For this reason we have devised a scheme similar to that introduced by Ap-pel <ref> [1] </ref>, allowing batch filtering and recording of pointer stores, using a sequential store buffer (SSB) to buffer the necessary information. The SSB comprises some number of contiguous pages, bounded by a guard page that has been protected from writes.
Reference: [2] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Commun. ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> Nov. </month> <year> 1970. </year>
Reference-contexts: All objects directly reachable from the roots are copied into new space, and the roots updated. In the second phase all objects reachable from the new space objects are copied over using a non-recursive Ch eney scan <ref> [2] </ref>. 1 As each object is copied, a forwarding pointer is left in the old copy, so that other references to the object can be updated as they are encountered. Since the toolkit makes no object format assumptions, the details of forwarding pointer format are up to the language implementor.
Reference: [3] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: After a scavenge, all the old steps of the scavenged generations are deleted and their blocks become available for allocation. 2.4 Smalltalk details Our Smalltalk system consists of a virtual machine of our own design. It includes a bytecode interpreter for the instruction set defined in <ref> [3] </ref>, and we run a Smalltalk image cloned (converted into our format) from an earlier release of Smalltalk-80. 2 We manage contexts (stack frames) as described in [7]. In particular, a number of frames are preallocated and assembled on a doubly linked list.
Reference: [4] <author> R. L. Hudson, J. E. B. Moss, A. Diwan, and C. F. </author> <title> Weight. A language-independent garbage collector toolkit. </title> <type> COINS Technical Report 91-47, </type> <institution> University of Massachusetts, Amherst, </institution> <month> Sept. </month> <year> 1991. </year> <note> Submitted for publication. </note>
Reference-contexts: Its basis is the UMass Language-Independent Garbage Collector Toolkit, to which we add language specific code for our Smalltalk system. We first offer a condensed description of the toolkit and continue with appropriate details of the Smalltalk system. For a more detailed discussion of the toolkit see <ref> [4] </ref>. 2.1 The toolkit concept The toolkit divides the responsibility for and support of garbage collection into two parts: a language-independent part, supplied by the toolkit, and a language-specific part, nominally supplied by the language implementor.
Reference: [5] <author> D. W. Jones. </author> <title> An empirical comparison of priority-queue and event-set implementations. </title> <journal> Commun. ACM, </journal> <volume> 29(4) </volume> <pages> 300-311, </pages> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Further, as also discussed in [14], any object that has few pointers in it and that exceeds some threshold in size should be stored in LOS to avoid the overhead of copying. Without going into all the details, LOS uses free list allocation based on splay trees <ref> [10, 11, 5] </ref> and once allocated an LOS object is never moved. However, LOS objects still belong to a step, which is indicated by threading the objects onto a doubly linked list rooted in the step data structure.
Reference: [6] <author> K. McCall. </author> <title> The Smalltalk-80 benchmarks. </title> <editor> In G. Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <booktitle> chapter 9, </booktitle> <pages> pages 153-173. </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: This benchmark explores the cost of applications that generate garbage rapidly. Interactivethe macro benchmarks: For this benchmark we iterate 10 times through the full set of macro benchmarks. These benchmarks are part of the standard suite of benchmarks <ref> [6] </ref> used to compare the relative performance of different Smalltalk implementations. They measure system support for the programming activities that constitute typical interaction with the Smalltalk system, such as keyboard activity, compilation of methods to bytecodes, and browsing.
Reference: [7] <author> J. E. B. Moss. </author> <title> Managing stack frames in Smalltalk. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 229-240, </pages> <address> St. Paul Minnesota, </address> <month> July </month> <year> 1987. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 22, </volume> <month> 7 (July </month> <year> 1987). </year>
Reference-contexts: It includes a bytecode interpreter for the instruction set defined in [3], and we run a Smalltalk image cloned (converted into our format) from an earlier release of Smalltalk-80. 2 We manage contexts (stack frames) as described in <ref> [7] </ref>. In particular, a number of frames are preallocated and assembled on a doubly linked list. Ordinary calls traverse the list in one direction and ordinary returns traverse it the other way, with cost similar to a stack.
Reference: [8] <author> R. A. Shaw. </author> <title> Improving garbage collector performance in virtual memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Stanford University, </institution> <month> Mar. </month> <year> 1987. </year>
Reference-contexts: An operating system could more efficiently supply the information needed in the page protection scheme if it offered appropriate calls to manipulate the page dirty bits maintained by most memory management hardware <ref> [8] </ref>. With each of these schemes we are faced with the choice of remembering either the slot that is updated or the object containing that slot. For remembered sets, this is simply a matter of entering the object pointer or the slot address in the appropriate remembered set. <p> Page 13 Shaw considered the relationship of collection to vir-tual memory for LISP programs [9]. In particular, Shaw examined various write barrier methods, including hypothetical user access to page dirty bits maintained by the operating system <ref> [8] </ref>. The most directly related work of which we are aware is [18]. There, Zorn studies not only the write barrier, but also the read barrier, which is used in incremental collection. <p> Note that this suggests that the access to hardware dirty bits discussed in <ref> [8] </ref> may not improve matters much over a decent implementation of reflecting the page trap to user code. We were also surprised that the effects of the various schemes on the running time were not more pronounced, and that much of the difference between the schemes is in root processing.
Reference: [9] <author> R. A. Shaw. </author> <title> Empirical Analysis of a LISP System. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> Feb. </month> <year> 1988. </year> <note> Available as Technical Report CSL-TR-88-351. </note>
Reference-contexts: While our checks are not as tightly coded, the apparent time penalty is still small, although it may be because our interpreter is relatively slow compared with the SOAR design. Page 13 Shaw considered the relationship of collection to vir-tual memory for LISP programs <ref> [9] </ref>. In particular, Shaw examined various write barrier methods, including hypothetical user access to page dirty bits maintained by the operating system [8]. The most directly related work of which we are aware is [18].
Reference: [10] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <booktitle> In Proceedings of the ACM SIGACT Symposium on Theory, </booktitle> <pages> pages 235-245, </pages> <address> Boston, Massachusetts, </address> <month> Apr. </month> <year> 1983. </year>
Reference-contexts: Further, as also discussed in [14], any object that has few pointers in it and that exceeds some threshold in size should be stored in LOS to avoid the overhead of copying. Without going into all the details, LOS uses free list allocation based on splay trees <ref> [10, 11, 5] </ref> and once allocated an LOS object is never moved. However, LOS objects still belong to a step, which is indicated by threading the objects onto a doubly linked list rooted in the step data structure.
Reference: [11] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> J. ACM, </journal> <volume> 32(3), </volume> <month> July </month> <year> 1985. </year>
Reference-contexts: Further, as also discussed in [14], any object that has few pointers in it and that exceeds some threshold in size should be stored in LOS to avoid the overhead of copying. Without going into all the details, LOS uses free list allocation based on splay trees <ref> [10, 11, 5] </ref> and once allocated an LOS object is never moved. However, LOS objects still belong to a step, which is indicated by threading the objects onto a doubly linked list rooted in the step data structure.
Reference: [12] <author> P. G. Sobalvarro. </author> <title> A lifetime-based garbage collector for LISP systems on general-purpose computers, 1988. B.S. </title> <type> Thesis, </type> <institution> Dept. of EECS, Massachusetts Institute of Technology, </institution> <address> Cambridge. </address>
Reference-contexts: The other schemes divide the heap into logical regions of size 2 k bytes, aligned on a 2 k -byte boundary, for some fixed k. We call these regions cards, after <ref> [12, 17] </ref>. Each card has a corresponding entry in a card table indicating whether the card might contain pointers into younger generations.
Reference: [13] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: We have implemented several versions of the three most common write barrier approaches. They vary mostly in the granularity of the information they record. The first scheme associates a remembered set with each generation <ref> [13] </ref>, recording the objects or locations in older generations that may contain pointers into that generation. Any pointer store that creates a reference from an older generation to a younger generation is recorded in the remembered set for the younger generation. <p> For remembered sets, remembering slots is marginally cheaper than remembering objects, since the slots encode the interesting pointer information more exactly, whereas the remembered objects must be scanned to find their interesting pointers. 7 Related Work Ungar introduced generation scavenging <ref> [13] </ref>, building on earlier work on generational collection. Further details as to the cost of store checks appear in [15], with the conclusion that special hardware in the SOAR chip might offer a time performance improvement of 3% over a tightly coded inline check.
Reference: [14] <author> D. Ungar and F. Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 1-17, </pages> <address> San Diego, California, </address> <month> Sept. </month> <year> 1988. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 23, </volume> <month> 11 (Nov. </month> <year> 1988). </year>
Reference-contexts: The degree of advantage depends on the survival rate a/b, but may be significant in some applications. Blocks do introduce a problem: they cannot handle objects larger than the block size. To handle such objects we provide a large object space (LOS), as suggested in <ref> [14] </ref>. Indeed, it is probably a good idea to put in LOS any object that consumes a significant fraction of a block; we used the heuristic threshold of 1/8 of a block. Further, as also discussed in [14], any object that has few pointers in it and that exceeds some threshold <p> handle such objects we provide a large object space (LOS), as suggested in <ref> [14] </ref>. Indeed, it is probably a good idea to put in LOS any object that consumes a significant fraction of a block; we used the heuristic threshold of 1/8 of a block. Further, as also discussed in [14], any object that has few pointers in it and that exceeds some threshold in size should be stored in LOS to avoid the overhead of copying.
Reference: [15] <author> D. M. Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year> <type> Ph.D. Dissertation, </type> <institution> University of California at Berkeley, </institution> <month> February </month> <year> 1986. </year>
Reference-contexts: Further details as to the cost of store checks appear in <ref> [15] </ref>, with the conclusion that special hardware in the SOAR chip might offer a time performance improvement of 3% over a tightly coded inline check.
Reference: [16] <author> P. R. Wilson, M. S. Lam, and T. G. Moher. </author> <title> Effective static-graph reorganization to improve locality in garbage-collected systems. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 177-191, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 6 (June </month> <year> 1991). </year>
Reference-contexts: Also, it would not be hard to incorporate suggestions such as hierarchical clustering <ref> [16] </ref>. 2 Smalltalk-80 is a registered trademark of PARC Place Systems. Page 3 generation 0 (regardless of the generation of the target of the pointer). 3 There is a total of five generations, with one step in each of generations 1, 2, 3, and 4.
Reference: [17] <author> P. R. Wilson and T. G. Moher. </author> <title> Design of the Opportunistic Garbage Collector. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 23-35, </pages> <address> New Orleans, Louisiana, </address> <month> Oct. </month> <year> 1989. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 24, </volume> <month> 10 (Oct. </month> <year> 1989). </year>
Reference-contexts: The other schemes divide the heap into logical regions of size 2 k bytes, aligned on a 2 k -byte boundary, for some fixed k. We call these regions cards, after <ref> [12, 17] </ref>. Each card has a corresponding entry in a card table indicating whether the card might contain pointers into younger generations.
Reference: [18] <author> B. Zorn. </author> <title> Barrier methods for garbage collection. </title> <type> Technical Report CU-CS-494-90, </type> <institution> University of Colorado at Boulder, </institution> <month> Nov. </month> <year> 1990. </year> <note> Page 15 Page 16 Page 17 Page 18 </note>
Reference-contexts: If the item is a pointer, this is followed by a generation test, which we perform by determining the generations of both the modified source object and the target object whose pointer is being stored, and comparing the two. Following Zorn <ref> [18] </ref>, and based on our own run-time traces of the Smalltalk system which reveal that most stores occur to initialize newly allocated objects, we can frequently avoid the need to determine the generation of the target object by checking if the modified object is in generation 0. <p> Page 13 Shaw considered the relationship of collection to vir-tual memory for LISP programs [9]. In particular, Shaw examined various write barrier methods, including hypothetical user access to page dirty bits maintained by the operating system [8]. The most directly related work of which we are aware is <ref> [18] </ref>. There, Zorn studies not only the write barrier, but also the read barrier, which is used in incremental collection. Our results agree with Zorn on the cost of the write barrier: even when implemented in software, its cost appears to be modest.
References-found: 18

