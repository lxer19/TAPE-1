URL: ftp://ftp.win.tue.nl/pub/techreports/michelr/TutorialSemantics.ps.Z
Refering-URL: http://www.win.tue.nl/cs/fm/sjouke/publications.html
Root-URL: http://www.win.tue.nl
Email: email: sjouke@win.tue.nl, michelr@win.tue.nl  
Title: Operational Semantics for MSC'96  
Author: S. Mauw and M.A. Reniers 
Address: P.O. Box 513, NL-5600 MB Eindhoven, The Netherlands.  
Affiliation: Department of Computing Science, Eindhoven University of Technology,  
Abstract-found: 0
Intro-found: 1
Reference: [AHP96] <author> R. Alur, G.J. Holzmann, and D. Peled. </author> <title> An analyzer for Message Sequence Charts. </title> <booktitle> Software Concepts and Tools, </booktitle> <volume> 17(2) </volume> <pages> 70-77, </pages> <year> 1996. </year>
Reference-contexts: Next, it allows for a good comparison to alternative semantics definitions of MSC, such as approaches based on Petri nets [GGR93], Buchi automata [LL95], process algebra [Man93, MWW93], and partial orders <ref> [AHP96] </ref>. Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL [IT88] and LOTOS [BB88] which are also provided with an operational semantics. Finally, an operational semantics is useful for the development of a simulation tool.
Reference: [BB88] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 14(1) </volume> <pages> 25-59, </pages> <year> 1988. </year>
Reference-contexts: Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL [IT88] and LOTOS <ref> [BB88] </ref> which are also provided with an operational semantics. Finally, an operational semantics is useful for the development of a simulation tool. The semantics obtained is mostly an extension of the formal definition of MSC'93 in [IT95].
Reference: [BBP94] <author> J.A. Bergstra, I. Bethke, and A. Ponse. </author> <title> Process algebra with iteration and nesting. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 243-258, </pages> <year> 1994. </year>
Reference-contexts: The constructs optional and exception (newly introduced in MSC'96) are easily captured as special cases of delayed choice and are therefore not considered in this tutorial. The loop operators are based on bounded and unbounded versions of the iteration operator defined in <ref> [BBP94] </ref>. Also these are not considered in this tutorial. For an initial treatment of recursion we refer to [MR97]. We once more explain the transformation by means of an example. We start from the MSC given in Figure 5.
Reference: [BK84] <author> J.A. Bergstra and J.W. Klop. </author> <title> Process algebra for synchronous communication. </title> <journal> Information and Control, </journal> 60(1/3):109-137, 1984. 
Reference-contexts: This turns out to be a special case, i.e., S = ?. Instead of k ? we often write k . This is in line with notation used in the process algebra ACP <ref> [BK84, BW90, BV95, Vra97] </ref>. The parallel composition of two processes is the interleaved execution of the events of the processes while maintaining the ordering of events as specified by the processes in isolation.
Reference: [BM94] <author> J.C.M. Baeten and S. Mauw. </author> <title> Delayed choice: an operator for joining Message Sequence Charts. </title> <editor> In D. Hogrefe and S. Leue, editors, </editor> <booktitle> Formal Description Techniques VII, IFIP Transactions C, Proceedings 7 th International Conference on Formal Description Techniques, </booktitle> <pages> pages 340-354. </pages> <address> Chapman-Hall, </address> <year> 1994. </year>
Reference-contexts: Next, we explain the deduction rules from Table 1. These deduction rules are taken from <ref> [BM94] </ref> where the delayed choice operator was introduced in the setting of bisimulation semantics as a means for composing MSCs.
Reference: [BV95] <author> J.C.M. Baeten and C. Verhoef. </author> <title> Concrete process algebra. </title> <editor> In S. Abramsky, Dov M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Semantic Modelling, volume 4 of Handbook of Logic in Computer Science, </booktitle> <pages> pages 149-268. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Both terminology and notation are taken from <ref> [BV95] </ref>. The goal of an operational semantics is, given an expression denoting a process in a certain state, to describe all possible activities that can be performed by the process in that state and to describe the state of the process after such an activity. <p> This turns out to be a special case, i.e., S = ?. Instead of k ? we often write k . This is in line with notation used in the process algebra ACP <ref> [BK84, BW90, BV95, Vra97] </ref>. The parallel composition of two processes is the interleaved execution of the events of the processes while maintaining the ordering of events as specified by the processes in isolation.
Reference: [BW90] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra, </title> <booktitle> volume 18 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: This turns out to be a special case, i.e., S = ?. Instead of k ? we often write k . This is in line with notation used in the process algebra ACP <ref> [BK84, BW90, BV95, Vra97] </ref>. The parallel composition of two processes is the interleaved execution of the events of the processes while maintaining the ordering of events as specified by the processes in isolation.
Reference: [Eng85] <author> J. Engelfriet. </author> <title> Determinacy ! (observation equivalence = trace equivalence). </title> <journal> Theoretical Computer Science, </journal> <volume> 36(1) </volume> <pages> 21-25, </pages> <year> 1985. </year>
Reference-contexts: For a definition thereof we refer to [Par81]. In the case of MSC'96, where we only have deterministic processes, i.e., it is not possible for a process to perform an a-transition to two states represented by different terms, the notions of trace equivalence and bisimulation equivalence coincide <ref> [Eng85] </ref>. The reason to use bisimulation equivalence anyway is that we anticipate at an extension of the set of operators with an operator for non-deterministic choice. In the presence of non-deterministic choice, there is a difference between trace semantics and bisimulation semantics.
Reference: [GGR93] <author> J. Grabowski, P. Graubmann, and E. Rudolph. </author> <title> Towards a Petri net based semantics definition for Message Sequence Charts. </title> <editor> In O. Faergemand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings of the Sixth SDL Forum, </booktitle> <pages> pages 179-190, </pages> <address> Darm-stadt, 1993. Amsterdam, </address> <publisher> North-Holland. </publisher>
Reference-contexts: First, it unambiguously defines the meaning of an MSC by interpreting an MSC in the mathematical model of transition graphs. Next, it allows for a good comparison to alternative semantics definitions of MSC, such as approaches based on Petri nets <ref> [GGR93] </ref>, Buchi automata [LL95], process algebra [Man93, MWW93], and partial orders [AHP96]. Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL [IT88] and LOTOS [BB88] which are also provided with an operational semantics.
Reference: [Hau94] <author> O. Haugen. </author> <title> MSC structural concepts. </title> <type> Technical Report TD 9006, ITU-T Experts Meeting SG 10, Turin, </type> <year> 1994. </year>
Reference-contexts: First, High-level MSCs (HMSC) [MR95] are used to indicate the relation between different smaller MSCs. In an HMSC one can express parallelism, sequencing, alternatives and recursion. HMSCs are the synthesis of the roadmap approach [IT93a] and the operator approach <ref> [Hau94] </ref>. As such they replace the informal use of roadmaps [IT93a] for overview specification. With MSC reference expressions one is able to abstract from the actual contents of an MSC. In an MSC, references to other MSCs may be included, combined by several operators.
Reference: [HL97] <author> O. Haugen and Y. Lahav. </author> <title> MSC/SDL new features. </title> <booktitle> Tutorials of the Eighth SDL Forum, </booktitle> <year> 1997. </year>
Reference-contexts: It is assumed that the reader has (at least) a basic knowledge of the language MSC'93. For a comprehensive treatment of the complete MSC'96 language we refer to <ref> [HL97] </ref>. An introduction to MSC'96 is [RGG96]. 2.1 Events An event is the basic unit of observation. It models a part of the system's behaviour which is considered as one indivisible action.
Reference: [IT88] <author> ITU-T. </author> <title> ITU-T Recommendation Z.100: Specification and Description Language (SDL). ITU-T, </title> <address> Geneva, </address> <year> 1988. </year>
Reference-contexts: Next, it allows for a good comparison to alternative semantics definitions of MSC, such as approaches based on Petri nets [GGR93], Buchi automata [LL95], process algebra [Man93, MWW93], and partial orders [AHP96]. Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL <ref> [IT88] </ref> and LOTOS [BB88] which are also provided with an operational semantics. Finally, an operational semantics is useful for the development of a simulation tool. The semantics obtained is mostly an extension of the formal definition of MSC'93 in [IT95].
Reference: [IT93a] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.100 Annex I: SDL Methodology Guidelines. </title> <address> ITU-TS, Geneva, </address> <year> 1993. </year>
Reference-contexts: First, High-level MSCs (HMSC) [MR95] are used to indicate the relation between different smaller MSCs. In an HMSC one can express parallelism, sequencing, alternatives and recursion. HMSCs are the synthesis of the roadmap approach <ref> [IT93a] </ref> and the operator approach [Hau94]. As such they replace the informal use of roadmaps [IT93a] for overview specification. With MSC reference expressions one is able to abstract from the actual contents of an MSC. In an MSC, references to other MSCs may be included, combined by several operators. <p> First, High-level MSCs (HMSC) [MR95] are used to indicate the relation between different smaller MSCs. In an HMSC one can express parallelism, sequencing, alternatives and recursion. HMSCs are the synthesis of the roadmap approach <ref> [IT93a] </ref> and the operator approach [Hau94]. As such they replace the informal use of roadmaps [IT93a] for overview specification. With MSC reference expressions one is able to abstract from the actual contents of an MSC. In an MSC, references to other MSCs may be included, combined by several operators. A substitution mechanism is included which supports the reuse of modular specifications.
Reference: [IT93b] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.120: Message Sequence Chart (MSC). </title> <address> ITU-TS, Geneva, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Acknowledgements We would like to thank the members of the MSC development group for their initiating work. Andre Engels is acknowledged for the fruitful discussions on some technical matters. 2 MSC'96 The previous version of the MSC language, MSC'93 <ref> [IT93b] </ref>, was developed to express behavioural traces of distributed systems. It has primitives for denoting objects (instances) and for describing the relative order of messages exchanged between these objects. Furthermore it has some more specific features, such as instance creation and timers.
Reference: [IT95] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.120 Annex B: Algebraic semantics of Message Sequence Charts. </title> <address> ITU-TS, Geneva, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: As the semantics is currently still under development, details may change. However, we expect that the basic ideas of the chosen approach remain stable. The semantics proposed for standardisation is very much an extension of the previous formal semantics <ref> [IT95, MR94a, Mau96] </ref>. There are some differences, though. First, we have slightly changed the set of basic operators, such that it yields a smoother definition. <p> From a semantical point of view the three ways to combine components can be described in one framework. In this tutorial we do not consider substructure references. For a thorough treatment of those we refer to <ref> [MR94b, IT95] </ref>. Also gates and substitutions are not treated in this tutorial. Gates are difficult but not troublesome and substitution should be trivial. <p> Finally, an operational semantics is useful for the development of a simulation tool. The semantics obtained is mostly an extension of the formal definition of MSC'93 in <ref> [IT95] </ref>. A major difference is that the state operator, used for enforcing the message orderings, is replaced by the generalised sequential composition operator. The reason is that the latter allows for a uniform treatment of the message orderings and causal orderings. S. Mauw and M.A. Reniers 17
Reference: [IT96] <author> ITU-TS. </author> <title> ITU-TS Draft Recommendation Z.120: Message Sequence Chart 1996 (MSC96). </title> <address> ITU-TS, Geneva, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently, the ITU 1 -standardised specification language Message Sequence Chart (MSC) <ref> [IT96] </ref> has been extended with constructs for more complete and structured specifications. The new version of the language is called MSC'96. Currently, research is performed on the extension of the old formal semantics towards a semantics for MSC'96.
Reference: [LL95] <author> P.B. Ladkin and S. Leue. </author> <title> Interpreting message flow graphs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 7(5) </volume> <pages> 473-509, </pages> <year> 1995. </year>
Reference-contexts: First, it unambiguously defines the meaning of an MSC by interpreting an MSC in the mathematical model of transition graphs. Next, it allows for a good comparison to alternative semantics definitions of MSC, such as approaches based on Petri nets [GGR93], Buchi automata <ref> [LL95] </ref>, process algebra [Man93, MWW93], and partial orders [AHP96]. Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL [IT88] and LOTOS [BB88] which are also provided with an operational semantics.
Reference: [LRR97] <author> S. Loidl, E. Rudolph, and U. Rinkel. </author> <title> MSC'96 and beyond a critical look. </title> <booktitle> Workshop of the Eighth SDL Forum, 1997. 18 Tutorial for the Eighth SDL Forum, </booktitle> <address> Evry, France, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: It is obvious that the a-posteriori construction of a formal semantics will reveal many places in which the informal language description is ambiguous, under-specified, inconsistent or suboptimal. In <ref> [LRR97] </ref> a number of such situations is described. Nevertheless, there are also parts of MSC'96 that can be understood unambiguously. Of course, these are the parts of MSC'96 which are already covered by the old formal semantics.
Reference: [Man93] <author> J. de Man. </author> <title> Towards a formal semantics of Message Sequence Charts. </title> <editor> In O. Faergemand and A. Sarma, editors, </editor> <title> SDL'93 : Using Objects, </title> <booktitle> Proceedings of the Sixth SDL Forum, </booktitle> <pages> pages 157-165, </pages> <address> Darmstadt, 1993. Amsterdam, </address> <publisher> North-Holland. </publisher>
Reference-contexts: First, it unambiguously defines the meaning of an MSC by interpreting an MSC in the mathematical model of transition graphs. Next, it allows for a good comparison to alternative semantics definitions of MSC, such as approaches based on Petri nets [GGR93], Buchi automata [LL95], process algebra <ref> [Man93, MWW93] </ref>, and partial orders [AHP96]. Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL [IT88] and LOTOS [BB88] which are also provided with an operational semantics. Finally, an operational semantics is useful for the development of a simulation tool.
Reference: [Mau96] <author> S. Mauw. </author> <title> The formalization of Message Sequence Charts. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 28(12) </volume> <pages> 1643-1657, </pages> <year> 1996. </year> <note> Special issue on SDL and MSC, </note> <editor> guest editor O. </editor> <publisher> Haugen. </publisher>
Reference-contexts: As the semantics is currently still under development, details may change. However, we expect that the basic ideas of the chosen approach remain stable. The semantics proposed for standardisation is very much an extension of the previous formal semantics <ref> [IT95, MR94a, Mau96] </ref>. There are some differences, though. First, we have slightly changed the set of basic operators, such that it yields a smoother definition.
Reference: [MM95] <author> S. Mauw and E.A. van der Meulen. </author> <title> Generating tools for Message Sequence Charts. </title> <editor> In R. Braek and A. Sarma, editors, </editor> <booktitle> SDL'95 with MSC in CASE, Proceedings of the Seventh SDL Forum, </booktitle> <pages> pages 51-62, </pages> <address> Oslo, 1995. Amsterdam, </address> <publisher> North-Holland. </publisher>
Reference-contexts: With a simulator sequences of events can be generated at random or user-driven. The basic functionality of a simulator resembles the definition of an operational semantics. For Basic Message Sequence Charts, i.e., Message Sequence Charts with only instances, messages and local actions in <ref> [MM95] </ref> the process algebra semantics of MSC'93 is used to define a prototype simulator. 5 Summary and concluding remarks We have explained the basics of the formal semantics of MSC'96 which are currently under development. The semantics of an MSC is derived in several steps.
Reference: [MR94a] <author> S. Mauw and M.A. Reniers. </author> <title> An algebraic semantics of Basic Message Sequence Charts. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 269-277, </pages> <year> 1994. </year>
Reference-contexts: As the semantics is currently still under development, details may change. However, we expect that the basic ideas of the chosen approach remain stable. The semantics proposed for standardisation is very much an extension of the previous formal semantics <ref> [IT95, MR94a, Mau96] </ref>. There are some differences, though. First, we have slightly changed the set of basic operators, such that it yields a smoother definition. <p> For the message orderings we need to express that the message output precedes the message input. This can be achieved by using a state operator as was done in <ref> [MR94a] </ref>. However, this approach does not generalise easily for the causal orderings. Therefore, we need a more general means to describe ordering. This is achieved by attributing the composition operators with a set of ordering requirements. <p> Constructs for design in the large are interpreted as applications of several operators. We obtained an operational semantics, which consists of a description of the (possible) be-haviour of an MSC. We did not provide for any process algebraic axioms as presented in <ref> [MR94a, MR94b] </ref>. We expect a complete axiomatisation to be infeasible. Nevertheless, an operational semantics as proposed here, serves several purposes. First, it unambiguously defines the meaning of an MSC by interpreting an MSC in the mathematical model of transition graphs.
Reference: [MR94b] <author> S. Mauw and M.A. Reniers. </author> <title> An algebraic semantics of Message Sequence Charts. </title> <type> Technical Report CSN 94/23, </type> <institution> Eindhoven University of Technology, Department of Computing Science, Eindhoven, </institution> <year> 1994. </year>
Reference-contexts: From a semantical point of view the three ways to combine components can be described in one framework. In this tutorial we do not consider substructure references. For a thorough treatment of those we refer to <ref> [MR94b, IT95] </ref>. Also gates and substitutions are not treated in this tutorial. Gates are difficult but not troublesome and substitution should be trivial. <p> Constructs for design in the large are interpreted as applications of several operators. We obtained an operational semantics, which consists of a description of the (possible) be-haviour of an MSC. We did not provide for any process algebraic axioms as presented in <ref> [MR94a, MR94b] </ref>. We expect a complete axiomatisation to be infeasible. Nevertheless, an operational semantics as proposed here, serves several purposes. First, it unambiguously defines the meaning of an MSC by interpreting an MSC in the mathematical model of transition graphs.
Reference: [MR95] <author> S. Mauw and M.A. Reniers. </author> <title> Hierarchical MSC. </title> <booktitle> SG10 meeting, </booktitle> <address> Geneva TD 28, ITU-TS, </address> <year> 1995. </year>
Reference-contexts: In combination with the coregion construct this makes it possible to express arbitrary partial orders on the events in a coregion. 2.3 Design Several techniques have been introduced to support the modular design of specifications in a top-down or bottom-up manner. First, High-level MSCs (HMSC) <ref> [MR95] </ref> are used to indicate the relation between different smaller MSCs. In an HMSC one can express parallelism, sequencing, alternatives and recursion. HMSCs are the synthesis of the roadmap approach [IT93a] and the operator approach [Hau94]. As such they replace the informal use of roadmaps [IT93a] for overview specification.
Reference: [MR97] <author> S. Mauw and M.A. Reniers. </author> <title> High-Level Message Sequence Charts. </title> <editor> In A. Cavalli and A. Sarma, editors, SDL'97: </editor> <title> Time for Testing - SDL, </title> <booktitle> MSC and Trends, Proceedings of the Eighth SDL Forum, </booktitle> <address> Evry, France, 1997. </address> <publisher> Elsevier Science Publishers. </publisher>
Reference-contexts: The loop operators are based on bounded and unbounded versions of the iteration operator defined in [BBP94]. Also these are not considered in this tutorial. For an initial treatment of recursion we refer to <ref> [MR97] </ref>. We once more explain the transformation by means of an example. We start from the MSC given in Figure 5. This example shows how to deal with complex building blocks such as coregions and inline expressions.
Reference: [MWW93] <author> S. Mauw, M. van Wijk, and T. Winter. </author> <title> A formal semantics of synchronous Interwork-ings. </title> <editor> In O. Faergemand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings of the Sixth SDL Forum, </booktitle> <pages> pages 167-178, </pages> <address> Amsterdam, 1993. Darmstadt, </address> <publisher> North-Holland. </publisher>
Reference-contexts: It can be thought of as the vertical composition of MSC fragments. The operator ffi, i.e., ffi ? , is based on the weak sequential composition operator of [RW94] and the interworking sequencing operator of <ref> [MWW93] </ref>. In MSC every event is associated to an instance on which it is defined. <p> First, it unambiguously defines the meaning of an MSC by interpreting an MSC in the mathematical model of transition graphs. Next, it allows for a good comparison to alternative semantics definitions of MSC, such as approaches based on Petri nets [GGR93], Buchi automata [LL95], process algebra <ref> [Man93, MWW93] </ref>, and partial orders [AHP96]. Moreover, it enables a comparison to other languages for the description of distributed systems, such as SDL [IT88] and LOTOS [BB88] which are also provided with an operational semantics. Finally, an operational semantics is useful for the development of a simulation tool.
Reference: [Par81] <author> D.M.R. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> Theoretical Computer Science, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <booktitle> Proceedings of the Fifth GI-Conference, </booktitle> <address> Kerlsruhe, West Germany. </address>
Reference-contexts: Usually we omit the labels of the nodes. The operational semantics presented can be used to define a notion of equivalence on processes. Examples thereof are trace equivalence, bisimulation equivalence and graph isomorphism. The intended equivalence for MSC'96 is bisimulation semantics. For a definition thereof we refer to <ref> [Par81] </ref>. In the case of MSC'96, where we only have deterministic processes, i.e., it is not possible for a process to perform an a-transition to two states represented by different terms, the notions of trace equivalence and bisimulation equivalence coincide [Eng85].
Reference: [RGG96] <author> E. Rudolph, J. Grabowski, and P. Graubmann. </author> <title> Tutorial on Message Sequence Charts (MSC'96). Tutorials of the First joint International Conference on Formal Description Techniques for Distributed Systems and Communication Protocols, and Protocol Specification, Testing, and Verification (FORTE/PSTV'96), </title> <year> 1996. </year>
Reference-contexts: It is assumed that the reader has (at least) a basic knowledge of the language MSC'93. For a comprehensive treatment of the complete MSC'96 language we refer to [HL97]. An introduction to MSC'96 is <ref> [RGG96] </ref>. 2.1 Events An event is the basic unit of observation. It models a part of the system's behaviour which is considered as one indivisible action.
Reference: [RW94] <author> A. Rensink and H. Wehrheim. </author> <title> Weak sequential composition in process algebras. </title> <editor> In B. Jonsson and J. Parrow, editors, CONCUR'94: </editor> <booktitle> Concurrency Theory, volume 836 of Lecture Notes in Computer Science, </booktitle> <pages> pages 226-241, </pages> <address> Uppsala, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: It can be thought of as the vertical composition of MSC fragments. The operator ffi, i.e., ffi ? , is based on the weak sequential composition operator of <ref> [RW94] </ref> and the interworking sequencing operator of [MWW93]. In MSC every event is associated to an instance on which it is defined.
Reference: [Vra97] <author> J.L.M. Vrancken. </author> <title> The algebra of communicating processes with empty step. </title> <journal> Theoretical Computer Science, </journal> <volume> 177(2) </volume> <pages> 287-328, </pages> <year> 1997. </year>
Reference-contexts: This turns out to be a special case, i.e., S = ?. Instead of k ? we often write k . This is in line with notation used in the process algebra ACP <ref> [BK84, BW90, BV95, Vra97] </ref>. The parallel composition of two processes is the interleaved execution of the events of the processes while maintaining the ordering of events as specified by the processes in isolation.
References-found: 30

