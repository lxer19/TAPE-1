URL: ftp://ftp.cis.upenn.edu/pub/papers/kannan/shibu.ps.Z
Refering-URL: http://www.cis.upenn.edu/~kannan/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Computing the Local Consensus of Trees  
Author: Sampath Kannan Tandy Warnow Shibu Yooseph 
Date: November 21, 1995  
Address: Philadelphia, PA 19104  
Affiliation: Department of Computer and Information Science University of Pennsylvania  
Abstract: The inference of consensus from a set of evolutionary trees is a fundamental problem in a number of fields, such as biology and historical linguistics, and many models for inferring this consensus have been proposed. In this paper we present a model for deriving what we call a local consensus tree T from a set of trees, T . The model we propose presumes a function f , called a total local consensus rule, which determines for every triple A of species, the form that the local consensus tree should take on A. We show that all local consensus trees, when they exist, can be constructed in polynomial time, and that many fundamental problems can be solved in linear time. We also consider partial local consensus rules and study optimization problems under this model. We present linear time algorithms for several variations. Finally we point out that the local consensus approach ties together many previous approaches to constructing consensus trees.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho A., Hopcroft J., Ullman J., </author> <title> The design and analysis of computer algorithms, </title> <publisher> Addison-Wesley Pub. Co., </publisher> <year> 1974 </year>
Reference-contexts: Note that this process of identifying rep and rep fl has to be done only once. Analysis of running time : The isomorphism test in Phase 0 can be performed in O (n) using a simple modification of the tree-isomorphism testing algorithm in <ref> [1] </ref>. There is an O (n) cost for preprocessing of T 1 and T 2 to answer lca queries in Phase 1.
Reference: [2] <author> Aho, Sagiv, Szymanski, and Ullman, </author> <title> Inferring a tree from lowest common ancestors with an application to the optimization of relational expressions, </title> <journal> SIAM J. of Computing, </journal> <volume> Vol 10, No. 3, </volume> <year> 1981. </year>
Reference-contexts: The construction of the RDLC can be accomplished by defining the set A = f ((a; b); c) : T 1 jfa; b; cg = T 2 jfa; b; cg = ((a; b)c)g. This set of rooted triples can then be passed to the algorithm of Aho et al. <ref> [2] </ref>, which computes a tree (if it exists) having the required form on every triple in the set, and resolving a minimum number of additional triples outside that set. The algorithm in [2] takes O (pn) time where p = jAj. <p> This set of rooted triples can then be passed to the algorithm of Aho et al. <ref> [2] </ref>, which computes a tree (if it exists) having the required form on every triple in the set, and resolving a minimum number of additional triples outside that set. The algorithm in [2] takes O (pn) time where p = jAj. Since in our case, p 2 O (n 3 ), the use of the algorithm of [2] would result in a running time of O (n 4 ). <p> The algorithm in <ref> [2] </ref> takes O (pn) time where p = jAj. Since in our case, p 2 O (n 3 ), the use of the algorithm of [2] would result in a running time of O (n 4 ). We will obtain a speed-up to an O (n 2 ) algorithm (which includes the verification) for the construction of the relaxed-discord tree, by using the fact that the tree necessarily exists. <p> We will obtain a speed-up to an O (n 2 ) algorithm (which includes the verification) for the construction of the relaxed-discord tree, by using the fact that the tree necessarily exists. Our algorithm however takes advantage of the ideas in <ref> [2] </ref>, and so we begin by briefly describing how that algorithm works. 6.2.1 The ASSU Algorithm In [2], Aho et al. describe algorithms which determine if a family of constraints on least common ancestor relations can be satisfied within a single rooted tree. <p> Our algorithm however takes advantage of the ideas in <ref> [2] </ref>, and so we begin by briefly describing how that algorithm works. 6.2.1 The ASSU Algorithm In [2], Aho et al. describe algorithms which determine if a family of constraints on least common ancestor relations can be satisfied within a single rooted tree. We describe here the simple algorithm they give for the case where the constraints are given as rooted resolved triples, ((x; y); z). <p> Computing the Local Consensus of Trees 22 Running Time Analysis: Note that this algorithm does not require an explicit verification of the constructed tree, since in fact we know that the tree exists and we are simply computing it by mimicking efficiently what the algorithm in <ref> [2] </ref> would create. There are at most n recursive stages. We will show that each stage can be implemented in O (n) time thereby proving the O (n 2 ) bound. Case 2 can be handled in O (n) time as follows. <p> We begin by discussing the case where f is a partial local consensus function. Lemma 7.1. (Aho et. al <ref> [2] </ref>) Let A be a multi-set of k rooted triples on a leaf set S, with jSj = n. We can determine in O (kn log n) time if a tree T exists such that T jt is homeomorphic to t for all t 2 A. <p> We can determine in O (kn log n) time if a tree T exists such that T jt is homeomorphic to t for all t 2 A. In [15], an algorithm is given for the problem addressed in <ref> [2] </ref> for the case where all the triples are resolved. In this case a faster algorithm can be obtained. Lemma 7.2. (Henzinger, King, Warnow [15]) Let A be a multi-set of k resolved rooted triples on a leaf set S, with jSj = n.
Reference: [3] <author> Barthelemy, J. and Janowitz, F. </author> <title> A formal theory of consensus, </title> <journal> SIAM J. Disc. Math., </journal> <volume> 3 </volume> <month> 305-322 </month> <year> (1991). </year>
Reference: [4] <author> Barthelemy, J. and McMorris, F. </author> <title> The median procedure for n-Trees, </title> <journal> Journal of Classification, </journal> <volume> 3 </volume> <month> 329-334 </month> <year> (1986). </year>
Reference-contexts: The median tree can be computed in polynomial time Computing the Local Consensus of Trees 24 and has a nice characterization in terms of the character encoding <ref> [4, 16, 6] </ref>. Both the above notions are related to versions of the local consensus problem, and the relevant local consensus trees always contain at least as much `information' as these trees. The work represented in this paper can be extended in several directions.
Reference: [5] <author> Wm. Brown, E.M. Prager, A. Wang, A.C. Wilson, </author> <title> Mitochondrial DNA sequences of primates: tempo and mode of evolution, </title> <journal> J. Mol. Evol. </journal> <volume> 18 </volume> <pages> 225-239, </pages> <year> 1982. </year>
Reference: [6] <author> Day, W.H.E. </author> <title> Optimal algorithms for comparing trees with labeled leaves, </title> <journal> Journal of Classification, </journal> <month> 2;7-28 </month> <year> (1985). </year>
Reference-contexts: This particular consensus tree always exists and can be constructed in O (n) time <ref> [6] </ref>. The construction part of the algorithm for binary local consensus trees is therefore simple, and what remains is the verification that the strict consensus tree is also the binary local consensus tree (i.e. that the tree we have constructed using the algorithm in [6] satisfies the constraints imposed upon it <p> be constructed in O (n) time <ref> [6] </ref>. The construction part of the algorithm for binary local consensus trees is therefore simple, and what remains is the verification that the strict consensus tree is also the binary local consensus tree (i.e. that the tree we have constructed using the algorithm in [6] satisfies the constraints imposed upon it by the binary local consensus rule). 3.2 Verifying that a Consensus Tree is a Binary Local Consensus Tree We now prove some structural lemmas to help determine whether the consensus tree is in fact the binary local consensus. Lemma 3.2. <p> If not, declare that T is not the binary local consensus tree. Computing the Local Consensus of Trees 8 Theorem 3.1. Construction and verification for the binary local consensus can be done in linear time. Proof. Day's algorithm <ref> [6] </ref> runs in linear time. Also, step 2 of the above algorithm takes linear time since at most a linear number of species are reintroduced by replacement above. <p> Thus ff =2 C (T plc ). 2 5.2 Construction Phase By Theorem 5.1, the pessimistic local consensus tree, if it exists, is identically the strict consensus tree. Thus to construct the pessimistic local consensus tree, it suffices to use the O (n) algorithm in <ref> [6] </ref> for the strict consensus tree. 5.3 Verification Phase Let T 1 and T 2 be the input trees, and let T be the strict consensus tree constructed using the algorithm in [6]. <p> Thus to construct the pessimistic local consensus tree, it suffices to use the O (n) algorithm in <ref> [6] </ref> for the strict consensus tree. 5.3 Verification Phase Let T 1 and T 2 be the input trees, and let T be the strict consensus tree constructed using the algorithm in [6]. We want to be able to verify whether T is actually the pessimistic local consensus in the case that T is a star. If T 1 or T 2 is already a star then there is nothing to verify since T is the true pessimistic local consensus. <p> Hence the strict consensus of T 1 and T 2 is the relaxed-accord local consensus of T 1 and T 2 . 2 As a consequence, the relaxed-accord local consensus can be constructed in O (n) time using the algorithm in <ref> [6] </ref>, and there is no need to verify that the tree constructed is correct. 6.2 Relaxed-Discord local consensus In the relaxed-discord local consensus (RDLC) problem we require that any triple on which the trees T 1 and T 2 agree must have its topology preserved in the consensus tree T . <p> The median tree can be computed in polynomial time Computing the Local Consensus of Trees 24 and has a nice characterization in terms of the character encoding <ref> [4, 16, 6] </ref>. Both the above notions are related to versions of the local consensus problem, and the relevant local consensus trees always contain at least as much `information' as these trees. The work represented in this paper can be extended in several directions.
Reference: [7] <author> G.F. Estabrook, C.S. Johnson, Jr. and F.R. McMorris, </author> <title> An idealized concept of the true cladistic character, </title> <journal> Math. Biosci. </journal> <volume> 23, </volume> <year> 1975, </year> <pages> pp. 263-272. </pages>
Reference: [8] <author> G.F. Estabrook, C.S. Johnson, Jr., and F.R. McMorris, </author> <title> An algebraic analysis of cladistic characters, </title> <journal> Discrete Math., </journal> <volume> 16, </volume> <year> 1976, </year> <pages> pp. 141-147. </pages>
Reference: [9] <author> G.F. Estabrook, C.S. Johnson, Jr., and F.R. McMorris, </author> <title> A mathematical foundation for the analysis of cladistic character compatibility, </title> <journal> Math. Biosci., </journal> <volume> 29, </volume> <year> 1976, </year> <pages> pp. 181-187. </pages>
Reference: [10] <author> M. Farach and M. </author> <title> Thorup, Optimal evolutionary tree comparison by sparse dynamic programming, </title> <note> to appear, FOCS '94. </note>
Reference-contexts: One approach has been to find a maximum subset S 0 S inducing homeomorphic subtrees; this subtree is then called a Maximum Agreement Subtree <ref> [14, 10, 17] </ref>. The primary disadvantage of this approach is that it does not return an evolutionary tree on the entire species set. There is however a connection between this problem and one of the local consensus methods.
Reference: [11] <author> J. Felsenstein, </author> <title> Numerical methods for inferring evolutionary trees, </title> <journal> The Quarterly Review of Biology, </journal> <volume> Vol. 57, No. 4, </volume> <month> Dec. </month> <year> 1982. </year>
Reference: [12] <author> Gusfield, D., </author> <title> Efficient algorithms for inferring evolutionary trees, </title> <journal> Networks, </journal> <volume> Vol. 21, </volume> <pages> pp. 19-28, </pages> <year> 1991. </year>
Reference-contexts: Definition 2.8. A set A of clusters is said to be compatible iff there exists a tree T such that C (T ) = A. The following proposition can be found in <ref> [12] </ref>. Proposition 2.1. A set A of clusters is compatible iff 8ff i ; ff j 2 A, ff i " ff j 2 fff i ; ff j ; ;g. We now state a theorem which will be used in the later sections. Theorem 2.1. <p> This problem can be solved in linear time <ref> [12, 19] </ref>. The weakness of this approach is that in practice, many data sets are incompatible, and it is therefore necessary to be able to handle the case where some pairs of trees resolve triples differently.
Reference: [13] <author> S. Kannan, E. Lawler, and T. Warnow, </author> <title> Determining the evolutionary tree, </title> <note> to appear, J. of Algorithms. </note>
Reference-contexts: To have a linear time algorithm, however, we need to be able to compute T 2 jrep (v) quickly. We cite the following result from <ref> [13] </ref> which will be useful to us in this case. Lemma 4.2. [13] Given a left-to-right ordering of the leaves of a tree and the ability to determine the topology of any triple of leaves a; b; c in constant time, we can construct the tree in linear time. <p> To have a linear time algorithm, however, we need to be able to compute T 2 jrep (v) quickly. We cite the following result from <ref> [13] </ref> which will be useful to us in this case. Lemma 4.2. [13] Given a left-to-right ordering of the leaves of a tree and the ability to determine the topology of any triple of leaves a; b; c in constant time, we can construct the tree in linear time. <p> The total time is therefore bounded by the cost of computing the triples. 2 While partial local consensus trees can be constructed in O (kn 3 ), total local consensus trees can be computed even faster. Lemma 7.3. [Kannan, Lawler, Warnow <ref> [13] </ref>] Given an oracle O which can answer queries of "What is the form of T jfa; b; cg for a species set fa; b; cg?", we can construct in O (n 2 ) time a tree T consistent with all the oracle queries (if it exists), and O (rn log <p> Proof. We can implement the oracle determining the form of the homeomorphic subtree of T f on a triple a; b; c by first preprocessing the trees to answer least common ancestor (lca) queries in constant time, using [18]. Then, answering a query needs only O (k) time. By <ref> [13] </ref>, we need only O (n 2 ) queries and O (n 2 ) additional work, for a total cost of O (kn 2 ) in the general case. When T f has degree bounded by r, we have total cost O (krn log n).
Reference: [14] <author> D. Keselman and A. Amir, </author> <title> Maximum agreement subtree in a set of evolutionary trees - metrics and efficient algorithms, </title> <note> to appear, FOCS '94. </note>
Reference-contexts: One approach has been to find a maximum subset S 0 S inducing homeomorphic subtrees; this subtree is then called a Maximum Agreement Subtree <ref> [14, 10, 17] </ref>. The primary disadvantage of this approach is that it does not return an evolutionary tree on the entire species set. There is however a connection between this problem and one of the local consensus methods.
Reference: [15] <author> M. Henzinger, V. King, and T. Warnow, </author> <title> A fast algorithm for constructing rooted trees from constraints, </title> <type> unpublished manuscript. </type>
Reference-contexts: We can determine in O (kn log n) time if a tree T exists such that T jt is homeomorphic to t for all t 2 A. In <ref> [15] </ref>, an algorithm is given for the problem addressed in [2] for the case where all the triples are resolved. In this case a faster algorithm can be obtained. Lemma 7.2. (Henzinger, King, Warnow [15]) Let A be a multi-set of k resolved rooted triples on a leaf set S, with <p> In <ref> [15] </ref>, an algorithm is given for the problem addressed in [2] for the case where all the triples are resolved. In this case a faster algorithm can be obtained. Lemma 7.2. (Henzinger, King, Warnow [15]) Let A be a multi-set of k resolved rooted triples on a leaf set S, with jSj = n.
Reference: [16] <author> McMorris, F. and Steel, M. </author> <title> The Complexity of the Median Procedure for Binary Trees, </title> <booktitle> Proceedings of the 4th Conference of the International Federation of Classification Societies, </booktitle> <address> Paris, </address> <year> 1993, </year> <title> to be published in the Series "Studies in Classification, Data Analysis, and Knowledge Organization" by Springer-Verlag. </title>
Reference-contexts: The median tree can be computed in polynomial time Computing the Local Consensus of Trees 24 and has a nice characterization in terms of the character encoding <ref> [4, 16, 6] </ref>. Both the above notions are related to versions of the local consensus problem, and the relevant local consensus trees always contain at least as much `information' as these trees. The work represented in this paper can be extended in several directions.
Reference: [17] <author> M. Steel and T. Warnow, </author> <title> Kaikoura tree theorems: computing the maximum agreement subtree, </title> <booktitle> Information Processing Letters (48) 1993, </booktitle> <pages> pp. </pages> <month> 77-82. </month> <title> Computing the Local Consensus of Trees 25 </title>
Reference-contexts: One approach has been to find a maximum subset S 0 S inducing homeomorphic subtrees; this subtree is then called a Maximum Agreement Subtree <ref> [14, 10, 17] </ref>. The primary disadvantage of this approach is that it does not return an evolutionary tree on the entire species set. There is however a connection between this problem and one of the local consensus methods.
Reference: [18] <author> D. Harel and R. Tarjan, </author> <title> Fast Algorithm for Finding Nearest Common Ancestors, </title> <journal> SIAM J. Comput. </journal> <volume> 13(2) </volume> <pages> 338-355, </pages> <year> 1984. </year>
Reference-contexts: We have thus shown the following theorem Theorem 4.4. The algorithm stated above constructs the OLC of two trees T 1 and T 2 if the OLC exists. Analysis of Running Time Phase 0: Preprocessing: In <ref> [18] </ref>, Harel and Tarjan give an O (n) time algorithm for preprocessing trees to answer lca queries in constant time. We have already shown that computing the ordered representative sets takes O (n) time. Thus the preprocessing stage takes O (n) time. <p> Proof. We can implement the oracle determining the form of the homeomorphic subtree of T f on a triple a; b; c by first preprocessing the trees to answer least common ancestor (lca) queries in constant time, using <ref> [18] </ref>. Then, answering a query needs only O (k) time. By [13], we need only O (n 2 ) queries and O (n 2 ) additional work, for a total cost of O (kn 2 ) in the general case.
Reference: [19] <author> T. Warnow, </author> <title> Tree compatibility and inferring evolutionary history, </title> <editor> J. </editor> <booktitle> of Algorithms (16), </booktitle> <year> 1994, </year> <pages> pp. 388-407. </pages>
Reference-contexts: This problem can be solved in linear time <ref> [12, 19] </ref>. The weakness of this approach is that in practice, many data sets are incompatible, and it is therefore necessary to be able to handle the case where some pairs of trees resolve triples differently.
References-found: 19

