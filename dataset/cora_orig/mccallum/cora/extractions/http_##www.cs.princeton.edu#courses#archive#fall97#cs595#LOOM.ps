URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/LOOM.ps
Refering-URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/reading.html
Root-URL: http://www.cs.princeton.edu
Phone: 2  
Title: Subtyping is not a good "Match" for object-oriented languages  
Author: Kim B. Bruce Leaf Petersen ?? and Adrian Fiech Williams 
Address: MA, USA  St. John's, Newfoundland, Canada  
Affiliation: College, Williamstown,  Memorial University of Newfoundland,  
Abstract: We present the design and rationale of a new statically-typed object-oriented language, LOOM. LOOM retains most of the features of the earlier language PolyTOIL. However the subtyping relation is dropped from LOOM in favor of the matching relation. "Hash types", which are defined in terms of matching, are introduced to provide some of the benefits of subtyping. These types can be used to provide support for heterogeneous data stuctures in LOOM. LOOM is considerably simpler than PolyTOIL, yet is just as expressive. The type system for the language is decidable and provably type safe. The addition of modules to the language provides better control over information hiding and allows the provision of access like that of C++'s friends.
Abstract-found: 1
Intro-found: 1
Reference: [AC95] <author> Martin Abadi and Luca Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> In Proceedings ECOOP '95, </booktitle> <pages> pages 145-167, </pages> <year> 1995. </year>
Reference-contexts: The relation &lt;# is referred to as "matching". In both PolyTOIL and <ref> [AC95] </ref>, the matching relation allowed the types of corresponding methods to be subtypes. Since the corresponding types must now be the same, a matching type simply is an extension of the original. It might seem that this would significantly impact the expressiveness of the language.
Reference: [AG96] <author> Ken Arnold and James Gosling. </author> <title> Java. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Types for singly and doubly-linked node classes. essentially the same as the use of extends on interfaces in Java <ref> [AG96] </ref>. It follows from the definition that if U &lt;# Object, then HetDbleNodeType (U) &lt;# HetNodeType (U). <p> Pure object-oriented languages like Smalltalk and Eiffel have generally chosen to identify classes with modules, though newer languages like Theta [DGLM94] (which can be seen as a descendant of the ADT-style language, Clu) and Java <ref> [AG96] </ref> have also chosen to provide modules (called packages in Java). 5 If t involves free type variables then the type of the value will have a type obtained by replacing the free type variables of t by corresponding values from the environment.
Reference: [AvdL90] <author> Pierre America and Frank van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In OOPSLA-ECOOP '90 Proceedings, </booktitle> <pages> pages 161-168. </pages> <booktitle> ACM SIGPLAN Notices,25(10), </booktitle> <month> October </month> <year> 1990. </year>
Reference: [BCC + 96] <author> Kim B. Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <booktitle> Theory and Practice of Object-Oriented Systems, </booktitle> <year> 1996. </year> <note> to appear. </note>
Reference-contexts: Binary methods have been hard to express in most statically-typed object-oriented programming languages because they seem to require a MyType term representing the type of self, yet MyType and subtyping have not interacted well. See <ref> [BCC + 96] </ref> for an exposition of the difficulties of handling binary methods in statically-typed object-oriented languages. In that paper, matching is suggested as one way of getting around these difficulties, but it is also criticized as not providing support for heterogeneous data structures.
Reference: [Bru93] <author> K. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference: [Bru94] <author> K. Bruce. </author> <title> A paradigmatic object-oriented programming language: design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 127-206, </pages> <year> 1994. </year> <note> An earlier version of this paper appeared in the 1993 POPL Proceedings. </note>
Reference: [BSvG95] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyTOIL: </author> <title> A type-safe polymorphic object-oriented language, extended abstract. </title> <booktitle> In ECOOP '95, </booktitle> <pages> pages 27-51. </pages> <publisher> LNCS 952, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: We provide a brief overview of LOOM's module system in section 5. Finally in section 6 we summarize and evaluate the features of the language. 2 Introduction to PolyTOIL and Matching In <ref> [BSvG95] </ref> we introduced PolyTOIL, a statically-typed object-oriented programming language which provides all of the usual constructs of class-based object-oriented languages. In particular, it supports objects which consist of instance variables and methods, and in which computation is based on message-sending. <p> In particular, it supports objects which consist of instance variables and methods, and in which computation is based on message-sending. Reuse is supported via inheritance, subtyping, and a form of bounded polymorphism. We refer the reader to <ref> [BSvG95] </ref> for the details of the language. We provide only a brief summary here. Relatively innovative features of the language include: The use of MyType in classes to refer to the type of self, the receiver of the message. The treatment of classes as first-class values of the language. <p> The definition of subtyping for object types is similar to that for matching, but also requires that MyType only occur positively 3 in method types (see <ref> [BSvG95] </ref> for definitions and details). In particular, an object type with a method with parameter of type MyType cannot have any non-trivial subtypes. As a result, if a class has a method with a parameter of type MyType, then subclasses will not give rise to subtypes. <p> Nevertheless it is possible to define a polymorphic list class that, when instantiated with the type of objects generated by Node, will generate singly-linked lists, while if it is instantiated with the type of objects generated by DbleNode will generate doubly-linked lists. (See <ref> [BSvG95] </ref> for the code and details.) The fact that these types are not subtypes is not a handicap in using them in the ways intended. These results suggested to us that subtyping might not be necessary at all. <p> The type-checking rules for classes are in a slightly different style from those in <ref> [BSvG95] </ref>. This slight variation makes the proof of type-safety somewhat simpler. The keyword self is of type MyType, and represents the object from the outside. <p> In order to prove the type safety of LOOM, we need to show that the type system is consistent with a semantics for the language. We can define a natural semantics for LOOM similar to that provided for PolyTOIL <ref> [BSvG95] </ref>. Once defined we can prove: 1.
Reference: [CDG + 88] <author> L. Cardelli, J. Donahue, L. Galssman, M. Jordan, B. Kalsow, and G. Nelson. </author> <type> Modula-3 report. Technical Report SRC-31, </type> <institution> DEC systems Research Center, </institution> <year> 1988. </year>
Reference-contexts: Interestingly it is the hybrid languages which have grown from ADT-style languages which have often provided the best support for this modularity. Thus Ada 95 [Int95] and Modula-3 <ref> [CDG + 88] </ref> have introduced module structures which are distinct from classes.
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proc. 17th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year>
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: the earlier examples of Nodes from PolyTOIL, they are now parameterized by the type of value stored in the node as well as 4 Some readers may find it useful to think of #t as an abbreviation for the type 9t &lt;# t:t of the second order lambda calculus. (See <ref> [CW85, MP88] </ref>.) class HetNode (T &lt;# Object; v: #T) var value = v: #T; next = nil: MyType; methods function getValue (): #T -return value.clone () - procedure setValue (newValue: #T) -value := newValue.clone ()- function getNext (): MyType -return next procedure setNext (newNext:MyType) -next := newNext procedure attachRight (newNext: MyType)
Reference: [DGLM94] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Meyers. </author> <title> Abstraction mechanisms in Theta. </title> <type> Technical report, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1994. </year>
Reference-contexts: Thus Ada 95 [Int95] and Modula-3 [CDG + 88] have introduced module structures which are distinct from classes. Pure object-oriented languages like Smalltalk and Eiffel have generally chosen to identify classes with modules, though newer languages like Theta <ref> [DGLM94] </ref> (which can be seen as a descendant of the ADT-style language, Clu) and Java [AG96] have also chosen to provide modules (called packages in Java). 5 If t involves free type variables then the type of the value will have a type obtained by replacing the free type variables of
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrop. </author> <title> The annotated C ++ reference manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference: [GM96] <author> Andreas Gawecki and Florian Matthes. </author> <title> Integrating subtyping, matching and type quantification: A practical perspective. </title> <booktitle> In ECOOP '96, </booktitle> <pages> pages 26-47. </pages> <publisher> LNCS 1098, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: These results suggested to us that subtyping might not be necessary at all. At the same time, we began to feel that presenting programmers with both the subtyping and matching hierarchies on types in a single language might be confusing. The paper <ref> [GM96] </ref> in ECOOP `96 presented a language TooL, which is more general than PolyTOIL in that the bound on polymorphic types and classes could be specified using either subtyping or matching, and type-checking of classes could be done assuming that MyType either matched or was a subtype of the intended type
Reference: [Int95] <author> Intermetrics. </author> <title> Ada 95 Reference Manual, </title> <note> version 6.0. </note> <year> 1995. </year>
Reference-contexts: Interestingly it is the hybrid languages which have grown from ADT-style languages which have often provided the best support for this modularity. Thus Ada 95 <ref> [Int95] </ref> and Modula-3 [CDG + 88] have introduced module structures which are distinct from classes. <p> It is worth noting in 7 An early version of LOOM did allow types to be changed, but we decided that the gains were not worth the added complexity. this regard that Ada 95 <ref> [Int95] </ref> also requires the programmer to mark the types of variables and parameters with the "class" suffix if values which are subclasses of the declared type may be used. A complication of LOOM compared to PolyTOIL is that binary messages may not be sent to hash types.
Reference: [Jon96] <author> Mark P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In 23rd ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 68-78, </pages> <year> 1996. </year>
Reference-contexts: With strong language support for modules it should be possible to change the implementation of a type without changing its public interface and without requiring recompilation of other modules which import it. See <ref> [Jon96] </ref> for a more detailed discussion of modules. We have chosen to follow the lead of languages like those in the Modula and Ada families and provide module interfaces which can be completely separate from the module implementation (e.g., the interface can be compiled before the implementation is written).
Reference: [KLM94a] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In 21st ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 138-150, </pages> <year> 1994. </year>
Reference-contexts: The keyword include used in the definition of HetDbleNodeType indicates that all methods of HetNodeType are included in HetDbleNodeType, as well as the new methods declared there. This may be thought of as a form of inheritance for types. It is modelled on a similar construct in Rapide <ref> [KLM94a] </ref>, and is HetNodeType (T &lt;# Object) = ObjectType getValue: Func ():#T; setValue: Proc (#T); getNext: Func ():MyType; setNext: Proc (MyType) attachRight: Proc (MyType) end ObjectType; HetDbleNodeType (T &lt;# Object) = ObjectType include HetNodeType getPrev: Func ():MyType; setPrev: Proc (MyType); end ObjectType; Fig. 3.
Reference: [KLM94b] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium of Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 138-150. </pages> <institution> Association for Computing Machinery, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Thus we can achieve the effect of C++'s friends without letting the non-exported methods escape the module boundary. This technique for providing information hiding while providing access by operations at the same level of abstraction is similar to that suggested in [PT93] and <ref> [KLM94b] </ref>, where bounded existential quantifiers based on subtyping are used to perform the information hiding. In summary, our implementation of modules in LOOM allows the programmer to specify how much information about an object type is revealed to other program units.
Reference: [LP91] <author> Wilf LaLonde and John Pugh. </author> <title> Subclassing 6= subtyping 6= is-a. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 57-62, </pages> <month> January </month> <year> 1991. </year>
Reference: [Mey92] <author> B. Meyer. </author> <title> Eiffel: the language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference: [MMMP90] <author> O. Madsen, B. Magnusson, and B. Moller-Pedersen. </author> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In OOPSLA-ECOOP '90 Proceedings, </booktitle> <pages> pages 140-150. </pages> <booktitle> ACM SIGPLAN Notices,25(10), </booktitle> <month> October </month> <year> 1990. </year>
Reference: [MP88] <author> J.C. Mitchell and G.D. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year> <note> Preliminary version appeared in Proc. 12th ACM Symp. on Principles of Programming Languages, </note> <year> 1985. </year>
Reference-contexts: the earlier examples of Nodes from PolyTOIL, they are now parameterized by the type of value stored in the node as well as 4 Some readers may find it useful to think of #t as an abbreviation for the type 9t &lt;# t:t of the second order lambda calculus. (See <ref> [CW85, MP88] </ref>.) class HetNode (T &lt;# Object; v: #T) var value = v: #T; next = nil: MyType; methods function getValue (): #T -return value.clone () - procedure setValue (newValue: #T) -value := newValue.clone ()- function getNext (): MyType -return next procedure setNext (newNext:MyType) -next := newNext procedure attachRight (newNext: MyType)
Reference: [Pet96] <author> Leaf Petersen. </author> <title> A module system for LOOM. </title> <type> Williams College Senior Honors Thesis, </type> <year> 1996. </year>
Reference-contexts: Acknowledgements: The LOOM language design is due to Bruce and Petersen. A more complete description of the language design, type-checing rules, natural semantics, and the analysis of complexity of type-checking can be found in Pe-tersen's honors thesis <ref> [Pet96] </ref>. The proof of type safety was done by Fiech with the assistance of Bruce, and was based on a similar proof for PolyTOIL.
Reference: [Pie92] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Proc 19th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 305-315, </pages> <year> 1992. </year>
Reference-contexts: These include the decidability of type checking for LOOM, the provision of natural semantics, and the proof of type safety. Pierce's <ref> [Pie92] </ref> results on the undecidability of subtyping in the second-order bounded polymorphic lambda calculus has caused designers of languages supporting bounded polymorphism to be concerned about whether their type systems are undecidable.
Reference: [PT93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically typed friendly functions via partially abstract types. </title> <type> Technical Report ECS-LFCS-93-256, </type> <institution> University of Edinburgh, </institution> <year> 1993. </year>
Reference-contexts: That is, for each object type we only list those methods which we wish to publicly advertise. This can be expressed using the matching relation from LOOM. The following example is similar to one presented in <ref> [PT93] </ref>. If we declare IntSetType &lt;# ObjectType add: proc (Integer); remove: proc (Integer); contains: func (Integer):Boolean; intersect: proc (MyType) end; in an interface, then we know that IntSetType has methods add, remove, contains, and intersect with the appropriate types. <p> Thus we can achieve the effect of C++'s friends without letting the non-exported methods escape the module boundary. This technique for providing information hiding while providing access by operations at the same level of abstraction is similar to that suggested in <ref> [PT93] </ref> and [KLM94b], where bounded existential quantifiers based on subtyping are used to perform the information hiding. In summary, our implementation of modules in LOOM allows the programmer to specify how much information about an object type is revealed to other program units.
Reference: [Sny86] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proc. 1st ACM Symp. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-46, </pages> <month> October </month> <year> 1986. </year>
Reference: [Tes85] <author> L. Tesler. </author> <title> Object Pascal report. </title> <type> Technical Report 1, </type> <institution> Apple Computer, </institution> <year> 1985. </year>
References-found: 26

