URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-40.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Email: amir@cc.gatech.edu;  gruia@cc.gatech.edu.  
Title: FAfS,TgTER SCALED MATCHING  
Author: Amihood Amir Gruia Calinescu 
Note: Partially supported by NSF grant IRI-90-13055 and CCR-92-23699.  
Date: July 1993  
Address: GIT-CC-93/40  Atlanta, Georgia 30332-0280  Atlanta, GA 30332-0280; (404) 853-0083;  Atlanta, GA 30332-0280; (404) 853-9389;  
Affiliation: Georgia Tech Georgia Tech  College of Computing Georgia Institute of Technology  College of Computing, Georgia Institute of Technology,  College of Computing, Georgia Institute of Technology,  
Abstract: The rapidly growing need for analysis of digitized images in multimedia systems has lead to a variety of interesting problems in multidimensional pattern matching. One of the problems is that of scaled matching, finding all appearances of a pattern in a text in all discrete sizes. Another important problem is dictionary matching, quick search through a dictionary of preprocessed patterns in order to find all dictionary patterns that appear in the input text. In this paper we provide a very simple algorithm for two dimensional scaled matching. Our algorithm is the first linear-time alphabet-independent scaled matching algorithm. Its running time is O(jT j), where jT j is the text size, and is independent of jj, the size of the alphabet. Our technique generalizes to produce the first known algorithm for scaled dictionary matching. We can find all appearances of all dictionary patterns that appear in the input text in any discrete scale. The time bounds of our algorithm are equal to the best known exact (no scaling) two dimensional dictionary matching algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Amir, G. Benson, and M. Farach. </author> <title> Alphabet independent two dimensional matching. </title> <note> To appear, SIAM J. Comp., </note> <year> 1992. </year>
Reference-contexts: A lacking crucial element in this multimedia effort is the equivalent of "text string searching" in an image database [17]. Much theoretical progress has been made in recent years in the area of multidimensional pattern matching. Exact two dimensional matching can now be done in in alphabet-independent linear time <ref> [1, 16, 3, 2] </ref>. Approximate two dimensional matching, where one seeks all appearances of a pattern P in text T with some possible errors, can be doneeffi-ciently under various definitions of error [4, 8]. <p> same technique can be used to generalize the algorithms for other versions of the dictionary matching problem to the scaled case. 3 Alphabet Independent Scaled Matching 3.1 Algorithm's Idea and Data Structures Our algorithm is based on the alphabet independent exact two dimensional matching algorithm of Amir, Benson and Farach <ref> [1] </ref>. That algorithm has two stages, the candidate consistency stage and the candidate verification stage. In the candidate consistency stage, we check for every pair of text location if both locations can be the start of a pattern appearance. <p> In [3, 16] there are two different algorithms that construct the witness table in time O (m 2 ). The candidate consistency stage takes time O (n 2 ) <ref> [1] </ref>. 4 Amir and Calinescu In the candidate verification stage, a wave is employed to verify which of the non-conflicting sources are indeed starts of pattern appearances. This stage is also done in time O (n 2 ). <p> It is not hard to see that a constant number of range minimum queries on B r and C r can handle the cases in the lemma. 3.2 The Algorithm The algorithm is a modification of the alphabet independent two dimensional matching algorithm of <ref> [1] </ref>. The modification allows running the algorithm on an s-coarse text. An s-coarse text is an b n s c fi b n s c grid of s-blocks. <p> This will necessitate separate handling of the first and last row and column of a pattern occurrence. Verification Stage 8 Amir and Calinescu The verification is similar to the exact matching algorithm presented in <ref> [1] </ref>. The verifica tion algorithm for scale s follows. 4.1 Run a horizontal wave on the s-scale grid recording for each s-block, its position relative to the nearest leftmost overlapping source, and the offset of that source. <p> Assumption: We again assume that the patterns are non-trivial. If trivial patterns appear in the dictionary they are taken out during preprocessing, and handled separately. Definitions: 1. A diagonal pivot of mfim matrix P is the largest i such that Rows P <ref> [1; 1; . . . ; m] </ref>; . . .; P [i 1; 1; . . . m] are either all equal to each other or each consists of one repeating symbol, and columns P [1; . . .; m; 1]; . . .; P [1; . . .m; i1] are <p> If trivial patterns appear in the dictionary they are taken out during preprocessing, and handled separately. Definitions: 1. A diagonal pivot of mfim matrix P is the largest i such that Rows P [1; 1; . . . ; m]; . . .; P <ref> [i 1; 1; . . . m] </ref> are either all equal to each other or each consists of one repeating symbol, and columns P [1; . . .; m; 1]; . . .; P [1; . . .m; i1] are either all equal to each other or each consists of one <p> A diagonal pivot of mfim matrix P is the largest i such that Rows P [1; 1; . . . ; m]; . . .; P [i 1; 1; . . . m] are either all equal to each other or each consists of one repeating symbol, and columns P <ref> [1; . . .; m; 1] </ref>; . . .; P [1; . . .m; i1] are either all equal to each other or each consists of one repeating symbol. 2. Let P be an m fi m matrix, and let i be the diagonal pivot of P . <p> i such that Rows P [1; 1; . . . ; m]; . . .; P [i 1; 1; . . . m] are either all equal to each other or each consists of one repeating symbol, and columns P [1; . . .; m; 1]; . . .; P <ref> [1; . . .m; i1] </ref> are either all equal to each other or each consists of one repeating symbol. 2. Let P be an m fi m matrix, and let i be the diagonal pivot of P .
Reference: [2] <author> A. Amir, G. Benson, and M. Farach. </author> <title> Alphabet independent two dimensional matching. </title> <booktitle> Proc. 24th ACM Symposium on Theory of Computation, </booktitle> <pages> pages 59-68, </pages> <year> 1992. </year>
Reference-contexts: A lacking crucial element in this multimedia effort is the equivalent of "text string searching" in an image database [17]. Much theoretical progress has been made in recent years in the area of multidimensional pattern matching. Exact two dimensional matching can now be done in in alphabet-independent linear time <ref> [1, 16, 3, 2] </ref>. Approximate two dimensional matching, where one seeks all appearances of a pattern P in text T with some possible errors, can be doneeffi-ciently under various definitions of error [4, 8]. <p> The reduced matrix P [i] of P is the square matrix P [i 1; . . . ; m; i 1; . . . ; m]. Observations: Every non-trivial square matrix has a diagonal pivot. The pivot of every reduced pattern P [i] is in location P [i] <ref> [2; 2] </ref>. Lemma 2: Consider an s-block starting at position T [p; q] (i.e. T [p; . . .; p+s1; q; . . . ; q +s 1]). <p> Proof: Similar to the proof of lemma 1. Outline of Scaled Dictionary Matching Algorithm Step 1 Preprocessing: Construct dictionary D R whose elements are the reduced matrices of the patterns in dictionary D. (The pivots of all patterns in dictionary D R are in the same location, <ref> [2; 2] </ref>.) Preprocess this dictionary in a manner similar to the dictionary preprocessing of AF .
Reference: [3] <author> A. Amir, G. Benson, and M. Farach. </author> <title> The truth, the whole truth, and nothing but the truth: Alphabet independent two dimensional witness table construction. </title> <type> Technical Report GIT-CC-92/52, </type> <institution> Georgia Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: A lacking crucial element in this multimedia effort is the equivalent of "text string searching" in an image database [17]. Much theoretical progress has been made in recent years in the area of multidimensional pattern matching. Exact two dimensional matching can now be done in in alphabet-independent linear time <ref> [1, 16, 3, 2] </ref>. Approximate two dimensional matching, where one seeks all appearances of a pattern P in text T with some possible errors, can be doneeffi-ciently under various definitions of error [4, 8]. <p> A preprocessed witness table allows constant time elimination of one of the two candidate sources, if they do not agree in every location of the overlap. In <ref> [3, 16] </ref> there are two different algorithms that construct the witness table in time O (m 2 ).
Reference: [4] <author> A. Amir and M. Farach. </author> <title> Efficient 2-dimensional approximate matching of non-rectangular figures. </title> <booktitle> Proc. of 2nd Symposium on Discrete Algorithms, </booktitle> <address> San Francisco, CA, </address> <pages> pages 212-223, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Exact two dimensional matching can now be done in in alphabet-independent linear time [1, 16, 3, 2]. Approximate two dimensional matching, where one seeks all appearances of a pattern P in text T with some possible errors, can be doneeffi-ciently under various definitions of error <ref> [4, 8] </ref>. Scaled matching, where all appearances of a pattern P scaled to any discrete size are sought in text T , can also be solved in linear time for fixed finite alphabets [9]. Much progress has been made with dictionary matching as well.
Reference: [5] <author> A. Amir and M. Farach. </author> <title> Two dimensional dictionary matching. </title> <journal> Information Processing Letters, </journal> <volume> 44 </volume> <pages> 233-239, </pages> <year> 1992. </year>
Reference-contexts: Dictionary matching allows preprocessing of a (possibly vast) dictionary of patterns. Subsequently, appearances of dictionary patterns in various input texts are to be found quickly. Various algorithms for two dimensional matching (static, dynamic, square patterns, rectangular patterns) were developed <ref> [5, 6, 11, 13] </ref>. The two remaining fundamental problems in dictionary matching are 1) Scaled dictionary matching and 2) Approximate dictionary matching. This paper addresses the scaled two dimensional dictionary matching problem. The tech-inques of [9] for scaled matching can not be generalized to multidimensions. <p> We present what is, to our knowledge, the first algorithm for scaled two dimensional dictionary matching. Our algorithm solves the scaled dictionary matching problem for a static dictionary of square pattern matrices in time similar to that of the non scaled algorithm <ref> [5] </ref>. Our times are: O (jDj log k) preprocessing, where jDj is the total dictionary size and k is the number of patterns in the dictionary, and O (jT j log k) text scanning time, for input text T . This is identical to the time at [5], the best non-scaled <p> non scaled algorithm <ref> [5] </ref>. Our times are: O (jDj log k) preprocessing, where jDj is the total dictionary size and k is the number of patterns in the dictionary, and O (jT j log k) text scanning time, for input text T . This is identical to the time at [5], the best non-scaled matching algorithm for a static dictionary of square patterns. It is somewhat surprising that scaling does not add to the complexity of single matching nor dictionary matching. This paper is organized as follows. <p> Preprocess the set in a way that enables solution to the following problem: Input: Text T [n fi n] over alphabet . Output: All ordered pairs ([x; y]; j) such that pattern P j matches the subsquare of text beginning at location T [x; y]. Amir and Farach <ref> [5] </ref> provided an algorithm for the static two dimensional dictionary matching problem where the dictionary preprocessing was done in time O (d log k) and subsequent text scans took time O (n 2 log k). In [6], the dynamic two dimensional dictionary matching problem was considered. <p> Verification Time: O (b n s c 2 ). 4 Dictionary Scaled Matching We are now ready to solve the problem of scaled dictionary matching for a static dictionary of squares. This is the scaled version of the problem solved by Amir and Farach in <ref> [5] </ref>. In that paper an algorithm (henceforth refered to as AF ) was presented that preprocessed the dictionary in time O (d log k), where d is the sum of the sizes of all dictionary patterns and k is the number of patterns.
Reference: [6] <author> A. Amir, M. Farach, R.M. Idury, J.A. La Poutre, and A.A Schaffer. </author> <title> Improved dynamic dictionary matching. </title> <booktitle> Proc. 4th ACM-SIAM SODA, </booktitle> <pages> pages 392-401, </pages> <year> 1993. </year> <note> 12 Amir and Calinescu </note>
Reference-contexts: Dictionary matching allows preprocessing of a (possibly vast) dictionary of patterns. Subsequently, appearances of dictionary patterns in various input texts are to be found quickly. Various algorithms for two dimensional matching (static, dynamic, square patterns, rectangular patterns) were developed <ref> [5, 6, 11, 13] </ref>. The two remaining fundamental problems in dictionary matching are 1) Scaled dictionary matching and 2) Approximate dictionary matching. This paper addresses the scaled two dimensional dictionary matching problem. The tech-inques of [9] for scaled matching can not be generalized to multidimensions. <p> Amir and Farach [5] provided an algorithm for the static two dimensional dictionary matching problem where the dictionary preprocessing was done in time O (d log k) and subsequent text scans took time O (n 2 log k). In <ref> [6] </ref>, the dynamic two dimensional dictionary matching problem was considered. In the dynamic version, patterns may be inserted to and deleted from the dictionary.
Reference: [7] <author> A. Amir, M. Farach, and Y. Matias. </author> <title> Efficient randomized dictionary matching algorithms. </title> <booktitle> Proc. 3rd. Combinatorial Pattern Matching Conference, </booktitle> <pages> pages 259-272, </pages> <address> 1992. Tucson, Arizona. </address>
Reference-contexts: Giancarlo [11] also obtained an algorithm for the dynamic two dimensional dictionary matching problem, but his algorithm is less efficient. In <ref> [7] </ref> simple randomized algorithm for this problem were presented. All above algorithms assume that the patterns are squares (although the text need not be). Idury and Schaffer [13] showed an algorithm for dynamic two dimensional dictionary matching of general rectangular patterns.
Reference: [8] <author> A. Amir and G. Landau. </author> <title> Fast parallel and serial multidimensional approximate array matching. </title> <journal> Theoretical Computer Science, </journal> <volume> 81 </volume> <pages> 97-115, </pages> <year> 1991. </year>
Reference-contexts: Exact two dimensional matching can now be done in in alphabet-independent linear time [1, 16, 3, 2]. Approximate two dimensional matching, where one seeks all appearances of a pattern P in text T with some possible errors, can be doneeffi-ciently under various definitions of error <ref> [4, 8] </ref>. Scaled matching, where all appearances of a pattern P scaled to any discrete size are sought in text T , can also be solved in linear time for fixed finite alphabets [9]. Much progress has been made with dictionary matching as well.
Reference: [9] <author> A. Amir, G.M. Landau, and U. Vishkin. </author> <title> Efficient pattern matching with scaling. </title> <journal> Journal of Algorithms, </journal> <volume> 13(1) </volume> <pages> 2-32, </pages> <year> 1992. </year>
Reference-contexts: Scaled matching, where all appearances of a pattern P scaled to any discrete size are sought in text T , can also be solved in linear time for fixed finite alphabets <ref> [9] </ref>. Much progress has been made with dictionary matching as well. In the traditional pattern matching model a single pattern is sought in a single text. Dictionary matching allows preprocessing of a (possibly vast) dictionary of patterns. <p> Various algorithms for two dimensional matching (static, dynamic, square patterns, rectangular patterns) were developed [5, 6, 11, 13]. The two remaining fundamental problems in dictionary matching are 1) Scaled dictionary matching and 2) Approximate dictionary matching. This paper addresses the scaled two dimensional dictionary matching problem. The tech-inques of <ref> [9] </ref> for scaled matching can not be generalized to multidimensions. The main idea was analysing the text with the aid of power columns. Those are the text columns appearing m 1 columns apart, where P is an m fi m pattern. <p> This dependence on the pattern size make the power columns useless where a dictionary of different sized patterns is involved. In this paper we present a novel idea for solving the scaled dictionary matching problem for a single pattern. This idea is significantly simpler than the algorithm of <ref> [9] </ref> and has an additional advantage of being alphabet-independent. The previous scaled matching algorithm had a worst case running time of O (jT j log jj), where jT j and jj are the respective sizes of the text and the alphabet. <p> More precisely, P s [i; j] = P [d s j e] Follwing <ref> [9] </ref> we define the problem of two-dimensional pattern matching with scal ing as follows: Input: Pattern matrix P [i; j] i = 1; :::m; j = 1; :::; m and Text matrix T [i; j] i = 1; :::; n; j = 1; :::; n where n &gt; m. <p> Our alphabet independent result is also true for rectangular texts and patterns. In <ref> [9] </ref>, this problem was solved in time O (n 2 ). However, the alphabet was finite. Over an infinite alphabet, the Amir-Landau-Vishkin algorithm will achieve time O (n 2 log m). <p> The back wave should advance only m 1 s-blocks, since the edge row and column need to be checked separately. 4.6 Find all scaled s appearances of the first and last pattern row and column (string scaled matching, can be done in linear time by <ref> [9] </ref> and appropriate range minima queries). Discard all remaining sources where the edges do not match. Verification Time: O (b n s c 2 ). 4 Dictionary Scaled Matching We are now ready to solve the problem of scaled dictionary matching for a static dictionary of squares. <p> The suffix tree construction adds the log k multiplicative factor to our complexity. Using suffix trees of the run-length representation of text and pattern, as in <ref> [9] </ref>, we can answer the following queries in constant time: Input: Text location T [x; y], and pattern subrow (or subcolumn) R = P [z; w; . . .; w + j]. Decide: If there is an s-occurrence of R starting at T [x; y].
Reference: [10] <author> H. N. Gabow, J. L. Bentley, and R. E. Tarjan. </author> <title> Scaling and related techniques for geometry problems. </title> <booktitle> Proc. 16th ACM Symposium on Theory of Computing, </booktitle> <pages> 67(135-143), </pages> <year> 1984. </year>
Reference-contexts: A Range Minimum query is of the form: Given a range of indices [i; :::; j], where 1 i j n, return an index k i k j such that l k = minfl i ; :::; l j g. In <ref> [10] </ref> it was shown that a list of length n can be preprocessed in time O (n) such that subsequent range minimum queries can be answered in constant time.
Reference: [11] <author> R. Giancarlo. </author> <title> The suffix of a square matrix, with applications. </title> <booktitle> Proc. 4th SODA, </booktitle> <pages> pages 402-410, </pages> <year> 1993. </year>
Reference-contexts: Dictionary matching allows preprocessing of a (possibly vast) dictionary of patterns. Subsequently, appearances of dictionary patterns in various input texts are to be found quickly. Various algorithms for two dimensional matching (static, dynamic, square patterns, rectangular patterns) were developed <ref> [5, 6, 11, 13] </ref>. The two remaining fundamental problems in dictionary matching are 1) Scaled dictionary matching and 2) Approximate dictionary matching. This paper addresses the scaled two dimensional dictionary matching problem. The tech-inques of [9] for scaled matching can not be generalized to multidimensions. <p> In the dynamic version, patterns may be inserted to and deleted from the dictionary. An algorithm was provided where a dictionary update takes time O (jP j log d) (P is the pattern inserted or deleted) and the text scanning takes time O (n 2 log d). Giancarlo <ref> [11] </ref> also obtained an algorithm for the dynamic two dimensional dictionary matching problem, but his algorithm is less efficient. In [7] simple randomized algorithm for this problem were presented. All above algorithms assume that the patterns are squares (although the text need not be).
Reference: [12] <author> D. Harel and R.E. Tarjan. </author> <title> Fast algorithms for finding nearest common ancestor. </title> <journal> Computer and System Science, </journal> <volume> 13 </volume> <pages> 338-355, </pages> <year> 1984. </year>
Reference-contexts: Implementation: In addition to preprocessing for range minimum queries over the B and C arrays, we also need suffix trees [15, 18] of the dictionary patterns and text, preprocessed for constant time lowest common ancestor queries <ref> [12] </ref>. The suffix tree construction adds the log k multiplicative factor to our complexity.
Reference: [13] <author> R.M. Idury and A.A Schaffer. </author> <title> Multiple matching of rectangular patterns. </title> <note> Proc. 25th ACM STOC, page to appear, </note> <year> 1993. </year>
Reference-contexts: Dictionary matching allows preprocessing of a (possibly vast) dictionary of patterns. Subsequently, appearances of dictionary patterns in various input texts are to be found quickly. Various algorithms for two dimensional matching (static, dynamic, square patterns, rectangular patterns) were developed <ref> [5, 6, 11, 13] </ref>. The two remaining fundamental problems in dictionary matching are 1) Scaled dictionary matching and 2) Approximate dictionary matching. This paper addresses the scaled two dimensional dictionary matching problem. The tech-inques of [9] for scaled matching can not be generalized to multidimensions. <p> Giancarlo [11] also obtained an algorithm for the dynamic two dimensional dictionary matching problem, but his algorithm is less efficient. In [7] simple randomized algorithm for this problem were presented. All above algorithms assume that the patterns are squares (although the text need not be). Idury and Schaffer <ref> [13] </ref> showed an algorithm for dynamic two dimensional dictionary matching of general rectangular patterns.
Reference: [14] <author> R. Jain. </author> <title> Workshop report on visual information systems. </title> <type> Technical Report Technical Report, </type> <institution> National Science Foundation, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Recently the world has been witnessing a strong convergence of market forces such as the computer industry, television, photo/films, library, and telephone. All these diverse industries need to digitize and analyse digitized images <ref> [14] </ref>. A lacking crucial element in this multimedia effort is the equivalent of "text string searching" in an image database [17]. Much theoretical progress has been made in recent years in the area of multidimensional pattern matching.
Reference: [15] <author> E. M. McCreight. </author> <title> A space-economical suffix tree construction algorithm. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 262-272, </pages> <year> 1976. </year>
Reference-contexts: Implementation: In addition to preprocessing for range minimum queries over the B and C arrays, we also need suffix trees <ref> [15, 18] </ref> of the dictionary patterns and text, preprocessed for constant time lowest common ancestor queries [12]. The suffix tree construction adds the log k multiplicative factor to our complexity.
Reference: [16] <author> K. Park and Z. Galil. </author> <title> Truly alphabet-independent two-dimensional pattern matching. </title> <booktitle> Proc. 33rd IEEE FOCS, </booktitle> <pages> pages 247-256, </pages> <year> 1992. </year>
Reference-contexts: A lacking crucial element in this multimedia effort is the equivalent of "text string searching" in an image database [17]. Much theoretical progress has been made in recent years in the area of multidimensional pattern matching. Exact two dimensional matching can now be done in in alphabet-independent linear time <ref> [1, 16, 3, 2] </ref>. Approximate two dimensional matching, where one seeks all appearances of a pattern P in text T with some possible errors, can be doneeffi-ciently under various definitions of error [4, 8]. <p> A preprocessed witness table allows constant time elimination of one of the two candidate sources, if they do not agree in every location of the overlap. In <ref> [3, 16] </ref> there are two different algorithms that construct the witness table in time O (m 2 ).
Reference: [17] <author> A. Pentland. </author> <title> Invited talk. </title> <booktitle> NSF Institutional Infrastructure Workshop, </booktitle> <year> 1992. </year>
Reference-contexts: All these diverse industries need to digitize and analyse digitized images [14]. A lacking crucial element in this multimedia effort is the equivalent of "text string searching" in an image database <ref> [17] </ref>. Much theoretical progress has been made in recent years in the area of multidimensional pattern matching. Exact two dimensional matching can now be done in in alphabet-independent linear time [1, 16, 3, 2].
Reference: [18] <author> P. Weiner. </author> <title> Linear pattern matching algorithm. </title> <booktitle> Proc. 14 IEEE Symposium on Switching and Automata Theory, </booktitle> <pages> pages 1-11, </pages> <year> 1973. </year>
Reference-contexts: Implementation: In addition to preprocessing for range minimum queries over the B and C arrays, we also need suffix trees <ref> [15, 18] </ref> of the dictionary patterns and text, preprocessed for constant time lowest common ancestor queries [12]. The suffix tree construction adds the log k multiplicative factor to our complexity.
References-found: 18

