URL: ftp://ftp.cs.columbia.edu/reports/reports-1994/cucs-021-94.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1994.html
Root-URL: http://www.cs.columbia.edu
Phone: (212)-939-7085 Fax: (212)-666-0140  
Title: An Architecture for Integrating Concurrency Control into Environment Frameworks  
Author: George T. Heineman Gail E. Kaiser fl, George T. Heineman and Gail E. Kaiser 
Keyword: Componentization, Transactions, Software Architecture, Collaborative  
Note: Work c  
Address: 500 West 120th Street, New York, NY 10027  
Affiliation: Department of Computer Science, Columbia University  
Abstract: Research in layered and componentized systems shows the benefit of dividing the responsibility of services into separate components. It is still an unresolved issue, however, how a system can be created from a set of existing (independently developed) components. This issue of integration is of immense concern to software architects since a proper solution would reduce duplicate implementation efforts and promote component reuse. In this paper we take a step towards this goal within the domain of software development environments (SDEs) by showing how to integrate an external concurrency control component, called Pern, with environment frameworks. We discuss two experiments where we integrated Pern with Oz, a multi-site, decentralized process centered environment, and ProcessWEAVER, a commercial process server. We introduce an architecture for retrofitting an external concurrency control component into an environment. 1 This paper is based on work sponsored in part by Advanced Research Project Agency under 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Malcolm Atkinson, Francois Bancilhon, David DeWitt, Klaus Dittrich, David Maier, and Stanley Zdonik. </author> <title> The object-oriented database system manifesto. </title> <editor> In Won Kim, Jean-Marie Nicolas, and Shojiro Nishio, editors, </editor> <booktitle> 1st International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 40-57, </pages> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year> <note> Elsevier Science. </note>
Reference-contexts: While the omission allows for flexibility, it puts an extra burden on the system designer/builder. Further, it is not clear whether either the checkout paradigm or conventional transactions, the main models explicitly incorporated into some existing SDEs, are really adequate. The database community reports <ref> [18, 1, 21] </ref> that short, pre-programmed, atomic and serializable transactions, developed for data processing (payroll, inventory, and the like), are not appropriate for the long-duration, open-ended (e.g., interactive), and potentially collaborative applications prevalent in engineering design applications and, we believe, in SDEs.
Reference: [2] <author> Naser S. Barghouti. </author> <title> Concurrency Control in Rule-Based Software Development Environments. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> February </month> <year> 1992. </year> <month> CUCS-001-92. </month>
Reference-contexts: We conclude with lessons learned and suggestions for future work. Since our focus in this paper is on interfacing task management services and external concurrency control mechanisms, we do not discuss the cooperative transaction functionality supported by our component (for details, see <ref> [2, 14] </ref>). Instead, for simplicity in presentation, we employ conventional transactions in all of our examples. 2 Requirements The basic requirements imposed on TMS by concurrency control mechanisms, whether internal or external, include the following: * Logical units that could potentially be mapped to transactions.
Reference: [3] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Concurrency control in advanced database applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-317, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: SDE applications probably require what are sometimes termed "cooperative transactions". A variety of collaborative concurrency control mechanisms have been proposed in the literature; see <ref> [3] </ref> for a survey. In general, cooperative transactions make it possible to guarantee atomicity (rollback of an entire atomic unit if it cannot be completed) and possible to enforce serializability (isolation that makes it appear as if only one user/task is accessing the data repository).
Reference: [4] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: pre-existing component (s), with the rest of a system implemented more-or-less from scratch to take advantage of these components (e.g., Mach [20], Camelot [10], and many database applications); (2) building-block kits, where sets of components that can be mixed and matched are designed and implemented together (e.g., Genesis and Avoca <ref> [4] </ref>); and (3) compo-nentization, where a pre-existing system is reengineered into individual components, perhaps in preparation for (1) or (2).
Reference: [5] <author> Israel Z. Ben-Shaul. </author> <title> Oz: A decentralized process centered environment. </title> <institution> CUCS-011-93, Columbia University Department of Computer Science, </institution> <month> April </month> <year> 1993. </year> <type> PhD Thesis Proposal. </type>
Reference-contexts: The Oz experiment builds Pern into the Oz runtime executables through direct linking. The ProcessWEAVER experiment utilizes remote procedure calls (RPC) here, the mediator is the boilerplate RPC code that provides the standard client/server stub interface. 8 4 Experiment 1: Oz Oz <ref> [5] </ref> is a multi-site, decentralized process centered environment. The Oz process server is the TMS component of the Oz architecture and defines a three-level hierarchy of nested contexts. The lowest level, the activity level, is where Oz interfaces to actual tools (e.g., through envelopes [13]).
Reference: [6] <author> Israel Z. Ben-Shaul and Gail E. Kaiser. </author> <title> A paradigm for decentralized process modeling and its realization in the OZ environment. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 179-188, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Each site communicates with other sites through an interprocess communication layer (IPC). In Oz, each process-step corresponds to a transaction. The decentralized process modeling aspects of Oz, discussed in <ref> [6] </ref>, allow treaties to be formed between sites (in pairwise fashion) to define the specific collaboration that may occur between those sites. A treaty between SiteA and SiteB defines a common sub-process and sub-schema (a "unit of commonality") that becomes part of each site's local process.
Reference: [7] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An architecture for multi-user software development environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: Here, one "inconsistent state" is the situation whereby the change is incorporated into SE1 and SE2, but not SE3. Since each process-step corresponds to a transaction, Oz creates the atomic units by setting appropriate dependencies between transactions. 10 The Marvel system <ref> [7] </ref> (from which Oz evolved) already provided support for enforcing local atomic units within individual sites (Marvel supported only single site environments). We considered two possible approaches to providing transactional semantics for summits. The first required building a special purpose transaction manager for Oz.
Reference: [8] <editor> Prasun Dewan, editor. </editor> <booktitle> Special Issue on Collaborative Software, volume 6:2 of Computing Systems, The Journal of the USENIX Association. </booktitle> <institution> University of California Press, </institution> <month> Spring </month> <year> 1993. </year>
Reference-contexts: But some SDEs do not provide any concurrency control at all, either because the system was initially envisioned as supporting only one-user/one-task (at a time) and later extended to multiple concurrent tasks per user and/or to multiple users with essentially manual synchronization (e.g., passing the "floor" in multi-user editors <ref> [8] </ref>), or because the designers assumed that some external facility would provide concurrency control (such as for the Cap Gemini Innovation ProcessWEAVER [11]). In this paper, we present an external concurrency control (ECC) architecture with example applications drawn from the latter category, where concurrency control was left for another component.
Reference: [9] <author> Anthony Earl. </author> <title> Principles of a reference model for computer aided software engineering environments. </title> <editor> In Fred Long, editor, </editor> <booktitle> Software Engineering Environments International Workshop on Environments, volume 467 of Lecture Notes in Computer Science, </booktitle> <pages> pages 115-129, </pages> <address> Chinon, France, </address> <month> September </month> <year> 1989. </year> <note> Springer-Verlag. </note>
Reference-contexts: The concept of componentized systems has obvious potential benefits from dividing the technical and economic responsibilities for providing services; in the case of SDEs, we can refer to the "Toaster" model <ref> [9] </ref> to find user interface, task management, data integration, data repository and communication components, as well as individual tools. It is still unclear, however, how one can and should integrate SDE components (as opposed to tools) together to produce a coherent, useful, and usable system. <p> However, there must be some means for ECC to interact with the other components, such as through additional mediators or an extended interface provided by TMS. 3 ECC Architecture To fix the terminology for this paper, we turn to the "Toaster" model by Earl <ref> [9] </ref>. This reference model targets particular services of an SDE and groups them by functionality; the various layers are shown in Figure 2. Data repository services are responsible for storing the data in any combination of file system and database (s).
Reference: [10] <author> Jeffrey L. Eppinger, Lily B. Mummert, and Alfred Z. Spector, </author> <title> editors. Camelot and Avalon A Distributed Transaction Facility. </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo CA, </address> <year> 1991. </year> <month> 18 </month>
Reference-contexts: this paper explores the integration of independently developed, pre-existing components, in contrast to work on (1) construction of systems based on one (or a small number of) pre-existing component (s), with the rest of a system implemented more-or-less from scratch to take advantage of these components (e.g., Mach [20], Camelot <ref> [10] </ref>, and many database applications); (2) building-block kits, where sets of components that can be mixed and matched are designed and implemented together (e.g., Genesis and Avoca [4]); and (3) compo-nentization, where a pre-existing system is reengineered into individual components, perhaps in preparation for (1) or (2).
Reference: [11] <author> Christer Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In 2nd International Conference on the Software Process: Continuous Software Process Improvement, </booktitle> <pages> pages 12-26, </pages> <address> Berlin, Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: one-user/one-task (at a time) and later extended to multiple concurrent tasks per user and/or to multiple users with essentially manual synchronization (e.g., passing the "floor" in multi-user editors [8]), or because the designers assumed that some external facility would provide concurrency control (such as for the Cap Gemini Innovation ProcessWEAVER <ref> [11] </ref>). In this paper, we present an external concurrency control (ECC) architecture with example applications drawn from the latter category, where concurrency control was left for another component. <p> So as a second test 12 case, we chose a commercial product ProcessWEAVER where we had no special knowledge of the system nor access to the source code. 5 Experiment 2: ProcessWEAVER ProcessWEAVER <ref> [11] </ref> is a set of utilities that adds process support capability to Unix-based toolkits. ProcessWEAVER utilities communicate with each other via a Broadcast Message Server (BMS). These utilities support modeling and enactment of process models.
Reference: [12] <author> Jorge F. Garza and Won Kim. </author> <title> Transaction management in an object-oriented database system. </title> <booktitle> In SIGMOD International Conference on Data Management, </booktitle> <pages> pages 37-45, </pages> <address> Chicago IL, </address> <month> June </month> <year> 1988. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 17(3), </volume> <month> September </month> <year> 1988. </year>
Reference-contexts: For example, if ECC is requested to acquire a lock on a sub-item of a larger set of data items, the mediator can request intention locks on all ancestors (as in the Orion system <ref> [12] </ref>). During recovery, the recovery mediator communicates with data repository services to restore the data appropriately, thus abstracting ECC from any one particular data representation. The architecture in Figure 3 is open-ended and flexible, allowing for several different types of mediators.
Reference: [13] <author> Mark A. Gisi and Gail E. Kaiser. </author> <title> Extending a tool integration language. </title> <editor> In Mark Dowson, editor, </editor> <booktitle> 1st International Conference on the Software Process: Manufacturing Complex Systems, </booktitle> <pages> pages 218-227, </pages> <address> Redondo Beach CA, October 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The Oz process server is the TMS component of the Oz architecture and defines a three-level hierarchy of nested contexts. The lowest level, the activity level, is where Oz interfaces to actual tools (e.g., through envelopes <ref> [13] </ref>). The process-step level encapsulates activities with prerequisites and immediate consequences (if any) of tool invocations as determined by a process. The task level is a set of logically related process steps with the combined set of their prerequisites and consequences.
Reference: [14] <author> George T. Heineman. </author> <title> A transaction manager component for cooperative transaction models. </title> <institution> CUCS-017-93, Columbia University Department of Computer Science, </institution> <month> July </month> <year> 1993. </year> <type> PhD Thesis Proposal. </type>
Reference-contexts: We conclude with lessons learned and suggestions for future work. Since our focus in this paper is on interfacing task management services and external concurrency control mechanisms, we do not discuss the cooperative transaction functionality supported by our component (for details, see <ref> [2, 14] </ref>). Instead, for simplicity in presentation, we employ conventional transactions in all of our examples. 2 Requirements The basic requirements imposed on TMS by concurrency control mechanisms, whether internal or external, include the following: * Logical units that could potentially be mapped to transactions. <p> Israel Ben-Shaul collaborated with the authors on devising the transactional semantics for Oz summits, and along with Naser Barghouti was instrumental in developing the original cooperative transaction management facilities of Marvel (the distinctions between Pern's and Marvel's transaction models are outlined in <ref> [14] </ref>). Several members of the Programming Systems Laboratory are working on developing other environment framework components, including a multi-lingual, multi-modal process server [19, 24]. 17
Reference: [15] <author> George T. Heineman and Gail E. Kaiser. </author> <title> Incremental process support for code reengineering (Experience Report). </title> <booktitle> In International Conference on Software Maintenance, </booktitle> <address> Victoria BC, Canada, </address> <month> September </month> <year> 1994. </year> <note> In press. </note>
Reference-contexts: Process-centered environment support for such componentization is described briefly in <ref> [15] </ref>. The transaction manager from Marvel was isolated and reengineered as a separate component. First, all references to Marvel rules and rule chaining was eliminated from within the transaction manager; this effectively severed the link with Marvel's TMS.
Reference: [16] <author> George T. Heineman and Gail E. Kaiser. </author> <title> Integrating a transaction manager component with ProcessWEAVER. </title> <type> Technical Report CUCS-012-94, </type> <institution> Columbia University Department of Computer Science, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Once again, we needed to decide which component is responsible for concurrency control. Since Process-WEAVER was a commercial product, however, it had to be used "as is" without any source code modifications. Instead, we implemented a 200 line co-shell library (see <ref> [16] </ref> for details) that defined a mediator for ProcessWEAVER to communicate with Pern. ProcessWEAVER was thus parameterized so that only individual CPs had knowledge of transactions, not the rest of the process modeling facilities and framework. <p> In our experiment, ProcessWEAVER is the TMS component and Pern becomes a physically separate utility working in conjunction with the other ProcessWEAVER components to provide the necessary transaction services. In <ref> [16] </ref>, we discussed several alternatives for integrating transactions with Process 14 WEAVER, ultimately deciding upon augmenting a cooperative procedure with additional places and transitions.
Reference: [17] <author> Gail E. Kaiser. </author> <title> Cooperative transactions for multi-user environments. </title> <editor> In Won Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> ACM Press, </publisher> <address> New York NY, </address> <year> 1994. </year> <note> In press. </note>
Reference-contexts: The checkout paradigm addresses long-duration and open-ended activities, but is weak on collaboration since user tasks are performed in a private workspace; version merging, notification, group workspaces, and other work-arounds that attempt to extend checkout to collaborative work are discussed elsewhere <ref> [17] </ref>. SDE applications probably require what are sometimes termed "cooperative transactions". A variety of collaborative concurrency control mechanisms have been proposed in the literature; see [3] for a survey.
Reference: [18] <editor> Erich Neuhold and Michael Stonebraker (editors). </editor> <booktitle> Future directions in DBMS research. SIGMOD Record, </booktitle> <volume> 18(1) </volume> <pages> 17-26, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: While the omission allows for flexibility, it puts an extra burden on the system designer/builder. Further, it is not clear whether either the checkout paradigm or conventional transactions, the main models explicitly incorporated into some existing SDEs, are really adequate. The database community reports <ref> [18, 1, 21] </ref> that short, pre-programmed, atomic and serializable transactions, developed for data processing (payroll, inventory, and the like), are not appropriate for the long-duration, open-ended (e.g., interactive), and potentially collaborative applications prevalent in engineering design applications and, we believe, in SDEs.
Reference: [19] <author> Steven S. Popovich. </author> <title> Rule-based process servers for software development environments. </title> <booktitle> In 1992 Centre for Advanced Studies Conference, </booktitle> <volume> volume I, </volume> <pages> pages 477-497, </pages> <address> Toronto ON, Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Canada Ltd. Laboratory. </institution>
Reference-contexts: Several members of the Programming Systems Laboratory are working on developing other environment framework components, including a multi-lingual, multi-modal process server <ref> [19, 24] </ref>. 17
Reference: [20] <author> Richard Rashid, Avadis Tevanian, Michael Young, David Golub, Robert Baron, David Black, William Bolosky, and Jonathan Chew. </author> <title> Machine-independent virtual memory management for paged uniprocessor and multiprocessor architectures. </title> <booktitle> In 2nd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 31-39, </pages> <address> Palo Alto CA, </address> <month> October </month> <year> 1987. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 22(10), </volume> <month> October </month> <year> 1987. </year>
Reference-contexts: software architecture, this paper explores the integration of independently developed, pre-existing components, in contrast to work on (1) construction of systems based on one (or a small number of) pre-existing component (s), with the rest of a system implemented more-or-less from scratch to take advantage of these components (e.g., Mach <ref> [20] </ref>, Camelot [10], and many database applications); (2) building-block kits, where sets of components that can be mixed and matched are designed and implemented together (e.g., Genesis and Avoca [4]); and (3) compo-nentization, where a pre-existing system is reengineered into individual components, perhaps in preparation for (1) or (2).
Reference: [21] <author> Lawrence A. Rowe. </author> <title> Report on the 1989 Software CAD Databases Workshop. </title> <editor> In Gerhard Ritter, editor, </editor> <booktitle> 11th World Computer Conference IFIP Congress '89, </booktitle> <pages> pages 719-725, </pages> <address> San Francisco CA, </address> <month> August </month> <year> 1989. </year> <note> Elsevier Science. 19 </note>
Reference-contexts: While the omission allows for flexibility, it puts an extra burden on the system designer/builder. Further, it is not clear whether either the checkout paradigm or conventional transactions, the main models explicitly incorporated into some existing SDEs, are really adequate. The database community reports <ref> [18, 1, 21] </ref> that short, pre-programmed, atomic and serializable transactions, developed for data processing (payroll, inventory, and the like), are not appropriate for the long-duration, open-ended (e.g., interactive), and potentially collaborative applications prevalent in engineering design applications and, we believe, in SDEs.
Reference: [22] <author> Kevin J. Sullivan and David Notkin. </author> <title> Reconciling environment integration and component independence. </title> <editor> In Richard N. Taylor, editor, </editor> <booktitle> SIGSOFT '90 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 22-33, </pages> <address> Irvine CA, </address> <month> December </month> <year> 1990. </year> <note> ACM Press. Special issue of Software Engineering Notes, 15(6), </note> <month> December </month> <year> 1990. </year>
Reference-contexts: To make integration possible under such circumstances, we argue that external mediators must be implemented to overcome the mismatch between components (see <ref> [22] </ref>, for a supporting view). Our challenge is that TMS components (as described in the literature) do not specify any particular model of what they require for concurrency control, nor do the (known) implementations provide any pre-defined interface to an ECC utility.
Reference: [23] <author> Ian Thomas. </author> <title> PCTE interfaces: Supporting tools in software-engineering environments. </title> <journal> IEEE Software, </journal> <volume> 6(6) </volume> <pages> 15-23, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: It is still unclear, however, how one can and should integrate SDE components (as opposed to tools) together to produce a coherent, useful, and usable system. Previous work on componentized SDEs, such as various systems constructed on top of PCTE <ref> [23] </ref>, has generally adopted ad hoc solutions suitable for their particular integrated system rather than introducing a general architecture for a class of component integrations.
Reference: [24] <author> Andrew Z. Tong, Gail E. Kaiser, and Steven S. Popovich. </author> <title> A flexible rule-chaining engine for process-based software engineering. </title> <booktitle> In 9th Knowledge-Based Software Engineering Conference, </booktitle> <address> Monterey CA, </address> <month> September </month> <year> 1994. </year> <note> In press. </note>
Reference-contexts: Several members of the Programming Systems Laboratory are working on developing other environment framework components, including a multi-lingual, multi-modal process server <ref> [19, 24] </ref>. 17
References-found: 24

