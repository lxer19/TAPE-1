URL: ftp://ftp.cs.rochester.edu/pub/papers/systems/97.tr648.Coign_for_inter-component_communication_analysis.ps.gz
Refering-URL: http://www.cs.rochester.edu/u/gchunt/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Coign: Efficient Instrumentation for Inter-Component Communication Analysis  
Author: Galen C. Hunt and Michael L. Scott 
Keyword: Component Software, Distributed Applications, Groupware, Component Placement, Coign, Inter-Component Communication Analysis (ICCA).  
Web: Web: http://www.cs.rochester.edu/u/gchunt/coign.  
Note: Email: fgchunt,scottg@cs.rochester.edu. World Wide  The first author was supported by a Research Fellowship from Microsoft Corporation. This work was also supported in part by NSF grants CDA-9401142 and CCR-9319445.  
Address: Rochester, NY 14627-0226  
Affiliation: Department of Computer Science University of Rochester  
Abstract: We propose a conceptual framework, inter-component communication analysis (ICCA), for understanding and exploring the structure of component applications. ICCA models an application as a graph with vertices representing components and edges representing communication links and instantiation relationships between components . Communication edges are labeled with the amount of communication that would cross the interface if the connected components were located in separate address spaces. We describe the Coign runtime system for gathering the data necessary to create the ICCA graph. Coign is distinctive in that it creates the entire ICCA graph using only application binaries. It can in fact be used on components lacking source code. Quantifying inter-component communication is vital to understanding and exploiting the architecture of component applications. We demonstrate the use of ICCA and Coign to determine an optimal distribution of a component application across a network. ICCA helps programmers by providing important information about the application at exactly the level needed: the level of component composition. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Apple Computer, Inc. The OpenDOC Software Development Kit. Cupertino, </institution> <address> CA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Component systems offer programmers and users great potential for simplifying development, increasing object reuse, and reducing application costs. Systems such as ActiveX/COM [19], OpenDoc <ref> [1] </ref>, Java Beans [15] and others [7, 13] support creation of applications by aggregating components. Components may come from a programmer's private library, from code shared by a colleague, or from a commercial component provider. Components can be combined to create applications cheaply and with relatively little effort.
Reference: [2] <author> H.-D. Bocker and J. Herczeg. </author> <title> Browsing Through Program Execution. </title> <booktitle> In Proceedings of INTERACT '90, The Third Internation Conference on Human-Computer Interaction, pages 991- 997, </booktitle> <address> Cambridge, UK, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: They use two instrumentation systems. One records message information, specifically sender, receiver and arguments; the second animates method invocations. Bocker and Herczeg [4] instrument individual methods to uncover dynamic properties of Smalltalk programs. Their work consists of two parts, TRICK, an instrumentation system, and TRACK <ref> [2, 3] </ref>, a graphical front end for manipulating the instrumentation. As with GraphTrace, the focus is on visualizing different parts of program execution. Using TRACK, the programmer can place a tracer around a particular class, object, or method. Execution enters the tracer before proceeding into the surrounded code.
Reference: [3] <author> H.-D. Bocker and J. Herczeg. </author> <title> TRACK- A Trace Construction Kit. </title> <booktitle> In CHI-90, Human Factors in Computer Systems Conference Proceedings, </booktitle> <pages> pages 415-422, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: They use two instrumentation systems. One records message information, specifically sender, receiver and arguments; the second animates method invocations. Bocker and Herczeg [4] instrument individual methods to uncover dynamic properties of Smalltalk programs. Their work consists of two parts, TRICK, an instrumentation system, and TRACK <ref> [2, 3] </ref>, a graphical front end for manipulating the instrumentation. As with GraphTrace, the focus is on visualizing different parts of program execution. Using TRACK, the programmer can place a tracer around a particular class, object, or method. Execution enters the tracer before proceeding into the surrounded code.
Reference: [4] <author> H.-D. Bocker and J. Herczeg. </author> <title> What Tracers Are Made of. </title> <booktitle> In OOPSLA/ECOOP '90 Conference Proceedings, </booktitle> <pages> pages 89-99, </pages> <address> Ottawa, Ontario, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Runtime information is combined with static analysis to provide several views animating the execution of the instrumented program. They use two instrumentation systems. One records message information, specifically sender, receiver and arguments; the second animates method invocations. Bocker and Herczeg <ref> [4] </ref> instrument individual methods to uncover dynamic properties of Smalltalk programs. Their work consists of two parts, TRICK, an instrumentation system, and TRACK [2, 3], a graphical front end for manipulating the instrumentation. As with GraphTrace, the focus is on visualizing different parts of program execution.
Reference: [5] <author> N. Brown and C. Kindel. </author> <title> Distributed Component Object Model Protocol - DCOM/1.0. </title> <publisher> Microsoft Corporation, </publisher> <address> Redmond, WA, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: Much effort has been invested in attempts to reduce the difficulty of developing distributed applications. Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA [23], and DCOM <ref> [5] </ref> ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another. Other systems, including Amoeba [21], , DOME [8], Globe [13], Infospheres [7] and Legion [18], attempt to reduce the development costs of distributed applications by creating completely distributed environments.
Reference: [6] <author> I. Carmichael, V. Tzerpos, and R. C. Holt. </author> <title> Design Maintenance: Unexpected Architectural Interactions. </title> <booktitle> In Proceedings of the IEEE International Conference on Software Maintenance, </booktitle> <address> Opio, France, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: We have already shown how ICCA can be used in determining how to distribute components of an application, 7 either for a client-server distribution or for multiple users. ICCA is also useful in answering programmer questions about the following issues: Unknown Connections Carmichael et al. <ref> [6] </ref> document that even in well-designed, well-written programs there are often connections between components that are either not well understood or not known to exist by the system designers. A simple application of ICCA is to provide the designer with a mapping of the existing connections between components at runtime.
Reference: [7] <author> K. M. Chandy, A. Chelian, B. Dimitrov, H. Le, J. Mandelson, M. Richardson, A. Rifkin, P. A. G. Sivilotti, W. Tanaka, and L. Weisman. </author> <title> A WorldWide Distributed System Using Java and the Internet. </title> <booktitle> In Proceedings of the Fifth International Symposium on High Performance Distributed Computing, </booktitle> <address> Syracuse, NY, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Component systems offer programmers and users great potential for simplifying development, increasing object reuse, and reducing application costs. Systems such as ActiveX/COM [19], OpenDoc [1], Java Beans [15] and others <ref> [7, 13] </ref> support creation of applications by aggregating components. Components may come from a programmer's private library, from code shared by a colleague, or from a commercial component provider. Components can be combined to create applications cheaply and with relatively little effort. <p> Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another. Other systems, including Amoeba [21], , DOME [8], Globe [13], Infospheres <ref> [7] </ref> and Legion [18], attempt to reduce the development costs of distributed applications by creating completely distributed environments. Their general philosophy is that all objects, regardless of their location, are treated equal.
Reference: [8] <author> J. N. Cotrim Arabe, A. Beguelin, B. Lowekamp, E. Seligman, M. Starkey, and P. Stephan. Dome: </author> <title> Parallel Programming in a Distributed Computing Environment. </title> <booktitle> In Proceedings of the Tenth International Parallel Processing Symposium, </booktitle> <address> Honolulu, HI, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another. Other systems, including Amoeba [21], , DOME <ref> [8] </ref>, Globe [13], Infospheres [7] and Legion [18], attempt to reduce the development costs of distributed applications by creating completely distributed environments. Their general philosophy is that all objects, regardless of their location, are treated equal.
Reference: [9] <author> B. J. Cox. </author> <title> Objective C: Programming Smalltalk-80 Methods in C Language. </title> <booktitle> In Proceedings of the 1893 USENIX Software Tools Users Group Summer Conference, </booktitle> <pages> page 236, </pages> <address> Toronto, Canada, </address> <month> July </month> <year> 1983. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: In essence, measurement is a side product of data marshaling with the optimization that no data needs to be copied. 2.2 Aliases ICCA requires that all inter-component messages be instrumented. Unlike Smalltalk [11], or Objective-C <ref> [9] </ref>, COM has no central message dispatcher. All messages are passed as indirect function calls through an interface's virtual function table (vtable). The COM runtime drops out of the way once a component has been instantiated.
Reference: [10] <author> W. Cunningham and K. Beck. </author> <title> A Diagram for Object-Oriented Programs. </title> <booktitle> In OOPSLA '86 Conference Proceedings, </booktitle> <pages> pages 361-367, </pages> <address> Portland, OR, </address> <month> September - October </month> <year> 1986. </year>
Reference-contexts: All of the histograms are logged to coign.msg when the application terminates. 6 Related Work A number of researchers have recognized the potential benefits of instrumenting message communication. Their work highlights the richness of information available from monitoring inter-object messages. Cunningham and Beck <ref> [10] </ref> instrument message calls by modifying the Smalltalk-80 debugger. The purpose of their system is to create object call diagrams when the programmer issues step or send commands. Unlike the debugger's runtime stack display, which reflects only the current state of computation, the call diagram contains accumulated calling information.
Reference: [11] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In essence, measurement is a side product of data marshaling with the optimization that no data needs to be copied. 2.2 Aliases ICCA requires that all inter-component messages be instrumented. Unlike Smalltalk <ref> [11] </ref>, or Objective-C [9], COM has no central message dispatcher. All messages are passed as indirect function calls through an interface's virtual function table (vtable). The COM runtime drops out of the way once a component has been instantiated.
Reference: [12] <author> D. </author> <title> Hartman. </title> <journal> Unclogging Distributed Computing. IEEE Spectrum, </journal> <volume> 29(5) </volume> <pages> 36-39, </pages> <month> May </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: Much effort has been invested in attempts to reduce the difficulty of developing distributed applications. Run-time systems, such as RPC [22], DCE <ref> [12] </ref>, DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another.
Reference: [13] <author> P. Homburg, M. van Steen, and A. S. Tanenbaum. </author> <title> An Architecture for a Scaleable Wide Area Distributed System. </title> <booktitle> In Proc. Seventh ACM SIGOPS European Workshop, </booktitle> <address> Connemara, Ireland, </address> <month> Septem-ber </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Component systems offer programmers and users great potential for simplifying development, increasing object reuse, and reducing application costs. Systems such as ActiveX/COM [19], OpenDoc [1], Java Beans [15] and others <ref> [7, 13] </ref> support creation of applications by aggregating components. Components may come from a programmer's private library, from code shared by a colleague, or from a commercial component provider. Components can be combined to create applications cheaply and with relatively little effort. <p> Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another. Other systems, including Amoeba [21], , DOME [8], Globe <ref> [13] </ref>, Infospheres [7] and Legion [18], attempt to reduce the development costs of distributed applications by creating completely distributed environments. Their general philosophy is that all objects, regardless of their location, are treated equal.
Reference: [14] <institution> International Business Machines. </institution> <note> SOMobjects Developer Toolkit Version 2.1. </note> <institution> IBM, </institution> <address> White Plains, NY, </address> <year> 1995. </year>
Reference-contexts: Much effort has been invested in attempts to reduce the difficulty of developing distributed applications. Run-time systems, such as RPC [22], DCE [12], DSOM <ref> [14] </ref>, CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another.
Reference: [15] <author> JavaSoft. </author> <title> JavaBeans, Version 1.0 API Specification. </title> <address> Mountain View, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Component systems offer programmers and users great potential for simplifying development, increasing object reuse, and reducing application costs. Systems such as ActiveX/COM [19], OpenDoc [1], Java Beans <ref> [15] </ref> and others [7, 13] support creation of applications by aggregating components. Components may come from a programmer's private library, from code shared by a colleague, or from a commercial component provider. Components can be combined to create applications cheaply and with relatively little effort.
Reference: [16] <author> M. F. Kleyn and P. C. Gingrich. </author> <title> GraphTrace Understanding Object-Oriented Systems Using Concurrently Animated Views. </title> <booktitle> In OOPSLA '88 Conference Proceedings, </booktitle> <pages> pages 191-205, </pages> <address> San Diego, CA, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The purpose of their system is to create object call diagrams when the programmer issues step or send commands. Unlike the debugger's runtime stack display, which reflects only the current state of computation, the call diagram contains accumulated calling information. Kleyn and Gingrich <ref> [16] </ref> describe the GraphTrace system for program visualization. They instrument the LISP runtime in STROBE to record all method invocations. Runtime information is combined with static analysis to provide several views animating the execution of the instrumented program. They use two instrumentation systems.
Reference: [17] <author> P. Leach and D. Perry. CIFS: </author> <title> A Common Internet File System. In Microsoft Interactive Developer, </title> <month> November </month> <year> 1996. </year>
Reference-contexts: Progressing from the server-based document file to the client display, the com components. ponents are: document component, layout component, viewer component, and paint component. We examine three possible distributions: File System The first distribution retrieves files directly from the server using the CIFS <ref> [17] </ref> distributed file system. In this case, all of the components are located on the client. For this experiment, we calculate network traffic as the number of bytes retrieved from the server, namely the size of the document.
Reference: [18] <author> M. Lewis and A. Grimshaw. </author> <title> The Core Legion Object Model. </title> <booktitle> In Proceedings of the Fifth International Symposium on High Performance Distributed Computing, </booktitle> <address> Syracuse, NY, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another. Other systems, including Amoeba [21], , DOME [8], Globe [13], Infospheres [7] and Legion <ref> [18] </ref>, attempt to reduce the development costs of distributed applications by creating completely distributed environments. Their general philosophy is that all objects, regardless of their location, are treated equal.
Reference: [19] <author> Microsoft Corporation and Digital Equipment Corporation. </author> <title> The Component Object Model Specification. </title> <address> Redmond, WA, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Component systems offer programmers and users great potential for simplifying development, increasing object reuse, and reducing application costs. Systems such as ActiveX/COM <ref> [19] </ref>, OpenDoc [1], Java Beans [15] and others [7, 13] support creation of applications by aggregating components. Components may come from a programmer's private library, from code shared by a colleague, or from a commercial component provider. Components can be combined to create applications cheaply and with relatively little effort.
Reference: [20] <author> Microsoft Corporation. </author> <title> HookOLE Architecture, Alpha Release. </title> <address> Redmond, WA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: The user defines and attaches trace filters to the tracer. Applicable filters are called before and after the instrumented code. They suggest using filters to display message arguments and return values, check argument values for validity, and update program animations. HookOLE <ref> [20] </ref> is a general purpose instrumentatin system for instrumenting COM interface. HookOLE redirects vtable function pointers to special interface wrappers. Interface wrappers call out to user-defined interface filters that are allowed to examine message parameters and return values.
Reference: [21] <author> S. J. Mullender, G. van Rossum, A. S. Tanenbaum, R. van Renesse, and H. vanStaveren. </author> <title> Amoeba: A Distributed Operating System for the 1990s. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 44-53, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another. Other systems, including Amoeba <ref> [21] </ref>, , DOME [8], Globe [13], Infospheres [7] and Legion [18], attempt to reduce the development costs of distributed applications by creating completely distributed environments. Their general philosophy is that all objects, regardless of their location, are treated equal.
Reference: [22] <author> B. J. Nelson. </author> <title> Remote Procedure Call. </title> <editor> Ph. D. </editor> <title> dissertation, </title> <type> Technical Report CMU-CS-81-119, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: Much effort has been invested in attempts to reduce the difficulty of developing distributed applications. Run-time systems, such as RPC <ref> [22] </ref>, DCE [12], DSOM [14], CORBA [23], and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another.
Reference: [23] <author> Object Management Group, Inc. </author> <title> The Common Object Request Broker: Architecture and Specification, Revision 2.0. Framingham, </title> <address> MA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Much effort has been invested in attempts to reduce the difficulty of developing distributed applications. Run-time systems, such as RPC [22], DCE [12], DSOM [14], CORBA <ref> [23] </ref>, and DCOM [5] ease development of distributed applications by providing convenient mechanisms for transferring control and data from one machine to another.
Reference: [24] <author> R. W. Scheifler and J. Gettys. </author> <title> The X Window System. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2) </volume> <pages> 79-109, </pages> <month> April </month> <year> 1986. </year> <month> 11 </month>
Reference-contexts: Window System In the second distribution, the application is split at the interface between the display subsystem and the components. This is analogous to running the application on the server using the X Window System <ref> [24] </ref> to display documents on the client's screen. To measure network traffic in this case, we use the calculation of message traffic between the paint component and all other components in the system. Again, this is a conservative estimate, but will suffice for our needs.
References-found: 24

