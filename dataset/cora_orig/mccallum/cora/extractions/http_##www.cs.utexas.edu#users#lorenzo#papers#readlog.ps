URL: http://www.cs.utexas.edu/users/lorenzo/papers/readlog.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Phone: 2  
Title: Deriving Optimal Checkpoint Protocols for Distributed Shared Memory Architectures  
Author: Lorenzo Alvisi ? and Keith Marzullo ?? 
Address: Ithaca NY  Engineering, La Jolla CA  
Affiliation: 1 Cornell University, Department of Computer Science,  University of California at San Diego, Department of Computer Science and  
Abstract: Uncoordinated checkpointing is one technique used to build processes that can recover to a consistent state after crashing. This technique requires each process to periodically record its state in a checkpoint. Furthermore, the threads executing on each process log any nondeterministic action that they take following the latest checkpointed state. When a process crashes, a new process, initialized with the appropriate recorded local state, is created in its place. The new process restarts executing, and whenever one of its threads confronts a nondeterministic choice, the thread references the log in order to reproduce the same action performed before the crash. Thus, uncoordinated check-pointing implements an abstraction of a resilient process in which the crash of a process is translated into intermittent unavailability of that process. We give a specification of the consistency property "no orphan threads" in the context of multithreaded processes running on a shared memory multiprocessor. We also give a definition of optimality for uncoordinated checkpointing protocols given a memory coherency protocol. We then use this specification to derive an existing uncoordinated checkpoint protocol and show that it is optimal. This protocol assumes that once a process crashes, no further processes crash until the first process completes re covery. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Lorenzo Alvisi and Keith Marzullo. </author> <title> Optimal Message Logging Protocols. </title> <institution> Cornell University Department of Computer Science Technical Report TR 94-1457, </institution> <month> Septem-ber </month> <year> 1994. </year>
Reference-contexts: After recovery is complete, all object versions acquired by surviving processes will have been regenerated, and the system will be in a consistent state. 6 Discussion In <ref> [1, 2] </ref> we have presented a derivation of message logging protocols based on the specification "no orphan processes". The derivation and resulting protocols are different from what we present in this paper because the system model is considerably different. <p> However, much of the work that is presented in [2] can be applied to the distributed shared memory model presented here. In particular, we have developed a set of optimal read logging protocols that use the techniques presented in <ref> [1] </ref> to tolerate any number of concurrent failures. We have not yet derived read logging protocols for memory coherency protocols other than entry consistency. However, we believe that it should be possible to apply our approach to other memory coherency models.
Reference: 2. <author> Lorenzo Alvisi and Keith Marzullo. </author> <title> Message logging: Pessimistic, optimistic, causal and optimal. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Distributed Computing Systems. IEEE Computer Society, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: In fact, it was this unrealistic assumption that prompted the research that led to this paper. We had recently examined the related problem of uncoordinated checkpointing in distributed message passing systems <ref> [2] </ref> and realized that the specification could be modified to apply to distributed shared memory systems and then used to derive the protocol presented in [7]. <p> After recovery is complete, all object versions acquired by surviving processes will have been regenerated, and the system will be in a consistent state. 6 Discussion In <ref> [1, 2] </ref> we have presented a derivation of message logging protocols based on the specification "no orphan processes". The derivation and resulting protocols are different from what we present in this paper because the system model is considerably different. <p> The derivation and resulting protocols are different from what we present in this paper because the system model is considerably different. However, much of the work that is presented in <ref> [2] </ref> can be applied to the distributed shared memory model presented here. In particular, we have developed a set of optimal read logging protocols that use the techniques presented in [1] to tolerate any number of concurrent failures.
Reference: 3. <author> B. N. Bershad, M. J. Zekauskas, and W. A. Sawdon. </author> <title> The midway distributed shared memory system. </title> <booktitle> In Proceedings of the 93 COMPCON Conference, </booktitle> <pages> pages 528-537. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1993. </year>
Reference-contexts: We then derive an existing protocol [7] used in the DiSOM system [4]. The entry consistency memory model was first introduced in the Midway system <ref> [3] </ref>. In this model, programmers is given the responsibility of explicitly structuring their applications in order to ensure that processes view a sequentially consistent memory [6]. In exchange, the weaker consistency requirement imposed by the model allows for good performance.
Reference: 4. <author> P. Guedes and M. Castro. </author> <title> Distributed shared object memory. </title> <booktitle> In Proceedings of the 4th Workshop on Workstation Operating Systems, </booktitle> <pages> pages 142-149, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: We then derive an existing protocol [7] used in the DiSOM system <ref> [4] </ref>. The entry consistency memory model was first introduced in the Midway system [3]. In this model, programmers is given the responsibility of explicitly structuring their applications in order to ensure that processes view a sequentially consistent memory [6].
Reference: 5. <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The execution of the system is represented by a run, which is an irreflex-ive partial ordering of events executed by threads. The events executed by the threads of a given process are totally ordered, but the events of threads of different processes may not be ordered <ref> [5] </ref>.
Reference: 6. <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):241-248, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: The entry consistency memory model was first introduced in the Midway system [3]. In this model, programmers is given the responsibility of explicitly structuring their applications in order to ensure that processes view a sequentially consistent memory <ref> [6] </ref>. In exchange, the weaker consistency requirement imposed by the model allows for good performance. The features of the entry consistency model can be summarized as follows: All access to shared objects must be enclosed between explicit acquire and release commands.
Reference: 7. <author> N. Neves, M. Castro, and P. Guedes. </author> <title> A checkpoint protocol for an entry consistent shared memory system. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Principles of Distributed Computing. ACM SIGACT/SIGOPS, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Hence, the metrics we use to define optimality do not refer to the cost incurred by the periodic recording of the states of processes. We use the specification to derive an existing uncoordinated checkpointing protocol <ref> [7] </ref> for a particular memory coherency protocol and show that the protocol is optimal with respect to our metrics. This protocol makes the (perhaps unrealistic) assumption that once a process crashes, no further processes crash until the first process completes recovery. <p> We had recently examined the related problem of uncoordinated checkpointing in distributed message passing systems [2] and realized that the specification could be modified to apply to distributed shared memory systems and then used to derive the protocol presented in <ref> [7] </ref>. It is then relatively straightforward to apply our results in the message passing domain to modify this protocol into one that can tolerate any pattern of process crashes and recoveries. 2 System Model We assume a set T of threads. <p> An example of a read logging protocol that meets the above definition of optimality with respect to the Midway memory coherency protocol is given in <ref> [7] </ref>. This protocol is described in detail in the next section. 5 The DiSOM Protocol In this section, we illustrate the formalism developed in Section 3 by applying it to a particular memory coherency protocol (entry consistency) with the assumption that f = 1. We then derive an existing protocol [7] <p> <ref> [7] </ref>. This protocol is described in detail in the next section. 5 The DiSOM Protocol In this section, we illustrate the formalism developed in Section 3 by applying it to a particular memory coherency protocol (entry consistency) with the assumption that f = 1. We then derive an existing protocol [7] used in the DiSOM system [4]. The entry consistency memory model was first introduced in the Midway system [3]. In this model, programmers is given the responsibility of explicitly structuring their applications in order to ensure that processes view a sequentially consistent memory [6]. <p> DiSOM defines the notion of object ownership: a process p is the owner of an object o if the last version of object o has been produced by one of the threads running on p. The system assumptions made in Section 2 are also made in <ref> [7] </ref>: threads are piecewise deterministic and processes fail in a fail-stop manner. The failure of a process can lead to the loss of a suffix of the versions of objects. The correctness condition for recovery given in [7] is: A system state is consistent if all threads, holding objects, hold the <p> The system assumptions made in Section 2 are also made in <ref> [7] </ref>: threads are piecewise deterministic and processes fail in a fail-stop manner. The failure of a process can lead to the loss of a suffix of the versions of objects. The correctness condition for recovery given in [7] is: A system state is consistent if all threads, holding objects, hold the last versions of those objects and no thread has acquired a version of an object that was lost due to a failure. Protocol Derivation. <p> This is a unique version for o because, if tid were to create another version of o, it would first have to re-acquire o and perforce start a new state interval. Following <ref> [7] </ref>, we call the pair htid; lti the execution point ep prd of thread tid when it created v. We denote this execution point as ep prd for this version of o.
Reference: 8. <author> Fred B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: We assume that processes fail independently according to the fail-stop model applied to processes <ref> [8] </ref>. When a process fails, then all the threads of that process also fail.
References-found: 8

