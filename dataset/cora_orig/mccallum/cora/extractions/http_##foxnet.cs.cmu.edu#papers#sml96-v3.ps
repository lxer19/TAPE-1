URL: http://foxnet.cs.cmu.edu/papers/sml96-v3.ps
Refering-URL: http://foxnet.cs.cmu.edu/papers.html
Root-URL: 
Title: An Interpretation of Standard ML in Type Theory  
Author: Robert Harper Christopher Stone 
Note: This report also appears as Fox Memorandum CMU-CS-FOX-97-01  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: June 27, 1997  
Pubnum: CMU-CS-97-147  
Abstract: This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050, in part by the National Science Foundation under Grant No. CCR-9502674, and in part by the US Army Research Office under Grant No. DAAH04-94-G-0289. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency, the U.S. Government or the National Science Foundation. 
Abstract-found: 1
Intro-found: 1
Reference: [Har93] <author> Robert Harper. </author> <title> A simplified account of polymorphic references. </title> <type> Technical Report CMU-CS-93-169, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: The two levels are connected by the ability to define modules local to a core expression. Dynamic Semantics of the Internal Language. The dynamic semantics is essentially a contextual semantics [WF91]. The handling of references and exceptions is similar to Harper's account of polymorphic references <ref> [Har93] </ref>. Elaboration. <p> *con 0 then decs ` exp 0 exp : con 0 and by the inductive hypothesis we have decs ` c E 0 [exp 0 exp 2 ] : con; that is, decs ` b E [exp 0 ] : con. ffi 7.1.3 Soundness of the Internal Language Following Harper <ref> [Har93] </ref>, we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions [Tof90]. (An essentially similar
Reference: [HL94] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <year> 1994. </year>
Reference-contexts: Additionally, the constructors are extended with (restricted) tuples of constructors and functions at the constructor level. Note that there are no polymorphic types (polytypes) in our system. The modules system is based on the translucent sum or manifest type modules calculi <ref> [HL94, Ler94] </ref>. In addition to translucent signatures, we have total and partial functor signatures. Our subtyping relation on signatures involves only forgetting of type definitions and totality, and not dropping or reordering components. This means that subtyping has no run-time effect. <p> These higher-order modules are based on the translucent sum formalism <ref> [HL94] </ref>. As this is compatible with first-class modules (which are not included in this definition), our higher-order functors propagate less type-sharing information than those in the system of MacQueen and Tofte [MT94].
Reference: [HM93] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <year> 1993. </year>
Reference-contexts: The type-theoretic interpretation of Standard ML is divided into three main parts. 3 Type Structure of the Internal Language. The internal language is an explicitly-typed -calculus, with a second-class modules system. The core of the internal language is based on the XML and ML calculi <ref> [HM93, HMM90] </ref>. The constructors of kind (where is the kind of types) include partial and total function types, record types, sum types, reference types, recursive types, and a single extensible sum. Additionally, the constructors are extended with (restricted) tuples of constructors and functions at the constructor level.
Reference: [HM95] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In 22nd Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <year> 1995. </year>
Reference-contexts: The elaboration has application to language implementation as well, as it may be viewed as a reference implementation of a front-end for an SML compiler. In particular, we are using this translation as a guide to our re-implementation of the TIL/ML compiler <ref> [HM95, Mor95, Tar96, TMC + 96] </ref>. Compilers for other languages defined by interpretation into the internal language could share the back end of the TIL/ML compiler; only a front-end need be written for each specific language. There are some disadvantages to our approach.
Reference: [HMM90] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In 17th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <year> 1990. </year>
Reference-contexts: The type-theoretic interpretation of Standard ML is divided into three main parts. 3 Type Structure of the Internal Language. The internal language is an explicitly-typed -calculus, with a second-class modules system. The core of the internal language is based on the XML and ML calculi <ref> [HM93, HMM90] </ref>. The constructors of kind (where is the kind of types) include partial and total function types, record types, sum types, reference types, recursive types, and a single extensible sum. Additionally, the constructors are extended with (restricted) tuples of constructors and functions at the constructor level.
Reference: [Ler94] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year>
Reference-contexts: Additionally, the constructors are extended with (restricted) tuples of constructors and functions at the constructor level. Note that there are no polymorphic types (polytypes) in our system. The modules system is based on the translucent sum or manifest type modules calculi <ref> [HL94, Ler94] </ref>. In addition to translucent signatures, we have total and partial functor signatures. Our subtyping relation on signatures involves only forgetting of type definitions and totality, and not dropping or reordering components. This means that subtyping has no run-time effect.
Reference: [Ler96] <author> Xavier Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 667-698, </pages> <year> 1996. </year>
Reference-contexts: This problem involved abstract types defined in anonymous structure expressions, defined locally in let or local at the module level, or hidden by SML's transparent ascription (strexp : sigexp). This has been corrected by: 1. Restricting the EL to named form at the module level, following Leroy <ref> [Ler96] </ref>. This can always be achieved by a simple prepass over the program. (The grammar in Section 5 shows what we mean by named form.) 7 2.
Reference: [Lil97] <author> Mark Lillibridge. </author> <title> Translucent Sums: A Foundation for Higher-Order Module Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1997. </year> <note> Available as CMU Technical Report CMU-CS-97-122. </note>
Reference-contexts: Roughly speaking one can always first "inline" the abbreviations and then test for equivalence as in the previous case. It is not obvious how to extend the proof to include Rule 31 in a simple fashion. Lil-libridge <ref> [Lil97] </ref> gives a complex argument for the decidability of constructor equivalence in a related system (without records of constructors).
Reference: [Mor95] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1995. </year> <note> Available as CMU Technical Report CMU-CS-95-226. </note>
Reference-contexts: The elaboration has application to language implementation as well, as it may be viewed as a reference implementation of a front-end for an SML compiler. In particular, we are using this translation as a guide to our re-implementation of the TIL/ML compiler <ref> [HM95, Mor95, Tar96, TMC + 96] </ref>. Compilers for other languages defined by interpretation into the internal language could share the back end of the TIL/ML compiler; only a front-end need be written for each specific language. There are some disadvantages to our approach.
Reference: [MT94] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title> <booktitle> In European Symposium on Programming, </booktitle> <pages> pages 409-423. </pages> <publisher> Springer-Verlag, LNCS 788, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: These higher-order modules are based on the translucent sum formalism [HL94]. As this is compatible with first-class modules (which are not included in this definition), our higher-order functors propagate less type-sharing information than those in the system of MacQueen and Tofte <ref> [MT94] </ref>. Finding a clean type-theoretic description of this latter system is the subject of current research. 6 1.3.4 Top-level Since we allow locally-defined modules in our external language, it suffices to consider programs to be closed expressions of type ans, where ans is a fixed base type of answers.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [MTHM97] <author> Robin Milner, Mads Tofte, Robert Harper, and Dave MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction 1.1 Overview This document consists of a type-theoretic account of a variant of (Revised) Standard ML <ref> [MTHM97] </ref>, hereafter referred to simply as Standard ML or SML. The approach taken here is to elaborate SML abstract syntax (the external language, or EL) into an explicitly-typed - calculus (the internal language, or IL).
Reference: [Plo81] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: The presentation is strongly influenced by the work of Plotkin <ref> [Plo81] </ref> and Wright and Felleisen [WF91], and is a significant departure from the framework employed in The Definition. In particular we employ a small step semantics in which transitions represent basic evaluation steps of an abstract machine.
Reference: [Tar96] <author> David Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year> <month> 73 </month>
Reference-contexts: The elaboration has application to language implementation as well, as it may be viewed as a reference implementation of a front-end for an SML compiler. In particular, we are using this translation as a guide to our re-implementation of the TIL/ML compiler <ref> [HM95, Mor95, Tar96, TMC + 96] </ref>. Compilers for other languages defined by interpretation into the internal language could share the back end of the TIL/ML compiler; only a front-end need be written for each specific language. There are some disadvantages to our approach.
Reference: [TMC + 96] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <year> 1996. </year>
Reference-contexts: The elaboration has application to language implementation as well, as it may be viewed as a reference implementation of a front-end for an SML compiler. In particular, we are using this translation as a guide to our re-implementation of the TIL/ML compiler <ref> [HM95, Mor95, Tar96, TMC + 96] </ref>. Compilers for other languages defined by interpretation into the internal language could share the back end of the TIL/ML compiler; only a front-end need be written for each specific language. There are some disadvantages to our approach.
Reference: [Tof90] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89(1) </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Language Following Harper [Har93], we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions <ref> [Tof90] </ref>. (An essentially similar observation was made by Wright and Felleisen [WF91].) Fix a base type ans of answers to which a complete, closed program might evaluate. 2 We can say that a machine state is well-formed, written ` (; ; E; phrase); if and only if ` b E [phrase]
Reference: [WF91] <author> Andrew Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <year> 1991. </year>
Reference-contexts: This means that subtyping has no run-time effect. The two levels are connected by the ability to define modules local to a core expression. Dynamic Semantics of the Internal Language. The dynamic semantics is essentially a contextual semantics <ref> [WF91] </ref>. The handling of references and exceptions is similar to Harper's account of polymorphic references [Har93]. Elaboration. <p> The presentation is strongly influenced by the work of Plotkin [Plo81] and Wright and Felleisen <ref> [WF91] </ref>, and is a significant departure from the framework employed in The Definition. In particular we employ a small step semantics in which transitions represent basic evaluation steps of an abstract machine. We rely on substitution, rather than environments; values are particular expressions of the language. <p> with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions [Tof90]. (An essentially similar observation was made by Wright and Felleisen <ref> [WF91] </ref>.) Fix a base type ans of answers to which a complete, closed program might evaluate. 2 We can say that a machine state is well-formed, written ` (; ; E; phrase); if and only if ` b E [phrase] : ans, phrase is closed, and ` .
References-found: 17

