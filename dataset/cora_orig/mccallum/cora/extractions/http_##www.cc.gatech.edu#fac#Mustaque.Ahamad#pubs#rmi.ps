URL: http://www.cc.gatech.edu/fac/Mustaque.Ahamad/pubs/rmi.ps
Refering-URL: http://www.cs.gatech.edu/fac/Mustaque.Ahamad/pubs.html
Root-URL: 
Title: Efficient Implementations of Java Remote Method Invocation (RMI)  
Author: Vijaykumar Krishnaswamy Dan Walther Sumeer Bhola Ethendranath Bommaiah George Riley Brad Topol Mustaque Ahamad 
Keyword: Distributed Objects, Remote Method Invocation, Caching, Multicast.  
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Java and the Remote Method Invocation (RMI) mechanism supported by it make it easy to build distributed applications and services in a heterogeneous environment. When the applications are interactive and require low response time, efficient implementations of RMI are needed. We explore both transport level protocols as well as object caching in the RMI framework to meet the performance requirements of interactive applications. We have developed a prototype system that offers new transport protocols and allows objects to be cached at client nodes. We describe the design issues and the implementation choices made in the prototype along with some preliminary performance results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multi-cast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: Communication protocols that exploit the request-response nature of communication in distributed applications include T-TCP [3], VMTP [4] and others. Reliable multicast communication has been studied extensively (Isis and related systems <ref> [1] </ref>, SRM [6], RMTP [15], Log-based [7] and others). Our multicast protocol is designed specifically to meet the needs of object consistency protocols.
Reference: [2] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Trans. on Comp. Sys., </journal> <month> February </month> <year> 1984. </year>
Reference-contexts: For example, the "invocation-response" nature of RMI can be exploited to develop a more efficient communication protocol than TCP (such an approach was used in the implementation of remote procedure call or RPC <ref> [2] </ref> which is closely related to RMI). Furthermore, when possible, a client may be able to cache the state of remote objects and invoke them locally. In this case, the overhead associated with communication can be avoided when there is significant locality of access. <p> Given this, any explicit acknowledgments used by TCP for requests can be avoided in a reliable protocol that is aware of the structure of RMI communication. A similar argument was used in the implementation of remote procedure calls by Birrell and Nelson in <ref> [2] </ref>.
Reference: [3] <author> R. Braden "RFC1644: </author> <title> T/TCP - TCP Extensions for Transactions Functional Specification" July 1994 </title>
Reference-contexts: Communication protocols that exploit the request-response nature of communication in distributed applications include T-TCP <ref> [3] </ref>, VMTP [4] and others. Reliable multicast communication has been studied extensively (Isis and related systems [1], SRM [6], RMTP [15], Log-based [7] and others). Our multicast protocol is designed specifically to meet the needs of object consistency protocols.
Reference: [4] <author> D. R. Cheriton, VMTP: </author> <title> A Transport Protocol for the Next Generation of Communication Systems Proc. </title> <booktitle> SIGcomm, </booktitle> <pages> pp. 406-415, </pages> <year> 1986. </year>
Reference-contexts: Communication protocols that exploit the request-response nature of communication in distributed applications include T-TCP [3], VMTP <ref> [4] </ref> and others. Reliable multicast communication has been studied extensively (Isis and related systems [1], SRM [6], RMTP [15], Log-based [7] and others). Our multicast protocol is designed specifically to meet the needs of object consistency protocols.
Reference: [5] <author> Michael Condict, Dejan Milojicic, </author> <title> Franklin Reynolds and Don Bolinger.Towards a worldwide civilization of objects. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 25-32, </pages> <address> Connemara, Ireland, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Also, Flex did not explore transport level support for fast remote invocations. Object replication and caching in Java independent of the RMI mechanism have been explored in systems such as TIE <ref> [5] </ref> and Mocha [16]. By incorporating 15 caching in the RMI framework, we ensure that applications do not need to differently deal with cached and non-cached objects.
Reference: [6] <author> Floyd, S., Jacobson, V., Liu, C., McCanne, S., and Zhang, L., </author> <title> A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing. </title> <booktitle> ACM SIGCOMM 95, </booktitle> <month> August </month> <year> 1995, </year> <pages> pp. 342-356. 16 </pages>
Reference-contexts: We have implemented a reliable multicast framework along the lines of SRM <ref> [6] </ref>, with a few novel changes. Like SRM, we use application data unit framing, negative acknowledgments, 6 and multicast the retransmit request and response messages on the whole group. <p> Communication protocols that exploit the request-response nature of communication in distributed applications include T-TCP [3], VMTP [4] and others. Reliable multicast communication has been studied extensively (Isis and related systems [1], SRM <ref> [6] </ref>, RMTP [15], Log-based [7] and others). Our multicast protocol is designed specifically to meet the needs of object consistency protocols. As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete).
Reference: [7] <author> H.W. Holbrook, S.K. Singhal, and D.R. Cheriton. </author> <title> Log-based Receiver-Reliable Multicast for Distributed Interactive Simulation. </title> <booktitle> In Proceedings of SIGCOMM '95 , Cambridge, </booktitle> <address> MA, August,1995. </address> <publisher> ACM SIGCOMM. </publisher>
Reference-contexts: Communication protocols that exploit the request-response nature of communication in distributed applications include T-TCP [3], VMTP [4] and others. Reliable multicast communication has been studied extensively (Isis and related systems [1], SRM [6], RMTP [15], Log-based <ref> [7] </ref> and others). Our multicast protocol is designed specifically to meet the needs of object consistency protocols. As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete).
Reference: [8] <institution> Java Remote Method Invocation Documentation, </institution> <note> http://java.sun.com/products/jdk/1.1/docs/guide/rmi/spec/rmiTOC.doc.html </note>
Reference-contexts: Some preliminary performance studies of object caching are also reported in this section. A discussion of the prototype and performance studies is presented in Section 5. We describe related work and conclude the paper in Sections 6 and 7. 2 The Java RMI Framework The RMI framework <ref> [8] </ref> in Java allows distributed application components to communicate via remote object invocations. In particular, a client running at one node can access a remote service by invoking a method of the object that implements the service.
Reference: [9] <author> A. D. Joseph, A. F. de Lespinasse, J. A. Tauber, D. K. Gifford, and M. F. Kaashoek. </author> <title> Rover: A toolkit for mobile information access. </title> <booktitle> In Proc. of 15th SOSP, </booktitle> <year> 1995. </year>
Reference-contexts: As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete). Object caching has been studied in systems such as Spring [14], Flex [10], Thor [13], Rover <ref> [9] </ref> and others. The Spring distributed operating system presented a generic architecture for object caching. There are several differences in the approaches taken by Spring and by us due to differences in the system environments.
Reference: [10] <author> R. Kordale, M. Ahamad and M. Devarakonda. </author> <title> Object Caching in a CORBA Compliant System. </title> <journal> Usenix Systems Journal, </journal> <year> 1996. </year>
Reference-contexts: As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete). Object caching has been studied in systems such as Spring [14], Flex <ref> [10] </ref>, Thor [13], Rover [9] and others. The Spring distributed operating system presented a generic architecture for object caching. There are several differences in the approaches taken by Spring and by us due to differences in the system environments. <p> For example, in distributed file systems and distributed shared memories, a number of protocols have been developed. In our future work, we will explore different consistency levels and consistency protocols by developing a consistency framework similar to the one developed in Flex <ref> [10] </ref>. 7 Concluding Remarks Interactive distributed applications programmed with Java can run on wide range of platforms. However, the interactive response time needs of such applications in high communication latency environments require efficient support for communication across sites.
Reference: [11] <author> S. Kasera, J. Kurose, and D. Towsley. </author> <title> Scalable reliable multicast using multiple multicast groups. </title> <booktitle> Proc. of 1997 ACM Sigmetrics, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: One of the main disadvantages of this scheme is that every member is required to participate in servicing retransmission requests. We propose to provide an option to permit the usage of a separate group address for multicasting retransmission requests and responses <ref> [11] </ref>. To quantify the performance gains of using multicast as against unicast to implement one-to-many communication (e.g., as used by an invalidation protocol that is discussed in the next section), we have obtained measurements comparing the two mechanisms.
Reference: [12] <author> K. Li, and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM trans. on Comp. Sys., </journal> <month> Nov </month> <year> 1989. </year>
Reference-contexts: We chose a straightforward protocol for maintaining the consistency of cached objects (similar to one used in the Ivy system for maintainingg coherence of distributed shared memory page <ref> [12] </ref>). Considerable work has been done in the area of object consistency and consistency protocols. For example, in distributed file systems and distributed shared memories, a number of protocols have been developed.
Reference: [13] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber., U. Maheshwari and L. Shrira. </author> <title> Safe and Efficient Sharing of Persistent Objects in Thor. </title> <booktitle> ACM SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete). Object caching has been studied in systems such as Spring [14], Flex [10], Thor <ref> [13] </ref>, Rover [9] and others. The Spring distributed operating system presented a generic architecture for object caching. There are several differences in the approaches taken by Spring and by us due to differences in the system environments.
Reference: [14] <author> Michael N. Nelson, Graham Hamilton, and Yousef A. Khalidi. </author> <title> A Framework for Caching in an Object-Oriented System. </title> <institution> Sun Microsystems Laboratories Technical Report SMLI-TR-93-19. </institution>
Reference-contexts: As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete). Object caching has been studied in systems such as Spring <ref> [14] </ref>, Flex [10], Thor [13], Rover [9] and others. The Spring distributed operating system presented a generic architecture for object caching. There are several differences in the approaches taken by Spring and by us due to differences in the system environments.
Reference: [15] <author> S. Paul, K. K. Sabnani, J. C. Lin, </author> <title> S.Bhattacharyya. </title> <journal> Reliable Multicast Transport Protocol IEEE Journal on Selected Areas in Communications, </journal> <volume> Vol. 15, No. </volume> <month> 3,April </month> <year> 1997, </year> <pages> Pages 407-421. </pages>
Reference-contexts: Communication protocols that exploit the request-response nature of communication in distributed applications include T-TCP [3], VMTP [4] and others. Reliable multicast communication has been studied extensively (Isis and related systems [1], SRM [6], RMTP <ref> [15] </ref>, Log-based [7] and others). Our multicast protocol is designed specifically to meet the needs of object consistency protocols. As a result, it can offer optimizations that are not possible in generic protocols (e.g., messages with newer values of an object make messages containing overwritten values obsolete).
Reference: [16] <author> Topol, Brad and Ahamad, Mustaque and Stasko, John T., </author> " <title> Robust State Sharing for Wide Area Distributed Applications ," Technical Report GIT-CC-97-25, </title> <month> September </month> <year> 1997. </year>
Reference-contexts: Also, Flex did not explore transport level support for fast remote invocations. Object replication and caching in Java independent of the RMI mechanism have been explored in systems such as TIE [5] and Mocha <ref> [16] </ref>. By incorporating 15 caching in the RMI framework, we ensure that applications do not need to differently deal with cached and non-cached objects.
Reference: [17] <author> Ann Wollrath, Roger Riggs , Jim Waldo. </author> <title> A Distributed Object Model for Java System.Proceedings of the USENIX COOTS 1996. </title> <type> 17 </type>
Reference-contexts: The Java language is a popular foundation for building distributed services and applications because it hides the problems that arise due to heterogeneity of server and client hardware and software platforms. Remote Method Invocation (RMI) is Java's mechanism for supporting distributed object based computing <ref> [17] </ref>. RMI allows client/server based distributed applications to be developed easily because a client application running in a Java virtual machine at one node can invoke objects implemented by a remote Java virtual machine (e.g., a remote service) the same way as local objects.
References-found: 17

