URL: ftp://ftp.cs.rochester.edu/pub/papers/theory/94.tr519.On_serializable_languages.ps.Z
Refering-URL: http://www.cs.rochester.edu/u/ogihara/mitsuhome.html
Root-URL: 
Title: On Serializable Languages  
Author: Mitsunori Ogihara 
Address: Rochester, NY 14627  
Affiliation: Department of Computer Science University of Rochester  
Abstract: Technical Report 519 June, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [Bar89] <author> D. Barrington. </author> <title> Bounded-width polynomial-size branching programs recognize exactly those languages in NC 1 . Journal of Computer and System Science, </title> <booktitle> 38 </booktitle> <pages> 150-164, </pages> <year> 1989. </year>
Reference-contexts: Let H = h m ffi ffi h 1 , where the multiplication is from right to left. We say that the program accepts the input if the resulting mapping H fixes 1 (maps 1 to 1). Recently, Barrington <ref> [Bar89] </ref> has shown that a language belongs to NC 1 if and only if it is recognized by a width-5 polynomial-length branching programs. <p> Obviously, SF k PSPACE for any k. By following Barrington's construction <ref> [Bar89] </ref>, Cai and Furst [CF91] showed that PSPACE SF 5 . 1 An immediate question follows from this result is whether the inclusion holds for SF k with k 4. <p> Thus, L 2 P==OptP. This proves the theorem. 2 4 Computational Power of Width-3 Bottleneck Turing Ma chines Barrington <ref> [Bar89, Theorem 6] </ref> showed that languages recognized by polynomial-length branching programs over S 3 are AC 0 -reducible to the MOD (6) functions. Based on the analysis, we obtain the following result. Theorem 4.1 perm-SF 3 = 3 P. <p> So, fi h [x; r (jxj) ](1) = 2 if x 2 A and 1 otherwise. Thus, L 2 perm-SF 3 . The proof for the other direction is similar to that of <ref> [Bar89, Theorem 6] </ref>. Let L 2 perm-SF 3 via a polynomial p and f 2 PF such that for every x 2 fl , x 2 L $ fi f [x; p (jxj) ](1) = 1: Let a = (1 2) and b = (2 3).
Reference: [BGH90] <author> R. Beigel, J. Gill, and U. Hertrampf. </author> <title> Counting classes: Thresholds, parity, </title> <booktitle> mods, and fewness. In Proceedings of the 7th Symposium on Theoretical Aspects of Computer Science. Springer-Verlag Lecture Notes in Computer Science #415, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: The following properties are well-known. Proposition 2.1 1. [PZ83] P (P) = P (P) = P = P. 2. <ref> [BGH90] </ref> 3 P ( 3 P) = P ( 3 P) = 3 P = 3 P. 3. [BGH90] For every L 2 3 P, L 2 3 P is witnessed by a polynomial p and A 2 P such that for every x, k fy 2 p (jxj) j xy <p> The following properties are well-known. Proposition 2.1 1. [PZ83] P (P) = P (P) = P = P. 2. <ref> [BGH90] </ref> 3 P ( 3 P) = P ( 3 P) = 3 P = 3 P. 3. [BGH90] For every L 2 3 P, L 2 3 P is witnessed by a polynomial p and A 2 P such that for every x, k fy 2 p (jxj) j xy 2 Ag k 0; 1 (mod 3). 4. [TO92] P (PH) BPP (P) and 3 P (PH) BPP
Reference: [BT88] <author> D. A. Mix Barrington and D. Therien. </author> <title> Finite monoids and the fine structure of N C 1 . Journal of the Association for Computing Machinery, </title> <booktitle> 35(4) </booktitle> <pages> 941-95, </pages> <month> October </month> <year> 1988. </year> <month> 15 </month>
Reference-contexts: Recently, Barrington [Bar89] has shown that a language belongs to NC 1 if and only if it is recognized by a width-5 polynomial-length branching programs. Regarding complexity of languages recognized by polynomial-size branching programs with fewer width, Barring-ton and Therien <ref> [BT88] </ref> have shown that they belong to ACC (6), the class of languages recognized by constant depth, polynomial-size, unbounded fan-in circuits with MOD (6). Motivated by Barrington's innovating result, Cai and Furst [CF87, CF91] introduced the notion of bottleneck Turing machines. <p> Obviously, SF k PSPACE for any k. By following Barrington's construction [Bar89], Cai and Furst [CF91] showed that PSPACE SF 5 . 1 An immediate question follows from this result is whether the inclusion holds for SF k with k 4. Barrington and Therien's <ref> [BT88] </ref> observation that branching programs over finite solvable monoids capture only languages in ACC suggests that SF 4 is contained in the counting polynomial-time hierarchy [Wag86, Tor91] CH = k PP PP k . In fact, we locate the class in a finite level of the hierarchy.
Reference: [CF87] <author> J. Cai and M. Furst. </author> <title> PSPACE survives three-bit bottlenecks. </title> <booktitle> In Proceedings of the 2nd Conference on Structure in Complexity Theory, </booktitle> <pages> pages 94-102. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: Regarding complexity of languages recognized by polynomial-size branching programs with fewer width, Barring-ton and Therien [BT88] have shown that they belong to ACC (6), the class of languages recognized by constant depth, polynomial-size, unbounded fan-in circuits with MOD (6). Motivated by Barrington's innovating result, Cai and Furst <ref> [CF87, CF91] </ref> introduced the notion of bottleneck Turing machines. <p> We call 1 We note here that the range of safe-storages for width-k bottleneck TMs has been changed to [0; k] in [CF91]. Consequently, the class SF k+1 in <ref> [CF87] </ref> is represented as SF k in [CF91]. In this paper, we employ the notation in [CF87]. 2 such a machine a shrink bottleneck Turing machine and by shr -SF k denote the class of all languages recognized by width-k shrink bottleneck Turing machines. <p> We call 1 We note here that the range of safe-storages for width-k bottleneck TMs has been changed to [0; k] in [CF91]. Consequently, the class SF k+1 in <ref> [CF87] </ref> is represented as SF k in [CF91]. In this paper, we employ the notation in [CF87]. 2 such a machine a shrink bottleneck Turing machine and by shr -SF k denote the class of all languages recognized by width-k shrink bottleneck Turing machines.
Reference: [CF91] <author> J. Cai and M. Furst. </author> <title> PSPACE survives constant-width bottlenecks. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 2(1) </volume> <pages> 67-76, </pages> <year> 1991. </year>
Reference-contexts: Regarding complexity of languages recognized by polynomial-size branching programs with fewer width, Barring-ton and Therien [BT88] have shown that they belong to ACC (6), the class of languages recognized by constant depth, polynomial-size, unbounded fan-in circuits with MOD (6). Motivated by Barrington's innovating result, Cai and Furst <ref> [CF87, CF91] </ref> introduced the notion of bottleneck Turing machines. <p> Obviously, SF k PSPACE for any k. By following Barrington's construction [Bar89], Cai and Furst <ref> [CF91] </ref> showed that PSPACE SF 5 . 1 An immediate question follows from this result is whether the inclusion holds for SF k with k 4. <p> Consider a bottleneck Turing machine whose associate function has range R k [ fI k g, where I k is the identity. We call 1 We note here that the range of safe-storages for width-k bottleneck TMs has been changed to [0; k] in <ref> [CF91] </ref>. Consequently, the class SF k+1 in [CF87] is represented as SF k in [CF91]. <p> We call 1 We note here that the range of safe-storages for width-k bottleneck TMs has been changed to [0; k] in <ref> [CF91] </ref>. Consequently, the class SF k+1 in [CF87] is represented as SF k in [CF91]. In this paper, we employ the notation in [CF87]. 2 such a machine a shrink bottleneck Turing machine and by shr -SF k denote the class of all languages recognized by width-k shrink bottleneck Turing machines. <p> Hemachandra and Hoene [HH91] showed that the p m -closure of the nearly near-testable sets coincides with P==OptP. The former characterization| p 2 = perm-SF 2 |strengthens the result by Cai and Furst <ref> [CF91] </ref> that the Boolean hierarchy over NP is in SF 2 . The p 2 = shr -SF 2 result leads us to a question about the smallest width for bottleneck Turing machines to capture levels of the polynomial-time hierarchy.
Reference: [CGH + 88] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wag-ner, and G. Wechsung. </author> <title> The boolean hierarchy I: Structural properties. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1232-1252, </pages> <year> 1988. </year>
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference-contexts: Cai and Furst's result PSPACE = perm-SF 5 = SF 5 leads us to a question of whether SF k = perm-SF k for k &lt; 5. We give a complete characterization of languages in perm-SF k , k 4, in terms of MOD k P <ref> [CH90] </ref> classes; that is, perm-SF 2 = P, perm-SF 3 = 3 P P , and perm-SF 4 = P 3 P P (for the definition of these classes, see Section 2). <p> We assume the reader's familiarith with basic notions from complexity theory. 2.1 Complexity Classes We define the complexity classes we will be concerned with. For k 2, MOD k P <ref> [CH90] </ref> is the class of languages L for which there exists a polynomial time-bounded nondeterministic Turing machine M such that for every x, it holds that x 2 L if and only if the number of accepting computation paths of M on x is not a multiple of k.
Reference: [GP86] <author> L. Goldschlager and I. Parberry. </author> <title> On the construction of parallel computers from various bases of boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 43-58, </pages> <year> 1986. </year>
Reference-contexts: Especially, MOD 2 P is denoted by P <ref> [GP86, PZ83] </ref>. We will also be specially interested in MOD 3 P. Purely as a convention, we will be using 3 P to denote MOD 3 P throughout this paper.
Reference: [HH91] <author> L. Hemachandra and A. Hoene. </author> <title> On sets with efficient implicit membership tests. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(6) </volume> <pages> 1148-156, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: The latter result is interesting in the light of self-reducible structure of sets|the nearly near-testable sets <ref> [HH91] </ref>. A language A is nearly near-testable [HH91] if there exists a polynomial-time algorithm that, given x, either outputs the membership of x or outputs the parity of A (x) and A (x ), where x is the predecessor of x. Hemachandra and Hoene [HH91] showed that the p m -closure <p> The latter result is interesting in the light of self-reducible structure of sets|the nearly near-testable sets <ref> [HH91] </ref>. A language A is nearly near-testable [HH91] if there exists a polynomial-time algorithm that, given x, either outputs the membership of x or outputs the parity of A (x) and A (x ), where x is the predecessor of x. Hemachandra and Hoene [HH91] showed that the p m -closure of the nearly near-testable sets coincides with <p> structure of sets|the nearly near-testable sets <ref> [HH91] </ref>. A language A is nearly near-testable [HH91] if there exists a polynomial-time algorithm that, given x, either outputs the membership of x or outputs the parity of A (x) and A (x ), where x is the predecessor of x. Hemachandra and Hoene [HH91] showed that the p m -closure of the nearly near-testable sets coincides with P==OptP. The former characterization| p 2 = perm-SF 2 |strengthens the result by Cai and Furst [CF91] that the Boolean hierarchy over NP is in SF 2 .
Reference: [KL80] <author> R. Karp and R. Lipton. </author> <title> Some connections between nonuniform and uniform complexity classes. </title> <booktitle> In Proceedings of the 12th Symposium on Theory of Computing, </booktitle> <pages> pages 302-309. </pages> <publisher> ACM Press, </publisher> <year> 1980. </year>
Reference-contexts: Proof The first part follows from Lemma 2.8 and Theorems 5.2 and 5.3 via Proposition 2.1. The second part follows from Lemma 2.7 and Theorem 5.3. 2 For a class of sets C, C=poly <ref> [KL80] </ref> is the class of sets L for which there exist a set A 2 C and a function h : fl ! fl such that for all x, it holds that x 2 L $ xh (0 jxj ) 2 A.
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> Journal of Computer and System Science, </journal> <volume> 36 </volume> <pages> 490-509, </pages> <year> 1988. </year>
Reference-contexts: It is well-known for every k 1, that p p p p OptP <ref> [Kre88] </ref> is the class of functions f for which there exist a polynomial p and a set A 2 P such that for all x, it holds that f (x) = maxfy 2 p (jxj) j xy 2 Ag if such a y exists and 0 p (jxj) otherwise.
Reference: [KT94] <author> J. Kobler and T. Thierauf. </author> <title> Complexity-restricted advise functions. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(2) </volume> <pages> 261-275, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: We also show complete characterizations of width-2 classes; that is, shr -SF 2 = p and SF 2 = P==OptP, where P==OptP is the class of languages recognized by a P-language with some input-dependent advice from an OptP-function <ref> [KT94] </ref>. The latter result is interesting in the light of self-reducible structure of sets|the nearly near-testable sets [HH91]. <p> For a class of languages C, C==OptP <ref> [KT94] </ref> is the class of sets L for which there a set A 2 C and a function f 2 OptP such that for all x, it holds that x 2 L $ xh (x) 2 A: 2.2 Basic Properties of SF-classes For k 2, let [k] denote f1; ; kg.
Reference: [Lau83] <author> C. Lautemann. </author> <title> BPP and the polynomial hierarchy. </title> <journal> Information Processing Letters, </journal> <volume> 17 </volume> <pages> 215-217, </pages> <year> 1983. </year>
Reference: [PZ83] <author> C. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proceedings of the 6th GI Conference on Theoretical Computer Science, </booktitle> <pages> pages 269-276. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #145, 1983. 16 </note>
Reference-contexts: Especially, MOD 2 P is denoted by P <ref> [GP86, PZ83] </ref>. We will also be specially interested in MOD 3 P. Purely as a convention, we will be using 3 P to denote MOD 3 P throughout this paper. <p> The following properties are well-known. Proposition 2.1 1. <ref> [PZ83] </ref> P (P) = P (P) = P = P. 2. [BGH90] 3 P ( 3 P) = P ( 3 P) = 3 P = 3 P. 3. [BGH90] For every L 2 3 P, L 2 3 P is witnessed by a polynomial p and A 2 P such
Reference: [Sch87] <author> U. Schoning. </author> <title> Probabilistic complexity classes and lowness. </title> <booktitle> In Proceedings of the 2nd Conference on Structure in Complexity Theory, </booktitle> <pages> pages 2-8. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: It is well-known <ref> [Sch87] </ref> for any class C closed under p pos -reductions [Sel82], that BPP (C) P=poly. The complexity bounds we have obtained for SF-classes allow us to obtain the following classification in the light of polynomially length bounded advice.
Reference: [Sel82] <author> A. Selman. </author> <title> Reductions on NP and P-selective sets. </title> <journal> Theoretical Computer Science, </journal> <volume> 19 </volume> <pages> 287-304, </pages> <year> 1982. </year>
Reference-contexts: It is well-known [Sch87] for any class C closed under p pos -reductions <ref> [Sel82] </ref>, that BPP (C) P=poly. The complexity bounds we have obtained for SF-classes allow us to obtain the following classification in the light of polynomially length bounded advice.
Reference: [Sip83] <author> M. Sipser. </author> <title> A complexity theoretic approach to randomness. </title> <booktitle> In Proceedings of the 15th Symposium on Theory of Computing, </booktitle> <pages> pages 330-335. </pages> <publisher> ACM Press, </publisher> <year> 1983. </year>
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: 3 P) = 3 P = 3 P. 3. [BGH90] For every L 2 3 P, L 2 3 P is witnessed by a polynomial p and A 2 P such that for every x, k fy 2 p (jxj) j xy 2 Ag k 0; 1 (mod 3). 4. <ref> [TO92] </ref> P (PH) BPP (P) and 3 P (PH) BPP ( 3 P). p T p For a class C, define 9 C (8 C) to be the class of languages L for which there exist a polynomial p and a language A 2 C such that for every x, x
Reference: [Tor91] <author> J. Toran. </author> <title> Complexity classes defined by counting quantifiers. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 38(3) </volume> <pages> 753-774, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Barrington and Therien's [BT88] observation that branching programs over finite solvable monoids capture only languages in ACC suggests that SF 4 is contained in the counting polynomial-time hierarchy <ref> [Wag86, Tor91] </ref> CH = k PP PP k . In fact, we locate the class in a finite level of the hierarchy. Hence, we cannot hope PSPACE = SF 4 unless PSPACE collapses to a finite level of the counting polynomial-time hierarchy.
Reference: [Wag86] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year> <month> 17 </month>
Reference-contexts: Barrington and Therien's [BT88] observation that branching programs over finite solvable monoids capture only languages in ACC suggests that SF 4 is contained in the counting polynomial-time hierarchy <ref> [Wag86, Tor91] </ref> CH = k PP PP k . In fact, we locate the class in a finite level of the hierarchy. Hence, we cannot hope PSPACE = SF 4 unless PSPACE collapses to a finite level of the counting polynomial-time hierarchy.
References-found: 20

