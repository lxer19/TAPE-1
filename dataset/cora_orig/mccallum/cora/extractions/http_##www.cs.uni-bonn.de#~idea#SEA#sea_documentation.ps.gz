URL: http://www.cs.uni-bonn.de/~idea/SEA/sea_documentation.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/~idea/SEA/publications.html
Root-URL: http://cs.uni-bonn.de
Title: Intelligent Database Environment for Advanced Applications IDEA The Schema Evolution Assistant: Tool Documentation  
Author: Rainer Manthey 
Note: ESPRIT Project 6333 Page 1  
Pubnum: 16.12.1996 IDEA.DE.22.O.008  
Abstract-found: 0
Intro-found: 1
Reference: [CM93] <author> Stefano Ceri and Rainer Manthey. </author> <title> Consolidated specification of Chimera. </title> <booktitle> IDEA deliverable IDEA.DE.2P.006.001, ESPRIT Project 6333, </booktitle> <year> 1993. </year>
Reference-contexts: The Interpreter supports most of the features of Chimera but does not aim at providing particularly efficient or refined implementations of individual concepts. There are a few points where the implemented version of Chimera deviates from the version specified in <ref> [CM93] </ref>. Apart from these points, the functionality of Chimera has been enhanced by low-level schema evolution operations for the Chimera Interpreter programming interface in order to enable basic changes of an application schema. <p> This conforms with the editing style in the Graphical User Interface where implementations are the only parts which have to be typed in the original Chimera syntax as specified in <ref> [CM93] </ref>.
Reference: [Dau96] <author> Ulrich Daugs. </author> <title> Entwurf und Implementierung einer grafischen Oberflache zur Verwaltung objektorientierter Datenbank-Schemata. </title> <type> Diploma thesis, </type> <institution> University of Bonn, Germany, </institution> <year> 1996. </year>
Reference-contexts: Whereas the CPT/GUI itself has already been described in [GLM96], the following sec ESPRIT Project 6333 Page 13 Intelligent Database Environment for Advanced Applications IDEA tion discusses the schema evolution specific preprocessing done by the CPT/GUI. The CPT/GUI is entirely described in-depth in <ref> [Dau96] </ref>. On user demand, the CPT/GUI passes changes of the current schema over to the SEA, using an abstract language described in section 4.2.
Reference: [ECL93] <author> ECRC, </author> <title> Munchen. ECL i PS e User Manual, </title> <year> 1993. </year>
Reference-contexts: is started again, the user can decide whether to work with the unchanged database, or whether to continue his work on the modified schema. 4.2 Passing Schema Changes to the SEA While the GUI is implemented in Tcl/Tk [Ous94], the SEA control is realized in ECL i PS e Prolog <ref> [ECL93] </ref>. It can thus not easily access the data structures of the GUI, making it necessary to explicitly pass schema changes to the SEA control.
Reference: [GL96] <author> Ulrike Griefahn and Thomas Lemke. </author> <title> Implementing Chimera on top of an active relational database system. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.007, ESPRIT Project 6333, </booktitle> <year> 1996. </year>
Reference-contexts: This became necessary as our tools heavily rely on the ability of such a DBMS to support both, deductive and active rules within a uniform environment. Our Chimera Interpreter <ref> [GLM96, GL96] </ref> compiles Chimera commands into operations which the underlying relational system | called Phoenix [Gri95] | is able to interpret. Phoenix has been implemented on top of Eclipse, but may be run in main-memory mode (i.e., without persistent data structures) by most conventional Prolog systems as well. <p> The Chimera Prototyping Tool, for example, compiles each functional attribute access class (X), X.attribute = 25 into an access to an (n+1)-ary relation class (X, A 1 , ..., 25, ..., A n ), where n is the number of extensional attributes of the class <ref> [GL96] </ref>. If one attribute is removed from the class, the arity of the base relation changes, and all accesses have to be recompiled. These effects however are implementation specific and are not logically implied from within a data model as the consequences on schema, instances, and applications. <p> For the SEA developed at the University of Bonn, the relevant Chimera DBMS is the Chimera Prototyping Tool (CPT) <ref> [GLM96, GL96] </ref>, also realized at Bonn. The sequel of this documentation focuses on the design of a Schema Evolution Assistant in this environment. 4 THE SEA GRAPHICAL USER INTERFACE The Graphical User Interface of the Schema Evolution Assistant is split over several components. <p> ESPRIT Project 6333 Page 17 Intelligent Database Environment for Advanced Applications IDEA The implementation of the CPT/CI is described in-depth in <ref> [GL96] </ref>. After a Chimera schema has been defined via the CPT/GUI, it is stored in the CPT's data dictionary, the CDB 1 . Afterwards, the schema is mapped onto a relational database schema. <p> Giving an example, if the name of an attribute is changed for an object class, the corresponding access and inheritance rules for this attribute have to be changed for the class itself and all its subclasses (see <ref> [GL96] </ref> for details of the implementation mapping). Note that these interdependencies are not strategy dependent but have to be considered anyway in order to avoid low-level runtime errors: the consistency of the implementation of a Chimera schema itself should, in our opinion, not be the subject of user decisions.
Reference: [GLM96] <author> Ulrike Griefahn, Thomas Lemke, and Rainer Manthey. </author> <title> CPT user manual. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.006, ESPRIT Project 6333, </booktitle> <year> 1996. </year>
Reference-contexts: This became necessary as our tools heavily rely on the ability of such a DBMS to support both, deductive and active rules within a uniform environment. Our Chimera Interpreter <ref> [GLM96, GL96] </ref> compiles Chimera commands into operations which the underlying relational system | called Phoenix [Gri95] | is able to interpret. Phoenix has been implemented on top of Eclipse, but may be run in main-memory mode (i.e., without persistent data structures) by most conventional Prolog systems as well. <p> A complete description of the SEA/GUI is not included in this document because it is to a large account identical with the GUI of the underlying DBMS (CPT/GUI) which has already been described in <ref> [GLM96] </ref>. Chapter 5 then presents the CPT Schema Evolution Extension, a component which encapsulates routines for mapping changes of a Chimera schema onto the CPT data dictionary and the Phoenix implementation of that schema. <p> For the SEA developed at the University of Bonn, the relevant Chimera DBMS is the Chimera Prototyping Tool (CPT) <ref> [GLM96, GL96] </ref>, also realized at Bonn. The sequel of this documentation focuses on the design of a Schema Evolution Assistant in this environment. 4 THE SEA GRAPHICAL USER INTERFACE The Graphical User Interface of the Schema Evolution Assistant is split over several components. <p> Due to its tight integration into the Graphical User Interface of the Chimera Prototyping Tool, the CPT/GUI, parts of the SEA/GUI are realized within the CPT/GUI, providing the same interface for schema design and schema evolution. Whereas the CPT/GUI itself has already been described in <ref> [GLM96] </ref>, the following sec ESPRIT Project 6333 Page 13 Intelligent Database Environment for Advanced Applications IDEA tion discusses the schema evolution specific preprocessing done by the CPT/GUI. The CPT/GUI is entirely described in-depth in [Dau96].
Reference: [Gri95] <author> Ulrike Griefahn. </author> <title> First specification of Phoenix, an active database programming language. </title> <type> Technical Report IAI-TR-95-4, </type> <institution> University of Bonn, Germany, </institution> <year> 1995. </year>
Reference-contexts: This became necessary as our tools heavily rely on the ability of such a DBMS to support both, deductive and active rules within a uniform environment. Our Chimera Interpreter [GLM96, GL96] compiles Chimera commands into operations which the underlying relational system | called Phoenix <ref> [Gri95] </ref> | is able to interpret. Phoenix has been implemented on top of Eclipse, but may be run in main-memory mode (i.e., without persistent data structures) by most conventional Prolog systems as well. <p> Afterwards, the schema is mapped onto a relational database schema. As a base system, we use Phoenix, an active relational system with deductive capabilities implemented in ECL i PS e as well <ref> [Gri95] </ref>. Phoenix of course has its own data dictionary where the Phoenix implementation of a Chimera schema is stored. Phoenix moreover manages the "real" database, containing Phoenix relations and tuples representing Chimera objects (among others).
Reference: [Lem94a] <author> Thomas Lemke. </author> <title> Schema evolution in OODBMS: A selective overview of problems and solutions. IDEA working paper IDEA.WP.22.O.002, ESPRIT Project 6333, </title> <year> 1994. </year>
Reference-contexts: Finally, some strategies for the realization of schema evolution are sketched in chapter 2.3. A more detailed discussion of these topics has already been given in <ref> [Lem94a] </ref>. 2.1 Consistent and Compatible Schemas In order to be valid, a Chimera schema has to be consistent according to its structure (attributes, method signatures, inheritance graph) and the intended behaviour of its instances (method code, trigger code), both in the presence of inheritance. <p> the notion of behavioural consistency at schema level such that no call leads to an undefined method call with respect to method name, and arity and domain of parameters. 2.2 Consequences of Schema Changes The effects of schema modifications on both consistency and compatibility have been discussed in detail in <ref> [Lem94a] </ref>.
Reference: [Lem94b] <author> Thomas Lemke. </author> <title> The Schema Evolution Assistant: Tool specification. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.002, ESPRIT Project 6333, </booktitle> <year> 1994. </year>
Reference-contexts: This decision led to the development of a reflective Schema Evolution Assistant which has already been presented within the IDEA project <ref> [Lem94b, LM95] </ref>. The experience we gained with the construction of a reflective schema evolution component was very positive up to a certain degree. <p> The schema evolution functionality itself has already been introduced and summarized in the SEA specification <ref> [Lem94b] </ref>. <p> Second, only those schema evolution operations rated to be of a high priority in <ref> [Lem94b] </ref> have been realized within the SEA/Plan component. The CPT/GUI, which however supports also minor changes like, e.g., changing parameter names, groups these changes to larger units like, e.g., changing an operation and its implementation, which are then supported by SEA.
Reference: [Lem95] <author> Thomas Lemke. </author> <title> DDL = DML? An exercise in reflective schema management for Chimera. IDEA working paper IDEA.WP.22.O.003, ESPRIT Project 6333, </title> <year> 1995. </year>
Reference-contexts: The chapter closes with a discussion which, among others, explains why the development of the Reflective SEA has been suspended in favour of a non-reflective variant. Please note that the Reflective SEA has already been described in more detail in <ref> [Lem95] </ref> and [LM95]. ESPRIT Project 6333 Page 21 Intelligent Database Environment for Advanced Applications IDEA 6.1 Architecture and SEA Control The architecture of the Reflective SEA has already been discussed in [LM95]. We present here a slightly changed version of that architecture, given in figure 3. <p> Figure 4 sketches the algorithm performed by SEA/Control. 6.2 A Meta Schema for Chimera A meta schema for a subset of Chimera has been motivated and discussed in-depth in <ref> [Lem95] </ref>, a (more or less) complete meta schema for Chimera has been given in the appendix of [LM95]. Here, we want to recall the principle design of such a meta schema by briefly discussing some aspects of the reflective representation of object classes within Chimera. <p> (Type), Type.name = Name -&gt; modify (attribute.domain, Self, Type) ; set_attribute_class (Name): object_class (Class), Class.name = Name -&gt; ESPRIT Project 6333 Page 26 Intelligent Database Environment for Advanced Applications IDEA modify (attribute.class, Self, Class) end; A detailed discussion of the use of such a meta schema can be found in <ref> [Lem95] </ref>, the entire meta schema and an example of a schema evolution performed via the Reflective Schema Manager is given in [LM95]. 6.3 Discussion: Ideal versus Reality The reflective approach to schema management turned out to be very powerful and flexible for realizing advanced schema management tasks without the need of
Reference: [LM95] <author> Thomas Lemke and Rainer Manthey. </author> <title> The Schema Evolution Assistant: Tool description. IDEA working paper IDEA.DE.22.O.004, ESPRIT Project 6333, </title> <year> 1995. </year>
Reference-contexts: This decision led to the development of a reflective Schema Evolution Assistant which has already been presented within the IDEA project <ref> [Lem94b, LM95] </ref>. The experience we gained with the construction of a reflective schema evolution component was very positive up to a certain degree. <p> The chapter closes with a discussion which, among others, explains why the development of the Reflective SEA has been suspended in favour of a non-reflective variant. Please note that the Reflective SEA has already been described in more detail in [Lem95] and <ref> [LM95] </ref>. ESPRIT Project 6333 Page 21 Intelligent Database Environment for Advanced Applications IDEA 6.1 Architecture and SEA Control The architecture of the Reflective SEA has already been discussed in [LM95]. We present here a slightly changed version of that architecture, given in figure 3. <p> Please note that the Reflective SEA has already been described in more detail in [Lem95] and <ref> [LM95] </ref>. ESPRIT Project 6333 Page 21 Intelligent Database Environment for Advanced Applications IDEA 6.1 Architecture and SEA Control The architecture of the Reflective SEA has already been discussed in [LM95]. We present here a slightly changed version of that architecture, given in figure 3. Reflective schema management is handled by the RSM, the Reflective Schema Manager. <p> The coordination between RSM and CPT/SE is done by the SEA/Control. Given a set of schema evolution commands from the CPT/GUI, it first calls the Reflective Schema 3 Note that this component has been called CSME (Chimera Schema Manager Extension) in <ref> [LM95] </ref>. ESPRIT Project 6333 Page 22 Intelligent Database Environment for Advanced Applications IDEA ESPRIT Project 6333 Page 23 Intelligent Database Environment for Advanced Applications IDEA Input: A list SE of schema evolution commands C. Algorithm: 1. <p> Figure 4 sketches the algorithm performed by SEA/Control. 6.2 A Meta Schema for Chimera A meta schema for a subset of Chimera has been motivated and discussed in-depth in [Lem95], a (more or less) complete meta schema for Chimera has been given in the appendix of <ref> [LM95] </ref>. Here, we want to recall the principle design of such a meta schema by briefly discussing some aspects of the reflective representation of object classes within Chimera. <p> Page 26 Intelligent Database Environment for Advanced Applications IDEA modify (attribute.class, Self, Class) end; A detailed discussion of the use of such a meta schema can be found in [Lem95], the entire meta schema and an example of a schema evolution performed via the Reflective Schema Manager is given in <ref> [LM95] </ref>. 6.3 Discussion: Ideal versus Reality The reflective approach to schema management turned out to be very powerful and flexible for realizing advanced schema management tasks without the need of implementing a sophisticated schema management component.
Reference: [Man93] <author> Rainer Manthey. </author> <title> Beyond data dictionaries: Towards a reflective architecture of intelligent database systems. </title> <booktitle> In Deductive Object-Oriented Database Systems (DOOD '93), </booktitle> <year> 1993. </year>
Reference-contexts: The use of such reflective techniques also in the realization of database management systems has been proposed by Manthey <ref> [Man93] </ref>.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <note> ESPRIT Project 6333 Page 37 </note>
Reference-contexts: When the system is started again, the user can decide whether to work with the unchanged database, or whether to continue his work on the modified schema. 4.2 Passing Schema Changes to the SEA While the GUI is implemented in Tcl/Tk <ref> [Ous94] </ref>, the SEA control is realized in ECL i PS e Prolog [ECL93]. It can thus not easily access the data structures of the GUI, making it necessary to explicitly pass schema changes to the SEA control.
References-found: 12

