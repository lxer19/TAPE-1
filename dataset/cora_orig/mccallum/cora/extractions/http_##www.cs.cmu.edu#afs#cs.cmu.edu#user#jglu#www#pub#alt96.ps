URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/jglu/www/pub/alt96.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/jglu/www/ilp.html
Root-URL: 
Title: Inductive Logic Programming Beyond Logical Implication  
Author: Jianguo Lu Jun Arima 
Affiliation: Institute for Social Information Science, Fujitsu Laboratories Ltd. Department of Computer Science, Fudan University  Institute for Social Information Science, Fujitsu Laboratories Ltd.  
Abstract: This paper discusses the generalization of definite Horn programs beyond the ordering of logical implication. Since the seminal paper on generalization of clauses based on subsumption, there are various extensions in this area. Especially in inductive logic programming(ILP), people are using various methods that approximate logical implication, such as inverse resolution(IR), relative least general generalization(RLGG), and inverse implication(II), to generalize clauses. However, the logical implication is not the most desirable form of generalization. A program is more general than another program does not necessarily mean that the former should logically imply the latter. Instead, a more natural notion of generalization is the set inclusion ordering on the success set of logic programs. We observe that this kind of generalization relation is especially useful for inductive synthesis of logic programs. In this paper, we first define an ordering between logic programs which is strictly weaker than the implication ordering. Based on this ordering, we present a set of generalization rules borrowed from unfold/fold program transformation method and ILP. We also give some strategies to apply those rules. 
Abstract-found: 1
Intro-found: 1
Reference: [ALLM] <author> Aha, D. W., Lapointe, S., Ling, C. X., Matwin, S., </author> <title> Learning recursive relations with randomly selected small training sets. </title> <booktitle> In Proceedings of the Eleventh International Machine Learning Conference (pp. </booktitle> <pages> 12-18). </pages> <address> New Brunswick, NJ: </address> <publisher> Morgan Kaufmann. </publisher> <year> 1994. </year> <note> (NCARAI TR: AIC-94-024). </note>
Reference: [Buntine] <author> Wray Buntine, </author> <title> Generalized subsumption and its applications to induction and redundancy, </title> <journal> Artificial Intelligence, </journal> <volume> 36(2) </volume> <pages> 149-176, </pages> <year> 1988. </year>
Reference: [Cypher] <author> Allen Cypher, Ed., </author> <title> Watch What I Do: Programming by Demonstration, </title> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Sometimes it is even easier than the ground fact form 9 . Especially, in the realm of programming by demonstration <ref> [Cypher] </ref>, there are various methods to give traces by providing friendly user interface. * This kind of representation may occur as an intermediate result during the process of saturating the ground facts 10 . Also, it may result from flattening a fact 11 .
Reference: [DM] <author> DeJong, G., Mooney, R., </author> <title> Explanation-based generalization: an alternative view, </title> <journal> Machine Learning, </journal> <volume> 1, </volume> <pages> 145-176, </pages> <year> 1986. </year>
Reference: [FIG] <author> K. Furukawa, M. Imai, and Randy Goebel, </author> <title> Hyper least general generalization and its application to higher-order concept learning, </title> <type> draft. </type>
Reference: [Hagiya] <author> Masami Hagiya, </author> <title> Programming by example and proving by example using higher-order unification, </title> <booktitle> 10th Conference on Automated Deduction (M. </booktitle> <editor> E. Stickel ed.), </editor> <booktitle> Lecture Notes in Artificial Intelligence, </booktitle> <address> Vol.448, </address> <year> 1990, </year> <month> pp.588-602. </month>
Reference-contexts: Due to the fact that expansion (and saturation) may be infinite in general, we may need to use higher-order logic programs [Miller] to represent the result of expansion of recursive programs. Another benefit of using higher order language is that we can describe generalizations in a more formal way <ref> [Hagiya] </ref>. Study of the transformational approach Within the range of this paper, a problem is that it is hard to decide when to stop the unfolding operation. We will investigate more strategies and construct a system to do more experiments.
Reference: [Idestam-Almquist93] <author> Peter Idestam-Almquist, </author> <title> Generalization of Horn clauses, </title> <type> PhD Dissertation, </type> <institution> Department of Computer Science and Systems Science, Stockholm University and the Royal Institute of Technology, </institution> <year> 1993. </year>
Reference: [Idestam-Almquist95] <author> P. Idestam-Almquist, </author> <title> Efficient Induction of Recursive Definitions by Structural Analysis of Saturations, </title> <booktitle> in Proceedings of the Fifth Workshop on Inductive Logic Programming (ILP95), </booktitle> <institution> Department of Computer Science, Katholieke Universiteit Leuven, Belgium, </institution> <year> 1995. </year>
Reference-contexts: For example, for programs P0 and P as below, P0:ancestor (n1,n5):-parent (n1,n2),parent (n2,n3), parent (n3,n4),parent (n4,n5). ancestor (m1,m4):-parent (m1,m2),parent (m2,m3),parent (m3,m4). P: ancestor (X,Y):-parent (X,U),parent (U,V),parent (V,Y). ancestor (X,Y):-parent (X,U),ancestor (U,Y). By using the structure analysis method <ref> [Idestam-Almquist95] </ref>, P can be obtained from P0. By using strategy 3, we can have similar results.
Reference: [LLM] <author> S.Lapointe, C.Ling, S.Matwin, </author> <title> Constructive Inductive Logic Programming, </title> <booktitle> Proceedings of The Third International Workshop on Inductive Logic Programming ILP'93 April 1-3, 1993 Bled, Slovenia. </booktitle> <pages> 255-264. </pages>
Reference-contexts: and multiply are defined in the background theory, then a path structure of the saturation of fac (3,2) could be fac (3; 6) : s (2; 3); s (1; 2); m (3; 2; 6); m (2; 1; 2): This is the same as our form of representation. 11 For instance, <ref> [LLM] </ref> represent the positive factorial example as f actorial (sss0; sss0fl (ss0fl s0)). Its flattened form is similar to our representation.
Reference: [Lloyd] <author> Lloyd, J.W., </author> <title> Foundations of logic programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference: [MB] <author> S. Muggleton and W. Buntine. </author> <title> Machine invention of first-order predicates by inverting resolution. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Inductive Logic Programming, Lon-don, 1992. </booktitle> <publisher> Academic Press. </publisher>
Reference: [M88] <author> Maher, M.J., </author> <title> Equivalence of logic programs, Foundations of Deductive Databases and Logic Programming, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [MF] <author> Muggleton, S., Feng, C., </author> <title> Efficient induction of logic programs. </title> <booktitle> In Proceedings of the First Conference on Algorithmic Learning Theory, </booktitle> <address> Tokyo., 1990. </address> <publisher> Ohmsha. </publisher>
Reference: [MP] <author> Marcinkowski, J., L. Pacholski, </author> <title> Undecidability of the Horn clause implication problem. </title> <booktitle> Proceedings of the 33 Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <address> Pittsburgh, </address> <year> 1992. </year> <pages> 354-362. </pages>
Reference: [MR] <author> Muggleton, S., L. De Raedt. </author> <title> Inductive logic programming: theory and methods. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:629-679, </volume> <year> 1994. </year>
Reference: [Muggleton] <author> Muggleton, S., </author> <title> Inverting the resolution principle. </title> <booktitle> In Machine Intelligence 12. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1991. </year>
Reference: [Miller] <author> Miller, D., </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification, </title> <booktitle> in Proceedings of the international workshop on Extensions of logic programming, Tubingen 1989. </booktitle> <address> LCNS 475. </address>
Reference-contexts: We expect that for a subset of logic programs, this kind of ordering can be reduced to the subsumption ordering by means of function expansion. Due to the fact that expansion (and saturation) may be infinite in general, we may need to use higher-order logic programs <ref> [Miller] </ref> to represent the result of expansion of recursive programs. Another benefit of using higher order language is that we can describe generalizations in a more formal way [Hagiya].
Reference: [Niblett] <author> Niblett, T., </author> <title> A study of generalization in logic programs, </title> <booktitle> In Proceedings of the third European working session on learning, </booktitle> <publisher> Pitman, </publisher> <year> 1988. </year>
Reference: [NMS] <author> Numao, M., T.Maruoka, and M.Shimura, </author> <title> Inductively Speeding Up Logic Programs, </title> <booktitle> Machine Intelligence 13, </booktitle> <publisher> Oxford University Press 1994, </publisher> <pages> pp. 371-385. </pages>
Reference-contexts: Also, it may result from flattening a fact 11 . In this sense, our method presented in this paper is independent on our specific setting. Our work shares some ideas in explanation based learning (EBL)[DM]. Especially, a similar ordering is used in <ref> [NMS] </ref>. In EBL, the basic steps are explanation and generalization, where the explanation is deductive derivations, and share some commonality with the unfolding operation. The difference is that here the unfolding operation has some specific requirements so that the generality is preserved.
Reference: [Plotkin70] <author> Plotkin, G. D., </author> <title> A note on inductive generalization, </title> <booktitle> Machine Intelligence 5, </booktitle> <publisher> Edinburgh University Press 1970, </publisher> <pages> pp. 153-163. </pages>
Reference: [Plotkin71] <author> Plotkin, G.D., </author> <title> A further note on inductive generalization, </title> <booktitle> Machine Intelligence 6, </booktitle> <publisher> Edinburgh University Press 1971, </publisher> <pages> pp. 101-124. </pages>
Reference: [PP] <author> Pettorossi, A., M. Proietti, </author> <title> Transformation of logic programs: foundations and techniques, </title> <journal> J. Logic programming, </journal> <year> 1994, </year> <month> 19(20), </month> <pages> pp. 261-320. </pages>
Reference: [Rouveirol] <author> Rouveirol, C., </author> <title> Flattening and saturation: two representation changes for generalization, </title> <booktitle> Machine learning 14, </booktitle> <pages> pp. 219-232, </pages> <year> 1994. </year>
Reference: [RP] <author> Rouveirol, C., Jean Francois Puget, </author> <title> Beyond inversion of resolution, </title> <editor> in Bruce W. Porter and Ray J. Mooney(eds.) </editor> <booktitle> Machine learning: Proceedings of the seventh international conference on machine learning, 1990. </booktitle> <publisher> Morgan Kaufmann. </publisher> <pages> pp. 122-130. </pages>
Reference-contexts: More generally, their focuses are different: we are studying the generalization between programs, while EBL focus on improving the efficiency of a problem solver. Another work which makes a clause longer before doing generalization is saturation <ref> [RP] </ref>. This approach differs ours in that the result of saturation still logically implies the original clause. This is an initial report on our study on the generalization beyond implication. Further work to be performed can be viewed in the following three aspects.
Reference: [TS] <author> Tamaki, H., Sato, T., </author> <title> Unfold/fold transformation of logic programs, </title> <editor> in: S. A. Tarnlund (ed.), </editor> <booktitle> Proceedings of the 2nd international conference on logic programming, </booktitle> <institution> Uppsala, Sweden, </institution> <year> 1984, </year> <pages> pp. 127-138. </pages>
References-found: 25

