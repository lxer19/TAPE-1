URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/96-039.ps.Z
Refering-URL: http://www.cs.unc.edu/Info/Publications/PHDAbstracts.html
Root-URL: http://www.cs.unc.edu
Title: c  
Author: Subodh Kumar 
Degree: All Rights Reserved  
Abstract-found: 0
Intro-found: 0
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics, </booktitle> <pages> pages 385-397, </pages> <year> 1991. </year>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> At the same time, it is not guaranteed to be crack-free. Overall, our method can render, in real-time, models more than an order of magnitude larger than those by [RHD89]. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in <ref> [FMM86, AES91, AES93] </ref>. Luken et al. [Luk93, LC93] use the standard basis to represent NURBS but generate general polygons. Cracks can appear in their images as well. We defer the discussion of these algorithms until after we have presented our tessellation algorithm. <p> There is considerable literature on computation of such bounds <ref> [LR81, FMM86, Roc87, AES91] </ref>. In particular, Rock-wood et al. [Roc87] and Abi-Ezzi et al. [AES91] use these bounds to compute the sampling size. Suffering from the use of loose bounds, both these methods often over-sample the surface. <p> There is considerable literature on computation of such bounds [LR81, FMM86, Roc87, AES91]. In particular, Rock-wood et al. [Roc87] and Abi-Ezzi et al. <ref> [AES91] </ref> use these bounds to compute the sampling size. Suffering from the use of loose bounds, both these methods often over-sample the surface. <p> Determine bounds on the surface in object space as a pre-processing step. At run time, compute the step size as a function of the pre-computed bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. The first method finds f 3 in one step and all computation must be performed at rendering time. On the other hand, the second method factors f 3 into two, f 1 and f 2 . <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [FMM86, AES93]. An algorithm for computation of bounds based on the size criterion is presented in <ref> [AES91] </ref>. However, the bounds in [AES91] should be modified to use the mean value theorem for vector valued functions, as we show next. In contrast, our method computes the exact extrema (as a part of pre-processing). Hence, for a given , our bounds are tighter. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [FMM86, AES93]. An algorithm for computation of bounds based on the size criterion is presented in <ref> [AES91] </ref>. However, the bounds in [AES91] should be modified to use the mean value theorem for vector valued functions, as we show next. In contrast, our method computes the exact extrema (as a part of pre-processing). Hence, for a given , our bounds are tighter. <p> that (C (t + ffi) C (t)) = ffi (X (t 1 ); Y (t 2 ); Z (t 3 )); where t 1 ; t 2 ; t 3 2 [t; t + ffi]. t 1 ; t 2 and t 3 need not be equal (as assumed in <ref> [AES91] </ref>). <p> Moreover, in order to improve its efficiency, it uses simple algorithms to estimate its bounds (Equation IV.2), which can be rather loose for rational patches. We use the idea of Abi-Ezzi et al. <ref> [AES91] </ref> and decompose the bound computation into an off-line and an on-line algorithm. They evaluate their bounds in object space and map them to screen space. Our screen-space mapping is slightly less complicated, and hence more efficient, but is less general. <p> Our screen-space mapping is slightly less complicated, and hence more efficient, but is less general. We also improve on the tightness of their bounds by spending more time in the off-line component and computing the exact maxima of derivatives using techniques from elimination theory (as discussed in Chapter IV). <ref> [AES91] </ref> uses the standard mean value theorem for its bound computation, which is not applicable to many surfaces. We modify the bound computation (see Chapter IV) so that it is applicable to vector-valued functions, which surface functions are. <p> Color plate A displays the wire-frames and shaded images of the pencil and goblet models computed using the three methods. Since we use tighter bounds, the variation in sizes of our triangle is less than that produced by [RHD89] or <ref> [AES91] </ref> 99 algorithms. Model Number of Our Algorithm [RHD89] Algorithm [AES91] Algorithm Patches # Tris. Ratio # Tris. Ratio # Tris. <p> Since we use tighter bounds, the variation in sizes of our triangle is less than that produced by [RHD89] or <ref> [AES91] </ref> 99 algorithms. Model Number of Our Algorithm [RHD89] Algorithm [AES91] Algorithm Patches # Tris. Ratio # Tris. Ratio # Tris.
Reference: [AES93] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: At the same time, it is not guaranteed to be crack-free. Overall, our method can render, in real-time, models more than an order of magnitude larger than those by [RHD89]. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in <ref> [FMM86, AES91, AES93] </ref>. Luken et al. [Luk93, LC93] use the standard basis to represent NURBS but generate general polygons. Cracks can appear in their images as well. We defer the discussion of these algorithms until after we have presented our tessellation algorithm. <p> We compute improved bounds for the rational surfaces in object space as part of the pre-processing phase. They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [FMM86, AES93] </ref>. An algorithm for computation of bounds based on the size criterion is presented in [AES91]. However, the bounds in [AES91] should be modified to use the mean value theorem for vector valued functions, as we show next.
Reference: [Ake93] <author> K. Akeley. </author> <title> Reality Engine Graphics. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 109-116, </pages> <year> 1993. </year>
Reference-contexts: It is important to be able to visualize these models to speed up their design, prototyping and evaluation. While graphics systems have reached the capability to render millions of transformed, shaded and z-buffered triangles per second <ref> [Fea89, MEP92, Ake93] </ref>, they are not able to render such complex and detailed engineering models. <p> The fifth column corresponds to the speed-up due to visibility computation and the sixth shows the speed-up due to incremental computation. 1.6.2 Pixel-Planes 5 implementation Pixel-Planes 5 [Fea89] uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators <ref> [Ake93] </ref>. Figure 1.11 presents a block diagram of the Pixel-Planes 5 system. Front-end geometry processing, such as transformation and setup for rasterization, is performed on the Graphics Processors (GPs) which contain Intel i860 RISC microprocessors running at 40 MHz, 8 MB of main memory, and communications hardware.
Reference: [Ali96] <author> D. Aliaga. </author> <title> Visualization of complex models using dynamic texture-based simplification. </title> <booktitle> In Proceedings of IEEE Visualization'96, </booktitle> <year> 1996. </year>
Reference-contexts: Due to coherence, the image does not change much over a small time-interval. Hence this image, with a small warp to account for the change of view point, is re-displayed as texture <ref> [Ali96, SLS + 96] </ref>. The system must choose the part of the geometry to re-display using textures. This choice can significantly impact both rendering speed and realism.
Reference: [Baj90] <author> C.L. Bajaj. </author> <title> Rational hypersurface display. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(2) </volume> <pages> 117-127, </pages> <year> 1990. </year> <title> (Symposium on Interactive 3D Graphics). </title>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> Vlassopoulos [Vla90] proposes an algorithm that operates in terms of line segments in the domain. This algorithm starts with a uniform grid and adds horizontal or vertical segments in the parts of the domain where the approximation has a high deviation from the surface or normal deviation. Bajaj <ref> [Baj90] </ref> presents an adaptive sampling scheme based on surface curvature. This scheme is designed to polygonize surfaces in three dimension or higher. Bajaj recommends polygonizing implicit surfaces by parametrizing them first.
Reference: [BE92] <author> M. Bern and D. Eppstein. </author> <title> Mesh generation and optimal triangulation. </title> <editor> In D.-Z. Du and F. K. Hwang, editors, </editor> <booktitle> Computing in Euclidean Geometry, volume 1 of Lecture Notes Series on Computing, </booktitle> <pages> pages 23-90. </pages> <publisher> World Scientific, </publisher> <address> Singapore, </address> <year> 1992. </year>
Reference-contexts: As we will see in Chapter V, efficient triangulation of PSLGs is an important part of the algorithm for surface tessellation. A number of techniques to triangulate polygons and PSLGs have been proposed in computational geometry literature <ref> [DP89, BE92, O'R94, Kum95] </ref>. A number of these techniques attempt to optimize different properties of the triangulation, e.g. angles of the triangle, size of triangles etc.
Reference: [BEWD91] <author> R. Bedichek, C. Ebeling, G. Winkenbach, and T. DeRose. </author> <title> Rapid low-cost display of spline surfaces. </title> <editor> In C. Sequin, editor, </editor> <booktitle> Proceedings of advanced reseach in VLSI, </booktitle> <pages> pages 340-355, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: As shown earlier, the normal are cross products of partial derivatives, which themselves are Bezier surfaces. In this section we show how to efficiently compute points on a Bezier surface (and curve). The de Casteljau algorithm [Far93] is a popular technique to compute points on a surface. Hardware systems <ref> [DBB + 89, BEWD91] </ref> have been designed around this algorithm.
Reference: [BKSS90] <author> N. Beckmann, P. Kriegel, R. Schneider, and B. Seeger. </author> <title> R* tree: An effi-cient and robust access method for points and rectangles. </title> <booktitle> In International Conference on Management of Data, </booktitle> <pages> pages 322-331, </pages> <year> 1990. </year>
Reference-contexts: Now, in addition to the standard hierarchy of object bounding volumes, we maintain a hierarchy of pseudo-Gauss maps. We call this the Normal hierarchy, as opposed to the standard object hierarchy. Our approach of using bounding box hierarchy is similar to R-trees <ref> [BKSS90] </ref> and exhibits logarithmic traversal time on average. This approach greatly simplifies the merging of the normal and object space hierarchies into one structure. Thus we have to store and traverse only one tree. The object-space hierarchy is constructed based on object-space adjacency.
Reference: [Bli78] <author> J. F. </author> <title> Blinn. Computer Display of Curved Surfaces. </title> <type> Ph.d. thesis, </type> <institution> University of Utah, </institution> <year> 1978. </year>
Reference-contexts: He defines surface elements using four boundary curves and decomposes each curve into segments such that only one intersection may occur with any scan-line. Whitted uses Newton's iteration to compute the extrema of spans and interpolates the normal across a span for fast shading. Blinn <ref> [Bli78] </ref> does not pre-process the patches but performs Newton-Raphson iterations to compute all extrema along each of the screen coordinates. He also presents heuristics to handle singularities and many other special cases. Lane et al. [LCWB80] perform the scan-line intersection by recursively subdividing patches.
Reference: [BR94] <author> C.L. Bajaj and A. Royappa. </author> <title> Triangulation and display of rational parametric surfaces. </title> <booktitle> In Proceedings of IEEE Visualization'94, </booktitle> <pages> pages 69-76, </pages> <publisher> IEEE Computer Society, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference-contexts: Bajaj [Baj90] presents an adaptive sampling scheme based on surface curvature. This scheme is designed to polygonize surfaces in three dimension or higher. Bajaj recommends polygonizing implicit surfaces by parametrizing them first. Bajaj et al. <ref> [BR94] </ref> simplify the sampling process by first identifying all degenerate points and curves on the surface and subdividing surfaces along these features. Although adaptive subdivision schemes produce fewer triangles, none of the algorithms listed above are able to render more than a few hundred Bezier patches in real-time.
Reference: [Bro96] <author> F. Brooks. </author> <title> Newport news shipbuilding company interview re ship design process. </title> <type> Technical Report TR96-002, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1996. </year> <note> Not available publicly. </note>
Reference-contexts: Performance of the greedy rendering algorithm : : : : : : : : : : : : : : 114 xiv Chapter I Preview 1.1 Introduction In many applications, like engineering design of large equipment, and walkthroughs of ships and submarines, models are traditionally represented as millions of polygons <ref> [Bro96] </ref>. It is important to be able to visualize these models to speed up their design, prototyping and evaluation.
Reference: [Cat74] <author> E. Catmull. </author> <title> A Subdivision Algorithm for Computer Display of Curved Surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: A number of techniques to display smoothly shaded surfaces have been devised in the past. We can broadly classify these techniques into four categories: 1.2.1 Pixel level subdivision Catmull <ref> [Cat74] </ref> presents one of the first algorithms for displaying surfaces up to the accuracy of the resolution of display. This algorithm subdivides a surface into smaller and smaller sub-patches until each sub-patch is no bigger than the size of one screen pixel. <p> He uses bounding volumes to eliminate surfaces not intersected by a ray. If a ray intersects the volume bounding a surface, that surface is subdivided using Catmull's scheme <ref> [Cat74] </ref> and the process is repeated until the volume is small enough to be approximated as the point of intersection. Whitted also performs anti-aliasing by filtering in the areas of high luminance gradient. <p> As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95]. As <ref> [Cat74] </ref>, these methods subdivide the surfaces into smaller components, but only until each component is flat enough to be approximated by a polygon. (In this sense the algorithm of Lane et al. may also be classified as a polygonal approximation method.) Some apply the subdivision recursively, stopping when their flatness test
Reference: [CCT92] <author> K. L. Clarkson, R. Cole, and R. E. Tarjan. </author> <title> Randomized parallel algorithms for trapezoidal diagrams. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 2(2) </volume> <pages> 117-133, </pages> <year> 1992. </year>
Reference-contexts: The trimming curve forms another polygonal chain, offset from the staircase. These two chains define a planar straight line graph (see Chapter II). 4. Triangulate the graph using one of the known efficient algorithms designed for this purpose, e.g. <ref> [Sei91, CCT92] </ref>. In this way we do not generate any extra triangles. The actual graph triangulation is the most expensive operation and takes O (n log fl n) time for n points on average.
Reference: [Che95] <author> S.E. Chen. </author> <title> QuickTime vr an image-based approach to virtual invi-ronment navigation. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 29-38, </pages> <year> 1995. </year>
Reference-contexts: This choice can significantly impact both rendering speed and realism. The maintenance of smoothness at the boundary between real geometry and texture is also a tough problem. * Image-based rendering: Taking the concept of images further, some recent techniques dispense with geometry altogether and represent models as images <ref> [Che95, MB95, LH96, GGSC96] </ref>. The basic principle of image-based rendering is to generate multiple views from a small number of photographs. Such computation is quite slow on current graphics systems.
Reference: [Cla76] <author> J. H. Clark. </author> <title> Hierarchical geometric models for visible surface algorithms. </title> <journal> Communications of ACM, </journal> 19(10) 547-554, 1976. 
Reference-contexts: Furthermore, empirical evidence shows that model sizes tend to grow ten fold every two years while the rendering speed only about doubles [Wal96]. These large models not only throttle the rendering pipeline, but also encounter system memory limitations. Researchers like Clark <ref> [Cla76] </ref> realized quite early that not all triangles need be sent to the graphics sub-system every frame. He advocated hierarchically grouping objects into clusters and spending only as much effort rendering each cluster as is needed for a satisfactory 1 The Sub model consists of 900,000 triangles. image of it. <p> M N E, the patch is back-facing. 53 In general, the analytic method results in slightly more conservative estimates than the pseudo-map method described earlier, but it does not degrade in performance for values of e close to c, as the pseudo-map method does. 3.4 Hierarchical extension Hierarchical spatial partitioning <ref> [Cla76, FKN80, TFFH94, KM96] </ref> is routinely used in computer graphics to speed up visibility computations. We employ this well known technique and use a hierarchy of bounding boxes. The extension for view-frustum clipping is straightforward. We group patches, and compute volumes tightly enclosing the group.
Reference: [Cla79] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 13(2) </volume> <pages> 289-299, </pages> <year> 1979. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> Once the approximating polygons are computed, standard polygon rendering techniques are applicable. One common problem with these techniques are occurrence of cracks between adjacent patches if their triangular ap 7 proximations do not match at the boundary. A common solution <ref> [Cla79, RHD89] </ref> to this problem is to stop subdividing a boundary if the adjacent boundary reaches its subdivision limit. Most recent efforts for fast display of surfaces have concentrated on the approximation method.
Reference: [DBB + 89] <author> T. DeRose, M. Bailey, B. Barnard, R. Cypher, D. Dobrikin, C. Ebeling, S. Konstantinidou, L. McMurchie, H. Mizrahi, and B. Yost. Apex: </author> <title> two 129 architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5(5) </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference-contexts: As shown earlier, the normal are cross products of partial derivatives, which themselves are Bezier surfaces. In this section we show how to efficiently compute points on a Bezier surface (and curve). The de Casteljau algorithm [Far93] is a popular technique to compute points on a surface. Hardware systems <ref> [DBB + 89, BEWD91] </ref> have been designed around this algorithm.
Reference: [de 59] <author> P. de Casteljau. </author> <title> Outillages methodes calcul. </title> <type> Technical report, </type> <institution> A. Citroen, Paris, </institution> <year> 1959. </year>
Reference-contexts: In this chapter we show how our results can be extended to 3-sided and other n-sided domains. For simplicity of presentation we assume that the domain is a regular n-gon. 9.1.1 Bezier triangles Bezier surfaces defined over a triangular domain are often called Bezier triangles. In fact, de Casteljau <ref> [de 59, de 63] </ref> first devised Bezier triangles, which were later generalized to tensor-product surfaces. Sabin [Sab77] first generalized Bezier to triangular B-splines, The theory of triangular NURBS has been further developed recently by Dahmen et al. [DMS92]. Bezier triangles are obtained from triangular NURBS surfaces by repeated knot insertion.
Reference: [de 63] <author> P. de Casteljau. </author> <title> Courbes et surfaces a poles. </title> <type> Technical report, </type> <institution> Andre Citroen automobilies, Paris, </institution> <year> 1963. </year>
Reference-contexts: In this chapter we show how our results can be extended to 3-sided and other n-sided domains. For simplicity of presentation we assume that the domain is a regular n-gon. 9.1.1 Bezier triangles Bezier surfaces defined over a triangular domain are often called Bezier triangles. In fact, de Casteljau <ref> [de 59, de 63] </ref> first devised Bezier triangles, which were later generalized to tensor-product surfaces. Sabin [Sab77] first generalized Bezier to triangular B-splines, The theory of triangular NURBS has been further developed recently by Dahmen et al. [DMS92]. Bezier triangles are obtained from triangular NURBS surfaces by repeated knot insertion.
Reference: [de 78] <author> C. de Boor. </author> <title> A practical guide to splines. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Chapter IX shows how our algorithms can be extended to non-rectangular domains. Finally Chapter X concludes the dissertation. 26 Chapter II Mathematical Background 2.1 Surfaces This chapter introduces our notation and the mathematical theory underlying our algorithms. [FVFH93] is an excellent introduction to graphics in general. See <ref> [de 78, Far93] </ref> for introduction to splines. We refer to the 3D space in which the NURBS (Non-Uniform Rational B-Spline) model is defined as object space [Wat95]. We use homogeneous coordinates.
Reference: [DLW93] <author> T. DeRose, M. Lounsbery, and J. Warren. </author> <title> Multiresolution analysis for surfaces of arbitrary topology type. </title> <type> Technical Report TR 93-10-05, </type> <institution> Department of Computer Science, University of Washington, </institution> <year> 1993. </year>
Reference-contexts: These techniques are well suited for architectural environments but are not as effective for engineering models that are not easily partitioned into cells and portals. * Model reduction: Graphics literature contains description of a number of techniques to reduce the number of polygons used to represent a model <ref> [DZ81, Tur92, SZL92, DLW93, HDD + 93, Var94] </ref>. In general, these methods generate a sequence of discrete approximations of parts of a model, each at a coarser level of detail from the previous one.
Reference: [DMS92] <author> W. Dahmen, C. Michelli, </author> <title> and H.P. Seidel. Blossoming begets B-spline bases built better by B-patches. </title> <journal> Mathematics of Computation, </journal> <volume> 59(199) </volume> <pages> 97-115, </pages> <year> 1992. </year>
Reference-contexts: In fact, de Casteljau [de 59, de 63] first devised Bezier triangles, which were later generalized to tensor-product surfaces. Sabin [Sab77] first generalized Bezier to triangular B-splines, The theory of triangular NURBS has been further developed recently by Dahmen et al. <ref> [DMS92] </ref>. Bezier triangles are obtained from triangular NURBS surfaces by repeated knot insertion. In this section we present an algorithm to tessellate Bezier triangles. We use the barycentric coordinates of the domain triangle.
Reference: [DN93] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 101-108, </pages> <year> 1993. </year>
Reference: [DP89] <author> L. De Floriani and E. Puppo. </author> <title> A survey of constrained Delaunay triangulation algorithms for surface representaion. </title> <editor> In G. G. Pieroni, editor, </editor> <booktitle> Issues on Machine Vision, </booktitle> <pages> pages 95-104. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1989. </year>
Reference-contexts: As we will see in Chapter V, efficient triangulation of PSLGs is an important part of the algorithm for surface tessellation. A number of techniques to triangulate polygons and PSLGs have been proposed in computational geometry literature <ref> [DP89, BE92, O'R94, Kum95] </ref>. A number of these techniques attempt to optimize different properties of the triangulation, e.g. angles of the triangle, size of triangles etc.
Reference: [DZ81] <author> M.J. Dehaemer and M.J. Zyda. </author> <title> Simplification of objects rendered by polygonal approximations. </title> <journal> Computer and Graphics, </journal> <volume> 15(2) </volume> <pages> 175-184, </pages> <year> 1981. </year>
Reference-contexts: These techniques are well suited for architectural environments but are not as effective for engineering models that are not easily partitioned into cells and portals. * Model reduction: Graphics literature contains description of a number of techniques to reduce the number of polygons used to represent a model <ref> [DZ81, Tur92, SZL92, DLW93, HDD + 93, Var94] </ref>. In general, these methods generate a sequence of discrete approximations of parts of a model, each at a coarser level of detail from the previous one.
Reference: [Far93] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1993. </year> <month> 130 </month>
Reference-contexts: Some of the issues in such interactive rendering are described next. 1.4 Issues in polygonal approximations Some of the main issues to consider when using polygonal approximation for NURBS are: 1. NURBS form: A NURBS surface is commonly represented in terms of the standard basis <ref> [Far93, Wat95] </ref> as a mesh of control points and a pair of knot vectors. A point on the surface can be computed using matrix multiplication, forward-differencing, the Oslo algorithm, or variants of the Cox de Boor algorithm [Far93]. <p> A point on the surface can be computed using matrix multiplication, forward-differencing, the Oslo algorithm, or variants of the Cox de Boor algorithm <ref> [Far93] </ref>. On the other hand, we can use a different basis, e.g. the Bernstein basis, and represent the surface as a collection of Bezier patches. We must pick the representation that facilitates efficient evaluation of the points (geometry) and normals (for shading) on the surface. <p> Chapter IX shows how our algorithms can be extended to non-rectangular domains. Finally Chapter X concludes the dissertation. 26 Chapter II Mathematical Background 2.1 Surfaces This chapter introduces our notation and the mathematical theory underlying our algorithms. [FVFH93] is an excellent introduction to graphics in general. See <ref> [de 78, Far93] </ref> for introduction to splines. We refer to the 3D space in which the NURBS (Non-Uniform Rational B-Spline) model is defined as object space [Wat95]. We use homogeneous coordinates. <p> The shape of the surface is controlled by two one-dimensional arrays of knot vectors, and a two-dimensional array of control points <ref> [Far93] </ref>. Figure 2.2 illustrates the relationship between a domain and a surface patch. <p> One of the advantages of the Bezier representation is that it is more intuitive. It is also more easy to evaluate than general NURBS. Using knot insertion <ref> [Far93] </ref> we decompose each NURBS surface into a series of rational Bezier patches, and each NURBS curve into a series of rational Bezier curves. Knots may be inserted at any parameter value without altering the shape of the NURBS. <p> As shown earlier, the normal are cross products of partial derivatives, which themselves are Bezier surfaces. In this section we show how to efficiently compute points on a Bezier surface (and curve). The de Casteljau algorithm <ref> [Far93] </ref> is a popular technique to compute points on a surface. Hardware systems [DBB + 89, BEWD91] have been designed around this algorithm. <p> The time taken by the de Casteljau algorithm to evaluate a point on a Bezier curve of degree n is proportional to n 2 . On the other hand the modified Horner's rule <ref> [Far93] </ref> results in the evaluation of the point in O (n) time, and each of F u and F u in an additional O (n) each. <p> Overall, back-patch culling improves the observed rendering performance by about 20 35%. 3.2 Patch clipping A Bezier patch, F, is contained in the convex polytope of its control points <ref> [Far93] </ref>. Let us denote this convex polytope as P F . We denote by B F the smallest axis-aligned bounding box that encloses P F . The first phase of visibility processing involves checking whether a patch lies in the viewing volume at all. <p> Let us denote G = G N G D . In order to evaluate the control points of G, we must ensures that the degree of G N is the same as that of G D . Hence, we elevate the u and v degrees <ref> [Far93] </ref>, respectively, of G N by one. Now we have G in rational Bezier form. Coefficients of G D are the weights and those of G N are the weighted 46 control points.
Reference: [Fea89] <author> H. Fuchs and J. Poulton et al. </author> <title> Pixel-Planes 5: A heterogeneous mul-tiprocessor graphics system using processor-enhanced memories. </title> <journal> ACM Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 79-88, </pages> <year> 1989. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: It is important to be able to visualize these models to speed up their design, prototyping and evaluation. While graphics systems have reached the capability to render millions of transformed, shaded and z-buffered triangles per second <ref> [Fea89, MEP92, Ake93] </ref>, they are not able to render such complex and detailed engineering models. <p> Our renderer is built around a core Bezier system called SPEED 4 . Our current implementation on the SGI-Onyx (with 4 R4400 CPUs, 2 Gigabytes of memory, and a Reality Engine II) can display about five thousand Bezier patches and that on the Pixel-Planes 5 <ref> [Fea89] </ref> can display more than thirty thousand Bezier patches at interactive frame rates (about 10 frames a second). 4 Surfaces of Parameter Elegantly and Efficiently Displayed 21 1.6.1 SGI implementation in Figure 1.6. The stage V and rasterization are performed on the graphics accelerator. The final images are Gouraud shaded. <p> The fifth column corresponds to the speed-up due to visibility computation and the sixth shows the speed-up due to incremental computation. 1.6.2 Pixel-Planes 5 implementation Pixel-Planes 5 <ref> [Fea89] </ref> uses extensive parallelism to increase rendering performance. This has become the practice in high-performance graphics accelerators [Ake93]. Figure 1.11 presents a block diagram of the Pixel-Planes 5 system. <p> Triangle raster-ization and shading is performed on renderer boards which contain arrays of 128 by 128 1-bit processors with local memory <ref> [Fea89] </ref> and an instruction sequencer. The processing units are connected by a 160 million word per second ring communications network. All stages, I-V, of our tessellation algorithm run in parallel on the GPs.
Reference: [FK90] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> As opposed to uniform sampling methods, that place samples only on a grid, adaptive sampling methods may place the samples almost anywhere on the domain. Forsey et al. <ref> [FK90] </ref> present a simple recursive subdivision based scheme that tests the size and flatness of each sub-patch and approximates it with a rectangle once the rectangle is closer to it than a user-specified tolerance. Sheng et al. [SH93] present an adaptive tessellation algorithm for trimmed patches.
Reference: [FKN80] <author> H. Fuchs, Z. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priority tree structure. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 124-133, </pages> <year> 1980. </year>
Reference-contexts: The main thrust of these techniques is to reduce the number of polygons passed to the pipeline | * Visibility computation: For large models, the number of off-screen polygons is likely to be high. Spatial partitioning with the help of data structures like Octrees [Hun78] and BSP trees <ref> [FKN80] </ref> are regularly used by rendering systems to reduce the number of off-screen polygons passed to the graphics pipe. Recently Teller et al. [TS91] and Luebke et al. [LG95] described techniques to subdivide models into cells and portals and only render cells visible through these portals. <p> M N E, the patch is back-facing. 53 In general, the analytic method results in slightly more conservative estimates than the pseudo-map method described earlier, but it does not degrade in performance for values of e close to c, as the pseudo-map method does. 3.4 Hierarchical extension Hierarchical spatial partitioning <ref> [Cla76, FKN80, TFFH94, KM96] </ref> is routinely used in computer graphics to speed up visibility computations. We employ this well known technique and use a hierarchy of bounding boxes. The extension for view-frustum clipping is straightforward. We group patches, and compute volumes tightly enclosing the group.
Reference: [FM84] <author> A. Fournier and D. Montuno. </author> <title> Triangulating simple polygons and equivalent problems. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 3 </volume> <pages> 153-174, </pages> <year> 1984. </year>
Reference-contexts: The monotone polygons are obtained from the trapezoidal decomposition by adding a diagonal between two vertices of the original PSLG if they lie on different sides of a trapezoid (Figure 2.8 (b)). Narkhede's implementation employs the greedy scheme of Fournier et al. <ref> [FM84] </ref> to triangulate each monotone polygon by repeatedly cutting a convex corner. It starts with the lowermost point, p l , and connects it to each vertex visible from it by drawing 41 diagonals. A diagonal of a PSLG divides it into two components. <p> Once all points directly visible from p l are connected to it, the algorithm moves to the next lowest point and repeats the process until the complete polygon is triangulated. We modified the <ref> [FM84] </ref> algorithm to avoid thin triangles and vertices of high degree, as described in Chapter V. 42 Chapter III Visibility 3.1 Overview While viewing a large model composed of many thousands of Bezier patches, usually not all patches are visible from a given view point. <p> The delimiting 0-1-cells form a set of staircase-like polygonal chains with a non-zero offset from the trimming curves as shown in Figure 5.1. This is a PSLG. 6. We trapezoidize the PSLG using [Sei91] and generate monotone polygons. 7. Finally we triangulate the monotone polygons using greedy triangulation <ref> [FM84] </ref>. The problem with the algorithm described above is that it generates triangles with edges greater than ffi even if the adjacent samples points are less than ffi 2 apart. This results mostly from the greedy triangulation which is prone to generating long 78 triangles.
Reference: [FMM86] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <booktitle> Computer Aided Geometric Design, </booktitle> <volume> 3(4) </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> At the same time, it is not guaranteed to be crack-free. Overall, our method can render, in real-time, models more than an order of magnitude larger than those by [RHD89]. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in <ref> [FMM86, AES91, AES93] </ref>. Luken et al. [Luk93, LC93] use the standard basis to represent NURBS but generate general polygons. Cracks can appear in their images as well. We defer the discussion of these algorithms until after we have presented our tessellation algorithm. <p> This normally results in a conservative estimate of the required size, but the estimation is be done only once per patch. That is the prime reason why uniform subdivision methods are generally faster than adaptive methods in practice <ref> [FMM86] </ref>. We use uniform subdivision. (Chapter VII presents more detailed analysis of the reasons why we chose uniform sampling.) This chapter presents the algorithm to compute the sampling size required for smooth display of a trimmed Bezier patch. <p> There is considerable literature on computation of such bounds <ref> [LR81, FMM86, Roc87, AES91] </ref>. In particular, Rock-wood et al. [Roc87] and Abi-Ezzi et al. [AES91] use these bounds to compute the sampling size. Suffering from the use of loose bounds, both these methods often over-sample the surface. <p> Determine bounds on the surface in object space as a pre-processing step. At run time, compute the step size as a function of the pre-computed bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. The first method finds f 3 in one step and all computation must be performed at rendering time. On the other hand, the second method factors f 3 into two, f 1 and f 2 . <p> We compute improved bounds for the rational surfaces in object space as part of the pre-processing phase. They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [FMM86, AES93] </ref>. An algorithm for computation of bounds based on the size criterion is presented in [AES91]. However, the bounds in [AES91] should be modified to use the mean value theorem for vector valued functions, as we show next. <p> In case the surface area is small and curvature is high, using only the triangle size criterion results in an undersampling of the surface (Figure 4.2). The solution to this problem involves the deviation criterion. The bound on deviation is computed using results from <ref> [FMM86] </ref>: For a linearly parametrized triangle T = l (u; v) between three points on a surface at l (0; 0); l (l 1 ; 0) and l (0; l 2 ): max kF (u; v) l (u; v)k 8 1 M 1 + 2l 1 l 2 M 2 + <p> This would result in cracks in the rendered image (Figure 1.5). To address this issue <ref> [FMM86, RHD89] </ref> suggest that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of filling triangles be generated at the boundary as shown in Figure 4.4. <p> This is indeed the case after converting NURBS models into Bezier patches. Adaptive subdivision does well on patches with highly varying curvatures. On such models the uniform tessellation may over-sample the patch. 97 7.4 Uniform sampling Uniform subdivision methods generally outperform <ref> [FMM86, KS95] </ref> adaptive methods. Most uniform subdivision algorithms first estimate the step size to use for tessellation and use results from approximation theory [Pre75]. In the context of computer graphics, Lane et al. [LR81] present methods to estimate the maxima, minima and roots of a Bezier polynomial. <p> Most uniform subdivision algorithms first estimate the step size to use for tessellation and use results from approximation theory [Pre75]. In the context of computer graphics, Lane et al. [LR81] present methods to estimate the maxima, minima and roots of a Bezier polynomial. Filip et al. <ref> [FMM86] </ref> apply and extend these results to compute the step size for uniform tessellation. In particular, they derive the deviation bounds reported in Chapter IV.
Reference: [For79] <author> A.R. Forrest. </author> <title> On the rendering of surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 13(2) </volume> <pages> 253-259, </pages> <year> 1979. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Due to its importance in design, curved surface rendering has been an active area of research for more than two decades. Forrest <ref> [For79] </ref> performed one of the earliest studies on benefits of shaded displays of curved surfaces. Forrest claims that simple wire-frame renderings do not lend themselves well to effective visualization of a surface, even with hidden line elimination and perspective projection.
Reference: [FS93] <author> T.A. Funkhouser and C.H. Sequin. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 247-254, </pages> <year> 1993. </year>
Reference-contexts: Recently Teller et al. [TS91] and Luebke et al. [LG95] described techniques to subdivide models into cells and portals and only render cells visible through these portals. Funkhouser et al. <ref> [FS93] </ref> use similar computation to fetch visible (and close to visible) parts of a model into memory, if the complete model does 2 not fit into the main memory.
Reference: [FVFH93] <author> J. Foley, A. VanDam, S. Feiner, and J. Hughes. </author> <title> Computer Graphics principles and practice. </title> <publisher> Addison Wesley, </publisher> <address> Menlo Park, California, </address> <year> 1993. </year>
Reference-contexts: Chapter IX shows how our algorithms can be extended to non-rectangular domains. Finally Chapter X concludes the dissertation. 26 Chapter II Mathematical Background 2.1 Surfaces This chapter introduces our notation and the mathematical theory underlying our algorithms. <ref> [FVFH93] </ref> is an excellent introduction to graphics in general. See [de 78, Far93] for introduction to splines. We refer to the 3D space in which the NURBS (Non-Uniform Rational B-Spline) model is defined as object space [Wat95]. We use homogeneous coordinates. <p> Apart from making efficient use of hardware for rendering triangles, our method is able to easily employ techniques such as anti-aliasing, shadow generation, texture mapping and radiosity computation, which improve the quality of the final image and are known to work well on polygons <ref> [FVFH93, Wat95] </ref>. Although the actual surface approximation resides in the three-dimensional object space, it is much easier to perform the triangulation in the two-dimensional parametric domain of a patch.
Reference: [GGSC96] <author> S. Gortler, R. Grzeszczuk, R. Szelski, and M. Cohen. </author> <booktitle> The lumigraph. In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 43-54, </pages> <year> 1996. </year>
Reference-contexts: This choice can significantly impact both rendering speed and realism. The maintenance of smoothness at the boundary between real geometry and texture is also a tough problem. * Image-based rendering: Taking the concept of images further, some recent techniques dispense with geometry altogether and represent models as images <ref> [Che95, MB95, LH96, GGSC96] </ref>. The basic principle of image-based rendering is to generate multiple views from a small number of photographs. Such computation is quite slow on current graphics systems.
Reference: [Gre83] <author> J. Gregory. </author> <title> C 1 rectangular and non-rectanguar surface patches. </title> <editor> In R. Barnhill and W. Boehm, editors, </editor> <booktitle> Surfaces and CAGD, </booktitle> <pages> pages 25-33. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1983. </year> <month> 131 </month>
Reference-contexts: There 122 exist parametrizations defined over multisided convex domains. Gregory <ref> [Gre83] </ref> presents some of the pioneering work on multisided patches. Herron [Her79] describes an algorithm to decompose general multisided patches into triangular and rectangular patches. More recently, Loop et al. [LD89] present a unifying framework for multisided patches, or S-patches.
Reference: [HDD + 93] <author> H. Hoppe, T. DeRose, T. Duchamp, J. Mcdonald, and W. Stuetzle. </author> <title> Mesh optimization. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 19-26, </pages> <year> 1993. </year>
Reference-contexts: These techniques are well suited for architectural environments but are not as effective for engineering models that are not easily partitioned into cells and portals. * Model reduction: Graphics literature contains description of a number of techniques to reduce the number of polygons used to represent a model <ref> [DZ81, Tur92, SZL92, DLW93, HDD + 93, Var94] </ref>. In general, these methods generate a sequence of discrete approximations of parts of a model, each at a coarser level of detail from the previous one.
Reference: [Her79] <author> G. Herron. </author> <title> Triangular and Multisided Patch Schemes. </title> <type> PhD thesis, </type> <institution> Dept. of Mathematics, University of Utah, </institution> <address> Salt Lake City, </address> <year> 1979. </year>
Reference-contexts: There 122 exist parametrizations defined over multisided convex domains. Gregory [Gre83] presents some of the pioneering work on multisided patches. Herron <ref> [Her79] </ref> describes an algorithm to decompose general multisided patches into triangular and rectangular patches. More recently, Loop et al. [LD89] present a unifying framework for multisided patches, or S-patches. They define surfaces by embedding the m sided domain in a m 1 dimensional space.
Reference: [HL95] <author> B. Hendrickson and R. Leland. </author> <title> A multilevel algorithm for partitioning graphs. </title> <booktitle> Proc. Supercomputing '95, </booktitle> <year> 1995. </year>
Reference-contexts: This chapter also presents a speed-up trick, called greedy rendering, that allows us to display out-of-date triangles in order to maintain interactive frame rates. 8.2 Static load balancing A number of load balancing algorithms reduce the problem to graph partitioning <ref> [HL95, KK95] </ref>. These algorithms assume the existence of a load graph. The vertices and edges of a load graph have weights associated with them. The goal is to find sub-graphs of the load graph such that each sub-graph satisfies certain properties.
Reference: [Hop96] <author> H. Hoppe. </author> <title> Progressive meshes. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 99-108, </pages> <year> 1996. </year>
Reference-contexts: At rendering time, the system picks and displays the appropriate version of each part based on its distance from the viewer. Switching smoothly between versions is a tough problem for these methods. The methods of progressive meshes <ref> [Hop96] </ref> alleviates this problem by varying detail more gradually. However, there remain difficult problems like handling degenerate models and efficiently switching detail to the desired level. * Textures: Recently there has been an increase in support for rendering textured polygons on current graphics systems.
Reference: [Hun78] <author> G. Hunt. </author> <title> Efficient Computation and Data Structure for Graphics. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Princeton University, </institution> <year> 1978. </year>
Reference-contexts: The main thrust of these techniques is to reduce the number of polygons passed to the pipeline | * Visibility computation: For large models, the number of off-screen polygons is likely to be high. Spatial partitioning with the help of data structures like Octrees <ref> [Hun78] </ref> and BSP trees [FKN80] are regularly used by rendering systems to reduce the number of off-screen polygons passed to the graphics pipe. Recently Teller et al. [TS91] and Luebke et al. [LG95] described techniques to subdivide models into cells and portals and only render cells visible through these portals.
Reference: [IW92] <author> K. Iino and D. Wilde. </author> <title> Subdivision of triangular Bezier patches into rectangular Bezier patches. </title> <journal> Transactions of the ASME, </journal> <year> 1992. </year>
Reference-contexts: We again use the quotient rule for derivatives of rationals. 9.1.2 Sampling It is easy to reparametrize a triangular domain onto a rectangular domain <ref> [IW92] </ref> and apply all results described earlier in this dissertation, but that defeats the whole purpose of using triangular Bezier surfaces. A better solution may be to extend the domain by reflection about w = 0.
Reference: [Jae80] <author> J. Jaech. </author> <title> Surface rendering by computer and a scan-line solution to the cracking problem. </title> <type> Master's thesis, </type> <institution> Computer Science Department, University of Washington, </institution> <year> 1980. </year>
Reference: [Kaj82] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Whitted also performs anti-aliasing by filtering in the areas of high luminance gradient. Kajiya <ref> [Kaj82] </ref> presents a numerical solution and reduces the ray patch intersection in real projective 3-dimensional space to intersection of algebraic curves in 2-dimensional complex space. It uses results from elimination theory (see Chapter II) to compute the points of intersection.
Reference: [Kel95] <author> P. Keller. </author> <title> Parallel tessellation of Bezier surface patches using a SIMD processor array. </title> <type> Master's thesis, </type> <institution> Computer Science Department, University of North Carolina at Chapel Hill, </institution> <year> 1995. </year>
Reference: [KK95] <author> G. Karypis and V. Kumar. </author> <title> Multilevel k-way partitioning scheme for irregular graphs. </title> <type> Technical Report TR95-064, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1995. </year> <month> 132 </month>
Reference-contexts: This chapter also presents a speed-up trick, called greedy rendering, that allows us to display out-of-date triangles in order to maintain interactive frame rates. 8.2 Static load balancing A number of load balancing algorithms reduce the problem to graph partitioning <ref> [HL95, KK95] </ref>. These algorithms assume the existence of a load graph. The vertices and edges of a load graph have weights associated with them. The goal is to find sub-graphs of the load graph such that each sub-graph satisfies certain properties.
Reference: [KKMN95] <author> S. Kumar, S. Krishnan, D. Manocha, and A. Narkhede. </author> <title> Representation and display of complex CSG models. </title> <type> Technical Report TR95-019, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1995. </year>
Reference-contexts: Since our step size determination is dependent on the representation of the curve, different tessellations of the same curve may result. Our solution involves computing the space representation of each trimming curve. For solid models generated using CSG we use a seven-dimensional curve fitting method described in <ref> [KKMN95] </ref>. This method bounds error in the three object space dimensions, the two parametric dimensions of F 1 's domain and the two parametric dimensions of F 2 's domain at the same time.
Reference: [KM84] <author> P.A. Koparkar and S. P. Mudur. </author> <title> Computational techniques for processing parametric surfaces. Computer Vision, </title> <journal> Graphics and Image Processing, </journal> <volume> 28(3) </volume> <pages> 303-322, </pages> <year> 1984. </year>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>.
Reference: [KM94a] <author> S. Krishnan and D. Manocha. </author> <title> Global visibility and hidden surface algorithms for free form surfaces. </title> <type> Technical Report TR94-063, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: These back-facing patches are hidden behind other patches and are not visible to the viewer. In general, the exact computation of the visible portions of a NURBS model is a non-trivial problem requiring silhouette computation <ref> [KM94a] </ref>. In this chapter we show that it is relatively simple to perform a conservative visibility test. We present an efficient algorithm to determine if a patch is back-facing in a given frame.
Reference: [KM94b] <author> S. Kumar and D. Manocha. </author> <title> Interactive display of large scale trimmed NURBS models. </title> <type> Technical Report TR94-008, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: Now, In general, the trimming curves are not allowed to intersect. Intersecting trimming curves do not have well defined interiors. <ref> [KM94b] </ref> presents an algorithm to generate non-intersecting trimming curves from a set of potentially intersecting trimming curves in a semantically consistent way. Bezier surfaces are special types of NURBS surfaces, that do not have any knots except at the corner points.
Reference: [KM96] <author> S. Kumar and D. Manocha. </author> <title> Hierarchical visibility culling for spline models. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 142-150, </pages> <address> Toronto, Canada, </address> <year> 1996. </year>
Reference-contexts: M N E, the patch is back-facing. 53 In general, the analytic method results in slightly more conservative estimates than the pseudo-map method described earlier, but it does not degrade in performance for values of e close to c, as the pseudo-map method does. 3.4 Hierarchical extension Hierarchical spatial partitioning <ref> [Cla76, FKN80, TFFH94, KM96] </ref> is routinely used in computer graphics to speed up visibility computations. We employ this well known technique and use a hierarchy of bounding boxes. The extension for view-frustum clipping is straightforward. We group patches, and compute volumes tightly enclosing the group. <p> Allowing different node types can potentially increase the tree size, but it allows us to avoid performing potentially ineffective tests. The type of a node is determined at the time of hierarchy construction. More details on the construction and traversal of ON E-trees can be found is <ref> [KM96] </ref>. 56 Chapter IV Surface Sampling 4.1 Overview To display a NURBS surface, we dynamically compute a triangulation of points on the surface as a function of the viewing parameters. In each frame, these points can be picked by uniformly or adaptively sampling the domain.
Reference: [KS95] <author> R. Klein and W. Straber. </author> <title> Large mesh generation from boundary models with parametric face representation. </title> <booktitle> In Proc. of ACM SIGGRAPH Symposium on Solid Modeling, </booktitle> <pages> pages 431-440, </pages> <year> 1995. </year>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> Sheng et al. [SH93] present an adaptive tessellation algorithm for trimmed patches. This algorithm starts with a Delaunay triangulation of points on the patch. It then subdivides each edge longer than a user-specified value in object space. Klein et al. <ref> [KS95] </ref> similarly use Delaunay triangulation. Their algorithm incrementally computes the farthest (in terms of Eu-clidean distance) patch point from the current approximation and inserts that point into the triangulation. The process terminates when this farthest point is closer than some user-specified tolerance. <p> This is indeed the case after converting NURBS models into Bezier patches. Adaptive subdivision does well on patches with highly varying curvatures. On such models the uniform tessellation may over-sample the patch. 97 7.4 Uniform sampling Uniform subdivision methods generally outperform <ref> [FMM86, KS95] </ref> adaptive methods. Most uniform subdivision algorithms first estimate the step size to use for tessellation and use results from approximation theory [Pre75]. In the context of computer graphics, Lane et al. [LR81] present methods to estimate the maxima, minima and roots of a Bezier polynomial.
Reference: [Kum95] <author> S. Kumar. </author> <title> A survey of polygon triangulation algorithms. </title> <type> Technical Report TR96-011, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1995. </year>
Reference-contexts: As we will see in Chapter V, efficient triangulation of PSLGs is an important part of the algorithm for surface tessellation. A number of techniques to triangulate polygons and PSLGs have been proposed in computational geometry literature <ref> [DP89, BE92, O'R94, Kum95] </ref>. A number of these techniques attempt to optimize different properties of the triangulation, e.g. angles of the triangle, size of triangles etc.
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed NURB surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> Overall, our method can render, in real-time, models more than an order of magnitude larger than those by [RHD89]. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in [FMM86, AES91, AES93]. Luken et al. <ref> [Luk93, LC93] </ref> use the standard basis to represent NURBS but generate general polygons. Cracks can appear in their images as well. We defer the discussion of these algorithms until after we have presented our tessellation algorithm. <p> Ratio # Tris. Ratio Goblet 72 535 1 790 1.48 659 1.23 Pencil 570 4720 1 6875 1.45 5810 1.23 Dragon 5354 19220 1 22500 1.15 22755 1.18 Table 7.2: Comparison of the number of triangles generated for a given tolerance 7.5 Direct NURBS tessellation Luken et al. <ref> [Luk93, LC93] </ref> present an algorithm to polygonize trimmed NURBS surfaces. They generate general polygons, not triangles. They do not decompose trimmed NURBS into trimmed Bezier patches either, but tessellate NURBS directly. They divide each u-span and each v-span into uniform steps.
Reference: [LCWB80] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year> <month> 133 </month>
Reference-contexts: Blinn [Bli78] does not pre-process the patches but performs Newton-Raphson iterations to compute all extrema along each of the screen coordinates. He also presents heuristics to handle singularities and many other special cases. Lane et al. <ref> [LCWB80] </ref> perform the scan-line intersection by recursively subdividing patches. If the convex hull of a patch intersects the current scan-line, the patch is subdivided into smaller sub-patches so that the convex hull of each sub-patch bounds it more tightly.
Reference: [LD89] <author> C. Loop and T. DeRose. </author> <title> A multisided generalization of Bezier surfaces. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 8(3) </volume> <pages> 204-234, </pages> <year> 1989. </year>
Reference-contexts: There 122 exist parametrizations defined over multisided convex domains. Gregory [Gre83] presents some of the pioneering work on multisided patches. Herron [Her79] describes an algorithm to decompose general multisided patches into triangular and rectangular patches. More recently, Loop et al. <ref> [LD89] </ref> present a unifying framework for multisided patches, or S-patches. They define surfaces by embedding the m sided domain in a m 1 dimensional space. The result is a generalization of barycentric coordinates. Our tessellation algorithm for triangular Bezier patches generalizes quite easily to S-patches.
Reference: [LG95] <author> D. Luebke and C. Georges. </author> <title> Portals and mirrors: Simple, fast evaluation of potentially visible sets. In Symposium on Interactive 3D Graphics, </title> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: Spatial partitioning with the help of data structures like Octrees [Hun78] and BSP trees [FKN80] are regularly used by rendering systems to reduce the number of off-screen polygons passed to the graphics pipe. Recently Teller et al. [TS91] and Luebke et al. <ref> [LG95] </ref> described techniques to subdivide models into cells and portals and only render cells visible through these portals. Funkhouser et al. [FS93] use similar computation to fetch visible (and close to visible) parts of a model into memory, if the complete model does 2 not fit into the main memory.
Reference: [LH96] <author> M. Levoy and P. Hanrahan. </author> <title> Light field rendering. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 31-42, </pages> <year> 1996. </year>
Reference-contexts: This choice can significantly impact both rendering speed and realism. The maintenance of smoothness at the boundary between real geometry and texture is also a tough problem. * Image-based rendering: Taking the concept of images further, some recent techniques dispense with geometry altogether and represent models as images <ref> [Che95, MB95, LH96, GGSC96] </ref>. The basic principle of image-based rendering is to generate multiple views from a small number of photographs. Such computation is quite slow on current graphics systems.
Reference: [LR81] <author> J.M. Lane and R.F. Riesenfeld. </author> <title> Bounds on polynomials. </title> <journal> BIT, </journal> <volume> 21(1) </volume> <pages> 112-117, </pages> <year> 1981. </year>
Reference-contexts: There is considerable literature on computation of such bounds <ref> [LR81, FMM86, Roc87, AES91] </ref>. In particular, Rock-wood et al. [Roc87] and Abi-Ezzi et al. [AES91] use these bounds to compute the sampling size. Suffering from the use of loose bounds, both these methods often over-sample the surface. <p> Determine bounds on the surface in object space as a pre-processing step. At run time, compute the step size as a function of the pre-computed bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. The first method finds f 3 in one step and all computation must be performed at rendering time. On the other hand, the second method factors f 3 into two, f 1 and f 2 . <p> Note that all these computations are part of the pre-processing stage. Similarly, the maximum of f x (0; v) corresponds to computing the roots of f x v (0; v) = 0, which can be computed using root-finders or subdivision properties of Bezier curves <ref> [LR81] </ref>. Based on the solutions of these equations, we compute the maximum values of f x (u; v) in the domain [0; 1]fi [0; 1]. Let the maximum value be at [u x ; v x ]. f y (u; v) and f z (u; v) are computed similarly. <p> Most uniform subdivision algorithms first estimate the step size to use for tessellation and use results from approximation theory [Pre75]. In the context of computer graphics, Lane et al. <ref> [LR81] </ref> present methods to estimate the maxima, minima and roots of a Bezier polynomial. Filip et al. [FMM86] apply and extend these results to compute the step size for uniform tessellation. In particular, they derive the deviation bounds reported in Chapter IV.
Reference: [Luk93] <institution> W.L. Luken. Tessellation of trimmed NURB surfaces. Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Overall, our method can render, in real-time, models more than an order of magnitude larger than those by [RHD89]. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in [FMM86, AES91, AES93]. Luken et al. <ref> [Luk93, LC93] </ref> use the standard basis to represent NURBS but generate general polygons. Cracks can appear in their images as well. We defer the discussion of these algorithms until after we have presented our tessellation algorithm. <p> Ratio # Tris. Ratio Goblet 72 535 1 790 1.48 659 1.23 Pencil 570 4720 1 6875 1.45 5810 1.23 Dragon 5354 19220 1 22500 1.15 22755 1.18 Table 7.2: Comparison of the number of triangles generated for a given tolerance 7.5 Direct NURBS tessellation Luken et al. <ref> [Luk93, LC93] </ref> present an algorithm to polygonize trimmed NURBS surfaces. They generate general polygons, not triangles. They do not decompose trimmed NURBS into trimmed Bezier patches either, but tessellate NURBS directly. They divide each u-span and each v-span into uniform steps.
Reference: [MB95] <author> L. Mcmillan and G. Bishop. </author> <title> Plenoptic modeling: An image based rendering system. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 39-46, </pages> <year> 1995. </year>
Reference-contexts: This choice can significantly impact both rendering speed and realism. The maintenance of smoothness at the boundary between real geometry and texture is also a tough problem. * Image-based rendering: Taking the concept of images further, some recent techniques dispense with geometry altogether and represent models as images <ref> [Che95, MB95, LH96, GGSC96] </ref>. The basic principle of image-based rendering is to generate multiple views from a small number of photographs. Such computation is quite slow on current graphics systems.
Reference: [MD92] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curves. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 232-241, </pages> <year> 1992. </year>
Reference-contexts: There is well-researched elimination theory <ref> [Sed83, MD92] </ref> that derives techniques for computing zeros. In particular, we use the method of resultants [Usp48]. The resultant of a set of polynomials is a function of the coefficients and variables of the equations which evaluates to zero iff the polynomials have a (non-trivial) common root. <p> We need to compute the zeros of this expression. This problem reduces to computing the eigenvalues of a companion matrix <ref> [MD92] </ref>. Good implementations of eigenvalue evaluators are available as part of numerical libraries like EISPACK and LAPACK. The resulting algorithms are fast, accurate, need no initial guess of the solutions, and do not suffer from convergence problems [MD92]. <p> This problem reduces to computing the eigenvalues of a companion matrix <ref> [MD92] </ref>. Good implementations of eigenvalue evaluators are available as part of numerical libraries like EISPACK and LAPACK. The resulting algorithms are fast, accurate, need no initial guess of the solutions, and do not suffer from convergence problems [MD92]. In Chapter IV we will need to find roots of derivatives of Bezier functions. This theory is useful for that. We first compute the Sylvester's determinant each of whose entries is an array of coefficients. The value of the determinant is a function of these coefficients. <p> max kF uu (u; v)k; M 2 = max kF uv (u; v)k; and M 3 = max kF vv (u; v)k; We can again reduce the computations of M 1 , M 2 and M 3 to finding zeros of polynomials and solve them using techniques from elimination theory <ref> [MD92] </ref>. However, in practice this method typically oversamples the surface as the degrees of the polyno mials are very high and the bounds become loose (often by a factor of two or more).
Reference: [MEP92] <author> S. Molnar, J. Eyles, and J. Poulton. PixelFlow: </author> <title> High speed rendering using image composition. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 231-248, </pages> <year> 1992. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: It is important to be able to visualize these models to speed up their design, prototyping and evaluation. While graphics systems have reached the capability to render millions of transformed, shaded and z-buffered triangles per second <ref> [Fea89, MEP92, Ake93] </ref>, they are not able to render such complex and detailed engineering models.
Reference: [Nas93] <author> R. Nash, </author> <year> 1993. </year> <title> Silicon Graphics, </title> <type> Personal Communication. </type>
Reference-contexts: By factoring out parts of the computation that are independent of the view point and may be performed off-line, we are able to speed up the on-line computation of the sampling size. 1.5.3 Efficient processing of trimmed patches Traditionally, real-time tessellation of trimmed surfaces has been considered hard <ref> [Nas93, Seg95] </ref>. We have devised an efficient scheme to tessellate trimmed surfaces. <p> The final images are Gouraud shaded. The performance of the algorithm on the SGI Onyx with one R4400 CPU is shown in Table 1.1. We have compared our implementation to that in the standard GL library on SGIs. The SGI-GL implementation is based on the algorithm presented in <ref> [RHD89, Nas93] </ref> and has a microcoded geometry engine implementation for surface evaluations. That implementation does not take advantage of the multiple host CPUs since the tessellation is done on the Reality Engine hardware. Model Num.
Reference: [NM95] <author> A. Narkhede and D. Manocha. </author> <title> Fast polygon triangulation based on Sei-del's algorithm. </title> <editor> In A. Paeth, editor, </editor> <title> Graphics Gems V, </title> <publisher> Academic Press, </publisher> <year> 1995. </year>
Reference-contexts: In fact, it maximizes 40 the minimum angle of any triangle. Unfortunately, it is expensive to compute. It takes O (n log n) time to compute the Delaunay triangulation of a PSLG containing n vertices. In our system, we used the public domain implementation by Narkhede et al. <ref> [NM95] </ref> of a randomized incremental algorithm devised by Seidel [Sei91]. The [Sei91] algorithm triangulates PSLGs by first decomposing it into a number of monotone polygons, and then triangulating each monotone polygon. It can triangulate a PSLG with n vertices in O (n log fl n) expected time.
Reference: [NSK90] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto. </author> <title> Ray tracing trimmed rational surface patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 337-345, </pages> <year> 1990. </year> <note> (SIGGRAPH Proceedings). 134 </note>
Reference-contexts: Kajiya [Kaj82] presents a numerical solution and reduces the ray patch intersection in real projective 3-dimensional space to intersection of algebraic curves in 2-dimensional complex space. It uses results from elimination theory (see Chapter II) to compute the points of intersection. Nishita et al.'s algorithm <ref> [NSK90] </ref> is subdivision based, but performs the surface subdivision using an operation called Bezier clipping. Bezier clipping eliminates large parts of a surface that do not intersect a ray. This technique is applicable to trimmed surfaces as well.
Reference: [O'N66] <author> B. O'Neill. </author> <title> Elementary Differential Geometry. </title> <publisher> Academic Press, </publisher> <year> 1966. </year>
Reference-contexts: We define the Gauss map of a surface with a continuous unit normal vector field as follows <ref> [O'N66] </ref>: The Gauss map G r of a surface, F, is a map G r : F ! S 2 , the 2-Sphere, i.e. the standard sphere embedded in 3D, which maps point F (u; v) to the vector U (u; v), translated to the origin, where U (u; v) =
Reference: [O'R94] <author> J. O'Rourke. </author> <title> Computational Geometry in C. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: As we will see in Chapter V, efficient triangulation of PSLGs is an important part of the algorithm for surface tessellation. A number of techniques to triangulate polygons and PSLGs have been proposed in computational geometry literature <ref> [DP89, BE92, O'R94, Kum95] </ref>. A number of these techniques attempt to optimize different properties of the triangulation, e.g. angles of the triangle, size of triangles etc. <p> A number of techniques to triangulate polygons and PSLGs have been proposed in computational geometry literature [DP89, BE92, O'R94, Kum95]. A number of these techniques attempt to optimize different properties of the triangulation, e.g. angles of the triangle, size of triangles etc. In particular, constrained Delaunay triangulation <ref> [O'R94] </ref> has the useful property of being regular and is therefore routinely used in applications like fluid dynamics and finite element analysis. It avoids long and thin triangles. In fact, it maximizes 40 the minimum angle of any triangle. Unfortunately, it is expensive to compute.
Reference: [PR95] <author> L. Piegl and A. Richard. </author> <title> Tessellating trimmed NURBS surfaces. </title> <booktitle> Computer Aided Geometric Design, </booktitle> <volume> 27(1) </volume> <pages> 16-26, </pages> <year> 1995. </year>
Reference-contexts: The Bezier form incurs only a one-time cost of conversion from NURBS to Bezier. These Luken algorithms assume that a NURBS surface forms a complete solid, and hence make no attempt to prevent cracks between NURBS surfaces. Piegl et al. <ref> [PR95] </ref> also tessellate NURBS directly. They use a surface deviation tolerance to guide their step size.
Reference: [Pre75] <author> P. M. Prenter. </author> <title> Splines and Variational Methods. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: On such models the uniform tessellation may over-sample the patch. 97 7.4 Uniform sampling Uniform subdivision methods generally outperform [FMM86, KS95] adaptive methods. Most uniform subdivision algorithms first estimate the step size to use for tessellation and use results from approximation theory <ref> [Pre75] </ref>. In the context of computer graphics, Lane et al. [LR81] present methods to estimate the maxima, minima and roots of a Bezier polynomial. Filip et al. [FMM86] apply and extend these results to compute the step size for uniform tessellation.
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 107-117, </pages> <year> 1989. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: trimming curve samples : : : : : : : : : : : : : : : : : : : : 88 6.5 Data structure for incremental triangulation : : : : : : : : : : : : : : : : 90 7.1 Comparison of <ref> [RHD89] </ref> tessellation to ours (on the right) : : : : : : : : 98 8.1 Global queue with locking: a potential bottleneck : : : : : : : : : : : : 106 8.2 Timeline showing consistent behavior : : : : : : : : : <p> Although ray tracing can generate high quality images, it can involve millions of ray intersections, each needing thousands of operations. As a result, these methods are too slow for interactive display. 1.2.4 Polygonal approximation A number of algorithms for approximating curved surfaces with polygons are described in the literature <ref> [Cla79, KM84, FMM86, RHD89, Baj90, FK90, AES91, LC93, KS95] </ref>. <p> Once the approximating polygons are computed, standard polygon rendering techniques are applicable. One common problem with these techniques are occurrence of cracks between adjacent patches if their triangular ap 7 proximations do not match at the boundary. A common solution <ref> [Cla79, RHD89] </ref> to this problem is to stop subdividing a boundary if the adjacent boundary reaches its subdivision limit. Most recent efforts for fast display of surfaces have concentrated on the approximation method. <p> As mentioned above, a number of NURBS tessellation algorithms have been proposed recently. Some are based on adaptive sampling, while others use uniform sampling. In particular, Rockwood et al. <ref> [RHD89] </ref> proposed a real-time algorithm for trimmed NURBS surfaces. A variant of this algorithm has been implemented as SGI GL and OpenGL primitives. Their method uses the Bezier representation for surfaces, and performs tessellations as a function of the view point. <p> Furthermore, the operations used on trimming curves are relatively expensive and affect the performance of the overall algorithm. At the same time, it is not guaranteed to be crack-free. Overall, our method can render, in real-time, models more than an order of magnitude larger than those by <ref> [RHD89] </ref>. Some techniques to improve the quality of tessellation and the efficiency of its computation are presented in [FMM86, AES91, AES93]. Luken et al. [Luk93, LC93] use the standard basis to represent NURBS but generate general polygons. Cracks can appear in their images as well. <p> The final images are Gouraud shaded. The performance of the algorithm on the SGI Onyx with one R4400 CPU is shown in Table 1.1. We have compared our implementation to that in the standard GL library on SGIs. The SGI-GL implementation is based on the algorithm presented in <ref> [RHD89, Nas93] </ref> and has a microcoded geometry engine implementation for surface evaluations. That implementation does not take advantage of the multiple host CPUs since the tessellation is done on the Reality Engine hardware. Model Num. <p> We may compute f 3 in two ways: 1. Transform the surface (control points) into screen space. Use the transformed representation to compute the bounds on derivatives, and the step sizes as a function of these bounds <ref> [Roc87, RHD89] </ref>. 2. Determine bounds on the surface in object space as a pre-processing step. At run time, compute the step size as a function of the pre-computed bounds and viewing parameters [LR81, FMM86, AES91]. <p> Let be the required step size in screen space. For adjacent samples to be closer than , the step sizes along the u and v parametric directions are given as <ref> [RHD89] </ref>: n u = m fl min (W ij ) max k W ij R ij W i;j+1 R i;j+1 k (IV.2) In practice these bounds are good for polynomial surfaces only, when W ij = 1. <p> This would result in cracks in the rendered image (Figure 1.5). To address this issue <ref> [FMM86, RHD89] </ref> suggest that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of filling triangles be generated at the boundary as shown in Figure 4.4. <p> Filip et al. [FMM86] apply and extend these results to compute the step size for uniform tessellation. In particular, they derive the deviation bounds reported in Chapter IV. Rockwood et al. <ref> [RHD89] </ref> report one of the first successful attempts at real-time rendering of trimmed NURBS surfaces, and we draw profusely from their method. [RHD89] decomposes NURBS surfaces into Bezier patches and uniformly tessellates each Bezier patch. It also uniformly tessellates each trimming curve. <p> In particular, they derive the deviation bounds reported in Chapter IV. Rockwood et al. <ref> [RHD89] </ref> report one of the first successful attempts at real-time rendering of trimmed NURBS surfaces, and we draw profusely from their method. [RHD89] decomposes NURBS surfaces into Bezier patches and uniformly tessellates each Bezier patch. It also uniformly tessellates each trimming curve. The sampling criterion is based on the triangle edge size. In order to simplify the triangulation, [RHD89] decomposes each trimming curve into monotonic segments and introduces degenerate triangles between sample points <p> at real-time rendering of trimmed NURBS surfaces, and we draw profusely from their method. <ref> [RHD89] </ref> decomposes NURBS surfaces into Bezier patches and uniformly tessellates each Bezier patch. It also uniformly tessellates each trimming curve. The sampling criterion is based on the triangle edge size. In order to simplify the triangulation, [RHD89] decomposes each trimming curve into monotonic segments and introduces degenerate triangles between sample points on the trimming curve and its intersection with the uniform surface grid. We adapt [RHD89] boundary triangulation algorithm for crack prevention. <p> The sampling criterion is based on the triangle edge size. In order to simplify the triangulation, <ref> [RHD89] </ref> decomposes each trimming curve into monotonic segments and introduces degenerate triangles between sample points on the trimming curve and its intersection with the uniform surface grid. We adapt [RHD89] boundary triangulation algorithm for crack prevention. In particular, we make sure that the sample points on a boundary curves coincide on both its adjacent patches. <p> As a result, we obtain a reduction in the number of triangles produced and an improvement in the uniformity of these triangles. A comparison of the two triangulations on a brake-rotor is shown in Figure 7.1. Since the <ref> [RHD89] </ref> algorithm performs the computation of sampling size entirely in screen space, it is computationally more expensive. Moreover, in order to improve its efficiency, it uses simple algorithms to estimate its bounds (Equation IV.2), which can be rather loose for rational patches. <p> Color plate A displays the wire-frames and shaded images of the pencil and goblet models computed using the three methods. Since we use tighter bounds, the variation in sizes of our triangle is less than that produced by <ref> [RHD89] </ref> or [AES91] 99 algorithms. Model Number of Our Algorithm [RHD89] Algorithm [AES91] Algorithm Patches # Tris. Ratio # Tris. Ratio # Tris. <p> Color plate A displays the wire-frames and shaded images of the pencil and goblet models computed using the three methods. Since we use tighter bounds, the variation in sizes of our triangle is less than that produced by <ref> [RHD89] </ref> or [AES91] 99 algorithms. Model Number of Our Algorithm [RHD89] Algorithm [AES91] Algorithm Patches # Tris. Ratio # Tris. Ratio # Tris.
Reference: [Roc87] <author> A. Rockwood. </author> <title> A generalized scanning technique for display of parametrically defined surface. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7(8) </volume> <pages> 15-26, </pages> <year> 1987. </year>
Reference-contexts: There is considerable literature on computation of such bounds <ref> [LR81, FMM86, Roc87, AES91] </ref>. In particular, Rock-wood et al. [Roc87] and Abi-Ezzi et al. [AES91] use these bounds to compute the sampling size. Suffering from the use of loose bounds, both these methods often over-sample the surface. <p> There is considerable literature on computation of such bounds [LR81, FMM86, Roc87, AES91]. In particular, Rock-wood et al. <ref> [Roc87] </ref> and Abi-Ezzi et al. [AES91] use these bounds to compute the sampling size. Suffering from the use of loose bounds, both these methods often over-sample the surface. <p> We may compute f 3 in two ways: 1. Transform the surface (control points) into screen space. Use the transformed representation to compute the bounds on derivatives, and the step sizes as a function of these bounds <ref> [Roc87, RHD89] </ref>. 2. Determine bounds on the surface in object space as a pre-processing step. At run time, compute the step size as a function of the pre-computed bounds and viewing parameters [LR81, FMM86, AES91].
Reference: [Sab77] <author> M. Sabin. </author> <title> The Use of Piecewise Forms for Numerical Representation of Shape. </title> <type> PhD thesis, </type> <institution> Hungarian Academy of Sciences, </institution> <address> Budapest, </address> <year> 1977. </year>
Reference-contexts: For simplicity of presentation we assume that the domain is a regular n-gon. 9.1.1 Bezier triangles Bezier surfaces defined over a triangular domain are often called Bezier triangles. In fact, de Casteljau [de 59, de 63] first devised Bezier triangles, which were later generalized to tensor-product surfaces. Sabin <ref> [Sab77] </ref> first generalized Bezier to triangular B-splines, The theory of triangular NURBS has been further developed recently by Dahmen et al. [DMS92]. Bezier triangles are obtained from triangular NURBS surfaces by repeated knot insertion. In this section we present an algorithm to tessellate Bezier triangles.
Reference: [SAE93] <author> L.A. Shirman and S.S. Abi-Ezzi. </author> <title> The cone of normals technique for fast processing of curved patches. </title> <booktitle> In EUROGRAPHICS, </booktitle> <pages> pages 261-272, </pages> <year> 1993. </year>
Reference-contexts: The normal of a back-facing polygon faces away from the viewer's eye. Analogously, if all the 45 surface normals of a Bezier patch point away from the eye-point, we refer to it as a back-patch (Figure 3.1). A similar technique was independently proposed by Shirman et al. <ref> [SAE93] </ref>. They maintain a floating cone that bounds all normals and derive expressions to compute if the cone faces away from the user. Our approach is simpler and more general. It is easily customized to different applications by appropriately choosing the complexity of the back-patch test, as shown later.
Reference: [SC88] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed NURBS with adaptive forward differencing. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 189-198, </pages> <year> 1988. </year> <note> (SIG-GRAPH Proceedings). </note>
Reference-contexts: The pixel is then assigned the color of that sub-patch. Catmull devised a fast subdivision algorithm for bicubic patches. While resulting in effective images, this method is quite slow due to the depth of subdivisions. The adaptive forward differencing of Shantz et al. <ref> [SL87, SC88] </ref> is similar in principle and handles 5 trimming curves. It converts the NURBS basis to a forward difference basis and scales the difference up or down depending on the speed of parametric curves on the surface. <p> Tessellate each patch recursively. Thus the stopping criteria are based on the local properties of the surface. Other techniques like adaptive forward-differencing <ref> [SC88] </ref> are, similarly, based on local properties. On the other hand, uniform sampling methods use global surface properties to determine their sampling size. This normally results in a conservative estimate of the required size, but the estimation is be done only once per patch.
Reference: [Sed83] <author> T.W. </author> <title> Sederberg. Implicit and Parametric Curves and Surfaces. </title> <type> PhD thesis, </type> <institution> Purdue University, </institution> <year> 1983. </year>
Reference-contexts: There is well-researched elimination theory <ref> [Sed83, MD92] </ref> that derives techniques for computing zeros. In particular, we use the method of resultants [Usp48]. The resultant of a set of polynomials is a function of the coefficients and variables of the equations which evaluates to zero iff the polynomials have a (non-trivial) common root.
Reference: [Seg95] <author> M. Segal, </author> <year> 1995. </year> <title> Silicon Graphics, </title> <type> Personal Communication. </type>
Reference-contexts: By factoring out parts of the computation that are independent of the view point and may be performed off-line, we are able to speed up the on-line computation of the sampling size. 1.5.3 Efficient processing of trimmed patches Traditionally, real-time tessellation of trimmed surfaces has been considered hard <ref> [Nas93, Seg95] </ref>. We have devised an efficient scheme to tessellate trimmed surfaces.
Reference: [Sei91] <author> R. Seidel. </author> <title> A simple and fast randomized algorithm for computing trapezoidal decompositions and for triangulating polygons. </title> <journal> Computational Geometry Theory & Applications, </journal> <volume> 1(1) </volume> <pages> 51-64, </pages> <year> 1991. </year> <month> 135 </month>
Reference-contexts: The trimming curve forms another polygonal chain, offset from the staircase. These two chains define a planar straight line graph (see Chapter II). 4. Triangulate the graph using one of the known efficient algorithms designed for this purpose, e.g. <ref> [Sei91, CCT92] </ref>. In this way we do not generate any extra triangles. The actual graph triangulation is the most expensive operation and takes O (n log fl n) time for n points on average. <p> Unfortunately, it is expensive to compute. It takes O (n log n) time to compute the Delaunay triangulation of a PSLG containing n vertices. In our system, we used the public domain implementation by Narkhede et al. [NM95] of a randomized incremental algorithm devised by Seidel <ref> [Sei91] </ref>. The [Sei91] algorithm triangulates PSLGs by first decomposing it into a number of monotone polygons, and then triangulating each monotone polygon. It can triangulate a PSLG with n vertices in O (n log fl n) expected time. <p> Unfortunately, it is expensive to compute. It takes O (n log n) time to compute the Delaunay triangulation of a PSLG containing n vertices. In our system, we used the public domain implementation by Narkhede et al. [NM95] of a randomized incremental algorithm devised by Seidel <ref> [Sei91] </ref>. The [Sei91] algorithm triangulates PSLGs by first decomposing it into a number of monotone polygons, and then triangulating each monotone polygon. It can triangulate a PSLG with n vertices in O (n log fl n) expected time. <p> It can triangulate a PSLG with n vertices in O (n log fl n) expected time. In practice, we have found the implementation of Narkhede et al. to be quite efficient. A brief description of the basic idea of <ref> [Sei91] </ref> follows. Seidel's algorithm starts by decomposing the PSLG into a set of trapezoids (see edges to the trapezoidal data structure in that order, updating the trapezoidization each time. It decomposes the trapezoids into monotone polygons in linear time (Figure 2.8 (c)). <p> Generate triangles for 1-cells using a diagonal. 5. The delimiting 0-1-cells form a set of staircase-like polygonal chains with a non-zero offset from the trimming curves as shown in Figure 5.1. This is a PSLG. 6. We trapezoidize the PSLG using <ref> [Sei91] </ref> and generate monotone polygons. 7. Finally we triangulate the monotone polygons using greedy triangulation [FM84]. The problem with the algorithm described above is that it generates triangles with edges greater than ffi even if the adjacent samples points are less than ffi 2 apart.
Reference: [SH93] <author> X. Sheng and B. Hirsch. </author> <title> Triangulation of trimmed surfaces in parametric space. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 24(8) </volume> <pages> 437-444, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Forsey et al. [FK90] present a simple recursive subdivision based scheme that tests the size and flatness of each sub-patch and approximates it with a rectangle once the rectangle is closer to it than a user-specified tolerance. Sheng et al. <ref> [SH93] </ref> present an adaptive tessellation algorithm for trimmed patches. This algorithm starts with a Delaunay triangulation of points on the patch. It then subdivides each edge longer than a user-specified value in object space. Klein et al. [KS95] similarly use Delaunay triangulation.
Reference: [SL87] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 21(4) </volume> <pages> 189-196, </pages> <year> 1987. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: The pixel is then assigned the color of that sub-patch. Catmull devised a fast subdivision algorithm for bicubic patches. While resulting in effective images, this method is quite slow due to the depth of subdivisions. The adaptive forward differencing of Shantz et al. <ref> [SL87, SC88] </ref> is similar in principle and handles 5 trimming curves. It converts the NURBS basis to a forward difference basis and scales the difference up or down depending on the speed of parametric curves on the surface.
Reference: [SLS + 96] <author> J. Shade, D. Lischinski, D. Salesin, T. DeRose, and J. Snyder. </author> <title> Hierarchical image caching. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 75-82, </pages> <year> 1996. </year>
Reference-contexts: Due to coherence, the image does not change much over a small time-interval. Hence this image, with a small warp to account for the change of view point, is re-displayed as texture <ref> [Ali96, SLS + 96] </ref>. The system must choose the part of the geometry to re-display using textures. This choice can significantly impact both rendering speed and realism.
Reference: [SZL92] <author> W.J. Schroeder, J.A. Zarge, and W.E. Lorensen. </author> <title> Decimation of triangle meshes. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 65-70, </pages> <year> 1992. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: These techniques are well suited for architectural environments but are not as effective for engineering models that are not easily partitioned into cells and portals. * Model reduction: Graphics literature contains description of a number of techniques to reduce the number of polygons used to represent a model <ref> [DZ81, Tur92, SZL92, DLW93, HDD + 93, Var94] </ref>. In general, these methods generate a sequence of discrete approximations of parts of a model, each at a coarser level of detail from the previous one.
Reference: [TFFH94] <author> S. Teller, C. Fowler, T. Funkhouser, and P Hanrahan. </author> <title> Partitionaing & ordering large radiosity computations. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 443-450. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: M N E, the patch is back-facing. 53 In general, the analytic method results in slightly more conservative estimates than the pseudo-map method described earlier, but it does not degrade in performance for values of e close to c, as the pseudo-map method does. 3.4 Hierarchical extension Hierarchical spatial partitioning <ref> [Cla76, FKN80, TFFH94, KM96] </ref> is routinely used in computer graphics to speed up visibility computations. We employ this well known technique and use a hierarchy of bounding boxes. The extension for view-frustum clipping is straightforward. We group patches, and compute volumes tightly enclosing the group.
Reference: [TS91] <author> S. Teller and C. Sequin. </author> <title> Visibility preprocessing for interactive walk-throughs. </title> <journal> ACM Computer Graphics, </journal> <volume> 25(4) </volume> <pages> 61-69, </pages> <year> 1991. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Spatial partitioning with the help of data structures like Octrees [Hun78] and BSP trees [FKN80] are regularly used by rendering systems to reduce the number of off-screen polygons passed to the graphics pipe. Recently Teller et al. <ref> [TS91] </ref> and Luebke et al. [LG95] described techniques to subdivide models into cells and portals and only render cells visible through these portals.
Reference: [Tur92] <author> G. Turk. </author> <title> Re-tiling polygonal surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 55-64, </pages> <year> 1992. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: These techniques are well suited for architectural environments but are not as effective for engineering models that are not easily partitioned into cells and portals. * Model reduction: Graphics literature contains description of a number of techniques to reduce the number of polygons used to represent a model <ref> [DZ81, Tur92, SZL92, DLW93, HDD + 93, Var94] </ref>. In general, these methods generate a sequence of discrete approximations of parts of a model, each at a coarser level of detail from the previous one.
Reference: [Usp48] <author> J.V. Uspensky. </author> <title> Theory of Equations. </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1948. </year>
Reference-contexts: There is well-researched elimination theory [Sed83, MD92] that derives techniques for computing zeros. In particular, we use the method of resultants <ref> [Usp48] </ref>. The resultant of a set of polynomials is a function of the coefficients and variables of the equations which evaluates to zero iff the polynomials have a (non-trivial) common root. There exist a variety of resultant formulations. We use Sylvester's resultant for two polynomial equations [Usp48]. <p> the method of resultants <ref> [Usp48] </ref>. The resultant of a set of polynomials is a function of the coefficients and variables of the equations which evaluates to zero iff the polynomials have a (non-trivial) common root. There exist a variety of resultant formulations. We use Sylvester's resultant for two polynomial equations [Usp48].
Reference: [Var94] <author> A. Varshney. </author> <title> Hierarchical Geometric Approximations. </title> <type> PhD thesis, </type> <institution> University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: These techniques are well suited for architectural environments but are not as effective for engineering models that are not easily partitioned into cells and portals. * Model reduction: Graphics literature contains description of a number of techniques to reduce the number of polygons used to represent a model <ref> [DZ81, Tur92, SZL92, DLW93, HDD + 93, Var94] </ref>. In general, these methods generate a sequence of discrete approximations of parts of a model, each at a coarser level of detail from the previous one.
Reference: [VB93] <author> M. Vigo and P. Brunet. </author> <title> Piecewise linear approximation of trimmed surface. </title> <editor> In G. Farin, H. Hagen, and H. Noltemeier, editors, </editor> <booktitle> Geometric Modeling, </booktitle> <year> 1993. </year>
Reference-contexts: Klein et al. [KS95] similarly use Delaunay triangulation. Their algorithm incrementally computes the farthest (in terms of Eu-clidean distance) patch point from the current approximation and inserts that point into the triangulation. The process terminates when this farthest point is closer than some user-specified tolerance. Vigo et al. <ref> [VB93] </ref> also start with a triangular surface approximation. Their algorithm recursively subdivides each triangle with an edge longer than a user-specified tolerance. Vlassopoulos [Vla90] proposes an algorithm that operates in terms of line segments in the domain.
Reference: [Vla90] <author> V. Vlassopoulos. </author> <title> Adaptive polygonization of parametric surface. </title> <journal> Visual Computer, </journal> <volume> 6 </volume> <pages> 291-298, </pages> <month> November </month> <year> 1990. </year> <month> 136 </month>
Reference-contexts: The process terminates when this farthest point is closer than some user-specified tolerance. Vigo et al. [VB93] also start with a triangular surface approximation. Their algorithm recursively subdivides each triangle with an edge longer than a user-specified tolerance. Vlassopoulos <ref> [Vla90] </ref> proposes an algorithm that operates in terms of line segments in the domain. This algorithm starts with a uniform grid and adds horizontal or vertical segments in the parts of the domain where the approximation has a high deviation from the surface or normal deviation. <p> Although adaptive subdivision schemes produce fewer triangles, none of the algorithms listed above are able to render more than a few hundred Bezier patches in real-time. The main reason is that they generally require too much time to perform the tessellation: more than a minute for some patches <ref> [Vla90] </ref>. We performed an empirical test to study the requirements on a real-time adaptive tessellation algorithm. 95 We stored a number of sequences of view points used in a user-run of our display system.
Reference: [Wal96] <institution> Unc walkthrough group video progress report, 1996. University of North Carolina at Chapel Hill. </institution>
Reference-contexts: Furthermore, empirical evidence shows that model sizes tend to grow ten fold every two years while the rendering speed only about doubles <ref> [Wal96] </ref>. These large models not only throttle the rendering pipeline, but also encounter system memory limitations. Researchers like Clark [Cla76] realized quite early that not all triangles need be sent to the graphics sub-system every frame.
Reference: [Wat95] <author> J. Watts. </author> <title> A practical approach to dynamic load balancing. </title> <type> Master's thesis, </type> <institution> Caltech Computer Science Department, </institution> <year> 1995. </year>
Reference-contexts: Some of the issues in such interactive rendering are described next. 1.4 Issues in polygonal approximations Some of the main issues to consider when using polygonal approximation for NURBS are: 1. NURBS form: A NURBS surface is commonly represented in terms of the standard basis <ref> [Far93, Wat95] </ref> as a mesh of control points and a pair of knot vectors. A point on the surface can be computed using matrix multiplication, forward-differencing, the Oslo algorithm, or variants of the Cox de Boor algorithm [Far93]. <p> See [de 78, Far93] for introduction to splines. We refer to the 3D space in which the NURBS (Non-Uniform Rational B-Spline) model is defined as object space <ref> [Wat95] </ref>. We use homogeneous coordinates. Viewing transformations, like rotation, translation, and scaling, map objects to eye space, and a perspective transformation maps them to the screen space. A curve or a surface may be represented algebraically. For example y = f (x) defines a curve. <p> Apart from making efficient use of hardware for rendering triangles, our method is able to easily employ techniques such as anti-aliasing, shadow generation, texture mapping and radiosity computation, which improve the quality of the final image and are known to work well on polygons <ref> [FVFH93, Wat95] </ref>. Although the actual surface approximation resides in the three-dimensional object space, it is much easier to perform the triangulation in the two-dimensional parametric domain of a patch.
Reference: [Whi78] <author> J.T. Whitted. </author> <title> A san line algorithm for computer display of curved surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 12(3) </volume> <pages> 8-13, </pages> <year> 1978. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: These algorithms process the screen-pixels in scan-line order. For each scan-line, the intersections of the scan-plane with the surfaces are used as spans. Whitted <ref> [Whi78] </ref> advocates subdividing surfaces at silhouettes and in areas of high curvature. This decomposes surfaces into elements, each of which are free of silhouettes except at their boundaries and are relatively flat.
Reference: [Whi79] <author> J.T. Whitted. </author> <title> An improved illumination model for shaded display. </title> <journal> ACM Computer Graphics, </journal> <volume> 13(3) </volume> <pages> 1-14, </pages> <year> 1979. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Most scan-line based methods exploit spatial coherence to speed up span computation. However, due to the inherent complexity of scan-line intersection, these algorithms are too slow for real-time display of large models. 6 1.2.3 Ray tracing Whitted <ref> [Whi79] </ref> presents one of the earliest methods of producing photo-realistic images of bicubic surfaces using ray tracing. He uses bounding volumes to eliminate surfaces not intersected by a ray.
Reference: [Won84] <author> E. Wong. </author> <title> Tessellation of variable order polynomial surface and polyhedral geometries. </title> <type> Master's thesis, </type> <institution> Computer Science Department, Rensselaer Polytechnic Institute, </institution> <year> 1984. </year> <month> 137 </month>
References-found: 94

