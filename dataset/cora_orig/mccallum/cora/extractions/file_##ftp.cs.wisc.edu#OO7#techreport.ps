URL: file://ftp.cs.wisc.edu/OO7/techreport.ps
Refering-URL: http://www.cs.wisc.edu/shore/shore.papers.html
Root-URL: 
Title: The OO7 Benchmark  
Author: Michael J. Carey David J. DeWitt Jeffrey F. Naughton 
Date: January 21, 1994  January 21  
Note: Version of  Note on Version of  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: The OO7 Benchmark represents a comprehensive test of OODBMS performance. In this report we describe the benchmark and present performance results from its implementation in four OODB systems. It is our hope that the OO7 Benchmark will provide useful insight for end-users evaluating the performance of OODB systems; we also hope that the research community will find that OO7 provides a database schema, instance, and workload that is This report is a modified version of the original OO7 technical report (the original report was written in Spring of 1993.) The most important change to the report is the introduction of Versant numbers, which were run in December of 1993. In this version of the report and in subsequent versions, we have eliminated our explanations of what we think is the cause each system's performance (the Spring 1993 report is available as "techreport.old.ps" via anonymous ftp from ftp.cs.wisc.edu.) This is in anticipation of future releases of numbers as we get them; revising the explanations for every new release of numbers is time consuming and would prevent the timely distribution of the numbers. useful for evaluating new techniques and algorithms for OODBMS implementation.
Abstract-found: 1
Intro-found: 1
Reference: [And90] <editor> T. Anderson et al. </editor> <booktitle> The HyperModel Benchmark. In Proceedings of the EDBT Conference, </booktitle> <address> Venice, Italy, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: "cold" time is the time required for the first iteration, reflecting the elapsed time starting with an empty cache, while the "warm" time measures the case where the cache has been fully initialized. 2.2 The HyperModel Benchmark Another benchmark directly related to OO7 is the HyperModel Benchmark developed at Tek-tronix <ref> [And90] </ref>. Starting with the initial Sun simple database operations benchmark, the developers of HyperModel set out to develop a more comprehensive engineering DBMS performance test suite based a hypertext application model. Compared to OO1, Hypermodel includes both a richer schema and a wider range of operations. <p> While HyperModel includes different read-only traversal operations, they seem to have been designed mainly to be different from one another, as opposed to probing the design/performance space of OODB systems. (In fact, the performance results in <ref> [And90] </ref> were presented as an appendix, with no attempt being made to draw insights or conclusions from the results.) No tests are included in HyperModel for object queries, updates to indexed vs. non-indexed object attributes, repeated object updates, the impact of transaction boundaries, or various other performance-related OODB features that OO7
Reference: [BDT83] <author> Dina Bitton, David J. DeWitt, and Carolyn Turbyfill. </author> <title> Benchmarking database systems: A systematic approach. </title> <booktitle> In Proceedings of the Ninth International Conference on Very large data bases, </booktitle> <pages> pages 8-19, </pages> <year> 1983. </year>
Reference-contexts: While doing this, we were also influenced significantly by the philosophy underlying the Wisconsin Benchmark for relational database systems <ref> [BDT83] </ref>; we wanted OO7 to be a relatively broad stress test for OODB systems, both in terms of function and system performance. 3 OO7 Database Description Since the OO7 Benchmark is designed to test many different aspects of system performance, its database structure and operations are nontrivial.
Reference: [CS92] <author> R. Cattell and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: Section 5 describes the benchmark's operations and discusses the experimental results for each operation as it is presented. Finally, Section 6 contains some conclusions and our plans for future work. 2 Related Work 2.1 The OO1 Benchmark The OO1 Benchmark <ref> [CS92] </ref> 2 , commonly referred to as the Sun Benchmark, was really the first "standard" benchmark that attempted to predict DBMS performance for engineering design applications. <p> Because of its early visibility and its simplicity, OO1 has became a de facto standard for OODB benchmarking. As such, it has been run on many of the current OODB products <ref> [CS92] </ref>. The database that the OO1 Benchmark is based upon consists of part objects and connections between them. Each part has five data fields: a part id, a type, an (x,y) coordinate pair, and a build date.
Reference: [DD88] <author> J. Duhl and C. Damon. </author> <title> A performance comparison of object and relational databases using the sun benchmark. </title> <booktitle> In Proceedings of the ACM OOPSLA Conference, </booktitle> <address> San Diego, California, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Engineers at Ontologic used the initial Sun Benchmark to study the performance of Vbase, their first OODB product offering <ref> [DD88] </ref>. Their reflections on the work provided a useful summary of some of that benchmark's shortcomings, including its lack of an opportunity for semantic object clustering (discussed further below), its very simple schema, and its lack of complex operations such as traversals.
Reference: [DFMV90] <author> David J. DeWitt, Philippe Futtersack, David Maier, and Fernando Velez. </author> <title> A study of three alternative workstation-server architectures for object-oreinted database systems. </title> <booktitle> In Proceedings of the VLDB Conference, </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Also in this area, researchers at Altair designed a complex object benchmark (ACOB) for use in studying alternative client/server process architectures <ref> [DFMV90] </ref>. Unlike previous OODB benchmarks, a notion of complex objects was included in the design; however, only a small number of traversal and update operations were involved, as these were sufficient to expose the tradeoffs among the software architectures of interest. <p> The ESM provides files of untyped objects of arbitrary size, B-trees, and linear hashing. The current version of the ESM (Version 2.2) [EXO92] uses a page-server architecture <ref> [DFMV90] </ref> where client processes request pages that they need from the server via TCP/IP. If the server cannot satisfy the request from its buffer pool, a disk I/O is initiated by invoking a disk process to perform the actual I/O operation. <p> The client and server buffer pools were set to 1,500 (12 MBytes) and 4,500 pages (36 Mbytes) respectively. Raw devices were used for both the log and data volumes. Objectivity/DB, Version 2.1 Unlike Exodus, Objectivity/DB, also available as DEC Object/DB V1.0, employs a file server architecture <ref> [DFMV90] </ref>. In this architecture, there is no server process for handling data. Instead, client processes access database pages via NFS. Since NFS does not provide locking, a separate lock server process is used. <p> Objects (which inherit from an Ontos defined root object class) are created in the context of one of three different storage managers. The "in-memory" storage manager manages transient objects much as the heap does in a standard C++ implementation. The "standard" storage manager implements an object-server architecture <ref> [DFMV90] </ref>, with both the unit of locking and the unit of transfer between the client and server processes being an individual object.
Reference: [EXO92] <author> The EXODUS Group. </author> <title> Using the EXODUS storage manager V2.0.2. </title> <type> Technical Documen tation, </type> <month> January </month> <year> 1992. </year>
Reference-contexts: The ESM provides files of untyped objects of arbitrary size, B-trees, and linear hashing. The current version of the ESM (Version 2.2) <ref> [EXO92] </ref> uses a page-server architecture [DFMV90] where client processes request pages that they need from the server via TCP/IP. If the server cannot satisfy the request from its buffer pool, a disk I/O is initiated by invoking a disk process to perform the actual I/O operation.
Reference: [FZT + 92] <author> Michael J. Franklin, Michael J. Zwilling, C. K. Tan, Michael J. Carey, and David J. DeWitt. </author> <title> Crash recovery in client-server EXODUS. </title> <booktitle> In Proceedings of the ACM-SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 165-174, </pages> <month> June </month> <year> 1992. </year> <month> 31 </month>
Reference-contexts: The ESM also provides concurrency control and recovery services. Locking is provided at the page and file levels (all the normal modes) with a special non-2PL protocol for index pages. Recovery is based on logging the changed portions of objects <ref> [FZT + 92] </ref>. Pages in the client buffer pool are cached across transaction boundaries, but locks must be reacquired from the server when cached pages are first used in subsequent transactions.
Reference: [Gra81] <author> Jim N. Gray et al. </author> <title> The recovery manager of the System R database manager. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2):223 - 242, </volume> <month> June </month> <year> 1981. </year>
Reference-contexts: The current release of Objectivity/DB provides only coarse grain locking, at the level of a container, and the current B-tree implementation cannot index objects distributed across multiple containers. Recovery is implemented via shadows <ref> [Gra81] </ref>. During the course of a transaction, updates are written to a shadow database. At commit time, these updates are applied carefully to the actual database with a journal being used to recover in the event that the commit fails. If the transaction aborts, the shadow database is simply deleted.
Reference: [RC89] <author> Joel E. Richardson and Michael J. Carey. </author> <title> Persistence in the E language: Issues and implementation. </title> <journal> Software Practice and Experience, </journal> <volume> 19, </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: Recovery is based on logging the changed portions of objects [FZT + 92]. Pages in the client buffer pool are cached across transaction boundaries, but locks must be reacquired from the server when cached pages are first used in subsequent transactions. The E programming language <ref> [RC89] </ref> extends C++, adding persistence as a basic storage class, collections of persistent objects, and B-tree indices. The services provided by E are relatively primitive compared to its commercial counterparts. There is no support for associations, iterators with selection predicates, queries, or versions.
Reference: [RKC87] <author> W. Rubenstein, M. Kubicar, and R. Cattell. </author> <title> Benchmarking simple database operations. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The specification of OO1 was based on its designers' experience with an initial "simple database operations" benchmark <ref> [RKC87] </ref> that they had implemented and used at Sun. Some operations in the initial benchmark were found to be highly correlated with others; e.g., small range queries added little insight beyond that obtained from exact-match lookups, so they were eliminated in OO1.
Reference: [SCD] <author> D. Schuh, M. Carey, and D. DeWitt. </author> <title> Persistence in E Revisited | Implementation Experiences. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: The current version of E is based on the GNU g++ 2.3.1 compiler. E uses the ESM for storing persistent objects. Operations on persistent objects are compiled into instructions for a virtual machine that are interpreted at runtime <ref> [SCD] </ref>; the current version of this interpreter is EPVM 3.0. EPVM 3.0 stores memory-resident persistent objects in the buffer pool of the ESM client process; pointers between such memory-resident objects are swizzled (and tested) in software as they are traversed, as was done in EPVM 2.0 [WD92].
Reference: [WC92] <author> M. Winslett and S. Chu. </author> <title> Database management systems for ECAD applications: Archi tecture and performance. </title> <booktitle> In Proceedings of the NSF Conference on Design and Manufacturing Systems, </booktitle> <address> Atlanta, Georgia, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Finally, Winslett and Chu recently studied OODB (and relational DB) system performance by porting an actual VLSI layout editor (the MAGIC editor from UC Berkeley) onto several systems <ref> [WC92] </ref>. However, since only the file I/O portions of MAGIC were modified, this work focused on the systems' save/restore performance rather than their performance when applications are operating on database objects. 2.4 Why Another Benchmark? OO1 and HyperModel both represent significant efforts in the area of OODB benchmarking.
Reference: [WD92] <author> S. White and D. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the VLDB Conference, </booktitle> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: EPVM 3.0 stores memory-resident persistent objects in the buffer pool of the ESM client process; pointers between such memory-resident objects are swizzled (and tested) in software as they are traversed, as was done in EPVM 2.0 <ref> [WD92] </ref>. When the ESM decides to replace a page, all pointers are unswizzled; if the page is dirty, log records for its updated objects are generated and sent to the server along with the page.
References-found: 13

