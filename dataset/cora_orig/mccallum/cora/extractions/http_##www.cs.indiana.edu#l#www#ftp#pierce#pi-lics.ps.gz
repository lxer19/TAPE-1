URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pi-lics.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Email: Benjamin.Pierce@inria.fr sad@dcs.ed.ac.uk  
Title: Typing and Subtyping for Mobile Processes  
Author: Benjamin Pierce Davide Sangiorgi 
Address: BP 105 King's Buildings 79153 Le Chesnay Cedex, France Edinburgh, EH9 3JZ, U.K.  
Affiliation: INRIA, Projet Formel Department of Computer Science  
Abstract: Milner's presentation of the -calculus includes a type system assigning arities to channels and enforcing a corresponding discipline in their use. We extend Milner's language of types by distinguishing between the ability to read from a channel, the ability to write to a channel, and the ability both to read and to write. This refinement gives rise to a natural subtype relation similar to those studied in typed -calculi. The greater precision of our type discipline yields stronger versions of some standard theorems about the -calculus. These can be used, for example, to obtain the validity of fi-reduction for the more efficient of Milner's encodings of the call-by-value -calculus, for which fi-reduction does not hold in the ordinary - calculus. We define the syntax, typing, subtyping, and operational semantics of our calculus, prove that the typing rules are sound, apply the system to Milner's - calculus encodings, and sketch extensions to higher-order process calculi and polymorphic typing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky. </author> <title> The lazy lambda calculus. </title> <editor> In D. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 65-116. </pages> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: As an example, we consider Milner's encoding of the lazy -calculus <ref> [1] </ref>, an untyped -calculus with a deterministic reduction strategy that evaluates only re-dexes at the extreme left of the term. We first present Milner's original version and then assign sorts to the channels in the translation.
Reference: [2] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyp-ing recursive types. </title> <booktitle> In Proceedings of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-118, </pages> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year> <note> Also available as DEC Systems Research Center Research Report number 62, August 1990. To appear in TOPLAS. </note>
Reference-contexts: The subsort relation is formalized in Section 2 using a notion of simulation of regular trees and treated using techniques similar to those developed by Amadio and Cardelli for combining subtyping and recursive types in typed -calculi <ref> [2] </ref>. Section 3 proves the soundness of the resulting type system. The greater precision of our type discipline yields stronger versions of some standard theorems about the -calculus. <p> Theorem: [Soundness and completeness of the algorithm] For all sorts S and T , ` S T iff Tree (S) tr Tree (T ). Proof sketch: The proof uses techniques similar to those developed by Amadio and Cardelli for -calculi with subtyping and recursive types <ref> [2, 5] </ref>. We first show that the algorithm is terminating on all inputs by arguing that the size of cannot increase without bound.
Reference: [3] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Com-binators and Functional Programming Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: The ref constructor, like our tag, is constrained by both requirements and thus behaves non-variantly in the subtype relation. A different analogy relates our definition of sub-sorting and the subtype relations found in some typed -calculi <ref> [3, 4, 21] </ref>. <p> The subsort relation now generates a natural subtype relation using the standard subtyping rule for function types. This extension essentially amounts to adjoining to our system a standard functional type system along the lines of Cardelli's simply typed -calculi with subtyping <ref> [3] </ref>. We conjecture that the soundness of typing can be shown via a straightforward translation from the enriched system of sorts into the first-order sorts described above, following the structure of Sangiorgi's translation of the higher-order -calculus into first-order -calculus.
Reference: [4] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: The ref constructor, like our tag, is constrained by both requirements and thus behaves non-variantly in the subtype relation. A different analogy relates our definition of sub-sorting and the subtype relations found in some typed -calculi <ref> [3, 4, 21] </ref>.
Reference: [5] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: Theorem: [Soundness and completeness of the algorithm] For all sorts S and T , ` S T iff Tree (S) tr Tree (T ). Proof sketch: The proof uses techniques similar to those developed by Amadio and Cardelli for -calculi with subtyping and recursive types <ref> [2, 5] </ref>. We first show that the algorithm is terminating on all inputs by arguing that the size of cannot increase without bound.
Reference: [6] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: This is equivalent to regarding alphabetic variable names | channel names and sort variables | as informal abbreviations for an underlying representation based on DeBruijn indices <ref> [6] </ref>, and implies the usual conventions about name capture during substitution, alpha-conversion, side-conditions concerning freshness of names, etc.
Reference: [7] <author> U. Engberg and M. Nielsen. </author> <title> A calculus of communicating systems with label-passing. </title> <type> Report DAIMI PB-208, </type> <institution> Computer Science Department, University of Aarhus, Denmark, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus [14] achieved a remarkable simplification and generalization of its predecessors (including CCS [11] and ECCS <ref> [7] </ref>) by focusing on the notion of naming and allowing the data values communicated along channels to themselves be channels.
Reference: [8] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus [25, 23]; it has been further studied by Turner [24] and Gay <ref> [8] </ref>, who consider most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> The algorithmic problem of inferring these annotations is deferred to future investigation (c.f. <ref> [24, 8] </ref>). Our basic syntactic categories are defined by the grammar in Figure 1. We use the metavariables S, T , and U for sorts; P , Q, and R for process expressions; and for sorting assumptions (or sortings); and a, b, c, etc. for channels (or names).
Reference: [9] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Carrying this program a step further leads us to wonder what role the polymorphism found in ML [10] or the polymorphic -calculus <ref> [9, 20] </ref> might play in typing for processes.
Reference: [10] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: A general theme in this paper has been the observation that a type system for a process calculus can be presented using concepts familiar from the literature on typed -calculi. Carrying this program a step further leads us to wonder what role the polymorphism found in ML <ref> [10] </ref> or the polymorphic -calculus [9, 20] might play in typing for processes.
Reference: [11] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Pren-tice Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus [14] achieved a remarkable simplification and generalization of its predecessors (including CCS <ref> [11] </ref> and ECCS [7]) by focusing on the notion of naming and allowing the data values communicated along channels to themselves be channels.
Reference: [12] <author> R. Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> final version in Journal of Mathem. Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: Moreover, the existence of natural embeddings of both lazy and call-by-value -calculi into the -calculus <ref> [12] </ref> suggests that it may form an appropriate foundation for the design of new programming languages. Milner extended the original -calculus to a polyadic -calculus, in which the atomic unit of communication is finite tuples of names instead of single names [13]. <p> For instance, these theorems play a pivotal role in the proof of validity of fi-reduction for Milner's encodings of -calculus <ref> [12] </ref> as well as in the proof of representability of higher-order -calculus in first-order -calculus [23]. <p> trigger m to be transmitted outside of the syntactic scope of P , Q, and R as long as each such transmission places an appropriate static restriction on their possible use by the receiver. 5.2 Encoding the call-by-value -calculus In the original version of his paper on Functions as Processes <ref> [12] </ref>, Milner presented two candidates, V and V 0 , for the encoding of call-by-value -calculus [19] in -calculus. The encoding V 0 is more efficient than V, since in V the number of steps required to simulate a fi-reduction may increase as the computation proceeds. But the proofs in [12] <p> <ref> [12] </ref>, Milner presented two candidates, V and V 0 , for the encoding of call-by-value -calculus [19] in -calculus. The encoding V 0 is more efficient than V, since in V the number of steps required to simulate a fi-reduction may increase as the computation proceeds. But the proofs in [12] were only given for V; the analysis of V 0 was left open. <p> Later, Sangiorgi [23] showed that in the standard -calculus, fi-reduction is not valid for V 0 | that is, V 0 [[(x:M )y:N ]]hpi and V 0 [[M f y:N =xg]]hpi are not necessarily equivalent. (The final version of <ref> [12] </ref>, which appeared in the Journal of Mathematical Structures, was written after the results in [23] were known and presents only the encoding V.) Intuitively, the problems with V 0 are similar to those arising in equation (1) above: the external environment may obtain a trigger and then use it in
Reference: [13] <author> R. Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> LFCS, Dept. of Comp. Sci., Edinburgh Univ., </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: Milner extended the original -calculus to a polyadic -calculus, in which the atomic unit of communication is finite tuples of names instead of single names <ref> [13] </ref>. <p> We call a sort S guarded if it has the form S = ( ~ S) I . We often write the process expression ff: 0, where ff is an input or output prefix, as just ff. Also, following Milner <ref> [13] </ref>, we introduce an explicit replication operator ! instead of allowing systems of recursive definitions of process expressions; !P stands for the parallel composition of any finite number of copies of P . To simplify the presentation, we omit the notational devices of abstraction and concretion [13] and the basic operations <p> Also, following Milner <ref> [13] </ref>, we introduce an explicit replication operator ! instead of allowing systems of recursive definitions of process expressions; !P stands for the parallel composition of any finite number of copies of P . To simplify the presentation, we omit the notational devices of abstraction and concretion [13] and the basic operations of summation of processes and matching of names. We believe that our results can be extended straightforwardly to a calculus including summation, abstraction, and concretion, while the case of matching is more delicate; Section 6 discusses these extensions. <p> = I (Sf A: S =Ag): Similarly, I i extracts the I/O annotation of the ith component of a sort: I i ((S 1 ::S n ) I ) = I (S i ) andI i (A: S) = I i (Sf A: S =Ag): 2.2 Reduction Semantics Following Milner <ref> [13] </ref>, we present the operational semantics of the -calculus using two relations: a structural equivalence on process terms that permits the rearrangement of parallel compositions, replications, and restrictions so that the participants in a potential communication can be brought into immediate proximity; and a reduction relation that describes the act of
Reference: [14] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Milner, Parrow, and Walker's -calculus <ref> [14] </ref> achieved a remarkable simplification and generalization of its predecessors (including CCS [11] and ECCS [7]) by focusing on the notion of naming and allowing the data values communicated along channels to themselves be channels. <p> abort the others, and a matching operator [a = b]P , which allows P to proceed only if a and b are the same channel. (It seems that both operators may often be avoided in practice, although they play an important theoretical role, for instance, in axiomatisations of behavioral equivalences <ref> [14, 18] </ref>.) Our basic results should extend straightforwardly to summation, whose behavior under typing is exactly like that of parallel composition. Matching, however, is more problematic, since adding it in unrestricted form would destroy some of the basic results presented in section 5.
Reference: [15] <author> R. Milner and D. Sangiorgi. </author> <title> Barbed bisimulation. </title> <editor> In W. Kuich, editor, </editor> <booktitle> 19th ICALP, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 685-695. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The most popular way of defining behavioral equivalence on processes is via the notion of bisimula-tion. In <ref> [15, 23] </ref>, Milner and Sangiorgi proposed barbed bisimulation as a tool for uniformly defining bisimulation-based equivalences in different calculi.
Reference: [16] <author> F. Nielson. </author> <title> The typed -calculus with first-class processes. </title> <booktitle> In Proc. PARLE `89, volume 366 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: This stands in contrast to recent proposals <ref> [17, 16] </ref> that attempt to assign more informative types to processes, describing the sets of channels on which processes may communicate, their interaction protocols, freedom from deadlock, etc.
Reference: [17] <author> O. Nierstrasz. </author> <title> Towards an object calculus. </title> <editor> In M. Tokoro, O. Nierstrasz, P. Wegner, and A. Yonezawa, editors, </editor> <booktitle> ECOOP '91 Workshop on Object Based Concurrent Programming, </booktitle> <address> Geneva, Switzerland, </address> <year> 1991, </year> <booktitle> volume 612 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: This stands in contrast to recent proposals <ref> [17, 16] </ref> that attempt to assign more informative types to processes, describing the sets of channels on which processes may communicate, their interaction protocols, freedom from deadlock, etc.
Reference: [18] <author> Joachim Parrow and Davide Sangiorgi. </author> <title> Algebraic theory for name-passing calculi. </title> <note> In preparation, </note> <year> 1993. </year>
Reference-contexts: abort the others, and a matching operator [a = b]P , which allows P to proceed only if a and b are the same channel. (It seems that both operators may often be avoided in practice, although they play an important theoretical role, for instance, in axiomatisations of behavioral equivalences <ref> [14, 18] </ref>.) Our basic results should extend straightforwardly to summation, whose behavior under typing is exactly like that of parallel composition. Matching, however, is more problematic, since adding it in unrestricted form would destroy some of the basic results presented in section 5.
Reference: [19] <author> G.D. Plotkin. </author> <title> Call by name, call by value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: as long as each such transmission places an appropriate static restriction on their possible use by the receiver. 5.2 Encoding the call-by-value -calculus In the original version of his paper on Functions as Processes [12], Milner presented two candidates, V and V 0 , for the encoding of call-by-value -calculus <ref> [19] </ref> in -calculus. The encoding V 0 is more efficient than V, since in V the number of steps required to simulate a fi-reduction may increase as the computation proceeds. But the proofs in [12] were only given for V; the analysis of V 0 was left open.
Reference: [20] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: Carrying this program a step further leads us to wonder what role the polymorphism found in ML [10] or the polymorphic -calculus <ref> [9, 20] </ref> might play in typing for processes.
Reference: [21] <author> John Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 185. </note>
Reference-contexts: The ref constructor, like our tag, is constrained by both requirements and thus behaves non-variantly in the subtype relation. A different analogy relates our definition of sub-sorting and the subtype relations found in some typed -calculi <ref> [3, 4, 21] </ref>.
Reference: [22] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: We write ` S &gt; &lt; T when ` S T and ` T S. There is a close analogy between channel sorts and the reference types found in some programming languages. In Reynolds' language Forsythe <ref> [22] </ref>, for example, the type of a mutable storage cell holding a value of type T can be written ref (T ), an abbreviation for sink (T )^source (T ). (Reynolds's actual notation is slightly different.) That is, a mutable cell containing an element of T is modeled as a connected
Reference: [23] <author> D. Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus <ref> [25, 23] </ref>; it has been further studied by Turner [24] and Gay [8], who consider most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> The most popular way of defining behavioral equivalence on processes is via the notion of bisimula-tion. In <ref> [15, 23] </ref>, Milner and Sangiorgi proposed barbed bisimulation as a tool for uniformly defining bisimulation-based equivalences in different calculi. <p> By itself, barbed bisimulation is a rather coarse relation. Better discriminating power is achieved by considering the induced congruence, called barbed congruence. It is proved in <ref> [23] </ref> that barbed congruence coincides in both CCS and -calculus with the ordinary bisimilarity congruences. In a sorted calculus, the processes being compared must obey the same sorting and the contexts employed must be compatible with this sorting. <p> For instance, these theorems play a pivotal role in the proof of validity of fi-reduction for Milner's encodings of -calculus [12] as well as in the proof of representability of higher-order -calculus in first-order -calculus <ref> [23] </ref>. However, in the basic - calculus the theorems must be accompanied by a fairly heavy side condition on the use of names in P , Q, and R, namely that m may occur free only as the channel along which an output occurs. <p> The encoding V 0 is more efficient than V, since in V the number of steps required to simulate a fi-reduction may increase as the computation proceeds. But the proofs in [12] were only given for V; the analysis of V 0 was left open. Later, Sangiorgi <ref> [23] </ref> showed that in the standard -calculus, fi-reduction is not valid for V 0 | that is, V 0 [[(x:M )y:N ]]hpi and V 0 [[M f y:N =xg]]hpi are not necessarily equivalent. (The final version of [12], which appeared in the Journal of Mathematical Structures, was written after the results <p> that in the standard -calculus, fi-reduction is not valid for V 0 | that is, V 0 [[(x:M )y:N ]]hpi and V 0 [[M f y:N =xg]]hpi are not necessarily equivalent. (The final version of [12], which appeared in the Journal of Mathematical Structures, was written after the results in <ref> [23] </ref> were known and presents only the encoding V.) Intuitively, the problems with V 0 are similar to those arising in equation (1) above: the external environment may obtain a trigger and then use it in incorrectly (i.e. in input position). <p> A more significant extension involves adding higher-order communication | communication of processes and abstraction of processes on both channels and processes. Following Sangiorgi <ref> [23] </ref>, we can enrich our language of sorts to include descriptions of channels carrying processes | e.g. (ok ) | channels carrying processes abstracted on processes | e.g. (ok !ok ) | and so on.
Reference: [24] <author> David N. Turner, </author> <year> 1992. </year> <type> Ph.D. thesis, </type> <institution> LFCS, University of Edinburgh. </institution> <note> In preparation. </note>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus [25, 23]; it has been further studied by Turner <ref> [24] </ref> and Gay [8], who consider most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions. <p> = phj 1 i : phj 2 i : : : : ; then we expect that executing the program (- p:(T )) (P j C 1 j C 2 ) should 2 We learned recently that a by-structure presentation of Milner's -calculus sorting has been studied independently by Turner <ref> [24] </ref>. His system is essentially identical to the fragment of ours in which subtyping is omitted. result in the print jobs represented by j 1 and j 2 eventually being received and processed, in that order, by the printer process P . <p> The algorithmic problem of inferring these annotations is deferred to future investigation (c.f. <ref> [24, 8] </ref>). Our basic syntactic categories are defined by the grammar in Figure 1. We use the metavariables S, T , and U for sorts; P , Q, and R for process expressions; and for sorting assumptions (or sortings); and a, b, c, etc. for channels (or names). <p> by the process a (A; x:(A) + ; y:A) : xhyi : 0, which reads a pair of channels from a and outputs the second along the first. (A similar polymorphic extension of -calculus sorting has been proposed independently by Turner; it will be described in his forthcoming Ph.D. thesis <ref> [24] </ref>.) Acknowledgements This research was begun while both authors were visitors at INRIA-Roquencourt, in projects Formel and Para, and was partially supported by ESPRIT Basic Research Action "TYPES" and "CONFER." Our ideas were influenced by many conversations with Robin Milner and David N. Turner.
Reference: [25] <author> David Walker. </author> <title> Objects in the pi-calculus. </title> <note> To appear in Information and Computation, </note> <year> 1992. </year>
Reference-contexts: Milner's sort discipline plays an essential role in later papers on properties of the -calculus <ref> [25, 23] </ref>; it has been further studied by Turner [24] and Gay [8], who consider most general sortings. Our typing discipline retains the basic character of Milner's, while extending it in two dimensions.
References-found: 25

