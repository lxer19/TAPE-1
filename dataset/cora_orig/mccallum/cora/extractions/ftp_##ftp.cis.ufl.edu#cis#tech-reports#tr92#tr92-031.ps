URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-031.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: hanson@cis.ufl.edu  widom@almaden.ibm.com  
Title: An Overview of Production Rules in Database Systems  
Author: Eric N. Hanson Jennifer Widom 
Date: 7 October 1992  
Address: Gainesville, FL 32611 USA  650 Harry Road San Jose, CA 95120 USA  
Affiliation: Dept. of Computer and Information Sciences University of Florida  IBM Almaden Research Center  University of Florida  
Pubnum: CIS-TR-92-031  
Abstract: Database researchers have recognized that integrating a production rules facility into a database system provides a uniform mechanism for a number of advanced database features including integrity constraint enforcement, derived data maintenance, triggers, protection, version control, and others. In addition, a database system with rule processing capabilities provides a useful platform for large and efficient knowledge-base and expert systems. Database systems with production rules are referred to as active database systems, and the field of active database systems has indeed been active. This paper summarizes current work in active database systems and suggests future research directions. Topics covered include database rule languages, rule processing semantics, and implementation issues. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken, J. Widom, and J. M. Hellerstein. </author> <title> Behavior of database production rules: Termination, confluence, and observable determinism. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: It is an undecidable problem to determine in advance whether rules are guaranteed to terminate, although conservative algorithms have been proposed that warn the rule programmer when looping is possible <ref> [1] </ref>. A run-time solution to detecting and preventing infinite loops is to provide a forward-chaining (i.e. rule triggering) depth limit. In this case, the number of rules executed during rule processing is monitored; if the limit is reached, rule processing is terminated.
Reference: [2] <institution> ASK Computer Co. </institution> <note> INGRES/SQL Reference Manual, Version 6.4, </note> <year> 1992. </year>
Reference-contexts: In the commercial 2 realm, some production rule capabilities are provided in Ingres <ref> [2] </ref>, InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3. <p> Initial experimentation with such applications has been performed in the context of HiPAC [32], and the commercial Ingres system includes rule processing facilities and a mechanism for "asynchronous multicast" that make such applications possible in practice <ref> [2] </ref>. Examples of potential application domains using this approach include: Real-time information display: For example, an application might create a new window on a stock trader's workstation whenever the price of a certain stock exceeds a threshold.
Reference: [3] <author> C. Beeri and T. Milo. </author> <title> A model for active object oriented database. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: A number of other research projects are not described in detail in this paper, either because the projects are fairly preliminary, because their features do not differ significantly from projects that are covered, or simply for lack of space; these are described in <ref> [3, 10, 15, 31, 37, 39] </ref>. In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3.
Reference: [4] <author> L. Brownston, R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1985. </year> <month> 27 </month>
Reference-contexts: The production rule paradigm originated in the field of Artificial Intelligence (AI) with expert systems rule languages such as OPS5 <ref> [4] </ref>. While some work has been done on using database systems to provide efficient underlying support for OPS5 (e.g. [38, 42]), in this paper we focus on database systems with fully integrated production rules facilities, often referred to as active database systems. <p> Regarding conflict resolution, recall from Section 3.5 that each Ariel rule is assigned a numeric priority, but that the assignments need not be unique. In the case of rules with the same priority, Ariel uses a mechanism similar to that used by OPS5 <ref> [4] </ref>. Conflict resolution in Ariel proceeds as follows: 1. Pick the rule (s) with highest numeric priority 2. If there's a tie, pick the rule (s) most recently matched by changes 3. If there's still a tie, pick the rule (s) whose condition is the most selective 4. <p> Finally, in HiPAC triggering data is passed to the rule's action through explicitly specified parameters. 5.5 Rule Programming Support Programming tools for expert systems rule languages have evolved to include many useful features that support the rule programmer. Many of these features, such as those found in OPS5 <ref> [4] </ref> and KEE [27], would be valuable for database rule programming as well. These include the ability to trace rule execution, to display the current set of triggered rules, to query and browse the set of rules, and to cross-reference rules and data.
Reference: [5] <author> S. Ceri. </author> <title> A declarative approach to active databases. </title> <booktitle> In Proceedings of the Eighth International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: One suggested approach to application development treats database rules as "assembly language", automatically generating rules from higher level specifications <ref> [5, 7, 8] </ref>. While this approach works well for a number of standard applications, there will always be a need to develop applications using rules directly. In addition, considerable work is needed on increasing the communication capability between database rules and applications; this is discussed below.
Reference: [6] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logic Programming and Databases. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: We focus on active database systems and do not cover deductive database systems here. Readers interested in deductive database systems can consult the extensive literature on the subject, e.g. <ref> [6, 43] </ref>. This paper provides a broad survey of current work in active database systems, covering general issues and concepts as well as describing the several research projects mentioned above. (As a default, the Ariel system is used for illustrative purposes when appropriate.) The paper is organized as follows.
Reference: [7] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for constraint maintenance. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Data Bases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: One suggested approach to application development treats database rules as "assembly language", automatically generating rules from higher level specifications <ref> [5, 7, 8] </ref>. While this approach works well for a number of standard applications, there will always be a need to develop applications using rules directly. In addition, considerable work is needed on increasing the communication capability between database rules and applications; this is discussed below.
Reference: [8] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: One suggested approach to application development treats database rules as "assembly language", automatically generating rules from higher level specifications <ref> [5, 7, 8] </ref>. While this approach works well for a number of standard applications, there will always be a need to develop applications using rules directly. In addition, considerable work is needed on increasing the communication capability between database rules and applications; this is discussed below.
Reference: [9] <author> S. Chakravarthy et al. HiPAC: </author> <title> A research project in active, time-constrained database management (final report). </title> <type> Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, Cambridge, Massachusetts, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: A number of powerful prototype systems have been built in the research context, while more limited production rule features are appearing in products and proposed standards. Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC <ref> [9, 11, 32] </ref>, Ode [19], POSTGRES [40, 41], RPL [13], and Starburst [45, 46]. <p> Finally, as mentioned in Section 3.5, HiPAC rules may have relative ordering, and this ordering is used to influence the serialization order of concurrently executing nested sub-transactions. Further details on HiPAC's rule language and rule processing semantics appear in <ref> [9, 11, 32] </ref>. 4.3 Ode As described in Section 3.2, there are two types of rules in Ode, constraint rules and trigger rules, hereafter referred to as constraints and triggers. Constraints and triggers have very different execution semantics, so we describe each in turn. <p> Other alternatives are to terminate execution of that rule and continue rule processing, to return to the state preceding rule processing and resume database processing, or to restart rule processing. The nested transaction model used in HiPAC takes some of these possibilities into account <ref> [9] </ref>. <p> Using this implementation, a simulated financial trading application was coded, with most control of the application embedded in rules. Further details on HiPAC's implementation and applications appear in <ref> [9, 32] </ref>. Rule processing in Ode is built into the implementation of O++, a database programming language extension to C++. For each Ode class, the hard constraints, soft constraints, and triggers defined for that class are packaged into three system-defined methods: hard constraints (), soft constraints () and triggers ().
Reference: [10] <author> D. Cohen. </author> <title> Compiling complex database transition triggers. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: A number of other research projects are not described in detail in this paper, either because the projects are fairly preliminary, because their features do not differ significantly from projects that are covered, or simply for lack of space; these are described in <ref> [3, 10, 15, 31, 37, 39] </ref>. In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3.
Reference: [11] <author> U. Dayal et al. </author> <title> The HiPAC project: Combining active databases and timing constraints. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: A number of powerful prototype systems have been built in the research context, while more limited production rule features are appearing in products and proposed standards. Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC <ref> [9, 11, 32] </ref>, Ode [19], POSTGRES [40, 41], RPL [13], and Starburst [45, 46]. <p> Finally, as mentioned in Section 3.5, HiPAC rules may have relative ordering, and this ordering is used to influence the serialization order of concurrently executing nested sub-transactions. Further details on HiPAC's rule language and rule processing semantics appear in <ref> [9, 11, 32] </ref>. 4.3 Ode As described in Section 3.2, there are two types of rules in Ode, constraint rules and trigger rules, hereafter referred to as constraints and triggers. Constraints and triggers have very different execution semantics, so we describe each in turn.
Reference: [12] <author> C. de Maindreville and E. Simon. </author> <title> A production rule based approach to deductive databases. </title> <booktitle> In Proceedings of the Fourth International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1988. </year>
Reference-contexts: Firing the selected rule for all instantiations in each phase rather than only one is sometimes known as firing rules to saturation <ref> [12] </ref>. The semantic and practical differences between firing single instantiations and firing rules to saturation are explored in RDL1, a production rule implementation of a deductive database system [12, 30]. <p> The semantic and practical differences between firing single instantiations and firing rules to saturation are explored in RDL1, a production rule implementation of a deductive database system <ref> [12, 30] </ref>. A related modification to the recognize-act cycle is set-oriented firing, in which the selected rule's action is executed once for the entire set of instantiations [21]. Ariel and Starburst both use a form of set-oriented firing; see Sections 4.1 and 4.5.
Reference: [13] <author> L. M. L. Delcambre and J. N. Etheredge. </author> <title> The Relational Production Language: A production language for relational databases. </title> <booktitle> In Proceedings of the Second International Conference on Expert Database Systems, </booktitle> <month> April </month> <year> 1988. </year>
Reference-contexts: Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC [9, 11, 32], Ode [19], POSTGRES [40, 41], RPL <ref> [13] </ref>, and Starburst [45, 46].
Reference: [14] <author> L. M. L. Delcambre and J. N. Etheredge. </author> <title> A self-controlling interpreter for the relational production language. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Rule actions are executed by submitting data manipulation commands to the underlying DBMS. While this approach is sufficient for experimenting with a database rule language, it does not provide the functionality or efficiency of the fully integrated approach. Further details on the implementation of RPL appear in <ref> [14] </ref>. In POSTGRES, two different mechanisms are implemented for rules, tuple level processing and query rewrite. When a rule is created, the user selects which mechanism is to be used for that rule.
Reference: [15] <author> O. Diaz, N. Patom, and P. Gray. </author> <title> Rule management in object-oriented databases: A uniform approach. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: A number of other research projects are not described in detail in this paper, either because the projects are fairly preliminary, because their features do not differ significantly from projects that are covered, or simply for lack of space; these are described in <ref> [3, 10, 15, 31, 37, 39] </ref>. In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3.
Reference: [16] <institution> Digital Equipment Corporation. </institution> <note> Rdb/VMS - SQL Reference Manual, </note> <month> November </month> <year> 1991. </year>
Reference-contexts: In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb <ref> [16] </ref>, and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3. Products and standards are not covered in this paper since their capabilities are subsumed by research projects that are covered.
Reference: [17] <author> K. P. Eswaran. </author> <title> Specifications, implementations and interactions of a trigger subsystem in an integrated database system. </title> <type> Technical Report RJ 1820, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, California, </address> <year> 1976. </year>
Reference-contexts: Database researchers have observed for some time that if a database system also provides mechanisms for creating and processing production rules (also referred to in this context as triggers or alerters), then the database system becomes active, and many useful capabilities can be provided by this active behavior <ref> [17, 34] </ref>. The production rule paradigm originated in the field of Artificial Intelligence (AI) with expert systems rule languages such as OPS5 [4].
Reference: [18] <author> C. L. Forgy. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern match problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year> <month> 28 </month>
Reference-contexts: Further details appear in [24, 25]. Ariel's condition testing mechanism uses an algorithm called A-TREAT, which is a descendent of the TREAT algorithm used in some main-memory production rule systems [33]. 21 TREAT itself is a descendant of the pioneering Rete algorithm <ref> [18] </ref>, developed for OPS5. These algorithms use discrimination networks to efficiently compare large collections of patterns to large collections of data without iterating over the collections. Tokens representing modified data items are passed through the networks. <p> When a token reaches a p-node, it enters the corresponding rule's conflict set. Further details on the Rete algorithm can be found in <ref> [18] </ref>. An advantage of the Rete algorithm is its ability to reuse temporary results; a disadvantage is its need to maintain and store the contents of fi-memory nodes. The TREAT algorithm eliminates the use of fi-memory nodes; for details see [33].
Reference: [19] <author> N. Gehani and H. V. Jagadish. </author> <title> Ode as an active database: Constraints and triggers. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: A number of powerful prototype systems have been built in the research context, while more limited production rule features are appearing in products and proposed standards. Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC [9, 11, 32], Ode <ref> [19] </ref>, POSTGRES [40, 41], RPL [13], and Starburst [45, 46]. <p> Coupling modes originated in the HiPAC project but subsequently have been discussed in the context of other active database systems, e.g. <ref> [19, 37] </ref>. <p> Once activated, a trigger can be deactivated; if a trigger is designated as once-only then it is deactivated automatically after it is triggered. Further details on Ode's rule language and rule processing semantics appear in <ref> [19] </ref>. 4.4 POSTGRES In POSTGRES, unlike in other relational active database systems, rule processing is invoked immediately after any modification to any tuple that triggers and satisfies the condition of one or more rules. (This sometimes is referred to as tuple-oriented rule processing, as opposed to set-oriented as in Ariel and <p> Further details on the implementation of rules in Ode, including a number of suggested refinements, appear in <ref> [19] </ref>. 5.3 Condition Testing In many active database systems, including HiPAC, Ode, RPL, and Starburst, rule conditions are tested during rule processing by querying the database. Although this is a straightforward approach, there is clear potential for poor performance.
Reference: [20] <author> N. Gehani, H. V. Jagadish, and O. Shmueli. </author> <title> Event specification in an active object-oriented database. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: In RPL, rules are purely pattern-based, so no triggering events are specified. We next consider the object-oriented systems. In Ode, rules are purely pattern-based. (Recent work in the context of the Ode project has suggested a rich event specification language <ref> [20] </ref>, but this event language has not been integrated with Ode's rule language.) The HiPAC project allows by far the most complex triggering events of any database rule language, although it must be stated that the HiPAC language has not been implemented to the same extent as the other projects covered
Reference: [21] <author> D. N. Gordin and A. J. Pasik. </author> <title> Set-oriented constructs: From Rete rule bases to database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: A related modification to the recognize-act cycle is set-oriented firing, in which the selected rule's action is executed once for the entire set of instantiations <ref> [21] </ref>. Ariel and Starburst both use a form of set-oriented firing; see Sections 4.1 and 4.5. In active database systems, where production rule processing is fully integrated with conventional database activity (e.g. queries, modifications, transactions), a pure recognize-act semantics is not always appropriate or adequate.
Reference: [22] <author> A. Gupta. </author> <title> Parallelism in Production Systems. </title> <publisher> Pitman Publishing, </publisher> <year> 1987. </year>
Reference-contexts: Applying parallelism: For some database rule languages, parallelism in rule condition testing may be necessary to achieve desired levels of performance. Parallelism has been used successfully to increase the performance of the OPS5 rule language both on a shared memory multiprocessor <ref> [22] </ref> and on a fine-grain parallel machine [29].
Reference: [23] <author> L. Haas et al. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 143-160, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Unfortunately, the semantics can differ between the two approaches, as explained in [41]. Further details on the implementation of rules in POSTGRES appear in [40, 41]. The Starburst DBMS has as one of its primary goals extensibility <ref> [23] </ref>, and the rule system implementation relies on Starburst's extensibility features. The attachment feature is used to monitor data modifications that are of interest to rules. These modifications are stored in a main-memory data structure called a transition log.
Reference: [24] <author> E. N. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: A number of powerful prototype systems have been built in the research context, while more limited production rule features are appearing in products and proposed standards. Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel <ref> [24] </ref>, HiPAC [9, 11, 32], Ode [19], POSTGRES [40, 41], RPL [13], and Starburst [45, 46]. <p> Further details on Ariel's rule language and rule processing semantics appear in <ref> [24] </ref>. 4.2 HiPAC Before describing run-time rule processing in HiPAC, it is necessary to introduce the concept of coupling modes. Coupling modes originated in the HiPAC project but subsequently have been discussed in the context of other active database systems, e.g. [19, 37]. <p> However, the overhead of condition testing still occurs, in the maintenance of markers through data modifications. The most sophisticated approach to condition testing in a database rule system is taken in Ariel, so we outline Ariel's condition testing mechanism here. Further details appear in <ref> [24, 25] </ref>. Ariel's condition testing mechanism uses an algorithm called A-TREAT, which is a descendent of the TREAT algorithm used in some main-memory production rule systems [33]. 21 TREAT itself is a descendant of the pioneering Rete algorithm [18], developed for OPS5. <p> When a virtual ff-memory node is accessed, the predicate stored in the node is processed to derive the value of the node; details are given in <ref> [24] </ref>. 22 Finally, in addition to the performance enhancement techniques mentioned above, Ariel has generalized the notion of tokens and ff-memory nodes from the standard TREAT network in order to effectively test both event- and transition-based conditions with a minimum of restrictions on how such conditions can be used [24]. 5.4 <p> in <ref> [24] </ref>. 22 Finally, in addition to the performance enhancement techniques mentioned above, Ariel has generalized the notion of tokens and ff-memory nodes from the standard TREAT network in order to effectively test both event- and transition-based conditions with a minimum of restrictions on how such conditions can be used [24]. 5.4 Action Execution In all database rule systems, rule actions are executed by submitting operations to the DBMS query processor. However, most systems need some additional mechanism for binding the data that triggered a rule to operations in the rule's action.
Reference: [25] <author> E. N. Hanson, M. Chaabouni, C.-H. Kim, and Y.-W. Wang. </author> <title> A predicate matching algorithm for database rule systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: However, the overhead of condition testing still occurs, in the maintenance of markers through data modifications. The most sophisticated approach to condition testing in a database rule system is taken in Ariel, so we outline Ariel's condition testing mechanism here. Further details appear in <ref> [24, 25] </ref>. Ariel's condition testing mechanism uses an algorithm called A-TREAT, which is a descendent of the TREAT algorithm used in some main-memory production rule systems [33]. 21 TREAT itself is a descendant of the pioneering Rete algorithm [18], developed for OPS5. <p> This index makes use of an interval binary search tree to efficiently test conditions that specify closed intervals (e.g. const 1 &lt; table.column const 2 ), open intervals (e.g. const &lt; table.column), or points (e.g. const = table.column). Details of this mechanisms can be found in <ref> [25] </ref>. A different data structure called the interval skip list can be used in place of the interval binary search tree, with similar performance and a more straightforward implementation [26].
Reference: [26] <author> E. N. Hanson and T. Johnson. </author> <title> The interval skip list: A data structure for finding all intervals that overlap a point. </title> <type> Technical Report TR92-016, </type> <institution> Computer and Information Sciences Department, University of Flordia, Gainesville, Florida, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Details of this mechanisms can be found in [25]. A different data structure called the interval skip list can be used in place of the interval binary search tree, with similar performance and a more straightforward implementation <ref> [26] </ref>. As a second optimization, Ariel can reduce the amount of state information stored in its discrimination network by replacing ff-memory nodes with virtual ff-memory nodes. Virtual ff-memory nodes contain only the predicate associated with the node, not the tuples matching the predicate.
Reference: [27] <author> S. Hedberg and M. Steizner. </author> <title> Knowledge Engineering Environment (KEE) System: Summary of Release 3.1. </title> <publisher> Intellicorp Inc., </publisher> <month> July </month> <year> 1987. </year>
Reference-contexts: Many of these features, such as those found in OPS5 [4] and KEE <ref> [27] </ref>, would be valuable for database rule programming as well. These include the ability to trace rule execution, to display the current set of triggered rules, to query and browse the set of rules, and to cross-reference rules and data.
Reference: [28] <author> L. Howe. </author> <title> Sybase data integrity for on-line applications. </title> <type> Technical report, </type> <institution> Sybase Inc., </institution> <year> 1986. </year>
Reference-contexts: In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase <ref> [28] </ref>. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3. Products and standards are not covered in this paper since their capabilities are subsumed by research projects that are covered.
Reference: [29] <author> M. A. Kelly and R. E. Seviora. </author> <title> An evaluation of DRete on CUPID for OPS5. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <year> 1989. </year>
Reference-contexts: Applying parallelism: For some database rule languages, parallelism in rule condition testing may be necessary to achieve desired levels of performance. Parallelism has been used successfully to increase the performance of the OPS5 rule language both on a shared memory multiprocessor [22] and on a fine-grain parallel machine <ref> [29] </ref>. This work can serve as a starting point for parallel rule condition testing in active databases. 26 Feedback from the initial use of rule processing in large-scale database applications should provide valuable guidance to help researchers and practitioners continue to improve the capabilities of active database systems.
Reference: [30] <author> G. Kiernan, C. de Maindreville, and E. Simon. </author> <title> Making deductive database a practical technology: A step forward. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: The semantic and practical differences between firing single instantiations and firing rules to saturation are explored in RDL1, a production rule implementation of a deductive database system <ref> [12, 30] </ref>. A related modification to the recognize-act cycle is set-oriented firing, in which the selected rule's action is executed once for the entire set of instantiations [21]. Ariel and Starburst both use a form of set-oriented firing; see Sections 4.1 and 4.5.
Reference: [31] <author> A. M. Kotz, K. R. Dittrich, and J. A. Mulle. </author> <title> Supporting semantic rules by a generalized event/trigger mechanism. </title> <booktitle> In Proceedings of the International Conference on Extending Data Base Technology, </booktitle> <month> March </month> <year> 1988. </year>
Reference-contexts: A number of other research projects are not described in detail in this paper, either because the projects are fairly preliminary, because their features do not differ significantly from projects that are covered, or simply for lack of space; these are described in <ref> [3, 10, 15, 31, 37, 39] </ref>. In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3.
Reference: [32] <author> D. R. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1989. </year> <month> 29 </month>
Reference-contexts: A number of powerful prototype systems have been built in the research context, while more limited production rule features are appearing in products and proposed standards. Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC <ref> [9, 11, 32] </ref>, Ode [19], POSTGRES [40, 41], RPL [13], and Starburst [45, 46]. <p> Finally, as mentioned in Section 3.5, HiPAC rules may have relative ordering, and this ordering is used to influence the serialization order of concurrently executing nested sub-transactions. Further details on HiPAC's rule language and rule processing semantics appear in <ref> [9, 11, 32] </ref>. 4.3 Ode As described in Section 3.2, there are two types of rules in Ode, constraint rules and trigger rules, hereafter referred to as constraints and triggers. Constraints and triggers have very different execution semantics, so we describe each in turn. <p> Using this implementation, a simulated financial trading application was coded, with most control of the application embedded in rules. Further details on HiPAC's implementation and applications appear in <ref> [9, 32] </ref>. Rule processing in Ode is built into the implementation of O++, a database programming language extension to C++. For each Ode class, the hard constraints, soft constraints, and triggers defined for that class are packaged into three system-defined methods: hard constraints (), soft constraints () and triggers (). <p> Initial experimentation with such applications has been performed in the context of HiPAC <ref> [32] </ref>, and the commercial Ingres system includes rule processing facilities and a mechanism for "asynchronous multicast" that make such applications possible in practice [2].
Reference: [33] <author> D. P. Miranker. </author> <title> TREAT: A better match algorithm for AI production systems. </title> <booktitle> In Proceedings of the AAAI Conference on Artificial Intelligence, </booktitle> <month> August </month> <year> 1987. </year>
Reference-contexts: Further details appear in [24, 25]. Ariel's condition testing mechanism uses an algorithm called A-TREAT, which is a descendent of the TREAT algorithm used in some main-memory production rule systems <ref> [33] </ref>. 21 TREAT itself is a descendant of the pioneering Rete algorithm [18], developed for OPS5. These algorithms use discrimination networks to efficiently compare large collections of patterns to large collections of data without iterating over the collections. Tokens representing modified data items are passed through the networks. <p> An advantage of the Rete algorithm is its ability to reuse temporary results; a disadvantage is its need to maintain and store the contents of fi-memory nodes. The TREAT algorithm eliminates the use of fi-memory nodes; for details see <ref> [33] </ref>. A simulation study has shown that TREAT can be expected to perform better than Rete in the context of database rule systems [44]. TREAT has also been shown to outperform Rete for a collection of OPS5 applications [33], although Rete can perform better in certain situations. <p> The TREAT algorithm eliminates the use of fi-memory nodes; for details see <ref> [33] </ref>. A simulation study has shown that TREAT can be expected to perform better than Rete in the context of database rule systems [44]. TREAT has also been shown to outperform Rete for a collection of OPS5 applications [33], although Rete can perform better in certain situations. Ariel's A-TREAT algorithm is designed to both speed up rule processing in a database environment and reduce the storage requirements of TREAT. An important performance optimization in A-TREAT is a top-level discrimination network for testing single-table selection conditions.
Reference: [34] <author> M. Morgenstern. </author> <title> Active databases as a paradigm for enhanced computing environments. </title> <booktitle> In Proceedings of the Ninth International Conference on Very Large Data Bases, </booktitle> <month> October </month> <year> 1983. </year>
Reference-contexts: Database researchers have observed for some time that if a database system also provides mechanisms for creating and processing production rules (also referred to in this context as triggers or alerters), then the database system becomes active, and many useful capabilities can be provided by this active behavior <ref> [17, 34] </ref>. The production rule paradigm originated in the field of Artificial Intelligence (AI) with expert systems rule languages such as OPS5 [4].
Reference: [35] <author> E. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: Rather than selecting one triggered rule to execute using some form of conflict resolution, HiPAC executes all triggered rules concurrently. If, during rule execution, additional rules are triggered, they also are executed concurrently. To do this, HiPAC uses an extension of the nested transaction model of execution <ref> [35] </ref>, which lends itself well to this rule processing semantics and to the realization of coupling modes. The basic rule processing algorithm in HiPAC is described as follows: 1. Some (user- or rule-generated) event triggers rules R 1 , R 2 , : : : , R n 14 2.
Reference: [36] <author> ORACLE Corporaton. </author> <title> ORACLE7 Reference Manual, </title> <year> 1992. </year>
Reference-contexts: In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle <ref> [36] </ref>, Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3. Products and standards are not covered in this paper since their capabilities are subsumed by research projects that are covered.
Reference: [37] <author> U. Schreier, H. Pirahesh, R. Agrawal, and C. Mohan. Alert: </author> <title> An architecture for transforming a passive DBMS into an active DBMS. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: A number of other research projects are not described in detail in this paper, either because the projects are fairly preliminary, because their features do not differ significantly from projects that are covered, or simply for lack of space; these are described in <ref> [3, 10, 15, 31, 37, 39] </ref>. In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3. <p> Coupling modes originated in the HiPAC project but subsequently have been discussed in the context of other active database systems, e.g. <ref> [19, 37] </ref>.
Reference: [38] <author> T. Sellis, C.-C. Lin, and L. Raschid. </author> <title> Implementing large production systems in a DBMS environment: </title> <booktitle> Concepts and algorithms. In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: The production rule paradigm originated in the field of Artificial Intelligence (AI) with expert systems rule languages such as OPS5 [4]. While some work has been done on using database systems to provide efficient underlying support for OPS5 (e.g. <ref> [38, 42] </ref>), in this paper we focus on database systems with fully integrated production rules facilities, often referred to as active database systems.
Reference: [39] <author> E. Simon, J. Kiernan, and C. de Maindreville. </author> <title> Implementing high-level active rules on top of relational databases. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Data Bases, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: A number of other research projects are not described in detail in this paper, either because the projects are fairly preliminary, because their features do not differ significantly from projects that are covered, or simply for lack of space; these are described in <ref> [3, 10, 15, 31, 37, 39] </ref>. In the commercial 2 realm, some production rule capabilities are provided in Ingres [2], InterBase, Oracle [36], Rdb [16], and Sybase [28]. Finally, very simple rule capabilities have been incorporated into the SQL2 standard, while somewhat more general capabilities have been proposed for SQL3.
Reference: [40] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in data base systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC [9, 11, 32], Ode [19], POSTGRES <ref> [40, 41] </ref>, RPL [13], and Starburst [45, 46]. <p> There is no conflict resolution mechanism in POSTGRES|triggered rules are executed in arbitrary order. If rollback is executed in a rule action, then rule processing terminates and the transaction is aborted. Further details on POSTGRES's rule language and rule processing semantics appear in <ref> [40, 41] </ref>. 16 As a simple example of the difference between tuple-oriented and set-oriented rule pro- cessing in relational systems, consider the following rule: define rule SetSalary on insert to employee then begin starting-salary := (select avg (salary) from employee) 10 ; update employee (salary = starting-salary) where employee.id = new.id <p> However, when applicable, the "compile-time" approach of query rewrite can be considerably more efficient than the "run-time" approach of tuple level processing. Unfortunately, the semantics can differ between the two approaches, as explained in [41]. Further details on the implementation of rules in POSTGRES appear in <ref> [40, 41] </ref>. The Starburst DBMS has as one of its primary goals extensibility [23], and the rule system implementation relies on Starburst's extensibility features. The attachment feature is used to monitor data modifications that are of interest to rules.
Reference: [41] <author> M. Stonebraker and G. Kemnitz. </author> <title> The POSTGRES next-generation database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 78-92, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC [9, 11, 32], Ode [19], POSTGRES <ref> [40, 41] </ref>, RPL [13], and Starburst [45, 46]. <p> There is no conflict resolution mechanism in POSTGRES|triggered rules are executed in arbitrary order. If rollback is executed in a rule action, then rule processing terminates and the transaction is aborted. Further details on POSTGRES's rule language and rule processing semantics appear in <ref> [40, 41] </ref>. 16 As a simple example of the difference between tuple-oriented and set-oriented rule pro- cessing in relational systems, consider the following rule: define rule SetSalary on insert to employee then begin starting-salary := (select avg (salary) from employee) 10 ; update employee (salary = starting-salary) where employee.id = new.id <p> However, when applicable, the "compile-time" approach of query rewrite can be considerably more efficient than the "run-time" approach of tuple level processing. Unfortunately, the semantics can differ between the two approaches, as explained in <ref> [41] </ref>. Further details on the implementation of rules in POSTGRES appear in [40, 41]. The Starburst DBMS has as one of its primary goals extensibility [23], and the rule system implementation relies on Starburst's extensibility features. <p> However, when applicable, the "compile-time" approach of query rewrite can be considerably more efficient than the "run-time" approach of tuple level processing. Unfortunately, the semantics can differ between the two approaches, as explained in [41]. Further details on the implementation of rules in POSTGRES appear in <ref> [40, 41] </ref>. The Starburst DBMS has as one of its primary goals extensibility [23], and the rule system implementation relies on Starburst's extensibility features. The attachment feature is used to monitor data modifications that are of interest to rules.
Reference: [42] <author> A. Tzvieli. </author> <title> On the coupling of a production system shell and a DBMS. </title> <booktitle> In Proceedings of the Third International Conference on Data and Knowledge Bases, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: The production rule paradigm originated in the field of Artificial Intelligence (AI) with expert systems rule languages such as OPS5 [4]. While some work has been done on using database systems to provide efficient underlying support for OPS5 (e.g. <ref> [38, 42] </ref>), in this paper we focus on database systems with fully integrated production rules facilities, often referred to as active database systems.
Reference: [43] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes I and II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1989. </year>
Reference-contexts: We focus on active database systems and do not cover deductive database systems here. Readers interested in deductive database systems can consult the extensive literature on the subject, e.g. <ref> [6, 43] </ref>. This paper provides a broad survey of current work in active database systems, covering general issues and concepts as well as describing the several research projects mentioned above. (As a default, the Ariel system is used for illustrative purposes when appropriate.) The paper is organized as follows. <p> As a default, we consider relational systems when the distinction is unimportant. In the remainder of this section we briefly introduce basic concepts and terminology for relational and object-oriented database systems. For further details see, e.g. <ref> [43] </ref>. In a relational database system, all data is stored in tables (or relations). Associated with each table is a fixed number of columns (or attributes). <p> A database rule may generate an error during its execution for a number of reasons|e.g., because data it depends on (such as a table) has been deleted, because data access privileges have been revoked, because concurrently executing transactions have created a deadlock <ref> [43] </ref>, because of a system-generated error, or because the rule action itself has uncovered an error condition. Errors such as missing data or revoked privileges can usually be avoided in any database system with a sophisticated enough dependency-tracking facility.
Reference: [44] <author> Y.-W. Wang and E. N. Hanson. </author> <title> A performance comparison of the Rete and TREAT algorithms for testing database rule conditions. </title> <booktitle> In Proceedings of the Eighth International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: The TREAT algorithm eliminates the use of fi-memory nodes; for details see [33]. A simulation study has shown that TREAT can be expected to perform better than Rete in the context of database rule systems <ref> [44] </ref>. TREAT has also been shown to outperform Rete for a collection of OPS5 applications [33], although Rete can perform better in certain situations. Ariel's A-TREAT algorithm is designed to both speed up rule processing in a database environment and reduce the storage requirements of TREAT.
Reference: [45] <author> J. Widom, R. J. Cochrane, and B. G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC [9, 11, 32], Ode [19], POSTGRES [40, 41], RPL [13], and Starburst <ref> [45, 46] </ref>. <p> As usual, if rollback is executed in a rule action, then rule processing terminates and the transaction is aborted. Further details on Starburst's rule language and rule processing semantics appear in <ref> [45, 46] </ref>. 4.6 Error Recovery One issue not yet fully addressed in many active database systems is the semantics of error recovery during rule processing. <p> The Starburst rule system also includes components for concurrency control, authorization, and crash recovery. Further details on the implementation of rules in Starburst appear in <ref> [45] </ref>. While there are three different implementations of HiPAC|one in C, one in Smalltalk-80, and one in Lisp|all are main-memory prototypes not fully integrated with a conventional DBMS. The most substantial of these is the Smalltalk implementation, which includes both a rule manager and a transaction manager.
Reference: [46] <author> J. Widom and S. J. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1990. </year> <month> 30 </month>
Reference-contexts: Important research projects, all of which are described in this paper to some extent, include (alphabetically) Ariel [24], HiPAC [9, 11, 32], Ode [19], POSTGRES [40, 41], RPL [13], and Starburst <ref> [45, 46] </ref>. <p> As usual, if rollback is executed in a rule action, then rule processing terminates and the transaction is aborted. Further details on Starburst's rule language and rule processing semantics appear in <ref> [45, 46] </ref>. 4.6 Error Recovery One issue not yet fully addressed in many active database systems is the semantics of error recovery during rule processing.
References-found: 46

