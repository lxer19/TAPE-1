URL: http://www.cs.cornell.edu/Info/People/mhr/papers/certificates.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/mhr/project.html
Root-URL: 
Phone: 2  
Title: Certificates and Fast Algorithms for Biconnectivity in Fully-Dynamic Graphs m) amortized time, and solves the
Author: Monika R. Henzinger and Han La Poutre 
Note: O(  as stated in [2].  
Address: Ithaca, NY 14853, USA.  Netherlands.  
Affiliation: 1 Department of Computer Science, Cornell University,  Department of Computer Science, Utrecht University, Utrecht, The  
Abstract: In this paper, we present sparse certificates for biconnec-tivity together with algorithms for updating these certificates. We thus obtain fully-dynamic algorithms for biconnectivity in graphs that run in O( n log n logd m n e) amortized time per operation, where m is the number of edges and n is the number of nodes in the graph. This improves upon the results in [11], in which algorithms were presented running in 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Cheriyan and R. Thurimella, </author> <title> "Algorithms for parallel k-vertex connectivity and sparse certificates" Proc. </title> <booktitle> 23rd Annual Symp. on Theory of Computing, </booktitle> <year> 1991, </year> <pages> 391-401. </pages>
Reference-contexts: However, this approach seems not to work for certificates for biconnectiv--ity. Like for many other problems involving k-connectivity, such as designing static, parallel, incremental, or fully-dynamic algorithms, 2-vertex-connectivity appears to be substantially harder to deal with than 2-edge-connectivity. An example of this can also be observed in <ref> [1] </ref>, considering parallel algorithms for k-connectivity, where sparse static certificates for biconnectivity are defined in terms of breadth-first trees, whereas those for 2-edge-connectivity can consist of any kind of spanning trees. <p> Up to now, no efficient fully-dynamic algorithms for maintaining breadth-first trees are known, and it is commonly felt that these trees are hard to maintain indeed. So, designing certificates for fully-dynamic biconnectivity and thus speeding up the fully-dynamic algorithms for it is an appealing open problem <ref> [1, 2, 11] </ref>. In this paper, we present new, sparse certificates for biconnectivity that can efficiently be maintained under insertion and deletion of edges. <p> For a tree T , we denote by T (x; y) the (unique) path between nodes x and y in T . We give some definitions concerning certificates, as occurring in <ref> [1, 2] </ref>. For any graph property P , and graph G, a certificate for G is a graph G 0 such that G has property P if and only if G 0 has property P . <p> A (green) edge of B is converted into a red edge only if it changes the number of components of T b [ G r . This can be done by maintaining the biconnected components dynamically [7, 12], thus yielding an add-on sequence indeed. As was shown in <ref> [1] </ref>, the graph T b [ B is a certificate for biconnectivity, hence, so is T b [ G r . (We do not really need the breadth-first forest, but can do this with all the existing edges once they are ordered as well.) Insertions and Deletions.
Reference: 2. <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> "Sparsification A technique for speeding up dynamic graph algorithms" Proc. </title> <booktitle> 33nd Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 60-69. </pages>
Reference-contexts: minimum spanning trees and the connectivity, 2-edge-connectivity and the 2-vertex-connectivity relations in fully-dynamic graphs were presented that run in O ( p m) time per operation (amortized time for 2-vertex-connectivity). (In this paper, n is the number of nodes and m is the number of edges.) In the meantime, in <ref> [2] </ref>, the concept of certificates and sparsification trees (for definitions, see Section 2) was introduced to speed up several fully-dynamic graph algorithms. <p> Up to now, no efficient fully-dynamic algorithms for maintaining breadth-first trees are known, and it is commonly felt that these trees are hard to maintain indeed. So, designing certificates for fully-dynamic biconnectivity and thus speeding up the fully-dynamic algorithms for it is an appealing open problem <ref> [1, 2, 11] </ref>. In this paper, we present new, sparse certificates for biconnectivity that can efficiently be maintained under insertion and deletion of edges. <p> We introduce sparse certificates that are determined in a relaxed, history-dependent way, and that thus are not defined in a more mathematical, "static" way, like in <ref> [2] </ref>. In particular, the certificates we use are not "stable", as defined and used throughout in [2] (see also Definition 1). Also, we develop extensions of the algorithms that must be speeded up themselves [11] as well, to be able to maintain the certificates. <p> We introduce sparse certificates that are determined in a relaxed, history-dependent way, and that thus are not defined in a more mathematical, "static" way, like in <ref> [2] </ref>. In particular, the certificates we use are not "stable", as defined and used throughout in [2] (see also Definition 1). Also, we develop extensions of the algorithms that must be speeded up themselves [11] as well, to be able to maintain the certificates. <p> For a tree T , we denote by T (x; y) the (unique) path between nodes x and y in T . We give some definitions concerning certificates, as occurring in <ref> [1, 2] </ref>. For any graph property P , and graph G, a certificate for G is a graph G 0 such that G has property P if and only if G 0 has property P . <p> A property is said to have sparse certificates if there is some constant c such that for every graph G on an n-vertex set, we can find a strong certificate for G with at most cn edges. In <ref> [2] </ref>, some sparse certificates are given for k-edge-connectivity, minimum spanning trees, and bipartiteness, all depending on the data structures for minimum spanning trees presented by Frederickson [4, 5]. Also, the concept of stable certificate is defined, which is important for the use of certificates in sparsifica-tion trees, as follows. <p> However, for fully-dynamic biconnectivity, this definition seems to be too strict. Amongst others, it supposes that for each graph, a (unique) certificate can be chosen, which then has to be maintained by the dynamic algorithms with only O (1) changes (see <ref> [2] </ref>). We seem to need a more liberal concept of certification. 2.1 Sparsification tree We sketch how certificates can be used in sparsification trees [2] to maintain a property P . Our final strategies will be somewhat different, though. As in [2], maintain a partition of the graph edges in d <p> that for each graph, a (unique) certificate can be chosen, which then has to be maintained by the dynamic algorithms with only O (1) changes (see <ref> [2] </ref>). We seem to need a more liberal concept of certification. 2.1 Sparsification tree We sketch how certificates can be used in sparsification trees [2] to maintain a property P . Our final strategies will be somewhat different, though. As in [2], maintain a partition of the graph edges in d m n e groups, all but one containing exactly n edges. The remaining group is called the small group. <p> the dynamic algorithms with only O (1) changes (see <ref> [2] </ref>). We seem to need a more liberal concept of certification. 2.1 Sparsification tree We sketch how certificates can be used in sparsification trees [2] to maintain a property P . Our final strategies will be somewhat different, though. As in [2], maintain a partition of the graph edges in d m n e groups, all but one containing exactly n edges. The remaining group is called the small group. Insertion of an edge in the graph is always done in the small group. <p> The certificate C (x) is found and maintained in S (x). Thus, the certificate at the root is the certificate of the whole graph. For further details and elaboration, we refer to <ref> [2] </ref>. 3 Certificates for biconnectivity In this section, we present sparse certificates for biconnectivity together with algorithms for updating these certificates, and handling sparsification trees. 3.1 Monotone sparse certificates and their maintenance Consider a graph G of n nodes.
Reference: 3. <author> D. Eppstein, Z. Galil, G. F. Italiano, and T. Spencer. </author> <title> "Separator based sparsifica-tion for dynamic planar graph algorithms". </title> <booktitle> Proc. 25th Annual Symp. on Theory of Computing, </booktitle> <year> 1993, </year> <pages> 208-217. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>.
Reference: 4. <author> G. N. Frederickson, </author> <title> "Data Structures for On-line Updating of Minimum Spanning Trees" SIAM J. </title> <journal> Comput. </journal> <volume> 14 (1985), </volume> <pages> 781-798. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>. <p> In <ref> [4, 5, 11] </ref>, algorithms for maintaining minimum spanning trees and the connectivity, 2-edge-connectivity and the 2-vertex-connectivity relations in fully-dynamic graphs were presented that run in O ( p m) time per operation (amortized time for 2-vertex-connectivity). (In this paper, n is the number of nodes and m is the number of <p> In particular, sparse certificates could be used for speeding up fully-dynamic algorithms for maintaining minimum spanning trees and the connectivity and 2-edge-connectivity relations in graphs <ref> [4, 5] </ref>, to O ( p n) time per operation. Basically, these sparse certificates were defined in terms of (successive, minimum) spanning trees, and were main tained by applying Fredericksons minimum spanning trees data structure [4]. <p> Basically, these sparse certificates were defined in terms of (successive, minimum) spanning trees, and were main tained by applying Fredericksons minimum spanning trees data structure <ref> [4] </ref>. The algorithm to be speeded up was thus used on the resulting certificate for the whole graph (viz., in the root of the sparsification tree). ? Maiden name: Monika H. Rauch. This research was supported in part by the NSF Career Award 27813. ?? Full name: Johannes A. <p> In [2], some sparse certificates are given for k-edge-connectivity, minimum spanning trees, and bipartiteness, all depending on the data structures for minimum spanning trees presented by Frederickson <ref> [4, 5] </ref>. Also, the concept of stable certificate is defined, which is important for the use of certificates in sparsifica-tion trees, as follows. Definition 1 Let A be a function mapping graphs to strong certificates. Then A is stable if it has the following properties: 1. <p> To determine which edges change colour, as described above, we use the following dynamic data structures, which allow deletions, restricted insertions, and colour changes of edges as described above. 1. We keep the graph T b [ G r in a dynamic minimum spanning tree data struc-ture of Frederickson <ref> [4] </ref> with all blue edges having cost 0. Whenever a blue edge is deleted, this data structure provides us with the minimum cost red edge. This edge becomes blue. 2. We keep T b [ G r in a dynamic biconnectivity data structure of Rauch [11].
Reference: 5. <author> G. N. Frederickson, </author> <title> "Ambivalent Data Structures for Dynamic 2-edge-connectivity and k smallest spanning trees" Proc. </title> <booktitle> 32nd Annual IEEE Symp. </booktitle> <institution> on Foundation of Comput. Sci., </institution> <year> 1991, </year> <pages> 632-641. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>. <p> In <ref> [4, 5, 11] </ref>, algorithms for maintaining minimum spanning trees and the connectivity, 2-edge-connectivity and the 2-vertex-connectivity relations in fully-dynamic graphs were presented that run in O ( p m) time per operation (amortized time for 2-vertex-connectivity). (In this paper, n is the number of nodes and m is the number of <p> In particular, sparse certificates could be used for speeding up fully-dynamic algorithms for maintaining minimum spanning trees and the connectivity and 2-edge-connectivity relations in graphs <ref> [4, 5] </ref>, to O ( p n) time per operation. Basically, these sparse certificates were defined in terms of (successive, minimum) spanning trees, and were main tained by applying Fredericksons minimum spanning trees data structure [4]. <p> In [2], some sparse certificates are given for k-edge-connectivity, minimum spanning trees, and bipartiteness, all depending on the data structures for minimum spanning trees presented by Frederickson <ref> [4, 5] </ref>. Also, the concept of stable certificate is defined, which is important for the use of certificates in sparsifica-tion trees, as follows. Definition 1 Let A be a function mapping graphs to strong certificates. Then A is stable if it has the following properties: 1. <p> No two adjacent clusters can be combined and still satisfy 1 to 3. The partition splits G into O (m=k) clusters of size k and is found in time O (m+n) <ref> [5] </ref>. We denote by C (x) a cluster containing a representative of a vertex x and say that C (x) contains x. If the representatives of x are contained in &gt; 1 clusters, then x is a shared vertex and all clusters C (x) are called x-clusters and share x.
Reference: 6. <author> M.H. Rauch Henzinger and V. King, </author> <title> "Randomized Dynamic Graph Algorithms with Polylogarithmic Time per Operation" Proc. </title> <booktitle> 27th Annual Symp. on Theory of Computing, </booktitle> <year> 1995, </year> <pages> 519-527. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>.
Reference: 7. <author> J.A. La Poutre, </author> <title> "Dynamic Graph Algorithms and Data Structures" Ph.D. </title> <type> Thesis, </type> <institution> Utrecht University, </institution> <year> 1991. </year>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>. <p> A (green) edge of B is converted into a red edge only if it changes the number of components of T b [ G r . This can be done by maintaining the biconnected components dynamically <ref> [7, 12] </ref>, thus yielding an add-on sequence indeed.
Reference: 8. <author> J.A. La Poutre, </author> <title> "Alpha-Algorithms for Incremental Planarity Testing" Proc. </title> <booktitle> 26 Annual Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> 706-715. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>.
Reference: 9. <author> J.A. La Poutre and J. Westbrook, </author> <title> "Dynamic Two-Connectivity with Backtracking" Proc. </title> <booktitle> 5 th Annual ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> 204-212. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>.
Reference: 10. <author> M. H. Rauch. </author> <title> "Fully Dynamic Biconnectivity in Graphs" Proc. </title> <booktitle> 33nd Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 50-59. </pages>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>.
Reference: 11. <author> M. H. Rauch. </author> <title> "Improved Data Structures for Fully Dynamic Biconnectivity" Proc. </title> <booktitle> 26 Annual Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> 686-695. </pages> <note> An improved version is published as Technical Report 94-1412, </note> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY. </address>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>. <p> In <ref> [4, 5, 11] </ref>, algorithms for maintaining minimum spanning trees and the connectivity, 2-edge-connectivity and the 2-vertex-connectivity relations in fully-dynamic graphs were presented that run in O ( p m) time per operation (amortized time for 2-vertex-connectivity). (In this paper, n is the number of nodes and m is the number of <p> Up to now, no efficient fully-dynamic algorithms for maintaining breadth-first trees are known, and it is commonly felt that these trees are hard to maintain indeed. So, designing certificates for fully-dynamic biconnectivity and thus speeding up the fully-dynamic algorithms for it is an appealing open problem <ref> [1, 2, 11] </ref>. In this paper, we present new, sparse certificates for biconnectivity that can efficiently be maintained under insertion and deletion of edges. <p> In particular, the certificates we use are not "stable", as defined and used throughout in [2] (see also Definition 1). Also, we develop extensions of the algorithms that must be speeded up themselves <ref> [11] </ref> as well, to be able to maintain the certificates. Thus, our approach also appears to be the first combination of certificates and maintenance algorithms that also uses the algo rithm that must be "speeded up" itself to maintain the certificates, and not just Fredericksons minimum spanning tree algorithms. <p> Whenever a blue edge is deleted, this data structure provides us with the minimum cost red edge. This edge becomes blue. 2. We keep T b [ G r in a dynamic biconnectivity data structure of Rauch <ref> [11] </ref>. Whenever a blue or red edge is deleted, this data structure provides us with the new potential articulation points generated one at a time, in time proportional to the number of actually generated potential articulation points. 3. We keep G in a dynamic biconnectivity data structure of Rauch [11]. <p> Rauch <ref> [11] </ref>. Whenever a blue or red edge is deleted, this data structure provides us with the new potential articulation points generated one at a time, in time proportional to the number of actually generated potential articulation points. 3. We keep G in a dynamic biconnectivity data structure of Rauch [11]. This allows to test for every new potential articulation point a of T b [ G r whether it is also an articulation point of G. If not, some green edge (x; y) such that a 2 T b (x; y) should become red, as above. 4. <p> If not, some green edge (x; y) such that a 2 T b (x; y) should become red, as above. 4. We keep a replacement data structure that provides such a green edge. It is described in the next section. By <ref> [11] </ref>, the operations on the data structures 1 and 2 can be performed in O ( n) time per returned edge or node, since T b [ G r has O (n) edges, and the operations on data structure 3 can be performed in O ( p m) time, while the <p> Thus, the certificate C (G) for G is given by C (root) [ Y , i.e., the certificate related to the root, joined with the existing yellow edges in the yellow delay set. This obviously is a sparse certificate again. We run the biconnectivity algorithms of <ref> [11] </ref> on this for maintaining C (G) and for computing the queries asked. Lemma 6 Let x be a node of the sparsification tree. <p> Finally, each insertion of an edge is now charged for O (log m n ) amortized operations in total, by the delay-build/rebuild strategy. Each such certificate operation takes O ( p since the occurring graphs have O (n) edges, and by <ref> [11] </ref> and Theorem 9. Adding up the number of certificate operations and using [11], yields the theorem. ut 4 The replacement data structure In this section, we describe the replacement data structure, as mentioned in Subsection 3.1. <p> Each such certificate operation takes O ( p since the occurring graphs have O (n) edges, and by <ref> [11] </ref> and Theorem 9. Adding up the number of certificate operations and using [11], yields the theorem. ut 4 The replacement data structure In this section, we describe the replacement data structure, as mentioned in Subsection 3.1. <p> We naturally expand T b to be a spanning tree of the expanded graph G 0 (where all dashed edges thus are in T b ). We decompose G 0 as in <ref> [11] </ref>. A cluster is a set of vertices that induces a connected subgraph of T . An edge is incident to a cluster if exactly one of its endpoints is in the cluster. <p> The blue edges form a spanning tree of H and of H br . Two clusters that are adjacent in this spanning tree are called tree neighbours. 4.2 Outline of the data structure We maintain both H and H br dynamically in the high-level data structure of <ref> [11] </ref>. For a graph H 0 (with H 0 either H or H br ), the high-level data structure of [11] maintains for each cluster C in H 0 the following graph H 0 (C): H 0 (C) contains a node for each tree neighbour of C. <p> are adjacent in this spanning tree are called tree neighbours. 4.2 Outline of the data structure We maintain both H and H br dynamically in the high-level data structure of <ref> [11] </ref>. For a graph H 0 (with H 0 either H or H br ), the high-level data structure of [11] maintains for each cluster C in H 0 the following graph H 0 (C): H 0 (C) contains a node for each tree neighbour of C. <p> There is an edge between two tree neighbours L 1 and L 2 of C iff there is an edge in H 0 n C between the subtree containing L 1 and the subtree containing L 2 . The data structure in <ref> [11] </ref> can be extended to label an edge (L 1 ; L 2 ) in H 0 (C) with an edge in H 0 n C connecting the subtree of L 1 with the subtree of L 2 . As shown in [11], all graphs H 0 (C) can be maintained <p> The data structure in <ref> [11] </ref> can be extended to label an edge (L 1 ; L 2 ) in H 0 (C) with an edge in H 0 n C connecting the subtree of L 1 with the subtree of L 2 . As shown in [11], all graphs H 0 (C) can be maintained in time O (k + m=k) per edge insertion in G or edge deletion in G. Augmenting the data structure to label edges of H 0 (C) with edges of H 0 does not increase the running time. <p> To distinguish them from the others, we call all shared vertices that are not new, old. In the next subsections, we will describe how we find a green covering edge for different types of candidates. Again, we have the high-level data structures of <ref> [11] </ref> as the base, but we modify and extend it. We will consider a candidate a, where b 1 and b 2 are the neighbours of a on (u; v). <p> The data structure consists of two shared graphs, G 1 (a) and G 2 (a). (They correspond to G (a) and ~ G (a) in <ref> [11] </ref>.) We maintain the minimum spanning tree of G 1 (a) dynamically and we build G 2 (a) whenever a is a candidate. Basically, G 1 (a) corresponds to G (a) n a with some edges between cluster--nodes missing. <p> Thus, some cluster-nodes are not connected in G 1 (a), even though they are connected in G (a) n a. To "add" the missing edges, we build the graph G 2 (a) whenever we answer a query. The data structure and algorithms basically follow ideas from <ref> [11] </ref>.
Reference: 12. <author> J. Westbrook, R. E. Tarjan, </author> <title> "Maintaining bridge-connected and biconnected components on-line" Algorithmica 7 (1992), 433-464. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Currently, several results exist for incremental and fully-dynamic graph problems, like for maintaining spanning trees, the 2-edge- or the 2-vertex-connected components of a graph, or the planarity of a graph under the insertions and/or deletions of edges and vertices <ref> [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] </ref>. <p> A (green) edge of B is converted into a red edge only if it changes the number of components of T b [ G r . This can be done by maintaining the biconnected components dynamically <ref> [7, 12] </ref>, thus yielding an add-on sequence indeed.
References-found: 12

